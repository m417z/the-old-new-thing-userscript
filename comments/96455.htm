<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (22)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1300495">
				<div id="div-comment-1300495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://Damsteen.nl' rel='external nofollow' class='url'>Sebastiaan D.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300495">
			June 23, 2017 at 7:26 am</a>		</div>

		<p>What happens when many web requests (from your example) complete simultaniously? Then you would have a problem in the task example wouldn&#8217;t you?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2" id="comment-1300565">
				<div id="div-comment-1300565" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300565">
			June 23, 2017 at 2:33 pm</a>		</div>

		<p>Then all tasks will become ready and the thread pool will work through them. If you have one thread pool thread per core, then you are going as fast as possible (since all threads will be at 100% CPU utilization until the work queue is drained).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1300505">
				<div id="div-comment-1300505" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300505">
			June 23, 2017 at 7:49 am</a>		</div>

		<p>This is neat !</p>
<p>But I&#8217;m kind of surprised. I believed that Raymond wasn&#8217;t a C# programmer and didn&#8217;t want to write about C# / .NET ? (according to very old posts)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2 parent" id="comment-1300506">
				<div id="div-comment-1300506" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300506">
			June 23, 2017 at 8:06 am</a>		</div>

		<p>Very old blog post is very old. Have you not heard of CLR Week?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1300515">
				<div id="div-comment-1300515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300515">
			June 23, 2017 at 8:24 am</a>		</div>

		<p>Yes I have. I was under the impression they were exceptionnal, and didn&#8217;t change the &#8220;rule&#8221;.  My bad !</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1300585">
				<div id="div-comment-1300585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300585">
			June 24, 2017 at 3:44 am</a>		</div>

		<p>Even if the customer wasn&#8217;t actually using C#, I for one don&#8217;t want to see all the boilerplate that would be needed to propagate state through an asynchronous network call in C, as it would obscure the point of the post.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1300516">
				<div id="div-comment-1300516" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken in NH</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300516">
			June 23, 2017 at 8:42 am</a>		</div>

		<p>Thank you Raymond. This post will go into my bookmarks. I have had a few <strike>arguments</strike> discussions with colleagues who have misread Stephen Cleary&#8217;s advice to either make it async/await all the way down (and use in appropriate situations) or ConfigureAwait(false) (basically turning tasks into threads). They found it hard to keep tasks from deadlocking and read Cleary&#8217;s post as a justification for their dislike of tasks and async/await.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1300525">
				<div id="div-comment-1300525" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jnm2</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300525">
			June 23, 2017 at 10:00 am</a>		</div>

		<p>Funny that I read this just after reading this article with a jaundiced eye:<br />
<a href="https://ayende.com/blog/178369/a-thread-per-task-keep-the-headache-away" rel="nofollow">https://ayende.com/blog/178369/a-thread-per-task-keep-the-headache-away</a></p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-mngoldeneagle even depth-2" id="comment-1300555">
				<div id="div-comment-1300555" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300555">
			June 23, 2017 at 12:23 pm</a>		</div>

		<p>Reading that post, it sounds like what they need moreso is a custom threadpool that can manage the workflow more efficiently and take priority into account, rather than dedicated threads.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1300625">
				<div id="div-comment-1300625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300625">
			June 25, 2017 at 10:18 am</a>		</div>

		<p>This is a classical case of &#8220;Good advice comes with a rationale so you can tell when it becomes bad advice&#8221;*. The argument for not using explicit threads is that creating millions of short-lived threads is expensive and wasteful. The argument does in no way apply if what you&#8217;re doing is create a handful of long-lived threads for specific scenarios. Doing so is perfectly acceptable and using thread-pool threads for such a scenario would be an abuse of the system. </p>
<p>Now if you still want to use tasks for your long running threads because frankly the API is nicer, you can go and use TaskFactory.StartNew TaskCreationOptions.LongRunning (just be careful with the other parameters you have to pass to that function, it&#8217;s rather tricky to use correctly). </p>
<p>*https://blogs.msdn.microsoft.com/oldnewthing/20091104-00/?p=16153</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1300556">
				<div id="div-comment-1300556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Piotr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300556">
			June 23, 2017 at 1:24 pm</a>		</div>

		<p>is await implemented as I/O Completion Port?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1300566">
				<div id="div-comment-1300566" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300566">
			June 23, 2017 at 5:36 pm</a>		</div>

		<p>await is nothing more than a suspend/resume point in a function; upon waking up it&#8217;ll do the right thing.  In other words, it depends on the actual thing being awaited since it will be the one doing the waking up.  If the thing you are doing is using the IO completion port then yes, if it is dumb and it is not, then no.</p>
<p>Also yes, more so than not, if you stick with things in the CLR/BCL/.NET proper, their awaitable types/methods are most likely using the IO completion port infrastructure under the covers simply by ways of already using what was there before async/wait came into being.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1300575">
				<div id="div-comment-1300575" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua Schaeffer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300575">
			June 24, 2017 at 2:30 am</a>		</div>

		<p>IIRC the Windows 8 thread pool isn&#8217;t used in the .NET Framework but it is used in WinRT which is now used for I/O in .NET Core on Windows 10. The thread creation throttling finally made it possible to run managed code on the same pool without thread explosion during GC. The original .NET Framework thread pool was supposedly forked from the WinXP native pool and all the I/O was written to complete with explicit event handles instead of IOCP packets, meaning it ran like an old dog under stress. How it lasted this long is far beyond me.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1300595">
				<div id="div-comment-1300595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300595">
			June 24, 2017 at 9:06 pm</a>		</div>

		<p>Good to know. I never used it, being lazy and just keeping around enough threads to always service something. Now I never will.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1300666">
				<div id="div-comment-1300666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.wpdev.fr' rel='external nofollow' class='url'>Kevin Gosse</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300666">
			June 26, 2017 at 3:45 am</a>		</div>

		<p>Do you have more information on the subject? Poking around the code of WinRT, the threadpool is clearly just a wrapper to native APIs. However, I can&#8217;t find the same thing on the CoreClr repository&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1300626">
				<div id="div-comment-1300626" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vilx-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300626">
			June 25, 2017 at 12:26 pm</a>		</div>

		<p>I just wonder &#8211; at the end of the day, you still have X items of work that need doing and SOMEONE SOMEWHERE needs to switch between them and schedule CPU time for each of them. What difference does it make if we do this locally via 200 Tasks, or offload it to the kernel in the form of 200 threads? It seems to me that the total amount of work that needs to be done doesn&#8217;t change either way. Why are the Tasks considered more efficient?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1300635">
				<div id="div-comment-1300635" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Csaba Varga</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300635">
			June 25, 2017 at 1:36 pm</a>		</div>

		<p>Threads need memory for their stack, thread-local storage, plus whatever per-thread bookkeeping the OS needs to do. Tasks need memory only to store their current state, which is typically at least an order of magnitude less than what a full-blown thread needs.</p>
<p>Switching between C# tasks is also more efficient since the same thread can just look up what to do next from some internal data structure. Switching between OS threads, on the other hand, requires complex steps like saving and restoring registers and switching memory descriptors, and you also must involve the kernel to do it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt depth-2" id="comment-1300645">
				<div id="div-comment-1300645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300645">
			June 25, 2017 at 7:10 pm</a>		</div>

		<p>Consider task that takes 500ms waiting for network resource and then 500ms to do actual work (common pattern for task like reading database from network and do computations and return result. More often the wait itself is longer than the work itself on busy systems), and running on 4 core machine.</p>
<p>In pure ThreadPool based model, the 200 task will offload to 200 Threads which in turn compete for the 4 logical CPU cores available. Total time taken will be around 200 * 1000ms / 4 = 50 seconds.</p>
<p>In Task based model, the thread will be suspended on wait and freeing the CPU to do other works, so when each thread will hit the CPU briefly and put to wait, and then waken when data is ready and can perform CPU intensive tasks. Since time is not wasted when waiting, the overall processing time now becomes a little more than 200 * 500ms / 4 = 25 seconds, (the &#8220;a little more&#8221; part refers to the cost of task switching and the delay on waking out tasks, which is usually very small when compare with the time spent on wait).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1300665">
				<div id="div-comment-1300665" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">samlh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300665">
			June 25, 2017 at 9:34 pm</a>		</div>

		<p>The reason Tasks are more scalable than threads is that they do not need to keep the whole stack around when suspended, they can just store the needed data on the heap (4MB vs (e.g.) 1kb). Also, the tasks are scheduled in user space, and thus can avoid the need to context-switch to the kernel and back.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1300955">
				<div id="div-comment-1300955" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1300955">
			June 29, 2017 at 11:14 am</a>		</div>

		<p>&#8220;The reason Tasks are more scalable than threads is that they do not need to keep the whole stack around when suspended, &#8221;</p>
<p>This only applies to solutions with dedicated threads, not to thread pool solutions. There is no principle difference between C# tasks and using a threadpool (even the C# tasks has to run somewhere in the background =&gt; they use the .Net thread pool).</p>
<p>It all depends on how small the parts are which are put to background execution (assigned to a task or to a thread), and how good eternal operations (i.e. I/O) are made asynchronous (that is, by not putting threads to sleep to wait for the result, but freeing up the thread in the meantime).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1301015">
				<div id="div-comment-1301015" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1301015">
			June 30, 2017 at 4:57 am</a>		</div>

		<p>s/eternal/external/</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1301375">
				<div id="div-comment-1301375" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170623-00/?p=96455#comment-1301375">
			July 5, 2017 at 2:29 am</a>		</div>

		<p>To perform the same over-all work, .NET Tasks are not magically faster than .NET threads. .NET Tasks are executed by the .NET threadpool. If some of your tasks are doing cpu-bound operations which therefore really need a thread for some lengthy time, .NET seems to be somewhat lazy to create additional threads to process other waiting tasks. So, when only ever two threadpool threads are processing a larger number of waiting tasks, this will be slower than using an appropriate number of threads.</p>
<p>.NET does not know in advance how long or short a task will run. The creation of new threadpool threads to process other waiting tasks is bound to some heuristic which may or may not work in favor of your specific case.</p>
<p>(Also: .NET threads are also not the same as OS threads. As far as I understood, in many cases of waiting for something by a .NET synchronization method, the OS thread will be released for reuse by another .NET thread.)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>