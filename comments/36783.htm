<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (53)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-239633">
				<div id="div-comment-239633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SynMan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239633">
			January 6, 2005 at 7:11 am</a>		</div>

		<p>I guess Macros where superceded with inline, templates, constants, RTTI, etc. The only valid use I can think of is some of the maps in MFC (or when you don&#8217;t have advanced C++ functions)<br />
<br />Yours</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239643">
				<div id="div-comment-239643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.dotnetjunkies.com/weblog/sriram' rel='external nofollow' class='url'>Sriram</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239643">
			January 6, 2005 at 7:25 am</a>		</div>

		<p>Raymond -you and Paul Graham will never get along.:-) Have you tried Lisp macros?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239653">
				<div id="div-comment-239653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.dotnetjunkies.com/weblog/sriram' rel='external nofollow' class='url'>Sriram</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239653">
			January 6, 2005 at 7:27 am</a>		</div>

		<p>Also, I&#8217;ve dug through the Rotor sources and they use a lot of macros all over the place &#8211; especially in exception handling,etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239673">
				<div id="div-comment-239673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239673">
			January 6, 2005 at 8:15 am</a>		</div>

		<p>This is an excellent point, but to be honest, I don&#8217;t see this kind of nonsense much any more.  (The Message Map macros in ATL and MFC bother me, though&#8211;they hide too much.)</p>
<p>Obscuring the code flow is bad, but filigree code flows are at least as bad.  It seems most OO programmers have forgotten the lessons of structured programming, as if the two are incompatible.  Premature returns, breaks, continues, gotos, setjmps/longjmps, exceptions &#8212; sometimes these have their place, but those times are much rarer than most programmers appear to believe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239683">
				<div id="div-comment-239683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Avid Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239683">
			January 6, 2005 at 8:43 am</a>		</div>

		<p>What are you looking at the source code for?<br />
<br />&quot; Pah, source-level debugging! Once the optimizer&#8217;s done with your code source-level debugging is useless.&quot;<br />
<br /><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2004/11/11/255800.aspx" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2004/11/11/255800.aspx</a></p>
<p>Great post!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239703">
				<div id="div-comment-239703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasmusic.com' rel='external nofollow' class='url'>Joshua Schaeffer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239703">
			January 6, 2005 at 9:22 am</a>		</div>

		<p>WHAT?! You just mentioned C#?!?!  How dare you!! This is NOT a .NET blog!!!!!</p>
<p>:-/</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239723">
				<div id="div-comment-239723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://p-nand-q.com' rel='external nofollow' class='url'>Gerson Kurz</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239723">
			January 6, 2005 at 9:50 am</a>		</div>

		<p>ATLBASE.H, #define IMPL_THUNK &#8211; nuff said ;) </p>
<p>A nice use of macros using the same header twice: (yes I can hear you screaming already ;)</p>
<p>step 1: </p>
<p>#ifdef STRINGARRAY_BUILD<br />
<br />    #undef DECLARE_STRING<br />
<br />    #define DECLARE_STRING(__ID,__string)</p>
<p>     { TEXT(#__ID), &amp;__ID },<br />
<br />#else<br />
<br />    #ifdef CREATESTRINGS_BUILD<br />
<br />        #define DECLARE_STRING(__ID,__string)</p>
<p>            LPCTSTR __ID = __string;<br />
<br />    #else<br />
<br />        #define DECLARE_STRING(__ID,__string)</p>
<p>            extern LPCTSTR __ID;<br />
<br />    #endif<br />
<br />#endif</p>
<p>step 2: loadsa DECLARE_STRING macros in header.h</p>
<p>step 3: in header.cpp</p>
<p>#include &quot;header.h&quot;<br />
<br />#define STRINGARRAY_BUILD<br />
<br />#include &quot;header.h&quot;</p>
<p>neat, eh?</p>
<p>On a totally unrelated note, does everyone know the difference between the __TEXT and TEXT macros? No, they are NOT equal. Try:</p>
<p>#define xyz &quot;123&quot;</p>
<p>LPCTSTR a = TEXT(xyz);<br />
<br />LPCTSTR b = __TEXT(xyz);</p>
<p>works fine UNLESS you have UNICODE #defined ;) </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239733">
				<div id="div-comment-239733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Senor Coconut</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239733">
			January 6, 2005 at 9:54 am</a>		</div>

		<p>Do<br />
<br />#define unless(x) if(!(x))<br />
<br />#define until(x) while(!(x))<br />
<br />count?</p>
<p>James Curran: I&#8217;d guess that<br />
<br />#define LOOP while(1) {<br />
<br />#define DONE break;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239743">
				<div id="div-comment-239743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239743">
			January 6, 2005 at 10:31 am</a>		</div>

		<p>Macros are great. My only complaint against them is that nobody has added an extension to swallow up the first { or ; token that comes after the usage of the macro. I use unless() and until() and I also use:</p>
<p>template &lt;class T, unsigned S&gt; char (&amp; lengthof(T (&amp;)[S])) [S];<br />
<br />#define lengthof(x) (sizeof(lengthof(x)))</p>
<p>#define widthof(x) sizeof(x[0])</p>
<p>#define numbits(x) (sizeof(x)*CHAR_BIT)</p>
<p>And now for something even more evil^H^H^H^Huseful: I have this custom build tool that allows me to embed perl code right in the middle of source code and it acts just like PHP or ASP except you generate C/C++ code on the fly instead of HTML.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239753">
				<div id="div-comment-239753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239753">
			January 6, 2005 at 10:36 am</a>		</div>

		<p>Gerson, asdf: Noting of course that your macros aren&#8217;t flow control macros.</p>
<p>Avid Reader: You&#8217;re changing the subject. This is about reading code not stepping through it with a debugger.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239773">
				<div id="div-comment-239773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeproject.com/script/articles/list_articles.asp?userid=152' rel='external nofollow' class='url'>Mike Dunn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239773">
			January 6, 2005 at 11:01 am</a>		</div>

		<p>Raymond: Whatever you do, don&#8217;t look at the sample code in the WMP Format SDK. Example of an evil macro [this will probably come out bad in HTML, but oh well]:</p>
<p>#define CORg(hResult)<br />
<br />    do<br />
<br />        {<br />
<br />        hr = (hResult);<br />
<br />        if (FAILED(hr))<br />
<br />            {<br />
<br />            goto Error;<br />
<br />            }<br />
<br />        }<br />
<br />    while (fFalse)</p>
<p>Note the use of a local variable called &quot;hr&quot; (which must be an HRESULT that you have to declare) and the goto to a specially-named label.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239793">
				<div id="div-comment-239793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jonwis' rel='external nofollow' class='url'>Jon Wiswall</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239793">
			January 6, 2005 at 11:16 am</a>		</div>

		<p>Side note&#8230; RAII kind of moots the original problem you&#8217;re pointing out.  The critical section acquisition should have been performed by a C++ object with a destructor.  If there was </p>
<p>CCriticalSectionLockGrant cs_grant(g_cs);<br />
<br />cs_grant.Acquire();</p>
<p>at the top of the function, one could reasonably assume that the grant would function properly no matter how wierdly control flow ended up progressing.  Flow-control code is ugly at the best of times.  Deeply-nested &quot;if (SUCCEEDED(..)) { if (SUCCEEDED(..)) { } }&quot; statements are just as hard to read and maintain as &quot;linear looking&quot; code with macros.</p>
<p>Compilers and editors nowadays handle long dscriptive identifiers just fine.  If you must use flow-control macros (and some of us do), put what they do right in the name.  My group has, for example, IFNOTNTSUCCESS_EXIT to replace the typical &quot;if (!NT_SUCCESS(status = &#8230;)) return status;&quot; pattern.  Coupled with destructors, the code appears to run in a straight line with appropriate error code handling.  The names of the macros describe exactly what they do.</p>
<p>(Further, not to antagonize Raymond, but perhaps a better source browser is in order if looking up the definitions of macros is too hard.  What happens when you have to go figure out what that Block::DoSomething function did?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239813">
				<div id="div-comment-239813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239813">
			January 6, 2005 at 11:44 am</a>		</div>

		<p>&#8230;I&#8217;m gonna go hide in the corner now.  This code is evil beyond belief.</p>
<p>Vorn</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239823">
				<div id="div-comment-239823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239823">
			January 6, 2005 at 12:47 pm</a>		</div>

		<p>Oh, I forgot about for_each: <a target="_new" href="http://www.nwcpp.org/Meetings/2004/01.html" rel="nofollow">http://www.nwcpp.org/Meetings/2004/01.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239833">
				<div id="div-comment-239833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">autist0r</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239833">
			January 6, 2005 at 1:28 pm</a>		</div>

		<p>If you like macros, look at &lt;a href=&quot;<a target="_new" href="http://www.openssl.org&quot;&gt;OpenSSL&lt;/a&gt;" rel="nofollow"></a><a href="http://www.openssl.org&quot;&gt;OpenSSL&lt;/a&#038;gt" rel="nofollow">http://www.openssl.org&quot;&gt;OpenSSL&lt;/a&#038;gt</a>; code. :p</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239843">
				<div id="div-comment-239843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Swaim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239843">
			January 6, 2005 at 2:29 pm</a>		</div>

		<p>Pro *C anyone?<br />
<br />(It&#8217;s an Oracle precompiler that lets you embed SQL directly in your C/C++ code. It can generate really interesting code if you make a mistake.)</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239853">
				<div id="div-comment-239853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239853">
			January 6, 2005 at 3:08 pm</a>		</div>

		<p>(Yes, the critical section question could be avoided by using a lock object with destructor, but that&#8217;s not my point. Note also that this function temporarily exits the critical section. Most lock objects don&#8217;t support that sort of thing, though it isn&#8217;t usually that hard to add, at the cost of a member variable.) </p>
<p>As a related aside, &quot;Unlock&quot; objects can be useful in this situation too (at the cost of an unnecessary Lock / Unlock if an exceptional code path is taken).  The idea is to unlock in the constructor &amp; re-lock in the destructor.</p>
<p>It suppose it would be less readable to a newcomer than LeaveCriticalSection / EnterCriticalSection though.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239863">
				<div id="div-comment-239863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">K Biel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239863">
			January 6, 2005 at 3:19 pm</a>		</div>

		<p>Raymond,</p>
<p>It seems obvious to me that the macros in the bourne shell code were used to emulate the look of a bourne shell script.  Not that I am recommending this approach, but it doesn&#8217;t really support your point as it is a special case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239873">
				<div id="div-comment-239873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Byron Ellacott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239873">
			January 6, 2005 at 3:45 pm</a>		</div>

		<p>As people pointed out in your rant against exceptions, cleanup code is what try&#8230;finally was introduced to handle. ;)</p>
<p>However, I would agree that functions will generally be easier to understand if they only return at one point, and if that point is at the bottom of the function.</p>
<p>And macros are an excellent way to make code harder to read.  C++ really doesn&#8217;t need to be made harder to read.  Any worse, and it&#8217;d be perl. ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239663">
				<div id="div-comment-239663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.honestillusion.com' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239663">
			January 6, 2005 at 8:02 am</a>		</div>

		<p>Hmmm&#8230; I&#8217;ve been going through that Bourne excerpt, and trying to figure out what the macros stand for.  Here are some of my guesses:</p>
<p>#if _some_compile_indicating_macro<br />
<br />   #define REG register<br />
<br />#else<br />
<br />   #define REG<br />
<br />#endif</p>
<p>#define IF  if(<br />
<br />#define THEN ) {<br />
<br />#define FI }<br />
<br />#define WHILE while (<br />
<br />#define DO ) {<br />
<br />#define OD }<br />
<br />#define ADR(x)  (&amp;(x))</p>
<p>LOOP/POOL throw me, because there seems to be no loop control around them.  My only guess is that there are defined as:<br />
<br />#define LOOP {<br />
<br />#define POOL }<br />
<br />with the intention of putting other flow control before it, ie:<br />
<br />while (x &lt; 100)<br />
<br />LOOP /* etc */ POOL</p>
<p>So, not only are they abusing C to create this &quot;language&quot;, they are even abusing the rules of *that* language!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239883">
				<div id="div-comment-239883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239883">
			January 6, 2005 at 4:16 pm</a>		</div>

		<p>Exceptions aside, there is a HUGE difference between having to lookup what DoSomething does and looking up what those MACROs do.</p>
<p>Here we are talking about flow control.  DoSomething will &quot;do something&quot; and execution will continue at the next line of code.  However, with those MACROS, all bets are off.  You can not make any assumptions about the macros since not only can they have parameter side effects but also flow control side effects.</p>
<p>(Doh, email server down.  I can&#8217;t spell check my babble)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239893">
				<div id="div-comment-239893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239893">
			January 6, 2005 at 4:24 pm</a>		</div>

		<p>Thanks, Tim, for articulating what I inadvisedly left unwritten.</p>
<p>Often you don&#8217;t care what the functions do. You&#8217;re just following the flow of execution trying to answer questions like &quot;Does every code path that executes line X also eventually execute line Y?&quot; or its converse &quot;Is it ever possible to be at line Y without having gone through line X?&quot;  In such cases, you don&#8217;t care what DoSomething does &#8211; as long as it returns.  But if there is a macro that hides flow control, you&#8217;re going to miss stuff.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239903">
				<div id="div-comment-239903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.skrill.org/' rel='external nofollow' class='url'>Scorponok</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239903">
			January 6, 2005 at 4:49 pm</a>		</div>

		<p>&quot;It seems obvious to me that the macros in the bourne shell code were used to emulate the look of a bourne shell script. Not that I am recommending this approach, but it doesn&#8217;t really support your point as it is a special case.&quot;</p>
<p>Isn&#8217;t that a bit of a silly reason to have all the macros? Bourne shell scripting and C/C++ are going to be quite different, so why would you try  to force one to look like the other? It&#8217;ll only end in tears when you suddenly run into something that you can&#8217;t hammer into place like that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239913">
				<div id="div-comment-239913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://thor.prohosting.com/bmm6o' rel='external nofollow' class='url'>Brian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239913">
			January 6, 2005 at 5:00 pm</a>		</div>

		<p>Agreed.  The Bourne shell &quot;script&quot; is more weird and misguided than evil.  It&#8217;s like they were jealous of the people who were writing C compilers in C and wanted to write a Bourne shell  in a Bourne script.  This is the next best thing! (though it&#8217;s a huge gap from best to next best)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239923">
				<div id="div-comment-239923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239923">
			January 6, 2005 at 5:38 pm</a>		</div>

		<p>I think &#8216;assert&#8217; is a useful flow control macro. I&#8217;d argue that MFC and ATL are full of flow control macros that some people find useful, too.</p>
<p>This seems like another of those stupid &quot;you can do anything with macros, therefore they are evil&quot; posts. The same people tend to think things like &quot;goto is evil, except when you use it for X, Y and Z&quot; (where the latter are things they consider idiomatic like handling errors in C programs by jumping to the end of the function), &quot;C++ is bloated and inefficient compared to C&quot; (because they don&#8217;t really understand the code they&#8217;re writing) and &quot;exceptions lead to unmanageable software&quot; (because they&#8217;re generally clueless about the disciplines that exceptions require &#8211; the same people find themselves debugging resource leaks and crashes whilst blaming the diagnostic output).</p>
<p>Guys, newsflash: it&#8217;s just a tool. Use common sense. That C# doesn&#8217;t have an appropriate mechanism for syntactic manipulation is a weakness. That C++ has a dangerous-and-difficult-to-validate mechanism is a different weakness.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239763">
				<div id="div-comment-239763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Pryor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239763">
			January 6, 2005 at 10:42 am</a>		</div>

		<p>Is the primary complaint against control flow macros, or against *poorly named* control flow macros?</p>
<p>For example, I find that the the GLib g_return family of macros tends to clarify function assertion logic.</p>
<p>Compare:</p>
<p>void SomeFunction (void *handle, int arg1, int arg2)<br />
<br />{<br />
<br />    if (handle == null)<br />
<br />        return;<br />
<br />    if (arg1 &lt;= 0 || arg1 &gt; SOME_CONST)<br />
<br />        return;<br />
<br />    if (arg2 == INVALID_ARG)<br />
<br />        return;<br />
<br />    // &#8230;<br />
<br />}</p>
<p>to:</p>
<p>void SomeFunction (void *handle, int arg1, int arg2)<br />
<br />{<br />
<br />    g_return_if_fail (handle == NULL);<br />
<br />    g_return_if_fail (arg1 &lt;= 0 || arg1 &gt; SOME_CONST);<br />
<br />    g_return_if_fail (arg2 == INVALID_ARG);</p>
<p>    // &#8230;<br />
<br />}</p>
<p>As more assertions are added, I find that the macros clarify understanding.</p>
<p>See: <a target="_new" href="http://developer.gnome.org/doc/API/2.0/glib/glib-Warnings-and-Assertions.html#id2797042" rel="nofollow">http://developer.gnome.org/doc/API/2.0/glib/glib-Warnings-and-Assertions.html#id2797042</a></p>
<p>The primary issue is one of naming.  It can be difficult, but it&#8217;s necessary that clear, concise, and *useful* names be used for everything (constants, functions, macros).  A function called DoSomething() is equally unhelpful when debugging, and invocation of member functions or modification of global data can have ramifications that can be as subtle as control-flow macros.  The need to dig through header or source code while debugging isn&#8217;t limited to macros.</p>
<p>As always, the solution is clarity and restraint.  If the macros clarify things, they can be useful, but as the Bourne Shell example shows, they can also be a hindrence.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239933">
				<div id="div-comment-239933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://kentb.blogspot.com' rel='external nofollow' class='url'>Kent Boogaart</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239933">
			January 6, 2005 at 6:55 pm</a>		</div>

		<p>James, the title of the blog entry is &quot;A rant against flow control macros&quot;, not &quot;A rant against macros&quot;. Raymond is not denouncing macros completely &#8211; only their abuse in the area of flow control. Surely you&#8217;re not condoning the sample Bourne shell code?</p>
<p>IMHO, C# doesn&#8217;t need macros. Anything you can do with a macro, you can do by simply coding a helper method or two. The inlining performed by the JIT compliler will generally alleviate any efficiency concerns, provided you know how to help the JIT compiler inline methods.</p>
<p>A few blog entries ago, I asked about the new C++ standard (and thanks for the answer Andreas). I asked this because I&#8217;m interested in what improvements have been made to the language to counter abuse such as that demonstrated in Raymond&#8217;s post.</p>
<p>It&#8217;s frustrating for me, primarily a C# developer, to switch to C++ (as I have currently to write a game) because there are so many pitfalls and language nuances that should be ironed out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239783">
				<div id="div-comment-239783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239783">
			January 6, 2005 at 11:13 am</a>		</div>

		<p>Gerson, I like that example.</p>
<p>I did something sorta-similar in a project I was on several years ago.  It was coded in C, and I had a couple object-like pieces of code that had to be essentially duplicated for two different data types. I ended up using the preprocessor to compile source files multiple times. Something like this (more or less):</p>
<p>#ifdef TYPE_DISCRETE<br />
<br />#  define GLOBAL(x) discrete_##x<br />
<br />   typedef value_type int;<br />
<br />#else<br />
<br />#  define GLOBAL(x) not_discrete_##x<br />
<br />   typedef value_type float;<br />
<br />#endif</p>
<p>And then, globally exported symbols were treated like so:</p>
<p>value_type GLOBAL(read_sensor)()<br />
<br />{<br />
<br />   /* &#8230; logic goes here #ifdef DISCRETE can be used to add special case code to particular instances, if necessary.. */<br />
<br />}</p>
<p>Compiling the same source file with -DDISCRETE and without produced two seperate object modules.</p>
<p>It seemed like a funky hack at first, but it turned out to be pretty easy to explain, worked nicely with our source debugger, and saved an immense amount of time tracking down duplicate bugs in the two code paths.</p>
<p>More to the point of control flow macros, on the same project, I had to implement a state machine from a spec that was written in terms of numbered transitions and messages. I handled that by mapping transitions to a set of macros; and mapped messages to functions. It ended up being relatively easy to conform to the spec since the logic could be matched up quite closely.</p>
<p>C-style Macros have a lot of problems, but they really have their moments&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239963">
				<div id="div-comment-239963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Memet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239963">
			January 6, 2005 at 9:05 pm</a>		</div>

		<p>I would agree with Jonathan Pryor&#8217;s remark about poorly named control flow macros. I for example, have opted to use a project wide TRY/CATCH macros system that hides tedious stuff like propagating exceptions and translating C++ exceptions (internal error reporting system) to COM Errors at interface boundaries.<br />
<br /> It&#8217;s not so complicated, once you look at one function, you&#8217;ve pretty much seen all functions:<br />
<br />METHOD_BEGIN<br />
<br />&#8230;<br />
<br />METHOD_END | METHOD_END_NOTHROW | METHOD_END_COM | METHOD_END_INJECT_STATEMENT(x)</p>
<p> as you might guess, METHOD_END gets used about 98% of the time. Also, the catch doesn&#8217;t return anything, so returns are perfectly visible.</p>
<p> I find that these macros are something that the language just doesn&#8217;t do well: that is &#8216;decorating&#8217; function calls with code. Too often, in big projects, I see something else that infuriates me: random regions of code where hresults/bools/ints are returned from functions, while other places return void with exceptions. The idea, normally, with these macros is that they should be simple and deter programmers from wanting to add their own little version of things each time they have to deal with an error.</p>
<p> What do you guys think? What does Microsoft do for example for &#8216;enforcing&#8217; internal error policies when dealing with big projects?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239993">
				<div id="div-comment-239993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/mgrier' rel='external nofollow' class='url'>Michael Grier [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239993">
			January 6, 2005 at 9:28 pm</a>		</div>

		<p>Well everyone can go ahead and continue sticking their collective heads in the sand w.r.t. exceptions, but it&#8217;s not possible to write reliable general purpose software that uses them for general error control flow.  (Note the two caveats: general purpose software like libraries and platforms, and general error control flow meaning error paths which people expect to recover from as opposed to error paths from which you do not expect to recover.)</p>
<p>So this leaves you with a choice.  Do you prefer to see all the error checking and gotos, and therefore also the quality problem associated with them (bug counts tend to track bytes of code written by humans; abstractions like macros and functions have the desired behavior of decreasing the bugs/bytes-of-source-code) or the convoluted logical evaluation paths that people do to avoid goto and/or macros to help the error control flow paths.</p>
<p>I&#8217;ll counter-rant Raymond, as a person who&#8217;s had to debug a bunch of source code that follows Raymond&#8217;s preferred mode for the past few years, and I&#8217;ll take IFFAILED_EXIT() over the nested ifs (and general lack of error handling) that pervades this source code.</p>
<p>Jon&#8217;s point was good and really central (if not obvious) &#8211; a large part of the problem is the lack of adoption of RAII.  If we could get people to agree to RAII, then we&#8217;re debating whether it&#8217;s better to write:</p>
<p>hr = Foo();<br />
<br />if (SUCCEEDED(hr)) {<br />
<br />   hr = Bar();<br />
<br />   if (SUCCEEDED(hr)) {<br />
<br />      hr = Baz();<br />
<br />   }<br />
<br />}<br />
<br />return hr;</p>
<p>or&#8230;</p>
<p>hr = Foo();<br />
<br />if (FAILED(hr)) goto Exit;<br />
<br />hr = Bar();<br />
<br />if (FAILED(hr)) goto Exit;<br />
<br />hr = Baz();<br />
<br />if (FAILED(hr)) goto Exit;<br />
<br />hr = S_OK;<br />
<br />Exit:<br />
<br />return hr;</p>
<p>or:</p>
<p>IFFAILED_EXIT(Foo());<br />
<br />IFFAILED_EXIT(Bar());<br />
<br />IFFAILED_EXIT(Baz());<br />
<br />Exit:<br />
<br />return hr;</p>
<p>Well, my vote is clear.  The goal that people who are drawn to exceptions like moths to the flame have is the simple straightforward source code.  I wish there was a better approach that didn&#8217;t have the fundamental problems with exceptions, but I&#8217;ll personally take the control flow macros over (a) convoluted control flow like nested ifs or (b) the repeated possibility of mistakes in the error checking logic.</p>
<p>I agree with the earlier poster here &#8211; the real issue at hand is poorly named macros that influence control flow.  The thing I hate about exceptions is that I can&#8217;t see that:</p>
<p>x = Foo(a, b, c);</p>
<p>has like 6 opportunities for exit paths that you can&#8217;t see.  Its apparent simplicity is just a big fat lie.  At least with:</p>
<p>IFFAILED_EXIT(Foo(a, b, c, &amp;x));</p>
<p>(when you know that there aren&#8217;t exceptions in play) there is a single nonlinear (e.g. goto Exit) control flow path here.  Maybe I should have named the macro IFFAILED_GOTO_EXIT()?  I didn&#8217;t feel the extra 5 characters added any value.</p>
<p>To me personally, the really compelling factor that makes the macro usage attractive is that you can build tracing into the infrastructure.  At this point, I consider calling a central function when an error condition is first detected (I tend to call this &quot;origination&quot;) a manditory basic requirement because it means that you can set a breakpoint there in a debugger and often simply diagnose problems which derive from an untested error condition.  If it wasn&#8217;t for this utility, I would tend to agree that the difference between:</p>
<p>IFFAILED_EXIT(Foo(a, b, c, &amp;x));</p>
<p>and</p>
<p>if (FAILED(hr = Foo(a, b, c, &amp;x))) {<br />
<br />    ReportFailurePropagation(hr);<br />
<br />    goto Exit;<br />
<br />}</p>
<p>is a wash.  Except that the visibility/accessibility of the point of the control flow makes people ever so tempted to not use RAII.</p>
<p>(this is one of the reasons I hate people catching and rethrowing exceptions.  There was a point in time when turning on &quot;break on exceptions&quot; in the debugger was useful and you would very often break in only when something interesting was going bad.  Since they&#8217;ve evolved into a generalized communication mechanism, they&#8217;ve stopped being useful to find when&#8230; well&#8230; exceptional situations have occurred.)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240003">
				<div id="div-comment-240003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://kentb.blogspot.com' rel='external nofollow' class='url'>Kent Boogaart</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240003">
			January 6, 2005 at 9:31 pm</a>		</div>

		<p>Absolutely, proper design and code reviews will help to solve that. If you find yourself repeating constructs such as try / catch blocks all over the place then you need to re-think your design. eg. Wrap the invocation in a new method and handle the errors in that method. If you&#8217;re doing the same thing all the time (as using a macro implies) then this is fine.</p>
<p>What I&#8217;m failing to see is why you would possibly want to wrap exception catching up in a macro. Programmers will blindly use the macro, probably without understanding what the macro does. Either that, or they won&#8217;t use it or will write their own. That is exactly Raymond&#8217;s point. The programmer has to go and look at the macro to determine whether it is relevant to their particular context.</p>
<p>You can no longer just look at the code and understand it. You have to go off and look at several different macros, understand each one, keep them all in your head, and then make sense of the whole code segment utilising the macros.</p>
<p>I suppose you could argue that using methods / functions instead of macros yields little difference. You still have to know what each method does. I&#8217;m no C++ expert but I guess one of the major advantages of methods / functions is that they are easier to debug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240013">
				<div id="div-comment-240013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/ryanmy/' rel='external nofollow' class='url'>Ryan Myers [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240013">
			January 6, 2005 at 11:56 pm</a>		</div>

		<p>The legendary Bourne Shell macros are, in fact, made to make the code emulate Algol-68 as much as possible.  Steve Bourne was an Algol fanatic, and he felt that it was a failing of C that a single block construct was used (curly braces) instead of one for each different type of block (case/esac, if/fi, etc.).  The macros, and resulting code, were his little political statement.</p>
<p>Another, not so well known, annoyance about the Bourne Shell code include the fact that it does not use malloc()/free() for memory management, instead directly calling the sbrk() system call and doing its own heap management.</p>
<p>The so-called &quot;Bournegol C&quot; was the inspiration for the modern IOCCC.</p>
<p>Peter van der Linden mentions this and other hilarious/scary historical tidbits in &lt;u&gt;Expert C Programming: Deep C Secrets&lt;/u&gt;.  (If you don&#8217;t know the case where arrays and pointers are NOT equal, btw, you need to pick up this book now.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240023">
				<div id="div-comment-240023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Moi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240023">
			January 7, 2005 at 1:01 am</a>		</div>

		<p>I wonder what Raymond thought of the MFC exception macros. I&#8217;m not brave enough to ask!</p>
<p>Ramond &#8211; just tell your compiler to produce something with the macros expanded. Problem solved.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240033">
				<div id="div-comment-240033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240033">
			January 7, 2005 at 1:07 am</a>		</div>

		<p>If you&#8217;re reading somebody else&#8217;s code, you don&#8217;t want to have to compile it first just to see what it does. (And sending C/C++ code through the preprocessor tends to make it less readable rather than more. Try it.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240043">
				<div id="div-comment-240043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.JCABs-Rumblings.com' rel='external nofollow' class='url'>JCAB</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240043">
			January 7, 2005 at 1:55 am</a>		</div>

		<p>IMHO, the crux of the problem is that many of these macros essentially modify the language you&#8217;re programming in (Bourne Macros being a glaring example of this). So, even if the C++ compiler compiles it just fine, it just is not C++.</p>
<p>This can be a good thing in some cases, for some purposes, your mileage may vary. And you definitely don&#8217;t need macros to make a new language for your C++ compiler (check Boost Spirit, for instance). But I do believe it&#8217;s essential to realize, and advertise that it is not C++ any more, so learning C++ is not enough to be profficient in it.</p>
<p>I recently had to ream a young new programmer for over-using macros (for instance, he used a macro called &quot;Nothing&quot; instead of NULL), for no better reason than he liked the resulting language better. He just didn&#8217;t see (and still doesn&#8217;t see) that the language wasn&#8217;t quite C++ anymore.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239983">
				<div id="div-comment-239983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Memet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-239983">
			January 6, 2005 at 9:13 pm</a>		</div>

		<p>Kent Boogaart: the point of (well designed) control flow macros isn&#8217;t to mimic functions, it&#8217;s to avoid retyping of gramatical constructs over and over for example:<br />
<br />catch( SomeException&amp; e )<br />
<br />{ ReportSomeCriticalError(); }<br />
<br />catch( SomeOtherException&amp; w )<br />
<br />{ WarnUserButDontReportError(); }<br />
<br />catch( &#8230; )<br />
<br />{ ShutdownSystem(); }</p>
<p> With big projects with many programmers onboard, these generally tend to start off as :<br />
<br />catch(&#8230;)<br />
<br />{ /* remember to do something */ }<br />
<br />during initial development, and usually get transfered to:<br />
<br />catch(&#8230;)<br />
<br />{ ShutdownSystem(); }</p>
<p>during the final phases (if you&#8217;re lucky).</p>
<p> I know, people are going to say proper code reviews should solve that, but IMHO a programmer needs all the help the language can muster when dealing with boiler plate code.</p>
<p> Bottom line, IMO, bad code is just bad code. You can abuse pretty much everything if you put your mind to it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240063">
				<div id="div-comment-240063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Petr Kadlec</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240063">
			January 7, 2005 at 5:43 am</a>		</div>

		<p>I hate when macros are used to force the C language to behave as a compiler of some completely unrelated metadata- (or whatever) language. As an example I would consider various macros in Windows DDK, even those MFC message maps, or (which is where I have fought with those for the first time) macros in MS Flight Simulator SDK.</p>
<p>Not only you are forced to learn another language and use it in middle of your C source; there is also a problem when you want to use another programming language. In that case, you have to analyze the macros, understand what they do and then reimplement them in a totally different way in the other language. If the SDK would use either normal language constructs, or a special high-level tool, this would be not a problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240073">
				<div id="div-comment-240073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Moi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240073">
			January 7, 2005 at 5:53 am</a>		</div>

		<blockquote><p>
  Try it</p>
<p>I do. If I&#8217;m looking for a bug, for example, without running the code through a debugger, I find it easier to look at the real code than code with macros in (there&#8217;s no way I could keep every single #define in my head).
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240083">
				<div id="div-comment-240083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240083">
			January 7, 2005 at 6:49 am</a>		</div>

		<p>&quot;just tell your compiler to produce something with the macros expanded. Problem solved. &quot;</p>
<p>It&#8217;s too bad there aren&#8217;t editors that provide ways to do this interactively. Maybe it isn&#8217;t all that useful in most code (or perhaps it would encourage overuse of macros), but the abilty to hit a key and toggle back and forth between editable source and a view with expanded macros could be pretty useful.</p>
<p>&quot;I hate when macros are used to force the C language to behave as a compiler of some completely unrelated metadata- (or whatever) language. &quot;</p>
<p>I dunno. Given the choice between reading through a set of macros to understand a metadata language, versus reading through a custom written metadata compiler, I&#8217;d rather deal with the macros. I&#8217;d also wager that the macro/C-compiler combo is more likely to be robust than a special tool. </p>
<p>&quot;Not only you are forced to learn another language and use it in middle of your C source; &quot;</p>
<p>The Lisp folks (who admittedly have much more powerful macros than C) have had good luck over the years embedding custom languages into Lisp.   To some extent, it makes sense: If you can take tricky logic in your code and map it into a language that more closely matches the problem, that could end up being a more readable solution than a bunch of complex, probably tricky, logic written in C (or Lisp).  Isn&#8217;t that what the whole DSL movement is aiming for?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240163">
				<div id="div-comment-240163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">K Biel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240163">
			January 7, 2005 at 8:22 am</a>		</div>

		<p>Scorponok: &quot;Isn&#8217;t that a bit of a silly reason to have all the macros? Bourne shell scripting and C/C++ are going to be quite different, so why would you try to force one to look like the other? It&#8217;ll only end in tears when you suddenly run into something that you can&#8217;t hammer into place like that.&quot;</p>
<p>I didn&#8217;t say that is was a good idea to make C/C++ look like another language. Instead I was pointing out that the bourne code does not support Raymond&#8217;s point. Rather than obscure or hide the control flow, it actually made it quite explicit, but in the form of a bourne shell script. You and I might look at it and think it ridiculous, but someone who writes shell scripts all day long would recognize it immediately.</p>
<p>Let me state again, I am not endorsing the bourne source code. I was just trying to point out that it does not support Raymond&#8217;s point about how C macros can obscure control flow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240173">
				<div id="div-comment-240173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">K Biel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240173">
			January 7, 2005 at 8:24 am</a>		</div>

		<p>Oops, I meant &quot;flow control&quot; above when my fingers typed &quot;control flow&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240473">
				<div id="div-comment-240473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://andyandy.sprayblogg.no' rel='external nofollow' class='url'>Andreas H&#228;ber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240473">
			January 7, 2005 at 1:51 pm</a>		</div>

		<p>JCAB wrote &quot;I recently had to ream a young new programmer for over-using macros (for instance, he used a macro called &quot;Nothing&quot; instead of NULL), for no better reason than he liked the resulting language better. He just didn&#8217;t see (and still doesn&#8217;t see) that the language wasn&#8217;t quite C++ anymore.&quot;</p>
<p>Actually you are encouraged to just use 0 instead of &quot;#define NULL 0&quot; by Bjarne Strostrup in &quot;The C++ Programming Language&quot; :) (Personally I prefer to use NULL because it makes it easier to read and understand).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240493">
				<div id="div-comment-240493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240493">
			January 7, 2005 at 3:46 pm</a>		</div>

		<p>Anyone still using message crackers from windowsx.h?</p>
<p>switch (msg)  {<br />
<br />   HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);<br />
<br />   HANDLE_MSG(hwnd, WM_PAINT, OnPaint);<br />
<br />   &#8230;<br />
<br />   default: &#8230;<br />
<br />}<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240523">
				<div id="div-comment-240523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Memet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240523">
			January 7, 2005 at 8:20 pm</a>		</div>

		<p>(Sigh, I just lost my entire post, I&#8217;m retyping)</p>
<p>Kent Boogaart:<br />
<br /> The reason why we&#8217;ve opted to use macros across the project is because we wanted a unified exception handling system.<br />
<br /> What that means is that any exception thrown in a particular system should be a well known exception, preferably derived from a base class. So the macros handle either defined program failures, or catch all failures (which generally indicate there was a problem that we didn&#8217;t account for &#8211; which is bad).<br />
<br /> Also, exceptions aren&#8217;t meant to be used as control flow logic, they are meant to interrupt normal flow because something serious has occured.<br />
<br /> A good example is std::map::find() which returns std::map::end() if it can&#8217;t find the required element, it does *not* raise an exception. So it is wrong to compare exceptions to code like this:<br />
<br />hr = SomeOperation();<br />
<br />if( FAILED( hr ) )<br />
<br /> hr = DoSomeOtherOperation();<br />
<br />else<br />
<br /> hr = DoSomethingCool();</p>
<p> Here, we have a clear case of flow control based on the outcome of some function. On the other hand, operations like &#8216;new&#8217; need to be atomic from a syntactic perspective, and not raising an exception when a object fails instantiation is not an option.<br />
<br /> In the same vein, in the project we&#8217;re in, components do not raise exceptions when their output is not something that cannot be recovered from, but when it is they do. And at that point, having a unified exception handling architecture really gives cohesion to the system since now you can log what&#8217;s happening in the app using, for example, a single point of logging in your base exception class.</p>
<p> Michael Grier:<br />
<br /> The problem is not that we are in a blissful state of denial, it&#8217;s that C++ needs exceptions to be robust. C++ classes could not be instantiated properly without exceptions. When that observation sets in, you are faced with either using C++ as an enhanced C syntax compiler, and using COM (or something else) as your object model, or using C++ as an object oriented language and interfacing with COM as you would with any other C API. Even the #import code generates _com_error exceptions when wrapping around COM objects. It&#8217;s just a matter of principle, and for those who want to use C++ as an OOP, then exceptions are the way to go.</p>
<p>(I&#8217;m sure I forgot to say something from what I had originally written, ah well)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240833">
				<div id="div-comment-240833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/mgrier' rel='external nofollow' class='url'>Michael Grier [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240833">
			January 9, 2005 at 9:59 pm</a>		</div>

		<p>Re: memet:</p>
<p>C++ is very useful over C without dragging exceptions into the mix.  Exceptions are an experiment which has gone awry.  They&#8217;re the new snake oil.  They work well in functional languages since there aren&#8217;t side effects to be rolled back.  Even people who believe in RAII are rarely actually prepared to make every possible error control path actually have all the rollback necessary.</p>
<p>The point of the other blog entry Raymond references is that:</p>
<p>a = b + c;</p>
<p>doesn&#8217;t clearly have any control flow when in fact it may have 3 (or 2 more if you consider failures in destructors for temporaries which terminate the application to be control flow).</p>
<p>MUST_SUCCEED(Foo());</p>
<p>is not better.  There&#8217;s some statement of intent but it&#8217;s not clear what the ramifications are.  But then I&#8217;ve also seen this style:</p>
<p>check &lt;&lt; Foo();<br />
<br />check &lt;&lt; Bar();</p>
<p>is that clear either?  No, and for the same reason.  I forget where I saw this but the rationale given by the team was that it&#8217;s an idiom used in their source and when you get used to it, it&#8217;s clear.</p>
<p>My point here at the end is that this actually has nothing to do with the use of macros.  Hidden control flow is bad.  It causes a lot of errors.</p>
<p>If we can agree that all of:</p>
<p>if (FAILED(hr = Foo()) goto Exit;<br />
<br />if (FAILED(hr = Bar()) goto EXit;</p>
<p>and</p>
<p>if (SUCCEEDED(hr = Foo())) {<br />
<br />   hr = Bar();<br />
<br />}<br />
<br />return hr;</p>
<p>and</p>
<p>IF_FAILED_GOTO_EXIT(Foo());<br />
<br />IF_FAILED_GOTO_EXIT(Bar());</p>
<p>are reasonably clear (assuming that the macros do the expected thing&#8230; do you verify that SUCCEEDED() does what you expect?) then we can have a more interesting debate about:</p>
<p>a. How important RAII is<br />
<br />b. When do you split functions vs. nest conditions</p>
<p>I think that RAII is very important and I further think that if you can adopt a reasonable style you can prevent arbitrary new functions created only because the previous style created artificial source bloat and statement nesting.  I like the use of macros because except for the annoying extra text on each source line, you get control flow that looks very much like the &quot;exception-based ideal&quot;.</p>
<p>(I alluded to this but on my team when we started a recent project, we didn&#8217;t mandate use of the error checking macros.  So what happened?  A lot of little error-path-cleanup code snippets occurred which of course didn&#8217;t get all the error paths covered.  Thus we decided to disallow the explicit checks and &quot;goto Exit;&quot;.)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240843">
				<div id="div-comment-240843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-240843">
			January 10, 2005 at 2:01 am</a>		</div>

		<p>Michael Grier: I don&#8217;t consider your IF_FAILED_GOTO_EXIT as a good practice. I guess you&#8217;ve debugged a lot of deep nested ifs, but that&#8217;s also bad practice. Good code shouldn&#8217;t be too nested. If you introduce some coding discipline, you can always do something like</p>
<p>void DoSomething( &#8230;<br />
<br /> if ( cond1 ) return;<br />
<br /> someth1();<br />
<br /> if ( cond2 ) return;<br />
<br /> mainThing</p>
<p>etc. Instead the above code some people would produce two nested ifs, and when the &quot;main thing&quot; has any logic, there are more nestings, and the code is hard to follow. Making &quot;early returns&quot; has also good effect of looking (to me) more like mathematical expression where you first exclude trivial cases.</p>
<p>Very often, when I get the code from somebody else, and rewrite the &quot;multiple nesting&quot; to the above presented principle (anybody knows if there&#8217;s some name for it) I easily discover that the original author didn&#8217;t cover some cases. Multiple ifs make it hard to see uncovered cases. Using a lot of returns stimulates covering all the cases.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-241683">
				<div id="div-comment-241683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Memet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-241683">
			January 10, 2005 at 6:11 pm</a>		</div>

		<p>Micheal: I agree that hidden control flow is evil, but I also think cleanup code shouldn&#8217;t be &#8216;cleanup&#8217; code at all.<br />
<br /> I think we would all agree that duplicate code is the worst evil of all, correct? Well, in an ideal OO world where initialization is aquisition (with all the corrollaries that apply), there should never be &#8216;cleanup code&#8217;. In my opinion, cleanup code can <em>never</em> not be duplicate code. Anything that goes out of scope should &#8216;internally&#8217; do all operations it requires to free its resources (ie. execute its destructor). That has the advantage of localizing functionality. That also has the advantage of providing a language-wise transactional environment where I should not need to know what all possible exit paths are because the owners of the resources clean themselves up.</p>
<p> My favorite example of what I hate is creating an ATL ASP object using the wizard. This is the code that gets generated:<br />
<br />hr = lpContext-&gt;get_Request(&amp;lpRequest);<br />
<br />if(FAILED(hr))<br />
<br />{   lpContext.Release();<br />
<br />    return hr;<br />
<br />}</p>
<p>// Get Response Object Pointer<br />
<br />hr = lpContext-&gt;get_Response(&amp;lpResponse);<br />
<br />if(FAILED(hr))<br />
<br />{   lpContext.Release();<br />
<br />    lpRequest.Release();<br />
<br />    return hr;<br />
<br />}</p>
<p>// Get Server Object Pointer<br />
<br />hr = lpContext-&gt;get_Server(&amp;lpServer);<br />
<br />if(FAILED(hr))<br />
<br />{   lpContext.Release();<br />
<br />    lpRequest.Release();<br />
<br />    lpResponse.Release();<br />
<br />    return hr;<br />
<br />}</p>
<p>// Get Application Object Pointer<br />
<br />hr = lpContext-&gt;get_Application(&amp;lpApplication);<br />
<br />if(FAILED(hr))<br />
<br />{   lpContext.Release();<br />
<br />    lpRequest.Release();<br />
<br />    lpResponse.Release();<br />
<br />    lpServer.Release();<br />
<br />    return hr;<br />
<br />}// ad infinitum</p>
<p>Aside from the fact that the wizard generates object code but still uses functional cleanup (which I find weird), you can&#8217;t seriously be advocating that this (cleanup as required) is good practice, can you?<br />
<br /> With exceptions, and a properly OO model, hidden control flow becomes irrelevant as you don&#8217;t need clean up anyways. It&#8217;s only when you mix and match API and OOP that it becomes tricky, but that brings me back to my original post&#8217;s point.</p>
<p> All in all though, I don&#8217;t mean to drag you into a flame war about OOP and exceptions. My point is just that I personally find that C++ doesn&#8217;t really help you or provide you with tools for dealing with method encapsulation in a way that avoids code duplication, and that was originally why I had said Macros were useful for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-241853">
				<div id="div-comment-241853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Purplet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-241853">
			January 11, 2005 at 6:29 am</a>		</div>

		<p>quote :<br />
<br />Macros are great. My only complaint against them is that nobody has added an extension to swallow up the first { or ; token that comes after the usage of the macro.</p>
<p>#define SOMETHING(A) do { something(A); } while(0)</p>
<p>it swallows the ; and works ok if used in loops, ifs, etc :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-241823">
				<div id="div-comment-241823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul Spendlove</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-241823">
			January 11, 2005 at 5:20 am</a>		</div>

		<p>Michael Greer:<br />
<br />&quot;C++ is very useful over C without dragging exceptions into the mix. Exceptions are an experiment which has gone awry. They&#8217;re the new snake oil. They work well in functional languages since there aren&#8217;t side effects to be rolled back. Even people who believe in RAII are rarely actually prepared to make every possible error control path actually have all the rollback necessary.&quot;</p>
<p>Michael, why not read Bjarne Stroustrup&#8217;s &quot;Appendix E&quot; to the &quot;C++ Programming Language (3rd ed)&quot;? It puts forward the views of the designer of the language on exception safety. It has been freely available on the web for more than 4 years by now. </p>
<p>I think it&#8217;s something you haven&#8217;t read yet. Why? Because you refer to RAII taking effort to implement and involving &quot;rollback&quot;. But RAII is actually quite easy to implement and has *nothing* to do with whether you offer rollback semantics.</p>
<p>As well as defining what RAII actually means in this document, Stroustrup also points out why exceptions were added to C++ &#8211; to deal with errors in object construction. There are alternative ways to deal with such errors (eg by providing a separate error-checked &quot;init()&quot; function). Stroustrup covers the alternatives, and explains why he finds exceptions superior. I find his arguments convincing. You are at liberty to differ, but it&#8217;s surely worth at least checking out what Stroustrup has to say.</p>
<p>RAII is really not hard to do. It generally requires no more than a good reference-counted templated pointer &#8211; such classes are widely and freely available, eg from the boost project. You frequently don&#8217;t need to roll back every single operation, you just need to recover back to some higher level. Generally, simply releasing resources on the way back up the call chain is completely sufficient. When you *do* need to group stuff together in a transaction, you create a transaction object whose destructor rolls back, and give it a scope surrounding the members of the transaction.</p>
<p>In conclusion, if people wish not to use C++ exceptions, it&#8217;s up to them. But if they are going to talk about exceptions in C++ and use terms such as RAII, they&#8217;ll be able to make their points more convincingly if they first read what the designer of the language has to say on the topic. </p>
<p>PS RAII = &quot;Resource Acquisition Is Initialisation&quot;, for those who were wondering.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-370573">
				<div id="div-comment-370573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://engtech.wordpress.com/2006/04/14/w-cc-macros-are-bad/' rel='external nofollow' class='url'>Engineering Technology &raquo; Blog Archive &raquo; Macros are bad.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-370573">
			April 17, 2006 at 2:39 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://engtech.wordpress.com/2006/04/14/w-cc-macros-are-bad/" rel="nofollow">http://engtech.wordpress.com/2006/04/14/w-cc-macros-are-bad/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-455783">
				<div id="div-comment-455783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.livejournal.com/users/omerm/55178.html' rel='external nofollow' class='url'>omerm: QQ</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-455783">
			December 22, 2006 at 9:57 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.livejournal.com/users/omerm/55178.html" rel="nofollow">http://www.livejournal.com/users/omerm/55178.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-455793">
				<div id="div-comment-455793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.ljseek.com/qq_52954724.html' rel='external nofollow' class='url'>QQ by omerm () | LjSEEK.COM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-455793">
			December 22, 2006 at 9:58 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.ljseek.com/qq_52954724.html" rel="nofollow">http://www.ljseek.com/qq_52954724.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-523113">
				<div id="div-comment-523113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jeffhung.net/blog/articles/jeffhung/952/' rel='external nofollow' class='url'>???????????? (2007-07-09) [JeffHung.Blog]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050106-00/?p=36783#comment-523113">
			July 9, 2007 at 11:46 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.jeffhung.net/blog/articles/jeffhung/952/" rel="nofollow">http://www.jeffhung.net/blog/articles/jeffhung/952/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>