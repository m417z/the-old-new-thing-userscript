<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (13)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1015783">
				<div id="div-comment-1015783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Damien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015783">
			October 12, 2012 at 7:08 am</a>		</div>

		<p>I know that there is a cost associated with change, but I still find it difficult to comprehend the attitude of people who discover that they&#39;re doing the &quot;wrong thing&quot;, and then ask &quot;can I carry on doing the wrong thing?&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1015793">
				<div id="div-comment-1015793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SI</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015793">
			October 12, 2012 at 7:18 am</a>		</div>

		<p>I would assume the question was more along the lines of &quot;It seems to work, but if we get weird random crash reports from our customers, could this be a potential source&quot;, since the code in question might already be in released products.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1015803">
				<div id="div-comment-1015803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015803">
			October 12, 2012 at 7:23 am</a>		</div>

		<p>@Damien: This seems smart behavior to me. &nbsp;The customer may be resolving many important questions:</p>
<p>-How urgent is it that I fix this bug, compared to fixing other bugs?</p>
<p>-Is this bug the cause of any outstanding issues?</p>
<p>-Does this bug have any effects which I may be inadvertently relying on?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1015813">
				<div id="div-comment-1015813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">parkrrrr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015813">
			October 12, 2012 at 7:33 am</a>		</div>

		<p>In a modern transmission, all you do is cause undue wear on the synchronizers, which will eventually wear out and make you unable to shift with or without the clutch. I used to shift without a clutch pretty frequently in my &#39;93 Saturn SL1, because the hydraulic clutch had a small leak somewhere, so it tended to lose fluid over time and just randomly stop working. (A better workaround for this condition was to keep a new bottle of brake fluid in the car, but I wasn&#39;t very good about remembering to replace it after I used it.)</p>
<p>What happens from the user point of view is that you just can&#39;t shift into the desired gear until you hit precisely the right engine RPM for your speed, and then it just slips into gear. (What this means in practice is that if you&#39;re downshifting, you&#39;ll need to shift into neutral, hit the gas briefly, then hold the gearshift against the new gear while the engine winds down. When upshifting, you can skip the engine-revving part. This holding-the-gearshift-against-the-gear part is what wears out the synchros.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1015843">
				<div id="div-comment-1015843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015843">
			October 12, 2012 at 8:22 am</a>		</div>

		<p>@Stephen O:</p>
<p>Exactly. If you serialize IO operations, as a synchronous handle promises, you MUST have the IO inside a mutex-protected critical section. Obviously, this can&#39;t be done in user mode. But the IO manager must only use the mutex for synchronous handles. Thus, at the decision point whether to create a temporary OVERLAPPED and wait on the handle, the IO manager already knows the type of the handle.</p>
<p>Also, what if you opened a file for async IO, but used no standard GENERIC mask (which includes SYNCHRONIZE), but passed an explicit mask without SYNCHRONIZE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1015853">
				<div id="div-comment-1015853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015853">
			October 12, 2012 at 9:00 am</a>		</div>

		<p>It actually sounds useful, but only on pipes (for which two outstanding I/O requests are bad anyway).</p>
<p>Basically, a crude method of simulating the Unix select() call on pipes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1015823">
				<div id="div-comment-1015823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/stephen.oberholtzer_4000_freedompay.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>stephen.oberholtzer@freedompay.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015823">
			October 12, 2012 at 7:52 am</a>		</div>

		<p>This design seems like it would make synchronous handles not-thread-safe. &nbsp;Consider a synchronous serial port handle:</p>
<p>(1) Thread A calls WriteFile to transmit; transmit buffer is full, so operation blocks.</p>
<p>(2) Thread B calls ReadFile to receive</p>
<p>(3) After a several milliseconds some transmit buffer space becomes available and the IRP_MJ_WRITE operation completes.</p>
<p> &nbsp; &nbsp;The handle is signaled, and both A and B wake up.</p>
<p>What protects against this? &nbsp;Some sort of system-maintained critical section or mutex? &nbsp;Or nothing at all? (in which case, FILE_FLAG_OVERLAPPED would be *critical* for any handle that might be accessed by multiple threads simultaneously)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1015883">
				<div id="div-comment-1015883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015883">
			October 12, 2012 at 4:50 pm</a>		</div>

		<p>How come the system doesn&#39;t know if a handle is sync or async anyway?</p>
<p>What&#39;s the point of the FILE_FLAG_OVERLAPPED flag when creating the handle in that case?</p>
<div class="post">[<i>There are multiple parts to the system. The part of the system that deals with <code>OVERLAPPED</code> structures doesn&#39;t know. (The lower-level part that handles the I/O does know. That lower-level part is the one who cares about <code>FILE_FLAG_OVERLAPPED</code>.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1015893">
				<div id="div-comment-1015893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015893">
			October 12, 2012 at 6:39 pm</a>		</div>

		<p>My bosses were called to drive 3 hours, to get a 2 hour scolding from the customer over a bug i introduced when fixing a bug that wasn&#39;t causing any problems.</p>
<p>Some customers don&#39;t care about technical correctness or purity, only that they don&#39;t get fined thousands of dollars when financial information isn&#39;t being recorded properly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1015903">
				<div id="div-comment-1015903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015903">
			October 13, 2012 at 3:29 am</a>		</div>

		<p>I like the analogy here.</p>
<p>Handle = Gearbox</p>
<p>OVERLAPPED = Clutch</p>
<p>Synchronous fallback = Synchromesh fallback</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1015913">
				<div id="div-comment-1015913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henning Makholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1015913">
			October 13, 2012 at 4:41 am</a>		</div>

		<p>This is all well and fine for disk files, but it bears notice that the situation is a lot murkier for socket I/O.</p>
<p>In particular, it seems (based on anecdotal experience) that the kernel feature Raymond describes that reduces everything to asynchronous overlapped operations is not used for socket I/O. Instead the socket provider gets to see all the details of the call issued by the program (synchronous? asynchronous? OVERLAPPED? completion routine?) and is left to interpreting them correctly itself. II assume Microsoft&#39;s default socket provider knows how to do this the right way, but third-party socket providers for personal firewalls, VPNs or the like &#8230; generally don&#39;t. Often it seems they have only ever been tested with the Berkeley sockets subset of the Winsock interface.</p>
<p>When you&#39;re writing for servers, you can generally get away with telling customers not to use a buggy network stack, but for the desktop/laptop market, the prudent developer will be a lot more conservative than MSDN tells you you need to be.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1016213">
				<div id="div-comment-1016213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1016213">
			October 16, 2012 at 1:11 am</a>		</div>

		<p>[There are multiple parts to the system. The part of the system that deals with OVERLAPPED structures doesn&#39;t know. (The lower-level part that handles the I/O does know. That lower-level part is the one who cares about FILE_FLAG_OVERLAPPED.) -Raymond]</p>
<p>MSDN (<a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363858%28v=vs.85%29.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa363858%28v=vs.85%29.aspx</a>) says:</p>
<p>&quot;FILE_FLAG_OVERLAPPED: &#8230; If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an OVERLAPPED structure. &#8230;&quot;</p>
<p>This contradicts your statement that the layer dealing with the OVERLAPPED structures don&#39;t care about that flag. So, I&#39;m still confused and still think, the MSDN documentation needs to be improved to document the real behavior.</p>
<div class="post">[<i>The level that deals with OVERLAPPED structures doesn&#39;t care whether the handle is synchronous or asynchronous. If you pass an OVERLAPPED, it converts it to a kernel-thingie and calls the next lower level. If you don&#39;t pass an OVERLAPPED, it creates a temporary kernel-thingie and calls the next lower level. The lower-level part is the one that knows whether the handle is synchronous or asynchronous. But it no longer knows whether you passed an OVERLAPPED or not. (All it gets is a kernel-thingie.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1016513">
				<div id="div-comment-1016513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343#comment-1016513">
			October 17, 2012 at 12:25 am</a>		</div>

		<p>[The lower-level part is the one that knows whether the handle is synchronous or asynchronous.]</p>
<p>But as you described it works like this: WriteFile() and ReadFile() with lpOverlapped = NULL are using an temporary OVERLAPPED structure and Get&shy;Overlapped&shy;Result, which gives such calls &quot;blocking&quot; behavior. When called with an actual OVERLAPPED structure, the temporary OVERLAPPED structure and Get&shy;Overlapped&shy;Result are not employed, making such calls &quot;nonblocking&quot;.</p>
<p>The quoted desribtion in MSDN gives FILE_FLAG_OVERLAPPED the additional semantics of making WriteFile() and ReadFile() &quot;blocking&quot; even if you are using an OVERLAPPED structure, which by your describtion seems not to be true.</p>
<p>So the question remains: What else of the semantics of FILE_FLAG_OVERLAPPED is left for the lower level part to take care about? What does it control at all?</p>
<div class="post">[<i>I simplified the story so I could get to the point. The <code>Get&shy;Overlapped&shy;Result</code> actually happens at the lower level, which knows whether the handle is synchronous or asynchronous. (It is also the lower level which serializes I/O operations on synchronous handles.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>