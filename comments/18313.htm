<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (47)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-734123">
				<div id="div-comment-734123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734123">
			May 8, 2009 at 10:44 am</a>		</div>

		<p>Just use stl::sort. It&#8217;s better than quicksort (its worst case is still n log(n) rather than qs&#8217;s n*n). And its comparison function is &#8220;less than&#8221;, which returns bool.</p>
<div class="post">[<i>You&#8217;re focusing on the details and missing the big picture. What if you&#8217;re using a language that STL doesn&#8217;t support? (In fact, today&#8217;s example came from one such language.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734133">
				<div id="div-comment-734133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nicholas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734133">
			May 8, 2009 at 10:54 am</a>		</div>

		<p>&quot;Just use stl::sort&quot;</p>
<p>Yeah, well there are some standard library classes that accept a functor for comparison. &nbsp;Welcome back to the original problem.</p>
<p>But, the moral of this story goes well beyond sorting algorithms. &nbsp;If you violate the contract of an interface then bad things happen. &nbsp;I see it all the time, both intentional and unintentional.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734143">
				<div id="div-comment-734143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734143">
			May 8, 2009 at 11:15 am</a>		</div>

		<p>Serendipity is a wonderful thing. &nbsp;It just so happens that I, too, am working on sorting today. &nbsp;I need to find all possible shortest cyclic subgraphs of a directed graph (not that the graph cannot be acyclic if I&#8217;m looking for cycles) and print them out. &nbsp;I was just looking at Kahn&#8217;s topological sorting algorithm, but it only applied to DAGs. &nbsp;I have an idea how to modify it, though.</p>
<p>Clearly, using stl::sort is not an option. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-734153">
				<div id="div-comment-734153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734153">
			May 8, 2009 at 11:31 am</a>		</div>

		<blockquote><p>
  find all possible shortest cyclic subgraphs of a directed graph
</p></blockquote>
<p>Um&#8230; what does that have to do with sorting? &nbsp;Sounds like an interesting problem, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734163">
				<div id="div-comment-734163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JimLogas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734163">
			May 8, 2009 at 11:32 am</a>		</div>

		<p>Ah, takes me back to my coding days. A good pred function might be able to help out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dwalker-wk odd alt thread-odd thread-alt depth-1" id="comment-734193">
				<div id="div-comment-734193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734193">
			May 8, 2009 at 12:24 pm</a>		</div>

		<p>How to sort: &nbsp;Permute the set randomly, and then check to see if it&#8217;s sorted. &nbsp;If not, try again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734213">
				<div id="div-comment-734213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734213">
			May 8, 2009 at 12:49 pm</a>		</div>

		<p>how to sort: periodically check to see if the set is sorted. Bit errors will eventually result in a sorted set.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734223">
				<div id="div-comment-734223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734223">
			May 8, 2009 at 12:59 pm</a>		</div>

		<p>@Maurits</p>
<p>It is technically a sorting problem with a partial ordering. &nbsp;Essentially, the nodes in a directed graph can be partially ordered (sorted) such that those node with outgoing edges appear in a list or other data structure before those node into which their edged lead. &nbsp;Check out &lt;<a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Topological_sorting&gt;" rel="nofollow"></a><a href="http://en.wikipedia.org/wiki/Topological_sorting&#038;gt" rel="nofollow">http://en.wikipedia.org/wiki/Topological_sorting&#038;gt</a>; for an example. &nbsp;It&#8217;s true that this this sorting doesn&#8217;t actually compare the value of elements, but it is sorting nonetheless.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734243">
				<div id="div-comment-734243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734243">
			May 8, 2009 at 1:08 pm</a>		</div>

		<blockquote><p>
  how to sort: periodically check to see if the set is sorted. Bit errors will eventually result in a sorted set.
</p></blockquote>
<p>That takes way too long, Bogosort is a lot quicker: <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Bogosort" rel="nofollow">http://en.wikipedia.org/wiki/Bogosort</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734253">
				<div id="div-comment-734253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NUXI</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734253">
			May 8, 2009 at 1:38 pm</a>		</div>

		<p>I guess this is supposed to be readable example code, but how can you pass up the chance to layer the ?: operators?</p>
<p>return x &gt; y ? 1 : x &lt; y ? -1 : 0;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734263">
				<div id="div-comment-734263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734263">
			May 8, 2009 at 2:12 pm</a>		</div>

		<blockquote><p>
  That takes way too long, Bogosort is a lot quicker
</p></blockquote>
<p>Hey, don&#8217;t knock proton decay &#8211; one day, it&#8217;ll be the only energy source we have.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-734283">
				<div id="div-comment-734283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734283">
			May 8, 2009 at 4:54 pm</a>		</div>

		<p>VB to the rescue:</p>
<p>Function Compare(X, Y)</p>
<p>Select Case X</p>
<p>Case Is &gt; Y: Compare = 1</p>
<p>Case Y: Compare = 0</p>
<p>Case Is &lt; Y: Compare = -1</p>
<p>End Select</p>
<p>End Function</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734293">
				<div id="div-comment-734293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Criffer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734293">
			May 8, 2009 at 5:13 pm</a>		</div>

		<p>Simpler, faster, branchless, correct:</p>
<p>int compare(int x, int y)</p>
<p>{</p>
<p>return x &#8211; y;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734303">
				<div id="div-comment-734303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.virtualdub.org/' rel='external nofollow' class='url'>Phaeron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734303">
			May 8, 2009 at 5:25 pm</a>		</div>

		<p>Criffer: compare(0x7FFFFFFF, -0x80000000).</p>
<div class=post>[<i>And good luck generalizing to objects that don&#8217;t support subtraction. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734313">
				<div id="div-comment-734313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.roseharp.com/' rel='external nofollow' class='url'>Timothy Byrd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734313">
			May 8, 2009 at 6:45 pm</a>		</div>

		<p>@Alexander &#8211; you know there are coders out there capable of writing a &quot;less than&quot; operator that only gives a partial ordering.</p>
<p>I&#8217;ve been playing with Ruby lately, and it uses the spaceship operator for comparisons. I can easily imagine someone writing a comparator that triggers an infinite loop.</p>
<p>&#8212; T</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734323">
				<div id="div-comment-734323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734323">
			May 8, 2009 at 6:55 pm</a>		</div>

		<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Bogosort#Quantum_Bogosort" rel="nofollow">http://en.wikipedia.org/wiki/Bogosort#Quantum_Bogosort</a></p>
<p>^^^ That &quot;destroy universe&quot; operation doesn&#8217;t sound very thread-safe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734333">
				<div id="div-comment-734333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Brooks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734333">
			May 8, 2009 at 7:04 pm</a>		</div>

		<p>When we were developing Motif at OSF, we had a function that would determine a tab order for controls on a form, based on their &quot;reading order&quot; (left to right, top to bottom). The sort predicate was that if the two controls did not overlap in a vertical direction, they were sorted vertically, otherwise in the order of their X-coordinate. This was intended to return the best result when the controls were not nicely arranged on a grid but just jumbled about.</p>
<p>Motif (and the rest of the X stack) being OS-independent, this code gave reasonable results on HP-UX and Ultrix, but crashed very occasionally on Solaris.</p>
<p>It took us a couple of weeks to get to the bottom of it. It is possible to arrange three controls so that, according to this algorithm, A &lt; B &lt; C &lt; A. Solaris&#8217;s sort implementation was sufficiently different from the others that it crashed with this combination of results (probably a SVR4/BSD difference). The others managed at least to do something.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734353">
				<div id="div-comment-734353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Duke of New York</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734353">
			May 8, 2009 at 10:00 pm</a>		</div>

		<p>The person who asked today&#8217;s question is the kind of person who substitutes salt for sugar when cooking.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734363">
				<div id="div-comment-734363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734363">
			May 9, 2009 at 12:02 am</a>		</div>

		<p>Maurits:</p>
<p>A clever modern-day VB.NET implementation would be:</p>
<p>Function Compare(X As whatever, Y As whatever) As Integer</p>
<p>&nbsp;Return(If(X &gt; Y, 1, Int(X &lt; Y)))</p>
<p>End Function</p>
<p>This leverages the &quot;new&quot; VB.NET 2008 ternary intrinsic function .. works similar to how IIF() did in previous VB versions, but is now inlined and performs short-circuiting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734373">
				<div id="div-comment-734373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SDiZ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734373">
			May 9, 2009 at 12:29 am</a>		</div>

		<p>@ Criffer:</p>
<blockquote><p>
  int compare(int x, int y) {</p>
<p>  &nbsp;return x &#8211; y;
</p></blockquote>
<p>try x=MAX_INT, y=-1 and see it overflow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734383">
				<div id="div-comment-734383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erzengel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734383">
			May 9, 2009 at 1:01 am</a>		</div>

		<p>I would love to have had this person walk up to my office and ask me that question.</p>
<p>&#8220;The array I am sorting contains no duplicate elements, so the two items x and y should never be equal.&#8221;</p>
<p>&#8220;Ever think that maybe it compares an element with itself?&#8221;</p>
<p>Cue face-palm.</p>
<p>The &#8220;operate an element with itself&#8221; is an oft-overlooked part of many operators. Particularly operator=. Then people have the gall to ask, &#8220;Why would someone set an instance to itself?&#8221; or &#8220;Why would someone compare an instance to itself?&#8221;</p>
<p>Because functions don&#8217;t always know that two pointers point to the same instance, maybe?</p>
<div class=post>[<i>&gt;Cue face-palm </p>
<p>More likely, you&#8217;d get the response, &#8220;Why would it do that? What idiot sorts by comparing an element with itself?&#8221; -Raymond</p>
<p></i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734393">
				<div id="div-comment-734393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734393">
			May 9, 2009 at 3:00 am</a>		</div>

		<p>@Criffer, Phaeron:</p>
<p>I was going to write about the possibility of comparing using subtraction (restricted to ints, as Raymond&#8217;s response pointed out), but thinking through it, I realised that overflow could mess things up.</p>
<p>As many of you probably know, the processor (x86, at least) compares integers by performing a subtraction, setting flags according to the result and throwing the result away. However, the conditional branch instructions account for overflow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734413">
				<div id="div-comment-734413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734413">
			May 9, 2009 at 9:06 am</a>		</div>

		<p>The standard C++ sort is only guaranteed the average of O(n*ln n), not the worst case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734423">
				<div id="div-comment-734423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasonhaley.com/blog/post/2009/05/09/Interesting-Finds-May-9-2009.aspx' rel='external nofollow' class='url'>Jason Haley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734423">
			May 9, 2009 at 11:42 am</a>		</div>

		<p>Interesting Finds: May 9, 2009</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734433">
				<div id="div-comment-734433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erzengel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734433">
			May 9, 2009 at 4:38 pm</a>		</div>

		<p>&#8220;Why would it do that? What idiot sorts by comparing an element with itself?&#8221;</p>
<p>Cue me executing a Picard double face-palm.</p>
<p>After which I&#8217;d ask, &#8220;And how do you propose a function knows that an element IS itself without a comparison?&#8221;</p>
<div class=post>[<i>Duh. <code>if (i == j) result = 0; else result = comparator(a[i], a[j]);</code>. What idiot compares an item to itself? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734493">
				<div id="div-comment-734493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734493">
			May 10, 2009 at 1:21 am</a>		</div>

		<p>This reminds me of one of my comp. sci assignments: We had to implement several sorting algorithms, and for bonus points, display the &nbsp;operation of each algorithm graphically.</p>
<p>Viewing the various sorting algorithms running was quite fun (and made the way they work really apparent). Quicksort was not much fun to watch, but heapsort was cool.</p>
<p>Oh, and since I was into R.E.M. at the time, I called my program &quot;A Carnival of Sorts&quot;. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734533">
				<div id="div-comment-734533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734533">
			May 10, 2009 at 4:37 am</a>		</div>

		<p>Well, I think that the x&lt;y (without x==y) is pretty good to speed up things. If I need to sort the 3,5,2,4,1,2 array, the result should be 1,2,2,3,4,5. Who cares that the &quot;first&quot; 2 is behind the &quot;second&quot; 2 or the vice versa. The faster it breaks, the less comparations are made. If the algorithm goes beyond the array&#8217;s upper bound, it will sort a stable program from a buggy program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734543">
				<div id="div-comment-734543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734543">
			May 10, 2009 at 5:44 am</a>		</div>

		<p>Alin:</p>
<p>You&#8217;ve missed the whole point of the post, if you don&#8217;t implement the = part, then your &#8216;sort&#8217; may never finish.</p>
<p>If 2&lt;2 and 2&lt;2 then which one comes first? How do you know they are sorted?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734553">
				<div id="div-comment-734553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734553">
			May 10, 2009 at 5:45 am</a>		</div>

		<p>Well, if it is the case that most items being compared will not be equal, you could speed it up and still maintain correct behaviour &#8211; just break it up into several tests:</p>
<p>int compare2(x, y)</p>
<p>{</p>
<p>if (x &gt; y) return 1;</p>
<p>if (x &lt; y) return -1;</p>
<p>if (x == y) return 0;</p>
<p>}</p>
<p>More statements/lines in the source language does not necessarily translate to more machine instructions in the object code, especially when optimizations come into the picture.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734563">
				<div id="div-comment-734563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734563">
			May 10, 2009 at 11:39 am</a>		</div>

		<p>@Falcon:</p>
<p>That last if should be just a return. If it&#8217;s neither smaller nor larger, then it has to be equal. And if there were a third possibility, the function would return an undefined result.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734593">
				<div id="div-comment-734593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">W</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734593">
			May 10, 2009 at 6:28 pm</a>		</div>

		<p>@Falcon</p>
<p>Your function will break for simple floatingpoint numbers. Consider a=NaN and B=Nan</p>
<p>=&gt; none of a&lt;b, a&gt;b and a==b is true</p>
<p>I think even &quot;someone else&quot;&#8217;s function might break down here when supplied with an infinity and a NaN, but I don&#8217;t remember the comparison rules for all special cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734603">
				<div id="div-comment-734603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.widget5.co.nz' rel='external nofollow' class='url'>Tom Leys</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734603">
			May 10, 2009 at 6:39 pm</a>		</div>

		<p>If you want to see animated sorts, have a look at this : <a rel="nofollow" target="_new" href="http://www.sorting-algorithms.com/" rel="nofollow">http://www.sorting-algorithms.com/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734623">
				<div id="div-comment-734623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734623">
			May 10, 2009 at 8:55 pm</a>		</div>

		<p>BTW, on comparisons using subtraction, will it work if the numbers are unsigned instead of signed?</p>
<div class=post>[<i>I trust my readers are smart enough to figure out the answer to this question themselves. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734633">
				<div id="div-comment-734633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Toukarin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734633">
			May 10, 2009 at 11:48 pm</a>		</div>

		<p>Insightful. It&#8217;s one of those nitty gritty things that are obvious and yet not so obvious at first sight. Had someone asked this question before but I couldn&#8217;t really give a complete explanation like this one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734643">
				<div id="div-comment-734643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734643">
			May 11, 2009 at 12:07 am</a>		</div>

		<p>@someone else:</p>
<p>Yes, you&#8217;re quite right (for the integer case, at least). Can&#8217;t believe I missed that!</p>
<p>@W:</p>
<p>I admit I&#8217;m no FP expert, but I can see your point. Just goes to show how important it is to know exactly what you&#8217;re dealing with.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734663">
				<div id="div-comment-734663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734663">
			May 11, 2009 at 10:14 am</a>		</div>

		<p>&#8220;Well, notice that the comparison function is also inconsistent. In particular, the anti-symmetry rule is violated: compare(x, y) and compare(y, x) return the same value&#8221;</p>
<p>Maybe I&#8217;m missing it, but I don&#8217;t see that. compare(2,1) =&gt; 1 while compare(1,2) =&gt; -1.</p>
<p>Is lack of coffee making me miss something?</p>
<div class=post>[<i>After you finish your coffee, try reading the rest of the sentencce. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734703">
				<div id="div-comment-734703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DysgraphicProgrammer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734703">
			May 11, 2009 at 10:23 am</a>		</div>

		<p>Quote: More likely, you&#8217;d get the response, &#8220;Why would it do that? What idiot sorts by comparing an element with itself?&#8221; -Raymond</p>
<p>I find that thoughtlessness (or temporary stupidity) is far more common then actual persistent idiocy. Usually a small nudge in the right direction resolves that quickly. Maybe I have been luckier than most in my choice of coworkers?</p>
<div class=post>[<i>In real life, you never compare an item against itself. Bubblesort never compares an item against itself. Many quicksort implementations never compare an item against itself. The idea of comparing an item against itself while sorting is actually quite strange. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734653">
				<div id="div-comment-734653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734653">
			May 11, 2009 at 4:49 am</a>		</div>

		<p>A funny part is that there are more than one standards for comparisons:</p>
<p>* standard C one: int compare(input_type x, input_type y) : Returns 0, or a negative value, or a positive value.</p>
<p>* standard C++ one: bool less(input_type x, input_type y) : Returns true if x is strictly less than y.</p>
<p>It gets awkward when people start mixing the two. Notably, MFC uses the C convention, but I often stumble on code that assumes it uses the C++ one&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-734793">
				<div id="div-comment-734793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734793">
			May 11, 2009 at 12:42 pm</a>		</div>

		<p>@Roman,</p>
<blockquote><p>
  The standard C++ sort is only guaranteed the</p>
<p>  average of O(n*ln n), not the worst case.
</p></blockquote>
<p>A Standard C++ Library implementation included with Microsoft Visual C has such worst case guarantee. I don&#8217;t think other compiler vendors will settle for anything worse then.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-734863">
				<div id="div-comment-734863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Todd Wilder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734863">
			May 11, 2009 at 2:39 pm</a>		</div>

		<p>I was curious why .NET chose QuickSort for their sorting, because its worst case is n^2 while HeapSort is always (n)Log(n). I heard that other factors come into play, like memory management etc. Any Ideas?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-leo-davidson even thread-even depth-1" id="comment-734893">
				<div id="div-comment-734893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Leo+Davidson' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734893">
			May 11, 2009 at 3:15 pm</a>		</div>

		<p>Oops: QuickSort does allocate memory, but it&#8217;s usually implicit. e.g. Variables in recursive calls.</p>
<p>When I said it doesn&#8217;t require any memory I meant it doesn&#8217;t need to make temporary copies of the data itself. It does still need some memory for bookkeeping.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-leo-davidson odd alt thread-odd thread-alt depth-1" id="comment-734883">
				<div id="div-comment-734883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Leo+Davidson' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-734883">
			May 11, 2009 at 3:09 pm</a>		</div>

		<p>@Todd Wilder:</p>
<p>If you look up QuickSort on Wikipedia it explains the likely reason.</p>
<p>QuickSort and HeapSort are both in-place (i.e. they don&#8217;t need to allocate any temporary storage for the sorting).</p>
<p>QuickSort&#8217;s worst case is worse than HeapSort&#8217;s, however QuickSort is still *usually* faster than HeapSort.</p>
<p>i.e. On average QuickSort is so good that its &quot;bad days&quot; are worth living with.</p>
<p>Of course, if you know that your data is going to be arranged such that QuickSort will very often be slow then you&#8217;d want to use a different algorithm. If you don&#8217;t know, though, then QuickSort is likely to be a good bet.</p>
<p>(While at uni I had the privilege of meeting and attending some lectures by QuickSort&#8217;s inventor, C.A.R. Hoare.</p>
<p>Many of my other tutors &amp; lecturers had done &nbsp;impressive things, and Hoare himself has done a huge amount of other, more important/complex work, but there was something really cool about sharing tea and biscuits (among with other students in my year) with the person who invented QuickSort. Still the defacto sorting algorithm in just about every library despite being invented in the 60s.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-735093">
				<div id="div-comment-735093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-735093">
			May 12, 2009 at 1:27 am</a>		</div>

		<p>There&#8217;s always IntroSort (introspective sort). Average runtimes of quicksort, but worst case is still O(nlogn). The trick is it starts via quicksort, but it monitors itself and if it sees it actually has a quicksort taking O(n^2), it stops and goes heapsort.</p>
<p>Quicksort actually has well-known corner cases that cause it to go O(n^2), and most of them are unlikely to happen if you pay some attention. (I believe one of them is if the list is sorted backwards, in which case, swapping manually would be far faster).</p>
<p>The only bad thing is that quicksort isn&#8217;t stable &#8211; two items with the same value may get swapped. It matters if the comparison item is a subset of the entire item (e.g., sort by name an address book &#8211; if you have two people with identical names, quicksorting may swap the records around.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-735173">
				<div id="div-comment-735173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-735173">
			May 12, 2009 at 4:31 am</a>		</div>

		<p>When I want a stable sort, I use a merge-sort: A second buffer with the same size as the first, a copy only if necessary (whether log2(n) is even or odd), and a guaranteed O(nlogn) in all cases, best and worst.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-735193">
				<div id="div-comment-735193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-735193">
			May 12, 2009 at 4:58 am</a>		</div>

		<p>A quicksort algorithm can be implemented not to swap identical records, leaving them in the original order.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-735233">
				<div id="div-comment-735233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-735233">
			May 12, 2009 at 8:44 am</a>		</div>

		<p>Medinoc:</p>
<p>There is also an in-place variant of MergeSort() but I am not sure if it offers O(n log n) as an upper-bound.</p>
<p>It also seems to be quite a bit more complicated based on what little I have read about that variant.</p>
<p>The standard MergeSort() has the obvious advantage that it is trivial to parallelize, and the symmetry between best and worst case is a very attractive quality when writing for robustness (carefully crafted data to DoS a server using its sort algorithms weakness has been used at least once, targeting the Free Internet Chess Server)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dwalker-wk even thread-even depth-1" id="comment-735283">
				<div id="div-comment-735283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090508-00/?p=18313#comment-735283">
			May 12, 2009 at 11:07 am</a>		</div>

		<p>I have to mention my favorite Syncsort ad again: &nbsp;From Computerworld magazine, in the heyday of mainframes, the full-page ad featured a computer operations manager claiming that using the Syncsort product allowed them to run their production jobs in 240% less time!</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>