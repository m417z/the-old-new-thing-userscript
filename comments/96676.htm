<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (49)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1303535">
				<div id="div-comment-1303535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">French Guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303535">
			July 25, 2017 at 7:14 am</a>		</div>

		<p>If the default value is null (which is the case for reference and nullable types), it&#8217;s easier to debug the second line, because an empty collection will cause an InvalidOperationException, while a null first element will cause a NullReference exception (so you know what the problem is). If the default value is something other than null (which is the case for value types such as int), the two lines aren&#8217;t functionally equivalent, since an empty collection would result in DoSomething being called on the default value (0 for int).</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-aadsso-1live-com00037ffe8545d1b7 odd alt depth-2 parent" id="comment-1303556">
				<div id="div-comment-1303556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/David+Totzke' rel='external nofollow' class='url'>David Totzke</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303556">
			July 25, 2017 at 7:32 am</a>		</div>

		<p>There could be an extension method on the value type but now you don&#8217;t know if the one you are operating with is an actual instance from the list or a default you got from FirstOrDefault();  This is in addition to the other issues you have with Option 1.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1303595">
				<div id="div-comment-1303595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">French Guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303595">
			July 25, 2017 at 8:20 am</a>		</div>

		<p>I don&#8217;t see why getting a default value instead of a value from the collection is an issue (assuming you want to use a default value rather than fail if the collection is empty). The real issue is that you have no control over the default value supplied by FirstOrDefault(), so you should use collection.DefaultIfEmpty().First() instead, because that lets you supply your own application-relevant default value.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com00037ffe8545d1b7 odd alt thread-odd thread-alt depth-1 parent" id="comment-1303536">
				<div id="div-comment-1303536" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/David+Totzke' rel='external nofollow' class='url'>David Totzke</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303536">
			July 25, 2017 at 7:14 am</a>		</div>

		<p>Exercise:<br />
Option 1 &#8220;FirstOrDefault()&#8221; will return null if the collection is empty so you will get a NullReferenceException when you try to call DoSomething().  Not very helpful.<br />
Option 2  &#8220;First()&#8221; will result in an InvalidOperationException if collection is empty with the message &#8220;Sequence contains no elements&#8221; which is easier to debug.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1303546">
				<div id="div-comment-1303546" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303546">
			July 25, 2017 at 7:19 am</a>		</div>

		<p>More importantly, if you get a <code>Null&shy;Reference&shy;Exception</code> on Option 1, it&#8217;s not clear whether the problem is that <code>collection</code> is null, or that <code>collection</code> is non-null but empty. In Option 2, the two failure modes raise different exceptions.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1303575">
				<div id="div-comment-1303575" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AberAber</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303575">
			July 25, 2017 at 8:03 am</a>		</div>

		<p>Admittedly, I&#8217;ve been trying to harp on this&#8230;please don&#8217;t chain code&#8230;ever, so we can&#8217;t tell which is the null reference.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong even depth-4" id="comment-1303785">
				<div id="div-comment-1303785" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303785">
			July 25, 2017 at 6:48 pm</a>		</div>

		<p>But if it&#8217;s okay to not call .DoSomething() if foo is null, I found ?. operator handy.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-3 parent" id="comment-1303615">
				<div id="div-comment-1303615" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303615">
			July 25, 2017 at 8:24 am</a>		</div>

		<p>Additionally, collection could be non-null and non-empty but contain a null (in the first element).</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1303725">
				<div id="div-comment-1303725" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303725">
			July 25, 2017 at 11:24 am</a>		</div>

		<p>I made a rule long ago: don&#8217;t put nulls in collections.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong odd alt depth-5" id="comment-1303795">
				<div id="div-comment-1303795" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303795">
			July 25, 2017 at 7:02 pm</a>		</div>

		<p>So do I.</p>
<p>But seems lots of people, particularly those from Java background, loves to return null as default even for those function returning array.</p>
<p>So instead of just checking for the length of variable for 0, you also need to check whether the variable itself is null.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1303576">
				<div id="div-comment-1303576" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pierre B.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303576">
			July 25, 2017 at 8:09 am</a>		</div>

		<p>IDK, but if you&#8217;re smart enough to choose between two possible ways to code something, which involves knowing that one of the failure modes is the object being null, should you not be smart enough to&#8230; check for null in the first place before using the object?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1303605">
				<div id="div-comment-1303605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303605">
			July 25, 2017 at 8:21 am</a>		</div>

		<p>Darn.  Your position on this is far more succinct than mine.</p>
<p>The answer is, Yes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1303775">
				<div id="div-comment-1303775" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Koopa</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303775">
			July 25, 2017 at 6:24 pm</a>		</div>

		<p>If I see someone using &#8220;as&#8221; as in the example above, I think the developer didn&#8217;t know what &#8220;as&#8221; is used for in the first place. Don&#8217;t be an &#8220;as&#8221; ass.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1303835">
				<div id="div-comment-1303835" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303835">
			July 26, 2017 at 6:04 am</a>		</div>

		<p>You shouldn&#8217;t check for null if it is &#8220;impossible&#8221; for it to be null; a null check just tells people reading the code that there&#8217;s some scenario where it could be null.  Otherwise, I agree that you about checking for null (even if only to throw an InvalidArgumentException).  Ideally, a NullReferenceException will always indicates a bug in the code that generated a NullReferenceException (see Eric Lippert&#8217;s Vexing Exceptions: <a href="https://ericlippert.com/2008/09/10/vexing-exceptions/" rel="nofollow">https://ericlippert.com/2008/09/10/vexing-exceptions/</a> ).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1303585">
				<div id="div-comment-1303585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303585">
			July 25, 2017 at 8:17 am</a>		</div>

		<p>In terms of the question asked in the post (&#8220;which is easier to debug?&#8221;), then I agree, use the old-style C cast operator. (Warning: note the implicitly derogatory phrasing there.)  So, yes, as an example of how to make the right choice for maintenance programmers &#8212; do it this way.</p>
<p>However, this is imo an <b>anti-pattern</b> in dot-Net terms.  The C cast operator style should really only be used <i>internally</i>, in things like ParseInt().</p>
<p>I suggest that the correct way to handle 99.999% of these situations is to use the <b>as</b> operator and then check for null.  You probably shouldn&#8217;t need to do this anyway in a &#8220;perfect&#8221; system, because you shouldn&#8217;t need the cast in the first place.  But, hey, nobody&#8217;s perfect, and it&#8217;s a useful mental exercise to think about what &#8220;null&#8221; means in these circumstances.</p>
<p>If it means &#8220;throw an exception, Bozo,&#8221; then, dear Bozo, feel free to throw an exception.  Try to make it as specific as possible, though.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1303616">
				<div id="div-comment-1303616" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">kit</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303616">
			July 25, 2017 at 8:33 am</a>		</div>

		<p>Of course, as of C# 7 you can do :<br />
var thing = GetCurrentItem();<br />
var foo = thing as Foo ?? throw new Exception(&#8220;GetCurrentItem returns something that wasn&#8217;t a Foo&#8221;);<br />
foo.DoSomething();</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1303665">
				<div id="div-comment-1303665" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303665">
			July 25, 2017 at 9:45 am</a>		</div>

		<p>The <b>??</b> operator is basically syntactic sugar representing my approach to such an eventuality.<br />
I&#8217;m not knocking syntactic sugar.  Syntactic sugar buys eyeballs.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1303845">
				<div id="div-comment-1303845" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">kit</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303845">
			July 26, 2017 at 6:58 am</a>		</div>

		<p>Definitely syntactic sugar, but it lets you get the error handling code out of the way and leaves the good path code much more readable &#8211; which has to be good. And anything which reduces the number of keystrokes to write the error handling makes it more likely to get written.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1303695">
				<div id="div-comment-1303695" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken in NH</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303695">
			July 25, 2017 at 9:58 am</a>		</div>

		<p>You could do that before C#7. Even more succinct and readable in 7 though:<br />
if (!(GetCurrentItem() is Foo var foo)) throw new Exception(&#8220;GetCurrentItem returns something that wasn&#8217;t a Foo&#8221;);<br />
foo.DoSomething();</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2 parent" id="comment-1303625">
				<div id="div-comment-1303625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303625">
			July 25, 2017 at 8:40 am</a>		</div>

		<p>If you use <b>as Foo</b> followed by a null test, then you&#8217;re saying, &#8220;Be careful, because this thing might not be a <b>Foo</b>&#8221; which leaves the next programmer scouring the code trying to figure out how a non-<b>Foo</b> could get in there.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1303645">
				<div id="div-comment-1303645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303645">
			July 25, 2017 at 9:40 am</a>		</div>

		<p>I&#8217;m not going to claim to be the best C# programmer in the world, Raymond &#8212; but with enough experience of dealing with a backlog of 1000+ exceptions caused by lousy type conversions: I will make the bold claim that <b>as</b> and a null check is your friend here.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4 parent" id="comment-1303655">
				<div id="div-comment-1303655" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303655">
			July 25, 2017 at 9:42 am</a>		</div>

		<p>Basically, the non-Foo got there because the non-Foo was allowed to get to the other side of the managed airtight lock.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5" id="comment-1303685">
				<div id="div-comment-1303685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303685">
			July 25, 2017 at 9:57 am</a>		</div>

		<p>I guess the question is what you expect to happen if there is a non-Foo in the collection. If you&#8217;re testing for null, it sounds like you don&#8217;t want to crash, in which case this entire article does not apply. This article is about the case where you want to crash. In which case, you should crash in a more debuggable way.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1303825">
				<div id="div-comment-1303825" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SGP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303825">
			July 26, 2017 at 2:37 am</a>		</div>

		<p>Note that as operator and casting are not equivalent. Option 2 gives thing whatever it is an opportunity for user-defined explicit cast.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1304155">
				<div id="div-comment-1304155" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.solsoftsolutions.com' rel='external nofollow' class='url'>Mark S</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1304155">
			July 28, 2017 at 11:00 am</a>		</div>

		<p>Why on earth is it an &#8220;anti-pattern&#8221; to code what you mean?  If you&#8217;re always expecting the item to be convertible, there is an operation that explicitly does just that&#8230;  </p>
<p>`as` means &#8220;we might be getting an item that isn&#8217;t convertible, and that&#8217;s okay too&#8221; &#8212; if that&#8217;s not okay, then why use `as`?  Are the parentheses too hard to type?  Also as SGP notes, `as` doesn&#8217;t consider explicit cast operations defined on the type.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zidek odd alt depth-2" id="comment-1305026">
				<div id="div-comment-1305026" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Ji%C5%99%C3%AD+Z%C3%ADdek' rel='external nofollow' class='url'>Jiří Zídek</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1305026">
			August 2, 2017 at 2:50 pm</a>		</div>

		<p>Using &#8220;thing as Foo&#8221; implicates that your code can react to situation when thing is not a Foo. But in the snippet above the code does not react to such situation, so direct cast is better.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1303635">
				<div id="div-comment-1303635" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nathan_works</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303635">
			July 25, 2017 at 8:55 am</a>		</div>

		<p>I&#8217;d add to &#8220;pick the one that&#8217;s easier to debug&#8221; the extra caveat of  &#8220;and easier to maintain&#8221;.</p>
<p>One reason why I&#8217;m not a big fan of lambdas.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mzzt odd alt thread-odd thread-alt depth-1 parent" id="comment-1303636">
				<div id="div-comment-1303636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/The+MAZZTer' rel='external nofollow' class='url'>The MAZZTer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303636">
			July 25, 2017 at 9:06 am</a>		</div>

		<p>In general, I think as should only be used if you expect and want the cast to fail sometimes. In all cases where the cast is expected to always succeed you should probably use the casting operator. Otherwise as just turns a potential runtime error into a later runtime error or even a logic error which is more difficult to debug.</p>
<p>The compiler will still warn you if you use a nonsensical type with as (eg impossible to be that type so always null) same as if you make a cast that could never work.  So no problem there either way, it&#8217;s really just a runtime/logic error concern.</p>
<p>Exercise: If the collection can contain a null, then .FirstOrDefault is the more difficult to debug, since it won&#8217;t be clear if the return null is from the collection or not. If the collection is expected to never be empty .First() makes more sense to use, since if it is empty you&#8217;ll get an immediate exception which you can debug. Though you may still have to start over and debug when the collection is last manipulated to figure out why it&#8217;s empty when it shouldn&#8217;t be. So from that perspective neither one of these is &#8220;easy&#8221; though the second is slightly &#8220;easier&#8221;.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1303675">
				<div id="div-comment-1303675" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303675">
			July 25, 2017 at 9:54 am</a>		</div>

		<p>&#8220;In general, I think as should only be used if you expect and want the cast to fail sometimes. In all cases where the cast is expected to always succeed you should probably use the casting operator.&#8221;</p>
<p>Intellectually, yes.  Theoretically, yes.  In practice (and I speak from experience) a resounding <b>no</b>.</p>
<p>It all depends upon what you mean by &#8220;expects,&#8221; I think.  Now, first of all, you can&#8217;t &#8220;expect&#8221; the future, which is probably 805 of the coding effort, and will be done by people who don&#8217;t necessarily understand your original axioms and business logic.</p>
<p>And secondly, <i>even if you work with a cohesive team</i>, the chances of your &#8220;expectations&#8221; being met when you cross the boundaries between GUI and DB and business logic and the network are &#8230; the smallest violin that is capable of playing an epsilon you will ever see.</p>
<p>Do not rely on expectations.  Take back control Use the <b>as</b> operator.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong odd alt depth-3" id="comment-1303797">
				<div id="div-comment-1303797" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303797">
			July 25, 2017 at 7:10 pm</a>		</div>

		<p>I agree with this one.</p>
<p>Direct casting only for types your code created. If the variable to be casted is from external source (or even a &#8220;external team&#8221; source), you should use &#8220;as&#8221; and &#8220;TryParse()&#8221; as much as possible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-3 parent" id="comment-1303867">
				<div id="div-comment-1303867" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stuart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303867">
			July 26, 2017 at 7:47 am</a>		</div>

		<p>I completely disagree. Cast to get a usefully debuggable exception, and have a try-catch somewhere at a high level to handle the problem situation with a friendly error message (and log the exception details or transmit them to your error reporting server).</p>
<p>Adding null checks after every line of code makes the code harder to read, adds a layer of ambiguity (was the value the wrong type, or was it null already? THE WORLD MAY NEVER KNOW&lt;/ominousvoice&gt;) and is easier to mess up when refactoring or when someone else is maintaining the code that&#8217;s used to doing things the more normal idiomatic C# way of letting exceptions handle casting errors.</p>
<p>The best code is self-documenting &#8211; the more information you can convey about what&#8217;s going on directly in the code itself, the more convenient for the poor sod who has to read your code later (and that poor sod may very well be yourself!). Using &#8220;as&#8221; vs cast lets me convey to my future self whether I expected the value to always be the type I&#8217;m casting to, or to sometimes contain values of other types.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong odd alt depth-4 parent" id="comment-1303975">
				<div id="div-comment-1303975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303975">
			July 26, 2017 at 6:36 pm</a>		</div>

		<p>Hey, If &#8220;as&#8221; or &#8220;TryParse()&#8221; fails, nothing is preventing you from printing the result of whether the variable is null, and the result of .GetType().ToString().</p>
<p>Why would you want to throw an exception when you can get the same amount of information without throwing?</p>
<p>Regarding &#8220;Adding null checks after every line of code makes the code harder to read&#8221;, &#8221; guess the school is not teaching &#8220;IPO&#8221;(Input-Process-Output&#8221; basic pattern now, and they didn&#8217;t teach you that &#8220;you should do validation on any received external data you don&#8217;t create&#8221;? I guess validation on &#8220;Input&#8221; step don&#8217;t harm readability much?</p>
<p>And the best part is that it&#8217;s also self documenting &#8211; it explicitly spells out what kind of data do you expect, and in what criteria you&#8217;ll say &#8220;this shall not pass&#8221;.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong even depth-5" id="comment-1303976">
				<div id="div-comment-1303976" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303976">
			July 26, 2017 at 6:42 pm</a>		</div>

		<p>And IMO this also makes it easier to debug too. In release build your exception don&#8217;t get line number. With explicit log message, feel free to add &#8220;Validation x failed for variable y &#8211; reason&#8221; that will explicitly tell you where to look into.</p>
<p>And even if (God Forbids) you&#8217;re using debug builds in production, the line number will be at the place of catch statement, instead of actual line it occurs, if it&#8217;s wrapped in try&#8230;catch&#8230; block.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1303705">
				<div id="div-comment-1303705" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jedak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303705">
			July 25, 2017 at 10:10 am</a>		</div>

		<p>Exercise:<br />
Option 3: collections.FirstOfDefault()?.DoSomething();</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1303716">
				<div id="div-comment-1303716" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303716">
			July 25, 2017 at 11:13 am</a>		</div>

		<p>Entirely depends upon what you mean by &#8220;default.&#8221;  Some defaults are more privileged than others in C#. (To provide a concrete example of this, for a random reference type: defaulting to <b>null</b> brings us right back where we were at the top of this post.  Defaulting to a <b>null instance</b> &#8212; a reference to a (probably static) object that provides default behavior for each and every class method &#8212; well, that would obviously be a different thing.</p>
<p>How dangerous this difference might be depends upon the semantics of your class, or even of your application.  Do you want to fail-fast? Use a null.  Do you prefer &#8220;vanilla,&#8221; do-nothing, behavior? Use the null object pattern.  As always, the choice is up to you.</p>
<p>Observationally (over three years), however, I can claim with some confidence that &#8220;FirstOrDefault&#8221; as a way of hiding any sort of choice between null and not-null is a tad on the not especially safe side. (And you&#8217;d be surprised how many experienced programmers ignore the subsequent blue squiggly lines.)</p>
<p><b>FirstOrDefault()</b> is a lovely, sweet, beautiful way for Anders to introduce functionaliness into an imperative programming framework.  Regrettably, owing to the fact that &#8220;null&#8221; is not semantically the same as &#8220;the empty set,&#8221; it doesn&#8217;t actually work unless the programmer puts a bit of effort into it.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1303765">
				<div id="div-comment-1303765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jedak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303765">
			July 25, 2017 at 5:19 pm</a>		</div>

		<p>I believe you missed the ?. operator (<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators" rel="nofollow">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators</a>) in my code listing.  Which will cause the method to not be called if the previous item before the operator is null.  Thus my statement is somewhat of a joke because as written my code listing should never throw an exception.  Thus from a debugging perspective you would not be doing any debugging because of an exception.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1303856">
				<div id="div-comment-1303856" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303856">
			July 26, 2017 at 7:45 am</a>		</div>

		<p>Yes, but as Raymond said, you might WANT an exception to be thrown when &#8220;collection&#8221; is empty.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zidek odd alt depth-2" id="comment-1305035">
				<div id="div-comment-1305035" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Ji%C5%99%C3%AD+Z%C3%ADdek' rel='external nofollow' class='url'>Jiří Zídek</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1305035">
			August 2, 2017 at 2:53 pm</a>		</div>

		<p>This is semantically different, because it silently fails (does nothing) when collection is empty.<br />
The task is aparanetly to fail and do not continue if there is no suitable element in collection.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1303737">
				<div id="div-comment-1303737" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wear</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303737">
			July 25, 2017 at 12:12 pm</a>		</div>

		<p>The problem with .First() is that it&#8217;s just too prone to exploding. Can you really guarantee that the list is never going to be empty? To me that&#8217;s not generally an exceptional case. If it is exceptional for a collection to be empty then I&#8217;d rather make that check myself and throw an exception with a message or comment saying why it should never be empty.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1303755">
				<div id="div-comment-1303755" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jnm2</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303755">
			July 25, 2017 at 3:43 pm</a>		</div>

		<p>Yes. Thank you. I see this all the time and it drives me up the wall. Bookmarking so I can link to this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1303756">
				<div id="div-comment-1303756" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vince</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303756">
			July 25, 2017 at 4:11 pm</a>		</div>

		<p>If collection is null then you&#8217;re screwed either way.</p>
<p>If it&#8217;s not null and a value type collection, then it depends on what DoSomething() does.</p>
<p>The second one will tell you what&#8217;s wrong and usually points you to the line of code, and it works for both reference and value type collections. </p>
<p>I&#8217;ll go with option 2 :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1303816">
				<div id="div-comment-1303816" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jaloopa</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303816">
			July 26, 2017 at 12:59 am</a>		</div>

		<p>Option 2 inside a safety block<br />
if (collection.Any())<br />
{<br />
    collection.First().DoSomething();<br />
}</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1303906">
				<div id="div-comment-1303906" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303906">
			July 26, 2017 at 9:11 am</a>		</div>

		<p>The &#8220;if&#8221; version changes the behavior, so it doesn&#8217;t fall into the &#8220;if there&#8217;s no difference between the two options&#8221; category.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1303925">
				<div id="div-comment-1303925" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aged .Net Guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303925">
			July 26, 2017 at 10:12 am</a>		</div>

		<p>In addition to Raymond&#8217;s point the guard if(collection.Any()) &#8230; is only a valid guard in a single-threaded environment.</p>
<p>Such environments are already quaint and getting more so daily.  IMO an excellent way to fertilize code rot is to be writing assumedly-ST only code in 2017.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1304157">
				<div id="div-comment-1304157" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.solsoftsolutions.com' rel='external nofollow' class='url'>Mark S</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1304157">
			July 28, 2017 at 11:02 am</a>		</div>

		<p>Plus it&#8217;s wasteful, as it allocates another enumerator and starts iterating through it, only to then do the same thing again</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1303855">
				<div id="div-comment-1303855" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://skuldwyrm.no/' rel='external nofollow' class='url'>Roger Hågensen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303855">
			July 26, 2017 at 7:15 am</a>		</div>

		<p>Ooh. somewhat of a dilemma. I find &#8220;var foo = thing as Foo;&#8221; to more clearly indicate what the programmer might want/expect. I dislike casting but the casting is done on it&#8217;s own line rather than part of some more complex line.</p>
<p>The exercise I can&#8217;t comment about as I really do not like OOP and try to avoid it (as I&#8217;m a procedural kinda guy), they both look kinda messy to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1303985">
				<div id="div-comment-1303985" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Merken</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1303985">
			July 26, 2017 at 11:59 pm</a>		</div>

		<p>Option 1 will throw a nullref exception when either collection is null or FirstOrDefault returns null (depending on the type of collection, assuming this is a plain object-type array)</p>
<p>Option 2 will only throw a nullref exception when collection is null.</p>
<p>So option 2 seems easier to debug to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1304046">
				<div id="div-comment-1304046" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Gilbert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1304046">
			July 27, 2017 at 11:35 am</a>		</div>

		<p>I see a lot of comments saying, &#8220;as implies this, casts imply that&#8221;, but it&#8217;s more nuanced than that. If I see code like this:</p>
<p>var foo = obj as Foo;</p>
<p>foo.DoSomething();<br />
Use(foo);</p>
<p>&#8230;then I infer that the author does always expect obj to be a Foo. If they thought that obj might sometimes be a Foo, sometimes not, then they&#8217;d have added a check to see if the foo variable got a null reference or not.</p>
<p>Though I don&#8217;t think I&#8217;ve ever written it myself, in maintaining other people&#8217;s code I&#8217;ve also seen casts wrapped in try/catch blocks (apparently people who didn&#8217;t know that the as operator existed?):</p>
<p>Foo foo;</p>
<p>try<br />
{<br />
  foo = (Foo)obj;<br />
}<br />
catch<br />
{<br />
  foo = null;<br />
}</p>
<p>In this case, the context is very clearly telling me that the author *does* expect the cast to fail sometimes. So, you can&#8217;t make conclusions about the expectations of the code or its author based solely on whether the cast operator or as was used.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-sam-scheinhausmagnitudecapital-com even thread-even depth-1" id="comment-1304895">
				<div id="div-comment-1304895" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MgSm88' rel='external nofollow' class='url'>MgSm88</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170725-00/?p=96676#comment-1304895">
			August 2, 2017 at 7:11 am</a>		</div>

		<p>I disagree with the premise of this blog post, which is that somehow an `InvalidCastException` or `InvalidOperationException` is more descriptive than a `NullReferenceException`. I think all 3 are terrible options. </p>
<p>If you are testing an invariant, you should instead *write code that explicitly checks your assumptions, and explicitly throws if those assumptions fail*. And because you&#8217;re throwing your own exception, you can make a much more descriptive exception message that helps your future self quickly identify the source of the problem. This way there&#8217;s zero ambiguity, and its much faster to find and fix the bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>