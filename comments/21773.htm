<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (49)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-643603">
				<div id="div-comment-643603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nik</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643603">
			July 2, 2008 at 10:11 am</a>		</div>

		<p>Stunning. Looking forward to the next one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643613">
				<div id="div-comment-643613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643613">
			July 2, 2008 at 10:13 am</a>		</div>

		<p>Just a guess, but perhaps the internal testing was done against debug builds? &nbsp;Debug builds fill unused memory with 0xCC, which is not a signaling NaN.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643653">
				<div id="div-comment-643653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643653">
			July 2, 2008 at 10:27 am</a>		</div>

		<p>@Karellen: &nbsp;&quot;This was in the days before Windows Error Reporting, so all they had to work from was the faulting address, &#8230;&quot;</p>
<p>Maybe this was also in the days before such compiler warnings were common.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643693">
				<div id="div-comment-643693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Dunn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643693">
			July 2, 2008 at 10:57 am</a>		</div>

		<p>main()</p>
<p>{</p>
<p>union { double d; unsigned char uc[sizeof(double)]; } u;</p>
<p>&nbsp;cout &lt;&lt; &quot;Bytes: &quot;;</p>
<p>&nbsp;for (int i = 0; i &lt; sizeof(u.uc); i++)</p>
<p>&nbsp; &nbsp;cout &lt;&lt; hex &lt;&lt; (unsigned) u.uc[i] &lt;&lt; &#8216; &#8216;;</p>
<p>&nbsp;cout &lt;&lt; endl &lt;&lt; &quot;Class: &quot; &lt;&lt; _fpclass(u.d) &lt;&lt; endl;</p>
<p>&nbsp;cout &lt;&lt; &quot;Double val: &quot; &lt;&lt; u.d &lt;&lt; endl;</p>
<p>}</p>
<p>prints:</p>
<p>Bytes: cc cc cc cc cc cc cc cc</p>
<p>Class: 8</p>
<p>Double val: -9.25596e+061</p>
<p>Class 8 is _FPCLASS_NN (negative normal), so a bit pattern of all 0xCC bytes is a legal value for a double. VC6 didn&#8217;t warn me about using uninitialized data, although I did get a warning on &quot;double d; cout &lt;&lt; d;&quot;</p>
<p>As for why this wasn&#8217;t caught, possibly:</p>
<ol>
<li>
<p>Devs never ran release builds (entirely possible).</p>
</li>
<li>
<p>QA never ran release builds (I hope this isn&#8217;t the case).</p>
</li>
<li>
<p>Internal machines were old enough that they didn&#8217;t support raising an exception upon encountering a SNaN.</p>
</li>
<li>
<p>Raymond said &quot;If you ask the processor to&quot; watch for SNaNs &#8211; internal machines that did support the feature had it turned off.</p>
</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-643723">
				<div id="div-comment-643723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643723">
			July 2, 2008 at 12:33 pm</a>		</div>

		<p>You can set the floating point exception behaviour by calling _controlfp. The default appears to be that all floating point exceptions are masked. However, a program can change them at any time, which affects the behaviour for the thread that changes them. Therefore something that doesn&#8217;t cause a problem in testing in one host may be a problem in another. I seem to recall that VB6 turned floating point exceptions on, or maybe I&#8217;m confusing that with the fact that all VB errors were raised with a &#8216;Floating Point Inexact Result&#8217; exception.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643753">
				<div id="div-comment-643753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe Butler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643753">
			July 2, 2008 at 12:42 pm</a>		</div>

		<p>Did internal tests always call in this order:</p>
<p>res= GetInfo(AVERAGE_GLOB_SIZE, &amp;intResult, &amp;dblResult);</p>
<p>res= GetInfo(NUMBER_OF_GLOBS, &amp;intResult, &amp;dblResult);</p>
<p>where real world use might end up calling for num_of_globs first?</p>
<p>I.e. was the local dblValue simply the same point on the stack as when it was last used and was loaded with valid data.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643763">
				<div id="div-comment-643763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anthony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643763">
			July 2, 2008 at 12:48 pm</a>		</div>

		<p>Mike</p>
<p>The best bit is when something else that gets loaded into your process decides to call _controlfp on your behalf, like a certain printer driver did, whenever you loaded up the print settings.</p>
<p>As a result I had to abandon any hope of having control of floating point exceptions, as I couldn&#8217;t predict when this would have been called.</p>
<p>That one&#8217;s only beaten by someone I used to work with who thought it was a good idea to call setlocale in DllMain in response to DLL_PROCESS_ATTACH in a COM server. &nbsp; So your program worked fine until you loaded any object in his library.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643783">
				<div id="div-comment-643783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643783">
			July 2, 2008 at 1:27 pm</a>		</div>

		<p>Anthony,</p>
<p>I had a project a few years back that suffered from the same problem you had with a third-party DLL resetting the control word when hooking into my app. I contacted Microsoft&#8217;s support people and found out that DLLs created by Microsoft compilers prior to VS 2003 will automatically reset the floating point control word when loaded.</p>
<p>I think this exchange happened shortly after VS 2003 came out, so there were a lot of existing DLLs out there that had this problem. I bet there are still a lot of DLLs out there that have this problem. So it&#8217;s a small consolation, but your printer manufacturer was probably not being lazy or malicious.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643803">
				<div id="div-comment-643803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643803">
			July 2, 2008 at 1:55 pm</a>		</div>

		<p>&quot;Why wasn&#8217;t this problem caught in internal testing?&quot;</p>
<p>Huh, I know VS used to set uninitialized vars to 0 in debug mode, but I would have thought it would get hit in Release mode&#8230;unless they were testing with a Debug build.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643823">
				<div id="div-comment-643823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miles Archer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643823">
			July 2, 2008 at 2:22 pm</a>		</div>

		<p>Why wasn&#8217;t this caught in testing?</p>
<p>Perhaps it wasn&#8217;t reproduceable and considered a fluke that would never happen in production.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643833">
				<div id="div-comment-643833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DriverDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643833">
			July 2, 2008 at 2:23 pm</a>		</div>

		<p>&quot;Why wasn&#8217;t this problem caught in internal testing?&quot;</p>
<p>Maybe they didn&#8217;t do enough testing. Assuming their product was even moderately successful, more customers will be using their product for much more time than their testers ever did.</p>
<p>The last part is important: how much time do testers use an app before restarting it (or the computer), compared to real-world usage where the app could be running for hours or days at a time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643853">
				<div id="div-comment-643853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.henning.makholm.net/' rel='external nofollow' class='url'>Henning Makholm</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643853">
			July 2, 2008 at 2:33 pm</a>		</div>

		<p>One source of trouble here is the model of having the FP exception mask (and rounding control bits, etc) be a piece of global state that &quot;acts at a distance&quot; on all FP computations. It simply does not scale to applications that are put together from libraries of different origin &#8212; i.e. every nontrivial program.</p>
<p>Yes, that is how the hardware works, but C is enough of a high-level language that this detail should not be exposed to the programmer. Not many programmers consciously sets out to write a function that implements a complex floating-point computation using whatever rounding control for its intermediate results the caller has set up.</p>
<p>In an ideal world, programmers would specify exactly which FP behavior they wanted for which piece of code (using pragmas or whatnot), and the compiler would enforce the FPU state whenever control may reach FP code from an unknown location.</p>
<p>Unfortunately, in the real world this would probably be too much of a performance liability to sit well with numeric computing people. The i386&#8217;s FLDCW instruction does not appear to be designed to be used that heavily. It ought to have had a fast single-byte variant with an immediate argument &#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643863">
				<div id="div-comment-643863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643863">
			July 2, 2008 at 2:49 pm</a>		</div>

		<p>BTW, this is the same reason why copying memory by treating it as floating point numbers do not work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643873">
				<div id="div-comment-643873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SomeUser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643873">
			July 2, 2008 at 3:32 pm</a>		</div>

		<p>Anthony Wieser: i think you got it reversed. NAN is any floating point number with exponent=0xff. those are split into two categories:</p>
<p>(1) non signaling NAN &#8211; mantissa=0</p>
<p>(2) signaling NANs (notice there are many) &#8211; mantissa != 0. in fact you pass an error code in the mantissa bits (it was designed like this).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643643">
				<div id="div-comment-643643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643643">
			July 2, 2008 at 10:20 am</a>		</div>

		<p>Never mind testing, how did it pass check-in? The compiler should have warned against the use of an uninitialised variable. Why didn&#8217;t it? If it did, why was the warning not properly investigated?</p>
<div class=post>[<i>Many people turn off <a href="http://msdn.microsoft.com/en-us/library/aa733920.aspx" rel="nofollow">warning C4701</a> because it generates false positives on code like this: </p>
<pre>void f(int i, int *p)
{
 int j;
 if (i) j = 1;
 if (i) *p = j;
}
</pre>
<p>-Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643683">
				<div id="div-comment-643683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anthony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643683">
			July 2, 2008 at 10:42 am</a>		</div>

		<p>I once tried to use SNAN&#8217;s on purpose, but couldn&#8217;t for the life of me get it to work. &nbsp;</p>
<p>The spec seems to be:</p>
<p>An SNaN is a NaN with the most significant fraction bit clear. It is used to signal an exception when used in operations. SNaN&#8217;s can be handy to assign to uninitialized variables to trap premature usage. </p>
<p>Given this structure of a float with 1 byte packing,</p>
<p>// @struct IEEE_FLOATREP | allows bit access to 4 byte floats</p>
<p>typedef struct ieee_floatrep</p>
<p>{</p>
<p>	unsigned low_mantissa:16;	// @field low 16 bits of mantissa</p>
<p>	unsigned high_mantissa:7;	// @field high 7 bits of mantissa</p>
<p>	unsigned exponent:8; &nbsp; &nbsp;	// @field exponent of floating point number</p>
<p>	unsigned sign:1;			// @field sign of floating point number</p>
<p>} IEEE_FLOATREP;</p>
<p>Shouldn&#8217;t this generate an SNAN?</p>
<p>// @func void | SET_SNAN | sets a number to a Not A Number (SNAN)</p>
<p>// @parm float * | t | pointer to value to set to SNAN</p>
<p>#define SET_SNAN(t) (((IEEE_FLOATREP *) t)-&gt;high_mantissa = 0x00,</p>
<p>					((IEEE_FLOATREP *) t)-&gt;exponent = 0xff)</p>
<p>I couldn&#8217;t for the life of me get it to signal, or show up in the debugger as an SNAN.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643943">
				<div id="div-comment-643943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643943">
			July 2, 2008 at 7:59 pm</a>		</div>

		<p>&quot;this is the same reason why copying memory by treating it as floating point numbers [does] not work.&quot;</p>
<p>That&#8217;s actually not entirely stupid. On 32 bit usually sizeof(long double)==16, and sizeof(unsigned long)==8, therefore fewer iterations in a simple memcpy implementation. I wonder if anyone&#8217;s actually tried and measured it (a very quick google found nothing)?</p>
<p>As for the teaser question at the end of the post, perhaps they were using a 386 without a 387 (or a 486SX), on the hypothesis there might be a difference in the software vs hardware implementation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643953">
				<div id="div-comment-643953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643953">
			July 2, 2008 at 8:11 pm</a>		</div>

		<p>@steveg: &nbsp;You might be surprised at how the compiler implements that. &nbsp;In most cases, the compiler will emit code to push the double into the FPU stack, then pop it off into the target location. &nbsp;When doing this, you have to deal with NaNs and the possibility that, when the double is extended into a long double (80-bits), it might not come back out the exact same. &nbsp;Indeed, it&#8217;s possible that it may even be slower than just copying DWORDs as some FPU instructions take many more cycles than comparable integer instructions.</p>
<p>In the end, it&#8217;s just better to use native-size unsigned integers to bulk copy data.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-643793">
				<div id="div-comment-643793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643793">
			July 2, 2008 at 1:29 pm</a>		</div>

		<p>See, if they&#8217;d prototyped it like this, no worries:</p>
<p>union int_or_double {</p>
<p> &nbsp; int _int;</p>
<p> &nbsp; double _double;</p>
<p>};</p>
<p>BOOL GetInfo(int infoType, int_or_double *intOrDoubleResult)</p>
<p>&#8230; or even better</p>
<p>BOOL GetInfo(int infoType void *intOrDoubleResult)</p>
<p>&#8230; or better still</p>
<p>BOOL GetInfo(void *mystery_input_output_argument);</p>
<p>On a more serious note, if I was implementing this function I would seriously consider making it part of the contract that the un-asked-for output parameter be NULL, and enforce that at runtime.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643963">
				<div id="div-comment-643963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Dunn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643963">
			July 2, 2008 at 8:36 pm</a>		</div>

		<p>Heh, how soon they forget. Early FPS engines squeezed out extra speed by copying memory with the FPU.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643973">
				<div id="div-comment-643973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643973">
			July 2, 2008 at 8:36 pm</a>		</div>

		<p>@Tom: Yup, I&#8217;ve no doubt it&#8217;s slower (and stupid), just curious how much slower. The routine would have to call _controlfp appropriately. And copy using pointers to long doubles. And assume it was copying multiples of sizeof(long double).</p>
<p>Reader exercise: s/void|char/long double/g in memcpy.c in crt/src and see what happens.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643993">
				<div id="div-comment-643993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643993">
			July 2, 2008 at 11:11 pm</a>		</div>

		<p>There are some memcpy() that use x86 MMX or SSE instructions, e.g., the Linux kernel.</p>
<p>Are SNAN&#8217;s unqiue to the x86 architecture? is it possible to write portable code that uses SNANs?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644033">
				<div id="div-comment-644033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rivari</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644033">
			July 3, 2008 at 12:34 am</a>		</div>

		<p>Hi;</p>
<p>what does sizeof(long double)? size of long + double? I don&#8217;t think that u can init a &quot;long double var = 0&quot;.</p>
<p>Thnx for calrifying this for me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644043">
				<div id="div-comment-644043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ultrano</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644043">
			July 3, 2008 at 12:50 am</a>		</div>

		<p>@Rivari : that&#8217;s an 80-bit float. Full-precision stuff, only slower to load and store from/to memory, but not compute. Dropped in later compilers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644053">
				<div id="div-comment-644053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644053">
			July 3, 2008 at 12:52 am</a>		</div>

		<blockquote><p>
  &gt; what does sizeof(long double)? size of long + double? I don&#8217;t think that u can init a &quot;long double var = 0&quot; &lt;&lt;
</p></blockquote>
<p>You should probably just try it instead of guessing, you may be surprised&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644063">
				<div id="div-comment-644063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644063">
			July 3, 2008 at 1:00 am</a>		</div>

		<p>@ultrano:</p>
<blockquote><p>
  &gt; that&#8217;s an 80-bit float. Full-precision stuff, only slower to load and store from/to memory, but not compute. Dropped in later compilers &lt;&lt;
</p></blockquote>
<p>It&#8217;s not necessarily an 80-bit float &#8211; it simply has to be able to represent at least all double values with no loss of precision (in fact a long double may end up being implemented exactly as a double). &nbsp;The standard makes no promises that long doubles computations will be as fast as computations with doubles. &nbsp;</p>
<p>Also, why would later compilers drop a type that&#8217;s in the standard (since C89)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644073">
				<div id="div-comment-644073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644073">
			July 3, 2008 at 1:42 am</a>		</div>

		<p>&quot;(in fact a long double may end up being implemented exactly as a double)&quot;</p>
<p>In fact, that is exactly what current MS compilers implement it as.</p>
<p>Back in the 16-bit days however, long double was supported as a 80-bit floating point number, which cannot be supported by SSE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-643923">
				<div id="div-comment-643923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643923">
			July 2, 2008 at 7:19 pm</a>		</div>

		<p>&quot;this is the same reason why copying memory by treating it as floating point numbers do not work.&quot;</p>
<p>Thank god! Now I understand why I shouldn&#8217;t copy memory by *treating it as floating point numbers*. I never understood that rule until now.</p>
<p>/sarcasm</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643933">
				<div id="div-comment-643933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-643933">
			July 2, 2008 at 7:25 pm</a>		</div>

		<p>Let me just say that anyone who turns off the uninitialized variable warning *for whatever reason* is a fool and deserves every last crash they&#8217;ve earned.</p>
<p>The *only* proper way to resolve this warning is:</p>
<p>void f(int i, int *p)</p>
<p>{</p>
<p> int j = 0; // &lt;- instead</p>
<p> if (i) j = 1;</p>
<p> if (i) *p = j;</p>
<p>}</p>
<p>Of course, 0 is arbitrary, it&#8217;s just as good as uninitialized, but feel free to use 0xDEADBEEF if you prefer :-).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644133">
				<div id="div-comment-644133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644133">
			July 3, 2008 at 4:36 am</a>		</div>

		<p>One convenient way to initialise a floating point NaN in C/C++ (without signalling an exception) is as follows:</p>
<p>static const union { unsigned long l; float f; } NaN = { 0x7f800000 };</p>
<p>#define NotANumber NaN.f</p>
<p>(Modify as desired for double types and adjust the bit pattern to taste for signalled/non-signalled/inf/etc. Obviously this is not portable to some 64-bit compilers.)</p>
<p>This might be perfectly obvious to some people here, but it took me a while to discover.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644143">
				<div id="div-comment-644143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dog</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644143">
			July 3, 2008 at 5:23 am</a>		</div>

		<p>Can&#8217;t we just generalise this to &quot;Uninitialised variables can be deadly&quot;?</p>
<p>Seriously. How much effort does it take to add an &#8216;= 0&#8217;, &#8216;= &quot;&quot;&#8217; or &#8216;= NULL&#8217; to the end of each variable definition and remove a whole class of difficult to debug, subtle and inconsistent bugs?</p>
<p>I like the fact that C# considers the use of an uninitialised value an error.</p>
<p>Can someone tell me if MSVC has such an option (without treating all warnings as errors)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644003">
				<div id="div-comment-644003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644003">
			July 3, 2008 at 12:16 am</a>		</div>

		<p>Interesting! memcpy implemented as a simple loop is faster using (long double*) than (char*). In debug mode it&#8217;s much faster.</p>
<p>Debug</p>
<p>&#8212;&#8211;</p>
<p>memcpy_longdbl: &nbsp;1156</p>
<p>memcpy_char: &nbsp; &nbsp; 7875</p>
<p>memcpy (stdlib): 1016</p>
<p>Release (optimised for speed)</p>
<p>&#8212;&#8212;-</p>
<p>memcpy_longdbl: &nbsp; 953</p>
<p>memcpy_char: &nbsp; &nbsp; 1625</p>
<p>memcpy (stdlib): &nbsp;984</p>
<p>The test looped 1000 times copying from one 200,000 long double heap allocated block to another on an Intel 2.13ghz Core 2 6400. Visual Studio 2003. I used the C implementation in VC&#8217;s memcpy.c as the basis for both versions.</p>
<p>By default the MS stdlib memcpy calls RTLMoveMemory. <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms803004.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/ms803004.aspx</a></p>
<p>(YMMV, I did this over a sandwich).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644023">
				<div id="div-comment-644023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pedant # 27</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644023">
			July 3, 2008 at 12:26 am</a>		</div>

		<p>@RayTrent belched thus:</p>
<p>===</p>
<p>Let me just say that anyone who turns off the uninitialized variable warning *for whatever reason* is a fool and deserves every last crash they&#8217;ve earned.</p>
<p>The *only* proper way to resolve this warning is:</p>
<p>void f(int i, int *p) {</p>
<p>int j = 0; // &lt;- instead</p>
<p>if (i) j = 1;</p>
<p>if (i) *p = j;</p>
<p>}</p>
<p>Of course, 0 is arbitrary, it&#8217;s just as good as uninitialized, but feel free to use 0xDEADBEEF if you prefer :-).</p>
<p>===</p>
<p>Agree with your &#8216;fool&#8217; comment but not your &#8216;only way to resolve&#8217; one.</p>
<p>The code Raymond provided is perfectly valid &#8211; there will be no attempt to use j unless it&#8217;s first initialized (i controls both actions).</p>
<p>It&#8217;s also fixed by replacing the if statements by a single:</p>
<p>if (i) { j = 1; *p = j;}</p>
<p>but there may have been code between the two assignments which Raymond left out for cleanliness (almost certainly since the code segment is pretty useless as-is).</p>
<p>Cheers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644223">
				<div id="div-comment-644223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Larry Lard</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644223">
			July 3, 2008 at 8:33 am</a>		</div>

		<p>Raymond&gt; Many people turn off warning C4701 because it generates false positives</p>
<p>Was there a time when you couldn&#8217;t #pragma disable a compiler warning around a piece of code that generated a false positive for that warning?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644233">
				<div id="div-comment-644233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">doynax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644233">
			July 3, 2008 at 8:40 am</a>		</div>

		<p>Another interesting point is that IEEE floats aren&#8217;t a total order, as NaNs are unordered. A fact which can wreak havoc with searching and sorting algorithms.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644243">
				<div id="div-comment-644243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">no one in particular</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644243">
			July 3, 2008 at 8:41 am</a>		</div>

		<p>Is it just me, or is the original code really bad style in changing a variable it was not asked to change?</p>
<p>NUMBER_OF_GLOBS should change only ever the int-variable, as AVERAGE_GLOB_SIZE should only touche the double result.</p>
<p>Im my hands, even the ASSERTing for valid pointers would be in the switch-clause.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jamesnt even thread-even depth-1" id="comment-644263">
				<div id="div-comment-644263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/JamesNT' rel='external nofollow' class='url'>JamesNT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644263">
			July 3, 2008 at 9:48 am</a>		</div>

		<p>@Raymond,</p>
<p>I would say the bug in question was not caught in internal testing because this bug may result only after you&#8217;ve used the program a sufficient amount of time.</p>
<p>JamesNT</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644103">
				<div id="div-comment-644103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anthony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644103">
			July 3, 2008 at 2:54 am</a>		</div>

		<p>Well, eventually I&#8217;ve managed to track down what&#8217;s going on.</p>
<p>It appears that for an SNAN to work the value of the mantissa needs the high bit clear, but also the mantissa must be non-zero to be called a signalling NAN. &nbsp;Unhelpfully, the debugger always shows them as QNAN&#8217;s.</p>
<p>The correct definition is:</p>
<p>// @func void | SET_SNAN | sets a number to a Not A Number (SNAN)</p>
<p>// @parm float * | t | pointer to value to set to SNAN</p>
<p>#define SET_SNAN(t) (((IEEE_FLOATREP *) t)-&gt;high_mantissa = 0x01,</p>
<p>((IEEE_FLOATREP *) t)-&gt;exponent = 0xff)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jamesnt even thread-even depth-1" id="comment-644353">
				<div id="div-comment-644353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/JamesNT' rel='external nofollow' class='url'>JamesNT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644353">
			July 3, 2008 at 10:32 am</a>		</div>

		<p>@Dog</p>
<p>&quot;Seriously. How much effort does it take to add an &#8216;= 0&#8217;, &#8216;= &quot;&quot;&#8217; or &#8216;= NULL&#8217; to the end of each variable definition and remove a whole class of difficult to debug, subtle and inconsistent bugs?&quot;</p>
<p>Apparently, it is considerably difficult. &nbsp;The vast majority of programming I do is on programs I have &quot;inherited&quot; and I can tell you with harsh conviction that I see uninitialized variables all the time. &nbsp;Another major problem I see is a serious lack of error checking. &nbsp;For example, no error checking in the class that handles the connection to the Access database of an application. &nbsp;If the Access database isn&#8217;t there or is otherwise unavailable (i.e. think file share) then the user gets some criptic error message from VB6 or C++ that they will never understand in a million years instead of a nice dialog box that says &quot;Error: Database unavailable. &nbsp;Please ensure the comuter containing the database is available and connected to the network&quot; or other message meant for human consumption.</p>
<p>JamesNT</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644403">
				<div id="div-comment-644403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644403">
			July 3, 2008 at 12:33 pm</a>		</div>

		<p>In C++ you can get similar problems with instance variables, eg if there is a assignment operator or copy constructor that copies each member. (I believe I&#8217;ve seen this for compiler-generated functions, but it can certainly happen for hand-crafted ones.)</p>
<p>It&#8217;s slightly harder to initialise instance variables. You have to update each constructor, every time you add one. It&#8217;s not just &quot;=0&quot; at the point of declaration.</p>
<p>In most other situations, an uninitialised local variable is a sign that its scope is too big (it should have a defined value whenever it is in scope), which in turn suggests the function is too big and/or incoherent (in the technical sense). GetInfo() is doing several different things at once.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644203">
				<div id="div-comment-644203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644203">
			July 3, 2008 at 8:14 am</a>		</div>

		<p>There have been proposals to default-initialize ints *unless explicitly requested*.</p>
<p>Ie you&#8217;d have to write</p>
<p>int a = __uninitialized;</p>
<p>switch (b) {</p>
<p> &nbsp;case 1: a = 7; break;</p>
<p> &nbsp;case 2: a = 5; break; </p>
<p> &nbsp;/* &#8230; */</p>
<p>if you did not want the overhead of int a;</p>
<p>Old code would of course still compile, at a slight decrease in speed. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-644533">
				<div id="div-comment-644533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644533">
			July 3, 2008 at 8:42 pm</a>		</div>

		<blockquote><p>
  You have to update each constructor, every time you add one.
</p></blockquote>
<p>Is this true? &nbsp;Can&#8217;t you do</p>
<p>class CFoo {</p>
<p>int _1;</p>
<p>int _2;</p>
<p>&#8230;</p>
<p>int _n;</p>
<p>public:</p>
<p>CFoo() : _1(0), _2(0), &#8230; _n(0) {}</p>
<p>CFoo(double d) : CFoo() { &#8230; } // automatically initializes</p>
<p>};</p>
<p>Or is this a Java-ism?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644603">
				<div id="div-comment-644603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644603">
			July 4, 2008 at 4:14 am</a>		</div>

		<p>I just know I&#8217;m going to be shouted down for this, but&#8230;</p>
<p>The problem with initialising each and every variable when you declare it is that it implies that you haven&#8217;t thought properly about how they are used.</p>
<p>Everyone (I hope) will agree that if a variable is declared and then at its first use is initialised, then technically there is no potential error in the code. It just seems to me that the &#8216;safety&#8217; argument in favour of additionally initialising such variables at declaration is suprious because real safety comes from understanding the code and *being careful*.</p>
<p>But apparently care is not seen as being of value any more in todays health-and-safety culture&#8230; :-(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644613">
				<div id="div-comment-644613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644613">
			July 4, 2008 at 5:54 am</a>		</div>

		<p>@Maurtits : It&#8217;s (still) a Java-ism. </p>
<p>The closest current C++ alternative would be </p>
<p>CFoo (double d) { *this = CFoo(); /*&#8230;*/ }</p>
<p>It does require that CFoo::operator=(CFoo const&amp;) can deal with the uninitiazed *this</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644813">
				<div id="div-comment-644813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644813">
			July 4, 2008 at 5:23 pm</a>		</div>

		<p>&gt;&gt; The problem with initialising each and every variable when you declare it is that it implies that you haven&#8217;t thought properly about how they are used &lt;&lt;</p>
<p>Unfortunately, error happen. &nbsp;Especially when code is modified later. &nbsp;With your argument assertions would be undesirable and we could go to not needing to declare variables at all and have them instantiated at first use (note that &nbsp;there are a large number of enthusiasts of dynamic languages who would agree with this &#8211; I&#8217;m not one of them).</p>
<p>Ideally, you won&#8217;t declare the variable until it&#8217;s first use, so declaration is intialization.</p>
<p>If you have to declare early, then it harms nothing to give a default initialization &#8211; if the initialization is a throwaway, the compiler will optimize it away.</p>
<div class="post">[<i>The case where the compiler raises a spurious &#8220;Possibly uninitialized variable&#8221; warning is exactly the case where it <u>won&#8217;t</u> optimize it away! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644863">
				<div id="div-comment-644863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644863">
			July 5, 2008 at 8:05 am</a>		</div>

		<p>some object oriented guy used to tell me :</p>
<p>When you encounter a &quot;switch&quot; statement something is likely to be wrong around.</p>
<p>here instead of doing a switch, we could have make a method for each types. we won&#8217;t have encounter any of theses issues. and testing would have been simpler as well.</p>
<p>cheers,</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644883">
				<div id="div-comment-644883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644883">
			July 5, 2008 at 11:45 am</a>		</div>

		<p>From Ian:</p>
<p>&quot;The problem with initialising each and every variable when you declare it is that it implies that you haven&#8217;t thought properly about how they are used.&quot;</p>
<p>But, uninitialized variables induce very impredictible bugs.</p>
<p>If you want to get the best of both worlds, initialize int variables to 0xDEADBEEF as they&#8217;re very likely to induce early detected bugs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644953">
				<div id="div-comment-644953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-644953">
			July 6, 2008 at 1:32 pm</a>		</div>

		<blockquote><p>
  &gt; [The case where the compiler raises a spurious &quot;Possibly uninitialized variable&quot; warning is exactly the case where it won&#8217;t optimize it away! -Raymond] &lt;&lt;
</p></blockquote>
<p>In that case, the code should probably be refactored or you should live with the cost of the unnecessary initialization. &nbsp;Of course there are always exceptions to rules, but I think that in general it&#8217;s worthwhile to keep compilers happy.</p>
<p>For example, in the case where the code may be part of a a critical loop so you don&#8217;t want to pay for the initialization, then clearly the code needs every cycle it can get. The fact that the compiler is issuing the spurious diagnostic is a clue that the compiler may not have determined that the 2 conditionals are equivalent, so a refactor that eliminates the message may well pay off in further optimizing your code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-645213">
				<div id="div-comment-645213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080702-00/?p=21773#comment-645213">
			July 8, 2008 at 4:17 am</a>		</div>

		<p>@mikeb: This is what I meant about being careful. I wouldn&#8217;t use an assert() to check a condition that is obvious from the code. I do use asserts &#8211; I use them mainly for checking conditions where I believe the logic of the code makes that condition necessarily true but I can&#8217;t actually &#8216;see&#8217; it directly.</p>
<p>But if some code is so complicated that you can&#8217;t easily see whether a variable is initialised before it is used, then the problem is more serious than an uninitialised variable.</p>
<p>I think you are spot on with your later comment &quot;In that case [the compiler can&#8217;t tell if a variable is initialised], the code should probably be refactored&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>