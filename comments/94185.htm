<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (15)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1262335">
				<div id="div-comment-1262335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pierre B.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262335">
			August 26, 2016 at 8:12 am</a>		</div>

		<p>I suppose the kernel could create a new critical section with a new implementation and new macros to declare them?</p>
<p>(Plus, with the advent of IoT, eventually, the kernel folks will be able to send zaps to the offending coders.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com0003bffda225a672 odd alt thread-odd thread-alt depth-1 parent" id="comment-1262345">
				<div id="div-comment-1262345" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jnm236' rel='external nofollow' class='url'>jnm236</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262345">
			August 26, 2016 at 8:29 am</a>		</div>

		<p>Just curious- what&#8217;s the main reason Microsoft tries to shield users of software from the intentional bad decisions of the software writers like depending on undocumented features with no fallback?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1262355">
				<div id="div-comment-1262355" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262355">
			August 26, 2016 at 8:44 am</a>		</div>

		<p>Many times on this blog: because you tend to depend on third party libraries that do it wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1262365">
				<div id="div-comment-1262365" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262365">
			August 26, 2016 at 9:01 am</a>		</div>

		<p>Because when MS change the implementation in a non-backward-compatible way and the software no longer works the users (at big companies with expensive licenses) aren&#8217;t going to think &#8220;oh, the software must have been breaking the rules, we&#8217;ll find a new vendor now&#8221;, they&#8217;ll think &#8220;Windows sucks, the upgrade broke all our software, we&#8217;d better tell everyone not to upgrade&#8221;. Even if you could convince them it&#8217;s not Windows&#8217; fault they *still* can&#8217;t upgrade because their software is still broken. The truth will not set them free.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-dwalker-wk even depth-3" id="comment-1262485">
				<div id="div-comment-1262485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262485">
			August 29, 2016 at 7:33 am</a>		</div>

		<p>&#8220;The truth will not set them free.&#8221;  That&#8217;s one of the best explanations of this phenomenon I have ever heard!  </p>
<p>Even if (or when) the users fully understand that they can&#8217;t upgrade to a newer version of Windows *because* of bad decisions made by the ISVs, if their line-of-business software can&#8217;t handle an upgrade, then the users STILL cannot upgrade.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1262385">
				<div id="div-comment-1262385" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262385">
			August 26, 2016 at 1:10 pm</a>		</div>

		<p>Not to mention the flood lawsuits that would be generated accusing Microsoft of deliberately breaking compatibility for anticompetitive reasons.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1262395">
				<div id="div-comment-1262395" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262395">
			August 26, 2016 at 1:14 pm</a>		</div>

		<p>And before you say &#8220;But it is the ISVs that screwed up!&#8221; &#8211; yes, we know that. But will a jury understand that? Is it worth the costs of litigating and bad publicity?</p>
<p>Smarter for Microsoft and better for end users to just deal with the compat hacks.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1262445">
				<div id="div-comment-1262445" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262445">
			August 28, 2016 at 6:48 am</a>		</div>

		<p>Even ignoring large corporations or assigning blame, if everything works fine in Windows n and half your programs break with Windows N+1 are you going to upgrade to the newest windows release?</p>
<p>I certainly wouldn&#8217;t without good reason and as vista demonstrated there&#8217;s many people out there who are fine with an older OS version.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1263585">
				<div id="div-comment-1263585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Gilbert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1263585">
			September 4, 2016 at 5:20 pm</a>		</div>

		<p>One possible solution: When introducing a new feature, implement its underlying data storage two different ways from the very beginning. Each time e.g. InitializeCriticalSection is called, it picks one at random. With each Windows upgrade, replace one of the two possible data storage layouts. Document that you will do this. Do not document the layouts themselves. If this were done across the board, it would become common knowledge that you can&#8217;t depend on the underlying storage of system structures documented as opaque. The only question is, is that extra work (and extra bit/byte of storage in the data structures) worth the gain? I personally have to lean toward, &#8220;Probably, yes&#8221; :-) Having developers that don&#8217;t respect boundaries clearly makes a *big* difference to what you can and can&#8217;t do as the OS evolves.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-3" id="comment-1263826">
				<div id="div-comment-1263826" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1263826">
			September 6, 2016 at 8:37 am</a>		</div>

		<p>Back in the early days, developers were keenly sensitive to the number of cycles it took to perform an EnterCriticalSection. Articles were written about how few cycles it took to enter an uncontended lock. Adding an additional test and branch would have caused people to freak out.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1262425">
				<div id="div-comment-1262425" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Richard Barrell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262425">
			August 27, 2016 at 10:36 am</a>		</div>

		<p>Thank you for the explanation. The POSIX threads standard has a similar caveat that implementations are permitted spurious wakeups when sleeping on condition variables. I previously had no idea why. Your write up here illuminates why the pthreads standard&#8217;s authors too would have felt the need to allow spurious wakeups from condvars.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1262475">
				<div id="div-comment-1262475" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ariel Ben-Yehuda</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262475">
			August 29, 2016 at 5:12 am</a>		</div>

		<p>So WaitOnAddress is implemented half in userspace and half in kernelspace, unlike Linux&#8217;s similar futex(2) API?</p>
<p>The futex(2) implementation inserts itself to the hash table and checks for waiters within the kernel, so this kind of spurious wakeup should not happen.</p>
<p>However:<br />
    1) typically, you have to check your condition again under a lock, so spurious wakeups do not matter.<br />
    2) signals still &#8220;spuriously&#8221; wake you up.<br />
    3) there is the self-synchronized destruction problem.</p>
<p>The self-synchronized destruction problem has several variants, most classically appears when a refcount is protected by a lock. Suppose that `obj` is owned by 2 threads, with a refcount of 2, and both execute the code</p>
<p>&#8220;`<br />
    lock(&amp;obj-&gt;lock);<br />
    if(&#8211;obj-&gt;refcount) {<br />
        unlock(&amp;obj-&gt;lock);<br />
    } else {<br />
        unlock(&amp;obj-&gt;lock);<br />
        free(obj);<br />
    }<br />
&#8220;`</p>
<p>If `unlock` is inlined, this becomes</p>
<p>&#8220;`<br />
    lock(&amp;obj-&gt;lock);<br />
    if(&#8211;obj-&gt;refcount) {<br />
        obj-&gt;lock = LOCK_UNLOCKED;<br />
        WakeByAddressSingle(&amp;obj-&gt;lock);<br />
    } else {<br />
        obj-&gt;lock = LOCK_UNLOCKED;<br />
        WakeByAddressSingle(&amp;obj-&gt;lock);<br />
        free(obj);<br />
    }<br />
&#8220;`</p>
<p>And execution can progress as<br />
&#8220;`<br />
thread 0:<br />
    lock(&amp;obj-&gt;lock);<br />
    if(&#8211;obj-&gt;refcount) {<br />
        obj-&gt;lock = LOCK_UNLOCKED;<br />
thread 1:<br />
    lock(&amp;obj-&gt;lock); // finishes because obj-&gt;lock is unlocked.<br />
    if(&#8211;obj-&gt;refcount) {<br />
        obj-&gt;lock = LOCK_UNLOCKED;<br />
        WakeByAddressSingle(&amp;obj-&gt;lock);<br />
        free(obj);<br />
thread 0:<br />
        WakeByAddressSingle(&amp;obj-&gt;lock); // use after free!<br />
&#8220;`</p>
<p>The problem is that a thread must wake a lock *after* it allows for the lock to be taken, which allows another thread to free it. The &#8220;use-after-free&#8221; occurs in the *kernel*, so it can&#8217;t crash the user program. However, if the lock is reused, the next lock&#8217;s owner will see a spurious wakeup.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1262625">
				<div id="div-comment-1262625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1262625">
			August 30, 2016 at 7:53 am</a>		</div>

		<p>Um, futex is also implemented half in userspace and half in kernelspace. The &#8220;u&#8221; stands for &#8220;userspace&#8221; after all. (Userspace manipulates the integer, and then calls into kernelspace if waiting or waking is necessary.) Confusingly, the syscall is also called &#8220;futex&#8221; even though it really should be called &#8220;futexk&#8221;. Another solution to the problem you describe above is to call WakeByAddress before releasing the lock. It is explicitly permitted to call Wake while holding the lock.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1263085">
				<div id="div-comment-1263085" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1263085">
			September 1, 2016 at 4:19 pm</a>		</div>

		<p>I tried to figure out what was going on here; unfortunately I discovered the documentation is somehow wrong; WaitOnAddressSingle is somehow not in kernel32.dl in Windows 10l (in desperation tried GetProcAddress and got NULL back). Maybe it&#8217;s only in synchronization.lib; in which case the docs need some real improvement.</p>
<p>Either way this code is wrong and the solution is as follows:<br />
lock(&amp;obj-&gt;lock);<br />
unlock(&amp;obj-&gt;lock);<br />
if (InterlockedAdd(&amp;obj-&gt;refcount, -1) == 0) free(obj);</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1263095">
				<div id="div-comment-1263095" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160826-00/?p=94185#comment-1263095">
			September 1, 2016 at 4:30 pm</a>		</div>

		<p>On readback I typed it wrong here. My code does GetProcAddress(hKernel32, &#8220;WakeByAddressSingle&#8221;);</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>