<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (33)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-579253">
				<div id="div-comment-579253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.technoid.se' rel='external nofollow' class='url'>Technoid</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579253">
			December 20, 2007 at 10:30 am</a>		</div>

		<p>Actually on Cool &amp; Quiet enabled cpu&#8217;s, a low prioritized thread won&#8217;t get all of the cpu since the C&amp;Q function will throttle back the cpu to its lowest frequency.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579263">
				<div id="div-comment-579263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579263">
			December 20, 2007 at 10:41 am</a>		</div>

		<p>Technoid: I don&#8217;t think that&#8217;s the case. &nbsp;C&amp;Q (or Intel Speedstep) will throttle down the CPU if it&#8217;s idle. &nbsp;Simple as that. &nbsp;I doubt the CPU has any way to distinguish low-priority thread consuming 100% CPU time vs. high-priority thread doing the same. &nbsp;I&#8217;m not even sure the CPU has any concept of &quot;thread&quot;; that&#8217;s an OS abstraction.</p>
<p>&lt;rant&gt;Anyone else dislike how Windows essentially lets a thread of priority N starve if there&#8217;s a thread of priority N + 1 running? &nbsp;If everyone made their background work threads low-priority, this would probably be fine, but too often I find I have to manually reduce an application&#8217;s priority in Task Manager in order to unfreeze another app. &nbsp;IMHO, giving a priority-N+1-thread proportionally more CPU time than a priority-N thread, but letting both run, would work a lot better&#8230; probably make a single-core machine feel more like a dual-core machine, even.&lt;/rant&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579273">
				<div id="div-comment-579273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Huang</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579273">
			December 20, 2007 at 10:51 am</a>		</div>

		<p>Low priority thread says &#8211; All your cpu are belong to us.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579283">
				<div id="div-comment-579283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579283">
			December 20, 2007 at 11:28 am</a>		</div>

		<p>JS,</p>
<p>Have you given it a try in Vista? In my experience, Vista is much more responsive in situations where XP would be basically halted. (Especially when threads are stalled waiting for I/O.)</p>
<p>Of course I&#8217;m not sure what combinations of programs are doing this to you, it only happened very, very rarely to me in XP and usually it was over and done before I could get task manager opened anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579303">
				<div id="div-comment-579303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579303">
			December 20, 2007 at 11:50 am</a>		</div>

		<p>JS: I think the CPU speed scaling is under the control of the OS, not the hardware, so it can make a distinction based on the priority of the process using the CPU.</p>
<p>Last time I ran Linux on a laptop (Centrino SpeedStep capable), there was a runtime-settable option for whether the CPU speed control treated niced (low-priority) processes as &quot;active&quot; or &quot;idle&quot;.</p>
<p>My Macbook hides the details from me, but I would be surprised if it doesn&#8217;t do something similar; for both MacOS and Windows, if it doesn&#8217;t, I&#8217;m pretty sure that&#8217;s a design decision and not a hardware limitation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579313">
				<div id="div-comment-579313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579313">
			December 20, 2007 at 11:56 am</a>		</div>

		<p>&#8216;Anyone else dislike how Windows essentially lets a thread of priority N starve if there&#8217;s a thread of priority N + 1 running?&#8217;</p>
<p>I thought that the OS temporarily boosted thread priorities to ensure that this didn&#8217;t happen. According to this page, the adjusted priority is called dynanmic priority:</p>
<p><a rel="nofollow" target="_new" href="http://www.microsoft.com/technet/prodtechnol/windows2000serv/reskit/prork/pred_ana_umwv.mspx?mfr=true" rel="nofollow">http://www.microsoft.com/technet/prodtechnol/windows2000serv/reskit/prork/pred_ana_umwv.mspx?mfr=true</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579323">
				<div id="div-comment-579323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579323">
			December 20, 2007 at 12:53 pm</a>		</div>

		<p>Pretty much all process accounting mechanisms compute a process&#8217; CPU time based on what fraction of available cycles it consumes. That means if your 2.5GHz CPU lowers its speed to 1MHz in power-save mode, your low-priority process that uses 1M cycles in 1 second will be charged with 100% of the CPU time even though it used only 0.04% of all cycles that the CPU is capable of.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579333">
				<div id="div-comment-579333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579333">
			December 20, 2007 at 1:07 pm</a>		</div>

		<p>There have been times I swear a Below Normal process has been hogging the CPU causing my Normal and above processes to hang. &nbsp;Of course I&#8217;ve never been able to catch it, since it even slows down Process Explorer&#8217;s launching sequence to a crawl so by the time ProcExp has launched the rogue process has stopped eating the CPU. &nbsp;It&#8217;s infuriating.</p>
<p>I suppose it could be due to no I/O scheduling in XP. &nbsp;Vista isn&#8217;t really an option for me because it runs too slow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579343">
				<div id="div-comment-579343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579343">
			December 20, 2007 at 1:16 pm</a>		</div>

		<p>Please don&#8217;t forget that the idle thread in the Idle pseudo process is a thread as well &#8211; if it rans, the CPU will switch down speed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579353">
				<div id="div-comment-579353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wesha</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579353">
			December 20, 2007 at 1:33 pm</a>		</div>

		<p>&gt; You paid for that CPU. There&#8217;s no point withholding it just out of spite.</p>
<p>To the contrary, Microsoft conveniently forgot about that philosophy in Vista, and has no problem running software I don&#8217;t want on CPU I paid for. (Read: DRM).</p>
<div class=post>[<i>Thank you for turning a technical argument into a political one. Allow me to rephrase. &#8220;There&#8217;s no point forcing part of it to sit idle when there&#8217;s stuff it could be doing.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579453">
				<div id="div-comment-579453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Darrell Bennington</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579453">
			December 20, 2007 at 2:17 pm</a>		</div>

		<p>This reminds me of one of the first multi-threading projects I worked on. &nbsp;The software I was working on gave differing views of some test data off of what was basically a packet sniffer, some of the views very high level overviews that had to sift through quite a bit of data for even a screen full. &nbsp;A background thread was created with low priority as soon as the file was downloaded to pre-process the info. &nbsp;One of our users started complaining that the fan on her laptop would turn on when using the software with the latest version &#8211; no other problems with speed or sluggishness. &nbsp;We eventually figured out that it was this background thread using all the CPU when nothing higher priority was running.</p>
<p>Personally, I thought this was a good compliment to how well it worked &#8211; the only way she knew it was even running was the fans would kick on &#8211; management sided with her and the background thread turned into something that needed to be explicity launched by the user.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579483">
				<div id="div-comment-579483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jenkilmer@gmail.com' rel='external nofollow' class='url'>JenK</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579483">
			December 20, 2007 at 3:13 pm</a>		</div>

		<p>&quot;Priority merely controls which threads get first dibs on CPU time, but if you arrange so that your thread is the only one who wants to run, then it get all the CPU. The chicken at the bottom of the pecking order gets to eat all it wants if no higher-rank chickens are around. You paid for that CPU. There&#8217;s no point withholding it just out of spite.&quot;</p>
<p>I&#8217;m amazed that you&#8217;ve maintained that dry sense of humor while living in the Northwet. &nbsp;</p>
<p>Thanks for the laugh. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579493">
				<div id="div-comment-579493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Cook</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579493">
			December 20, 2007 at 3:16 pm</a>		</div>

		<p>I don&#8217;t care about politics, so I&#8217;m going to skip the DRM comment. :)</p>
<p>[&#8220;There&#8217;s no point forcing part of it to sit idle when there&#8217;s stuff it could be doing.&#8221; -Raymond]</p>
<p>Well, there&#8217;s one point. I run a NetBurst CPU still ( P4 Prescott 3.2GHz, yeah yeah yeah I know I&#8217;m obsolete&#8230; ) and some times I want to be able to bubble the pipeline with HLT instructions for thermal management reasons. Like when my thermal compound stopped working. In order to keep the CPU from going into thermal failure I had to use WinDBG to break into all processes that wanted to spend 100% of the CPU, including the low-priority ones, to keep the proc from going from 20 degrees to thermal failure in a minute thirty flat. I did eventuallly get that fixed when an Amazon box arrived, but in the meantime&#8230;</p>
<p>Granted, it&#8217;s a very nonstandard use case. But it would make sense to have such a feature in the scheduler so that in situations when the processor cannot throttle down the OS can.</p>
<div class=post>[<i>I can see the scathing reviews already. &#8220;We kicked off a background spellcheck, and it took three times as long on Windows&nbsp;n+1 than on Windows&nbsp;n. It takes a certain type of programming genius to make something suck that much.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579513">
				<div id="div-comment-579513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Sowul</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579513">
			December 20, 2007 at 3:30 pm</a>		</div>

		<p>Netburst had built in thermal management to throttle the clock if it was overheating.</p>
<p><a rel="nofollow" target="_new" href="http://www.intel.com/cd/channel/reseller/asmo-na/eng/support/support_faq/tech/242783.htm" rel="nofollow">http://www.intel.com/cd/channel/reseller/asmo-na/eng/support/support_faq/tech/242783.htm</a></p>
<p>(Among many other references &#8211; Tom&#8217;s hardware had a video of it in action. &nbsp;They removed the CPU cooler entirely while playing a game. &nbsp;The Pentium 4 would slow down, the Pentium III would lock up, and the Athlon XPs went up in smoke.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579523">
				<div id="div-comment-579523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jimbo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579523">
			December 20, 2007 at 5:02 pm</a>		</div>

		<p>Before people complain about thread scheduling in Win32, be sure you&#8217;re read up on dynamic thread priority adjustments and how the run queue works. &nbsp;Remember that the kernel threads to page memory in and out from the pagefile have a higher priority than most processes &#8212; thus, a low-level process may need a lot of pages from disk, and higher-priority threads are blocked during the access. &nbsp;And, learn the difference between an I/O-bound thread and a CPU-bound thread. &nbsp;Win32&#8217;s scheduling algorithm makes a lot more sense when you understand all the issues it&#8217;s attempting to solve.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579563">
				<div id="div-comment-579563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hobie-wan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579563">
			December 20, 2007 at 8:50 pm</a>		</div>

		<p>I remember similiar confusion in a thread about games and upgrading PCs a few years ago before video cards were handling much of the polygonal calculation. Some person was complaining that 3D game X was always consuming 100% of their processor, so they bit the bullet and upgraded their processor. They were complaining that it still took 100% of their processor, thinking that it should only take say 66% since it was 1 1/2 times faster. They couldn&#8217;t seem to grasp that the processor was always going to peg at 100% to give them the smoothest experience possible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579593">
				<div id="div-comment-579593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TraumaPony</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579593">
			December 20, 2007 at 9:42 pm</a>		</div>

		<p>It could be worse; it could be in an infinte loop :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579603">
				<div id="div-comment-579603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Day</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579603">
			December 21, 2007 at 1:28 am</a>		</div>

		<p>Darrell, your background process could have been set to a default cap of say 10% of CPU use, controlled by the application. So 100% CPU available, still uses 10% max and the fan never starts. Also a good idea to check whether the computer is on battery power and do no work if it is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579613">
				<div id="div-comment-579613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Day</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579613">
			December 21, 2007 at 1:34 am</a>		</div>

		<p>Hobie-wan, the game designers should appreciate that the user wanted them to not use all of the CPU for the game and went so far as to spend lots of money to try to achieve that result. The user might have other tasks to run or might prefer a quiet computer with temperature-controlled fans not running at full speed and annoying other family members, say.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579663">
				<div id="div-comment-579663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579663">
			December 21, 2007 at 4:50 am</a>		</div>

		<p>&quot;Hobie-wan, the game designers should appreciate that the user wanted them to not use all of the CPU for the game and went so far as to spend lots of money to try to achieve that result.&quot;</p>
<p>Providing a max-fps setting makes sense.</p>
<p>It&#8217;s not good to have an old game running at 3000 fps and eating 50% of your CPU while you&#8217;ve background tasks (compressing files or other tasks). If max-fps could be set to 120, the game would still be perfectly smooth, but would eat less than 2% of the CPU, giving more CPU time to other threads.</p>
<p>I don&#8217;t even count those un-cooperative fixed frame-rate games spending their sleeping time in empty loops eating as much CPU as they can.</p>
<p>Even if Windows is a pre-emptive multitasking OS, some level of cooperation can improve system performances.</p>
<p>However, I guess that this specific game wasn&#8217;t &quot;old&quot; and so could really run smoother thanks to the new CPU. Going from 30 fps to 50 fps is a Good Thing(TM).</p>
<p>PS: I find it funny that there are people who look at the system monitor and cry whenever more than 50% of their RAM or CPU is eaten. Some of them wish that there were an OS option to limit the amount of RAM and CPU taken to 50% of the available amount (slowing down their entire system).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579583">
				<div id="div-comment-579583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579583">
			December 20, 2007 at 9:38 pm</a>		</div>

		<p>The real tragedy is that the majority of programs use 100% of your CPU *INEFFICIENTLY*.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579673">
				<div id="div-comment-579673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">neerajsi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579673">
			December 21, 2007 at 6:14 am</a>		</div>

		<p>@Gabe:</p>
<p>I believe it&#8217;s much more complicated than that in Windows and it&#8217;s one of those nasty intersections of changing hardware and software behaviors. &nbsp;Until Vista there was no cycle-based CPU accounting, so I believe it was done off of the clock tick counter (10 ms granularity), but I&#8217;m not absolutely sure.</p>
<p>Now there is cycle counting, but some CPUs change the rate of cycle counting depending on the power state of the processor, and it&#8217;s simply not worth the hassle of keeping track of the current value per-processor in a synchronized manner. &nbsp;To make a long story short, the scenario you&#8217;re talking about (100% cpu but throttled down) probably can&#8217;t actually happen and wouldn&#8217;t be displayed that way. &nbsp;</p>
<p>Newer processors actually may actually promise to keep the timestamp counter running at its nominal speed regardless of CPU power state. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579683">
				<div id="div-comment-579683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579683">
			December 21, 2007 at 10:04 am</a>		</div>

		<p>Won&#8217;t your low priority thread tend to increase its working set at the expense of swapping out all your waiting high-priority threads, which then have to wait even longer so that they can be swapped back in again?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579753">
				<div id="div-comment-579753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Cook</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579753">
			December 21, 2007 at 11:24 am</a>		</div>

		<p>[I can see the scathing reviews already. &#8220;We kicked off a background spellcheck, and it took three times as long on Windows n+1 than on Windows n. It takes a certain type of programming genius to make something suck that much.&#8221; -Raymond]</p>
<p>Good point. Kernel flag off by default then?</p>
<p>@Mark:</p>
<p>I have a 540J, which supports HT technology and PAE/NX, but not EM64T nor SpeedStep.</p>
<div class="post">[<i>Seems awful strange to spend all that effort to add a scheduler feature only to leave it off by default. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579853">
				<div id="div-comment-579853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579853">
			December 21, 2007 at 1:09 pm</a>		</div>

		<p>[I can see the scathing reviews already. &quot;We kicked off a background spellcheck, and it took three times as long on Windows n+1 than on Windows n. It takes a certain type of programming genius to make something suck that much.&quot; -Raymond]</p>
<p>Searching for something is memory bound, not a CPU bound. The CPU would be idle for half of its cycles anyway waiting for data from RAM.</p>
<p>&quot;Remember that the kernel threads to page memory in and out from the pagefile have a higher priority than most processes &#8212; thus, a low-level process may need a lot of pages from disk, and higher-priority threads are blocked during the access.&quot;</p>
<p>Isn&#8217;t the I/O scheduler in Vista supposed to fix precisely this kind of problem ? Also, if threads are blocked because of disk access, it&#8217;s accessing the disk synchronously, which no OS on earth does anymore.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579903">
				<div id="div-comment-579903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579903">
			December 21, 2007 at 2:46 pm</a>		</div>

		<blockquote><p>
  [I can see the scathing reviews already. &quot;We kicked off a background spellcheck, and it took three times as long on Windows n+1 than on Windows n. It takes a certain type of programming genius to make something suck that much.&quot; -Raymond]
</p></blockquote>
<p>beats burnmarks on my thighs. Of course I&#8217;m some sort of freak &#8211; I want a laptop that lasts a long time, has a decent screen, etc, but doesn&#8217;t need to be all that fast.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579963">
				<div id="div-comment-579963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">idler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579963">
			December 21, 2007 at 3:31 pm</a>		</div>

		<p>Is it even possible for software to throttle back the cpu when executing instructions? I supposed that the cpu didn&#8217;t throttle back when executing instructions other than hlt.</p>
<p>The scheduler could maybe interleave the instructions from the low priority thread with hlts somehow, or maybe executing the thread every other second, but I guess that would not be easy or compatible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-580083">
				<div id="div-comment-580083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-580083">
			December 21, 2007 at 6:35 pm</a>		</div>

		<blockquote><p>
  Is it even possible for software to throttle back the cpu when executing instructions? I supposed that the cpu didn&#8217;t throttle back when executing instructions other than hlt.
</p></blockquote>
<p>Sure &#8211; that&#8217;s how clock scaling works.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-580123">
				<div id="div-comment-580123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-580123">
			December 21, 2007 at 7:54 pm</a>		</div>

		<blockquote><p>
  Seems awful strange to spend all that effort to add a scheduler feature only to leave it off by default.
</p></blockquote>
<p>Isn&#8217;t that how majority of Windows features work? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-580133">
				<div id="div-comment-580133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hobie-wan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-580133">
			December 21, 2007 at 7:58 pm</a>		</div>

		<p>&quot;However, I guess that this specific game wasn&#8217;t &quot;old&quot; and so could really run smoother thanks to the new CPU. Going from 30 fps to 50 fps is a Good Thing(TM).&quot;</p>
<p>Exactly. This was around Quake 1 and Half-Life 1. &nbsp; So it also meant Windows 98, some people still doing software rendering, and trying to crunch numbers while you gamed wasn&#8217;t a Good Thing&#174;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579923">
				<div id="div-comment-579923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jimbo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-579923">
			December 21, 2007 at 3:09 pm</a>		</div>

		<p>&quot;Isn&#8217;t the I/O scheduler in Vista supposed to fix precisely this kind of problem ? Also, if threads are blocked because of disk access, it&#8217;s accessing the disk synchronously, which no OS on earth does anymore.&quot;</p>
<p>I don&#8217;t know Vista well enough to comment on that.</p>
<p>I wasn&#8217;t saying there was synchronous I/O. &nbsp;The threads that are blocked are the normal priority threads, which are higher than the low-priority thread causing the demand paging, but lower than the kernel threads actually fetching the page.</p>
<p>A low-priority thread could inadvertantly demand a page in. &nbsp;Or, imagine the thread demanding hundreds of pages in (or out!) &nbsp;The CPU time the high-priority kernel threads needed to read/write from the disk would block even a normal-priority thread. &nbsp;If it was synchrounous I/O, yes, that would be numbskull, but then the kernel threads would block more often, relinquishing control more often. &nbsp;But because they work on non-blocking I/O, that means they&#8217;re going to stay *busier* manipulating pages &#8212; keeping lower priority threads on the pending queue.</p>
<p>We&#8217;re not talking hours of wait time here, only that the NT architecture has this sort of behavior, and it seems a bit perverse at first blush.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-580233">
				<div id="div-comment-580233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-580233">
			December 23, 2007 at 12:41 am</a>		</div>

		<p>The thing is still broken in Vista. There are a few unrelated changes, but it basically works the same.</p>
<p>The right way to do it is to dynamically lower the priority of the threads that are hogging the CPU.</p>
<p>The way Windows does it doesn&#8217;t make sense, and &quot;feels&quot; much worse in terms of responsiveness the moment there&#8217;s CPU pressure.</p>
<p>I/O scheduling has nothing to do with this. If a thread gets blocked for I/O, another thread can be executed immediately on the CPU. That&#8217;s certainly not new in Vista. I/O scheduling just lets you prioritize I/O requests.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-580423">
				<div id="div-comment-580423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.nikvoronin.com/2007/12/25/pochemu-potok-zaxvatyvaet-100-cpu/' rel='external nofollow' class='url'>?????? ???????????????????????? &raquo; Blog Archive &raquo; ???????????? ?????????? ?????????????????????? 100% CPU?</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071220-00/?p=24093#comment-580423">
			December 24, 2007 at 4:13 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.nikvoronin.com/2007/12/25/pochemu-potok-zaxvatyvaet-100-cpu/" rel="nofollow">http://www.nikvoronin.com/2007/12/25/pochemu-potok-zaxvatyvaet-100-cpu/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>