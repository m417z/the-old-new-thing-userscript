<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (17)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-623613">
				<div id="div-comment-623613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623613">
			April 24, 2008 at 11:09 am</a>		</div>

		<p>I&#8217;m sure that the basics of what you are saying is documented in MSDN. &nbsp;However, I&#8217;ve always been the type of person who understands things better knowing the &quot;why&quot;.</p>
<p>Of course, with pure contract programming, why isn&#8217;t really important.</p>
<p>Thanks for the info.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-623623">
				<div id="div-comment-623623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623623">
			April 24, 2008 at 11:21 am</a>		</div>

		<p>I think that understanding &quot;Why&quot; helps you truly understand the &quot;What&quot;, and makes you less likely to inadvertently make mistakes. &nbsp;You&#8217;re also probably more likely to guess correctly in areas where the contract isn&#8217;t well-defined.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-623643">
				<div id="div-comment-623643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623643">
			April 24, 2008 at 11:30 am</a>		</div>

		<p>That, combined with the fact that STA threads are required to pump messages, is why non-UI threads should be MTA, while UI threads should be STA. Unfortunately Visual Studio .NET defaults to STA even for console apps.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-623663">
				<div id="div-comment-623663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623663">
			April 24, 2008 at 11:52 am</a>		</div>

		<p>&#8220;Compatibility with this ancient model still exists today, thanks to the dreaded &#8220;main&#8221; threading model.&#8221;</p>
<p>VB ActiveX DLLs and controls used that threading model before a SP (3?) to VB 5 added support for the STA threading model.</p>
<div class=post>[<i>&#8220;The less said about that threading model the better.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-623753">
				<div id="div-comment-623753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623753">
			April 24, 2008 at 3:05 pm</a>		</div>

		<p>BTW, when was multi-threading support and the associated threading models added to COM? This is important if you are programming for Windows 95 or NT 3.5.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-623773">
				<div id="div-comment-623773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623773">
			April 24, 2008 at 3:21 pm</a>		</div>

		<p>Best explanation of the difference between STA and MTA I&#8217;ve ever read.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-623783">
				<div id="div-comment-623783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623783">
			April 24, 2008 at 5:44 pm</a>		</div>

		<p>Why is why important?</p>
<p>It depends on how your brain is wired.</p>
<p>For example, when I was getting my math degree, I had trouble remembering all those diverse formulas and rules. &nbsp;However, by understanding the theory behind them, I could always re-derive the formulas because I understood the whys. &nbsp;In many ways it provides a higher level understanding.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-623833">
				<div id="div-comment-623833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xepol</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623833">
			April 24, 2008 at 9:11 pm</a>		</div>

		<p>This is what is known as insane by design.</p>
<p>And now you all know why so few people even try to write multi-threaded code. &nbsp;If the basic synchronization and communication tasks don&#8217;t get you, strange terms and stranger design choices will.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-623853">
				<div id="div-comment-623853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623853">
			April 24, 2008 at 10:38 pm</a>		</div>

		<p>Xepol: how would you have designed multi-threaded COM in 16-bit Windows, then?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-623913">
				<div id="div-comment-623913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623913">
			April 25, 2008 at 10:25 am</a>		</div>

		<p>Xepol,</p>
<p>I&#8217;ve been doing multithreading programming for many many years. &nbsp;Yes, many new people make the mistake of trying to do the UI from non-UI threads, but that is an easy lesson to learn. &nbsp;But after you learn that lesson, the complexity of doing multithreaded code is huge compared to this lesson.</p>
<p>Complexity of multithreaded code: infinity</p>
<p>Complexity of multithreaded UI code: infinity+1</p>
<p>In other words, if people are having trouble doing multithreaded UI code, they are also going to have trouble doing multithreaded code in general. &nbsp;The UI aspect of it doesn&#8217;t add much complexity at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-623943">
				<div id="div-comment-623943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">noone in particular</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-623943">
			April 25, 2008 at 11:01 am</a>		</div>

		<p>&quot;how would you have designed multi-threaded COM in 16-bit Windows, then?&quot;</p>
<p>I would have thrown it overboard when switching to Win32 and designed something more straight.</p>
<p>But we have heard time and time again how backward comatibility right into the palaeolithic was the one fixed requirement in the design of Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-624163">
				<div id="div-comment-624163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RandyOakley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-624163">
			April 25, 2008 at 4:55 pm</a>		</div>

		<p>Multi-threaded code isn&#8217;t so hard, but you need to understand the constraints and methods used for synchronising threads. &nbsp;The Windows messaging structure doesn&#8217;t support multiple threads and the Windows GDI gets messed up when GDI objects are allocated in one thread and deleted in a different thread. So for an app to benefit from multi-threading, the primary/UI thread runs apartment threaded and the background / worker threads run multi-threaded. &nbsp;To avoid the major headaches have only the primary/UI thread pump windows messages, create windows and do GDI drawing calls. &nbsp;The background threads can churn along and but not directly update the UI. &nbsp;A simple technique I like to use for updating the UI after background threads have delivered data that can be used to update the UI is to use InterlockIncrement() to update a &quot;this bit of the use needs to be updated&quot; count. &nbsp;Back on the UI thread a timer ticks &#8212; say once every 1/30 a second and checks the &quot;this bit of the ui is dirty&quot; counts and repaints / updates the UI as needed and clears the dirty count. &nbsp;Simple, but effective.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-624223">
				<div id="div-comment-624223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">!bofh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-624223">
			April 26, 2008 at 5:44 am</a>		</div>

		<p>But polling is bad! Last time i checked, the events API can be used perfectly across threads.</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/01/24/516808.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/01/24/516808.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-624323">
				<div id="div-comment-624323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-624323">
			April 27, 2008 at 12:15 am</a>		</div>

		<p>&quot;right into the palaeolithic&quot;</p>
<p>When this stuff was designed, the palaeolithic was last week.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-624503">
				<div id="div-comment-624503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RandyOakley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-624503">
			April 28, 2008 at 12:47 pm</a>		</div>

		<p>It&#8217;s true that events can be used. &nbsp;However the are some advantanges to the simpler technquies. &nbsp; 1st of all human perception limits how frequently it is useful to update the UI &#8212; visual updates that happen more closely spaced that 1/30 will not be detetcable by the human eye. &nbsp; 2nd &#8212; &quot;poling is bad&quot; is a broad generalization &#8212; the method I&#8217;m suggesting isn&#8217;t actually poling in the typical sense. &nbsp;</p>
<p>Using an event based model &#8212; if five background tasks complete in one 1/30 second interval &#8212; the UI will get repainted 5 times. &nbsp; Using the &quot;repaint UI periodcially when marked dirty&quot; model &#8212; in the same circumstance the UI will get painted only once &#8212; as far a human observer is concerned &#8212; there is no detetable difference &#8212; but the latter approach makes more system resources availble to the background tasks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-624523">
				<div id="div-comment-624523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-624523">
			April 28, 2008 at 1:05 pm</a>		</div>

		<p>&quot;as far a human observer is concerned &#8212; there is no detetable difference &#8212; but the latter approach makes more system resources availble to the background tasks.&quot;</p>
<p>Don&#8217;t be so sure about that. Instead of haphazardly guessing how good the users&#8217; eyes are, you should use the best measurement available: The monitor refresh rate. The most efficient UI model is one where the screen is not redrawn unless there has been a change in the contents, and the most recent redraw was within the last monitor refresh. Obviously nobody would bother to implement the whole thing on their own, however if microsoft added it to a library so third parties could use it, it could be quite efficient (And would fit very neatly into the Vista window managers&#8217; double buffering scheme)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-655763">
				<div id="div-comment-655763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/andreww/archive/2008/08/11/why-your-comaddin-object-should-derive-from-standardolemarshalobject.aspx' rel='external nofollow' class='url'>Andrew Whitechapel</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080424-00/?p=22603#comment-655763">
			August 11, 2008 at 5:31 pm</a>		</div>

		<p>In general, it is important that any code in a managed Office add-in should execute on the main UI thread.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>