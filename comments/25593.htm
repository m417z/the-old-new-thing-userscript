<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (68)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-536283">
				<div id="div-comment-536283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lauren Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536283">
			August 14, 2007 at 11:03 am</a>		</div>

		<p>So in g(), the x=3 refers to the locally scoped x which doesn&#8217;t get created until later so is invalid to use at any point before it is declared? Why scope it that way (backwards to the enclosing block) if you aren&#8217;t going to allow use the var anywhere from within that block? And if you aren&#8217;t going to allow its use, why wouldn&#8217;t you default to allow the currently-valid (if not for the previously mentioned scoping rule) variable?</p>
<p>I wish I understood it. I&#8217;d probably feel a little better about myself now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536293">
				<div id="div-comment-536293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536293">
			August 14, 2007 at 11:10 am</a>		</div>

		<p>I think this is very interesting.</p>
<p>Moving from native to managed code generally means ceding control to the system to do things like memory management and controlling object lifetimes, so it seems ironic that C# gives you more precise control in the order of evaluation.</p>
<p>Of course, in C or C++ you CAN control the order when it&#8217;s important (by introducing sequence points), but you can also leave it up to the compiler to optimize when it&#8217;s not critical.</p>
<p>I understand the reasoning. &nbsp;I&#8217;m just amused because I find the result the opposite of what I&#8217;d expect.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536303">
				<div id="div-comment-536303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ytram</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536303">
			August 14, 2007 at 11:15 am</a>		</div>

		<p>Excerpt</p>
<p>&#8212;</p>
<p>int x;</p>
<p>void g()</p>
<p>{</p>
<p>&nbsp;x = 3; // error &#8211; using variable before declared</p>
<p>&nbsp;int x = 2;</p>
<p>}</p>
<p>&#8212;</p>
<p>The issue is not that you are using a variable before it&#8217;s declared, it&#8217;s that you are re-declaring &#8216;x&#8217;.</p>
<p>Fields on a class are automatically given their default value upon instantiation of a class, reference types get null, value types get their default value(0 for numeric, MinDate for DateTime, etc).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536313">
				<div id="div-comment-536313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SeanBa</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536313">
			August 14, 2007 at 11:18 am</a>		</div>

		<p>Lauren: If you intentionally wrote code like that, anyone who maintains it will despise you since two distinct variables in the same block would have the same name. If you&#8217;re reading through the code and don&#8217;t notice the new declaration you would assume both x&#8217;s refer to the same thing.</p>
<p>This will also cause you to notice a bug that might be hard to discover otherwise. Suppose you are cutting and pasting code to reorder the behavior of some block of code. If you happen to move the variable declaration below another use of the variable, C# will flag it as an error, even if a variable with the same name was declared in another scope.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ericlippert even thread-even depth-1" id="comment-536323">
				<div id="div-comment-536323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Eric+Lippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536323">
			August 14, 2007 at 11:24 am</a>		</div>

		<p>Lauren: there are two principles here.</p>
<p>1) Locals must be declared before they are used.</p>
<p>2) In a legal program, moving a local declaration which does not have a side effect (ie, an initialization) &quot;higher up&quot; in the function should not have a semantic impact.</p>
<p>Suppose we did it your way, and we had:</p>
<p>void M() {</p>
<p>// 30 lines of code</p>
<p>x = 10;</p>
<p>// 30 lines of code</p>
<p>int x;</p>
<p>// 30 lines of code</p>
<p>x = 20;</p>
<p>// 30 lines of code</p>
<p>}</p>
<p>A maintenance programmer decides that she wants all the declarations at the top of the method, so she moves the &quot;int x;&quot; up to the top, and suddenly the meaning of the program changes. &nbsp;That would be bad. &nbsp;That&#8217;s exactly the kind of subtle stupid bug that we&#8217;re trying to automatically prevent.</p>
<p>Look at it this way: is there ever a really compellingly good reason to write code like that above? &nbsp;I can&#8217;t think of any. It seems like a recipe for bugs to me. A fundamental principle of the design of C# is that it leads you to write correct programs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536333">
				<div id="div-comment-536333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lauren Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536333">
			August 14, 2007 at 11:29 am</a>		</div>

		<p>Is there any benefit to giving this error instead of just implicitly moving the variable declaration up to the top of the block and quietly doing what the programmer intends?</p>
<div class=post>[<i>C# is not JScript. JScript is the &#8220;quietly do what the programmer probably meant&#8221; language. C# is the &#8220;do what the&nbsp;programmer wrote&#8221; language.&nbsp;-Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536343">
				<div id="div-comment-536343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536343">
			August 14, 2007 at 11:42 am</a>		</div>

		<p>Raymond, there is a positive side effect to everyone assuming what you write is formal documentation: &nbsp;If you ever want to force an implementation one way just say it&#8217;s implemented like that and MS will be mad but have to comply.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536353">
				<div id="div-comment-536353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lauren Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536353">
			August 14, 2007 at 11:46 am</a>		</div>

		<p>The programmer wrote, though, to assign 3 to x, the only x available at that point in time being the class member.</p>
<p>Eric&#8217;s statement &quot;A fundamental principle of the design of C# is that it leads you to write correct programs&quot; makes this type of language rule understandable. It just knocked me for a loop looking at what is seemingly valid code that throws a compiler error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536383">
				<div id="div-comment-536383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymoose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536383">
			August 14, 2007 at 12:16 pm</a>		</div>

		<p>A question on your example F(i) + G(i++) * H(i): the breakdown implies that if G receives its parameter by reference, it receives not i, but a temporary variable that happens to be equal to i.</p>
<p>Is this actually the case, or is the assignment to temporary variables simply for clarification?</p>
<p>If it IS passed a temporary variable, what is the defined behaviour if you attempt to alter that value in G? Is it documented? (If so, you need only say so, and I&#8217;ll hopefully come across the answer once my self-edification in C# reaches the point where I feel able to comprehend the formal documentation. I&#8217;m still wrapping my mind around the object model.)</p>
<div class=post>[<i>You didn&#8217;t need to ask this question. Don&#8217;t be lazy. Think. If G() took a reference parameter, the example wouldn&#8217;t compile. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536393">
				<div id="div-comment-536393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymoose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536393">
			August 14, 2007 at 12:29 pm</a>		</div>

		<p>I honestly wasn&#8217;t trying to nitpick &#8211; I was curious. I apologize, I have a habit of tangenting off of interesting points.</p>
<p>If you want to keep all comments on topic, I&#8217;ll remember that for the future. Thanks for the response to my comment.</p>
<div class=post>[<i>It&#8217;s not that it wasn&#8217;t on topic; it&#8217;s that you already knew the answer, or should have. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536413">
				<div id="div-comment-536413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymoose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536413">
			August 14, 2007 at 12:34 pm</a>		</div>

		<p>(As your response to my comment changed between my first response to the response and this one, please ignore my earlier response. Or not. Your blog, your choice.)</p>
<p>I did think about it; I originally debated listing the possibilities I thought might happen (the function would work, but if G altered the parameter the results would be lost; an error would happen at run-time; an error would happen at compile-time), along with an explanation of why I didn&#8217;t have an obvious choice of actions (namely, I have experience with C, C++, and VB, but am still learning C#, and further, in NONE of those languages have I ever tried something quite as&#8230; odd as incrementing an operator in the middle of a function call in the middle of a calculation), but I chose to err on the side of a more concise, more readable query.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536443">
				<div id="div-comment-536443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/ericlippert/archive/2007/08/14/c-and-the-pit-of-despair.aspx' rel='external nofollow' class='url'>Fabulous Adventures In Coding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536443">
			August 14, 2007 at 12:49 pm</a>		</div>

		<p>Raymond has an interesting post today about two subtle aspects of C#: how order of evaluation in an expression</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ericlippert even thread-even depth-1" id="comment-536453">
				<div id="div-comment-536453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Eric+Lippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536453">
			August 14, 2007 at 12:58 pm</a>		</div>

		<p>Karellen: &nbsp;</p>
<p>Again, let me clarify that there are two principles here. First, that locals are always used after they are declared, and second, that the same identifier used two places in one block has the same meaning.</p>
<p>I think we have established why the second principle is sensible. You are asking why the first principle is sensible.</p>
<p>As Raymond pointed out, in JScript we implemented that declarations are logically hoisted to the top of the current scope, because JScript&#8217;s fundamental design principle is &quot;muddle on through&quot;. If the programmer does something odd, we interpret it as best we can and keep going.</p>
<p>In C#, we do NOT cleave to this design principle at all. &nbsp;The reason is to prevent misunderstandings by choosing rules that enable the developer to comprehend their program more easily. What is the compelling benefit of allowing a use before a declaration? It&#8217;s potentially confusing and has no obvious benefit, so we don&#8217;t allow it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ericlippert odd alt thread-odd thread-alt depth-1" id="comment-536463">
				<div id="div-comment-536463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Eric+Lippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536463">
			August 14, 2007 at 1:00 pm</a>		</div>

		<p>And to answer your other question, I would like very much if C# had an annotated specification. It would make my job easier.</p>
<p>However, the best you&#8217;re going to get is the blogs of people like me, Raymond, Eric Gunnerson, Wes Dyer, Mads Torgersen, Sreekar Choudhary, Charlie Calvert, etc. who discuss these design issues.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536473">
				<div id="div-comment-536473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://digioxy.com' rel='external nofollow' class='url'>Mike C</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536473">
			August 14, 2007 at 1:02 pm</a>		</div>

		<p>My own guess is that defining a strict order of evaluation makes short circuit operators possible.</p>
<p>Here&#8217;s a VB.Net example:</p>
<p>&lt;code&gt;If j &lt;&gt; 0 AndAlso i / j &gt; 5 Then&#8230;&lt;/code&gt;</p>
<p>Written as such, you shouldn&#8217;t worry about a division by zero error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536483">
				<div id="div-comment-536483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BA</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536483">
			August 14, 2007 at 1:29 pm</a>		</div>

		<p>Short circuiting is how the logical operators work in C, C++, and C# already.</p>
<p>I guess logical operators are one of the few places where C and C++ were doing sequencing. Raymond used the comma operator as an example. I&#8217;m assuming it is one of several examples.</p>
<p>Because in the section &quot;if (f(x) &amp;&amp; g(x)) { //stuff }&quot; g(x) will never execute if f(x) winds up returning a false value.</p>
<p>Since short circuiting is one of the &quot;features&quot; of the C and C++ languages, and C++ has a CLR implementation, they couldn&#8217;t realistically extend the language or not do short circuiting. So short circuiting is the way logical operators work.</p>
<p>But in VB.Classic, the logical operators didn&#8217;t short. So they introduced the &quot;AndAlso&quot; and &quot;OrElse&quot; operators to not change the expectations of VB.Classic programmers moving to VB.Net</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536503">
				<div id="div-comment-536503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536503">
			August 14, 2007 at 1:31 pm</a>		</div>

		<p>BA &gt; Yes, &amp;&amp; and || define sequence points in C and C++.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536533">
				<div id="div-comment-536533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536533">
			August 14, 2007 at 1:41 pm</a>		</div>

		<p>Karellen: It makes the use of stack space consistent. If a local variable&#8217;s lifetime didn&#8217;t extend to the start of a function it&#8217;s possible that a stack requirement might vary based on the execution path taken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536553">
				<div id="div-comment-536553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536553">
			August 14, 2007 at 1:56 pm</a>		</div>

		<p>Karellen:</p>
<p>The fact that the scope of a local variable extends to the beginning of the block it&#8217;s in even though you can&#8217;t reference it is useful in the situation where the local variable name hides another variable in an enclosing scope.</p>
<p>If you look at Raymond&#8217;s example:</p>
<p>int x;</p>
<p>void g()</p>
<p>{</p>
<p>&nbsp;x = 3; // error &#8211; using variable before declared</p>
<p>&nbsp;int x = 2;</p>
<p>}</p>
<p>}</p>
<p>Without the &#8216;enclosing scope&#8217; rule, the &quot;x = 3&quot; expression would be valid and would access the global x. &nbsp;The designers of C# wanted to prevent that because it was something that sometimes caused bugs, and the use of that type of &#8216;delayed&#8217; name hiding was not a tremendous benefit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536573">
				<div id="div-comment-536573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.soulsphere.org/' rel='external nofollow' class='url'>Simon Howard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536573">
			August 14, 2007 at 2:08 pm</a>		</div>

		<p>I think the question is more, &quot;why doesn&#8217;t C explicitly specify the order of evaluation?&quot;. &nbsp;The C standard has a number of things that aren&#8217;t defined, because doing so makes the language more flexible. &nbsp;When you&#8217;re writing a compiler, you can choose the path that&#8217;s most optimised for the architecture. &nbsp;For example, there might conceivably be some processor architecture out there where it is more efficient to have f() * g() evaluate g() first (although I can&#8217;t think why this would be).</p>
<p>With C#, you&#8217;re always running on the CLR anyway, so you&#8217;re always compiling down to the same &quot;architecture&quot;. &nbsp;It&#8217;s not like C where you can generate different assembly for different architectures &#8211; you&#8217;re always generating IL. &nbsp;So there&#8217;s no longer any reason for any ambiguity. &nbsp;Indeed, ambiguity leads to problems, so it&#8217;s better to specify it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536603">
				<div id="div-comment-536603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536603">
			August 14, 2007 at 2:40 pm</a>		</div>

		<p>Interesting stuff :)</p>
<p>Always love these kinds of blog posts.</p>
<p>I was struggling with this unintentionally a few weeks back (bad naming &#8211; was good it did this), so it seems very poetic to me that you touched on it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536613">
				<div id="div-comment-536613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536613">
			August 14, 2007 at 2:40 pm</a>		</div>

		<p>mikeb &gt; But according to Raymond&#8217;s post (and as brought up in my original query) you can&#8217;t have one variable shadow another anyway.</p>
<p>Even if you could use x before it were declared, your particular program <em>still</em> wouldn&#8217;t compile as you&#8217;d get an &quot;inner x shadows outer x&quot; (or whatever the message is) error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536643">
				<div id="div-comment-536643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.vacant-nebula.com/' rel='external nofollow' class='url'>Kip</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536643">
			August 14, 2007 at 3:41 pm</a>		</div>

		<p>This reminds me of C++/Java difference in scope of for-loop variables (I&#8217;m not sure about C#, I&#8217;ve never used it).</p>
<p>In C++, if you write:</p>
<p>for (int i = 0; i &lt; x; i++)</p>
<p>&nbsp;foo(i);</p>
<p>It gets compiled as if you wrote this:</p>
<p>int i = 0;</p>
<p>while (i &lt; x) {</p>
<p>&nbsp;foo(i);</p>
<p>&nbsp;i++;</p>
<p>}</p>
<p>Which means that you can&#8217;t do this:</p>
<p>for (int i = 0; i &lt; x1; i++)</p>
<p>&nbsp;foo1(i);</p>
<p>for (int i = 0; i &lt; x2; i++)</p>
<p>&nbsp;foo2(i);</p>
<p>Because there will be a compile error since the second loop redeclares i in the same scope. &nbsp;In Java, however, the i only has the scope of the loop, so that last block of code would compile just fine. &nbsp;I would guess the C# language designers made the same improvement, as it also avoids some subtle errors by forcing you to declare the variable outside of the loop if you actually intend to use it that way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536653">
				<div id="div-comment-536653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536653">
			August 14, 2007 at 3:43 pm</a>		</div>

		<p>As someone who maintains other people&#8217;s C/C++ code, I welcome these changes. Maybe we won&#8217;t get any more of this:</p>
<p>{</p>
<p>&nbsp; &nbsp;HRESULT hr;</p>
<p>&nbsp; &nbsp;(&#8230;)</p>
<p>&nbsp; &nbsp;if (bla) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;hr = DoThis(&#8230;);</p>
<p>&nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;// block copied from elsewhere&#8230;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;HRESULT hr = DoThat(&#8230;);</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;return hr;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536663">
				<div id="div-comment-536663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wolf Logan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536663">
			August 14, 2007 at 3:43 pm</a>		</div>

		<p>Karellen &#8211;</p>
<p>The &quot;no shadowing&quot; rule only applies to locals. In Raymond&#8217;s example, the &quot;x&quot; that would be shadowed is a class member, and it&#8217;s legal (although frowned upon) to shadow class members with locals. That exact situation is why the scoping rules say that locals scope from the beginning of the block, so that anywhere within a block, a variable name will be unambiguous.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536683">
				<div id="div-comment-536683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pingpong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536683">
			August 14, 2007 at 3:48 pm</a>		</div>

		<p>@Kip:</p>
<p>which C++ compiler and what settings are you using?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536693">
				<div id="div-comment-536693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel Colascione</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536693">
			August 14, 2007 at 3:57 pm</a>		</div>

		<p>Kip, that&#8217;s an unfortunate bug in some older C++ compilers (and in Microsoft&#8217;s current one, by default, due to backwards compatibility constraints.) The standard itself specifies Java-like rules for for-loop variable scoping.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536703">
				<div id="div-comment-536703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pingpong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536703">
			August 14, 2007 at 4:02 pm</a>		</div>

		<p>@Daniel COlascione:</p>
<p>If by current Microsoft compiler you mean the one included in VS 2005, then &quot;Force conformance in for loop scope&quot; is set to &quot;Yes&quot; by default.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536713">
				<div id="div-comment-536713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.vacant-nebula.com/' rel='external nofollow' class='url'>Kip</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536713">
			August 14, 2007 at 4:23 pm</a>		</div>

		<p>Sorry I didn&#8217;t track down the source, I know I first learned about the behavior on Visual Studio 6.</p>
<p>At work the C++ code I&#8217;m writing has to compile with VS 2005 on Windows, and it also has to compile for AIX and Solaris. &nbsp;I&#8217;m honestly not sure what the compiler settings are (we have build tools to handle all that for us&#8211;all I have to do is type &quot;mkmk&quot; on a console). &nbsp;I&#8217;d guess they enabled that setting to maintain back-compatibility when we moved from VS6 to VS.net then to VS 2005, or to maintain cross-compatibility with the Unix compilers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536253">
				<div id="div-comment-536253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536253">
			August 14, 2007 at 10:18 am</a>		</div>

		<p>Uh &#8211; hang on. If shadowing variables is now allowed and i cannot shadow i, how come x can shadow x? The outer x is declared in the block defining &#8220;class A&#8221;, so should overlap the x in A::g.</p>
<p>Shouldn&#8217;t it? Or have I misread something?</p>
<p>Second, if the scope of a variable covers the whole block, not just from the point of declaration, why can&#8217;t you do:</p>
<p>class A {</p>
<p>&nbsp;void f() {</p>
<p>&nbsp; &nbsp;x = 3;</p>
<p>&nbsp; &nbsp;int x;</p>
<p>&nbsp;}</p>
<p>}</p>
<p>Doesn&#8217;t the fact that that doesn&#8217;t work mean that the variable&#8217;s scope *does* begin only at the point of declaration? If not, what does saying that a variable&#8217;s scope begins at the start of the block mean? How is it different from it&#8217;s scope starting at the point of declaration?</p>
<p>*confused*</p>
<div class=post>[<i>Don&#8217;t be lazy. I&#8217;m not going to do your homework for you. Read the C# language specification. Section 5.1.7 (&#8220;Local Variables&#8221;) will be useful. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536723">
				<div id="div-comment-536723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536723">
			August 14, 2007 at 5:30 pm</a>		</div>

		<p>Wolf &gt; Ah! Now it makes sense!</p>
<p>Sorry, I assumed that the shadowing rules might be in some way consistent or logical. My bad.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536733">
				<div id="div-comment-536733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wolf Logan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536733">
			August 14, 2007 at 5:56 pm</a>		</div>

		<p>Karellen &#8211;</p>
<p>The shadowing rules are indeed consistent and logical, although they may not appear so unless you recognise the breadth of the CLR.</p>
<p>You can shadow class members with locals because they represent different categories of storage. The name &quot;x&quot; bound to a local is different from the name &quot;x&quot; bound to a member (which is in turn different from &quot;x&quot; bound to a static member). Therefore the compiler can distinguish between them, allowing shadowing to occur.</p>
<p>Two different locals named &quot;x&quot; would require some kind of context-binding, though, which doesn&#8217;t exist in C#. Therefore it&#8217;s forbidden to introduce a new local variable with the same name as an existing one &#8212; the compiler wouldn&#8217;t have a good way to distinguish between them, and providing such a mechanism would lead to enabling a questionable (if not downright felonious) programming practice.</p>
<p>Incidentally, this is related to the rules for member shadowing in derived classes. Check the spec in section 3.7.1 (<a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/aa691133" rel="nofollow">http://msdn2.microsoft.com/en-us/library/aa691133</a>(VS.71).aspx).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536423">
				<div id="div-comment-536423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536423">
			August 14, 2007 at 12:47 pm</a>		</div>

		<p>OK, I&#8217;ve read the relevant section of the spec.</p>
<p>So, the spec says: &#8220;[The] lifetime extends from entry into the [block] with which it is associated, until execution of that [block] ends in any way.&#8221;</p>
<p>Also: &#8220;Within the scope of a local variable, it is a compile-time error to refer to that local variable in a textual position that precedes its local-variable-declarator.&#8221;</p>
<p>I still don&#8217;t get what the point is of saying that the lifetime of the variable extends from the start of the block, if the variable can&#8217;t be referenced before its textual declaration. I don&#8217;t see the difference between that, and just saying that the lifetime of the variable is from its declaration until the end of the enclosing block.</p>
<p>Like Lauren, I&#8217;d have thought that if the lifetime of the variable truly covered the whole block, then all declarations should act &#8220;as-if&#8221; they were placed at the very start of the block, before any statements, no matter where they actually were in the source.</p>
<p>With Eric&#8217;s test code, again, if the &#8220;x&#8221;&#8216;s lifetime was in fact the whole block, I don&#8217;t see why moving the declaration to the top of the block would actually change the meaning of the program.</p>
<p>Why must local variables be declared before they&#8217;re used if their lifetime extends to before the point where they&#8217;re actually declared?</p>
<p>Or, why can&#8217;t variables be used at any point in their lifetime?</p>
<p>Does this make any sense? Coming from a C and C++ background, do I have some completely off-base notion of &#8220;lifetime&#8221;?</p>
<p>*still confused*</p>
<p>Heh. Alternatively, does the C# spec have a corresponding rationale document? :)</p>
<div class=post>[<i>That lifetime != visibility should not be that much of a shock to a C or C++ programmer: </p>
<pre>void F()
{
 int i;
 { int i; }
}
</pre>
<p>The lifetime of the outer &#8220;i&#8221; is the entire function F, even though it is not visible in the inner block. As I noted in the article, the rationale is to remove certain classes of programming errors. -Raymond</p>
<p></i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536753">
				<div id="div-comment-536753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GregM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536753">
			August 14, 2007 at 7:54 pm</a>		</div>

		<p>Kip, as others have described, this was a bug in VC++ 6. &nbsp;In VS2003 (and maybe 2002, never used it) you could enable certain warnings to make it behave like this. &nbsp;In VS2005, you can set an option to make it behave like this, and the default for new projects is to make it behave like this. &nbsp;I believe that converted projects use the old behavior, but I&#8217;m not 100% sure about that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536493">
				<div id="div-comment-536493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536493">
			August 14, 2007 at 1:30 pm</a>		</div>

		<p>&quot;You are asking why the [principle that locals are always used after they are declared] is sensible.&quot;</p>
<p>Close, I&#8217;m asking why that principle is sensible *if* a variable&#8217;s lifetime extends to before the point where it is declared.</p>
<p>I don&#8217;t get how the part of the spec that says that a variable&#8217;s lifetime extends back to the start of the block has any actual meaning. I don&#8217;t see how it makes the language any different from having the lifetime of the variable start at it&#8217;s declaration.</p>
<p>The only meaning I /can/ extract from variable lifetime extending back to the start of the block is that the variable should be usable before its declaration.</p>
<p>Personally, I think that you should only be able to use a variable after it&#8217;s been declared. That makes sense. That works how I&#8217;d expect things to work. But why extend the lifetime of variables to before their declaration? That&#8217;s what I don&#8217;t get.</p>
<p>Sorry for taking a while to explain things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536523">
				<div id="div-comment-536523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536523">
			August 14, 2007 at 1:40 pm</a>		</div>

		<p>&gt;&gt; However, the best you&#8217;re going to get is the blogs of people like me, Raymond, Eric Gunnerson, Wes Dyer, Mads Torgersen, Sreekar Choudhary, Charlie Calvert, etc. who discuss these design issues. &nbsp;&lt;&lt;</p>
<p>Uh-oh, Eric. &nbsp;You may have just undone months of effort that Raymond has made to ensure that his blog is *not* seen as a reference. &nbsp;It&#8217;s just a collection of entertaining and educational stories.</p>
<div class=post>[<i>Eric merely wrote that I tell interesting stories. I can accept that. He didn&#8217;t write, &#8220;The official Microsoft position on C# design issues can be found on the blogs of people like&#8230;&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536623">
				<div id="div-comment-536623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536623">
			August 14, 2007 at 2:46 pm</a>		</div>

		<p>&quot;When you&#8217;re writing a compiler, you can choose the path that&#8217;s most optimised for the architecture.&quot;</p>
<p>I think it&#8217;s more along the lines of &quot;when you&#8217;re writing a compiler, you can choose the implementation that&#8217;s *easiest*&quot;.</p>
<p>If you&#8217;re writing a compiler that does things recursively, it might be easiest to just have it do the &quot;rightmost&quot;/&quot;leafmost&quot; things first. If it&#8217;s more iterative, it might be easiest to do the &quot;leftmost&quot;/&quot;rootmost&quot; things first.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-536783">
				<div id="div-comment-536783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536783">
			August 14, 2007 at 11:50 pm</a>		</div>

		<p>Igor: If C++ were such a perfect language, why do we also have Java, Visual Basic, Perl, Haskell, Python, Ruby, and every other language that was developer after C++? (Not to mention updates to languages developed prior to C++: C&#8217;89, COBOL &#8217;85, Fortran &#8217;90, Smalltalk, etc)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536803">
				<div id="div-comment-536803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bobbo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536803">
			August 15, 2007 at 12:49 am</a>		</div>

		<blockquote><p>
  For example, there might conceivably be some</p>
<p>  processor architecture out there where it is</p>
<p>  more efficient to have f() * g() evaluate</p>
<p>  g() first (although I can&#8217;t think why this</p>
<p>  would be).
</p></blockquote>
<p>You could imagine a compiler that adds parallel processing for you&#8230; &nbsp;f() could be executed on one core/cpu and g() on another.</p>
<p>I&#8217;m sure &quot;for things we haven&#8217;t thought of&quot; is the major reason for leaving things unspecified.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536883">
				<div id="div-comment-536883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536883">
			August 15, 2007 at 5:11 am</a>		</div>

		<p>In particular, i is incremented before the function G is invoked although obviously the previous value of i is passed as its parameter. (I didn&#8217;t say original because I can&#8217;t tell whether F could have changed the value of i).</p>
<p>As for the VC6++ &quot;bug&quot;, ISO changed the `for&#8217; scoping rules; VC6++ simply uses the obsolete rules.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536893">
				<div id="div-comment-536893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536893">
			August 15, 2007 at 5:30 am</a>		</div>

		<p>itsadok: Yes, I was a bit confused.</p>
<p>When I learn i++/i&#8211; in school, I was told being a suffix means &quot;do it later&quot; (Although I&#8217;m wrong in remembering &quot;how late it will happen&quot;), so when I saw &quot;i++&quot; happens before G(), I thought something is wrong there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536903">
				<div id="div-comment-536903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabest</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536903">
			August 15, 2007 at 5:40 am</a>		</div>

		<p>There is one annoying thing about c#, it seems to follow the old non-standard vc way mentioned a couple of time above already, a variable declared inside for/foreach has the scope of the surrounding block too. For example this won&#8217;t compile in c#:</p>
<p>for(int i = 0; ; ) {}</p>
<p>int i = 0; // error</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536763">
				<div id="div-comment-536763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536763">
			August 14, 2007 at 11:31 pm</a>		</div>

		<p>Err&#8230; why exactly did we need C# again?</p>
<p>Was the programming in C++ *that* hard, or was the C++ itself *that* bad?</p>
<p>Someone please enlighten me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536913">
				<div id="div-comment-536913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">general</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536913">
			August 15, 2007 at 6:34 am</a>		</div>

		<p>The compiler has permission to do whatever it wants, as long as it can prove that the alternate has the same effect as the original one. Precedence of function arguments are not an exception from this rule.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536923">
				<div id="div-comment-536923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">auto</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536923">
			August 15, 2007 at 6:43 am</a>		</div>

		<p>&gt; It makes the use of stack space consistent. If a local variable&#8217;s lifetime didn&#8217;t extend to the start of a function it&#8217;s possible that a stack requirement might vary based on the execution path taken.</p>
<p>The compiler doesn&#8217;t have any constraints on when to allocate locals.</p>
<div class=post>[<i>The .locals pseudo-opcode and LocalVariables property might disagree with you. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536933">
				<div id="div-comment-536933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">c+++++c</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536933">
			August 15, 2007 at 6:47 am</a>		</div>

		<blockquote><p>
  that&#8217;s an unfortunate bug in some older C++ compilers (and in Microsoft&#8217;s current one, by default, due to backwards compatibility constraints.) The standard itself specifies Java-like rules for for-loop variable scoping.
</p></blockquote>
<p>No, the c++ standard at one point defined this behaviour, but the standard has changed recently.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536773">
				<div id="div-comment-536773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536773">
			August 14, 2007 at 11:50 pm</a>		</div>

		<p>[quote]</p>
<p>The expression F(i) + G(i++) * H(i) is evaluated as if it were written like this:</p>
<p>temp1 = F(i);</p>
<p>temp2 = i++;</p>
<p>temp3 = G(temp2);</p>
<p>temp4 = H(i);</p>
<p>return temp1 + temp3 * temp4;</p>
<p>[/quote]</p>
<p>Err&#8230; do you mean &#8220;F(i) + G(++i) * H(i)&#8221;?</p>
<p>I thought i++ is evaluated after execution of all other elements in the statement.</p>
<div class="post">[<i>&#8220;Hey, instead of doing even the slightest bit of research, I&#8217;ll just ask Raymond.&#8221; Don&#8217;t be lazy. Look it up. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536813">
				<div id="div-comment-536813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536813">
			August 15, 2007 at 12:57 am</a>		</div>

		<p>Ok, I checked the linked post. So it should be:</p>
<p>[quote]</p>
<p>The expression F(i) + G(i++) * H(i) is evaluated as if it were written like this:</p>
<p>temp1 = F(i);</p>
<p>temp3 = G(i);</p>
<p>temp4 = H(i);</p>
<p>i++;</p>
<p>return temp1 + temp3 * temp4;</p>
<p>[/quote]</p>
<p>instead because &quot;then method G is called with the old value of i&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536833">
				<div id="div-comment-536833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536833">
			August 15, 2007 at 1:05 am</a>		</div>

		<p>I&#8217;m still making it wrong&#8230; repost:</p>
<p>[quote]</p>
<p>The expression F(i) + G(i++) * H(i) is evaluated as if it were written like this:</p>
<p>temp1 = F(i);</p>
<p>temp2 = G(i);</p>
<p>i++;</p>
<p>temp4 = H(i); &nbsp;// new i</p>
<p>return temp1 + temp2 * temp4;</p>
<p>[/quote]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536943">
				<div id="div-comment-536943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536943">
			August 15, 2007 at 8:38 am</a>		</div>

		<p>gabest:</p>
<p>yes, that is because of what Raymond said earlier; any local variable declared ANYWHERE, is considered to be declared at the top of it&#8217;s scope.</p>
<p>the reasoning, again, as already stated, is to avoid bugs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-536853">
				<div id="div-comment-536853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">itsadok</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536853">
			August 15, 2007 at 3:02 am</a>		</div>

		<p>Cheong: look at Raymond&#8217;s code again, he does:</p>
<p>temp2 = i++;</p>
<p>temp3 = G(temp2);</p>
<p>Note that it&#8217;s G(temp2) and not G(i). temp2 holds the value of i *before* it was incremented. Therefore it&#8217;s equivalent to G(i++) and not G(++i).</p>
<p>Raymond: you have to cut people some slack&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536973">
				<div id="div-comment-536973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://thehungersite.com' rel='external nofollow' class='url'>AndyB</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536973">
			August 15, 2007 at 10:26 am</a>		</div>

		<p>That&#8217;s the trouble with this kind of thing, you cannot shadow<br />
variables anymore, so don&#8217;t worry about it, it&#8217;ll always be ok. Except<br />
when you can shadow variables (ie members) and you&#8217;ll get the same bugs<br />
but without really knowing to watch for them.</p>
<p>I think this kind of &#8216;fix&#8217; is reducing the skill or at least the<br />
knowledge required to be a programmer, just like in the previous blog<br />
entry having electronic cash registers are reducing the ability to add<br />
up in today&#8217;s youth! Was the ability to shadow a local variable that<br />
big a deal in old C++?</p>
<p>&#8220;A maintenance programmer decides that she wants&#8221;</p>
<p>what&#8217;s with this &#8216;she&#8217; business from MS employees? Its not correct<br />
english (where the masculine form encompasses the female, but not<br />
vice-versa) and just sounds wrong. I&#8217;d say its political correctness,<br />
but every blog seems to be written like this.</p>
<div class="post">[<i>There are cases where one might legitimately wish<br />
to shadow a member (constructors, mostly). But nobody could come up<br />
with cases where one would want to legitimately shadow a local<br />
variable. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537243">
				<div id="div-comment-537243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">austegard</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537243">
			August 15, 2007 at 12:21 pm</a>		</div>

		<p>Cheong&#8217;s confusion (an mine before I ran it in SnippetCompiler) stems from the fact that the expanded version is missing a temp variable &#8211; it really ought to be:</p>
<p>temp1 = F(i);</p>
<p>temp2 = i++;</p>
<p>temp3 = i;</p>
<p>temp4 = G(temp2);</p>
<p>temp5 = H(temp3); &nbsp;//same as H(i), but more explicitly illustrates the change from temp2 to temp3</p>
<p>return temp1 + temp4 * temp5;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-536953">
				<div id="div-comment-536953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-536953">
			August 15, 2007 at 8:39 am</a>		</div>

		<p>Karellen: Lifetime and scope can be different. &nbsp;The lifetime of the variable (the length of time that storage is allocated for it) is the entire block in which it was defined, but its scope (the lines of code that are permitted to access it) is only from the point of declaration to the end of the block.</p>
<p>You see the same thing happening with a static variable in a function in C/C++/C#: the lifetime is the same as the lifetime of the containing class (or in C, the compilation unit), but the scope is only the function. &nbsp;Would you want to be able to access a function&#8217;s static variables from another function in the same class, just because their lifetime hasn&#8217;t ended? &nbsp;I don&#8217;t. &nbsp;:-)</p>
<p>Here, the lifetime is the entire block (and in VB, the lifetime is actually the entire function for variables declared inside sub-function blocks, too: I&#8217;m not sure if C# has the same setup), but the scope just starts later.</p>
<p>Now, that doesn&#8217;t completely explain the error, though, because it&#8217;s not really a lifetime issue (that only affects runtime). &nbsp;It&#8217;s really just a scope issue. &nbsp;It happens because the scope doesn&#8217;t start until the declaration. &nbsp;I suspect the spec probably says something like &quot;the compiler searches outward block-by-block when binding a variable, starting with the block that the variable was used in; it uses the first declaration it finds; if that declaration is out of scope, it&#8217;s an error&quot; (but I don&#8217;t know that for sure, as I haven&#8217;t read the spec). &nbsp;So I&#8217;m guessing it won&#8217;t bind the variable reference to the field unless *no* local variable has the name &quot;x&quot;.</p>
<p>(And that still doesn&#8217;t provide a rationale, but the various comments here should. &nbsp;It helps with accidental bugs.)</p>
<p>As for why the lifetime should start at the start of a block (or in VB, a function), that&#8217;s when their storage is (probably?) first allocated. &nbsp;But lifetime doesn&#8217;t really have anything to do with this error message, either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537463">
				<div id="div-comment-537463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabest</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537463">
			August 15, 2007 at 5:03 pm</a>		</div>

		<p>mikey: ah, that way it makes sense now :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-537513">
				<div id="div-comment-537513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kuwanger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537513">
			August 15, 2007 at 8:09 pm</a>		</div>

		<p>Since I don&#8217;t have Raymond&#8217;s email address to ask him otherwise, I&#8217;d prefer if he didn&#8217;t make it appear that I conflate blog postings with published articles. &nbsp;But, given that this is a blog, it&#8217;s not like it matters, since one couldn&#8217;t use his blog posting as a reference to show anything anyways.</p>
<div class="post">[<i>The &#8220;published articles&#8221; are just blog postings in dead tree form. So it&#8217;s all the same. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537613">
				<div id="div-comment-537613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nathan Myers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537613">
			August 16, 2007 at 2:03 am</a>		</div>

		<p>For-loop-scoped variables in C++ don&#8217;t have Java-like scope. &nbsp;For-loop-scoped variables in Java have C++-like scope. &nbsp;(In other words, Java is mostly cribbed from early-&#8217;90s C++, before everything that made C++ particularly interesting and useful was added. &nbsp;Java omitted the sole particularly interesting pre-&#8217;90s feature, destructors. No, virtual functions aren&#8217;t interesting.)</p>
<p>The example presented works fine with a correct (i.e. non-MS) compiler. &nbsp;The local-variable scope rules have not &quot;changed recently&quot;, and are not about to change. &nbsp;Lots of other stuff is about to change, but without breaking existing programs. &nbsp;C# has cribbed some of the less interesting bits, such as &quot;auto&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-537653">
				<div id="div-comment-537653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Wenig</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537653">
			August 16, 2007 at 4:29 am</a>		</div>

		<p>people who are actively discussing that G(i++)increments i after evaluation fail to recognize the same fact for temp2 = i++. that should tell us something about the dangers of postfix increments&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537683">
				<div id="div-comment-537683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kuwanger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537683">
			August 16, 2007 at 6:21 am</a>		</div>

		<p>&#8216;[The &#8220;published articles&#8221; are just blog postings in dead tree form. So it&#8217;s all the same. -Raymond]&#8217;</p>
<p>So, TechNet Magazine is a yellow journalism rag? &nbsp;And no one<br />
should quote anything from it as a reliable source because one never<br />
knows when an article is &#8220;just blog postings in dead tree form&#8221;?<br />
&nbsp;Well, I&#8217;m glad you&#8217;ve cleared that up. &nbsp;I&#8217;ll be sure to<br />
avoid TechNet Magazine in the future.</p>
<div class="post">[<i>I&#8217;m impressed at your inability to use other cues to assess the reliability of printed information, such as tone,<br />
choice of subject matter, and distinguishing between a reporter and a<br />
columnist. Reading a newspaper must be very confusing for you. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-537703">
				<div id="div-comment-537703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537703">
			August 16, 2007 at 6:26 am</a>		</div>

		<p>Doh! One of those section numbers should be 3.11.5.1</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537713">
				<div id="div-comment-537713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537713">
			August 16, 2007 at 7:49 am</a>		</div>

		<p>BryanK: As for why the lifetime should start at the start of a block (or in VB, a function), that&#8217;s when their storage is (probably?) first allocated.</p>
<p>I think one of the things which makes the C# rule confusing for C++ programmers is that C++ has a notion of &quot;lifetime&quot; that is different to storage. In C++, the object&#8217;s lifetime begins when its constructor completes. So saying the lifetime starts at the start of the block implies the constructor is run then. I&#8217;m guessing this doesn&#8217;t matter for C# because it doesn&#8217;t have user-defined constructors for stack objects.</p>
<p>struct Demo { Demo() { cout &lt;&lt; &quot;Demon&quot;; } };</p>
<p>void func() {</p>
<p>&nbsp; &nbsp;cout &lt;&lt; &quot;Startn&quot;;</p>
<p>&nbsp; &nbsp;Demo d;</p>
<p>}</p>
<p>If the lifetime of d is moved to the start of func() the program&#8217;s output will change. In general, constructors would be a lot less useful.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-537723">
				<div id="div-comment-537723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537723">
			August 16, 2007 at 7:56 am</a>		</div>

		<p>AndyC: If a local variable&#8217;s lifetime didn&#8217;t extend to the start of a function it&#8217;s possible that a stack requirement might vary based on the execution path taken.</p>
<p>And that would be bad because&#8230;?</p>
<p>Stack space already depends on the execution path.</p>
<p>void func() {</p>
<p>&nbsp; &nbsp;if (rand()) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; char a[100];</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; stuff();</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; char a[200];</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; stuff();</p>
<p>&nbsp; &nbsp;}</p>
<p>}</p>
<p>Or imagine that each branch of the &#8220;if&#8221; came from inlining a different function.</p>
<div class=post>[<i>Compile that in your favorite C++ compiler and look at the stack usage the compiler uses. I think you&#8217;ll be surprised. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537853">
				<div id="div-comment-537853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kuwanger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537853">
			August 16, 2007 at 12:03 pm</a>		</div>

		<p>&#8216;[I&#8217;m impressed at your inability to use other cues to assess the reliability of printed information, such as tone, choice of subject matter, and distinguishing between a reporter and a columnist. Reading a newspaper must be very confusing for you. -Raymond]&#8217;</p>
<p>Now, I&#8217;m confused. &nbsp;I just went through the effort of agreeing with you, that your articles in TechNet Magazine are unreliable (&#8220;just blog postings in dead tree form&#8221;), sensationalized (you well admit: &nbsp;your blogs contain speculation, not checked facts), and are unprofessional (unless you want to start claiming that your blog is professional). &nbsp;So, what sort of reputable magazine would allow unreliable, sensationalized, unprofessional columns? &nbsp;Last I checked, those qualities fall under yellow journalism. &nbsp;Perhaps TechNet Magazine is really the computer-world version of MAD Magazine? &nbsp;Otherwise, I&#8217;m well out of ideas to explain your column.</p>
<div class=post>[<i>I guess the New York Times is also yellow journalism. They have columnists too. If you feel so strongly that an informal storytelling column besmirches the standards of a magazine, then feel free to let the editors know. (PS, there is a middle ground between &#8220;professional&#8221; and &#8220;unprofessional.&#8221; It&#8217;s called &#8220;informal.&#8221;) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-537693">
				<div id="div-comment-537693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537693">
			August 16, 2007 at 6:23 am</a>		</div>

		<p>&quot;No, the c++ standard at one point defined this behaviour, but the standard has changed recently.&quot;</p>
<p>No, the c++ standard did not change. There may have been a change between successive *drafts* of the standard, but the point of drafts is that they&#8217;re not the finished article, and are subject to change.</p>
<p>The c++ _standard_ has always mandated the current behaviour, ever since 1998 when it was ratified. Given that a change like this would not have been made between the final draft and the finished standard, it would have been introduced a while before then.</p>
<p>According to my copy of &quot;The Design and Evolution of C++&quot; the use of declarations in condition statements &quot;if (int i = foo()) { &#8230; }&quot; was introduced in 1991, and the behaviour of for() statements was later changed to match it. (sections 3.11.5.2, 3.11.5.2).</p>
<p>Given this, I think we can safely say that the &quot;for()&quot; behaviour is at least 10 years old, and has had a similar counterpart in &quot;if()&quot; statements for over 15 years. Let&#8217;s call it 1995.</p>
<p>That makes the change older than Javascript, Python 2 and ASP, and as old as Windows &#8217;95, Java, HTML 2, Ruby and PHP 2</p>
<p>That&#8217;s some strange definition of &quot;recent&quot; you&#8217;ve got.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xepol even thread-even depth-1" id="comment-538073">
				<div id="div-comment-538073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Xepol' rel='external nofollow' class='url'>Xepol</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-538073">
			August 16, 2007 at 7:04 pm</a>		</div>

		<p>Why? &nbsp;Because you could do some wickedly stupid code in C.</p>
<p>Take for example:</p>
<p>i = 0;</p>
<p>printf(&quot;%d %d %d&quot;,i,++i++,i+=49);</p>
<p>What would you expect to print out?</p>
<p>would you expect: 51 50 49</p>
<p>Start tossing function calls in that alter other parameter values used and EVERYTHING starts get a little wierd and hard to debug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538083">
				<div id="div-comment-538083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kuwanger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-538083">
			August 16, 2007 at 7:06 pm</a>		</div>

		<p>@Raymond: &nbsp;Consider, a food review column making distasteful remarks about a restaurant vs a food review column with a newspaper disclaimer of responsibility making distasteful remarks about a restaurant. &nbsp;Consider, Ann Landers put on the front page versus Ann Landers put in the advice section. &nbsp;Consider a website that reposts Ann Landers articles but doesn&#8217;t go through the bother of marking her columns as advice or, at least, disclaiming responsibility for their contents on the same page&#8211;okay, this isn&#8217;t a perfect analogy, given how well known Ann Landers is.</p>
<p>I&#8217;m at a complete loss on how to get you to consider the situation objectively. &nbsp;All I know is, I&#8217;m unwilling to endless argue against your red herrings.</p>
<div class=post>[<i>I think you&#8217;ll find that very few online versions of print media clearly call out the nature of each article. It&#8217;s left for the reader to figure out. <a href="http://seattletimes.nwsource.com/html/localnews/2003835140_brodeur14m.html" rel="nofollow">Here&#8217;s an example</a> of an opinion column with no explicit indication that it&#8217;s an opinion column. Do the opinions expressed in that article therefore establish the position of the Seattle Times newspaper? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537863">
				<div id="div-comment-537863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GregM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-537863">
			August 16, 2007 at 12:11 pm</a>		</div>

		<p>&quot;That&#8217;s some strange definition of &quot;recent&quot; you&#8217;ve got.&quot;</p>
<p>I&#8217;d give a little latitude on that, since Visual C++ 6.0 was released in 1998, and Visual C++ 5.0 was released in 1997 (at least according to my recollection and what I&#8217;m able to find on the web), so it is *possible* that it hadn&#8217;t yet been definitely extended to for() loops at the time the behavior of the compiler in those two versions was frozen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538283">
				<div id="div-comment-538283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593#comment-538283">
			August 17, 2007 at 8:28 am</a>		</div>

		<p>[Compile that in your favorite C++ compiler and look at the stack usage the compiler uses. I think you&#8217;ll be surprised. -Raymond]</p>
<p>The point remains. If the compiler choses to grow the stack once at the start instead of within each branch of the &#8220;if&#8221;, it could do the same for a variable declared in the middle of a function.</p>
<p>Also, note what I said about the code resulting from functions being inlined, and then consider what happens if they aren&#8217;t inlined. Or think of a recursive function &#8211; it will use more stackspace if it recurses deeper. Clearly stack space usage depends on code paths.</p>
<p>Finally, you&#8217;ve not answered the question: given the above, why would it be bad if the stack space used depended on code paths taken?</p>
<div class="post">[<i>It would be bad because it would be a violation of MSIL. I challenge you to write a method in MSIL that uses a variable amount of stack space. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>