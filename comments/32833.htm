<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (15)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-333473">
				<div id="div-comment-333473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333473">
			January 3, 2006 at 6:08 am</a>		</div>

		<p>I think it might be slightly clearer to novices if it weren&#8217;t for the LPxxx notation that obfuscates standard pointer types.  LPDWORD looks like an opaque type, a novice user probably doesn&#8217;t know what it means or how to decipher its name, so what else are they going to do?  The function expects an LPDWORD; if they don&#8217;t know that is, it&#8217;s not surprising if they declare an LPDWORD and pass it in directly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-rosyna odd alt thread-odd thread-alt depth-1" id="comment-333533">
				<div id="div-comment-333533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rosyna</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333533">
			January 3, 2006 at 7:00 am</a>		</div>

		<p>Indeed, why is the prototype not GetBinaryType(LPCTSTR lpApplicationName, DWORD* dwBinaryType) ? That would seem to make far more sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cornedbee even thread-even depth-1" id="comment-333553">
				<div id="div-comment-333553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CornedBee</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333553">
			January 3, 2006 at 7:33 am</a>		</div>

		<p>I believe the pointer typedefs were introduced to hide platform differences (e.g. LPDWORD was a FAR* in 16-bit), but I agree that they tend to confuse newbies.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-333733">
				<div id="div-comment-333733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Isaac Lin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333733">
			January 3, 2006 at 11:05 am</a>		</div>

		<p>I have seen plenty of buggy Unix code where the programmer blindly passed in uninitialized pointers, and inefficient code where the &quot;new&quot; solution was used (or even leaky, if the corresponding delete was forgotten). Then later programmers, seeing the precedent set by using new, proceed to do the same, causing headaches in making sure the data is deleted at the right time.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-333853">
				<div id="div-comment-333853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333853">
			January 3, 2006 at 2:04 pm</a>		</div>

		<p>Which is why MSDN should give a sample on the page.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-333493">
				<div id="div-comment-333493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://genezys.net' rel='external nofollow' class='url'>Vincent</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333493">
			January 3, 2006 at 6:25 am</a>		</div>

		<p>Actually, I often made the mistake when I started programming with Win32.</p>
<p>Obfuscating types only make the programmer so distant from the reality that you forget all about common rules. The second parameter is only a return value parameter, there is some tools in programming language to show that, out in IDL, using a reference (&amp;) in C++ and using a pointer (*) in C.</p>
<p>Using a LPDWORD instead of a DWORD* only hide the fact that this second parameter is actually a return value.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-333883">
				<div id="div-comment-333883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rick C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333883">
			January 3, 2006 at 3:26 pm</a>		</div>

		<p>Is this function really not supported under NT4, or is that a documentation failure?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-333973">
				<div id="div-comment-333973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jerry Pisk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333973">
			January 3, 2006 at 5:26 pm</a>		</div>

		<p>Maybe the newbies should read the docs instead of just looking at the prototype? It clearly says it&#8217;s a pointer to a variable to receive the information.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-334003">
				<div id="div-comment-334003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Leif</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-334003">
			January 3, 2006 at 6:07 pm</a>		</div>

		<blockquote><p>
  &quot;don&#8217;t tear your hair out trying to find some deep meaning&quot;</p>
<p>This line resonated with my experience. I&#8217;ve observed myself and others trying to find &quot;deep meaning&quot; behind the peculiar way a certain piece of code was written&#8230; but at least half the time, this is like second-guessing an idiot: the deep meaning simply isn&#8217;t there.</p>
<p>When reading code, one must always consider the possibility that the author was inexperienced or lazy (or both). As an example of laziness, I&#8217;ve seen coders who knew better introduce global variables when implementing a fix/feature, simply because that minimized the number of lines of code which had to be changed&#8230; and then years later, people would invent pseudo-sound reasons for doing it that way (&quot;using a global, rather than passing an extra parameter around to all those functions, yields faster code&quot;).</p>
<p>I love code archeology :-)
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-333703">
				<div id="div-comment-333703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-333703">
			January 3, 2006 at 10:19 am</a>		</div>

		<p>I was under the impression that the FAR modifier is simply ignored on platforms with pointers larger than 16 bits, so couldn&#8217;t they have simply required that the function recieve a &quot;DWORD FAR *&quot;?  Seems that should have worked cross-platform.</p>
<p>When I started programming and learned about the Windows API typedefs, it seemed like a great idea.  Everything is defined to have a specific size.  But now I&#8217;m not so sure.  Because Windows has changed, some of them now lie (LPARAM and WPARAM are the same size).  Plus, the P, C, etc. prefixes all define things for which keywords already exist.  At this point, I&#8217;ve decided that whoever originally designed the API was simply in love with typedefs.</p>
<p>I think it would be a great thing if Microsoft began to phase out the typedefs and switch over to more standard C++.  The typedefs could stay, for compatibility, but the examples and API could specify the standard types whenever possible, using typedefs only when a specific size is needed (e.g. DWORD/INT32), but not carrying any additional info (e.g. LPC *blech*).</p>
<p>I also think the TCHAR thing needs to go away.  UNICODE should be used universally.  The TCHAR thing is a very weak patch.  It most definitely doesn&#8217;t make the differences invisible.  If it did, I wouldn&#8217;t have to pepper my code with &quot;#IFDEF UNICODE&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-334113">
				<div id="div-comment-334113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-334113">
			January 4, 2006 at 12:34 am</a>		</div>

		<p>If you think that&#8217;s bad, I&#8217;m currently using a graphics library where the only documentation for most of it is the prototypes!<br />
<br />In most cases its fairly obvious, but the bezier curve function still eludes me&#8230; It takes arrays of x and y co-ordinates, the number of co-ordinates, the color and a mysterious &quot;int s&quot;&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-334163">
				<div id="div-comment-334163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ping?</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-334163">
			January 4, 2006 at 4:24 am</a>		</div>

		<p>This is precisely why Pascal has a &quot;var&quot; modifier for subroutine arguments&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-334183">
				<div id="div-comment-334183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-334183">
			January 4, 2006 at 5:56 am</a>		</div>

		<p>&quot;I think it would be a great thing if Microsoft began to phase out the typedefs and switch over to more standard C++. The typedefs could stay, for compatibility, but the examples and API could specify the standard types whenever possible, using typedefs only when a specific size is needed (e.g. DWORD/INT32), but not carrying any additional info (e.g. LPC *blech*). &quot;</p>
<p>For a specific version of Windows (for example Win32), every parameter has a specific size.<br />
<br />typedefing types allow to compile code with almost all compilers (not only C or C++ compilers, but also other languages which support type aliasing).<br />
<br />The idea, is that the headers, containing typedefs can be specific to the language or compiler.</p>
<p>The ISO C++ standard (and, C++ is not the only language which can use Win32 API), only says that sizeof(short)&lt;=sizeof(int)&lt;=sizeof(long), and, as the C89 standard does, requires that short integers are at least 16 bits and long integers are at least 32 bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-334563">
				<div id="div-comment-334563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-334563">
			January 4, 2006 at 10:08 pm</a>		</div>

		<p>Tuesday, January 03, 2006 10:19 AM by Derek<br />
<br />&gt; I was under the impression that the FAR<br />
<br />&gt; modifier is simply ignored on platforms with<br />
<br />&gt; pointers larger than 16 bits, so couldn&#8217;t<br />
<br />&gt; they have simply required that the function<br />
<br />&gt; recieve a &quot;DWORD FAR *&quot;? Seems that should<br />
<br />&gt; have worked cross-platform.</p>
<p>FAR doesn&#8217;t work cross-platform.  FAR is ignored on many WINDOWS platforms.</p>
<p>Wednesday, January 04, 2006 5:56 AM by SuperKoko<br />
<br />&gt; The ISO C++ standard (and, C++ is not the<br />
<br />&gt; only language which can use Win32 API),<br />
<br />&gt; only says that sizeof(short)&lt;=sizeof(int)&lt;=<br />
<br />&gt; sizeof(long),</p>
<p>I&#8217;m too lazy to look it up, but I&#8217;ll take your word for it.  Do you know offhand if such a requirement ever got into the second C standard?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-334663">
				<div id="div-comment-334663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://qstuff.blogspot.com/' rel='external nofollow' class='url'>Justin Olbrantz (Quantam</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060103-36/?p=32833#comment-334663">
			January 5, 2006 at 3:37 am</a>		</div>

		<p>You know, a few hours ago I wouldn&#8217;t have thought anyone would actually try that (getting the call to work by process of elimination). But just now I got a PM on a forum asking a question about why a call was crashing, and the problem was obviously due to them doing exactly that.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>