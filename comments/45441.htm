<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (36)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-bboorman even thread-even depth-1" id="comment-1242886">
				<div id="div-comment-1242886" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242886">
			June 5, 2015 at 7:05 am</a>		</div>

		<p>What about a /640K switch for my program? Because my program should never need more than 640KB.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242876">
				<div id="div-comment-1242876" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242876">
			June 5, 2015 at 7:08 am</a>		</div>

		<p>Having debugged a similar one, it&#39;s possible they had a similar mistake to mine: high bits of a pointer were being sheared off by some erroneous programming. Changes to 8.1 ASLR made the bug far easier to trigger. Oh and it was a Word plugin and our customers press send to Microsoft and the stack frame is hosed. The Word team must have had fun with that one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242866">
				<div id="div-comment-1242866" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242866">
			June 5, 2015 at 7:10 am</a>		</div>

		<p>The irony of that quote is that Gates never said it, and there&#39;s never been any evidence for him having ever said it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242856">
				<div id="div-comment-1242856" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242856">
			June 5, 2015 at 7:11 am</a>		</div>

		<p>Is there a reason people don&#39;t just use full-blown structs for this? &nbsp;Because I&#39;m pretty sure this is (at best) non-portable even if you do stick to the low bits. &nbsp;You can&#39;t know that the architecture is aligned in any particular way, and x86 doesn&#39;t even require proper alignment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242846">
				<div id="div-comment-1242846" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242846">
			June 5, 2015 at 7:30 am</a>		</div>

		<p>@Kevin: Pointer-sized objects can be written atomically in flat architectures.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242826">
				<div id="div-comment-1242826" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242826">
			June 5, 2015 at 7:41 am</a>		</div>

		<p>@Brian_EE: And then some unsporting person runs your program under a memory manager that borrows the VGA and MDA framebuffers to allow a whopping 736k of address space, and it doubtless fails in interesting ways. cf the &quot;Packed file is corrupt&quot; errors when DOS was loaded high.</p>
<p>@Anon: The Windows 95 resource kit does say that 2G address space is enough for any desktop application, which will sound just as ridiculous one day.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242806">
				<div id="div-comment-1242806" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242806">
			June 5, 2015 at 8:54 am</a>		</div>

		<p>If the solution to your problem involves crippling the system that should generally be a red flag that you&#39;re doing something wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1242796">
				<div id="div-comment-1242796" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242796">
			June 5, 2015 at 9:18 am</a>		</div>

		<p>Don&#39;t tag your pointers. Simple.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1221642">
				<div id="div-comment-1221642" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1221642">
			June 5, 2015 at 9:27 am</a>		</div>

		<p>@Kevin &#8211; space saving. If you&#39;ve got a value which is a pointer, and you want to store only 2 or 3 bits extra with it, then using a struct for that on a 64-bit system will double your per-value storage space to 128 bits, wasting around 60 bits/value. If you&#39;ve got a few hundred million of these values, the wasted space can really add up.</p>
<p>One notable example of this is in weakly-typed (scripting) languages, where all variables contain a &quot;value&quot; which can be of any type. Getting an efficient storage mechanism for *every single value* used by all the programs written in that language is very important. Tagged pointer, or tagged float/double values, are popular ways of achieving this. See:</p>
<p><a rel="nofollow" target="_new" href="http://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations">wingolog.org/&#8230;/value-representation-in-javascript-implementations</a></p>
<p>Rob Sayre&#39;s post &quot;Mozillaâ€™s New JavaScript Value Representation&quot; is no longer at its original home, but an archive is about 1/3 of the way down:</p>
<p><a rel="nofollow" target="_new" href="https://evilpie.github.io/sayrer-fatval-backup/cache.aspx.htm">evilpie.github.io/&#8230;/cache.aspx.htm</a></p>
<p>I also think the Linux kernel uses (used?) tagged pointers in of the large heavily used caches, like the directory entry/inode cache, or the page table tree.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242786">
				<div id="div-comment-1242786" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242786">
			June 5, 2015 at 11:43 am</a>		</div>

		<p>Before I modified our crash reporter to use a semi-documented technique to get the true Windows version number for crash reports, it reported NT 6.2 (Windows 8.0) for Windows 8.1. &nbsp;To distinguish 8.1 from 8.0, I looked in crash reports for system DLLs in the 0x00007FFFxxxxxxxx range instead of the 0x000007FFxxxxxxxx range.</p>
<p>Yesterday, I debugged a problem at first seemingly triggered by Windows 10. &nbsp;It turned out that some old code wasn&#39;t ported to 64-bit correctly, and our program on Windows 10 for some reason ends up allocating the whole lower 4 GB of address space, so the program crashed when that object got allocated above 4 GB.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1221632">
				<div id="div-comment-1221632" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1221632">
			June 5, 2015 at 12:00 pm</a>		</div>

		<p>I am not sure whether my math is correct, but 256 TB sounds like 48bits.</p>
<p>Did they put their tagging bits in the *middle*?</p>
<p>I would&#39;ve used either least significant bits or most significant bits, either way I would&#39;ve been in the clear.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242776">
				<div id="div-comment-1242776" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242776">
			June 5, 2015 at 12:25 pm</a>		</div>

		<p>@waleri: &quot;I would&#39;ve used either least significant bits or most significant bits, either way I would&#39;ve been in the clear.&quot;</p>
<p>Unless you had more than 16 flags.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242766">
				<div id="div-comment-1242766" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242766">
			June 5, 2015 at 1:38 pm</a>		</div>

		<p>The upper 16 bits of VAs are off limits anyway due to x86-64 pointer canonicalization&#8230;</p>
<div class="post">[<em>And this is precisely why people want to use them as tag bits. Because no valid pointer will use them. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242756">
				<div id="div-comment-1242756" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242756">
			June 5, 2015 at 3:26 pm</a>		</div>

		<p>Why does Windows use only 48 bits for address space on a 64-bit system?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242746">
				<div id="div-comment-1242746" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242746">
			June 5, 2015 at 3:27 pm</a>		</div>

		<p>Ooops. I should have refreshed my browser before posting that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242736">
				<div id="div-comment-1242736" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242736">
			June 5, 2015 at 5:25 pm</a>		</div>

		<p>@Myria: to get version #, extract version info from kernel32.DLL. Masking GetWindowsVersion was not very smart of MS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242726">
				<div id="div-comment-1242726" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242726">
			June 5, 2015 at 7:12 pm</a>		</div>

		<p>What happened to bending over backwards for backwards compatibility? (E.g. only using 8TB address space unless the application manifest specifies that it&#39;s Very-Large-Address-Aware)</p>
<div class="post">[<em>Can the &quot;backward compatibility for buggy apps is good&quot; commenters and the &quot;backward compatibility for buggy apps is bad&quot; commenters get into a room, and then somebody tell me who wins? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242716">
				<div id="div-comment-1242716" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242716">
			June 5, 2015 at 9:57 pm</a>		</div>

		<p>Anonymous Coward: they invented the NT kernel so that buggy applications don&#39;t take down the whole the OS when they crash, and then it&#39;s not their problem anymore</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242706">
				<div id="div-comment-1242706" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242706">
			June 6, 2015 at 4:00 am</a>		</div>

		<p>I read the linked article but I&#39;m still not clear as to what that instruction has to do with the address space limit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242696">
				<div id="div-comment-1242696" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242696">
			June 6, 2015 at 6:59 am</a>		</div>

		<p>thanks&#39;not an anon&#39; google &#39;x86-64 pointer canonicalization&#39; and the wikipedia article has a good explanation of the issues and why only 48 bits (for now)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1242686">
				<div id="div-comment-1242686" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Darran Rowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242686">
			June 6, 2015 at 5:52 pm</a>		</div>

		<p>@Neil:</p>
<p>The memory manager needs it to do its magic with paging.</p>
<p>Of course, this answer probably isn&#39;t satisfactory, but without knowing how protected mode works, more specifically memory paging, a longer answer isn&#39;t that useful.</p>
<p>If you do know about how protected mode works, then try looking at the Intel or AMD platform documents. The Intel 64 and IA-32 Architectures Software Developer Manuals and the AMD64 Architecture Programmer&#39;s Manual would be the place to look.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242676">
				<div id="div-comment-1242676" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242676">
			June 6, 2015 at 6:59 pm</a>		</div>

		<p>@John Elliott No sane Win 95 application will, at least.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242666">
				<div id="div-comment-1242666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242666">
			June 6, 2015 at 7:02 pm</a>		</div>

		<p>Neil: The basic problem is that Windows has a lock-free data structure (a singly-linked list) that requires an atomic compare-exchange operation. Although the data structure can be 128 bits, the early x64 processors could only atomically operate on 64 bits at a time. This means that all the bits of the structure that need to be changed atomically have to fit within those 64 bits.</p>
<p>The elements that need to change simultaneously are the count of entries in the list, a change counter, and a pointer to the first entry. The count of entries is documented as having 16 bits, so that&#39;s essentially hard-coded. That leaves the change counter and first entry pointer to fight it out for the remaining 48 bits.</p>
<p>Since the alignment of entries is guaranteed to be on 16-byte boundaries, the low 4 bits of the pointer will always be 0 and can be used for the change counter. However, the change counter has to be bigger than 4 bits to ensure the ability to detect changes on systems with a lot of CPUs.</p>
<p>Apparently MS decided that 9 was the minimum number of bits required for change detection, so that leaves 39 bits for the pointer. 2^39 bits yields about 500 billion pointers to unique locations, times 16 bytes per location gives you 8TB of space.</p>
<p>So why does the linked-list data structure&#39;s limit of 8TB worth of pointers require that Windows itself have the same limit? Because these linked-lists are ubiquitous throughout the OS, so being able to have a something in memory that couldn&#39;t be put in one of the lists would not be very useful.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242656">
				<div id="div-comment-1242656" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242656">
			June 7, 2015 at 4:34 am</a>		</div>

		<p>Windows 11, which will be true 64-bit, will implement the /256TB flag, for apps using only 48-bit pointers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242616">
				<div id="div-comment-1242616" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242616">
			June 7, 2015 at 4:15 pm</a>		</div>

		<p>@640k Doc Brown just turned up in the DeLorean to pick up a new hoverboard and dropped off a copy of Windows 11. He told me that where we were going, we don&#39;t need pointers. </p>
<p>In six years time we&#39;re due 128 bit cpu&#39;s (80386=1985, Opteron=2003).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jan-ringos odd alt thread-odd thread-alt depth-1" id="comment-1242606">
				<div id="div-comment-1242606" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Jan+Ringo%C5%A1' rel='external nofollow' class='url'>Jan RingoÅ¡</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242606">
			June 7, 2015 at 4:50 pm</a>		</div>

		<p>If I were to guess, based on how typical RAM size increased in servers around me over time, I would say we might get x86-64 CPUs with a few more addressing bits around the time the unix epoch rolls over, but it will then still take several more years before they are actually used for something other than releasing address space pressure or ASLR-like things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-1242596">
				<div id="div-comment-1242596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242596">
			June 7, 2015 at 6:54 pm</a>		</div>

		<p>Too back the boot option have switch to limit the CPU and max memory the applications see, but no swtich to limit the max address space it use.</p>
<p>Btw, does we have a swtch / registry value that blocks particular range(s) of address space being used, similar to what we had in EMM386.exe?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242586">
				<div id="div-comment-1242586" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242586">
			June 8, 2015 at 12:03 am</a>		</div>

		<p>With 64 Bit I can adress 16.777.216 TB of memory. Microsoft can only adress 256 TB. You should know that if you are going to use tagged pointers, you need to put your tag bits in the least significant bits, since those are bits you control.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242576">
				<div id="div-comment-1242576" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242576">
			June 8, 2015 at 1:35 am</a>		</div>

		<p>@ThomasX:</p>
<p>Correction &#8211; current x86-64 processors can only address 256TB, as they only support a 48-bit virtual address space, even though addresses are stored in 64 bits. Canonical addresses have already been mentioned in the comments.</p>
<p>You would face enormous obstacles trying to implement a 64-bit address space in any other OS running on the same processors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242566">
				<div id="div-comment-1242566" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242566">
			June 8, 2015 at 3:31 am</a>		</div>

		<p>@ThomasX You can&#39;t have 16.777.216TB of memory in any x64 hardware currently available, Intels new Skylake for example will support 64GB. Which is why 256TB of address space with 128TB for kernel and 128TB for user is a reasonable compromise. Even 48 bits of address space is only useful for address space layout randomization, not because mapping that amount of memory is practical. I don&#39;t know if Microsoft were involved in the x64 design, but they are &quot;inconvenienced&quot; the same as any OS when it comes to implementing address spaces (it&#39;s generally not a real inconvenience at all). While they are some algorithms where a full 64 bit address space would seem like a nice solution, they aren&#39;t practical as you don&#39;t have full control over the address space anyway. Inconvenient things like program and memory mapped I/O (gpu etc) all polute the address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242556">
				<div id="div-comment-1242556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242556">
			June 8, 2015 at 5:05 am</a>		</div>

		<p>@boogaloo: more like 2036. The 8080 (8bit) was 1974, The 8086 (16bit) 1978, The 80386 1985 and 64bit came 2003. Which gives a linear regression of 0.5174*Bitness+1969,5 with RÂ² of 0,9971 or just short of 2036 for 128bit (and 1971 for 4bit, which actually was the year the 4004 was released). But of course the AMD64 architecture was not released first with intel, so if we only use intel Chips for comparison it will be even later that &quot;x128&quot; is released :-)</p>
<p>Of course that&#39;s the same &quot;reasoning&quot; Mark Twain used in the following quote: &quot;In the space of one hundred and seventy-six years the Lower Mississippi has shortened itself two hundred and forty-two miles. That is an average of a trifle over one mile and a third per year. Therefore, any calm person, who is not blind or idiotic, can see that in the Old Oolitic Silurian Period, just a million years ago, next November, the Lower Mississippi River was upward of one million three hundred miles long, and stuck out over the Gulf of Mexico like a fishing-rod.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242536">
				<div id="div-comment-1242536" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242536">
			June 8, 2015 at 8:16 am</a>		</div>

		<p>256 TB ought to be enough for anybody.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1221622">
				<div id="div-comment-1221622" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">not an anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1221622">
			June 8, 2015 at 9:34 am</a>		</div>

		<p>@Raymond &#8212; while people may *want* to use them as tag bits, it doesn&#39;t mean the CPU will let &#39;em: trying to feed a noncanonical address to the CPU is documented in the AMD64 Architecture Programmer&#39;s Manual as causing a GPF (this is on print page 4 of volume 2, for those playing along at home).</p>
<div class="post">[<em>Obviously, you remove the tag before dereferencing. This can often be done at no extra cost by folding it into the addressing mode. e.g. <code>mov eax, [ebx-80000000h]</code>. Now you don&#39;t even need to test the tag bit before dereferencing: If the tag bit is not set, you AV! -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1221621">
				<div id="div-comment-1221621" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1221621">
			June 8, 2015 at 1:32 pm</a>		</div>

		<p>[Can the &quot;backward compatibility for buggy apps is good&quot; commenters and the &quot;backward compatibility for buggy apps is bad&quot; commenters get into a room, and then somebody tell me who wins? -Raymond]</p>
<p>Neither will win, because neither side is right. There&#39;s a big difference between retaining ABI compatibility when the contract changes and maintaining compatibility with those who abuse things. In this case, the number of significant bits in a pointer can be argued as part of the ABI (let someone else debate it&#8211;I will not).</p>
<p>What this customer could (probably) do is reserve *all* of the address above 8TB, then start another thread (to force stack frame below 8TB) and have the first thread wait for it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242506">
				<div id="div-comment-1242506" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242506">
			June 8, 2015 at 5:28 pm</a>		</div>

		<p>I was only asking because MS has a long history of trying to maintain compatibility with abusive programs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242386">
				<div id="div-comment-1242386" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150605-00/?p=45441#comment-1242386">
			June 9, 2015 at 4:18 pm</a>		</div>

		<p>@Anonymous Coward Mainly for important abusive programs.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>