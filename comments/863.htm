<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1126913">
				<div id="div-comment-1126913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1126913">
			May 29, 2014 at 7:17 am</a>		</div>

		<p>The vulnerability is real, but that snippet doesn&#39;t exploit it. The real vulnerability is the ability to create sufficient realtime threads to hog all CPU as an unprivileged user. This crashes the machine on the spot as even the write behind disk cache never flushes. Realtime threads should be limited to admin sessions and console sessions (not RDP sessions).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hikari odd alt thread-odd thread-alt depth-1" id="comment-1126933">
				<div id="div-comment-1126933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Chris+Crowther' rel='external nofollow' class='url'>Chris Crowther</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1126933">
			May 29, 2014 at 7:33 am</a>		</div>

		<p>Joshua: They don&#39;t even have to be real time threads to do that; I&#39;ve had AV products swallow so much CPU time just running at normal priority that you end up buttoning the system and rebooting.</p>
<p>I think Windows has the ability to impose a processor usage quota, although it&#39;s per-session so there&#39;s still a vector to screw people over. &nbsp;But then you can&#39;t really stop that entirely short of saying &quot;you can&#39;t run anything&quot;, at which point the system become kind of pointless.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126943">
				<div id="div-comment-1126943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1126943">
			May 29, 2014 at 7:36 am</a>		</div>

		<p>Recently, we ran into a situation where some commercial backup software (I won&#39;t mention the name), used 100% of the CPU for around 40 minutes each night when it started up. &nbsp;It was so bad, the NIC dropped packets and there was ZERO disk activity during that time. &nbsp;Once we tracked it down, we de-installed that software and alerted the vendor. &nbsp;They didn&#39;t seem to care too much. &nbsp;It turns out they are still using DDE to communicate between their background service and their foreground GUI.</p>
<p>That problem is NOT a Windows problem &#8212; it is 100% a case of really bad application software.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hikari odd alt thread-odd thread-alt depth-1" id="comment-1126963">
				<div id="div-comment-1126963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Chris+Crowther' rel='external nofollow' class='url'>Chris Crowther</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1126963">
			May 29, 2014 at 7:46 am</a>		</div>

		<p>That&#39;s a &quot;our codebase is old and we don&#39;t want to rewrite the code that&#39;s probably been there for nearly 30 years&quot; problem.</p>
<p>I&#39;m now just going to sit and reminisce about NetDDE and Wonderware InTouch (sometimes I miss doing industrial automation).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126973">
				<div id="div-comment-1126973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1126973">
			May 29, 2014 at 7:46 am</a>		</div>

		<p>@12BitSlab</p>
<p>But everything is a Microsoft problem&#8230; the &quot;100% Backwards Compatibility&quot; push for the worst development practices imaginable from third-parties means that Microsoft has taken responsibility for maintaining all of the bad software on Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jonathan-timssungard-com odd alt thread-odd thread-alt depth-1" id="comment-1126983">
				<div id="div-comment-1126983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/carbon+twelve' rel='external nofollow' class='url'>carbon twelve</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1126983">
			May 29, 2014 at 8:09 am</a>		</div>

		<p>@Joshua: But there&#39;s no point protecting realtime priority because it doesn&#39;t win anything: you can easily cripple windows by:</p>
<p>&gt; creating windows in a tight loop till you exhaust all the window handles on the system (note: at this point you can&#39;t open any tools to recover the system if they create windows);</p>
<p>&gt; creating processes in a tight loop till the system collapses under the weight;</p>
<p>&gt; allocating huge amounts of memory and constantly writing to random locations within it to cause a paging storm.</p>
<p>But also, there&#39;s no security vulnerability here in any real sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126993">
				<div id="div-comment-1126993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hildar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1126993">
			May 29, 2014 at 8:22 am</a>		</div>

		<p>Allowing a user with the right to execute code results in code execution. What a security risk!</p>
<p>What next, a user who can log in can log in? A local administrator can delete system32? (Actually bypassing the restrictions windows places on things in %windir% is left as an exercise for the reader. Don&#39;t try this at home^W on production kids)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127023">
				<div id="div-comment-1127023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127023">
			May 29, 2014 at 9:27 am</a>		</div>

		<p>@carbon twelve: Actually creating windows is something I&#39;ve recovered from. Ctrl+Alt+Del to spawn a new session. Each session has its own window count and handle space. On my production servers I leave windowless logins enabled and if the system can create new processes at all I can get back in and kill the offender.</p>
<p>I&#39;ve been able to use my windowless login during a paging storm so bad the console wasn&#39;t responding.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127033">
				<div id="div-comment-1127033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127033">
			May 29, 2014 at 9:28 am</a>		</div>

		<p>All kidding aside, it is of course possible to design the operating system in such a way that no process can cross particular boundaries of resource usage imposed on it. But then you&#39;re not really talking about a general desktop OS like Windows, where even measuring resource usage is an imprecise science at best, and which has to host a zoo of independent processes not explicitly designed to play nice.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127043">
				<div id="div-comment-1127043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127043">
			May 29, 2014 at 9:30 am</a>		</div>

		<p>Programs can also allocate all the memory on the system fill the page file and cause system failure in that way. &nbsp; If they are allowed to write files (temp directory?) they can exhaust all the disk space on that drive too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127053">
				<div id="div-comment-1127053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127053">
			May 29, 2014 at 9:44 am</a>		</div>

		<p>The problem isn&#39;t that a single program can consume all CPU cycles, its that the scheduler allows it to do that at the expense of every other process and cripple the system.</p>
<p>(And its an even bigger problem when Microsoft release a process critical to security &#8211; Microsoft Update &#8211; that causes that exact problem)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127063">
				<div id="div-comment-1127063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127063">
			May 29, 2014 at 9:52 am</a>		</div>

		<p>@Mc:</p>
<p>Memory Quota.</p>
<p>Disk Quota.</p>
<p>CPU Quota would also work for runaway CPU jobs if they weren&#39;t using realtime threads.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-even depth-1" id="comment-1127083">
				<div id="div-comment-1127083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127083">
			May 29, 2014 at 10:32 am</a>		</div>

		<p>I recall a professor of mine once prototyped an attack against servers on the Intel Netburst platform. The attack depended on the hyperthreading feature being enabled, the idea was that the malicious code would cause pipeline stall after pipeline stall completely bringing the machine to a halt. Although in my experience this didn&#39;t require a special attack, it just required running code&#8230; but that was an architecture problem, not an OS issue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127103">
				<div id="div-comment-1127103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">max630</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127103">
			May 29, 2014 at 10:35 am</a>		</div>

		<p>this is hardly a security poblem, but it really easy for application to make system&#39;s element unresponible. Even such microsoft software as visual studio, while starting, freezes the task panel for some seconds, and it is very annoying</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127113">
				<div id="div-comment-1127113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127113">
			May 29, 2014 at 10:58 am</a>		</div>

		<p>@Joshua: What default CPU usage quota would look like? People running numerical crunchers (aka &quot;video games&quot;) would be quite unhappy to learn they have to manually fiddle with settings to allow them to use 99% of CPU.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127153">
				<div id="div-comment-1127153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nico</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127153">
			May 29, 2014 at 11:58 am</a>		</div>

		<p>&gt; &nbsp;if I can run an arbitrary program, then I can do arbitrary things</p>
<p>Yet this didn&#39;t stop Microsoft from killing the Windows Gadget website and removing gadgets from Windows 8, just because &quot;they can run code&quot;. &nbsp;I understand the design was to replace gadgets with Metro apps in Windows 8, but that was no excuse for nuking the entire platform and ecosystem on Windows 7.</p>
<p>The advisory (<a rel="nofollow" target="_new" href="https://technet.microsoft.com/library/security/2719662">technet.microsoft.com/&#8230;/2719662</a>) could be entirely replaced with &quot;Malicious program is malicious&quot;. :(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1127173">
				<div id="div-comment-1127173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127173">
			May 29, 2014 at 12:53 pm</a>		</div>

		<p>Well, the least Windows could do is detect runaway threads and demote their priority. Unfortunately, Microsoft would rather implement another (possibly patented) kludge instead of fixing such problems.</p>
<p>Window handle space exhaustion can be alleviated by using process-local handles for non-topmost windows.</p>
<div class="post">[<em>Procses-local handles would mean that EnumChildWindows would return handles that you couldn&#39;t use. Also, the limited resource is not handles; it is desktop heap. Restricting handles is just a way to restrict heap usage. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127183">
				<div id="div-comment-1127183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127183">
			May 29, 2014 at 1:01 pm</a>		</div>

		<p>@aleqr1</p>
<p>From my experience Windows already automatically demotes process cpu priority of 100% cpu usage processes. But I am not sure if this applies when they have realtime priority.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127203">
				<div id="div-comment-1127203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127203">
			May 29, 2014 at 4:08 pm</a>		</div>

		<p>The problem isn&#39;t that a process can consume 100% CPU but that when this happens, Windows starts to handle ctrl-alt-del so badly. Out of the box, the process priorities aren&#39;t optimal, for example it would have been better if the taskbar would be running in a different process than the desktop and folder windows and if that process ran at high priority. It would also have been better if a process launched as the task manager got some special magic that normal processes don&#39;t have access to that gives the process extra high priority, higher than anything else.</p>
<p>There is a valid problem being reported here, but you need to be able to read between the lines. Yes, it is nonsensical if you take it as literally as you possibly can and then stop thinking. But if you try to look at this from the user&#39;s perspective, you understand that 100% CPU consumption is a very bad thing. And it happens. Programs have bugs that make them hang and do this. The user may not have enough technical knowledge to suggest the right cause or solution, but the problem is very valid.</p>
<div class="post">[<em>While there may be other issues here, it was reported as a security vulnerability in how Windows treats magic pixie dust. (I also shudder at the thought that some third party taskbar extension is now running at super-high priority. Not that having super-high priority really helps you any, because it will eventually block on something that isn&#39;t super-high priority.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1127213">
				<div id="div-comment-1127213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127213">
			May 29, 2014 at 4:31 pm</a>		</div>

		<p>[Procses-local handles would mean that EnumChildWindows would return handles that you couldn&#39;t use]</p>
<p>No. For an out of process caller, that needs to return only global handles.</p>
<div class="post">[<em>Okay, so you have the other problem, which is that you can&#39;t find all the windows. This breaks a lot of apps, including UI automation. Plus, as I noted, the issue is not handle exhaustion anyway. The issue is heap exhaustion. Whether or not you hide child window handles, they still occupy heap. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1127223">
				<div id="div-comment-1127223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127223">
			May 29, 2014 at 4:34 pm</a>		</div>

		<p>Task manager runs on High priority, but I think it sets the priority itself. If the box is overloaded by high priority runaway threads, it may not have an opportunity to start.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1127233">
				<div id="div-comment-1127233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127233">
			May 29, 2014 at 4:37 pm</a>		</div>

		<p>[Okay, so you have the other problem, which is that you can&#39;t find all the windows. This breaks a lot of apps, including UI automation. Plus, as I noted, the issue is not handle exhaustion anyway. -Raymond]</p>
<p>Most programs don&#39;t care about UI automation. For those special cases, the required programs could be run under some new appcompat flags.</p>
<p>For process-local windows, the desktop heap would not need to be used.</p>
<div class="post">[<em>But you have to decide ahead of time which heap to put the data in. If you put it in a per-process heap, and then somebody runs an automation app, well, now all your data are in the wrong place. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127253">
				<div id="div-comment-1127253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127253">
			May 29, 2014 at 5:55 pm</a>		</div>

		<p>[ The high priority thread must use lock-free everything to avoid blocking on low-priority threads, and you can&#39;t do that and present UI at the same time. -Raymond]</p>
<p>It&#39;s called calling CreateDC on another process&#39;s window and it&#39;s about as bad of an idea as it sounds. I&#39;ve only ever done it with the desktop window (which does NOT have clipchildren) as a joke. Not for production code if you value your sanity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127263">
				<div id="div-comment-1127263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Euro Micelli</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127263">
			May 29, 2014 at 6:02 pm</a>		</div>

		<p>&gt; @Alegr1: Most programs don&#39;t care about UI automation.</p>
<p>The moment the user needs Assistive Technology (Narrator, JAWS, etc.) every program has to care about UI Automation or it becomes unusable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-1127273">
				<div id="div-comment-1127273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127273">
			May 29, 2014 at 6:29 pm</a>		</div>

		<p>Argh&#8230; the Gadget toolbar&#8230;</p>
<p>I always want the ability to dock Modern Apps to Gadget toolbar. In that way you can effectively use the screen estate to host the kind of notification you want without using the whole screen.</p>
<p>I used to hold the CPU gadget at the upper right corner in Vista, then have memopad like application at the remaining of lower-right part of screen, and have the application I&#39;m using tiled to the remaining area on screen.</p>
<p>Btw, if you&#39;re using Win2008 or above with terminal server role and WSRM installed ( <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/rds/archive/2009/05/29/using-wsrm-to-control-rds-dynamic-fair-share-scheduling.aspx">blogs.msdn.com/&#8230;/using-wsrm-to-control-rds-dynamic-fair-share-scheduling.aspx</a> ), you can prevent non-admin process from eating up CPU resource and therefore preventing Administrator to login.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127293">
				<div id="div-comment-1127293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">immibis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127293">
			May 29, 2014 at 6:51 pm</a>		</div>

		<p>It&#39;s also a vulnerability if there is some security policy in place that normally prevents people running arbitrary programs, and the magic pixie dust circumvents it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127303">
				<div id="div-comment-1127303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127303">
			May 29, 2014 at 8:10 pm</a>		</div>

		<p>@The finder didn&#39;t seem concerned that apps can consume 100% CPU. They were concerned that pixie dust can consume 100% CPU.</p>
<p>We don&#39;t have access to your ‘finder’, so you can make him say all kinds of crazy stuff I suppose, but so far it sounds like you simply didn&#39;t understand him. Pixie dust caused 100% CPU consumption, bad things happened. If it had been something else that caused the 100% CPU consumption you&#39;d be saying that the finder was only concerned with that. Whatever.</p>
<p>@Since third party taskbar extensions run inside the taskbar, if you try to isolate them into another process, you now have cross-process input queue attachment, which is its own crazy world of hurt.</p>
<p>Then isolate them in a way that doesn&#39;t cause input queue attachment. Stop thinking in terms of problems, but in terms of solutions. Furthermore, people don&#39;t tend to run taskbar extensions. A taskbar is just a bunch of buttons and icons, it isn&#39;t that hard.</p>
<p>@Anything with UI cannot be shielded from other UI threads, because there is only one window manager. Also, there&#39;s that blah blah blah the same time.</p>
<p>Nonsense. You say it cannot be done over and over, but it is certainly possible, it just has to be implemented. Microsoft just chose not to, for whatever reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127243">
				<div id="div-comment-1127243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127243">
			May 29, 2014 at 4:50 pm</a>		</div>

		<p>@While there may be other issues here, it was reported as a security vulnerability in how Windows treats magic pixie dust.</p>
<p>I don&#39;t doubt that for a second. But if you want to interpret these reports you have to learn to read between the lines. And to stop interpreting things literally when the literal interpretation makes no sense. The people talking to you don&#39;t have the same knowledge you do, and you should be aware of that.</p>
<p>@I also shudder at the thought that some third party taskbar extension is now running at super-high priority.</p>
<p>That&#39;s why I suggested a) to run the taskbar in a different process than where most of the horrible extensions live and b) to give the task manager higher priority than everything else, including the task bar. You could even improve on point a) through sandboxing, but I feel I shouldn&#39;t even have to say that.</p>
<p>@Not that having super-high priority really helps you any, because it will eventually block on something that isn&#39;t super-high priority.</p>
<p>In practice, things that run at a higher priority are shielded quite well from ***-ups in things that run at a lower priority, so your statement that it doesn&#39;t help is simply false, as you well know.</p>
<div class="post">[<em>The finder didn&#39;t seem concerned that apps can consume 100% CPU. They were concerned that pixie dust can consume 100% CPU. Since third party taskbar extensions run inside the taskbar, if you try to isolate them into another process, you now have cross-process input queue attachment, which is its own crazy world of hurt. Anything with UI cannot be shielded from other UI threads, because there is only one window manager. Also, there&#39;s that cross-process input queue attachment. The high priority thread must use lock-free everything to avoid blocking on low-priority threads, and you can&#39;t do that <span style="text-decoration:underline;">and</span> present UI at the same time. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127363">
				<div id="div-comment-1127363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127363">
			May 30, 2014 at 5:42 am</a>		</div>

		<p>Wow! &nbsp;My security bulletin name made an actual blog entry. &nbsp;Thanks Raymond! &nbsp;(Also, MS07&#8230; long time reader.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127313">
				<div id="div-comment-1127313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Scarlet Manuka</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127313">
			May 29, 2014 at 11:36 pm</a>		</div>

		<p>@Anonymous Coward:</p>
<p>After pointing out that we have less access to the original problem submitter than Raymond, why do you claim to be in a better position to interpret the problem submitter&#39;s meaning?</p>
<p>&quot;Isolate them in a way that doesn&#39;t cause input queue attachment.&quot; Well, if they&#39;re not in the same process, you&#39;re going to have to have a shared input queue one way or another, or the extensions won&#39;t get input at all. So I assume you&#39;re calling for them to be in the same process but somehow running at a lower priority. So what are we talking about here, implementing priority on a sub-process level so the extensions can run at a different priority to the host process? How is the end user going to pick out which thread needs to have its priority lowered, never mind the OS re-architecting that would be required? I find it a bit laughable that you exhort Raymond to &quot;stop thinking in terms of problems, but in terms of solutions&quot;, and yet you&#39;re not proposing solutions, only complaining about problems.</p>
<p>&quot;People don&#39;t tend to run taskbar extensions&quot; &#8211; well, clearly they *do*, otherwise it wouldn&#39;t be an issue. Furthermore, if there&#39;s one thing I&#39;ve learned from reading this blog, it&#39;s that any exposed interface (and a good proportion of things that aren&#39;t even exposed) will be abused in horrifying ways by legions of incompetent application developers, and then will become a backwards compatibility constraint for eternity. So if taskbar extensions are possible at all (which they obviously are) it&#39;s a dead cert that people are using them, and I&#39;d give decent odds that somewhere there&#39;s a company whose core in-house business application would break if the taskbar extension functionality was downgraded in any way.</p>
<p>Your last two paragraphs are even more incoherent. To me it comes across as if you&#39;re saying &quot;LA LA LA I CAN&#39;T HEAR YOU I DON&#39;T CARE IF IT&#39;S PHYSICALLY IMPOSSIBLE YOU SHOULD MAKE IT HAPPEN ANYWAY.&quot; (Eliding Raymond&#39;s points with &quot;blah blah blah&quot; just makes it appear that you have no good answer for them, so you&#39;re hoping that by ignoring them people won&#39;t notice.) Or else you&#39;re saying that the issue of 100% CPU usage is so vital that the OS should be completely re-architected to make it possible to run taskbar extensions at a lower priority than the taskbar. Either way you don&#39;t appear to be in touch with reality.</p>
<div class="post">[<em>The finder concluded with the recommendation, &quot;Microsoft should make Windows refuse to execute programs that have been enchanted with magic pixie dust.&quot; They were totally fixated on the pixie dust. If they were concerned about applications in general being able to consume 100% CPU, then the recommendation would have been &quot;Microsoft should make Windows more resilient to programs that consume 100% CPU.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127413">
				<div id="div-comment-1127413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127413">
			May 30, 2014 at 7:10 am</a>		</div>

		<p>You can support UI automation/assistive tools without global handles, or on the other hand, with windowless controls. &nbsp;It&#39;s not as readily available, but e.g. IE does it, and I suppose Java applications do so too. &nbsp;In essence, the only handles that have to be &quot;global&quot; are those of top-level windows.</p>
<p>In this aspect, Mac OS X has a leaky implementation, where although you can&#39;t handle windows at such a low-level as in Win32 (at least, it&#39;s not documented), you need to enable access for assistive devices system-wide, giving the impression that under the hood, windows are actually global objects. &nbsp;The situation improved quite a bit in 10.9: <a rel="nofollow" target="_new" href="http://support.apple.com/kb/HT6026">support.apple.com/&#8230;/HT6026</a> &nbsp;Now, you tell which applications you allow to control the computer.</p>
<p>But OMG, the main thread GUI thing&#8230; &nbsp;It&#39;s not just the limit on a single thread, it&#39;s that the first thread is the only one guaranteed to be able to run a GUI and load certain libraries&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127473">
				<div id="div-comment-1127473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127473">
			May 30, 2014 at 8:44 am</a>		</div>

		<p>@Scarlet Manuka:</p>
<p>‘why do you claim to be in a better position to interpret the problem submitter&#39;s meaning?’ Because Raymond&#39;s interpretation is obviously false. I don&#39;t get the feeling I&#39;m hearing a real person here. Whereas if you assume that the ‘finder’ is technically incompetent and Raymond can&#39;t read between the lines, it all makes sense. The fact that the ‘finder’ was fixated on the pixie dust only corroborates that, since it aligns well with my experiences with customers.</p>
<p>‘you&#39;re not proposing solutions, only complaining about problems’ You cannot be serious. I have proposed many solutions already, some of which would actually help a lot and need no API or kernel changes. Others might, but then again Microsoft can do that.</p>
<p>‘&#8230;taskbar extensions&#8230;’ Suppose some people do. Why would it make sense to not add reliability for everyone who doesn&#39;t because some do? And why would it make sense to not shield the taskbar from all shell extensions and software in other processes, because it purportedly cannot be shielded from taskbar extensions, whiach are of limited use anyway?</p>
<p>‘I don&#39;t care if it&#39;s physically impossible’ It is not physically impossible, and claiming that it is, is dishonest. If I right click a taskbar button I want a menu to pop up with a working close button, immediately. There is nothing about computers that makes this impossible. And given that Microsoft can change Windows, they can make this work.</p>
<p>‘Eliding Raymond&#39;s points with &quot;blah blah blah&quot; just makes it appear’ If you read the bit I elided, you&#39;ll see that the bits I cut away were irrelevant objections that wouldn&#39;t actually stand in the way of improving the situation.</p>
<p>‘you don&#39;t appear to be in touch with reality.’ Right. I&#39;m getting the same opinion of you to be frank. I&#39;m sorry if I sound crass, but I feel like I&#39;m talking to a wall. I&#39;ve made many helpful suggestions and good points and none of them have been addressed in any way, and instead I&#39;ve been showered with irrelevancies that don&#39;t matter.</p>
<p>And what I understand even less is why you people have to be so unreasonable about it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127443">
				<div id="div-comment-1127443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127443">
			May 30, 2014 at 7:25 am</a>		</div>

		<p>@John Doe</p>
<p>You *CAN*. You *CAN* also build your own operating system from scratch. These are both GODAWFUL ideas.</p>
<p>We work with an application that is 30 years old, which is a void when examined with UIAutomation, because the original developers who worked on the project thought &quot;Hey, we CAN just roll our own controls, this &#39;windows&#39; thing will never last!&quot;, and instead rolled their own.</p>
<p> Every single control in the application is custom &#8211; from scrollbars to menu strips. This means that every single common interface has to be implemented &#8211; from scratch &#8211; in the application, because the alternative is burning it to the ground.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127703">
				<div id="div-comment-1127703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127703">
			May 31, 2014 at 3:01 am</a>		</div>

		<p>I have wondered whether it would be a good idea to automatically kill processes that are running so hot that they prevent the machine from being usable. Software would soon get fixed so that it behaved better. But I rarely run old software, so for the ancient Enterprise LOB apps you would need a compatibility flag that would did allow software to destabilise your machine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127713">
				<div id="div-comment-1127713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127713">
			May 31, 2014 at 3:07 am</a>		</div>

		<p>@Anonymous Coward</p>
<p>&quot;‘I don&#39;t care if it&#39;s physically impossible’ It is not physically impossible, and claiming that it is, is dishonest. If I right click a taskbar button I want a menu to pop up with a working close button, immediately. There is nothing about computers that makes this impossible. And given that Microsoft can change Windows, they can make this work.&quot;</p>
<p>If you&#39;ve read this blog for more than a month then you should be aware that Microsoft can&#39;t just change Windows however they want. They might be able to improve it for your case, but due to making compromises that might open up other issues. There is a finite number of people working at Microsoft, they probably have better things to do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127783">
				<div id="div-comment-1127783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127783">
			May 31, 2014 at 1:48 pm</a>		</div>

		<p>@Anonymous Coward:</p>
<p>&quot;Then isolate them in a way that doesn&#39;t cause input queue attachment. Stop thinking in terms of problems, but in terms of solutions.&quot;</p>
<p>Is there actually a simple way to do this that exists in Windows already? Input queue attachment is more abstract that AttachThreadInput, with the extension being dependent on the input from the taskbar, it is implicitly attached.</p>
<p>If you want to get rid of that, what choices do you have? Well, you could poll the input devices or somehow get Windows to forward all input messages to some unrelated hidden window. Polling is of course inefficient since it would have to be done constantly, so it would eat up CPU, and iirc, there is no Win32 function exposed to poll the mouse state. This polling would also have to run at high priority otherwise it would end up missing input if the CPU is under load.</p>
<p>So then, forwarding messages to a hidden message only window for the extensions to use. So what could go wrong with this? Well, the cross thread attachment also acts as a synchronisation barrier, so now the taskbar is waiting on some synchronisation object for the extension to finish doing its work, instead of the call acting as this barrier.</p>
<p>Is there any real way to change this? I don&#39;t think so, even with exposing new API functions or reusing legacy ones like DirectInput.</p>
<p>So, unless there is a method that exists that everyone in the world isn&#39;t getting, the only two options for the extension to act on user input are for the taskbar to forward events, i.e. input queue attachment, or independently get the input. Both of these have their own problems, especially with the extensions being isolated in some way from the taskbar, and the answers are not easy.</p>
<p>So while you may write &quot;Stop thinking in terms of problems, but in terms of solutions.&quot;, isn&#39;t it important to know what problem you are trying to solve before you design a solution for it?</p>
<div class="post">[<em>If you detach the input queues, then you create a whole bunch of new problems. Also, many shell extensions &quot;know&quot; that they are in the main Explorer process and run around doing crazy things (like subclassing other windows). -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127873">
				<div id="div-comment-1127873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ariel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127873">
			June 2, 2014 at 5:20 am</a>		</div>

		<p>@Crescens2k</p>
<p>If you really wanted a reliably fast taskbar, you could certainly do it Qubes-style &#8211; the taskbar and extension communicate (asynchronously) via a pipe (+ maybe shared memory for fast image transfer). Qubes even does it in an X11-compatible way (I&#39;m from the Linux world so I don&#39;t know if you can do it Win32-compatibly).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1127893">
				<div id="div-comment-1127893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1127893">
			June 2, 2014 at 8:02 am</a>		</div>

		<p>[If you detach the input queues, then you create a whole bunch of new problems. Also, many shell extensions &quot;know&quot; that they are in the main Explorer process and run around doing crazy things (like subclassing other windows). -Raymond]</p>
<p>Yeah, I was glossing over that a bit to try and explain that the attachment doesn&#39;t have to be as concrete as calling a function. But I probably failed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1128993">
				<div id="div-comment-1128993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperSpy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1128993">
			June 4, 2014 at 12:21 pm</a>		</div>

		<p>On the topic of Task Manager when the system is heavily loaded, it seems like Task Manager gets launched at normal priority, then after initializing sets itself to high. &nbsp;But if the system is heavily loaded or the offending task is running above normal, starting off at normal gets Task Manager stuck to the point where it can&#39;t ever get far enough to promote it&#39;s priority.</p>
<p>It would be nice if the &#39;Task Manager&#39; option from winlogon (which is already running at high priority) would just launch Taskmgr.exe at high priority directly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129093">
				<div id="div-comment-1129093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140529-00/?p=863#comment-1129093">
			June 4, 2014 at 3:25 pm</a>		</div>

		<p>About priority &#8211; AFAIK its possible to restrict non-admin users from setting too high priority to their processes and threads. Once upon a time SeIncreaseBasePriorityPrivilege was invented for that.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>