<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (20)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1234666">
				<div id="div-comment-1234666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234666">
			July 29, 2015 at 7:51 am</a>		</div>

		<p>&gt;I&#39;m told that the kernel team considered putting a no-access page between the two stacks, so that a runaway memory copy into the stack would encounter an access violation before it reached the backing store. For whatever reason, they didn&#39;t bother. </p>
<p>Hum&#8230; Is it possible to declare, at the processor (or memory hardware) level, a memory range to be only accessible through register spilling and not user code? Something like register spilling being made at another ring level, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234656">
				<div id="div-comment-1234656" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234656">
			July 29, 2015 at 7:55 am</a>		</div>

		<p>Long post is loooong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234646">
				<div id="div-comment-1234646" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234646">
			July 29, 2015 at 8:04 am</a>		</div>

		<p>Medinoc&#39;s comment prompted a question of my own, actually:</p>
<p>Is the spilling to the stack done by the hardware, or does it trap into the OS? (I thought the SPARC did it by a trap, but after a quick search I don&#39;t see a definitive answer but it sounds like I may be wrong.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234636">
				<div id="div-comment-1234636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234636">
			July 29, 2015 at 9:53 am</a>		</div>

		<p>What happens if you have both integer and floating point arguments? Or if you do:</p>
<p>union mixed_t {</p>
<p>double d;</p>
<p>int64_t i;</p>
<p>};</p>
<p>extern mixed_t foo(mixed_t m);</p>
<p>mixed_t mixed = { .d = 1.0 };</p>
<p>foo(mixed);</p>
<div class="post">[<em>I already provided links that answer this question. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234626">
				<div id="div-comment-1234626" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234626">
			July 29, 2015 at 10:05 am</a>		</div>

		<p>Did having so many registers make context switching expensive?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kirbyfcf2 odd alt thread-odd thread-alt depth-1" id="comment-1234616">
				<div id="div-comment-1234616" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Kirby+FC' rel='external nofollow' class='url'>Kirby FC</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234616">
			July 29, 2015 at 10:08 am</a>		</div>

		<p>Since I know absolutely nothing the Itanium I find this series very interesting.</p>
<p>But, is it just me or does the Itanium seem way overly complicated?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234606">
				<div id="div-comment-1234606" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234606">
			July 29, 2015 at 10:12 am</a>		</div>

		<p>@Kirby</p>
<p>I suspect the complexity gains significant benefits elsewhere, which I hope we get to see as this series evolves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234596">
				<div id="div-comment-1234596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234596">
			July 29, 2015 at 10:25 am</a>		</div>

		<p>@Evan: I don&#39;t really know anything about it, but doing register spilling by an OS trap sounds like it would be very expensive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234586">
				<div id="div-comment-1234586" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234586">
			July 29, 2015 at 11:16 am</a>		</div>

		<p>[the compiler may find that it needs to spill the parameter, thereby raising the STATUS_REG_NAT_CONSUMPTION exception. ]</p>
<p>That would have resulted in me filing a bug against the compiler because the undefined value clearly wasn&#39;t accessed. (For all the compiler knows it was passed a NaT rather than the caller passing two args, and the function clearly won&#39;t be using the 3rd arg).</p>
<p>It&#39;s a pretty simple fix &#8212; always use the NaT-clobbering write instruction to spill arguments.</p>
<div class="post">[<em>But that also masks a bug &#8211; what if the caller accidentally passed a NaT to you? You are silently clearing the NaT bit instead of raising an exception to say &quot;Whoa, I&#39;m operating with uninitialized data!&quot; Also, the special instructions for ignoring NaT are not as flexible as the normal memory instructions. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234576">
				<div id="div-comment-1234576" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234576">
			July 29, 2015 at 11:35 am</a>		</div>

		<p>@Bob: What do you think happens? For case 1, presumably the compiler stores the arguments as expected by the function. For the other case, if the union fits in a register, then it presumably is passed in the register and the receiving function accesses it as desired. Of course, having a bare union without the information required to know what&#39;s actually stored it is inherently dangerous, but how would that be different than how it&#39;s handled in other architectures?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234556">
				<div id="div-comment-1234556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234556">
			July 29, 2015 at 12:11 pm</a>		</div>

		<p>@Kirby It&#39;s mostly complicated for compiler writers, but actually a really simple ISA for hardware designers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234546">
				<div id="div-comment-1234546" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234546">
			July 29, 2015 at 2:09 pm</a>		</div>

		<p>You can now get 2 stacks on x86 with LLVM&#39;s SafeStack (enable with -fsanitize=safe-stack), coming soon to a compiler near you, with a buffer-stack stored behind a thread-local complementing the now register-backing-store at %esp/%rsp.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234536">
				<div id="div-comment-1234536" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234536">
			July 29, 2015 at 2:17 pm</a>		</div>

		<p>@Raymond: I mean what happens to the floating point registers with the alloc instruction i.e. how are they rotated or accounted for in the local variable counts?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234526">
				<div id="div-comment-1234526" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234526">
			July 29, 2015 at 2:44 pm</a>		</div>

		<p>@Jeffrey Bosboom</p>
<p>I&#39;m beginning to suspect, that only alloc&#39;ed registers are context switched.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234496">
				<div id="div-comment-1234496" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234496">
			July 29, 2015 at 4:14 pm</a>		</div>

		<p>@waleri That is correct. &nbsp;The floating-point registers are not part of the register window system; you (the compiler) have to manually save and restore them as necessary, just like you would integer registers on a more &quot;normal&quot; architecture. &nbsp;Most of the FP registers are call-clobbered, too (if I&#39;m reading this architecture manual correctly, only f2-f5 and f16-f31 are call-saved). &nbsp;However, you can move directly between floating-point and integer registers, so you can spill your FP registers into your &quot;local region&quot; of the integer regs and then the backing-store magic will do the rest.</p>
<p>The FP registers do have some magic of their own: Raymond will probably be getting to _rotating_ registers eventually.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234486">
				<div id="div-comment-1234486" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234486">
			July 29, 2015 at 5:20 pm</a>		</div>

		<p>@Evan:</p>
<p>SPARC handles register window overflow/underflow using a trap.</p>
<p>Even worse, on Sparc V7 (sun4, sun4c) the MMU did not enforce memory protections in kernel mode, so the register window overflow/underflow handler had to validate the spill/reload virtual addresses &quot;manually&quot;. This made window handling super expensive and negated any advantage it had. It also required a trap (&quot;ta 3&quot;) in order to do any kind of context-switch, including what would otherwise be 100% user-space thread switching on other architectures.</p>
<p>Sparc V9 cleans this up a little. &nbsp;The MMU is operational during the trap, and there is a little more hardware assist, so the handler can be really tight.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234476">
				<div id="div-comment-1234476" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234476">
			July 29, 2015 at 5:41 pm</a>		</div>

		<p>@Evan &#8211; SPARC has register window overflow and underflow traps which need to be handled by the operating system</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234456">
				<div id="div-comment-1234456" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234456">
			July 30, 2015 at 7:45 am</a>		</div>

		<p>Wow, what a detailed, information-packed, and professionally-done post with great visuals. &nbsp;Like a college class, but free.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1222212">
				<div id="div-comment-1222212" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1222212">
			July 30, 2015 at 8:49 am</a>		</div>

		<p>Thanks saveddijon and david; I&#39;m happy to know that my memory isn&#39;t completely faulty at least. (Unlike Sparc v7&#39;s memory spilling! *ba bum ksshhh*!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196981">
				<div id="div-comment-1196981" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Denis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1196981">
			August 3, 2015 at 6:39 am</a>		</div>

		<p>Wow, that calling mechanism looks just about right for a continuation-passing style compiler! Is there a very efficient implementation of Scheme on Itanium?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>