<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (46)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1308335">
				<div id="div-comment-1308335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stéphan Leclercq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308335">
			September 6, 2017 at 7:51 am</a>		</div>

		<p>&gt;&gt; To reduce disk space, they could move the bulk of their code into a DLL and have the EXE be a stub that loads the DLL and then calls the Run­The­Program function in the dll</p>
<p>Let&#8217;s be bold: one of the EXE is a stub that loads the full exe with LoadLibrary and call its main() function :-)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip odd alt depth-2" id="comment-1308345">
				<div id="div-comment-1308345" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308345">
			September 6, 2017 at 8:08 am</a>		</div>

		<p>That is something that would be nice to do.<br />
Inb4 someone gets picky with why this doesn&#8217;t work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1308355">
				<div id="div-comment-1308355" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308355">
			September 6, 2017 at 8:52 am</a>		</div>

		<p>Tried that; it&#8217;s theoretically possible if you&#8217;re willing to code against RawEntryPoint() and use a bunch of horrible-looking assembly to decode where you are DllMain or not.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1308415">
				<div id="div-comment-1308415" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308415">
			September 6, 2017 at 12:03 pm</a>		</div>

		<p>You don&#8217;t need assembler to decode whether your entry point is called as _DllMainCRTStartup() or [w]WinMainCRTStartup(): use the MSC intrinsic _ReturnAddress() to determine whether your caller is NTDLL.dll or KERNEL32.dll<br />
And you don&#8217;t need assembler to clean up the stack: [w]WinMainCRTStartup() does not return, but needs to call ExitProcess(), so you can always use a _DllMainCRTStartup() entry point.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-4 parent" id="comment-1308416">
				<div id="div-comment-1308416" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308416">
			September 6, 2017 at 12:17 pm</a>		</div>

		<p>I can&#8217;t believe you&#8217;re recommending that people rely on an extremely subtle implementation detail.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1308435">
				<div id="div-comment-1308435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308435">
			September 6, 2017 at 12:46 pm</a>		</div>

		<p>I only wrote that you don&#8217;t need assembler to detect whether a &#8220;raw&#8221; entry point is called as DLL or application.</p>
<p>Regarding the subtle details: the _DLLMainCRTStartup() entry is only called by NT&#8217;s user space module loader, which is implemented in NTDLL.dll As long as the module loader continues to be implemented in NTDLL.dll the _DLLMainCRTStartup() callback will be called from NTDLL.dll<br />
This didn&#8217;t change in the last 24 years.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5 parent" id="comment-1308445">
				<div id="div-comment-1308445" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308445">
			September 6, 2017 at 1:02 pm</a>		</div>

		<p>Sometimes things that haven&#8217;t changed in 24 years change. Especially extremely implementation-dependent things like this. (Example coming in a few months.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1308495">
				<div id="div-comment-1308495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308495">
			September 6, 2017 at 2:14 pm</a>		</div>

		<p>Of course things change from time to time.<br />
I don&#8217;t expect any production code to rely on the fact that the _DLLMainCRTStartup() callback is called from within NTDLL.dll, as this detail is not documented.<br />
Microsoft also dared to change other details of this interface at least twice in this millennium: with Windows XP they introduced the undocumented callback reason 4 alias DLL_APPLICATION_VERIFIER, and since Windows 7 they call this entry twice with reason 1 alias DLL_PROCESS_ATTACH when the DLL is registered as an application verifier provider.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5 parent" id="comment-1308505">
				<div id="div-comment-1308505" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308505">
			September 6, 2017 at 2:29 pm</a>		</div>

		<p>You say &#8220;I don&#8217;t expect any production code to rely on&#8221; what you wrote, but what you wrote was not qualified with any disclaimers like &#8220;Not for production use.&#8221; You just came right out and said to do it: &#8220;use the MSC intrinsic _ReturnAddress() to determine whether your caller is NTDLL.dll or KERNEL32.dll&#8221;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1308515">
				<div id="div-comment-1308515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308515">
			September 6, 2017 at 2:36 pm</a>		</div>

		<p>I wrote what ACTUALLY works!<br />
Maybe I should introduce a nitpickers corner.-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5 parent" id="comment-1308525">
				<div id="div-comment-1308525" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308525">
			September 6, 2017 at 2:37 pm</a>		</div>

		<p>Again, you are not being clear whether the information you are providing is intended for production use. You say &#8220;This is what actually works&#8221; which implies that it is suitable for production. But it&#8217;s not. On this site, I try to be clear about the distinction between contractual behavior and implementation detail. Because I&#8217;ve seen what happens when people confuse the two.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1308535">
				<div id="div-comment-1308535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308535">
			September 6, 2017 at 2:53 pm</a>		</div>

		<p>I replied to the false statement <i>it’s theoretically possible if you’re willing to code against RawEntryPoint() and use a bunch of horrible-looking assembly to decode where you are DllMain or not.</i> to show how this can be done practically and without a bunch of horrible-looking assembly.<br />
The purpose/intention is solely educational.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5 parent" id="comment-1308546">
				<div id="div-comment-1308546" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308546">
			September 6, 2017 at 3:11 pm</a>		</div>

		<p>It was not clear at what point we crossed from documented behavior to implementation-defined. Certainly nobody bothered to say that we landed in the implementation-defined part.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1308625">
				<div id="div-comment-1308625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308625">
			September 7, 2017 at 6:05 am</a>		</div>

		<p>We never crossed that line, simply because Microsoft provides <b>NO</b> documentation how or by whom _DLLMainCRTStartup() and [w]WinMainStartup() are called.<br />
The existing documentation for DllMain(), <a href="https://msdn.microsoft.com/en-us/library/ms682583.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/ms682583.aspx</a> and <a href="https://msdn.microsoft.com/en-us/library/ms682596.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/ms682596.aspx</a>, is even ambiguous: the name DllMain() is used for the function called by the CRT too. Only the documentation for the IDE/Compiler, <a href="https://msdn.microsoft.com/en-us/library/988ye33t.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/988ye33t.aspx</a>, or the linker, <a href="https://msdn.microsoft.com/en-us/library/f9t8842e.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/f9t8842e.aspx</a> and <a href="https://msdn.microsoft.com/en-us/library/aa235421.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/aa235421.aspx</a>, introduces the names *MainCRTStartup, and tells their calling convention.<br />
Even the fact that returning from an applications *MainCRTStartup() function does not terminate the process when secondary threads have been created is <b>NOT</b> documented there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-5" id="comment-1308595">
				<div id="div-comment-1308595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308595">
			September 6, 2017 at 10:42 pm</a>		</div>

		<p>Historically ms has treated most implementation details as public interfaces and kept them backwards compatible, instead of breaking them to maintain a better technical solution as a whole, this is what happens when you make such decisions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maximilien-noal odd alt depth-5" id="comment-1308616">
				<div id="div-comment-1308616" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maximilien+Noal' rel='external nofollow' class='url'>Maximilien Noal</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308616">
			September 7, 2017 at 5:16 am</a>		</div>

		<p>@640K :</p>
<p>No, this is what happens when people are lazy and/or do not want to play by the book.</p>
<p>Play stupid games (: relying on implementation detail), win stupid prizes (: a nightmarish code base).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5 parent" id="comment-1308635">
				<div id="div-comment-1308635" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308635">
			September 7, 2017 at 7:39 am</a>		</div>

		<p>So you&#8217;re saying that we were always on the &#8220;documented and supported&#8221; side of the line? Or you&#8217;re saying that we were always on the &#8220;not documented and unsupported&#8221; side? Because the original comment sounded like a &#8220;working within the bounds of documented and supported&#8221; comment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1308656">
				<div id="div-comment-1308656" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308656">
			September 7, 2017 at 7:59 am</a>		</div>

		<p>I choose the second alternative: we were always in the land of the undocumented.<br />
I didn&#8217;t expect that I need to mention that explicitly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5" id="comment-1308716">
				<div id="div-comment-1308716" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308716">
			September 7, 2017 at 9:13 am</a>		</div>

		<p>As a general rule, on this site, any venture into the undocumented is explicitly called out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5 parent" id="comment-1308755">
				<div id="div-comment-1308755" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308755">
			September 7, 2017 at 9:35 am</a>		</div>

		<p>On the contrary, I started this thread while remaining in the land of the documented: <a href="https://blogs.msdn.microsoft.com/oldnewthing/20040614-00/?p=38903" rel="nofollow">https://blogs.msdn.microsoft.com/oldnewthing/20040614-00/?p=38903</a></p>
<p>The horrible assembly is for determining your load address directly and for repairing the stack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-5" id="comment-1308905">
				<div id="div-comment-1308905" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308905">
			September 8, 2017 at 8:27 am</a>		</div>

		<p>You don&#8217;t need a bunch of ugly assembly to access your own modules MZ and PE headers and determine whether it was built as DLL or EXE: use <code>extern IMAGE_DOS_HEADER __ImageBase;</code> to access the MZ header, get the offset of the PE header from __ImageBase-&gt;e_lfanew, then test &#8230;-&gt;OptionalHeader.DllCharacteristics<br />
Unfortunately this but does not tell whether your modules raw entry point was called as [w]WinMainCRTStartup(void) or _DLLMainCRTStartup(HMODULE, DWORD, LPVOID).<br />
Fortunately another commenter pointed out that LoadLibrary(&#8220;some.exe&#8221;) succeeds, but does not call the entry point at all. Likewise CreateProcess(&#8220;some.dll&#8221;, &#8220;*&#8221;, &#8230;) fails with ERROR_BAD_EXE_FORMAT<br />
So: your precondition that a module linked as DLL may be loaded as EXE and vice versa does not hold!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt depth-5 parent" id="comment-1308765">
				<div id="div-comment-1308765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308765">
			September 7, 2017 at 10:02 am</a>		</div>

		<p>This is actually <a href="https://msdn.microsoft.com/en-us/library/f9t8842e.aspx" rel="nofollow">all documented</a> in the linker documentation, you don&#8217;t even need to do any of that work&#8230; you can tell NTLOADER exactly what you want called, that said you DO need to meet your side of the contract if you&#8217;re going to do that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-5" id="comment-1308915">
				<div id="div-comment-1308915" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308915">
			September 8, 2017 at 8:36 am</a>		</div>

		<p>No, you can&#8217;t tell NT&#8217;s module loader <b>HOW</b> to call the entry point: this is, as Raymond Chen already wrote, an implementation detail. JFTR: you can specify any symbol you like with /ENTRY: to the linker. If this symbols prototype but does <b>not</b> match the prototype expected by NT&#8217;s module loader your module will crash, sooner or later: _DLLMainCRTStartup(HMODULE, DWORD, LPVOID) differs from [w]MainCRTStartup()</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-archangelpip odd alt depth-4 parent" id="comment-1308526">
				<div id="div-comment-1308526" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308526">
			September 6, 2017 at 2:41 pm</a>		</div>

		<p>After playing around a lot with the raw entry point, it may surprise you to learn that you don&#8217;t have to call ExitProcess.<br />
While it is true that the CRT/VCRuntime source shows that after it returns from (w)main or (w)WinMain it calls exit, this is just an easy way to invoke the process cleanup. Returning from the entry point function exits the process naturally, in fact the exit in general is only called for unmanaged applications. This could change at some point in the future. So again, this is relying on an implementation detail.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1308545">
				<div id="div-comment-1308545" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308545">
			September 6, 2017 at 2:56 pm</a>		</div>

		<p>Simply returning from [w]WinMainCRTStartup() does <b>NOT</b> terminate the process if there is a secondary thread running.<br />
<b>I</b> don&#8217;t like zombies.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf odd alt depth-5" id="comment-1308615">
				<div id="div-comment-1308615" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308615">
			September 7, 2017 at 1:54 am</a>		</div>

		<p>I once experimented with that too, in a simple program. As Raymond said in &#8220;The old-fashioned theory on how processes exit&#8221; ( <a href="https://blogs.msdn.microsoft.com/oldnewthing/20070502-00/?p=27023" rel="nofollow">https://blogs.msdn.microsoft.com/oldnewthing/20070502-00/?p=27023</a> ), it&#8217;s fine when you control all threads (since assuming no one calls ExitProcess(), the process exits naturally when the last thread does) but nowadays you don&#8217;t. There is no CleanupThreads() functions, no way for a DLL to register for &#8220;thread cleanup notification&#8221;, and no way (outside of .Net) to mark your threads as &#8220;background threads&#8221; or register a standard &#8220;this thread should exit its main loop within this second&#8221; event.</p>
<p>Which means, as soon as you use any function that spawns a background thread, you&#8217;re screwed.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-4 parent" id="comment-1308745">
				<div id="div-comment-1308745" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308745">
			September 7, 2017 at 9:25 am</a>		</div>

		<p>In the lengthy exchange here, the &#8220;what actually works&#8221; comment is exactly what gets code into trouble, and causes the need for application compatibility shims, and all kinds of other things-that-should-not-be-necessary.  </p>
<p>It has already been pointed out that Microsoft could choose the have an upgrade path to break lots of programs, and say &#8220;well the program didn&#8217;t do the right thing&#8221;, even if the program did &#8220;what actually works&#8221; (or worked at the time).  Then no one would upgrade, because no business-critical software still runs.  </p>
<p>It is a huge distinction between what works, and what works but is also future-proof.  Some old code written for Windows 95 works, and even installs, and some does not.  Some code relies on the presence of C:\Program Files, and some code does not.  It may work for YOU, right now&#8230;.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1308927">
				<div id="div-comment-1308927" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308927">
			September 8, 2017 at 10:39 am</a>		</div>

		<p>1. my comment targeted the wrong claim <i>a bunch of horrible-looking assembly</i>.<br />
2. even Microsoft introduces incompatible changes from time to time, or removes old interfaces from the Win32 API.<br />
3. if I write code which relies on undocumented behaviour I don&#8217;t expect Microsoft or any other OS-vendor to fix my bugs if things go wrong.<br />
4. Microsoft &#8220;documents&#8221; quite some interfaces in header files like winnt.h only. See Raymonds next blog entry.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1309565">
				<div id="div-comment-1309565" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin Cathcart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1309565">
			September 14, 2017 at 10:50 am</a>		</div>

		<p>Do you even need to do that? I know that having a dll literally export a __stdcall function called &#8220;main&#8221;, and having the EXE simply DLLImport it worked just fine in a quick console mode app test. Is there some reason that one cannot do that with a function named WinMain, which just happens to be present in the dll, but is not the DLL&#8217;s entrypoint?</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1308455">
				<div id="div-comment-1308455" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308455">
			September 6, 2017 at 1:03 pm</a>		</div>

		<p>When LoadLibrary called to load executeable, but not dll, then it behaves like LoadLibraryEx(..DONT_RESOLVE_DLL_REFERENCES) so you executable loaded as dll will crash when it will try to call any API. So you need to essentially write own PE loader (or spoof NTDLL&#8217;s one to think its a really dll).</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1308465">
				<div id="div-comment-1308465" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308465">
			September 6, 2017 at 1:29 pm</a>		</div>

		<p>So how does the loader know it&#8217;s an executable not a DLL?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1308476">
				<div id="div-comment-1308476" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308476">
			September 6, 2017 at 1:52 pm</a>		</div>

		<p>obviously by looking for IMAGE_FILE_DLL in IMAGE_FILE_HEADER::Characteristics</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1308885">
				<div id="div-comment-1308885" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ZLB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308885">
			September 8, 2017 at 7:10 am</a>		</div>

		<p>An unexpected problem with doing that is that it causes Malware/Virus scanner heuristics to start flagging you up.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1308367">
				<div id="div-comment-1308367" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308367">
			September 6, 2017 at 9:35 am</a>		</div>

		<p>Clunky?  I&#8217;d call it clever, particularly the small stub solution.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1308395">
				<div id="div-comment-1308395" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">George</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308395">
			September 6, 2017 at 11:40 am</a>		</div>

		<p>This is just a single byte change? Can you write a small utility that modifies the binary?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2 parent" id="comment-1308405">
				<div id="div-comment-1308405" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308405">
			September 6, 2017 at 11:59 am</a>		</div>

		<p>Modifying a binary is likely to trigger anti-malware protection software. It will certainly invalidate the digital signature.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1308556">
				<div id="div-comment-1308556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308556">
			September 6, 2017 at 3:26 pm</a>		</div>

		<p>Jigsaw patch will take care of the digital signature just fine: the modification is known in advance so we can just carry both signatures in the modifier. I prefer your solution of loading a giant DLL from two stub EXEs anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1308425">
				<div id="div-comment-1308425" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308425">
			September 6, 2017 at 12:25 pm</a>		</div>

		<p>If customer concerned only about 3rd party dll&#8217;s in own address space then they just can MEM_RESERVE upper 2GB of own (large) address space before loading that risky dll.<br />
And put own heap manager over that reserved space to allocate own buffers on that 21s century&#8217;s high memory area.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-ranta even depth-2 parent" id="comment-1308565">
				<div id="div-comment-1308565" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ranta' rel='external nofollow' class='url'>ranta</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308565">
			September 6, 2017 at 3:30 pm</a>		</div>

		<p>I expected that would be the hack. It doesn&#8217;t seem entirely safe though:<br />
&#8211; What if the stack of the main thread ends up in the high 2G, and the add-in then crashes when doing arithmetic on addresses of local variables? Fix: run the add-in on another thread started after MEM_RESERVE.<br />
&#8211; What if e.g. kernel32 gets loaded in the high 2G?<br />
&#8211; What if a system DLL reserves some address space before your MEM_RESERVE, but frees it later, and the add-in then happens to allocate it?</p>
<p>I also expected there would be an override via UpdateProcThreadAttribute, but apparently not.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1308575">
				<div id="div-comment-1308575" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308575">
			September 6, 2017 at 5:59 pm</a>		</div>

		<p>&gt; What if the stack of the main thread ends up in the high 2G, and the add-in then crashes when doing arithmetic on addresses of local variables? Fix: run the add-in on another thread started after MEM_RESERVE.</p>
<p>Yeah. That fixes it. There&#8217;s also a trick using only documented APIs to reallocate your stack (begins with ConvertThreadToFiber).</p>
<p>&gt; What if e.g. kernel32 gets loaded in the high 2G?</p>
<p>Impossible.</p>
<p>&gt; What if a system DLL reserves some address space before your MEM_RESERVE, but frees it later, and the add-in then happens to allocate it?</p>
<p>Easily prevented by delay-loading everything but kernel32.dll.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even depth-3 parent" id="comment-1308585">
				<div id="div-comment-1308585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308585">
			September 6, 2017 at 7:53 pm</a>		</div>

		<p>Btw, I think system DLLs never loads above 2GB boundary on a 32-bit system, because if that&#8217;s the case, you can&#8217;t have any non-LargeAddressAware processes running on that system. Anytime these returns memory pointer above 2GB, and the non-LargeAddressAware processes may fail.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-msn odd alt depth-4 parent" id="comment-1308586">
				<div id="div-comment-1308586" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/poizan42' rel='external nofollow' class='url'>poizan42</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308586">
			September 6, 2017 at 10:28 pm</a>		</div>

		<p>Only if their &#8220;currently preferred base address&#8221; (i.e. the one selected by ASLR) is available. Now you are probably doing something nasty if the address where it wants to load kernel32.dll is already reserved before kernel32.dll is mapped, but for other system dlls it might happen. The reason that the system tries to use the same address for all instances of the same dll is so pages with relocations can be shared as much as possible &#8211; this also weakens ASLR because an information leak in one process can be used as part of an exploit of another, other OSes fixes this by using position independent code, but that comes with a performance penalty for x86.</p>
<p>That is at least how it works for 32-bit processes, I&#8217;m not sure about 64-bit processes since you already get IP-relative addressing for free.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong even depth-5" id="comment-1308605">
				<div id="div-comment-1308605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308605">
			September 7, 2017 at 1:18 am</a>		</div>

		<p>I think the DLL&#8217;s are preloaded but the process get the translated address mapped into their address space. And the system DLLs should always return a within 2GB address when a pointer is needed like when calling GetProcAddress() for some function in kernel32.dll.</p>
<p>There were tons of old application (and DLLs) that uses signed variable type to store pointer. As the memory allocation rules for DLLs follows that of the main program, not returning &gt;2GB value for system DLLs will certainly induce hangs and crash more often, and the general users will think it&#8217;s Windows&#8217; fault as &#8220;the program runs without problem on WinXP&#8221;. I don&#8217;t think Microsoft will choose to risk that.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-3 parent" id="comment-1308596">
				<div id="div-comment-1308596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308596">
			September 7, 2017 at 1:08 am</a>		</div>

		<p>kernel32/kernelbase/user32 cannot be higher than 2GB cuz there&#8217;re not-large-address-aware processes and these dlls always mapped at same address in each process in session (so ASLR randomizes their base across reboots) .<br />
To make sure nothing allocated/freed there its better to reserve memory before actually process starts. That mean CreateProcess(..CREATE_SUSPENDED..) and use VirtualQueryEx/VirtualAllocEx to reserve high addresses. Then resume process and tell it somehow where&#8217;re that reserved addresses that may actually be used by it.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1308835">
				<div id="div-comment-1308835" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stewart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308835">
			September 8, 2017 at 12:45 am</a>		</div>

		<p>I&#8217;m not sure CREATE_SUSPENDED will work here. During process creation the first thread will be created (suspended), but it&#8217;s user mode stack will probably be allocated as part of that. I haven&#8217;t tested it, but it seems it must work like that since if it didn&#8217;t allocate the stack until the process was resumed, the stack allocation might fail causing process creation to fail after CreateProcess has returned.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1308925">
				<div id="div-comment-1308925" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308925">
			September 8, 2017 at 9:43 am</a>		</div>

		<p>Yes, thread&#8217;s stack will be there as well as TEB, PEB, RTL_USER_PROCESS_PARAMETERS and some stuff related to SXS and compatibility layer.<br />
But assuming its your application and you don&#8217;t use such tricks like exiting from main thread and continue to live then (by bypassing CRT&#8217;s main epilog that calls ExitProcess) then everything should be fine.<br />
PS: I mentioned VirtualQueryEx due to AFAIR VirtualAlloc(Ex) (MEM_RESERVE) succeeds when trying to reserve already reserved pages, so need to check with VirtualQueryEx to find MEM_FREE to reserve them and only them. And (if you&#8217;re paranoic) that logic can be extended so if it will find anything unexpected there (something not from 1st sentence) &#8211; then disable &#8216;risky&#8217; extensions.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>