<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (29)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1040633">
				<div id="div-comment-1040633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lockwood</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040633">
			February 21, 2013 at 7:22 am</a>		</div>

		<p>And the favourite side dish at my local Indian takeaway is an indefinite NaN</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040663">
				<div id="div-comment-1040663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040663">
			February 21, 2013 at 8:17 am</a>		</div>

		<p>Amazing that √(-1) and (-∞ + ∞) both return the same kind of NAN as one is on the line (but you don&#39;t know where) and the other is off the line.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040673">
				<div id="div-comment-1040673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040673">
			February 21, 2013 at 8:19 am</a>		</div>

		<p>Somewhat related is that dividing -2147483648 (signed 32 bit minimum value) by minus one generates a cpu exception on Intel processors (in the same way as dividing by zero does). &nbsp;The immediate reason is that positive 2147483648 does not fit, and there is no infinity/nan equivalent for integers. &nbsp;I had to add explicit checks in some of my code. &nbsp;Originally seen at <a rel="nofollow" target="_new" href="http://kqueue.org/blog/2012/12/31/idiv-dos/" rel="nofollow">kqueue.org/&#8230;/idiv-dos</a> showing how to crash various pieces of software. &nbsp;I wonder if there is some way to get the kernel or critical user space apps to perform the calculation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-1040703">
				<div id="div-comment-1040703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040703">
			February 21, 2013 at 9:55 am</a>		</div>

		<p>Incidentally, the fact that a NaN compares different from itself constitutes a quick way to check for NaNs &#8211; in some code of mine, where there are licit cases in which a NaN could be around, there are several weird-looking if(x!=x) around that puzzled several people. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040713">
				<div id="div-comment-1040713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SpecLad</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040713">
			February 21, 2013 at 10:28 am</a>		</div>

		<p>So if all signaling NaNs are printed as #SNAN, the #IND ones must be quiet. So what&#39;s the difference, then, between #IND and #QNAN?</p>
<div class="post">[<em>As I noted in the article, #IND is a special type of #QNAN. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040723">
				<div id="div-comment-1040723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040723">
			February 21, 2013 at 11:28 am</a>		</div>

		<p>Matteo Italia,</p>
<p>I would have been puzzled, too (I wasn&#39;t aware of NaN comparing different from itself). If I had seen something like that, and had it explained, I would have walked up to the responsible programmer and ordered him to add an expanatory end-of-line comment to the statement :-)</p>
<p>But I wonder: Wouldn&#39;t many optimizing compilers determine at compile time that the expression will always be false, issue a warning (or error), and generate no code for the entire if-clause, treating an else-clause, if present, as unconditional code? You could of course force non-optimizaton by declaring x to be volatile, but that could prevent a lot of other optimization as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040733">
				<div id="div-comment-1040733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040733">
			February 21, 2013 at 11:56 am</a>		</div>

		<p>@j b: &nbsp;If you don&#39;t understand these things, then I don&#39;t think it makes sense for you to be in a position where you are making any orders. &nbsp;Regarding your query, why don&#39;t you get out your compiler and try it? &nbsp;A test on my machine using VS2010 SP1 and the default &quot;Release&quot; build settings shows that the optimizer does not optimize away the floating point comparison. &nbsp;This makes sense to me, especially given the fact that NaNs always compare as unequal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040743">
				<div id="div-comment-1040743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Christian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040743">
			February 21, 2013 at 11:58 am</a>		</div>

		<p>The best thing about NANs is that in LuaJit they are used to store pointers and integers and the type information inside the available bits of a double :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040753">
				<div id="div-comment-1040753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040753">
			February 21, 2013 at 12:10 pm</a>		</div>

		<p>@j b: &quot;volatile&quot; is not a magic marker that suppresses optimizations. I know it&#39;s convenient to use it as such in quick benchmarking situations, but do not, in production code, add &quot;volatile&quot; in a misguided attempt to suppress optimizations. Aside from that, floating-point and optimizations are a veritable minefield; adding &quot;volatile&quot; certainly never improves matters.</p>
<p>A quick way to check for NaN that doesn&#39;t require comments is to use, wait for it, isnan(). #include &lt;math.h&gt;. Section 7.12.3.4 of the C standard, right there, standard library, no need for shenanigans. &quot;I optimized the NaN check&quot; is not something I want to be around to hear. Anywhere.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zlynx odd alt thread-odd thread-alt depth-1" id="comment-1040763">
				<div id="div-comment-1040763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zan+Lynx%27' rel='external nofollow' class='url'>Zan Lynx'</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040763">
			February 21, 2013 at 12:25 pm</a>		</div>

		<p>&quot;if (x != x)&quot; does look very confusing and I&#39;d never expect that to be true. &quot;isnan(x)&quot; is much clearer.</p>
<p>What is even more confusing about floating point math is that &quot;x = y; z = y; if (x != z)&quot; may very well return true because of 64-bit double storage in RAM vs 80-bit storage in x87 registers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040773">
				<div id="div-comment-1040773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040773">
			February 21, 2013 at 12:28 pm</a>		</div>

		<p>@JM:</p>
<p>#undef isnan</p>
<p>#if definded(_cplusplus) || <strong>STDC_VERSION</strong> &gt;= 199901L</p>
<p>inline isnan(float x) { return x != x; }</p>
<p>inline isnan(double x) { return x != x; }</p>
<p>inline isnan(long double x) { return x != x; }</p>
<p>#else</p>
<p>#define isnan(x) ((x) != (x))</p>
<p>#endif</p>
<p>I suppose I should be disappointed if math.h doesn&#39;t contain that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040783">
				<div id="div-comment-1040783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040783">
			February 21, 2013 at 2:00 pm</a>		</div>

		<p>ChrisR,</p>
<p>&quot;Testing can prove the presence, not the absence of errors&quot;. Transferred to this situation: Finding one compiler that does NOT do this optimization (at some given optimization level) certainly does not prove that NO compiler wo&#39;nt do it.</p>
<p>JM,</p>
<p>I no way meant to suggest that &#39;volatile&#39; &quot;is a magic marker that suppresses optimizations&quot;, but it does suppress SOME optimizations. I am currently programming embedded systems where any externally defined name may, at link time (so it is unknown to the compiler), be linked to a location or register connected to an external device or event, and may change at any time. So optimizations based on the assumption that the left side &#39;x&#39; has the same value as the right side &#39;x&#39; must be suppressed, in case &#39;x&#39; was updated between the evaluation of the left and right operands of the comparison. Marking &#39;x&#39; as volatile informs the compiler that it cannot assume that &#39;x&#39; is unchanged througout the evaluation of the if-test, but must reloaded for every access. <em>Any</em> access to &#39;x&#39;, whether testing or other, should re-read the physical location/register, and not rely on a cached &#39;x&#39; value, neither in a physical cache or from previously calculated common subexpressions.</p>
<p>If &#39;x&#39; was a real peripheral register/location, this extreme carefulness would certainly be justified. If it is NOT, but just a plain variable, and you (ab)use &#39;volatile&#39; simply to fool the compiler to believe that &#39;x&#39; might change value midway in the if-test, the compiler will know that it cannot evaluate the bool expression at compile time, by flow analaysis. So there is no risk of the if-clause being optimized away. Numerous <em>other</em> flow analysis based optimizations could also be suppressed, e.g. common subexpression calculations. By using &#39;volatile&#39;, you have told the compiler: &#39;Be aware! This location could change its value at any time, behind your back! Don&#39;t trust it to be unchanged! Re-evaluate any expression where it occurs, every time, even though flow analysis indicates that it couldn&#39;t possibly have changed!&#39;</p>
<p>So, (ab)using &#39;volatile&#39; to make 110% sure that no compiler optimization will suppress the if-clause and all its associated code, and similar for every other place &#39;x&#39; is used. The general code quality could suffer, both in time and space.</p>
<p>&quot;&#8230; adding &quot;volatile&quot; certainly never improves matters&quot; &#8211; it certainly does if &#39;x&#39; is a location that is updated in real time by some peripheral sensor. In an embedded system, &#39;volatile&#39; is an extremely important keyword.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040793">
				<div id="div-comment-1040793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040793">
			February 21, 2013 at 2:12 pm</a>		</div>

		<p>@j b: &nbsp;I don&#39;t think I mentioned anywhere that all optimizing compilers behave the same. &nbsp;Nor that I had somehow proven that they all skip the &quot;optimization&quot; you mentioned. &nbsp;I simply picked (a fairly popular) compiler I had on my PC and tried it. &nbsp;This way I could see at least one compiler&#39;s behavior for myself, rather than just pondering and speculating.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-rat odd alt thread-odd thread-alt depth-1" id="comment-1040803">
				<div id="div-comment-1040803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/hacksoncode' rel='external nofollow' class='url'>hacksoncode</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040803">
			February 21, 2013 at 3:07 pm</a>		</div>

		<p>@Lockwood: Yeah, there&#39;s something about Indian food that generates references to IEEE conventions&#8230; my friends and I call Lime Pickles (&quot;Achaar&quot;, various spellings) &quot;IEEE NotAFlavor pickles&quot;, because they seem to contain all flavor directions at maximum magnitude.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040813">
				<div id="div-comment-1040813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040813">
			February 21, 2013 at 6:07 pm</a>		</div>

		<p>&quot;As I noted in the article, #IND is a special type of #QNAN. -Raymond&quot;</p>
<p>This confused me too until I read your comment. Reading back, I don&#39;t think you do mention this. You say &quot;The weird one is the Indefinite NaN.&quot; and then just seem to start talking about quiet NaNs, which seems like a switch in topic to someone like me who didn&#39;t know the connection. As the end you&#39;re still talking about quiet NaNs when suddenly you switch back to indefinite NaNs. This time it doesn&#39;t scan right at all if you think they&#39;re separate concepts, but the connection still isn&#39;t obvious if you don&#39;t already know it (again, to me at least).</p>
<p>As usual, great article, but I think this would be a lot clearer if you explicitly mention that indefinite NaNs are a type of quiet NaN when you first mention the term.</p>
<div class="post">[<em>I added a few clarifying sentences. I hope it helps. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040843">
				<div id="div-comment-1040843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040843">
			February 21, 2013 at 8:03 pm</a>		</div>

		<p>If you were not kidding my response would have been find a better bone to pick.</p>
<p>The only annoying thing I found is vsc doesn&#39;t seem to have an option to link against an alternate C library (it does have the option to link none). Unfortunately it tends to assume that certain functions in msvcrt*.dll /are present/ when not linking against it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040853">
				<div id="div-comment-1040853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040853">
			February 21, 2013 at 9:28 pm</a>		</div>

		<p>I tried to find the source to isnan in the various copies of Visual C++ I have but I cant find it.</p>
<p>It sounds like its one of those bits of the CRT (like say the floating point conversion routines, floating point parts of printf, lower level exception handling code etc) that Microsoft either cant or wont release.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040863">
				<div id="div-comment-1040863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JustSomeGuy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040863">
			February 21, 2013 at 9:51 pm</a>		</div>

		<p>Perhaps you should look into : int isnan(float f) { return f != f; }</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040883">
				<div id="div-comment-1040883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Silly</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040883">
			February 22, 2013 at 1:36 am</a>		</div>

		<p>I was thinking maybe _isnan was a compiler intrinsic, but I guess that can&#39;t be the case. Maybe it works by comparing the given argument for equality to all non-NaN floating point values, returning false if no match found. Maybe it just looks at the bits and does some fancy test. Anyways, I like to do all my arithmetic in VAX-G and thus avoid the esoteric questions of infinity and not number numbers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-1040823">
				<div id="div-comment-1040823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040823">
			February 21, 2013 at 6:26 pm</a>		</div>

		<p>[Wouldn&#39;t many optimizing compilers determine at compile time that the expression will always be false, issue a warning (or error), and generate no code for the entire if-clause, treating an else-clause, if present, as unconditional code? ]</p>
<p>Not if they claim to conform to IEEE 754. Of course if you enable -ffast-math or equivalent flags such test will happily fail, but in that case you are explicitly asking for non-IEEE 754 compliant behavior (and many of such optimizations remove the special behavior for non-numerical values, i.e. you may not even get the NaNs when you expect them).</p>
<p>[ A quick way to check for NaN that doesn&#39;t require comments is to use, wait for it, isnan(). ]</p>
<p>Right, if x was actually a double; but there x was a MathVector&lt;3, double&gt;, which overloaded the operator==/operator!= to check all the corresponding values of the two operands; I couldn&#39;t just do &quot;if(isnan(x))&quot;. The alternatives were adding yet another distracting for or just if(x!=x) (which, by the way, is well known idiom for anyone working with FP). Also, it *is* commented (there&#39;s something like &quot;check for NaNs&quot; or stuff like that).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040833">
				<div id="div-comment-1040833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JustSomeGuy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040833">
			February 21, 2013 at 7:29 pm</a>		</div>

		<p>Interestingly, NONE of the possibilities listed are permitted by the ISO C standard (as at C99 anyway). Infinities are meant to be &quot;[-]inf[inity]&quot; (or uppercase for the %F printf variant) and all NaNs start with &quot;[-]nan&quot; (again uppercase for %F).</p>
<p>However, since C90 is silent on the underlying representation of floating point, and does not specify what&#39;s printed for the non-specific values, I guess MS can be said to comply with *a* C standard, albeit a 20-year old one &#8211; that&#39;s gotta put it in TurboC territory surely :-)</p>
<p>Just kidding, it&#39;s actually a nice product, I just can&#39;t resist taking a dig at the behemoths sometimes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040893">
				<div id="div-comment-1040893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040893">
			February 22, 2013 at 7:15 am</a>		</div>

		<p>What&#39;s the 1 for? (I posted this yesterday, but I think it didn&#39;t go through)</p>
<div class="post">[<em>I don&#39;t know. My guess is so that it at least looks enough like a number so atoi won&#39;t barf. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-1040903">
				<div id="div-comment-1040903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040903">
			February 22, 2013 at 7:25 am</a>		</div>

		<p>JustSomeGuy: Visual C++ does not claim, and never has claimed, to be a C99 compiler. It is a mostly-conformant C++98 compiler (with various C++11 extensions in more recent versions), with a selectable C90 mode.</p>
<p><a rel="nofollow" target="_new" href="http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/" rel="nofollow">herbsutter.com/&#8230;/reader-qa-what-about-vc-and-c99</a></p>
<p>C99 is not a priority for Microsoft. If you want to use C99, use a different compiler.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman odd alt thread-odd thread-alt depth-1" id="comment-1040913">
				<div id="div-comment-1040913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1040913">
			February 22, 2013 at 7:58 am</a>		</div>

		<p>@j b: &quot;In an embedded system, &#39;volatile&#39; is an extremely important keyword.&quot;</p>
<p>Absolutely. Of course, in fairness, you shouldn&#39;t expect Windows (or any other environment) high-level programmers to know this.</p>
<p>As an embeeded hardware designer who also develops uP peripherals in FPGAs and sometimes writes the embedded C that accesses those real-time peripherals, I quickly learned the use of volatile to prevent the compiler from optimizing out repeated register reads in a loop.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041023">
				<div id="div-comment-1041023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1041023">
			February 22, 2013 at 12:47 pm</a>		</div>

		<p>@jb:</p>
<p>Optimising compilers only optimise things cautiously. If X is an int, and the compiler sees if(X != X), it might say &quot;that&#39;s always gonna be FALSE, so I can optimise it away&quot;. But if X is a float or a double, it won&#39;t optimise it, precisely BECAUSE there is a float and double (namely the NaNs) for which (X != X) is not FALSE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041033">
				<div id="div-comment-1041033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1041033">
			February 22, 2013 at 12:49 pm</a>		</div>

		<p>@Zan:</p>
<p>&quot;What is even more confusing about floating point math is that &quot;x = y; z = y; if (x != z)&quot; may very well return true because of 64-bit double storage in RAM vs 80-bit storage in x87 registers.&quot;</p>
<p>If you&#39;re comparing floats for equality, you&#39;re Doing It Wrong(TM).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041423">
				<div id="div-comment-1041423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nobugz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1041423">
			February 25, 2013 at 8:06 pm</a>		</div>

		<p>Puzzler: what kind of infinity is &quot;1.#J&quot;?</p>
<p>&nbsp; &nbsp;double z = 0;</p>
<p>&nbsp; &nbsp;printf(&quot;%.2f&quot;, 1/z);</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042033">
				<div id="div-comment-1042033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/nurbles_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>nurbles@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1042033">
			February 27, 2013 at 1:35 pm</a>		</div>

		<p>The &quot;1.#J&quot; infinity is one of the other kinda after ROUNDING has occurred.</p>
<p>I&#39;m ashamed to admit it, but it took us years to realize that simple fact.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1042093">
				<div id="div-comment-1042093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nobugz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130221-00/?p=5183#comment-1042093">
			February 27, 2013 at 3:56 pm</a>		</div>

		<p>Hehe, don&#39;t be ashamed. &nbsp;There are not a lot of computer scientists that know what rounded infinity looks like.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>