<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (30)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-bboorman even thread-even depth-1 parent" id="comment-1271425">
				<div id="div-comment-1271425" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271425">
			October 31, 2016 at 7:11 am</a>		</div>

		<p>I&#8217;ve been using micros for over 30 years, and probably the oldest I&#8217;ve used were 8085-based single-board-computers. So, I&#8217;ve never seen a stack-less processor.</p>
<p>The first thing that jumps out at me (haha, get it?) is that this technique wouldn&#8217;t work on systems that boot out of ROM, or at least you couldn&#8217;t have subroutines in your ROM code.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1271435">
				<div id="div-comment-1271435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271435">
			October 31, 2016 at 7:28 am</a>		</div>

		<p>If I remember correctly PowerPC doesn&#8217;t really have a stack.  The register used as the stack pointer is convention and there are no push or pop instructions.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-3" id="comment-1271505">
				<div id="div-comment-1271505" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271505">
			October 31, 2016 at 9:46 am</a>		</div>

		<p>Many RISC processors do not have an architectural stack, but they usually come with recommended convention for which register to treat &#8220;as if&#8221; it were a stack pointer.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1271445">
				<div id="div-comment-1271445" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271445">
			October 31, 2016 at 7:58 am</a>		</div>

		<p>Thanks for making me feel young; that doesn&#8217;t happen very often lately.<br />
I don&#8217;t think I&#8217;ve ever seen a stack-less processor either.  40 years ago I was an undergraduate taking first-year&#8221;Fortran for Engineers&#8221; and had no idea what a stack was.  But, the next year I took a mini-computer course and programmed four different mini-computers in assembly language.  I think one required that you do a push and jump on a subroutine call and a pop and jump on a return, but I&#8217;m pretty sure they all had stacks. After that, I started programming 8-bit microcomputers (Motorola, Intel, Zylog) and they all had stacks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1271465">
				<div id="div-comment-1271465" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271465">
			October 31, 2016 at 8:33 am</a>		</div>

		<p>The Parallax spin processor is stackless, uses self-modifying-code in the JMPRET instruction to edit the last instruction of a function to splice in the return address, and boots from ROM, and has functions in the ROM image.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-bboorman odd alt depth-3" id="comment-1271466">
				<div id="div-comment-1271466" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271466">
			October 31, 2016 at 8:50 am</a>		</div>

		<p>How does it &#8220;self-modify&#8221; the code in ROM? By definition, ROM contents are unalterable. Are the ROM functions copied into RAM at boot and those are what get modified?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman even depth-3 parent" id="comment-1271475">
				<div id="div-comment-1271475" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271475">
			October 31, 2016 at 8:56 am</a>		</div>

		<p>After some quick research, the Parallax copies it&#8217;s code from ROM to RAM as part of boot. So my initial comment stands &#8211; that is, you can&#8217;t execute subroutines out of ROM.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-davebacher odd alt depth-4" id="comment-1271545">
				<div id="div-comment-1271545" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271545">
			October 31, 2016 at 12:11 pm</a>		</div>

		<p>The strategy for doing it on ROM is to use a double jump.</p>
<p>For example, if I put a jmp at 0x0FF, I can have the app poke the return address it wants at 0x0100.  My ROM then jumps to 0x0FF consistently.  This sounds terrible &#8212; but its already how you&#8217;re communicating to ROM / OS on these architectures anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1271455">
				<div id="div-comment-1271455" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CarlD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271455">
			October 31, 2016 at 8:21 am</a>		</div>

		<p>Shades of the IBM 360 BALR instruction come to mind &#8211; Branch and Link Register.  Good times :)</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1271485">
				<div id="div-comment-1271485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271485">
			October 31, 2016 at 9:06 am</a>		</div>

		<p>And BR  R14.  Ah yes, the IBM 360.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1271525">
				<div id="div-comment-1271525" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271525">
			October 31, 2016 at 11:18 am</a>		</div>

		<p>BALR actually worked very well.  There were downsides, though.  With base-displacement addressing, if one wanted to use a referenced link, you were limited to a 4K space.  </p>
<p>For one project, I had to build &#8212; from scratch &#8212; an interpreter for S/360 all in BAL* &#8212; no privileged instructions.  I ended up building my own subroutine calling package that worked well and could handle recursion.  The crux of it was that I had to build my own stack routines.</p>
<p>Youngins today have no idea of the low level stuff we had to do in the olden days just to get things to work.</p>
<p>*BAL is Basic Assembler Language on S/360 and its follow-ons.  One could call OS SVCS but there was no access to anything that typical system software would need to do.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1271536">
				<div id="div-comment-1271536" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271536">
			October 31, 2016 at 11:27 am</a>		</div>

		<p>Ooops &#8211; typo &#8212; 12K for referenced links.  I truly am getting too old.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1271625">
				<div id="div-comment-1271625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271625">
			November 1, 2016 at 7:50 am</a>		</div>

		<p>Operating system modules (under 360 and 370 VM) had to be 4K or less in size, I believe, especially if they were pageable.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1271646">
				<div id="div-comment-1271646" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271646">
			November 1, 2016 at 8:21 am</a>		</div>

		<p>Yes, you are correct.  The page size was 4K and certain routines in the OS had to fit in 4k as to minimize paging.</p>
<p>One of my professors at UC wrote the debugger portion of OS/360.  Originally OS/360 was going to have a user configurable page size.  IBM had to drop that because of the requirement that they didn&#8217;t want certain things utilizing more than 1 page.  If I remember correctly, the selectable page sizes were going to be 512B, 1K, 2K and 4K.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1271495">
				<div id="div-comment-1271495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271495">
			October 31, 2016 at 9:20 am</a>		</div>

		<p>Oh. I thought it only meant COMMON blocks were static.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1271515">
				<div id="div-comment-1271515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271515">
			October 31, 2016 at 10:48 am</a>		</div>

		<p>Back in the long ago time, I programmed on Datapoint systems.</p>
<p>They had a stack, but it was implemented in the CPU itself.  There was a separate memory store of sixteen 16-bit words for the stack.  This meant that you couldn&#8217;t call more than 16 levels deep.  It would wrap back around and overwrite the first address if you did.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1271555">
				<div id="div-comment-1271555" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erkin Alp GÃ¼ney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271555">
			October 31, 2016 at 1:02 pm</a>		</div>

		<p>&gt; Another convention was to store the return address in a global variable somewhere<br />
Then that is your stack pointer.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1271565">
				<div id="div-comment-1271565" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271565">
			October 31, 2016 at 5:12 pm</a>		</div>

		<p>Nope. It&#8217;s one variable per function with predictable consequences if recursion is attempted.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-odd thread-alt depth-1" id="comment-1271575">
				<div id="div-comment-1271575" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271575">
			October 31, 2016 at 6:42 pm</a>		</div>

		<p>Sounds like how TSR works as described in here:<br />
<a href="http://textfiles.com/virus/memres.txt" rel="nofollow">http://textfiles.com/virus/memres.txt</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1271585">
				<div id="div-comment-1271585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Styles</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271585">
			November 1, 2016 at 6:30 am</a>		</div>

		<p>Hence the FORTRAN assigned GOTO. <a href="http://www.lahey.com/docs/lfprohelp/F95ARAssigned_GOTOStmt.htm" rel="nofollow">http://www.lahey.com/docs/lfprohelp/F95ARAssigned_GOTOStmt.htm</a></p>
<p>If you like you can look on the way this was used as a way of implementing the &#8216;subroutine&#8217; &#8216;design pattern&#8217;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1271605">
				<div id="div-comment-1271605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271605">
			November 1, 2016 at 7:16 am</a>		</div>

		<p>At school we weren&#8217;t taught using a real microprocessor instead we had to learn a fictitious processor for which we had two similar (but subtly different) emulations.</p>
<p>I always wondered why this processor had both types of subroutine instruction; I suppose it meant you could write an entire program stacklessly if you so wished, although you would obviously be unable to make use of the library ROM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1271645">
				<div id="div-comment-1271645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Elliott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271645">
			November 1, 2016 at 8:09 am</a>		</div>

		<p>I&#8217;ve seen BIOSes where the self-test doesn&#8217;t use any RAM until it&#8217;s verified that there&#8217;s RAM there to use, so to call a subroutine they put the return address in one of the processor registers (usually BP; sometimes SI, if a SI-is-return-address subroutine in turn wants to call a BP-is-return-address subroutine).</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-msn even depth-2" id="comment-1271665">
				<div id="div-comment-1271665" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/poizan42' rel='external nofollow' class='url'>poizan42</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271665">
			November 1, 2016 at 8:29 am</a>		</div>

		<p>The coreboot (or LinuxBIOS back then) project has actually made a C compiler for this &#8211; ROMCC</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1271827">
				<div id="div-comment-1271827" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271827">
			November 1, 2016 at 12:26 pm</a>		</div>

		<p>Oh man. Talk about a constrained environment.</p>
<p>I heard the newer processors boot up in a mode where the L2 or L3 cache is RAM and remains so until BIOS initializes southbridge.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1271935">
				<div id="div-comment-1271935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Patrick Star</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271935">
			November 2, 2016 at 5:10 am</a>		</div>

		<p>In the one I&#8217;ve worked with (Phoenix BIOS), the convention is to store the return address in BX. Also, to preserve the value of registers during a stackless function call, it uses the top 16 bits of the 32 bit registers. Remember, this all takes place very early, so it&#8217;s all 16 bit realmode &#8211; no 32 bits of address space yet and thus not much other use for the top 16 bits anyways.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1272045">
				<div id="div-comment-1272045" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1272045">
			November 2, 2016 at 12:36 pm</a>		</div>

		<p>Why can&#8217;t modern processors use 32-bit addressing early on, even during booting?  Or is there just no reason to?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1272055">
				<div id="div-comment-1272055" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Patrick Star</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1272055">
			November 2, 2016 at 1:23 pm</a>		</div>

		<p>DWalker07: Modern x86 CPUs still start in 16 bit real mode. However, EFI (as opposed to classic BIOS) enable protected mode and a flat 32 bit address space very early &#8211; one of the very first thing they do, in fact, long before even RAM is available.</p>
<p>Classic BIOSes basically stay in real mode for most of the boot &#8211; however, a bit later in the process they usually enable 32 bit addressing (using a trick called Flat Real Mode or Unreal Mode) so they can address more than 1MB of memory. After all &#8211; even just the BIOS itself is significantly larger than the original 8086 memory map assumes, and lots of more modern hardware is mapped way above 1MB, so you need that to get any sort of work done. But you still need compatibility with all the legacy code and things like VGA BIOS and option ROMs, so therefore they stay in real mode.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1272395">
				<div id="div-comment-1272395" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Patrick Star</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1272395">
			November 5, 2016 at 7:31 pm</a>		</div>

		<p>It&#8217;s not just that it decides to not use RAM &#8211; it simply can&#8217;t use it until it&#8217;s been initialized. Nowadays you solve this with cache-as-RAM (though last time I looked it&#8217;s not enabled on boot &#8211; you have to enable it yourself). Back in the days before this you had to stay stackless until at least some RAM was usable, typically the bottom 1MB or so. You can actually get a surprising amount of work done in that environment!</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1271875">
				<div id="div-comment-1271875" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rick C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1271875">
			November 1, 2016 at 2:20 pm</a>		</div>

		<p>Store the return address somewhere?  Looks like you missed an opportunity, Raymond:  &#8220;Nothing to push here, MOV along&#8221;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1272385">
				<div id="div-comment-1272385" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wombat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161031-00/?p=94605#comment-1272385">
			November 5, 2016 at 1:34 pm</a>		</div>

		<p>It was possible to implement recursive code on an IBM 370 mainframe, despite not having a stack. What you did was start by calling a dynamic memory allocate for what was effectively a stack frame, then save all registers in that dynamic block (the space after that was for local variables. You got the effect of the stack but it cost a memory allocation call.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>