<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-202113">
				<div id="div-comment-202113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henry Kropf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202113">
			August 10, 2004 at 7:49 am</a>		</div>

		<p>Raymond, didn&#8217;t you mean:</p>
<p>HANDLE h = CreateFileMapping(INVALID_HANDLE_VALUE, 0<br />
<br />                  PAGE_READWRITE, -1, 0, NULL);<br />
<br />                                  ^^</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202123">
				<div id="div-comment-202123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Qbeuek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202123">
			August 10, 2004 at 7:57 am</a>		</div>

		<p>Raymond is right &#8211; take a look into MSDN for a description of CreateFileMapping parameters.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202133">
				<div id="div-comment-202133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com/' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202133">
			August 10, 2004 at 8:08 am</a>		</div>

		<p>Mm. If we&#8217;re going to be critical I&#8217;ll point out a missing comma before PAGE_READWRITE and that I&#8217;d normally use NULL, rather than 0, for lpAttributes (especially if you&#8217;re going to use NULL for lpName). It&#8217;s a style point, obviously.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202143">
				<div id="div-comment-202143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henry Kropf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202143">
			August 10, 2004 at 8:23 am</a>		</div>

		<p>Ooops, yep. Ahhh mornings.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202153">
				<div id="div-comment-202153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miles Archer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202153">
			August 10, 2004 at 8:37 am</a>		</div>

		<p>Is this technique worth the trouble? Can it give reasonable performance?</p>
<p>Assume for the moment that I&#8217;m an ignorant manager ;-)</p>
<p>I have a CAD like application where users are building 3D models that won&#8217;t fit in 2GB and some day real soon won&#8217;t fit in 3GB. Is this a viable option or will performance suck? </p>
<p>Could you use this in conjuction with some sort of ram disk?</p>
<p>Or is all of this a waste of time and we should just plan on using 64 bit proc when the OS is read?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202163">
				<div id="div-comment-202163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202163">
			August 10, 2004 at 8:46 am</a>		</div>

		<p>The mapping virtual memory to multiple addresses trick is very handy. I keep meaning to write an article for MSDN magazine on it; it&#8217;s very useful for high-throughput networking &#8211; and for high-speed MPEG decoders ;-)</p>
<p>The only trick is that there&#8217;s no easy way of doing an all-in-one mapping of the memory to two adjacent blocks; you always run the risk that the memory you set aside is going to be gazumped before you can map the two virtual memory areas into adjacent sections.</p>
<p>I keep meaning to find someone in the kernel team to ask if they&#8217;ll add this in as a feature.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202183">
				<div id="div-comment-202183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shaun</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202183">
			August 10, 2004 at 10:31 am</a>		</div>

		<p>You said you were going to write a byte, but you read it instead :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202203">
				<div id="div-comment-202203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Jackson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202203">
			August 10, 2004 at 12:14 pm</a>		</div>

		<p>Simon, out of curiousity, how is that mapping virtual memory trick handy?  It seems that the biggest problem with that trick is that you never  have fine control over where these pages are located.</p>
<p>Now, if I could go and allocate a large set of pages, and only then subdivide them and point them to varying places, that would be cool.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202213">
				<div id="div-comment-202213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202213">
			August 10, 2004 at 12:31 pm</a>		</div>

		<p>All someone has to do now is write a virtual-virtual page manager library on top of this, and you can access terabytes? pentabytes? of memory.  Build your backing disk file, and put this vvpm on top of it.</p>
<p>Performance?  Well, then you&#8217;d need more than 4GB of RAM, in which case why didn&#8217;t you just go get a 64bit processor in the first place.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202223">
				<div id="div-comment-202223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202223">
			August 10, 2004 at 1:37 pm</a>		</div>

		<p>John:</p>
<p>Allocate a memory mapped section &#8211; 64kb in size is the minimum due to Windows platform constraints.</p>
<p>Reserve a block of memory 128kb in length in the memory map using VirtualAlloc.</p>
<p>Now, release those blocks, and map the memory mapped section into the 128kb area twice &#8211; one after the other.</p>
<p>You can now use the 128kb block as a persistent ring buffer that acts in an optimal fashion; when the head pointer moves into the second 64kb block, you adjust the head and tail back into the first 64kb block. You never run out of memory, never have to compact the buffer, and you can access it as fast as the processor can handle (unlike other ring buffer implementations which often force you to read data out one byte at a time).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202233">
				<div id="div-comment-202233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.rotd.org/' rel='external nofollow' class='url'>Andreas Magnusson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202233">
			August 10, 2004 at 4:14 pm</a>		</div>

		<p>Simon, neat trick, I&#8217;m not sure I fully understand this but if VirtualAlloc allocates memory in your process&#8217; (virtual) address space, shouldn&#8217;t it be safe from being &quot;gazumped&quot; (unless you &quot;gazump&quot; it yourself)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202243">
				<div id="div-comment-202243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202243">
			August 10, 2004 at 5:38 pm</a>		</div>

		<p>&quot;one-to-one mapping between virtual memory and virtual address space&quot;</p>
<p>I think the wording is a bit confusing here. I think what Raymond&#8217;s explanation really amounts to is &quot;one-to-one mapping between virtual memory and physical memory&quot;. And this mapping is indeed not one-to-one, multiple PA can be mapped to same VA, but one VA only maps to one PA in a single address space.</p>
<p>Take his sample program, for demonstration purpose, especially the one referred in his link &quot;you can map the same memory to multiple addresses&quot;, you will be granted two virtual addresses (actually logical addresses, but on most mordern ia32 OS, it&#8217;s almost always true logical address and virtual address are inter changable terms). They points to the same data in&#8211;now here is the secret&#8211;physical memory. This can be easily verfied if you know how to use a kernel inspection tool. For example, in my case, I got two pointers, 0x8a0000, 0x8b0000, on windows 2000, the virtual address of the PTE that contains the virtual address itself are translated to 0xc0002280 and 0xc00022c0. And if you go to both virtual addresses and display the content, they are 0x095fnnnn and 0x095fmmmm, remember the PTE_MASK? :) So the real physical addresses for both virtual memory addresses are 0x095f0000. </p>
<p>In conclusion, multiple PA can be mapped to the same VA, but one VA only maps to one PA in a single address space.</p>
<p>Raymond, I enjoyed your writing and keep up the good job!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202253">
				<div id="div-comment-202253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu**</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202253">
			August 10, 2004 at 5:45 pm</a>		</div>

		<p>&quot;0x095fnnnn and 0x095fmmmm&quot; are actually<br />
<br />0x095ff0nn and 0x095ff0mm</p>
<p>and btw, the PA changes everytime you run the program, but the two VA addresses rarely changes because afterall they are virtual :)</p>
<p>sorry about the typo.<br />
<br />ps, would be nice to be able to edit comment</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202263">
				<div id="div-comment-202263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202263">
			August 10, 2004 at 6:02 pm</a>		</div>

		<p>I stand by my original statement. They both map the same virtual memory, which since it happens to be present, also map the same physical memory. But if it gets paged out, then it doesn&#8217;t exist in physical memory yet still exists in virtual memory. And that virtual memory is still shared.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202273">
				<div id="div-comment-202273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202273">
			August 10, 2004 at 6:58 pm</a>		</div>

		<p>Raymond, physical memory doesn&#8217;t necessarily mean RAM, it&#8217;s broader term referred to actual data storage, thus it can be pagefile. When the data is swapped out, the pte is marked as non-present, however, it&#8217;s a fake non-present, its bits actually point to the location of the data in the pagefile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202283">
				<div id="div-comment-202283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202283">
			August 10, 2004 at 7:12 pm</a>		</div>

		<p>&quot;They both map the same virtual memory&quot; is really  bad wording imo. They are really same physical memory, different virtual memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202293">
				<div id="div-comment-202293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202293">
			August 10, 2004 at 8:04 pm</a>		</div>

		<p>Andreas: </p>
<p>The problem is that what I do is reserve the memory space using VirtualAlloc, and then I have to release my reservation on that space in order to set up the memory mapping there.</p>
<p>Goes like this:</p>
<p>1. Reserve 128kb span of virtual memory space<br />
<br />2. Get pointer to 128kb span.<br />
<br />3. Release 128kb span of virtual memory space.<br />
<br />4. Map 64kb at pointer.<br />
<br />5. Map 64kb at pointer + 64kb.</p>
<p>That&#8217;s why I want a kernel call; there&#8217;s a chance that (especially if I&#8217;m using 3rd party COM objects) something else in another thread can allocate a new page in my virtual memory map for its own heap &#8211; and if it happens between 3 and 5, there&#8217;s a chance that my allocation will fail.</p>
<p>Steps 1 through 3 are used in an effort to (hopefully!) make it more likely that steps 4 and 5 will succeed. But it&#8217;s not foolproof.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202303">
				<div id="div-comment-202303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202303">
			August 10, 2004 at 9:02 pm</a>		</div>

		<p>&quot;Physical memory doesn&#8217;t necessarily mean RAM, it&#8217;s broader term referred to actual data storage, thus it can be pagefile.&quot;  Perhaps that&#8217;s your definition of physical memory, but I think you&#8217;ll find that in most texts, physical memory means &quot;memory chips&quot;. Certainly that&#8217;s what the x86 CPU manuals mean.</p>
<p>I&#8217;ve made a note to myself to draw a diagram in a future entry to explain how virtual address space, virtual memory, and physical memory all fit together, since it seems there is a lot of confusion over it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202323">
				<div id="div-comment-202323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">God</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202323">
			August 11, 2004 at 12:36 am</a>		</div>

		<p>Dead mpz. No.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202333">
				<div id="div-comment-202333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">God</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202333">
			August 11, 2004 at 12:38 am</a>		</div>

		<p>Oops, Freudian slip there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202343">
				<div id="div-comment-202343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202343">
			August 11, 2004 at 12:39 am</a>		</div>

		<p>mpz &#8211; no, we can&#8217;t. Some of these &quot;hacks&quot; are actually really damn efficient ways of using the system. Moving to AMD64 doesn&#8217;t have anything to do with them one way or another.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202353">
				<div id="div-comment-202353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.rotd.org/' rel='external nofollow' class='url'>Andreas Magnusson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202353">
			August 11, 2004 at 12:56 am</a>		</div>

		<p>Simon:<br />
<br />Yeah, I got that, but if you do this setup at a time when there&#8217;s only one thread (e.g. at startup) it should be safe, right?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202363">
				<div id="div-comment-202363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sean McLeod</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202363">
			August 11, 2004 at 2:07 am</a>		</div>

		<p>Another variation of allocating/using more memory than your adress space is the Address Windowing Extensions (AWE) API set, which allows user applications to use up to 64 GB of physical non-paged memory in a 32-bit virtual address space on 32-bit platforms, with windowed views to this physical memory from within the applicationâ€™s virtual address space.</p>
<p>Which has been used for quite a few years on 32bit Intel Xeon systems which support 36bits for physical addresses.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202373">
				<div id="div-comment-202373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.blacksun.org.uk/' rel='external nofollow' class='url'>Paul Walker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202373">
			August 11, 2004 at 2:07 am</a>		</div>

		<p>Simon &#8211; I&#8217;m not sure that mapping the buffer twice helps speed that much. Okay, it means that you don&#8217;t have to access byte-by-byte the whole time, but in practice you wouldn&#8217;t do that anyway, and you still have to do the comparison to buffer-size in order to wrap once you have gone off the end.</p>
<p>Having said all that, I haven&#8217;t actually tested it. Might do so in a bit. :)</p>
<p>Regarding the interleaving of memory &#8211; with all the stuff Windows lets you do to its internals, isn&#8217;t there a call to temporarily lock the scheduler?</p>
<p>(By the way &#8211; still waiting for Statues of Ice&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202393">
				<div id="div-comment-202393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave stokes</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202393">
			August 11, 2004 at 3:17 am</a>		</div>

		<p>Hmm, well, what it comes down to is letting the system do some buffer handling and cacheing for you (which I guess is what virtual memory and paging is basically about). Your suggestion Raymond doesn&#8217;t give you 4GB addressability, it just lets you look at a window into that data inside your 2/3Gb space which you have to manage with some not so convenient code. I don&#8217;t know the physical addressing limit of current Intel chips, but given it&#8217;s a 32 bit architecture I guess it&#8217;s at most 4Gb (well, there&#8217;s some real address extensibility PAE? used by Datacenter Server, I believe). Anyway, into which (assuming you even have so much real storage) quite a bit of other stuff like bits of the the OS and other apps and data have to fit, so probably you end up paging most of a 4Gb buffer. While such functions as (virtual?) file mapping maybe make addressing a bit easier, and enable you to store stuff simply in the page file, you could also do it yourself with the file system. But then of course you might be double paging some of the data without knowing it. The fact is, you can&#8217;t just take a linear address space (or range) of say 4GB and address it directly, which is what would be nice, and make the programming much simpler. Some architectures let you do just that, regardless of how much real storage or virtual storage address range in a normal address space is available.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202403">
				<div id="div-comment-202403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202403">
			August 11, 2004 at 5:28 am</a>		</div>

		<p>&quot;Certainly that&#8217;s what the x86 CPU manuals mean. &quot;, show me where this manual is. In fact, the intel ia32 manuals deliberately avoid a specific definition of what physical address(memory) really means. It&#8217;s not only my definition but the definition shared by many other windows hackers such as Shreiber and the sysinternal wizards. </p>
<p>Looking forward to your diagram explaining the relation between *virtual address space&quot; and &quot;virtual memory&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202413">
				<div id="div-comment-202413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202413">
			August 11, 2004 at 5:40 am</a>		</div>

		<p>The ia32 system manual do make a distinction between physical memory (RAM) and disk pagefile. The windows implemention (linux does this too I believe) uses non-present PTE to locate pagefile data, therefore, the more exact term is physical address that we use to refer to actual data storage in the system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202313">
				<div id="div-comment-202313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mpz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202313">
			August 10, 2004 at 10:41 pm</a>		</div>

		<p>Dear God. Can&#8217;t we all just go AMD64 *right now* and forget these memory hacks ever existed?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202433">
				<div id="div-comment-202433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202433">
			August 11, 2004 at 5:45 am</a>		</div>

		<p>&quot;you can&#8217;t just take a linear address space (or range) of say 4GB and address it directly&quot;</p>
<p>Please elaborate on what you mean by &quot;address it directly&quot;. You can do that today. It&#8217;s called a 32-bit pointer.</p>
<p>By physical memory I mean things which are addressed via physical addresses.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202463">
				<div id="div-comment-202463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon Potter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202463">
			August 11, 2004 at 6:11 am</a>		</div>

		<p>Raymond, I would close the comments on this article now before everyone gets even more confused :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202483">
				<div id="div-comment-202483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave stokes</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202483">
			August 11, 2004 at 7:16 am</a>		</div>

		<p>Raymond &#8211;</p>
<p>&quot;Please elaborate on what you mean by &quot;address it directly&quot;. You can do that today. It&#8217;s called a 32-bit pointer.&quot;</p>
<p>Yeah, I&#8217;m just a dumb guy. But I&#8217;d have thought my meaning was actually pretty clear from everything else I wrote, I&#8217;m talking about addressing the 4GB you&#8217;ve mapped to what you&#8217;ve chosen to call &quot;virtual memory&quot;. You can&#8217;t address that directly, only as you say yourself by mapping parts of it to a window in your 2GB address space. </p>
<p>With the hardware mechanisms I&#8217;ve mentioned in a previous thread, data in a seperate address space can have a full range of say 4GB which can be directly addressed by suitable hardware registers, for what it&#8217;s worth.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202493">
				<div id="div-comment-202493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202493">
			August 11, 2004 at 7:47 am</a>		</div>

		<p>Alas that&#8217;s not how the i386 works; more on this is scheduled for a future entry.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202513">
				<div id="div-comment-202513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202513">
			August 11, 2004 at 8:44 am</a>		</div>

		<p>Andreas wrote:<br />
<br />&gt; Yeah, I got that, but if you do this setup<br />
<br />&gt; at a time when there&#8217;s only one thread (e.g.<br />
<br />&gt; at startup) it should be safe, right?</p>
<p>Because of load-time DLL injection, and depending on the version of the OS and which libraries it needs, there&#8217;s no real way of 100% ensuring that.</p>
<p>Paul Walker wrote:<br />
<br />&gt; Simon &#8211; I&#8217;m not sure that mapping the buffer<br />
<br />&gt; twice helps speed that much. Okay, it means<br />
<br />&gt; that you don&#8217;t have to access byte-by-byte<br />
<br />&gt; the whole time, but in practice you wouldn&#8217;t<br />
<br />&gt; do that anyway, and you still have to do the<br />
<br />&gt; comparison to buffer-size in order to wrap<br />
<br />&gt; once you have gone off the end. </p>
<p>You only have to do the comparison to buffer size when you add or remove data from the buffer &#8211; which is infrequently. And even then, you only need to adjust your head pointer when you remove data.</p>
<p>Compare it with the other ring buffer implementations out there on CodeProject et al. Either you can make things really complicated, and deal with the buffer in two halves, or you access it a byte at a time.</p>
<p>Also, another advantage of this is that if you use it with overlapped IO, you can set things up such that you can be feeding data into one end of the buffer, consuming it from the other, and whenever you try to do a Send or Write, you can always send the whole contents of the buffer in one go. If you&#8217;re using zero-copy writes/sends, this becomes quite important (eg. high-perf networking).</p>
<p>&gt; Regarding the interleaving of memory &#8211; with<br />
<br />&gt; all the stuff Windows lets you do to its<br />
<br />&gt; internals, isn&#8217;t there a call to temporarily<br />
<br />&gt; lock the scheduler? </p>
<p>Nope. At least, not in user-mode code. That&#8217;d kind of defeat the point of the pre-emptiveness of the scheduler. You can temporarily boost yourself to realtime priority, but that (again) isn&#8217;t 100% foolproof &#8211; you could have other realtime threads to compete with. Another option is to suspend all other threads in your process, and then resume them, but you risk setting up race conditions and losing state that way</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202443">
				<div id="div-comment-202443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://flaphead.dns2go.com/blog/archive/2004/08/11/296.aspx' rel='external nofollow' class='url'>Welcome to Flaphead.com @ Home</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202443">
			August 11, 2004 at 9:09 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202473">
				<div id="div-comment-202473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.blacksun.org.uk/' rel='external nofollow' class='url'>Paul Walker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-202473">
			August 11, 2004 at 6:15 am</a>		</div>

		<p>Regarding all of this&#8230; Linux makes distinctions between various different types of address, such as:</p>
<p>* user virtual addresses (seen by user-space code)<br />
<br />* physical addresses (used between CPU and memory)<br />
<br />* bus addresses (used between peripherals and mem)<br />
<br />* kernel logical addresses<br />
<br />* kernel virtual addresses</p>
<p>I&#8217;d imagine Windows makes at least the same distinctions.</p>
<p>For what it&#8217;s worth, I&#8217;ve never heard physical memory used to refer to anything except RAM chips. Certainly not swap.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204853">
				<div id="div-comment-204853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.savagenomads.net/archives/000203.html' rel='external nofollow' class='url'>Savage Nomads</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-204853">
			August 20, 2004 at 1:44 pm</a>		</div>

		<p>&amp;nbsp; As Evan&amp;nbsp;already mentioned on his blog, Raymond Chen has a great series on /3GB switch on his blog. What is really cool is that Raymond takes on some myths about the /3GB switch and&amp;nbsp; the fact that he&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-205083">
				<div id="div-comment-205083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-205083">
			August 22, 2004 at 8:11 am</a>		</div>

		<p>&quot;Allocate means it is available in my address space.&quot;</p>
<p>No! You missed the whole point of this entry.</p>
<p>&quot;Mapped&quot; means it is available in your address space.  &quot;Allocate&quot; means that the memory is committed to you.</p>
<p>You can &quot;actually&quot; use the memory &#8211; my ReadByte function shows how.  It&#8217;s not convenient, but it is nevertheless actual.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-205073">
				<div id="div-comment-205073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Tripper</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-205073">
			August 22, 2004 at 7:51 am</a>		</div>

		<p>Something that you are failing to deal with in this series of articles, that makes all their information lost: </p>
<p>explain the different between allocated memory and mapped memory.</p>
<p>If i want to allocate 2.5GB of memory, and i don&#8217;t have the /3GB switch, then i can&#8217;t use 2.5GB of memory.</p>
<p>You try to talk about tricks of mapping parts of files and whatnot. But i want to map a 2.5GB file, i want to access it all; and i can&#8217;t. And that is because without the /3GB switch i cannot allocate more than 2GB.</p>
<p>Dwell on the difference between *technically* somewhere there is more than 2GB of memory set aside for stuff, and *actually* not being able to use more than 2GB.</p>
<p>Allocate means it is available in my address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-208383">
				<div id="div-comment-208383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/archive/2004/09/08/226842.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-208383">
			September 8, 2004 at 11:22 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-744423">
				<div id="div-comment-744423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx' rel='external nofollow' class='url'>Fabulous Adventures In Coding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040810-00/?p=38203#comment-744423">
			June 11, 2009 at 3:05 am</a>		</div>

		<p>I started programming on x86 machines during a period of large and rapid change in the memory management</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>