<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (14)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-282413">
				<div id="div-comment-282413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Risto</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282413">
			June 13, 2005 at 9:13 am</a>		</div>

		<p>Finally, I can offer something intelligent! I did this in a .net program the other day, and there are functions to &quot;suspend updates&quot; to the list while you jam stuff in. Much faster. Offtopic now &#8230; I found my program did not display anything if I only inserted 1 item this way &#8230; still working on it &#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-282463">
				<div id="div-comment-282463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anthony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282463">
			June 13, 2005 at 10:27 am</a>		</div>

		<p>James Risto:  You&#8217;ll need to invalidate after you&#8217;ve SetRedraw(FALSE) to get them to display.</p>
<p>But, I&#8217;ll bet Raymond is going to show us the Virtual list view (in the end anyway) where you don&#8217;t have to insert them at all&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-282473">
				<div id="div-comment-282473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/member/andyandyx' rel='external nofollow' class='url'>Andreas Haeber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282473">
			June 13, 2005 at 10:48 am</a>		</div>

		<p>If no virtual listview then I&#8217;m gonna be disappointed, since he &quot;promised&quot; that in post #1 of the dictionary-serie [1] :)</p>
<p>[1] <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2005/05/09/415714.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2005/05/09/415714.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-282493">
				<div id="div-comment-282493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/andythecornbread/' rel='external nofollow' class='url'>Andy</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282493">
			June 13, 2005 at 2:05 pm</a>		</div>

		<p>Cool! I have been doing these as Raymond has been showing them and I was beggining to wonder when we would see the next one. I check everyday to see if you have a new dictionary tutorial post up. These have been some very cool posts/tutorials/explinations please keep them coming.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-282593">
				<div id="div-comment-282593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282593">
			June 14, 2005 at 3:52 am</a>		</div>

		<p>I consider the start of Raymond&#8217;s &quot;dictionary series&quot; a real masterpiece. Since C++ was introduced (cca. last 12 years) there were so many &quot;language prophets&quot; and the mentality of the most of the &quot;consumers&quot; of these prophecies was always &quot;this new thing is solution for everything&quot;. It was easy for &quot;prophets&quot;, since they didn&#8217;t have to really make something that works. They wrote the books. But the &quot;consumers&quot; spent a hell of the energy following the &quot;prophets&quot;. And here we have it – a lot of inefficient programs using everything possible just because (STL, RTTI, exceptions all around).</p>
<p>Somebody has to write the real truth about all hyped techniques overused in the last years. I haven&#8217;t seen anywhere something so effective like in Raymond&#8217;s articles. Just like</p>
<p><a rel="nofollow" target="_new" href="http://www.lysator.liu.se/c/bwk-on-pascal.html" rel="nofollow">http://www.lysator.liu.se/c/bwk-on-pascal.html</a></p>
<p>explained the real weaknesses of Pascal, it was about the time that somebody demonstrates that STL is not appropriate for really effective programs. I also liked the response of the NET fans. Yes, the first NET version of &quot;dictionary loader&quot; was faster than STL (I was not surprised – anybody who thinks that STL strings and streams should be widely used never made some really serious programs, but only wrote clumsy Basic equivalents in C++). But then Raymond showed what could be done with a good C programming. I&#8217;ve never seen any demonstration that NET can, with optimizations, achieve the same. And I don&#8217;t expect to see it, but I&#8217;d really appreciate if somebody of the NET people proves me wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-282603">
				<div id="div-comment-282603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hanson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282603">
			June 14, 2005 at 4:15 am</a>		</div>

		<p>In response to AC:</p>
<p>I think it&#8217;s unfair to slate the STL.  The only real issue is that it&#8217;s always slower to allocate thousands of objects than to pre-allocate a big chunk of memory and use pointers into it.  This idea goes much deeper than the STL and the STL even supports this approach with custom allocators.</p>
<p>Any technique can be mis-used and it gets tiring to hear the same old &#8216;throw the baby out with the bathwater&#8217; arguments&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-282623">
				<div id="div-comment-282623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Factory</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282623">
			June 14, 2005 at 7:43 am</a>		</div>

		<p>AC:<br />
<br />While there is no such thing as a silver bullet, that does not indicate that all new techniques since 1992 have been rubbish. (BTW C++ was started in the 80&#8217;s)<br />
<br />  And citing inefficiency as a bad thing is the wrong way to think about it. It&#8217;s programmers trading off efficiency for other more important attributes, like for example, maintainability.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-282633">
				<div id="div-comment-282633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joku</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282633">
			June 14, 2005 at 8:56 am</a>		</div>

		<p>The only performance issue I see with .NET is that MS doesn&#8217;t ship every edition of VS with the method level instrumentation tool. With easy tools (not only restricted to the VSTS) readily available to find the performance bottlenecks I am sure they&#8217;d be used already during developing, not only after people mail you how bad the perf is. It&#8217;s likely to take considerable work to fix perf issues after shipping.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-282643">
				<div id="div-comment-282643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2005/06/14/428892.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282643">
			June 14, 2005 at 9:02 am</a>		</div>

		<p>Text callbacks let you delay setting data into the listview.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-282653">
				<div id="div-comment-282653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282653">
			June 14, 2005 at 9:21 am</a>		</div>

		<p>To Ben Hanson: Your only real argument would be to write a STL and standard library version of the Raymond&#8217;s program that has comparable performance. You mention custom allocators &#8212; please use them and demonstrate to all of us your results. I still doubt that you can use strings and reach the goal.</p>
<p>To Factory: Just a few examples: 1) It is always easier to maintain and develop the code without using too much exceptions (if at all). That is confirmed even by Stroustrup. And modern standard library functions raise them all around. 2) Imagine that you received two DLLs to maintain. The interface of one is C++, a bunch of headers of the classes, all using STL,  exceptions and RTTI, and the interface of the second one is one header with some plain structures and a few functions operating on them. If both are supposed to do the same work, which would be easier to maintain?</p>
<p>To Joky: As I said, I&#8217;d really like to see a NET equivalent of Raymond&#8217;s last sample with the comparable performance.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-282673">
				<div id="div-comment-282673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/member/andyandyx' rel='external nofollow' class='url'>Andreas Haeber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282673">
			June 14, 2005 at 1:55 pm</a>		</div>

		<p>AC: As Rico Mariani wrote in his entries about this (see <a rel="nofollow" target="_new" href="http://blogs.msdn.com/ricom/archive/2005/05/19/420158.aspx" rel="nofollow">http://blogs.msdn.com/ricom/archive/2005/05/19/420158.aspx</a>) it&#8217;s impossible for the managed version to be quicker than Raymond&#8217;s final solution because his solution is quicker then the managed overhead. But at what cost? Rico got something reasonably fast without too much effort. So in productivity .NET wins, IMO. But developer productivity is easily traded away for performance when dealing with low-level stuff(e.g. OS scheduling algorithm) which are run every often and will give a huge performance impact to the system.</p>
<p>Is there any who would notice the 0.031 second difference between the final solutions? I doubt. But the programmer would note the amount of time spent for building the managed vs. the unmanaged version of the application.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-282733">
				<div id="div-comment-282733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282733">
			June 14, 2005 at 8:12 pm</a>		</div>

		<p>The question of whether it is necessary to do this kind of code tinkering and get that 0.3 seconds of performance improvement is a question that depends on the application.  For starting up Internet Explorer or Word of course it&#8217;s not needed.  If a web server or SQL server is supposed to respond to some number of requests every second then it&#8217;s almost needed, i.e. you might be able to avoid it by doubling your hardware but you probably want to improve the code first.  If a controller for some component of a car or airplane is supposed to serve 50 operations per second, you need to tinker with the code this way.</p>
<p>Although I wouldn&#8217;t recommend C++ for kernel mode code under an OS, it did work out all right in an embedded system without an OS.  The application had to do a ton of matrix calculations and C++&#8217;s overloading of operators made it easy to write the code.  But the first bottleneck wasn&#8217;t the matrix calculations, it was memory deallocations of temporary objects that were no longer necessary, and the second bottleneck was memory allocations in constructors.  The first step towards optimization was to make Lex and Yacc programs that would convert the application to use named static variables for everything, getting rid of the memory allocations.  Of course the resulting code is unreadable.  Maintenance (bug fixes etc.) still had to be done on the original code.  Other kinds of optimizations were done by tweaking the Yacc program to produce more efficient C++ programs using increasingly tailored subsets of the language.  Other kinds of optimizations produced speedups by lesser and lesser factors, but the factors all multiplied together.  Eventually we got our 50 iterations per second.</p>
<p>Anyway, automatic garbage collection really is one of several things that are enormously useful in rapid application prototyping.  After seeing how the result performs, then you figure out where you need to optimize.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-282773">
				<div id="div-comment-282773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hanson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-282773">
			June 15, 2005 at 2:37 am</a>		</div>

		<p>Reply to EC:</p>
<p>I think we all agree that optimised C will always beat C++ techniques and for sure specialised calls to Windows (say memory mapped files) will also give a huge performance when used well.  What I object to is when programmers say &quot;See? This C++ code is slow!&quot; and instead of trying to improve the speed with better use of the STL etc. they just go straight back to C.  For example if you are appending a lot of data to a std::vector and your code is slow, you can switch to a std::deque for a big performance increase.</p>
<p>It&#8217;s be great to try and prove a point by doing a version of Raymond&#8217;s code using a load of C++ best practices.  I&#8217;m sure it wouldn&#8217;t be faster, but it would be nice to show that it could be competitive.  I doubt I will ever have the time to do this &#8211; so instead I recommend the C++ in-depth series (<a rel="nofollow" target="_new" href="http://www.awprofessional.com/series/series.asp?st=44142&amp;rl=1" rel="nofollow">http://www.awprofessional.com/series/series.asp?st=44142&#038;rl=1</a>) for tips on good C++ usage.</p>
<p>On your DLL comment to Factory:</p>
<p>I wouldn&#8217;t recommend leaking exceptions from a DLL interface.  Probably better to trap the exceptions inside the DLL, convert to an error code, and support an extern &quot;C&quot; interface.</p>
<p>In general I would recommend the approach already mentioned on this thread: Code the highest level C++ you can and then optimise the (noticeably) slow parts, yes, resorting to optimised C if (really) necessary.  That way you should end up with easier to understand and maintain code.  It&#8217;s a real shame when C/C++ programmers opt for either or, instead of this approach, as both languages have a lot to offer in the appropriate context.</p>
<p>Cheers,</p>
<p>Ben</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-283043">
				<div id="div-comment-283043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050613-16/?p=35343#comment-283043">
			June 16, 2005 at 9:03 am</a>		</div>

		<p>Ben Hanson: Ok, so you claim that it you *believe* that it can be made competitive &quot;using best C++ practices&quot;, but you&#8217;ll never have a time to do this. Does it mean that even &quot;using best C++ practices&quot; takes too much time? Hopefully not so much as to read all the books to which you link. I&#8217;d take care, people who write the books will always try to &quot;sell&quot; something new because old things are common knowledge. Yet, that, together with the common sense, is what&#8217;s most of the time the major thing missing in the real projects.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>