<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1236876">
				<div id="div-comment-1236876" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236876">
			July 17, 2015 at 7:11 am</a>		</div>

		<p>Some people joke about how bad On Error Resume Next is, then try { &#8230; } catch (e) {} without batting an eye.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236866">
				<div id="div-comment-1236866" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236866">
			July 17, 2015 at 7:12 am</a>		</div>

		<p>Well that explains why I thought it didn&#39;t work</p>
<p> I never guessed you&#39;d have to press it a bunch of times.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236856">
				<div id="div-comment-1236856" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236856">
			July 17, 2015 at 7:12 am</a>		</div>

		<p>Hey, if it works for web browsers (they completely ignore unknown HTML elements, unknown attributes, unknown CSS, and undefined variables; web sites frequently have JS errors, yet keep working normally) then why not for machine code too?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236846">
				<div id="div-comment-1236846" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236846">
			July 17, 2015 at 7:43 am</a>		</div>

		<p>Thank you Don Corbitt, for all the work I &lt;b&gt;didn&#39;t&lt;/b&gt; lose.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236836">
				<div id="div-comment-1236836" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236836">
			July 17, 2015 at 7:47 am</a>		</div>

		<p>Answer to exercise: what would it mean to ignore a jump instruction??? For unconditional jumps, the program was probably REALLY expecting to jump here. The only way it can fault on the jump instruction itself is a computed jump for which the computation failed, so it has no address to jump to. Failing to jump and just dropping through to the next instruction will probably lead the program somewhere completely random; whatever case appears first in your switch statement, or possibly the top of some other function entirely if this was some kind of computed-tail-call thing. Or some completely other use of computed jumps produced by some esoteric language. In any case, the program will not be happy if the jump doesn&#39;t happen.</p>
<p>The much more likely case of a GPF &quot;caused by&quot; a jump instruction is a perfectly good jump (conditional or not) that led to somewhere meaningless. At this point it&#39;s too late; all Windows knows is you tried to execute instructions somewhere meaningless. It doesn&#39;t know how you got here, so it can&#39;t go back in time and pretend not to take that jump after all. At least, not until MS Research finishes that time machine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236826">
				<div id="div-comment-1236826" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236826">
			July 17, 2015 at 7:56 am</a>		</div>

		<p>@PaulZ: most likely it executes the jump table.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236816">
				<div id="div-comment-1236816" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236816">
			July 17, 2015 at 8:15 am</a>		</div>

		<p>@PaulZ: &nbsp;Why not just record the full memory state of every app continuously in a buffer, to allow the kernel to rewind the app to a time before the issue occurred? &nbsp;I checked with my web developer friends, and they concur that memory is so cheap and plentiful that this is a good idea</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1222081">
				<div id="div-comment-1222081" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Kj&#246;rling</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1222081">
			July 17, 2015 at 9:06 am</a>		</div>

		<p>@Bromide</p>
<p>Because Windows 3.1 was supposed to be able to do something at least moderately *useful* in 1992, on an 80286 with 1 MB RAM?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1222071">
				<div id="div-comment-1222071" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Michael Kj&#246;rling</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1222071">
			July 17, 2015 at 9:56 am</a>		</div>

		<p>*Woosh*</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236806">
				<div id="div-comment-1236806" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236806">
			July 17, 2015 at 11:20 am</a>		</div>

		<p>I like @Bromide&#39;s idea. &nbsp;It&#39;s like formally codifying the &quot;undefined behavior can lead to time travel&quot; rule.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236796">
				<div id="div-comment-1236796" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236796">
			July 17, 2015 at 12:16 pm</a>		</div>

		<p>There was also such application for Windows 95 called Norton Crash Guard. It intercepted crash and did similar things but with fancy UI.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236776">
				<div id="div-comment-1236776" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236776">
			July 17, 2015 at 12:35 pm</a>		</div>

		<p>@Maurits</p>
<p>Surely you can understand the difference between ON ERROR RESUME NEXT, which ignores all errors and executes the next statement immediately after the problem statement, and a try-catch block that can ignore a whole batch of related statements if the exception is recoverable and even expected condition (such as received Parse(&#8230;) call). Of course, throwing exceptions should be avoided as flow control, but .NET 1.0 and 1.1 taught many developers bad habits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236766">
				<div id="div-comment-1236766" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236766">
			July 17, 2015 at 12:38 pm</a>		</div>

		<p>For jump instructions, it&#39;s either a near jump or a far jump. Near jumps can&#39;t fault because Windows would always map in the entire segment. Far jumps would be to the kernel code that does segment loading and so the actual fault would be in kernel code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236756">
				<div id="div-comment-1236756" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236756">
			July 17, 2015 at 3:29 pm</a>		</div>

		<p>@Maurits:</p>
<p>Now, wait a minute. try/catch is an explictly anticipated code flow: the designer understands that if the code breaks anywhere in the try{} block, execution will escape the entire block (terminating in-progress loops, trashing local scopes, etc.) and GOTO the catch block. By invoking try/catch, the designer explicitly consents to this flow, and hopefully writes the catch block as a suitable response to that exception, leaving the application in a logically consistent state. If that&#39;s not the result, then the designer is at fault for writing an inadequate catch block.</p>
<p>But Windows 3.1&#39;s IGNORE is in no way anticipated! It skips over an instruction that, in virtually all cases, the designer fully intended to be executed. The odds of inconsistent state after such an operation are astronomical, and the designer can&#39;t be faulted. Even if the designer expected the exception, &quot;just skip it and resume execution&quot; is not an option that the designer can expect to have occurred!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236746">
				<div id="div-comment-1236746" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236746">
			July 18, 2015 at 4:14 am</a>		</div>

		<p>I have always wanted to leave a comment in this blog but I have always been to late, anyway:</p>
<p>A VERY nice work on those SysErrorBox() designs Mr. Chen! </p>
<p>If you ever meet the people/team behind that part of the Windows development (the SysErrorBox API), they were really doing an awesome job, as well, on the graphical design and keeping it all alive during CPU interrupt execution!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236736">
				<div id="div-comment-1236736" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236736">
			July 18, 2015 at 5:20 am</a>		</div>

		<p>David Stein: I don&#39;t think Maurits was talking about programmers making proper, intentional use of try/catch with carefully designed catch blocks. I think he&#39;s talking about situations where the code is littered with try blocks where the catch block does nothing.</p>
<p>For example, one code base I work with has EVERY. SINGLE. FUNCTION. wrapped in a try block with no logic in the catch block. All of the function&#39;s logic is in the try block; the catch block catches every exception and logs the name of the function and the error message, but there&#39;s no stack trace and no propagation of the error. It&#39;s as if the author wished for ON ERROR RESUME NEXT and did the best he could with his tools to emulate it. I&#39;m honestly not sure which is worse.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1236726">
				<div id="div-comment-1236726" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236726">
			July 18, 2015 at 5:45 am</a>		</div>

		<p>@Ken in NH: RESUME NEXT leaves your program in an inconsistent state. You can hope that every instruction that depended on failed instruction will fail also, but with every &quot;NEXT&quot; you are deeper in the undefined behavior zone.</p>
<p>On the other hand, a try block with an empty catch {} will bail out immediately, silently abandon the whole task, and resume work on something else.</p>
<p>This may be a desired idiom in case we want to just carry on or with badly designed APIs that throw spurious exceptions left and right.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236716">
				<div id="div-comment-1236716" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236716">
			July 18, 2015 at 12:01 pm</a>		</div>

		<p>Back in the bad old days of DOS we had a dbase application that kept suffering from data corruption. &nbsp;I was observing the user work with the program when I noticed that he was presented with the &quot;Abort, Retry, Ignore?&quot; prompt from DOS. &nbsp;He ignored the error and went back to working with the application. He had never mentioned to anyone that he was receiving these messages. &nbsp;When I asked him about why he never said anything, he said that he figured if he was given a choice to ignore the problem by the computer then it must be ok to do so.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236706">
				<div id="div-comment-1236706" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236706">
			July 18, 2015 at 1:53 pm</a>		</div>

		<p>Getting Abort, Retry or Ignore when an application was printing and the printer was offline was also very annoying. I wrote a TSR to solve that one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1236696">
				<div id="div-comment-1236696" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Darran Rowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236696">
			July 18, 2015 at 2:33 pm</a>		</div>

		<p>@Azarien:</p>
<p>Except in the case where someone does:</p>
<p>try{statement();}catch(e){}</p>
<p>try{statement_that_depends_on_previous_statement();}catch(e){}</p>
<p>While it bails out of the current instruction stream immediately, it doesn&#39;t bail out of the current set of actions. Exceptions don&#39;t guarantee that invariants are re-established.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236686">
				<div id="div-comment-1236686" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236686">
			July 18, 2015 at 3:48 pm</a>		</div>

		<p>A try { &#8230; } catch {} can be reasonable if the code is using an idiom such as RAII with the strong exception safe guarantee &#8211; under such circumstances any failure merely leaves the program in the state it was before the operation (or set of operations) started. (Some of the problems with exceptions and the difficulty of offering the strong guarantee have been previously noted in this blog, of course&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1222061">
				<div id="div-comment-1222061" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1222061">
			July 18, 2015 at 4:19 pm</a>		</div>

		<p>/*he said that he figured if he was given a choice to ignore the problem by the computer then it must be ok to do so.*/</p>
<p>In one of my apps I did following thing: if unexpected exception was caught, then app entered &#39;crashed&#39; state: immediately saved current data to special named save file and disabled all save data capabilities (menu items grayed + additional checks in code). Sure user was informed about crash too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236676">
				<div id="div-comment-1236676" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236676">
			July 18, 2015 at 9:32 pm</a>		</div>

		<p>I Googled this Don Corbitt and found he died in a plane crash in 2007. &nbsp;RIP. &nbsp;May your slumber never get an interrupt, and if you do we hope you are patching instruction pointers up in the sky.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236666">
				<div id="div-comment-1236666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236666">
			July 18, 2015 at 9:42 pm</a>		</div>

		<p>Update to previous: I guess it was 1999. &nbsp;My mistake.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1236656">
				<div id="div-comment-1236656" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236656">
			July 18, 2015 at 9:57 pm</a>		</div>

		<p>General Protection Fault in Windows 3.0? Are you sure?</p>
<p>As far as I remember, GPF came to be in Windows 3.1. Windows 3.0 generated Unrecoverable Application Error. Am I wrong?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command odd alt thread-odd thread-alt depth-1" id="comment-1236646">
				<div id="div-comment-1236646" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236646">
			July 18, 2015 at 11:49 pm</a>		</div>

		<p>Now, this is interesting:</p>
<p><a rel="nofollow" target="_new" href="https://support.microsoft.com/en-us/kb/75490">support.microsoft.com/&#8230;/75490</a></p>
<p>Dr. Watson, once used in Windows 3.0, turned Unrecoverable Application Errors into Recoverable Application Errors and added the ignore button. Hence, your &quot;bonus trivia&quot; at the bottom.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236636">
				<div id="div-comment-1236636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236636">
			July 19, 2015 at 1:08 am</a>		</div>

		<p>&gt; Fleet Command said:</p>
<p>&gt; As far as I remember, GPF came to be in Windows 3.1. Windows 3.0 generated Unrecoverable Application Error.</p>
<p>That&#39;s also my recollection.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236626">
				<div id="div-comment-1236626" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236626">
			July 19, 2015 at 11:23 am</a>		</div>

		<p>@Gabe: &quot;EVERY. SINGLE. FUNCTION.&quot;</p>
<p>Yes, I&#39;ve seen this too, and I always wondered who writes this kind of code. Until one day, I spoke with one developer who argued such code was the best possible code one could write. Unfortunately, that was probably not the worst of all problems he had with his brain.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-davebacher even thread-even depth-1" id="comment-1236606">
				<div id="div-comment-1236606" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236606">
			July 19, 2015 at 2:39 pm</a>		</div>

		<p>There is a JavaScript library on GitHub with an impolite name that recursively loads the JavaScript on the page, removing whatever parts error out. &nbsp;This reminds me a lot of that.</p>
<p>As a side note, either option was a sign a blue screen was coming &#8212; and so regardless of which button you hit (often times repeatedly), your next step should be to shut down to DOS, then restart the operating environment. &nbsp;Any time you started receiving GPFs, more bad news was invariably on the way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236596">
				<div id="div-comment-1236596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236596">
			July 19, 2015 at 6:56 pm</a>		</div>

		<p>@DavidStein I&#39;d expect that a large fraction of crashes are from non-critical code. Sure, clicking &quot;ignore&quot; might cause your window to be drawn incorrectly or something.</p>
<p>I&#39;d also expect there was less critical Windows code around when 3.1 was new.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1236586">
				<div id="div-comment-1236586" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236586">
			July 19, 2015 at 10:41 pm</a>		</div>

		<p>@Nitpicker (Corner?): Actually, saying &quot;it was UAE not GPF&quot; has more implications than just nitpicking on a name (or that fact that both messages above are from Windows 3.1.) Back then, UAE was just a plain worthless message that wasn&#39;t even worth seeing. GPF, however, showed segment and offset address. Back then, it was a troubleshooting clue; Windows 3.1 came with Dr. Watson built-in.</p>
<p>Those days were bad days. All those conventional memory, upper memory area, extended memory, expanded memory and worst of all, Lotus-Intel-Microsoft specifications!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236486">
				<div id="div-comment-1236486" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236486">
			July 20, 2015 at 1:49 pm</a>		</div>

		<p>&gt;Until one day, I spoke with one developer who argued such code was the best possible code one could write.</p>
<p>But he missed an important opportunity for optimization.</p>
<p>Having adopted a programming style in which it was made explicit that it didn&#39;t really matter whether you executed any given statement or not, you can take the next step and delete all statements.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236456">
				<div id="div-comment-1236456" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236456">
			July 20, 2015 at 10:45 pm</a>		</div>

		<p>&quot;Why didn&#39;t the code have to know how to ignore jump instructions and conditional jump instructions?&quot;</p>
<p>For an even more obvious reason than everyone else has given: they aren&#39;t memory operations, string memory operations, or selector loads, by the definition of this handler. The 8086 family has never had r/m forms of the conditional jump instructions. As for an indirect unconditional jump, it isn&#39;t really a &quot;memory operation&quot; as such. Besides, there is no way to &quot;ignore&quot; that, so it simply isn&#39;t handled by this handler.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236406">
				<div id="div-comment-1236406" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236406">
			July 21, 2015 at 12:41 am</a>		</div>

		<p>&gt; Fleet Command said:</p>
<p>&gt; Actually, saying &quot;it was UAE not GPF&quot; has more implications than just nitpicking on a name</p>
<p>&gt; (or that fact that both messages above are from Windows 3.1.) Back then, UAE was just a plain</p>
<p>&gt; worthless message that wasn&#39;t even worth seeing. GPF, however, showed segment and offset</p>
<p>&gt; address.</p>
<p>Strange thing: I was sure the UAE pop-up had some sort of debug info in it too. I was already tempted to jump into my DOS VM and take a looksie &#8211; now I will, for sure, install Windows 3.0 and try to crash it (shouldn&#39;t be hard :)).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236196">
				<div id="div-comment-1236196" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236196">
			July 21, 2015 at 3:00 pm</a>		</div>

		<p>@Gabe: It is perfectly sensible in C++ except it shouldn&#39;t be needed since no one should be throwing exceptions in the first place, but in case someone does the best you can do is log it and terminate, if you don&#39;t wish to terminate, or the idiot throwing exceptions was truly idiotic and did it when it was exceptional (should have crashed), then you just log it and continue. You can hunt down the idiot using exceptions in C++ later (with a pitchfork and mob).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1236186">
				<div id="div-comment-1236186" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236186">
			July 21, 2015 at 6:09 pm</a>		</div>

		<p>&quot;Exercise: Why didn&#39;t the code have to know how to ignore jump instructions and conditional jump instructions?&quot;</p>
<p>Because the ignore option does not even become available in those cases as for the conditions listed?</p>
<p>&quot;The faulting instruction is one of the following, possibly with one or more prefix bytes:</p>
<p>Memory operations: op r, m; op m, r; or op m.</p>
<p>String memory operations: movs, stos, etc.</p>
<p>Selector load: lds, les, pop ds, pop es.&quot;</p>
<div class="post">[<em>I guess I didn&#39;t phrase the question clearly enough. &quot;Why weren&#39;t jump instructions on the list?&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1236076">
				<div id="div-comment-1236076" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150717-00/?p=90881#comment-1236076">
			July 22, 2015 at 8:20 am</a>		</div>

		<p>Allan: In my case, every single function body is wrapped in a single try{}. As far as I can see, there is no thought given to whether exceptions are expected or not. If any exception is thrown, it gets logged without a stack trace and the function returns as if nothing abnormal happened.</p>
<p>Say you have a constructor that is supposed to assign valid objects to A, B, and C using this code: this.A = GetA(); this.B = GetB(); this.C = GetC(). If there is an exception in GetB(), the constructor will return with A and C having valid values but B being null (or an invalid value, depending on how GetB was written). This may cause data corruption or random breakage in unrelated parts of the app.</p>
<p>While this app happens to not be C++, I can&#39;t imagine any language where this sort of anti-pattern is acceptable.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>