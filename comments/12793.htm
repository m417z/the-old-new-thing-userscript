<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (27)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-862083">
				<div id="div-comment-862083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">prunoki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862083">
			September 22, 2010 at 7:39 am</a>		</div>

		<p>And that was a question from someone let&#39;s say a year ago?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862113">
				<div id="div-comment-862113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rangoric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862113">
			September 22, 2010 at 8:18 am</a>		</div>

		<p>With high certainty, that is is the case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-862123">
				<div id="div-comment-862123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862123">
			September 22, 2010 at 8:23 am</a>		</div>

		<p>I don&#39;t see Raymond having any obligation to reply to any question ever, let alone in someone else&#39;s timeframe. &nbsp;At least he is frank and honest, a rare quality on the internet.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862133">
				<div id="div-comment-862133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Programmerman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862133">
			September 22, 2010 at 8:50 am</a>		</div>

		<p>Is this Raymond&#39;s shortest blog post? I like the brevity, since the topic didn&#39;t need a long description or story.</p>
<div class="post">[<i><a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/12/03/9931711.aspx" rel="nofollow">Inspiration</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-862173">
				<div id="div-comment-862173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862173">
			September 22, 2010 at 10:37 am</a>		</div>

		<p>Do all statically linked DLL have to have this flag, for CreateProcess to honor the EXE&#39;s flag?</p>
<div class="post">[<i>What part of &quot;Nothing&quot; didn&#39;t you understand? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862203">
				<div id="div-comment-862203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Retro</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862203">
			September 22, 2010 at 11:18 am</a>		</div>

		<p>&#8230;and as such can be applied to any executable, be it compiled in .NET or whatever..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-862213">
				<div id="div-comment-862213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862213">
			September 22, 2010 at 11:45 am</a>		</div>

		<p>Uh, thank you, it was a question that bugged me some time ago, but I was too lazy to do some research about it. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-862243">
				<div id="div-comment-862243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862243">
			September 22, 2010 at 12:43 pm</a>		</div>

		<p>[I would think the onus would be on the plug-in author to adhere to the rules for writing plug-ins. -Raymond]</p>
<p>Ok, but what about the usual corner case of legacy shell extensions?</p>
<p>IIRC explorer.exe, as all the Windows components and as other processes that may use the common dialogs, is large-address-aware, but may load non-large-address-aware legacy shell extensions.</p>
<p>Since the loader does not check, do the shell take care of this in some way?</p>
<div class="post">[<i>Nope. Your badly-written shell extension that broke the rules is broken. (Why enforce this rule and none of the others?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-862253">
				<div id="div-comment-862253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862253">
			September 22, 2010 at 12:56 pm</a>		</div>

		<p>I was just thinking that explorer (and the shell in general), knowing that the loader does nothing to avoid such scenario, would auto-protect themselves a little bit (e.g. checking on their own if the dlls they are loading have the largeaddressaware bit set), since they often have to deal with broken shell extensions.</p>
<p>If &quot;your badly-written shell extension that broke the rules is broken&quot; and, as far as I understand, there&#39;s no quick compatibility shim that can avoid troubles, why let it potentially make damage in explorer and in other innocent applications?</p>
<div class="post">[<i>The shell didn&#39;t load the DLL directly; it just called CoCreateInstance(). It doesn&#39;t know what DLL to check even if it wanted to. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-862263">
				<div id="div-comment-862263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862263">
			September 22, 2010 at 1:05 pm</a>		</div>

		<p>Uh, yes, I didn&#39;t think about it. I suppose that implementing such kind of protection not in the loader would require major modifications in COM, which is definitely a no-do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-862343">
				<div id="div-comment-862343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862343">
			September 22, 2010 at 2:59 pm</a>		</div>

		<p>The chosen alternative is &quot;come on, LARGEADDRESSAWARE for anybody, hooray, even if your dlls can&#39;t handle it; you may experience some big boom but &#8211; hey &#8211; it&#39;s part of the game!&quot;; I don&#39;t think it&#39;s so much better.</p>
<p>By the way, if the other alternative was chosen, the ones who would be in a situation like the one you said and who liked to risk (as they can do, maybe without even knowing, now), could just flip the largeaddressaware bit in all their dlls with EDITBIN, or, to address the problems of those who can&#39;t even flip a bit to licensed dlls, an additional flag could be added in the exe headers, to tell to the loader &quot;go on, load even non-largeaddressaware dlls for me, I like adventure!&quot;. In any case, the risky behavior should be an opt-in, not the default.</p>
<p>However, I understand that it&#39;s an almost lose-lose situation (&quot;no matter what you do, someone will still call you a moron&quot;), and speculating on past choices isn&#39;t all that useful.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-862353">
				<div id="div-comment-862353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862353">
			September 22, 2010 at 4:47 pm</a>		</div>

		<p>Matteo, the risky behavior is already opt-in. &nbsp;If you, AND ALL THE DLL YOU LOAD are not large address aware, don&#39;t opt in to large addresses by setting this switch.</p>
<p>That doesn&#39;t help with buggy shell extensions, but then, there&#39;s really nothing you can do to guard against buggy shell extensions short of not loading them.</p>
<p>The chosen alternative is really &quot;LARGEADDRESSAWARE for anybody who says that they can handle it. &nbsp;If your dlls can&#39;t handle it; you may experience some big boom but &#8211; hey &#8211; that&#39;s what you get for saying that you can!&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-862233">
				<div id="div-comment-862233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862233">
			September 22, 2010 at 12:23 pm</a>		</div>

		<p>By the way, this means that any dll that has any chance to be loaded by a large-address-aware exe must be prepared to deal with large addresses, correct?</p>
<p>So this means that, e.g., any shell extension (which may be loaded in *any* process) must be large-address-aware &#8211; if not in the linker flag, at least in the facts.</p>
<p>This seems to be the recipe for a disaster; is there any particular motivation for not choosing a safer system, like requiring that all the dlls referenced from a large-address-aware process be large-address-aware, maybe providing some magic override for those particularly fond of shooting in their own foot?</p>
<div class="post">[<i>I would think the onus would be on the plug-in author to adhere to the rules for writing plug-ins. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-862293">
				<div id="div-comment-862293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862293">
			September 22, 2010 at 1:59 pm</a>		</div>

		<p>Ok, last question for today, I promise. :)</p>
<p>Now the games are closed, but had you had your time machine working, given enough time, a 5% raise etc, would you go back in time and change the loader to make it work in a more cautious fashion (large-address-aware exe can load only large-address-aware dlls) to avoid these potential problems*, you&#39;d think it&#39;s better to keep it as it is now?</p>
<p>* after fixing the WinHelp animation first, obviously :)</p>
<div class="post">[<i>The alternative is telling people &quot;In order to make your program large address aware, you have to modify every single DLL your program uses, including the ones you don&#39;t have permission to modify since you licensed them from another company. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-862303">
				<div id="div-comment-862303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862303">
			September 22, 2010 at 2:04 pm</a>		</div>

		<p>Sorry, forgot an &quot;or&quot;</p>
<p>you&#39;d think it&#39;s better to keep it as it is now =&gt; *or* you&#39;d think it&#39;s better to keep it as it is now</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862373">
				<div id="div-comment-862373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862373">
			September 22, 2010 at 10:01 pm</a>		</div>

		<p>LoadLibrary could of course fail if the LARGEADDRESSAWARE-flag was not set on a dll and the exe is started as a LARGEADDRESSAWARE-process. That whould be more compatible.</p>
<p>Windows could even (with a little work) start the process as a non-LARGEADDRESSAWARE process if not all statically linked dlls are LARGEADDRESSAWARE. That wouldn&#39;t prevent late binded dll of breaking the app ofcourse.</p>
<p>And why does this flag even exist on dlls? Why do VS support setting it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-862393">
				<div id="div-comment-862393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">non-tristate</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862393">
			September 22, 2010 at 10:23 pm</a>		</div>

		<p>@GregM:</p>
<p>LARGEADDRESSAWARE is not a tri-state (true/false/null) &quot;flag&quot;, it&#39;s a bit flag which always exists.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862433">
				<div id="div-comment-862433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Horst Kiehl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862433">
			September 23, 2010 at 3:18 am</a>		</div>

		<p>Matteo, 640k: Just a thought: Although the loader doesn&#39;t use the DLLs&#39; LARGEADDRESSAWARE flags to restrict the process to non-large addresses, the EXE&#39;s developer could use them (if he can read them) to consider whether the EXE should be marked LARGEADDRESSAWARE, in addition to documentation and testing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-862463">
				<div id="div-comment-862463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862463">
			September 23, 2010 at 3:51 am</a>		</div>

		<p>Perhaps verclsid.exe should have been made large address aware. Of course, that only helps developers using /3GB.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862553">
				<div id="div-comment-862553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Horst Kiehl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862553">
			September 23, 2010 at 8:04 am</a>		</div>

		<p>Matteo:</p>
<p>Jules suspected that shrinking the address space of a process to 2GB would be infeasible; I suspect that extending the address space from 2GB would be difficult too, although perhaps less. Wouldn&#39;t each and every DLL in the process have to be &quot;aware&quot; not only of large addresses but of the possibility and/or the execution of this dynamic shrinkage or extension? To me, building support for this into the OS sounds like too much work for a need that might be very rare.</p>
<p>BTW, yes, my thought above was just aimed at the scenario you too hinted at, in which the author of an EXE that would benefit from large addresses knows in advance which DLLs will be used in in the process &#8211; after I read between the lines a question like &quot;what is the use of whether a DLL is marked LARGEADDRESSAWARE?&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-862573">
				<div id="div-comment-862573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862573">
			September 23, 2010 at 8:19 am</a>		</div>

		<p>@Horst:</p>
<p>Maybe I explained my idea badly; I agree that dynamic shrinking/extension would be infeasible, and I never said it was the solution. As already said, IMO the right thing to do would be to check the LAA flag of all the static dependencies, and start the process as LAA or not-LAA depending on this &#8211; after all an executable should be able to work on a system without a 4 GiB address space without problems.</p>
<p>The real problem are the delayload/manually loaded dependencies: after the process has been created, we all agree that it&#39;s infeasible to change it&#39;s address space extension. What I proposed as possible is a loader flag, that, if disabled (which would be the default if it were to be implemented today e.g. for Windows 8) tells to LoadLibrary to ignore all this stuff and just load the dll as it does now, if enabled would check if the dll and its dependencies is LAA before loading it in a LAA process; in case of such requirement is not fulfilled by the dll to be loaded, LoadLibrary would simply fail. A registry setting may be provided to enable by default such flag systemwide.</p>
<p>Such change would not impact existing applications, because by default everything would be as it is now, but would let LAA applications choose not to risk with non-LAA dlls.</p>
<p>On the other hand, IMO this flag should have been on by default at the moment LAA was introduced: this would have forced developers of LAA applications to be potentially aware of the problem, but would still let them say &quot;who cares, just load my damn dll&quot;. A bit like the CheckForIllegalCrossThreadCalls property in Windows Forms: we know you&#39;re doing something potentially nasty, by default we warn you but if you like risk you can shut up the warning.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862613">
				<div id="div-comment-862613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862613">
			September 23, 2010 at 8:50 am</a>		</div>

		<p>CheckForIllegalCrossThreadCalls. Yeah, I had to turn that off after it yelped at provably safe code (accessing variables that I added in my derived class from another thread).</p>
<p>As for VB .NET, I wish that there was an option to set the EXE to LARGEADDRESSAWARE instead of me calling editbin as a post build action (there might be now but there&#39;s not in VS 2005).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-862453">
				<div id="div-comment-862453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862453">
			September 23, 2010 at 3:32 am</a>		</div>

		<p>Matteo: it really *can&#39;t* work any other way. &nbsp;If you attempt to honour it for DLLs, what do you do about DLLs that are loaded after the process has allocated memory (which almost all shell extensions are likely to be: AIUI they won&#39;t get loaded until the first time the process displays a shell dialog)? &nbsp;Remap the process&#39;s address space after the fact to prevent it exceeding 2GB? Sounds technically infeasible to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-862473">
				<div id="div-comment-862473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862473">
			September 23, 2010 at 4:14 am</a>		</div>

		<p>@GregM:</p>
<p>my problem isn&#39;t with the dlls loaded directly by the exe (although a check in the loader could make the whole thing safer), but the ones loaded indirectly, often without the original application even knowing it, e.g. the shell extensions I cited. The fact that you don&#39;t know what shell extensions may be loaded and if they support large addresses means that, to be safe, you mustn&#39;t use e.g. common dialogs *at all* in your application, since they may crash your application or, even worse, start to write stuff randomly in your address space (Heisenbugs FTW). Or, you could split your application in two processes, one large-address-aware that does the &quot;heavy lifting&quot; and one just to do UI and interfacing with can&#39;t-check-if-address-aware dlls. A huge mess.</p>
<p>What&#39;s tragic is that this potential problem do not affect just your executable, in which you can choose to avoid the problem by not loading anything unknown/not using LARGEADDRESSAWARE, it affects potentially *always* explorer.exe, which loads uncheckable (as far as LARGEADDRESSAWARE is concerned) stuff by default.</p>
<p>@Horst Kiehl:</p>
<p>this cannot be done if the dll is loaded implicitly by COM, as Raymond already said. Such check can be done simply and efficiently only in the loader.</p>
<p>@640k:</p>
<p>[ Windows could even (with a little work) start the process as a non-LARGEADDRESSAWARE process if not all statically linked dlls are LARGEADDRESSAWARE. ]</p>
<p>This in my opinion would be a nice solution, and it could be implemented even now that the games are closed. Even better, a new API could be made available to check if the address space is &quot;large&quot; or not, to let applications who really *need* a large address space deal with being loaded in a &quot;normal&quot; address space and let the user know.</p>
<p>[ That wouldn&#39;t prevent late binded dll of breaking the app ofcourse. ]</p>
<p>Some magic flag (like the one to change the loader search order) may be created, to let the application specify that it wants the &quot;secure&quot; behavior from LoadLibrary (and maybe even a registry setting to let the user force the secure behavior systemwide). This would be security as opt-in, but would be better than nothing.</p>
<p>However, since we all know that features start with -100 points, I don&#39;t think that we&#39;ll ever see such thing. The problem do affect only 32 bit processes (for x86_64 processes LARGEADDRESSAWARE means nothing, so e.g. Windows Explorer on a 64 bit version of Windows is not affected anymore), and everything should be moving towards 64 bit. I don&#39;t think that all this work will be done to fix this kind of potential problems (that regards only a small fraction of legacy, but recent, 32 bit applications). Moreover, since these applications are large-address-aware, they are supposed to treat pointers carefully, so they shouldn&#39;t have big problems to switch to 64 bit.</p>
<p>@Jules:</p>
<p>[ If you attempt to honour it for DLLs, what do you do about DLLs that are loaded after the process has allocated memory ]</p>
<p>LoadLibrary should fail if the &quot;secure LAA&quot; loader flag I described is set, or should go on (as it does now) if it&#39;s unset. Being the games closed, security as opt-in is the only thing that can be done.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-862643">
				<div id="div-comment-862643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862643">
			September 23, 2010 at 9:57 am</a>		</div>

		<p>&quot;LARGEADDRESSAWARE is not a tri-state (true/false/null) &quot;flag&quot;, it&#39;s a bit flag which always exists.&quot;</p>
<p>Where did I say that it was a tri-state? &nbsp;It&#39;s off by default, so don&#39;t set it unless you mean it.</p>
<p>&quot;my problem isn&#39;t with the dlls loaded directly by the exe (although a check in the loader could make the whole thing safer), but the ones loaded indirectly, often without the original application even knowing it, e.g. the shell extensions I cited. The fact that you don&#39;t know what shell extensions may be loaded and if they support large addresses means that, to be safe, you mustn&#39;t use e.g. common dialogs *at all* in your application, since they may crash your application or, even worse, start to write stuff randomly in your address space (Heisenbugs FTW).&quot;</p>
<p>The same thing can happen even if you don&#39;t set LARGEADDRESSAWARE. &nbsp;That&#39;s why I said</p>
<p>&quot;That doesn&#39;t help with buggy shell extensions, but then, there&#39;s really nothing you can do to guard against buggy shell extensions short of not loading them.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-862833">
				<div id="div-comment-862833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862833">
			September 23, 2010 at 6:31 pm</a>		</div>

		<p>I believe unless you&#39;re very sure, you shouldn&#39;t switch on LARGEADDRESSAWARE (so this flag is off by default).</p>
<p>If your application needs to call DLL functions that needs a much larger address space, in these days you should just target x64 instead.</p>
<p>Btw, just be curious, if you really have to code the application as 32-bit one, need a larger address spae, but also sure some particular version of DLL isn&#39;t handling large address properly, is it possible to instruct the compiler/linker always pass shared pointers to that particular DLL (or function) in &lt; 2GB address space? If so, problem solved. (As application writers marking their application as LARGEADDRESSAWARE should take the responsibility of ensuring the codes work on large address)</p>
<div class="post">[<i>Are you suggesting that the compiler/linker marshall all pointers so they point below the 2GB boundary? This is harder than it looks. (Imagine marshalling a linked list.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-862883">
				<div id="div-comment-862883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100922-00/?p=12793#comment-862883">
			September 23, 2010 at 7:29 pm</a>		</div>

		<p>There&#39;s two cases I suppose:</p>
<p>1) A call that caller allocates memory. If it&#39;s possible to tell compiler to generate codes allocate that buffer from the &lt; 2GB buffer, that&#39;d be enough.</p>
<p>2) A call where the DLL allocates memory (even a possibly partial case like the linked list you suggested). Is it possible to &quot;frame&quot; the loaded DLL, so that whenever it tries to allocate memory, it&#39;s always from the &lt; 2GB address space?</p>
<div class="post">[<i>The default behavior of VirtualAlloc is bottom-up, so memory allocations already tend to stay at low addresses as long as possible. The hard part of &quot;framing&quot; is knowing when you are in the frame and when you&#39;re not. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>