<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (36)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-409173">
				<div id="div-comment-409173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409173">
			August 15, 2006 at 10:30 am</a>		</div>

		<p>Not having different semantics in debug and release builds is important and should (hopefully) be common knowledge. &nbsp;What gets me is when the optimizer does something in the release build to cause an error.</p>
<p>For example, I recently had a bug that only appeared in one machine that was a quad-Xeon box running Windows Server 2003. &nbsp;Win 2K and XP ran the code fine. &nbsp;In fact, I developed the software on a Dual Xeon Win2K machine. &nbsp;It turned out that the optimizer reordered some floating point operations that resulted in my DLL generating a most-of-the-time increasing series instead of a stricly-increasing series. &nbsp;Fortunately my code checked for this condition and returned an error code, but it was certainly confusing as to why it worked everywhere but on that machine.</p>
<p>Since I didn&#8217;t have direct access to the Server 2K3 box, I had WinDbg a core dump of the process on a 2K box. &nbsp;That was fun!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409193">
				<div id="div-comment-409193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://cornbreadshome.spaces.live.com/' rel='external nofollow' class='url'>Andy</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409193">
			August 15, 2006 at 11:04 am</a>		</div>

		<p>Some days I read your &quot;don&#8217;t do this&quot; type of posts and I think &quot;wow that is a really good tip I never would have thought to check for that&quot;. Other days like today I look at it and go &quot;OMG please tell me people aren&#8217;t doing that in real life code&quot;. A while back you mentioned that all of your &quot;don&#8217;t do that&quot; posts stem from things you have actually seen or know for certain were done. That fact coupled with code like what you showed above just makes me pray that these people aren&#8217;t working on anything critical like navigation software for airplanes or if they are that they will read your blog and will stop writing horrendous code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409203">
				<div id="div-comment-409203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409203">
			August 15, 2006 at 11:12 am</a>		</div>

		<p>This kind of debug-code-changes-behavior is quite easy to spot, but then there are the times when the debug code has unintended consiquences, like printf&#8217;s taking long enough to make thread synchronisation work&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409213">
				<div id="div-comment-409213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409213">
			August 15, 2006 at 11:18 am</a>		</div>

		<p>It can get much worse than this.</p>
<p>I&#8217;ve heard of embedded systems that used the UART for debug messages. Most of the testing was done in debug mode, but just before release the UART was disabled since it might reveal secret information. Also the system was pretty slow. Lots of fatal bugs were uncovered, some that could not be fixed in time. Most were due to the changed timing from not having prints running &#8211; some of the drivers only worked because of the delays as a side effect of the UART interrupt service routine running every few ms.</p>
<p>In the end they ended up shipping a version with the UART pins disabled, but all the printfs still in the code. Ouch.</p>
<p>The lesson I think is to agressively minimise the printfs before testing &#8211; only really essential info should go out to the port. That way you have more time to find timing bugs in the code while you still have time to fix them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409243">
				<div id="div-comment-409243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.avid.com/exchange/blogs/andrew_kimpton/archive/2006/08/15/130282.aspx' rel='external nofollow' class='url'>Andrew Kimpton</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409243">
			August 15, 2006 at 11:43 am</a>		</div>

		<p>Raymond Chens excellent blog has a post today warning of the dangers of changing program behaviour between&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409253">
				<div id="div-comment-409253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Lee</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409253">
			August 15, 2006 at 11:43 am</a>		</div>

		<p>A coworker once did something like<br />
<br />&lt;pre&gt;<br />
<br />assert (someFunc() != null);<br />
<br />&lt;/pre&gt;</p>
<p>Where someFunc() actually did some necessary operation. &nbsp;Of course it wasn&#8217;t being called at all in the release version. &nbsp;This one didn&#8217;t make it into the wild but it was tricky to track down.</p>
<p>Another problem with debug versions is the memory guards that the memory manager puts at the beginning and end of memory blocks allowing your debug version to survive off by a few pointer calculations without trashing other memory. &nbsp;Especially when you use the guard character (ASCII 253 I believe) for an important delimiter in your strings like a company I previously worked for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409263">
				<div id="div-comment-409263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Feldstein</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409263">
			August 15, 2006 at 12:01 pm</a>		</div>

		<p>What about assertions that get turned off by compiler options in the release build?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409273">
				<div id="div-comment-409273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://aundh.blogspot.com' rel='external nofollow' class='url'>JamesW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409273">
			August 15, 2006 at 12:17 pm</a>		</div>

		<p>@Matt Lee</p>
<p>I won&#8217;t blame a coworke &#8211; I&#8217;ve done the assert() one myself. It&#8217;s easy to do if you&#8217;re not thinking too hard at the time because the #ifdef DEBUGs are hidden from view. Tends not to be found immediately because everything works on your debug project. It blows up once the program is tested in release a while later&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409303">
				<div id="div-comment-409303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tyler Reddun</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409303">
			August 15, 2006 at 12:33 pm</a>		</div>

		<p>Andy, it&#8217;s worse then that. When I was in collage we were tought that we had to put are param checks in the #ifdefs because it was clearly debug only code. Infact we got marked down if we didn&#8217;t do it. I suspect some people in his class still do it that way as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409343">
				<div id="div-comment-409343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">oPossum</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409343">
			August 15, 2006 at 1:03 pm</a>		</div>

		<p>VERIFY(someFunc()!=NULL); will keep someFunc()!=NULL in the release build and behave like ASSERT(someFunc()!=NULL) in the debug build.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409353">
				<div id="div-comment-409353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://forbidden-planet.blogspot.com' rel='external nofollow' class='url'>richard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409353">
			August 15, 2006 at 1:25 pm</a>		</div>

		<p>Hmmm &#8230; I have never understood why people want release builds to be different from debug builds. As far as I am concerned, if it is important enough to check during development, it is important enough to check at release.</p>
<p>For this reason, I dislike ASSERT() &#8211; not to mention it can also be a source of introducing subtle behavioural differences like:</p>
<p>ASSERT (i++ &gt; 0);</p>
<p>or ASSERT (some_modifying_function_call(i));</p>
<p>All of which I have seen in code.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409383">
				<div id="div-comment-409383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409383">
			August 15, 2006 at 1:56 pm</a>		</div>

		<p>IMHO, #ifdef DEBUG, ASSERT(), and their bretheren should not exist.</p>
<p>They just lead to issues like this.</p>
<p>The only semi valid reason to have them is for performance reasons. &nbsp;And for most code, that is not a good reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409403">
				<div id="div-comment-409403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409403">
			August 15, 2006 at 2:10 pm</a>		</div>

		<p>Assertions are invaluable, and they&#8217;re strictly debug code too, in my opinion. If you are afraid of altering the environment with your debug assertions, well use them in a sensible pattern, then. Like, for data structures in C++ you can define a const member function called AssertInvariants, put all your asserts in it (which cannot alter the state since &quot;this&quot; points to a constant object) and call it every time execution enters or leaves a function in a public interface. I can&#8217;t count the times this pattern has saved my ass against subtle corruption, off-by-one errors or faulty logic</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409413">
				<div id="div-comment-409413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409413">
			August 15, 2006 at 2:10 pm</a>		</div>

		<p>Assertions are invaluable, and they&#8217;re strictly debug code too, in my opinion. If you are afraid of altering the environment with your debug assertions, well use them in a sensible pattern, then. Like, for data structures in C++ you can define a const member function called AssertInvariants, put all your asserts in it (which cannot alter the state since &quot;this&quot; points to a constant object) and call it every time execution enters or leaves a function in a public interface. I can&#8217;t count the times this pattern has saved my ass against subtle corruption, off-by-one errors or faulty logic</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409423">
				<div id="div-comment-409423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409423">
			August 15, 2006 at 2:16 pm</a>		</div>

		<p>And let&#8217;s not forget the ever-popular deubg-code-stomping-on-GetLastError&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409443">
				<div id="div-comment-409443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DriverDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409443">
			August 15, 2006 at 3:00 pm</a>		</div>

		<p>&quot;I&#8217;ve heard of embedded systems that used the UART for debug messages. Most of the testing was done in debug mode,&#8230;&quot;</p>
<p>There&#8217;s one problem: most of development may be done with debug mode, but TESTING must be done with release code. Otherwise the product that is being tested is not what customer has. Doh!</p>
<p>Given that we know about these pitfalls, we should either 1) avoid using those constructs, or 2) design/review code to catch those mistakes. Even the best of us make mistakes. In my experience, precious few have learned from their (and their peers&#8217;) mistakes.</p>
<p>Understanding the system is also necessary. Perhaps a extra printf isn&#8217;t a big deal for a multi-threaded app, but the time it takes to send stuff over a UART in an embedded system is a big deal. Not realizing that leads to design mistakes and hard-to-find bugs.</p>
<p>I&#8217;d like to see more this in literature and taught in classes or peer-reviewed. Every C book says something along the lines of &quot;beware the min macro can eval its args twice&quot; &nbsp;But few warn about the pitfalls in:</p>
<p>ASSERT(i++ &lt; 10);</p>
<p>if (expr) &nbsp;DEBUG_PRINTF_MACRO((&quot;&#8230;&quot;));</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409453">
				<div id="div-comment-409453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.compuware.com/cs/blogs/igoodsell/archive/2006/08/15/840.aspx' rel='external nofollow' class='url'>Ian Goodsell - Dev Emporium</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409453">
			August 15, 2006 at 3:47 pm</a>		</div>

		<p>Here&#8217;s a post I&amp;amp;nbsp;read&amp;amp;nbsp;on&amp;amp;nbsp;The&amp;amp;nbsp;Old New Thing:&amp;amp;nbsp;&amp;amp;nbsp;Do not change program semantics&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409493">
				<div id="div-comment-409493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.dotnetkicks.com/tipsandtricks/Do_not_change_program_semantics_in_the_debug_build' rel='external nofollow' class='url'>DotNetKicks.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409493">
			August 15, 2006 at 6:50 pm</a>		</div>

		<p>You&#8217;ve been kicked (a good thing) &#8211; Trackback from DotNetKicks.com</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409503">
				<div id="div-comment-409503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">silkio</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409503">
			August 15, 2006 at 8:11 pm</a>		</div>

		<p>god those &#8216;trackbacks&#8217; are annoying.</p>
<p>Anyway, I had an annoying issue with MS SAPI 5.1, where you couldn&#8217;t actually use breakpoints in the app because it would freeze. I&#8217;m guessing it&#8217;s due to some strangeness in the SAPI lib itself or the com interop-y stuff between .net and the dlls.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409523">
				<div id="div-comment-409523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asmguru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409523">
			August 15, 2006 at 8:47 pm</a>		</div>

		<p>In my opinion DEBUG build should alert developers and RELEASE one should also not crash, so there should be some redundancy of sort:</p>
<p>HRESULT f (ISomething* pISomething)<br />
<br />{<br />
<br /> &nbsp;ASSERT (pISomething != NULL);<br />
<br /> &nbsp;if (pISomething == NULL)<br />
<br /> &nbsp;{<br />
<br /> &nbsp; &nbsp;return E_FAIL;<br />
<br /> &nbsp;}</p>
<p> &nbsp;&#8230;<br />
<br />}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jmstall even thread-even depth-1" id="comment-409533">
				<div id="div-comment-409533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Stall+-+MSFT' rel='external nofollow' class='url'>Mike Stall - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409533">
			August 15, 2006 at 9:07 pm</a>		</div>

		<p>Amen!<br />
<br />As a debugger developer, I see these showing up people saying &quot;The debugger broke my app&quot; and blaming the debugger tool.</p>
<p>While your&#8217;e at it, avoid kernel32!IsDebuggerPresent and Debugger.IsAttached. </p>
<p>Unfortunately, Winforms has a notorious violation of the &quot;don&#8217;t change behavior under a debugger&quot; rule by having a different wndproc for when under a debugger that has an additional exception catcher.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409463">
				<div id="div-comment-409463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.morganalley.com' rel='external nofollow' class='url'>Dewi Morgan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409463">
			August 15, 2006 at 4:10 pm</a>		</div>

		<p>Jonathan wrote: &quot;And let&#8217;s not forget the ever-popular deubg-code-stomping-on-GetLastError&#8230;&quot;</p>
<p>Yup. It&#8217;s the flip case of what was discussed in the article, where debug code breaks code, rather than having the code rely on debug code.</p>
<p>But I have to hold up my hands and say I was recently guilty of writing something like the following wrapper in PHP (paraphrased heavily for brevity):</p>
<p>function my_exec_sql($query) {<br />
<br /> &nbsp;global $DEBUG;<br />
<br /> &nbsp;if (builtin_exec_sql($query)) {<br />
<br /> &nbsp; &nbsp;; Store last insert id, so debug won&#8217;t clobber it.<br />
<br /> &nbsp; &nbsp;my_set_last_id(builtin_get_last_id());<br />
<br /> &nbsp; &nbsp;if ($DEBUG) {<br />
<br /> &nbsp; &nbsp; &nbsp;if (!builtin_exec_sql(&quot;<br />
<br /> &nbsp; &nbsp; &nbsp; &nbsp;INSERT INTO log_table<br />
<br /> &nbsp; &nbsp; &nbsp; &nbsp;VALUES (&#8216;&quot;.escape($query).&quot;&#8217;)<br />
<br /> &nbsp; &nbsp; &nbsp;&quot;)) {<br />
<br /> &nbsp; &nbsp; &nbsp; &nbsp;die(&quot;failed to save debug info&quot;);<br />
<br /> &nbsp; &nbsp; &nbsp;}<br />
<br /> &nbsp; &nbsp;}<br />
<br /> &nbsp;}<br />
<br /> &nbsp;else { die(&quot;failed to insert&quot;); }<br />
<br />}</p>
<p>Now, we&#8217;ll ignore the fact that relying on a DB to log debug info about the DB is fairly bad&#8230; </p>
<p>builtin_exec_sql() causes builtin_get_last_id() to return the index of the last inserted item.</p>
<p>Unfortunately, a function that called my_exec_sql() subsequently called builtin_get_last_id() directly, instead of calling my_get_last_id() function. This gave it the ids from log_table, instead of whatever table it was inserting to.</p>
<p>Worse, on a virgin test system, the ids were &quot;correct&quot;, so long as that function was only called for that one query. So it wasn&#8217;t reproducible no matter how many times you ran the query!</p>
<p>Not my fault, but a real pain to debug!</p>
<p>I changed it to insert to the log *before* doing the action, and then modify the log afterwards, on fail/success. This still has knock-on effects, and affects speed, but I felt this was less serious and more obvious than the subtle bug.</p>
<p>More appropriately to the topic of debug code making the system work, in another app I worked on (multithreaded java 1.0, back in the day), I found that removing a certain apparently-useless print(&quot;&quot;) call caused NullPointerExceptions, in an apparently unrelated thread.</p>
<p>Why? Both threads did stuff with some static variables in an object they both instantiated, and the crashing thread was assuming it was the first to instantiate the object. And as System.out.print() was a slow operation, it *was* the first, so long as that print existed.</p>
<p>Rather than track down the problem, the original programmers had instead just decided to keep the &quot;magic&quot; print(), and just remove all the content from it.</p>
<p>The problem was eventually resolved more correctly, but this has served me for years as a powerful lesson on the kind of mess not to get into with multithreading.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409563">
				<div id="div-comment-409563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.xt1.org/' rel='external nofollow' class='url'>Christian Mogensen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409563">
			August 16, 2006 at 5:31 am</a>		</div>

		<p>Subtle behavior changes are harder to catch.</p>
<p>We had some debug code that check an STL map&lt;&gt; that caused crashes under release.<br />
<br />Why?<br />
<br />Because the map&lt;&gt;::operator[] implicitly creates an item in the map.<br />
<br />When the debug code was present, the map was always guaranteed to have at least one item in it.<br />
<br />I guess this is why some people think C++ is evil&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409573">
				<div id="div-comment-409573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409573">
			August 16, 2006 at 5:44 am</a>		</div>

		<p>I&#8217;ll be the devil&#8217;s advocate for a moment here&#8230;</p>
<p>Depending on your situation it /may/ be better for your program to keep running despite certain types of error, thus changing the semantics. In the DEBUG build you want these errors reported, and if you&#8217;re in a debugger or have crash dumping you probably want it to crash immediately so that you can try to understand how it happened. But in the production build it might be better to carry on and cross our fingers.</p>
<p>Raymond&#8217;s justification is that customers will use your slow and undesirable DEBUG version, but actually in his example what the customer wants (and gets) is a version that crashes less. By putting most asserts and forced crashes into the DEBUG path only, you reduce the chance of the customer&#8217;s production version crashing. It might give bad results, but it probably won&#8217;t crash. For a lot of customers, a lot of the time, that&#8217;s actually the preferred outcome.</p>
<p>There has been some interesting research done on changing the behaviour of illegal memory accesses (a really important bit of semantics) in production systems. A lot of crashes found in ordinary application software go away with minimal side effects if the OS simply ignores illegal writes and provides zero values for illegal reads.</p>
<p>Obviously if you&#8217;re monitoring a nuclear reactor, you&#8217;d like to know if anything goes wrong with the software you&#8217;re using, and it is probably more acceptable for the software to fail safely, altogether, than for it to try to continue past a fault. For a word processor or a video game it&#8217;s much less certain that crashing is the right thing to do.</p>
<p>Here&#8217;s a really trivial example (please don&#8217;t bother shooting this down unless you have a real point to make too). Suppose you are playing World of Warcraft, and you&#8217;re the Main Tank for AQ20. Would you rather that a memory allocation problem in the WoW executable caused a crash, disconnecting you from the game and therefore almost inevitably resulting in a &quot;wipe&quot; of the raid or would it be better if it just corrupted the audio and video of the game, making it harder to play until you could tell everyone else and get a rest break to reboot your computer ?</p>
<p>If you&#8217;re the developer, I hope you&#8217;d choose the crash, the game is fun but hopefully you&#8217;re enthusiastic about actually finding and fixing bugs. I expect everyone else would choose the corruption.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409593">
				<div id="div-comment-409593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409593">
			August 16, 2006 at 9:26 am</a>		</div>

		<p>Nick : That sounds extraordinarily dangerous, even for non-nuclear-reactor scenarios.</p>
<p>If you&#8217;re doing illegal reads <em>or</em> writes, then that&#8217;s because your pointers are <em>badly</em> messed up, and you&#8217;re attempting to read/write to a page that&#8217;s not even been mapped into your address space. double-free()s, walking off either end an array, dereferencing dangling pointers; most of these will not produce a SEGV, they&#8217;ll just trash something else in your address space silently. (Remember, most of the time free() does not return memory to the OS, it just returns it to malloc())</p>
<p>If you end up trashing some other pointer and/or malloc&#8217;s housekeeping code then yes, you&#8217;re likely to get a SEGV further down the line when you try to deref a trashed pointer. But that&#8217;s just a symptom. The cause is deeper, and I&#8217;ve found that I&#8217;m relatively likely to have messed up some other data in the process. I&#8217;d rather my process stopped right there before things go <em>more</em> badly wrong, instead of continuting and increasing the chances that some bad data gets written somewhere (file containing important report, DB, etc&#8230;) permenantly.</p>
<p>What if the corruption is due to an attacker trying to exploit an error? (e.g. steal your legenday gear?) Crash and they&#8217;re gone. Keep going and you give them more of a chance to get what they&#8217;re after.</p>
<p>Once you&#8217;ve started reading/writing random memory, you can&#8217;t really be sure of anything anymore. Fail early.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409613">
				<div id="div-comment-409613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409613">
			August 16, 2006 at 9:54 am</a>		</div>

		<blockquote><p>
  A lot of crashes found in ordinary application software go away with minimal side effects if the OS simply ignores illegal writes and provides zero values for illegal reads.</p>
<p>I used to use a database server called SQLBase running under Novell Netware 3.12; it seems that this OS performed read and write fault emulation. Netware 4.11 disabled emulation by default but fortunately to run older versions of SQLBase you could turn it back on again. (Latest versions of Netware don&#8217;t support that option, they simply suspend the faulting process).</p>
<p>I use Mozilla 1.6 (yeah, I should upgrade) which occasionally crashes during garbage collection and I have found that I can use WinDbg to set the EIP to the function epilog to keep it running.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-409553">
				<div id="div-comment-409553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Charlie Tangora</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409553">
			August 16, 2006 at 4:37 am</a>		</div>

		<p>Funny, I just ran across this one today. From a simple stack allocator in an console videogame&#8217;s memory management, edited for brevity:</p>
<p>U8* Allocate(size_t numBytes)<br />
<br />{<br />
<br /> &nbsp;U8* ptr = m_current;<br />
<br /> &nbsp;m_current += numBytes;</p>
<p> &nbsp;ASSERT(m_current &lt;= m_topOfHeap);<br />
<br /> &nbsp;return ptr;<br />
<br />}</p>
<p>Yup, in release it gave you a pointer regardless of whether there was enough memory for you! Allocate more than your share, and you just start using other people&#8217;s memory.</p>
<p>This bug has been there for MONTHS. The person who wrote that code isn&#8217;t even at our company anymore. Nobody has any idea how it managed to work for so long.</p>
<p>Speaking of differences between debug and release, there&#8217;s also a wonderful &quot;feature&quot; in certain ports of gcc. In this sort of case:</p>
<p>float Stuff(float input)<br />
<br />{<br />
<br /> &nbsp;float output = input;</p>
<p> &nbsp;/* do stuff with output */<br />
<br /> &nbsp;/* but don&#8217;t create any other locals */</p>
<p> &nbsp;/* then forget to return output */<br />
<br />}</p>
<p>VC++ of course complains that you didn&#8217;t return anything. Well done, Microsoft!</p>
<p>But gcc in certain configurations (I think 4.0.2 on PowerPC is an example, but my memory may be failing me here) will not only not warn you, it will put your local variable on the stack where the return value should go. So the function works UNLESS it gets optimized.</p>
<p>You really feel warm and fuzzy once you&#8217;ve spent half a day trying to figure out if you&#8217;re seeing a compiler bug, then finding that mistake.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-409583">
				<div id="div-comment-409583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://deadnode.org/' rel='external nofollow' class='url'>James</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-409583">
			August 16, 2006 at 6:17 am</a>		</div>

		<p>On the hardware side, I recall a production error in a batch of computers some years ago. One capacitor&#8217;s value was very slightly too low. Of course, attaching an oscilloscope to the component *fixed* the problem, because the &#8216;scope itself had some capacitance, making the machine behave perfectly again&#8230;</p>
<p>I&#8217;ve heard at least one person suggest that the released code should have *more* checks than debug, since it&#8217;s running in a less known/controlled environment &#8211; I can&#8217;t remember who that was, but I tend to agree to some extent.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-410223">
				<div id="div-comment-410223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.explorewindows.com/Blogs' rel='external nofollow' class='url'>Vipin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-410223">
			August 17, 2006 at 2:11 pm</a>		</div>

		<p>Andy:&quot;That fact coupled with code like what you showed above just makes me pray that these people aren&#8217;t working on anything critical like navigation software for airplanes or if they are that they will read your blog and will stop writing horrendous code&quot;</p>
<p>These type of code exists and some people won&#8217;t even change the attitude towards writing both debug and release code having same code flow.I was recently looking at the code of a ssl vpn product and the guy(designated a senior staff engineer) has written code which doesn&#8217;t need certain condition to be statisfied to run properly in the debug build, but requires the condition in the release build and this library links statically to the modules other people write,imagine the catastrophe here.The user of the module would go nuts here at this behaviour. He will not budge to making that proper,being dictated by his ego. Now the bottom line is the release code flow never gets executed in the debug build until caught by surprise later on when the product ships. Coders have to keep their egos down, admit the mistakes like this in the code and fix them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-410273">
				<div id="div-comment-410273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://K.Hagan@thermoteknix.co.uk' rel='external nofollow' class='url'>Ken Hagan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-410273">
			August 17, 2006 at 3:56 pm</a>		</div>

		<p>I&#8217;m joining this late, but Tom&#8217;s initial response raised an important related issue&#8230;</p>
<p>&quot;What gets me is when the optimizer does something in the release build to cause an error.&quot;</p>
<p>Use full optimisation in debug builds. You&#8217;ll need &#8216;#pragma optimize(&quot;&quot;,off)&#8217; occasionally, but rip it out as soon as the bug is found. Debug what you intend to ship. Ship what you debugged.</p>
<p>Actually, in fairness to the compiler folks, I&#8217;ve been doing this for over a decade and found only a handful of optimiser bugs. (I optimise for size, not speed, so your mileage may vary.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-410293">
				<div id="div-comment-410293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.explorewindows.com/Blogs' rel='external nofollow' class='url'>Vipin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-410293">
			August 17, 2006 at 4:24 pm</a>		</div>

		<p>The problem is buffer overruns that would go unnoticed in a debug build because of the extra padding,etc won&#8217;t work on a sensitive stack when the release binary runs because all the padding and extra spacing which exists in a debug binary are stripped of,things like the FPO also happen. But the latest compilers solves buffer run catching via the /GZ compiler option, that brings the debug/release difference in that respect lot closer. But I guess Raymond&#8217;s post had to do with the code flow rather than the compiler introduced differences.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-410713">
				<div id="div-comment-410713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-410713">
			August 18, 2006 at 11:05 am</a>		</div>

		<p>&quot;What gets me is when the optimizer does something in the release build to cause an error.&quot;</p>
<p>Or indeed the JIT compiler&#8230; the IE(3-5+) VM for Java JIT compiler miscompiles some of my code and throws an impossible null pointer exception.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-411133">
				<div id="div-comment-411133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve Loughran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-411133">
			August 18, 2006 at 3:12 pm</a>		</div>

		<p>I seem to recall that MFC zeros out newed&#8217; &nbsp;memory in debug builds but not releases. all MFC based apps have a fundamentally different assumption about the state of newly allocated memory. </p>
<p>I now believe in running release-only code, with debug info compiled in. </p>
<div CLASS=post>[<i>&#8220;Well fix MFC then.&#8221; Was that directed to me? I don&#8217;t have the authority to make changes to MFC. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-411363">
				<div id="div-comment-411363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-411363">
			August 19, 2006 at 1:12 am</a>		</div>

		<p>Just imagine if airplanes were allowed to have black boxes only while the manufacturer was testing them with test pilots operating them. &nbsp;Just imagine if airplanes sold to airlines with ordinary crew and lots of passengers were prohibited from using black boxes so the causes of crashes couldn&#8217;t be investigated.</p>
<p>Just imagine if cars were allowed to have seatbelts during testing by manufacturers, but if it would be illegal for end users to install or use seatbelts.</p>
<p>Certain corporate policies that prohibit redistribution of debug builds have the same kind of effect. &nbsp;Yeah when we build verification into our own code we can make sure that it&#8217;s doing the same operations in release build as in debug build, but we&#8217;re still missing our black boxes. &nbsp;This kind of corporate policy is something that ought to be illegal.</p>
<p>Sure there are situations where debug tools need to be stripped out. &nbsp;If the program is running too slowly then do a performance test. &nbsp;If debug tools are the third biggest consumer of CPU time (or page faults or whatever) and the two biggest consumers are parts of the program that you can&#8217;t optimize any further, then it&#8217;s time to start looking at throwing your black box overboard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-411773">
				<div id="div-comment-411773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve Loughran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-411773">
			August 21, 2006 at 12:03 pm</a>		</div>

		<p>Raymond: The &quot;well fix MFC then&quot; comment was directed at, well, whoever maintains MFC. I don&#8217;t know the org chart. I suspect that MFC is on care-and-maintenance rather than active dev and probably has three interns and new PM every &nbsp;month, as MFC maintenance is viewed as one of those trouble-without-recognition postings.</p>
<p>I do know the version of new we use on our code is patched to always zero stuff; we take the hit because we do at least know everything is in a known state after allocation. That is one nice thing about MFC: as long as you dont try shipping your own MFC DLLs, you can patch bits and rebuild it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-411943">
				<div id="div-comment-411943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060815-00/?p=30113#comment-411943">
			August 22, 2006 at 12:01 am</a>		</div>

		<p>I get your point but your C# version is not that similar. &nbsp;A more similar example would be:</p>
<p>bool DoSomething(Thing p)<br />
<br />{<br />
<br />#if DEBUG<br />
<br /> // Do some extra parameter checking<br />
<br /> if (p == null) {<br />
<br /> &nbsp;Log(&quot;Error! p parameter must not be NULL.&quot;);<br />
<br /> &nbsp;return false; // WRONG!<br />
<br /> }<br />
<br />#endif<br />
<br /> &nbsp;&#8230; remainder of function &#8230;<br />
<br />System.Console.Out.WriteLine( p.ToString() ); //This will cause NullReferenceException.<br />
<br />}</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>