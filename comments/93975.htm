<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1258126">
				<div id="div-comment-1258126" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258126">
			July 28, 2016 at 7:12 am</a>		</div>

		<p>As one of my coworkers once said (actually before he died, not after,) Dennis Ritchie&#8217;s true legacy to the world is the buffer overrun.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-david-taylor odd alt depth-2" id="comment-1258135">
				<div id="div-comment-1258135" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/D+Taylor+84' rel='external nofollow' class='url'>D Taylor 84</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258135">
			July 28, 2016 at 7:21 am</a>		</div>

		<p>Or, perhaps more appropriate to this story, the dangling pointer&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1258157">
				<div id="div-comment-1258157" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">McBucket</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258157">
			July 28, 2016 at 11:06 am</a>		</div>

		<p>Struck by lightning, eh? </p>
<p>(not meaning any disrespect to your colleague, of course)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-exchange-development-blog-team odd alt depth-3" id="comment-1258245">
				<div id="div-comment-1258245" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">exchange development blog team</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258245">
			July 29, 2016 at 12:13 am</a>		</div>

		<p>That&#8217;s &#8216;struct by_lightning&#8217; to you, your version won&#8217;t compile.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1258235">
				<div id="div-comment-1258235" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Drak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258235">
			July 28, 2016 at 10:09 pm</a>		</div>

		<p>For a second I was wondering how your coworker would have been able to say anything after he had died, but then I figured out what you meant.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-paul-topping odd alt thread-odd thread-alt depth-1 parent" id="comment-1258145">
				<div id="div-comment-1258145" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/PaulTDessci' rel='external nofollow' class='url'>PaulTDessci</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258145">
			July 28, 2016 at 8:04 am</a>		</div>

		<p>I&#8217;ve always felt that the C/C++ Standard Library should provide the ability to check whether a pointer or object is on the stack, heap, or static storage. These memory categories are acknowledged in the language spec and it is not as if it would restrict implementations, at least AFAIK. Of course, such facilities could be abused but that could be said of C++ programming in general. Perhaps the promised reflection facilities due to be added to the language real soon now will help.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1258345">
				<div id="div-comment-1258345" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zboot</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258345">
			July 29, 2016 at 8:33 am</a>		</div>

		<p>And how exactly would the compiler know the difference between the stack and heap memory?</p>
<p>Once you answer that question, then explain how that doesn&#8217;t restrict an implementation.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1258156">
				<div id="div-comment-1258156" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258156">
			July 28, 2016 at 9:40 am</a>		</div>

		<p>No need to be harsh on DMR. This is a design problem, not a language problem.</p>
<p>Change the semantics of SendDataAsync() so that it takes ownership of the buffer and deletes it afterwards. That makes it almost impossible to pass a stack buffer in without it crashing the very first time you run the code.</p>
<p>What&#8217;s that you say? The client wants to retain the buffer so that they can re-use it themselves? Sounds like I&#8217;ve just saved you from *another* race condition, by forcing you to make a copy.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1258185">
				<div id="div-comment-1258185" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt (Visual Studio and Development Technologies MVP with C++ focus)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258185">
			July 28, 2016 at 12:47 pm</a>		</div>

		<p>Yes, you can use Java instead of learning to write C++ correctly.  But you also find that correctly-written C++ is significantly faster than the language-with-training-wheels equivalent.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-mngoldeneagle odd alt depth-3 parent" id="comment-1258187">
				<div id="div-comment-1258187" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258187">
			July 28, 2016 at 2:39 pm</a>		</div>

		<p>In situations where performance is critical, write in C.  Otherwise, write in the language than enables you to write correct code easiest. :-)</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1258295">
				<div id="div-comment-1258295" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258295">
			July 29, 2016 at 6:50 am</a>		</div>

		<p>&gt; In situations where performance is critical, write in C.</p>
<p>This is a bit trolly, but I at least believe to an extent&#8230; but I&#8217;d change that to &#8220;if performance is more critical than correctness or security, write in C.&#8221;</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1258396">
				<div id="div-comment-1258396" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://programmerman.net' rel='external nofollow' class='url'>Nick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258396">
			July 29, 2016 at 3:21 pm</a>		</div>

		<p>I promise you I can write very fast code that is wrong. exit(0) comes to mind.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-exchange-development-blog-team even depth-3 parent" id="comment-1258255">
				<div id="div-comment-1258255" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">exchange development blog team</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258255">
			July 29, 2016 at 12:24 am</a>		</div>

		<p>And then you find all the holes are in the JVM instead of your code.  With C you can at least get it right (think MISRA and others).  With Java you can write the best code in the world but you&#8217;re still at the mercy of the JVM.  MISRA can&#8217;t even deal with C++ yet, let alone Java.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-exchange-development-blog-team odd alt depth-4" id="comment-1258265">
				<div id="div-comment-1258265" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">exchange development blog team</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258265">
			July 29, 2016 at 12:25 am</a>		</div>

		<p>Argh, DO-178B, not MISRA for the C++.  Knew that was wrong as soon as I&#8217;d clicked &#8220;Post&#8221;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4" id="comment-1258335">
				<div id="div-comment-1258335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258335">
			July 29, 2016 at 8:07 am</a>		</div>

		<p>You seem to be misunderstanding what MISRA (or DO-178B) actually are. They are guidelines for developing specific systems in specific languages. </p>
<p>It&#8217;s not that it&#8217;d be particularly hard to develop a similar standard for Java (and quite a few things apply to any language), but there&#8217;s just less of a demand for it &#8211; particularly since many of the issues that MISRA deals with are non issues in Java to begin with (make sure that your linker supports identifiers with more than 6 characters?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mngoldeneagle odd alt depth-4" id="comment-1258385">
				<div id="div-comment-1258385" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258385">
			July 29, 2016 at 10:01 am</a>		</div>

		<p>Sure, until a vulnerability is discovered in the standard library.  Or MFC, ATL, or one of the dozens of libraries your project is dependent on.</p>
<p>At the end of the day, you&#8217;re always at the mercy of your dependencies, regardless of the language.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3 parent" id="comment-1258285">
				<div id="div-comment-1258285" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258285">
			July 29, 2016 at 6:41 am</a>		</div>

		<p>The fun thing about C++ ideologists is that every time there&#8217;s another problem due to C++&#8217;s design they always tell you that that&#8217;s all due to stupid people not knowing how to write &#8220;correct&#8221; c++. </p>
<p>Sadly they&#8217;re never able to provide a link to a large open source project that is written in &#8220;correct c++&#8221; and shows that it&#8217;s possible to actually write a large c++ program without buffer overflows, use after free and all the other fun things.</p>
<p>Mind you, that doesn&#8217;t mean that it&#8217;s impossible to design a reasonable safe language without GC as rust shows.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4 parent" id="comment-1258355">
				<div id="div-comment-1258355" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zboot</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258355">
			July 29, 2016 at 8:37 am</a>		</div>

		<p>Maybe people are busy writing non open source large scale &#8220;correct&#8221; c++ programs, not vetting every single open source project so they could one they prove a specious point.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1258386">
				<div id="div-comment-1258386" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258386">
			July 29, 2016 at 10:37 am</a>		</div>

		<p>So you&#8217;re saying &#8220;correct c++&#8221; is such a rarity that there&#8217;s just no open source project out there that manages it?</p>
<p>Well OK, so what are the closed source ones? As long as it&#8217;s one with a public bug tracker we can probably still get a good idea about it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1258415">
				<div id="div-comment-1258415" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">santosh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258415">
			July 30, 2016 at 11:02 am</a>		</div>

		<p>Chromium?</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-4 parent" id="comment-1258475">
				<div id="div-comment-1258475" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Haim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258475">
			August 2, 2016 at 3:29 am</a>		</div>

		<p>Well let&#8217;s see.<br />
how about Windows, Mach and Linux as Operating systems? how about the JVM, the CLR, WebKit and V8 ? HHVM? FireFox and Chrome?  shall I continue?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-mngoldeneagle odd alt depth-5" id="comment-1258535">
				<div id="div-comment-1258535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258535">
			August 2, 2016 at 8:43 am</a>		</div>

		<p>He&#8217;s not saying impossible, just that it&#8217;s really hard to do.  All of those projects were created by really smart, well-paid people and even then they still have suffered (and in many cases continue to suffer) from pretty well-understood bugs like buffer overruns, heap spray attacks, memory leaks, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-5" id="comment-1258855">
				<div id="div-comment-1258855" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258855">
			August 4, 2016 at 4:09 am</a>		</div>

		<p>Umm, every single one of those projects had thousands of bugs due to out of bounds indizes, use after free, memory leaks and all the other fun C++ bugs. </p>
<p>If anything all of those are great examples how even really clever and good programmers cannot create reliable software in C++. Yes all those people who say that in theory you could avoid all those bugs are right &#8211; in theory. In practice there exists not a single large C++ project that has ever managed to write &#8220;correct C++&#8221;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1258865">
				<div id="div-comment-1258865" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://adamrosenfield.com' rel='external nofollow' class='url'>Adam Rosenfield</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258865">
			August 4, 2016 at 6:45 am</a>		</div>

		<p>All software has bugs.  While in theory a single out-of-bounds memory write, use-after-free, etc. is Undefined Behavior and can erase your hard drive or make demons fly out your nose, in practice things like that that don&#8217;t *usually* happen.</p>
<p>The choice of language will impact the nature of the bugs written, so a C++ project will be more likely segfault on a bug, while a Java project will be more likely to throw an ArrayIndexOutOfBoundsException on a bug, and a PHP project will be more likely to have some type coercion bug and spew nonsense into your HTML output.  Good programmers will write solid code with fewer bugs per unit of code regardless of the language, and bad programmers will write more bugs per unit code.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-4 parent" id="comment-1258935">
				<div id="div-comment-1258935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258935">
			August 4, 2016 at 10:21 am</a>		</div>

		<p>Voo, you play the troll. I have seen it. I&#8217;m not kidding; a major open source C++ project with version number &gt; 1.20 that as of 1.0 has had zero buffer overflow security exploits. It&#8217;s not even hard because there is a string class.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1259305">
				<div id="div-comment-1259305" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1259305">
			August 6, 2016 at 10:22 am</a>		</div>

		<p>And the name of that project would be? I mean I&#8217;ve seen so, so many people claim the existence of such projects and how it wouldn&#8217;t be hard if you just followed some simple rules, but somehow nobody ever actually names an example.</p>
<p>I mean I&#8217;d really like to see their style guidelines, static analysis tools and code review rules if they manage to keep more than a handful people over several years from never introducing a single bug of the kind.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1258165">
				<div id="div-comment-1258165" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258165">
			July 28, 2016 at 11:51 am</a>		</div>

		<p>If you want to implement this on older versions of Windows than 8, the values you want are in reinterpret_cast(NtCurrentTeb()).  The StackBase and StackLimit members are what you should check against.  Note that StackLimit is the *lower* value, because stacks grow downward on Windows platforms.  (The Itanium complication to that statement isn&#8217;t relevant here.)</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1258175">
				<div id="div-comment-1258175" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258175">
			July 28, 2016 at 11:52 am</a>		</div>

		<p>Really?  This is parsed as HTML?</p>
<p>reinterpret_cast&lt;NT_TIB *&gt;(NtCurrentTeb())</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1258196">
				<div id="div-comment-1258196" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mihailik</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258196">
			July 28, 2016 at 3:21 pm</a>		</div>

		<p>Stack versus heap is a red herring, the root cause is design flaw of the API.</p>
<p>If the caller has no control over how long the buffer is in use, then heap-allocated buffer has the same vulnerability: whilst the function is doing its async processing the caller may change the contents of the buffer, or reclaim/reuse the memory altogether.</p>
<p>Checking for stack allocation is not restrictive enough: you merely get LESS corruption. Arguably, rare and hard-to-reproduce corruption on the heap will be even costlier to track and fix.</p>
<p>So, good luck! ;-)</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1258225">
				<div id="div-comment-1258225" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258225">
			July 28, 2016 at 5:04 pm</a>		</div>

		<p>Agreed. If the caller has no control of how long the buffer is in use, then that would be a problem.<br />
The &#8220;buffer&#8221; would either need to be some sort of reference-counted object like how IAdviseSink works, or there would need to be some sort of &#8220;unsubscribe&#8221; type of method that took a &#8220;cookie&#8221; provided by some sort of &#8220;subscribe&#8221; method, with the API providing a guarantee that the buffer would not be used after the &#8220;unsubscribe&#8221; method returned, so it could be safely freed after the call to &#8220;unsubscribe&#8221; (making threading issues the user of the API&#8217;s responsibility to handle). Or something else to that effect that makes the whole thing work. &#8220;Assuming that code is mostly correct&#8221; and that the blog article is edited for brevity makes me confident that this is indeed the case&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-odd thread-alt depth-1" id="comment-1258275">
				<div id="div-comment-1258275" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258275">
			July 29, 2016 at 5:10 am</a>		</div>

		<p>To me this is an issue of ownership, something the current C++11 and up semantics make abundantly clear:</p>
<p>* Raw pointer is an unowned optional<br />
* Owned pointers are always smart pointers<br />
* Sinks should take in a smart pointer<br />
* non-optional pointers should be references</p>
<p>Sadly this doesn&#8217;t work with WIN32 which is a C api&#8230; but that&#8217;s what a wrapper is for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1258276">
				<div id="div-comment-1258276" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258276">
			July 29, 2016 at 6:04 am</a>		</div>

		<p>This check could be done with static analysis. There&#8217;re already different arguments hints for analyzer, like __in, __out, __in_opt. So adding something like __in_no_stack/__out_no_stack could be helpful for this, since static analyzer may track argument&#8217;s origin.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1258315">
				<div id="div-comment-1258315" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Steel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258315">
			July 29, 2016 at 7:24 am</a>		</div>

		<p>The concern with stack vs. heap allocation is completely irrelevant. The problem is that the code violates the implicit lifetime contract that the SendDataAsync() function requires of the buffer passed as an argument: namely, that the it live until the asynchronous transfer completes (or is cancelled). Moving the buffer to a scope with the appropriate lifetime, the ColorSender object, solves the problem. It would be the appropriate fix even if the ColorSender object is itself allocated on the stack.</p>
<p>This is a case where a safe, easy to use interface contracts and performance requirements conflict: a safe, easy to use interface contract would have the SendDataAsync() function either make a copy of the buffer, or use something like a std::shared_ptr to ensure the buffer data remains available after SendDataAsync() returns. However, high performance means avoiding the extra copying or smart pointer overhead.</p>
<p>The C++ Core Guidelines help to address some of these concerns by making ownership and lifetime more explicit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1258405">
				<div id="div-comment-1258405" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160728-00/?p=93975#comment-1258405">
			July 29, 2016 at 5:52 pm</a>		</div>

		<p>Another commenter already mentioned the Rust language, but to go into more detail: in the Rust language, the prototype for the SendDataAsync function can specify that `buffer` must have a lifetime at least as long as `completion`, and the compiler verifies that (it&#8217;s a compilation error otherwise).</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>