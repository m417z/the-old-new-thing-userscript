<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (53)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1142073">
				<div id="div-comment-1142073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Unicode</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142073">
			August 1, 2014 at 7:19 am</a>		</div>

		<p>Does Windows by now properly support UTF-8, as ANSI-codepage, for console-IO and the like?</p>
<p>Last I heard, iostreams on windows was hopelessly broken&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142083">
				<div id="div-comment-1142083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142083">
			August 1, 2014 at 7:30 am</a>		</div>

		<p>Yes the iostreams are broken. When Unicode broke their original promise of fitting in wchar_t, it should have been abandoned. The standard libraries are littered with functions that can&#39;t work. The fix was made long ago and it is UTF-8. Yet MS went on and has forced a massive division.</p>
<div class="post">[<em>Remember, Windows was using Unicode before UTF-8 was invented. So it&#39;s everybody else who created the division by going in a different direction. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142093">
				<div id="div-comment-1142093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Charles Babbage</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142093">
			August 1, 2014 at 7:43 am</a>		</div>

		<p>On two occasions I have been asked, — &quot;Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?&quot; In one case a member of the Upper, and in the other a member of the Lower, House put this question. I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hikari odd alt thread-odd thread-alt depth-1" id="comment-1142103">
				<div id="div-comment-1142103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Chris+Crowther' rel='external nofollow' class='url'>Chris Crowther</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142103">
			August 1, 2014 at 7:51 am</a>		</div>

		<p>Joshua: Whose definition of wchar_t? &nbsp;Because they&#39;re not the same &#8211; it&#39;s compiler dependant, afaik. &nbsp;The C90 standard only said it has to be big enough to represent all the possible character codes for supported locales. &nbsp;So in theory a 32-bit Unicode character will fit in wchar_t, so long as the compiler considers it a supported locale.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142113">
				<div id="div-comment-1142113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142113">
			August 1, 2014 at 9:03 am</a>		</div>

		<p>@Chris Crowther: But sticking UTF-16 in wchar_t was always wrong. UCS-2 was fine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142133">
				<div id="div-comment-1142133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142133">
			August 1, 2014 at 9:22 am</a>		</div>

		<p>Nah&#8230;. if you can&#39;t have fixed-size characters (which for a brief while was the promise of Unicode, with 16 bits appearing to be all we&#39;d ever need) then the next best choice is a byte-stream. &nbsp;UTF-16 is the worst of both worlds.</p>
<p>I used to be a firm believer in &quot;16 bits good, 8 bits bad&quot; (formed when 16 bits meant UCS-2) but several years of having to deal with UTF-16 has disabused me of that notion. &nbsp;But here&#39;s a much more eloquent writeup: <a rel="nofollow" target="_new" href="http://www.theregister.co.uk/2013/10/04/verity_stob_unicode/">http://www.theregister.co.uk/&#8230;/verity_stob_unicode</a></p>
<p>As a side note, how come we don&#39;t often see the internets sneering at the notion &quot;65535 characters ought to be enough for anybody&quot; the way they sneer at the infamous 640KB statement?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142143">
				<div id="div-comment-1142143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142143">
			August 1, 2014 at 9:23 am</a>		</div>

		<p>Methinks parkrrr has never had to deal with split surrogate pairs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142153">
				<div id="div-comment-1142153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wear</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142153">
			August 1, 2014 at 9:44 am</a>		</div>

		<p>@Dave because 65535 characters is enough for a lot of people. Hell, 128 characters is enough for a lot of people. Now you could rewrite windows entirely to use UTF-8 and cause problems for everyone or you could stick with the currently mostly working system that only causes problems for people doing major internationalization work. Which is the better option?</p>
<p>One could also make the argument that the people doing major internationalization ought to know what they are doing and so the difference between using UTF-8 and UTF-16 is minimal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142163">
				<div id="div-comment-1142163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142163">
			August 1, 2014 at 9:53 am</a>		</div>

		<p>I am really interested to know why wcout&#39;s locale has any effect on how much of a wstring it will be printed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142173">
				<div id="div-comment-1142173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142173">
			August 1, 2014 at 10:25 am</a>		</div>

		<p>@Joshua:</p>
<p>Wouldn&#39;t wchar_t only storing UCS-2 be against the standard? The definition of wchar_t from the standard is &quot;Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (22.3.1).&quot;</p>
<p>Considering that VC supports Unicode as its largest extended character set, UCS-2 is just plain wrong. But again, I think this is history at work again, since IIRC, when Windows first used Unicode there was no UTF-16, only UCS-2. As the Unicode standard started to add more, then it became obvious that sticking with UCS-2 would be bad, but at the same time changing the character type for wchar_t was also bad.</p>
<p>Anyway, why would surrogate pairs be a bad thing when UTF-8 does similar things? Anyone who is used to dealing with character sets that can use more than one value per character would have no difficulty with UTF-8, UTF-16 or any of the multi-byte locale based character sets. Methinks the problem is always in the programmer who never accounts for these things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142193">
				<div id="div-comment-1142193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142193">
			August 1, 2014 at 10:47 am</a>		</div>

		<p>@Azarien:</p>
<p>The problem is the STL. There have been proposals to update it to be Unicode aware, but right now it isn&#39;t Unicode friendly at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1142203">
				<div id="div-comment-1142203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142203">
			August 1, 2014 at 11:27 am</a>		</div>

		<p>&gt;Wouldn&#39;t wchar_t only storing UCS-2 be against the standard?</p>
<p>Only if you have a working time machine. Ask Raymond for the pass to the secret lab.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142223">
				<div id="div-comment-1142223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Unicode</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142223">
			August 1, 2014 at 11:54 am</a>		</div>

		<p>@Joshua: I explicitly spoke about UTF-8 there, and I do not know of any reason for why it is and stays broken. Anyway, standard Facets are broken for Unicode whatever width one takes, yea, but that&#39;s another higher-layer issue.</p>
<p>Regarding fixed-size characters: If one takes that to mean graphemes (aka printing characters and the like) instead of codepoints, even UTF-32 is not fixed-size, and never was.</p>
<p>@Wear: Even US-English uses characters outside ASCII.</p>
<p>@Crescens2k: Surrogate pairs are worse than multi-byte codepoints in UTF-8, because they a) Make encoding detailds bleed into the character set definition, b) Too many people don&#39;t test them properly (lazyyness and ignorance are wide-spread there), and c) They gull people into thinking one codeunit is one character (and if they avoid that trap, one codepoint is one character). UTF-8 is far less susceptible to that, because multi-codeunit codepoints are far more common, thus people learn the error of their ways nearly immediately.</p>
<p>@alegr1: Being against the standard (which imho is eqivalent to being wrong, especially here), is independent of any reasons for why the standard is not followed.</p>
<p>Yes, Windows has good reason, but that&#39;s beside that point.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142233">
				<div id="div-comment-1142233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142233">
			August 1, 2014 at 12:22 pm</a>		</div>

		<p>For efficiency, you&#39;d rather stick with UTF-16 minus composition and surrogates.</p>
<p>For interoperability, you&#39;d rather stick with UTF-8 and deal with composition and surrogates. &nbsp;This doesn&#39;t map efficiently on Windows, so you can stick with UTF-16 if that&#39;s your priority, sacrificing everyone else.</p>
<p>Even with UTF-32 or whatever is it that can handle full code units, you still need to think about composition, at the cost of extra space you&#39;ll probably never need to use.</p>
<p>Damn Unicode and its composed characters, versions and useless characters, it ought to be called Multicode-dings already.</p>
<p>Oh, and I almost forgot about RTL, LTR&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142243">
				<div id="div-comment-1142243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nico</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142243">
			August 1, 2014 at 12:38 pm</a>		</div>

		<p>@Charles Babbage: &nbsp;Love it. &nbsp;Big fan of your work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142253">
				<div id="div-comment-1142253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142253">
			August 1, 2014 at 1:01 pm</a>		</div>

		<p>@Unicode:</p>
<p>a) History and compatibility makes things messy you know. What would have you done? With the change between Unicode 1 and 2, would you have just redone all the sizes and broke existing Unicode conformant code? Back then they were struggling to get people to change over, and just breaking existing code wouldn&#39;t have helped the cause any.</p>
<p>b) Programmers are programmers.</p>
<p>c) But one code point isn&#39;t always one character even without surrogates. The Unicode version 1 standard defined several combining characters. These have increased dramatically ever since. Also, who gulls people into thinking one code-point is one character? From the Unicode FAQ &quot;No. The first version of Unicode was a 16-bit encoding, from 1991 to 1995, but starting with Unicode 2.0 (July, 1996), it has not been a 16-bit encoding. The Unicode Standard encodes characters in the range U+0000..U+10FFFF, which amounts to a 21-bit code space. Depending on the encoding form you choose (UTF-8, UTF-16, or UTF-32), each character will then be represented either as a sequence of one to four 8-bit bytes, one or two 16-bit code units, or a single 32-bit code unit.&quot; Or from the standard itself &quot;UTF-16 encoding form: The Unicode encoding form that assigns each Unicode scalar value in the ranges U+0000..U+D7FF and U+E000..U+FFFF to a single unsigned 16-bit code unit with the same numeric value as the Unicode scalar value, and that assigns each Unicode scalar value in the range U+10000..U+10FFFF to a surrogate pair, according to Table 3-5.&quot; Unicode itself doesn&#39;t gull anyone into thinking it is a fixed size encoding. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142263">
				<div id="div-comment-1142263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142263">
			August 1, 2014 at 1:27 pm</a>		</div>

		<p>The consequence of using UTF-8 is you tend to break exactly once, the first time you move outside of 7 bit ASCII, rather than three times, the first time out of Windows-1252, the first time out of the local encoding, and the first time out of the Unicode basic plane.</p>
<p>Furthermore, opendir(), readdir(), closedir() are standard. What do you think happens when processing a directory on Windows with readdir() and fopen() when encountering a file whose filename is not in the unicode basic plane.</p>
<p>Answer: it doesn&#39;t work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142273">
				<div id="div-comment-1142273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Unicode</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142273">
			August 1, 2014 at 1:34 pm</a>		</div>

		<p>@Crescens2k:</p>
<p>I know why a) was done (and why it is making the best of a bad deal), just listing it as a bad point.</p>
<p>Point b) is not that programmers can be lazy or ignorant, but that it quite rampant there. Many are proud of doing it the wrong way and defend it to the death.</p>
<p>About point c), there&#39;s a definition of character in the official document, which makes it denote, depending on context, codepoint as well as grapheme (one or more codepoints). The point was that the obviously variable length of a UTF-8 &quot;character&quot; makes the error less prevalent, naturally avoided and easier corrected there.</p>
<p>Anyway, do you know why UTF-8 with iostreams on Windows was, is, and hopefully will not stay broken many more decades?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142283">
				<div id="div-comment-1142283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">theultramage</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142283">
			August 1, 2014 at 2:28 pm</a>		</div>

		<p>You can do UTF-8 output on Windows, just do SetConsoleOutputCP(CP_UTF8) or _setmode(_fileno(stdout), _O_U8TEXT). You do need to switch the font to something like Lucida Console, though. I assume that there&#39;s a toggle for iostreams somewhere as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142293">
				<div id="div-comment-1142293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142293">
			August 1, 2014 at 2:46 pm</a>		</div>

		<p>@theultramage: try C:&gt; chcp 97001</p>
<p>The console editor barfs pretty bad but UTF-8 output to the console suddenly starts working. I suspect all bugs are completely fixable with no backwards compatibility problems. (And if there are any the workaround is don&#39;t run the broken applications under chcp 97001) and since there is no other way to convince the system to use a UTF-anything console &#8230;</p>
<div class="post">[<em>How do you fix IsDBCSLeadByte? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142313">
				<div id="div-comment-1142313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142313">
			August 1, 2014 at 3:44 pm</a>		</div>

		<p>@Joshua:</p>
<p>Invalid code page</p>
<p>Is what cmd gives me.</p>
<p>@Unicode:</p>
<p>Well, there are several reasons, but iostreams just isn&#39;t Unicode friendly. If you want to write UTF-8 text, right now it is better to just use the CRT functions or the Windows functions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142323">
				<div id="div-comment-1142323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142323">
			August 1, 2014 at 4:00 pm</a>		</div>

		<p>It&#39;s funny that no one has yet mentioned anything about the actual point of Raymond&#39;s post. &nbsp;:-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142123">
				<div id="div-comment-1142123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">parkrrrr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142123">
			August 1, 2014 at 9:04 am</a>		</div>

		<p>It&#39;s not true that UTF-8 is &quot;the&quot; fix. There are other fixes for the problem, too, including the far saner* UTF-16. </p>
<p>* Relative sanity of UTF-16 not guaranteed and may vary with user&#39;s primary language.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142333">
				<div id="div-comment-1142333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142333">
			August 1, 2014 at 4:27 pm</a>		</div>

		<p>@Raymond: &quot;How do you fix IsDBCSLeadByte?&quot;</p>
<p>You don&#39;t. There are issues that deserve to stay broken for greater good.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142343">
				<div id="div-comment-1142343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142343">
			August 1, 2014 at 4:32 pm</a>		</div>

		<p>@Crescens2k: Oops I got it mixed up with the CPT Code for Initial Eval. The number is 65001.</p>
<p>[How do you fix IsDBCSLeadByte? -Raymond]</p>
<p>Trivial. Of all the assumptions about code page byte length, you just had to fix the one that isn&#39;t broken. In addition, this is one place where you can get away with all the breaking changes you wan, for two reasons.</p>
<p>1) chcp 65001 is only ever being attempted for this use, and right now people expect some breakage so the behavior is completely opt-in.</p>
<p>2) It&#39;s the only hope for ever getting Unicode console as nobody expects null bytes on TEXT STDIN or STDOUT.</p>
<p>Don&#39;t point me to Powershell&#39;s new console. It&#39;s a lost cause because to put back what is missing is to need to go right back down this same rabbit hole again after twice as much work.</p>
<div class="post">[<em>Not sure what you mean by &quot;isn&#39;t broken&quot;. Applications assume that if IsDBCSLeadByte is true, then the next character is the final byte of the character. (This is required by DBCS, because a lead byte in trail position is a trail byte.) Applications like, say, Explorer. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142353">
				<div id="div-comment-1142353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142353">
			August 1, 2014 at 5:18 pm</a>		</div>

		<p>Raymond, OEMCP not ANSICP. Explorer&#39;s not going to see it at all. I&#39;m pretty sure that IsDBCSLeadByteEx returns false if not operating on the magic 5 OEMCP that actually are MBCS and can stay that way.</p>
<p>This leaves only conhost.exe (the editor itself), cmd.exe, and find.exe. There really aren&#39;t that many console programs that process text (as opposed to simply passing it around) in Windows.</p>
<div class="post"><em>Oh, sorry, I missed that this was setting only the console code page. I don&#39;t think this change OEMCP, though. I&#39;ll have to play with it. -Raymond</em>]</div>
<div class="post"><em>chcp 65001 doesn&#39;t affect GetOEMCP(), so console apps that use WideCharToMultiByte(CP_OEMCP) [i.e., any console app that has localized text] will generate garbage output. (Note also that all these comments have nothing to do with the topic of the article. UTF-8 in the console is a topic for Michael Kaplan, not me, and I believe he has written about it rather extensively already.) -Raymond]</em></div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142183">
				<div id="div-comment-1142183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142183">
			August 1, 2014 at 10:36 am</a>		</div>

		<p>Leaving UTF-8 aside, event UTF-16 support sucks.</p>
<p>Why do I have to bother with locales when I&#39;m already using *w*cout, *w*string and *w*char_t, which are supposed to use UTF-16 on Windows?</p>
<p>Yes, I know there are some typographical issues between e.g. Hong Kong and Taiwan locales, but having a dumb &quot;C&quot; locale that does not work at all as a default is not a solution.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142373">
				<div id="div-comment-1142373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142373">
			August 2, 2014 at 7:24 am</a>		</div>

		<p>Why would IsDBCSLeadByte() ever return true under UTF-8, given that UTF-8 is not a DBCS, and therefore no bytes in a UTF-8 stream are DBCS lead bytes? Given that UTF-8 is self-synchronising, it would seem that IsDBCSLeadByte() is unnecessary in such a locale anyway, and that MultiByteToWideChar() should &quot;just work&quot;.</p>
<div class="post">[<em>If IsDBCSLeadByte always returns false, then code that parses 8-bit strings will assume one character = one byte. This will result in weird things like code that tries to wrap long lines at 80 characters wrapping at only 20; or code that tries to remove the last character from a string chopping off a partial character, leaving invalid utf-8 behind. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142393">
				<div id="div-comment-1142393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142393">
			August 2, 2014 at 1:04 pm</a>		</div>

		<p>@Karellen: I think the question is, why do iostreams convert wchar_t* strings from UTF-16 to ANSI and back to UTF-16, losing information, instead of just writing UTF-16 to the console directly?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142403">
				<div id="div-comment-1142403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Raymond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142403">
			August 2, 2014 at 1:29 pm</a>		</div>

		<p>Referring to Michael Kaplans blog would be much more useful if it was still online.</p>
<p>As is, most searches lead one to a not-found page at microsoft.</p>
<p>Only combining that with the internet archive helps:</p>
<p><a rel="nofollow" target="_new" href="https://web.archive.org/web/20131031155523/http://blogs.msdn.com/b/michkap">web.archive.org/&#8230;/michkap</a></p>
<p>Still, I had some small hope MS C++ implementation got better with UTF-8 by now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142363">
				<div id="div-comment-1142363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142363">
			August 2, 2014 at 7:10 am</a>		</div>

		<p>@Azarien: &quot;Why do I have to bother with locales when I&#39;m already using *w*cout, *w*string and *w*char_t, which are supposed to use UTF-16 on Windows?&quot;</p>
<p>Because locales are about a lot more than your character set. Like, which language is used by the OS/apps, which is kind of important if you want things to be usable by people by people who speak a different language from the author. Or how the digits in large numbers are grouped, and which character is used as a decimal mark for non-integers. Or how to format/parse dates like 01/02/03.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142383">
				<div id="div-comment-1142383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142383">
			August 2, 2014 at 9:24 am</a>		</div>

		<p>While we&#39;re on the subject of utf8 brokenness&#8230;</p>
<p>The WriteFile function returns the number of bytes written. &nbsp;This has been true since Windows NT 3.1. &nbsp;Lots of code depends on it.</p>
<p>However, if you write to a console with the codepage set to 65001, WriteFile returns the number of *characters* written.</p>
<p>MS refuse to fix this, yet (years later) there&#39;s still no mention of this feature in the WriteFile documentation.</p>
<p><a rel="nofollow" target="_new" href="http://connect.microsoft.com/VisualStudio/feedback/details/543801/unicode-issues-with-writefile-and-in-the-crt" rel="nofollow">connect.microsoft.com/&#8230;/unicode-issues-with-writefile-and-in-the-crt</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142413">
				<div id="div-comment-1142413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142413">
			August 2, 2014 at 8:44 pm</a>		</div>

		<p>Wow that WriteFile bug is /nasty/ and given the CRT expects it to work I&#39;m wondering how my testing got as far as it did.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142423">
				<div id="div-comment-1142423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142423">
			August 3, 2014 at 6:50 am</a>		</div>

		<p>In fact, any program that may read or write to a console and which is Obviously™ well written to loop until all byte are written will fail ridiculously due to a Win32 bug that won&#39;t be fixed. &nbsp;And to think it depends on the font tells even more, it&#39;s the console client that fails, not the console server.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142433">
				<div id="div-comment-1142433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142433">
			August 3, 2014 at 1:18 pm</a>		</div>

		<p>A company which develops and sells the os and the compiler/ide, and is part of the programming language committee, doesn&#39;t have any excuses for that code to fail. Stop blaming others and just make it work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1142453">
				<div id="div-comment-1142453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142453">
			August 3, 2014 at 6:55 pm</a>		</div>

		<p>@Wear : The nice thing about UTF-8 is that when only lower 127 ASCII range is used, it&#39;s exactly the same as ASCII table. That means for most programmer that don&#39;t work at Microsoft, there will be need to call one API version only and we can ensure old program continues to work.</p>
<p>Now since the API selected to use UTF-16 which requires to insert prepending nulls to low ASCII ranges, it means we can&#39;t just ditch the &#8230;A() API functions or some old programs (or newer programs that not written with Unicode directive enabled) will fail.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-1142463">
				<div id="div-comment-1142463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142463">
			August 3, 2014 at 7:06 pm</a>		</div>

		<p>@@Raymond: FYI, Michael Kaplan have created a new blog <a rel="nofollow" target="_new" href="http://www.siao2.com/">http://www.siao2.com/</a> and moved all old posts from internet archive over there. No need to bother the internet archive for this one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142443">
				<div id="div-comment-1142443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142443">
			August 3, 2014 at 2:32 pm</a>		</div>

		<p>Well your reply on WideCharToMultiByte makes it possible to now bring this back on topic. Let&#39;s say a hypothetical question</p>
<p>WideCharToMultiByte doesn&#39;t work when the console code page is changed:</p>
<p> &nbsp; &nbsp;SetConsoleCp(866) // Russian</p>
<p> &nbsp; &nbsp;SetConsoleOutputCp(866) // Russian</p>
<p> &nbsp; &nbsp;WideCharToMultiByte(CP_OEMCP, &#8230;, lpszConsoleOutputBuf, &#8230;)</p>
<p> &nbsp; &nbsp;WriteConsole(&#8230;, lpszConsoleOutbugBuf, &#8230;)</p>
<p>Answer: The call to WideCharToMultiByte is wrong. Use</p>
<p> &nbsp; &nbsp;SetConsoleCp(866) // Russian</p>
<p> &nbsp; &nbsp;SetConsoleOutputCp(866) // Russian</p>
<p> &nbsp; &nbsp;WideCharToMultiByte(GetConsoleOutputCP(), &#8230;, lpszConsoleOutputBuf, &#8230;)</p>
<p> &nbsp; &nbsp;WriteConsole(&#8230;, lpszConsoleOutbugBuf, &#8230;)</p>
<p>This behavior leads me to think that OEMCP is good for almost nothing. The only *possible* use I can find is interpreting filenames on MS-DOS FAT disks (no long file names).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142473">
				<div id="div-comment-1142473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">wen-xibo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142473">
			August 4, 2014 at 4:19 am</a>		</div>

		<p>Dear Raymond: I had read your document about RealGetWindowClass at <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2010/12/31/10110524.aspx">blogs.msdn.com/&#8230;/10110524.aspx</a> &nbsp;. &nbsp;</p>
<p>But unfortunately , I cann&#39;t get the base class name from a simple superclass from &quot;BUTTON&quot; class .</p>
<p> &nbsp;My new class is very simple : superclass &quot;BUTTON&quot; and transfer all of message to original class wnd proc . But RealGetWindowClass return &quot;MyButton&quot; same as GetClassName , I test program on XP and Win7 and get same result . </p>
<p> &nbsp;I want to debug into RealGetWindowClass but I am very poor on use windbg . &nbsp; &nbsp;I hope a method can found the base class of a superclass . </p>
<p> &nbsp;I need your help, thank you very much . </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142483">
				<div id="div-comment-1142483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">parkrrrr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142483">
			August 4, 2014 at 6:02 am</a>		</div>

		<p>The entire discussion of UTF-8 vs. UTF-16 is very English-centric. Half the people on Earth speak a language that requires, on average, three or more bytes per codepoint in UTF-8 vs approximately two bytes per codepoint in UTF-16. Thus the footnote in my original comment: UTF-8 looks sane if your language (human, not programming) only uses the Basic Latin charset. It looks a lot less sane if you use pretty much anything else.</p>
<p>And any argument that UTF-8 is easier to deal with is going to have to somehow square that with the fact that pretty much no website on the planet manages to render the ubiquitous U+2019 properly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142493">
				<div id="div-comment-1142493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142493">
			August 4, 2014 at 7:03 am</a>		</div>

		<p>@parkrrr: Comparing byte density of letter symbols to word symbols is not fair. Three bytes per word is still much better than English.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1142503">
				<div id="div-comment-1142503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142503">
			August 4, 2014 at 7:58 am</a>		</div>

		<p>@Joshua:</p>
<p>Cyrillic, Armenian, Georgian, Hindu, Tagalog,&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142523">
				<div id="div-comment-1142523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">frenchguy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142523">
			August 4, 2014 at 8:44 am</a>		</div>

		<p>Actually, any language that uses a script other than latin, except Chinese. Non-English latin-script languages probably get an average a little over 1 byte per character in utf-8.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142563">
				<div id="div-comment-1142563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@parkrr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142563">
			August 4, 2014 at 10:23 am</a>		</div>

		<p>There&#39;s a small sliver where UTF-16 has denser storage than UTF-8 by 2:3, yes.</p>
<p>But there&#39;s a much more important part where UTF-8 win 1:2.</p>
<p>Before you discount that, please take into account that even predominantly chinese texts can and do often have snippets of ASCII too. But that is not the most important reason that is a false economy: Textual computer protocolls and data-formats (HTML, HTTP, myriad others) use basic ASCII nearly exclusively. Thus even a pure chinese html page will be no bigger (probably smaller) using UTF-8 than UTF-16. Anyway, it would not hurt if chinese used double the amount of bytes for each symbol english uses: Equivalent text would still be shorter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142573">
				<div id="div-comment-1142573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142573">
			August 4, 2014 at 10:31 am</a>		</div>

		<p>@parkrrr,</p>
<p>I&#39;m not getting it. What&#39;s the problem with rendering U+2019 (RIGHT SINGLE QUOTATION MARK)? I see it the way it is supposed to be all the time.</p>
<p>And, what has the web site to do with the rendering? I leave the rendering of all characters, Unicode or not, to my local browser, not to the web site.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142633">
				<div id="div-comment-1142633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142633">
			August 4, 2014 at 2:21 pm</a>		</div>

		<p>@j b: Believe it or not, FTP is UTF-8 now, and this was done mostly without upgrading the old implementations. I&#39;m pretty sure the Windows client broke but all the old UNIX clients and servers that don&#39;t know what Unicode is work just fine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142663">
				<div id="div-comment-1142663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142663">
			August 4, 2014 at 5:17 pm</a>		</div>

		<p>@j b, they&#39;re plain 7-bit extended to 8-bit. &nbsp;That is, the upper 0 bit is effectively useless communication overhead. &nbsp;But not useless in the sense that current day machines all deal with octets at some point, so I guess low-level (wire/wireless level) communication should go like &quot;Hey, the upper-level protocol is guaranteed to send 7-bit characters, let&#39;s ditch the extra bit for the next ?? , shall we?&quot;</p>
<p>Except that every protocol you can think of being purely 7-bit no longer is, due to server extensions, client extensions, charset content-type support, and what not. &nbsp;Mainly because the wire protocols also guarantee octet transmission, in case that 7-bit protocol is actually only 7-bit for text content.</p>
<p>And lower-level protocols are better off with fast (de)compression.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142613">
				<div id="div-comment-1142613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142613">
			August 4, 2014 at 12:10 pm</a>		</div>

		<p>@parkrrr,</p>
<p>Protocol elemnents like HTTP (HTML is not a protocol &#8211; not any more than, say, JPEG!), SMTP, FTP, &#8230; are *never* (at least as of today) UTF-8 encoded! They are plain 7-bit ASCII &#8211; not even 8-bit 8859-x! The only time where you might run into a choice of how to represent these protocol elmeents would be in documentation. And then they are document contents, not protocol.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142683">
				<div id="div-comment-1142683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142683">
			August 5, 2014 at 12:23 am</a>		</div>

		<p>@Joshua &quot;WideCharToMultiByte(GetConsoleOutputCP()&quot;</p>
<p>Combined with &quot;MultiByteToWideChar(Windows.GetConsoleCP()&quot; at the reading side, this seems to be the only correct way for console programs. When you type something like &quot;cat file|find bla|find blub&quot;, the pipe for the redirected stdin/stdout channels has no agreed character semantics in itself. Because you already need to convert your input/output according to the actual console codepage, and probably don&#39;t want to detect the pipe case anyway, this would give both processes a common codepage. (If not this way, how else?)</p>
<p>But is there any situation where GetConsoleCP() and GetConsoleOutputCP() may return different values for a new process? Given that there are no &quot;character pipes&quot; to connect console processes, the concept of different codepages for inout and output seems very strange to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142703">
				<div id="div-comment-1142703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142703">
			August 5, 2014 at 1:51 am</a>		</div>

		<p>@Joshua,</p>
<p>I wasn&#39;t aware of that FTP extension (haven&#39;t been working with FTP at the protocol level for a while!), but I notice that the RFC 2640 extension applies to the file name parameter only, not to the protocol as a whole. Furthermore, RFC 2640 is still a &quot;Draft Standard&quot; &#8211; not that it means much, but it isn&#39;t mandatory at the same level as plain old FTP.</p>
<p>Anyway, thanks for making me aware of this extension.</p>
<p>(Sidetrack: Do anyone still use old 56 kbps lines at your side of the pond, letting the phone company steal the 8th bit for signalling? Or is that long gone history today, even in the US?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142713">
				<div id="div-comment-1142713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142713">
			August 5, 2014 at 2:07 am</a>		</div>

		<p>@John Doe,</p>
<p>In the old days of 56 kbps lines, the upper bit certainly wasn&#39;t &quot;useless communication overhead&quot; &#8211; it was what enabled the phone company to put you in contact with your communication peer. Every 6 sample, the signalling stole that bit for communication among the phone switches; that&#39;s why data communication couldn&#39;t make use of it, but the switches did. (In Europe, we never did that; for signalling between switches we had dedicated channels, so we could use the full 64 kbps capacity for user traffic, with full 8 bit data. Besides, we were much more in favor of dedicated digital networks, bit oriented such as X.21 networks, rather than &quot;reusing&quot; the old phone networks.)</p>
<p>Even though bit 8 today is always(?) zero, you cannot say tha 7-bit protocols are &quot;extended to 8-bit&quot;! They were defined using 7-bit ASCII, and 7-bit ASCII implies that bit 8 is available for other uses, such as parity, or in the case of 56 kbps lines, signalling purposes. The protocol specification doesn&#39;t implicitly change just because currently, noone sees a use for bit 8. You can change the specification, suc as with RFC 2640 for the file name parameter. But if e.g. someone suggests another extension using a command word containg characters outside 7-bit ASCII, it would for all practical purposes be unacceptable; old implementations would be unable to reliably parse the command and classify it as &quot;not supported&quot;. (Note in RFC 2640 how you might have to insert NUL bytes in the file name to keep old implementations from breaking!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1142723">
				<div id="div-comment-1142723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142723">
			August 5, 2014 at 2:47 am</a>		</div>

		<p>@j b</p>
<p>&quot;Even though bit 8 today is always(?) zero, you cannot say tha 7-bit protocols are &quot;extended to 8-bit&quot;! They were defined using 7-bit ASCII, and 7-bit ASCII implies that bit 8 is available for other uses&quot;</p>
<p>It doesn&#39;t make sense to treat data from a socket as anything other than 8 bit data. UTF-8 proponents have to deny that many .txt files have 8-bit data in them as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1142903">
				<div id="div-comment-1142903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140801-00/?p=353#comment-1142903">
			August 5, 2014 at 10:39 am</a>		</div>

		<p>If you care about storage size, just compress it with your favorite compression algorithm and be done with it. &nbsp;UTF-8 and UTF-16 compress pretty comparably. &nbsp;The size argument is just not a valid argument these days on computers with GBs of memory and TBs of durable storage. &nbsp;If you&#39;re truly processing GBs of text data, compression will do you far more wonders than changing from UTF-8 to UTF-16 or vice-versa.</p>
<p>But all of the other arguments for UTF-8 over UTF-16 are still perfectly valid.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>