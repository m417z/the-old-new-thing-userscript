<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (18)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1196491">
				<div id="div-comment-1196491" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196491">
			August 7, 2015 at 7:08 am</a>		</div>

		<p>Thanks Raymond, for an interesting tour of a rather weird architecture.</p>
<p>I&#39;ve been impressed with the clarity of your explanations, and I&#39;d love to see you do this again with another architecture that Windows has supported.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196481">
				<div id="div-comment-1196481" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196481">
			August 7, 2015 at 7:08 am</a>		</div>

		<p>Very interesting fortnight. I&#39;d definitely be voting for doing this with another architecture some time!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196471">
				<div id="div-comment-1196471" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BDCrazy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196471">
			August 7, 2015 at 7:11 am</a>		</div>

		<p>Fascinating adventure. &nbsp;Thanks for the work involved.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196461">
				<div id="div-comment-1196461" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196461">
			August 7, 2015 at 7:23 am</a>		</div>

		<p>Let me add my thanks as well. As you said at the beginning, it&#39;s very much like learning a foreign language. Not directly practical if you&#39;re not going to be in a place where you need it, but really interesting to see another way of looking at the world.</p>
<p>Is the br.ctop instruction something special that lets you get 4 instructions in an instruction group instead of 3? Or am I completely misunderstanding the prior parts of the series?</p>
<div class="post">[<em>You&#39;re confusing instruction groups (which can be arbitrarily large) and bundles (which are groups of three instructions). -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196451">
				<div id="div-comment-1196451" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196451">
			August 7, 2015 at 7:39 am</a>		</div>

		<p>(p16) ld4 r32 = [r29], 4 &nbsp; &nbsp; &nbsp;// execute an entire loop with</p>
<p>(p18) adds r34 = r34, 1 &nbsp; &nbsp; &nbsp; // a single instruction group</p>
<p>(p19) st4 [r28] = r35, 4 &nbsp; &nbsp; &nbsp;// using this one weird trick</p>
<p>Echoes of certain dumb internet advertisements. &nbsp; Funny!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196441">
				<div id="div-comment-1196441" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196441">
			August 7, 2015 at 7:43 am</a>		</div>

		<p>Question: &nbsp;This processor is great at pipelining and parallel execution. &nbsp;</p>
<p>But, the first illustration shows the job taking 13 steps. &nbsp;After rearrangement, the illustration takes &#8230; 13 steps. &nbsp;What have we gained? &nbsp;</p>
<p>Is the answer that when we are in the Kernel or &quot;cruise&quot; phase, everything runs faster without pipeline stalls?</p>
<div class="post">[<em>It&#39;s the same number of cycles, but expressed in far fewer instructions. If the kernel has <var>N</var> phases, then the old way needs <var>N</var>(<var>N</var>&minus;1) prologue instructions, <var>N</var>&sup2; kernel instructions, and <var>N</var>(<var>N</var>&minus;1) epilogue instructions. And that&#39;s assuming the number of iterations is an exact multiple of <var>N</var>. The new way, it&#39;s 3 set-up instructions and <var>N</var>+1 kernel instructions. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196431">
				<div id="div-comment-1196431" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196431">
			August 7, 2015 at 8:18 am</a>		</div>

		<p>@DWalker <a rel="nofollow" target="_new" href="http://www.youtube.com/watch?v=xECUrlnXCqk">http://www.youtube.com/watch</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196421">
				<div id="div-comment-1196421" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196421">
			August 7, 2015 at 9:25 am</a>		</div>

		<p>Came to the comments to thank you for the series and express LOLs at the &quot;one weird trick&quot; reference (And the &quot;but wait: there&#39;s more!&quot;).</p>
<p>This made for some heavy but enjoyable reading, thank you, Raymond, for writing it all up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196411">
				<div id="div-comment-1196411" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carl D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196411">
			August 7, 2015 at 10:13 am</a>		</div>

		<p>I must echo other comments here &#8211; well done on this series, Raymond! &nbsp;Itanium is a fascinating beast indeed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196401">
				<div id="div-comment-1196401" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196401">
			August 7, 2015 at 1:26 pm</a>		</div>

		<p>I see how I misinterpreted Part 1 now. I had read it that each &quot;bundle&quot; consisted of &quot;instruction groups&quot; separated by double-semicolons, but now I see that they&#39;re actually separate concepts, and an instruction group can span bundles, and due to all the pipelining and multiple-computation-areas and such in a processor, it can work on more than one bundle at once.</p>
<p>Yes, &quot;foreign language&quot; is a very apt analogy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196391">
				<div id="div-comment-1196391" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio &amp;#39;Grijan&amp;#39;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196391">
			August 7, 2015 at 3:02 pm</a>		</div>

		<p>@pc: if I have understood correctly, most Itanium processors have enough units to allow them execute up to six instructions (two bundles) in the same cycle. The exception is the last generation, which can execute up to twelve instructions (four bundles) per cycle. Knowing that, the kernel of four instructions written by Raymond would be executed in just one cycle, and there would be two spare execution units (the kernel could have two more instructions and still be executed in one cycle). There is a nice diagram explaining it in page 8 of <a rel="nofollow" target="_new" href="http://www.rw.cdl.uni-saarland.de/~kaestner/es0203/lectdk11.pdf">http://www.rw.cdl.uni-saarland.de/&#8230;/lectdk11.pdf</a> .</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196371">
				<div id="div-comment-1196371" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DoomMuffins</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196371">
			August 8, 2015 at 7:36 am</a>		</div>

		<p>Thanks for the read, Raymond &#8211; it was a fascinating series, and I hope to see one about the Alpha AXP.</p>
<p>I was wondering whether debuggers for this platform performed step-through in units of bundles rather than instructions (did each F10 in windbg print the entire current bundle?), and if not &#8211; what did they do to break each bundle up?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196361">
				<div id="div-comment-1196361" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196361">
			August 8, 2015 at 9:01 am</a>		</div>

		<p>DoomMuffins: Any interruption (like an exception, single-stepping in the debugger, or a hardware interrupt) sets not only the IIP (interruption instruction pointer) but also the bits in a status register that tell which instruction in the bundle is being executed.</p>
<p>Upon resuming from that interruption, the CPU knows which instruction in the bundle to execute next.</p>
<p>So even though you can&#39;t specify a branch to the middle of a bundle, the processor still handles it the way you would want in all other circumstances.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196351">
				<div id="div-comment-1196351" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">A regular viewer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196351">
			August 8, 2015 at 10:14 am</a>		</div>

		<p>I too thank you, Raymond. This was fascinating.</p>
<p>I have no actual low-level CPU programming experience and I did follow this series at a passable level. I &quot;got&quot; it &#8211; so to speak.</p>
<p>I want to highlight something here. This series explained the functioning of the Itanium processor in such a manner that a dyed-in-the-wool Visual Basic programmer can understand. And has understood. The credit for that goes to you, far more than, to Intel.</p>
<p>Again. Thank you.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196341">
				<div id="div-comment-1196341" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196341">
			August 8, 2015 at 8:50 pm</a>		</div>

		<p>@DoomMuffins:</p>
<p>Look up the handling of Bus Error and Address Error exceptions on 68k processors (68010 and later) &#8211; they saved their internal state in the exception stack frame, allowing them to resume execution of the faulting instruction!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196331">
				<div id="div-comment-1196331" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196331">
			August 9, 2015 at 11:27 am</a>		</div>

		<p>I&#39;m kind of relieved that we&#39;ve been saved from this insanity&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196321">
				<div id="div-comment-1196321" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">user</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196321">
			August 9, 2015 at 5:43 pm</a>		</div>

		<p>Another vote for the Alpha AXP next.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196311">
				<div id="div-comment-1196311" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196311">
			August 10, 2015 at 5:47 am</a>		</div>

		<p>@Azarien</p>
<p>It&#39;s not that insane &#8211; the gap between Itanium and Xeon is simply that Itanium exposes this level of detail to the ISA for a compiler or assembly programmer to exploit, whereas Xeon extracts this sort of insanity (and more) from the &quot;more traditional&quot; x86 ISA.</p>
<p>Effectively, the Itanium bet was that we&#39;d be quicker to write compilers that could fully exploit the features that Raymond has outlined than the hardware guys would be to detect cases where they can be exploited in an existing instruction stream.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>