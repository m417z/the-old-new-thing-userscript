<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (33)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-274963">
				<div id="div-comment-274963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/michkap/archive/2005/05/10/416008.aspx' rel='external nofollow' class='url'>Sorting It All Out</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-274963">
			May 10, 2005 at 10:39 am</a>		</div>

		<p>Raymond Chen is going to be developing a Chinese dictionary over the next while. This is a really cool&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-274973">
				<div id="div-comment-274973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lance Fisher</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-274973">
			May 10, 2005 at 10:48 am</a>		</div>

		<p>Makes me wish I knew some Chinese.  Could you do one in Russian?  Just kidding.  Not quite the same complexity, eh?  This will be really interesting.  I love the blog, Raymond.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-274983">
				<div id="div-comment-274983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-274983">
			May 10, 2005 at 11:13 am</a>		</div>

		<p>okay, so this doesn&#8217;t work for me; converting the first non-ascii character (0xa8) causes a conversion error.  in xmbtowc.c, _Mbrtowc() is using the macro _cpp_isleadbyte(), which uses the _pctype pointer from ctype.c.  if i&#8217;m reading this right, __init_ctype() is supposed to set _pctype to a newly-created table for the codepage.  the problem is that __init_ctype() gets called twice: inside the std::locale constructor, a temporary _Locinfo object gets used, and in its destructor it seems to restore the original locale, causing __init_ctype() to be called for the original &quot;C&quot; locale.  subsequently, neither __init_ctype() nor setlocale() is called, so the locale is the plain &quot;C&quot; locale.  am i missing something?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-274993">
				<div id="div-comment-274993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mark.santaniello.net/' rel='external nofollow' class='url'>Mark</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-274993">
			May 10, 2005 at 11:35 am</a>		</div>

		<p>Raymond,</p>
<p>Perhaps this could be made faster if you used v.reserve(&#8230;) to avoid realloc&#8217;s on push_back?  This would require some knowledge of the eventual size of the Dictionary.</p>
<p>-Mark</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275003">
				<div id="div-comment-275003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel Rejment</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275003">
			May 10, 2005 at 12:43 pm</a>		</div>

		<p>I had the same problems, but I found a workaround.<br />
<br />Add this line to the constructor:</p>
<p>std::locale old = std::locale::global(std::locale(&quot;.950&quot;));</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275013">
				<div id="div-comment-275013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aleko Petkov</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275013">
			May 10, 2005 at 1:08 pm</a>		</div>

		<p>The first order of business is to optimize the startup time? Hmmm, isn&#8217;t that a bit premature? :)</p>
<p>Jokes aside, this looks like an intersting project, I&#8217;ll be sure to keep an eye on it. Excellent blog, keep up the good work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275023">
				<div id="div-comment-275023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Dunn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275023">
			May 10, 2005 at 1:38 pm</a>		</div>

		<p>hmm, VC6 is giving me no love with this. dict.Length() returns 1184, but it sure runs blindingly fast! ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275033">
				<div id="div-comment-275033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Memet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275033">
			May 10, 2005 at 2:10 pm</a>		</div>

		<p>I&#8217;m curious, but I&#8217;m sure I&#8217;ll get an answer tomorrow: are you intending on making the input of the stream be processed faster? or defering it to a worker thread so that you can display the UI before the file is completely there?<br />
<br /> I&#8217;m personally quite a big fan of &#8216;few error/status messages&#8217;. What I mean by that is that I personally would take the path of having the UI show a &#8216;searching&#8217; status sign when a word is searched for, and use that same status display when the in memory database is locked because it is loading. The resulting scenario would be that if I launch my app and type in a word right away, I would get a &#8216;searching&#8230;&#8217; indicator until the db had fully loaded (as opposed to a &#8216;loading db&#8217; indicator).<br />
<br /> That&#8217;s just me, I&#8217;m hyped to see the rest!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275053">
				<div id="div-comment-275053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasmusic.com' rel='external nofollow' class='url'>Joshua Schaeffer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275053">
			May 10, 2005 at 3:12 pm</a>		</div>

		<p>I would just prefer using a database.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-banerjeeindranil odd alt thread-odd thread-alt depth-1" id="comment-275063">
				<div id="div-comment-275063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IndranilBanerjee' rel='external nofollow' class='url'>IndranilBanerjee</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275063">
			May 10, 2005 at 4:06 pm</a>		</div>

		<p>Premature optimisation is the root of all evil, so here goes&#8230;</p>
<p>The biggest and most immediate bang for you buck is to reserve a vector of reasonable size. For big dictionaries it will make a huge difference.</p>
<p>Secondly DictionaryEntry has a member called simp which does nothing but take up space, so you could lose that,</p>
<p>If there was still a problem. Then I would reduce the number of DictionaryEntry objects created and copied around.</p>
<p>Move the parsing code into a non member function which returned the positions of the substrings.</p>
<p>&lt;pre&gt;<br />
<br />if(Parse(line, space, lbrace, rbrace, firstslash, lastslash) {<br />
<br />  v.push_back( DictionaryEntry(line.substr(0, space),&#8230;.);<br />
<br />}<br />
<br />&lt;/pre&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275083">
				<div id="div-comment-275083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel Rejment</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275083">
			May 10, 2005 at 4:12 pm</a>		</div>

		<p>Did you really test the code?<br />
<br />Here are some timings:</p>
<p>No changes: 471 ms<br />
<br />Removing the simp member: 471 ms<br />
<br />Reserving space in vector: 421 ms</p>
<p>Didn&#8217;t test the string thing, but if I comment out the entire if-statement and just blast through the file with getline it still takes 361 ms. Unless you change the way the file is read, you won&#8217;t get it much faster than that.</p>
<p>-Daniel</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-banerjeeindranil odd alt thread-odd thread-alt depth-1" id="comment-275073">
				<div id="div-comment-275073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IndranilBanerjee' rel='external nofollow' class='url'>IndranilBanerjee</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275073">
			May 10, 2005 at 4:16 pm</a>		</div>

		<p>Doesnt a Dictionary involve doing lookups? If so why a vector? Surely a map is more appropriate?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-275093">
				<div id="div-comment-275093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275093">
			May 10, 2005 at 4:22 pm</a>		</div>

		<p>indranilbanerjee: Think it through. Suppose physical dictionaries worked like that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-banerjeeindranil odd alt thread-odd thread-alt depth-1" id="comment-275103">
				<div id="div-comment-275103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IndranilBanerjee' rel='external nofollow' class='url'>IndranilBanerjee</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275103">
			May 10, 2005 at 4:33 pm</a>		</div>

		<p>&quot;Think it through. Suppose physical dictionaries worked like that. &quot;</p>
<p>With a book I can add bookmarks and if I&#8217;m looking up a word beginning with Z I can start looking near the back.</p>
<p>I guess you can do the same with a random access container like vector. Not quite the same though</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-275123">
				<div id="div-comment-275123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275123">
			May 10, 2005 at 4:40 pm</a>		</div>

		<p>Substring searches are kind of hard with maps, too. And iterating through a map has poor locality &#8212; we&#8217;ll see the impact of that in autumn.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275133">
				<div id="div-comment-275133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.foxyshadis.com' rel='external nofollow' class='url'>foxyshadis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275133">
			May 10, 2005 at 5:18 pm</a>		</div>

		<p>I love it when you say things like that. Cracks me up, especially when the time comes. I bet you even have the precise date already.</p>
<p>I wonder if disk fragmentation would make much difference in a file this size. Maybe I should find out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275143">
				<div id="div-comment-275143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">B.Y.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275143">
			May 10, 2005 at 5:49 pm</a>		</div>

		<p>Well, I compiled and ran the program, it bailed after reading 1184 entries, apparently getline() failed on the entry after bao3 zhang4. Stepping into STL code was useless, since STL code was too difficult to figure out. </p>
<p>So I rewrote Dictionary::Dictionary() to use FILE and call MultiByteToWideChar() myself, and it worked fine, and it also seemed a lot faster than the IO stream version.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275153">
				<div id="div-comment-275153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Memet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275153">
			May 10, 2005 at 6:13 pm</a>		</div>

		<p>Yes, B.Y.</p>
<p> I agree that plain ReadFile, with API functions to translate encodings have always been almost an order of magnitude faster than the stream implementations of STL.</p>
<p> But then again, the complexity of the project increases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275163">
				<div id="div-comment-275163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Dunn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275163">
			May 10, 2005 at 6:24 pm</a>		</div>

		<p>Without doing any measurements (sorry Rico) I&#8217;d wager that the getline() is a big bottleneck.<br />
<br />A while ago I did something similar (line-by-line file reads) and I did it by inputting from a file into a stringstream. This was <em>incredibly</em> slow in some cases, and I figured out (after decrypting the STL source) that it was doing character-by-character appends to the string that the stringstream manages. This was causing a realloc on every character. UGH!<br />
<br />So I fixed it up by pre-calculating the length of each line and calling something like assign() (I forget what I did exactly) that takes a start/end point. That way there was just one string alloc per line.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275173">
				<div id="div-comment-275173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">C++ guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275173">
			May 10, 2005 at 6:42 pm</a>		</div>

		<p>Interesting topic.  I look forward to the next post.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275193">
				<div id="div-comment-275193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.dcelan-software.com' rel='external nofollow' class='url'>harry0418</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275193">
			May 10, 2005 at 7:19 pm</a>		</div>

		<p>There is a mob who have a CEDICT based dictionary available here: </p>
<p> <a rel="nofollow" target="_new" href="http://www.dcelan-software.com/chinese" rel="nofollow">http://www.dcelan-software.com/chinese</a></p>
<p>It is pretty cool.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275223">
				<div id="div-comment-275223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275223">
			May 10, 2005 at 9:49 pm</a>		</div>

		<p>Can&#8217;t compile this with MingW &#8211; Is wifstream part of standard C++?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275243">
				<div id="div-comment-275243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.mattryall.net' rel='external nofollow' class='url'>Matt Ryall</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275243">
			May 10, 2005 at 11:32 pm</a>		</div>

		<p>When you say you need a &quot;sanity check&quot;, Raymond, the need for unit tests for this code screams out at me. Why don&#8217;t you use CppUnit, or even just write a class yourself, to test the code? </p>
<p>As you&#8217;ve described in your sanity check, it&#8217;s easy to write a simple test for this. Run your startup code and verify that the output (or even the vector itself) has the correct number of lines. Surely this will be faster, more reliable, and more likely to be used than a manual test.</p>
<p>Regards,<br />
<br />Matt Ryall</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-275253">
				<div id="div-comment-275253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275253">
			May 10, 2005 at 11:47 pm</a>		</div>

		<p>If you want to write a CppUnit module, be my guest. But it would interrupt the flow of the article series. And writing a unit test to verify that the number of entries in the vector is correct seems like overkill for such a small program. Especially considering how long it would take to explain the unit testing framework &#8211; and of course people would then argue with my choice of unit testing framework. I just avoid the framework problem by writing raw Win32.</p>
<p>Remember people, this is a blog, not a book on software engineering.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275183">
				<div id="div-comment-275183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">C++ guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275183">
			May 10, 2005 at 6:45 pm</a>		</div>

		<p>You have load nearly every byte in the file into memory, so why not just load the whole into memory, into a big wchar_t buffer?  Then instead of wstrings in the dictionary entry, use pointers into the memory buffer.  So instead of:</p>
<p>wstring english;</p>
<p>Use<br />
<br />wchar_t* english_begin;<br />
<br />wchar_t* english_end;</p>
<p>This will reduce the code to nearly zero memory copies.</p>
<p>Maybe using a memory-mapped file would also help?  I dunno.  I&#8217;ve never used one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275263">
				<div id="div-comment-275263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene Hamilton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275263">
			May 11, 2005 at 2:06 am</a>		</div>

		<p>I am guessing he preprocesses the dict file and puts it in some sort of binary format.  No parsing needed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275273">
				<div id="div-comment-275273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Davy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275273">
			May 11, 2005 at 2:46 am</a>		</div>

		<p>I&#8217;m thinking the following would create a serious speedup:</p>
<p>&#8211; Read the file in chunks (read 2048 bytes)<br />
<br />&#8211; Then find the EOL for the current pos (append the chars to the chunk)<br />
<br />&#8211; Then prase the chunk (handle the eol in the memory)<br />
<br />&#8211; Loop this until last chunk</p>
<p>This will decrease the total diskreads(1 char at a time) and realocs(append 1 char at a time).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275303">
				<div id="div-comment-275303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">wojtek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275303">
			May 11, 2005 at 7:50 am</a>		</div>

		<p>I tried the same technique that Stuard, I memory mapped the file. Then converted to Unicode in one shot. I also played with data structure. Instead of wstring objects I tried good old wchar_t* pointers. During parsing I set these pointers to memory in Unicode buffer that I allocated anyway for MultiByteToWideChar call. I managed to come from around 700ms (original code) to ~30ms. Well, 700ms is my approximation, I also got only 1184 lines parsed by original code, as mentioned in previous posts but I didn&#8217;t bother to find out why. Maybe its VS60 fault? I bet Raymond did tested it as he writes:).<br />
<br />I also tried Stuard&#8217;s variant 1 and I got ~70ms.<br />
<br />For this size of file extra amount of memory needed isn&#8217;t that significant. I needed buffer exactly 1074434 bytes long for Unicode conversion, that&#8217;s not a big deal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275313">
				<div id="div-comment-275313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275313">
			May 11, 2005 at 7:59 am</a>		</div>

		<p>In Dictionary::Item(), instead if returning &quot;v[i]&quot;, you might consider &quot;v.at(i)&quot;.  The latter does range checking and throws an exception on an out-of-range error.  The former may return something (not anything useful) on an out of range index.  There is a slight performance hit, but the safety is usually worth it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-275323">
				<div id="div-comment-275323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275323">
			May 11, 2005 at 8:42 am</a>		</div>

		<p>I memory map lots of stuff in my apps. The facility is there and seems to bypass many potential sources of speed loss. You dont clutter the system page file allocating space for your app to get a copy of the data. If multiple instances of your app load up, the mapping is potentially shared.</p>
<p>You also avoid invoking ReadFile which is going to have multiple memory to memory copies (Im still not entirely clear on where Win32 keeps its disk cache, but suspect that memory mapped files avoid excercising that overly much too).</p>
<p>(Plus, memory mapping makes for efficient CE apps where your data files are in memory anyway and loading data the traditional way is explicitly wasteful).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-275293">
				<div id="div-comment-275293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stuart Dootson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-275293">
			May 11, 2005 at 4:10 am</a>		</div>

		<p>OK &#8211; so I tried my favourite strategy when presented with the challenge of optimising the parsing of a large text file &#8211; memory map it!</p>
<p>I tried three variants:</p>
<p>1. Map the file, but keep Raymonds DictionaryEntry::Parse method (i.e. allocate a string for each line on the fly).</p>
<p>2. As 1, but change DictionaryEntry::Parse to use a pair of pointers to define the line and use std::find rather than std::wstring::find (i.e. always operate on the converted file mapping).</p>
<p>3. As 2, but store pointer pairs instead of strings for each item in a DictionaryEntry. You obviously need to keep the converted file mapping (see below) allocated through the Dictionary life for this to work!</p>
<p>In all cases, I manually detect line endings by looking for either of &#8216;n&#8217; or &#8216;r&#8217;. Also, you need to create a wide-string equivalent of the file mapping by performing MultiByteToWideString on the whole file, which incurs a significant memory overhead compared to the std::wifstream approach.</p>
<p>As expected, improved performance was exhibited:</p>
<p>Original code: 575ms<br />
<br />Variant 1: 227ms<br />
<br />Variant 2: 199ms<br />
<br />Variant 3: 65ms</p>
<p>All timings are total elapsed times, averaged over 10 executions of the code. All code was compiled with VC++ 7.1 with a command line of &#8216;cl -EHsc -O2 &lt;filename&gt;&#8217;.</p>
<p>Conclusions?</p>
<p>1. I suspect calling MultiByteToWideString individually for each character in a file isn&#8217;t as time-efficient as calling it once for the whole file &#8211; what&#8217;s the per-invocation overhead of that function?<br />
<br />2. std::streams appear to add *a lot* of overhead, looking at the source.<br />
<br />3. Minimising the number of memory allocations/deallocations doesn&#8217;t hurt &#8211; what a surprise :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-276133">
				<div id="div-comment-276133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.interdictor.org' rel='external nofollow' class='url'>niven</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-276133">
			May 16, 2005 at 6:07 am</a>		</div>

		<p>MingW does seem to miss the wifstream definition. (Had the same problem with Dev-C++).</p>
<p>The Borland Cpp Builder compiles the program without problems (it is free and only an 8mb donwload)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405523">
				<div id="div-comment-405523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://w2k.fz.se/blog/?p=26' rel='external nofollow' class='url'>H??gerkonspiration &raquo; Genier i arbete: C# vs C++</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050510-55/?p=35673#comment-405523">
			August 2, 2006 at 7:11 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://w2k.fz.se/blog/?p=26" rel="nofollow">http://w2k.fz.se/blog/?p=26</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>