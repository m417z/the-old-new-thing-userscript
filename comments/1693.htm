<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1108483">
				<div id="div-comment-1108483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">parkrrrr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108483">
			February 21, 2014 at 7:13 am</a>		</div>

		<p>&quot;And there&#39;s a class of people who will see that you put a lot of work into protecting your assistant, and that will just convince them to work harder to circumvent the protection. Because something with this much protection must certainly be very valuable!&quot;</p>
<p>Alternatively, something with that many anti-debugging &quot;features&quot; must surely be doing something nefarious. Which is why, for example, I refuse to use a certain product even after Microsoft acquired it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108503">
				<div id="div-comment-1108503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108503">
			February 21, 2014 at 7:30 am</a>		</div>

		<p>An entertaining way is to check if the parent process is the master by looking at the image name of the parent process.</p>
<p>I don&#39;t use real anti-debugger these days so I can attach a debugger in production. I don&#39;t seem to mind debugging helper programs by attach to process. Otherwise they have nothing to do anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108533">
				<div id="div-comment-1108533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108533">
			February 21, 2014 at 8:08 am</a>		</div>

		<p>Why do the assistants have to run in separate processes?</p>
<p>Couldn&#39;t one just put the assistants in DLLs, either link them directly or LoadLibrary()/GetProcAddress() at runtime, and then run the assistants with CreateThread()?</p>
<p>(For debugging, &quot;master /debug-assistant AssistantFoo&quot;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108543">
				<div id="div-comment-1108543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lars Viklund</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108543">
			February 21, 2014 at 8:16 am</a>		</div>

		<p>Karellen: There are many benefits to the overhead of multiple processes.</p>
<p>On 32-bit platforms, you get more address space in total as it&#39;s per-process.</p>
<p>Crashing or relatively untrusted code only ruin things for itself.</p>
<p>You cut down on things like heap fragmentation and resource exhaustion in your long-running master as a separate process has perfect cleanup of its resources.</p>
<p>You can elevate child processes and not have to care about your master running in an escalated world.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108553">
				<div id="div-comment-1108553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108553">
			February 21, 2014 at 8:17 am</a>		</div>

		<p>@Karellen:</p>
<p>1: Loading a 32 bit DLL to call from a 64 bit process.</p>
<p>2: Containing a component that is not trusted to not corrupt process&#39;s memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108563">
				<div id="div-comment-1108563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108563">
			February 21, 2014 at 8:19 am</a>		</div>

		<p>@Karellen That is one approach, but there are merits to using separate processes. &nbsp;For example, Google around and you can find lists of reasons why Chrome does it this one. &nbsp;(Off the top of my head: if the assistant program crashes, the entire program doesn&#39;t crash. &nbsp;The assistant program can be given less security permissions and thus if it is hacked the consequences are limited. &nbsp;It is easier to measure individual memory and CPU consumption by the user for different aspects of your program (although shared memory blocks, which you&#39;d want to use to avoid extra memory consumption as much as possible, muddle the waters a bit).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108593">
				<div id="div-comment-1108593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108593">
			February 21, 2014 at 9:03 am</a>		</div>

		<p>Also, sometimes you just don&#39;t want to spend the effort to turn a standalone program into a DLL plugin. For example, OpenSSH â€” it&#39;s one thing if you ship your product together with ssh.exe (and fifty megabytes of Cygwin libraries), and another if you take the sources and try to compile-and-link them into your solution. Given how capricious Cygwin is, that&#39;s not really worth the effort. Just read to/write from the pipe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108603">
				<div id="div-comment-1108603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108603">
			February 21, 2014 at 9:13 am</a>		</div>

		<p>@Joker_vD But if you&#39;re shipping a standalone program that is designed to be run on its own, why do you care if the user runs it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108623">
				<div id="div-comment-1108623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108623">
			February 21, 2014 at 9:57 am</a>		</div>

		<p>Often because the login credentials are located in the parent process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1108633">
				<div id="div-comment-1108633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108633">
			February 21, 2014 at 10:00 am</a>		</div>

		<p>&quot;Why do the assistants have to run in separate processes?&quot;</p>
<p>I do it for 4 main reasons, some mentioned before: </p>
<p>&#8230;more address space&#8230;</p>
<p>&#8230;Crashing or relatively untrusted code&#8230;</p>
<p>&#8230;resource exhaustion&#8230;</p>
<p>The thing that I put in a separate process is a third party component that is known to be crash prone, memory leak prone, loads hundreds of DLLs, and is not thread-safe. &nbsp;So we get safe parallelism using multi-process instead of multithreading. &nbsp;Since the component is converting a file from one format to another, it&#39;s perfectly suited for this. &nbsp;Yes, there is some I/O contention, but it&#39;s still a lot faster, especially on some of the machines we run on (dual quad core </p>
<p>hyperthreaded, for 16 parallel processes).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108683">
				<div id="div-comment-1108683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108683">
			February 21, 2014 at 10:36 am</a>		</div>

		<p>@Karellen</p>
<p>Where I work, we do it because our main legacy product is written in a language using a framework that isn&#39;t easily interoperable with newer technologies.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108693">
				<div id="div-comment-1108693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jcs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108693">
			February 21, 2014 at 12:47 pm</a>		</div>

		<p>That trick is as old as MS-DOS itself; having been commonly used in DOS games in the 80s and 90s. I assume it&#39;s because different parts of the game were written in different languages, or by different development teams.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108703">
				<div id="div-comment-1108703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nicholas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108703">
			February 21, 2014 at 12:49 pm</a>		</div>

		<p>@Karellen</p>
<p>Sometimes 32-bit is all you need. &nbsp;Going 64-bit is not a clear cut decision. &nbsp;The following article, by the awesome Rico Mariani, explains the pros and cons:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/ricom/archive/2009/06/10/visual-studio-why-is-there-no-64-bit-version.aspx">blogs.msdn.com/&#8230;/visual-studio-why-is-there-no-64-bit-version.aspx</a></p>
<p>Developing 32-bit applications in a 64-bit environment seems to be a good balance. &nbsp;Also, going 64-bit puts you in a different universe where the development tactics that you know may not apply very well. &nbsp;Are you suggesting that it is worth going to 64-bit just so you can allocate a 7 GB array and call qsort on it? &nbsp;When you are dealing with big data your tactics and techniques change drastically, so bit-ness may not be the big factor here. &nbsp;Sure, if you are SQL Server then of course you are going to be 64-bit. &nbsp;For the average program, 32-bit is sufficient.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-john-ludlow odd alt thread-odd thread-alt depth-1" id="comment-1108713">
				<div id="div-comment-1108713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/John+Ludlow' rel='external nofollow' class='url'>John Ludlow</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108713">
			February 21, 2014 at 1:45 pm</a>		</div>

		<p>incompatibility between languages and architectures is definitely one reason to have separate processes. Other considerations may relate to how processes are allocated time on the CPU or how they can reserve memory. Even how many threads a process can reasonably have might be an issue.</p>
<p>Another reason I&#39;ve seen is simple compartmentalisation. We have a server process which consists of a manager service which invokes several child processes. Each child process has a relatively simple, well-defined job, and having them separated means it&#39;s much easier to distribute the components across different machines or set up configurations where only some of the components are installed. It also means that those components can be developed independently (or at least, more independently) of each other.</p>
<p>In response to the general concept, we also do something similar where an installer must be run by its bootstrapper, though in that case, rather than check to see if the parent process passed a flag, we check to see if certain properties of the environment match what we expect (in particular, is the process elevated?).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108723">
				<div id="div-comment-1108723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Graham</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108723">
			February 21, 2014 at 1:54 pm</a>		</div>

		<p>The official recommendation from Microsoft is that if you need to make MAPI calls as another user, you shouldn&#39;t impersonate the current user in a different thread, but kick off a separate process as that user. I think Raymond has also mentioned that running any kind of COM under impersonation is a bit risky, since you&#39;re relying on everything knowing how to handle the impersonation. If you run things as a separate process under a different user id, all those issues go away.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108733">
				<div id="div-comment-1108733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108733">
			February 21, 2014 at 2:33 pm</a>		</div>

		<p>@Nicholas:</p>
<p>The question is, sufficient for how long.</p>
<p>I am not the kind of person to agree with the whole idea of sometimes 32 bits is enough because that can cause the wrong kind of mind set. &quot;Why progress when what we have is enough&quot;.</p>
<p>Sure, stability is good, and changing for the sake of it is bad, but that is no reason to stick to the lowest common denominator if you can take advantage of more.</p>
<p>This can help future proof if the dataset of your application isn&#39;t defined, also it gives you access to things on the processor that you wouldn&#39;t have in 32 bit mode.</p>
<p>So I would say even the thing of &quot;sometimes 32 bit is enough&quot; itself is not clear cut. Take video players and web browsers, there was a time that it was felt that 32 bits was enough for that, some people think that. But I know people who like to keep as many tabs open as possible and have had a 32 bit browser run out of address space. Not to mention browsers themselves are getting a lot more complex. Video playback is going through that kind of thing too, 1080p encodes can be rather large, but the next step is towards 2k and 4k. </p>
<p>So you can never tell if a &quot;this is enough&quot; will suddenly one day be not enough.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1108743">
				<div id="div-comment-1108743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108743">
			February 21, 2014 at 3:03 pm</a>		</div>

		<p>My assistant programs do not perform safety checks because without a master to send them the data that they need to do what they do, they exit gracefully.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108753">
				<div id="div-comment-1108753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108753">
			February 21, 2014 at 5:05 pm</a>		</div>

		<p>@Crescens2k </p>
<p>There is a real cost in terms of performance and memory to go 64 bit. This is why there&#39;s now an x32 ABI for Linux and why things like ARM THUMB exist.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108673">
				<div id="div-comment-1108673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108673">
			February 21, 2014 at 10:32 am</a>		</div>

		<p>Ah yes, running your assistant in a sandbox. That does make sense &#8211; thanks everyone who suggested it.</p>
<p>Everyone stuck with 32-bit code and the problems it comes with, my deepest sympathies. To think, in this day and age, that some people still argue *against* using 64-bit code whereever possible!</p>
<p>As for isolating (poorly written?) 3rd party components, I got the impression that the article was discussing the case where the &quot;master&quot; and &quot;assistants&quot; were not just developed by the same team, but were all part of a single development effort. Which part of the article are people reading that encompasses 3rd party assistants?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1108773">
				<div id="div-comment-1108773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108773">
			February 21, 2014 at 7:33 pm</a>		</div>

		<p>&quot;As for isolating (poorly written?) 3rd party components, I got the impression that the article was discussing the case where the &quot;master&quot; and &quot;assistants&quot; were not just developed by the same team, but were all part of a single development effort. Which part of the article are people reading that encompasses 3rd party assistants?&quot;</p>
<p>My master and assistant are developed by the same team and are part of a single development effort. &nbsp;The assistant uses the third party component that has those problems. &nbsp;The third party component isn&#39;t a stand-alone exe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1108783">
				<div id="div-comment-1108783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108783">
			February 21, 2014 at 7:37 pm</a>		</div>

		<p>The running 32 bit code from a 64 bit process also pops up here, as I have occasion to call an older version of the assistant that was only developed as 32 bit (predated our move to 64 bit).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108793">
				<div id="div-comment-1108793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108793">
			February 21, 2014 at 7:37 pm</a>		</div>

		<p>@jcs:</p>
<p>&gt; That trick is as old as MS-DOS itself; having been commonly used in DOS games in the 80s and 90s. I assume it&#39;s because different parts of the game were written in different languages, or by different development teams.</p>
<p>In many cases, it&#39;s actually because machines at the time didn&#39;t have the resources to handle the entire game at once.</p>
<p>As an example, the original X-Com had two different executables &#8211; one for the tactical missions, and one for the strategic overworld. When you started a mission, the overworld executable would write the state of the game to a file, start the tactical executable, and then exit, leaving all the resources of the machine available to the tactical executable. When you finished the mission, the tactical executable would write the results of the mission into the save file and then restart the overworld.</p>
<p>Think of it as a high-level version of paging code in and out of memory as required.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108803">
				<div id="div-comment-1108803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108803">
			February 22, 2014 at 2:57 am</a>		</div>

		<p>A related use mode: the &quot;assistant&quot; process may not even run on the same computer. This is how one of our scientific computing programs works, there&#39;s a 32 bit GUI front end for viewing the data, and a solver executable that does the real computing. It&#39;s split so that the solver can run on clusters, can be a 32 or 64 bit version, run on other operating systems, and requires no GUI and a minimum amount of shared libraries (which is important on clusters).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108813">
				<div id="div-comment-1108813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108813">
			February 22, 2014 at 4:56 am</a>		</div>

		<p>@Karellen: I still think the proper way is &quot;compile as 32 bits, and don&#39;t bother with 64 bits unless really needed&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108833">
				<div id="div-comment-1108833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108833">
			February 22, 2014 at 9:20 am</a>		</div>

		<p>@Jon:</p>
<p>The converse is also true.</p>
<p>For a 32 bit process to run on a 64 bit system, it has to go through an emulation layer, this is not free.</p>
<p>For Windows this means for system calls, it goes through the 32 bit ntdll, this repackages it to 64 and then calls into the 64 bit ntdll to do the actual system call. Don&#39;t forget that on 64 bit systems, 32 bit processes also have to have two stacks and load more libraries. This also changes the semantics of some things too, like exceptions.</p>
<p>Another thing to remember is that while in 64 bit mode, the processor has access to double the amount of registers compared to 32 bit mode. So while there is a higher memory cost, register contention is usually lower and so code has to store things temporarily to the stack less. This is becoming more and more true with each compiler release as the x64 code generation is becoming better. So you can&#39;t just stick to one architecture unless the other is really needed, as you can never know the actual performance differences unless you really test.</p>
<p>@Azarien:</p>
<p>I will always think that the proper way is to check the requirements, and do lots of testing to decide which way to go. Lower register contention and 64 bit registers/instructions may be more desirable without the larger address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108843">
				<div id="div-comment-1108843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108843">
			February 22, 2014 at 9:56 am</a>		</div>

		<p>@Jon,</p>
<p>ARM Thumb does not affect the word length of the CPU. ARM instructions are encoded in either 16 or 32 bits, with Thumb (roughly) being the instruction subset that is encoded in 16 bits. The smaller ARM processors, like the M0, can only process these instructions, while larger models process both the 16 bit and 32 bit ones. Even 16 bit Thumb instructions operate on 32 bit values and registers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108853">
				<div id="div-comment-1108853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108853">
			February 22, 2014 at 10:56 am</a>		</div>

		<p>@Crescens2k: the requirements are usually &quot;must work&quot;, and that includes 32-bit Windows machines. Performance comes second.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108863">
				<div id="div-comment-1108863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108863">
			February 22, 2014 at 1:06 pm</a>		</div>

		<p>In my experience the additional memory pressure for 64-bit is generally evened out by the additional instructions and registers that it doesn&#39;t make any noticeable difference performance wise (on the other hand there are some programs that benefit immensely from 64bit mode even when not using more memory). </p>
<p>Managed code is rather interesting in that regard, since it can get the benefit of more memory (32gb only though), the additional registers and instructions without the increase memory pressure at the rather small cost of a few extra instructions for memory access. Does the CLR do that optimization too or are JVMs the only ones doing that?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108873">
				<div id="div-comment-1108873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108873">
			February 22, 2014 at 4:58 pm</a>		</div>

		<p>@j b: But the performance aspects are similar. In THUMB you gain with the smaller instruction length at the expense of having more instructions to do certain operations. In x64, the register and memory enhancements come at the expense of lower code density. In a way, THUMB is sort of rolling back some of the RISC aspects for the architecture. (And let&#39;s not get started about VLIW)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108893">
				<div id="div-comment-1108893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108893">
			February 23, 2014 at 7:33 am</a>		</div>

		<p>@Jon,</p>
<p>Certainly, for some operations, there are (non-Thumb) 32-bit ARM instructions doing in one instruction what would require two or more Thumb-instructions. For performance judgements, an important question is how often you really use those fancy instructions. Not very often. The ARM designers did a very good job in the dynamic analysis of actual code, selecting the ones to become 16-bit Thumb codes as those executed very frequently. If one out of a hundred instructions actually executed is one which would require more than one thumb instruction, it has very little effect on the total performance. (The 32-bit ARM instructions are not THAT complex!) One per hundred is a quite realistic figure in a lot of code. Obviously, there are cases that differ, but unless the CPU provides really complex operations that you would otherwise find aa a source code function (say, hyperbolic functioons) as single-instruction codes (ARM doesn&#39;t), you might be surprised by how large a percentage of actually executed instructions are Thumb instructions that couldn&#39;t be replaced by fewer 32-bit ARM instructions.</p>
<p>There is a cost to the 32-bit instructions, too: They frequently do not complete in one clock cycle (as almost all the Thumb instructions do), they put a higher load on the memory bus etc. So before jumping to the conclusion that going all 32-bit is faster (obviously: At the same clock frequency), you must add these costs.</p>
<p>Too often, you see comparisons of several alternatives, each in its own environment different from the others, and the conclusion for the SYSTEMS is applied to one selected component (such as the CPU). Full 32 bit (non-Thumb) ARM CPUs commonly run at higher frequencies, with faster memory/bus technologies, possibly with cache &#8211; faster by (system) design, not (primarily) by providing more complex instructions. Fortunately, all full 32 bit ARM processors can run Thumb code without recompilation, so if you want to do a fair comparison, you should run the Thumb code, and then the same source code complied for 32 bits non-Thunb code, on exactly the same hardware and system software. I haven&#39;t tried it myself (I don&#39;t have access to any great selction of ARM processors!), still I would be surprised if the performance improvement was more than a few percent. I would be less surprised if you could get even better performance by using a small Thumb CPU (say, an M0) and crank up the clock frequency a little, and still be way below the larger ARM CPUs in power consumption. True: All ARM processors have a very nice performance/power ratio, but they really excel in the lower range. Unless you need other 32-bit features, memory mangement, more complex interrupt handling etc., you may often be well served by one of the smaller Thumb-only CPUs even if you have to increase the clock frequency to reach the same performance. It still might save you power (if that is essential in your application).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1108903">
				<div id="div-comment-1108903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108903">
			February 23, 2014 at 8:06 am</a>		</div>

		<p>&quot;Why are people thinking that their software should be written to be compiled as 32-bit OR 64-bit?</p>
<p>Your software should compile as 32-bit AND 64-bit, with nothing more than the flick of a compiler switch.&quot;</p>
<p>Absolutely. &nbsp;We build, install, and test the 32 bit and 64 bit versions every night, and publish both to our end users for every release.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108883">
				<div id="div-comment-1108883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108883">
			February 23, 2014 at 3:07 am</a>		</div>

		<p>Why are people thinking that their software should be written to be compiled as 32-bit OR 64-bit?</p>
<p>Your software should compile as 32-bit AND 64-bit, with nothing more than the flick of a compiler switch.</p>
<p>Then you can use either, depending on your use cases. So for example, if you find that you are running out of address space or hitting some other problem because of the 32-bit-ness of one binary, you can just use the 64-bit version instead.</p>
<p>If you&#39;re worried about performance issues and think that 32- or 64-bit might be significantly better than the other for your specific use case, the only way to tell is &#8211; as always &#8211; to do both and *actually measure the performance* so you can compare real numbers. And to do that, you have to build both anyway.</p>
<div class="post">[<em>It also doubles the testing load. (Or quadruples if you want a 64-bit master to work with a 32-bit assistant.) If you are writing an in-house application, you probably have barely enough resources to test one version, much less two. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108913">
				<div id="div-comment-1108913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108913">
			February 23, 2014 at 4:39 pm</a>		</div>

		<p>64 bit code is faster, so it&#39;s definitely worth using it if you need your program to go as fast as possible.</p>
<p>The only way to make sure your code is run in the way you intend, is to make sure you don&#39;t let anyone else install it. You would have to supply it on a seriously locked down machine though, or just don&#39;t let anyone run it.</p>
<p>Trying to get your code to check who runs it would be like warning your staff not to accept new counterfeit bills that are indistinguishable from the real thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108923">
				<div id="div-comment-1108923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Magnus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108923">
			February 23, 2014 at 5:11 pm</a>		</div>

		<p>As well as digging through Program Files and finding programmes there, with the new Task Bar in Windows 7 it is far too easy to start a separate invocation of a programme.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108933">
				<div id="div-comment-1108933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">immibis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108933">
			February 23, 2014 at 6:05 pm</a>		</div>

		<p>@smf: see the second paragraph of the post.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108943">
				<div id="div-comment-1108943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108943">
			February 24, 2014 at 2:52 am</a>		</div>

		<p>@Azarien:</p>
<p>From my first post in these comments</p>
<p>&quot;Sure, stability is good, and changing for the sake of it is bad, but that is no reason to stick to the lowest common denominator if you can take advantage of more.&quot;</p>
<p>Sure getting it to work on 32 bit systems is important, but why would that stop you from taking advantage of the 64 bit system? Also what about Windows Server core or Window PE environments where the WoW64 subsystem isn&#39;t available by default. More and more companies are releasing multiple builds of their applications which you can choose between or even install side by side. You can detect processor capabilities at runtime, so why not take advantage of that fact.</p>
<p>One really awesome bit of software I would like to shine the spotlight on here is Process Explorer. It takes advantage of the fact that the average system is capable of running 32 bit code. Detects the processor, and if it finds that it is a 64 bit system, it will save the 64 bit binary which is stored as a resource. It will then re-launch itself using the 64 bit binary.</p>
<p>So I am all for using the system as much as possible, I am also for actual performance testing to see if there are possible gains.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1108953">
				<div id="div-comment-1108953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marc K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108953">
			February 24, 2014 at 5:26 am</a>		</div>

		<p>@Crescens2k:</p>
<p>I don&#39;t like the method Process Explorer uses. &nbsp;When they first implemented this, the size of the executable doubled. &nbsp;And then you have both the original 32-bit and the 64-bit running in memory. &nbsp;The 64-bit version also needs to be extracted to a user-writable area of the system. &nbsp;So, that executable is not properly secured.</p>
<p>I&#39;d rather they just package separate exes in the zip file and have the the 32-bit version launch the 64-bit version if a 64-bit OS is detected.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1108973">
				<div id="div-comment-1108973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1108973">
			February 24, 2014 at 6:24 am</a>		</div>

		<p>Well, I was using that as an example of how easy it is to detect these things, not about the layout itself.</p>
<p>Mental note, disclaimers would avoid this kind of situation where things I find obvious aren&#39;t to other people, or context is lost on people.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1109033">
				<div id="div-comment-1109033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1109033">
			February 24, 2014 at 9:19 am</a>		</div>

		<p>Had to do exactly this two years ago. My solution was to:</p>
<p>1) Pass an integer argument to the child process</p>
<p>2) The child process would use the integer to create a name and use it as the base for a shared memory queue and a shared memory settings block.</p>
<p>3) The child process would find parent and put a wait on the process handle (to ensure they shut down when the parent was abruptly terminated.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1109223">
				<div id="div-comment-1109223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140221-00/?p=1693#comment-1109223">
			February 26, 2014 at 4:37 am</a>		</div>

		<p>@immibis &nbsp; </p>
<p>I read it and understood it, I was just restating the issue.</p>
<p>No matter what you do to try and stop executable b from running unless it&#39;s called from executable a, someone else can take executable a and extract your magic incantation. Everything you can do to verify that you were started by executable a can be impersonated. As soon as your executable is able to be run on a computer you do not control then expect that it can be compromised.</p>
<p>You can protect against the user accidentally clicking on executable b, but that doesn&#39;t answer the &quot;How can I make sure my program is launched only from my helper program and no other parent?&quot;. Because &quot;only from my helper program&quot; means in no circumstance at all, ever, no matter what the person does because &quot;I&quot; can&#39;t cope with the terrible consequences that will happen if anyone is ever able to do that (like I&#39;ll lose my job/money/life etc).</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>