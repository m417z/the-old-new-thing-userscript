<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-302453">
				<div id="div-comment-302453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302453">
			September 1, 2005 at 12:12 pm</a>		</div>

		<p>I looked at the documentation for these two functions. RegQueryValueEx only says the buffer is in an undefined state if the buffer isn&#8217;t large enough. For all other cases I&#8217;d assume the buffer/key are good if the return value is ok or untouched if the return value is bad. I&#8217;d imagine other programmers would think the same thing since all other sane documentation works that way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-302463">
				<div id="div-comment-302463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302463">
			September 1, 2005 at 12:25 pm</a>		</div>

		<p>The &quot;output buffers are guaranteed unmodified on failure&quot; model means that all output parameters have to be double-buffered, which can be quite expensive for large buffers and tedious even if the buffers are small. For example, a function that computes a string can&#8217;t build the string directly into the output buffer; it has to build it in a separate buffer, and then only when everything is successful (including determining whether the buffer is big enough) copy the result into the output buffer. Do you write your functions this way?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302473">
				<div id="div-comment-302473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pmuhC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302473">
			September 1, 2005 at 12:27 pm</a>		</div>

		<p>Be paranoid about the returns from <em>any</em> call if the documentation for the call is not explicit about every eventuality.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302483">
				<div id="div-comment-302483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302483">
			September 1, 2005 at 12:55 pm</a>		</div>

		<p>It depends on the function. But exact cases where the buffer is undefined does get documented as I would expect MSDN to do. Take the RegQueryValueEx function, it explicitly says the buffer is undefined when the ERROR_MORE_DATA return code is returned. That to me implies the function either fills the buffer correctly or doesn&#8217;t touch it in all other cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302493">
				<div id="div-comment-302493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302493">
			September 1, 2005 at 1:11 pm</a>		</div>

		<p>&quot;For example, a function that computes a string can&#8217;t build the string directly into the output buffer; it has to build it in a separate buffer, and then only when everything is successful (including determining whether the buffer is big enough) copy the result into the output buffer.&quot;</p>
<p>The ideal order of thing is:<br />
<br />1. determine whether you can deliver all requested data<br />
<br />2. If so, start producing it. Because of step 1, this can happen directly into the output buffer.</p>
<p>&quot;Do you write your functions this way?&quot;</p>
<p>If robustness of an API has enough priority: yes. Doing this correctly also affects ease of use for the programmer, and sometimes for the user. Overall, the investment in getting a function really robust may pay out.</p>
<p>As an extreme example, a function to copy a file should make every effort to ensure that it can perform the requested task before copying the first byte.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-302503">
				<div id="div-comment-302503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302503">
			September 1, 2005 at 1:19 pm</a>		</div>

		<p>&quot;Determine whether you can deliver all requested data&quot;.  This is the hard part. Often you can&#8217;t tell until you actually try, and then you&#8217;re stuck having to remember the result of the attempt somewhere. Why not store it in the output buffer since that&#8217;s where you were going to put it anyway?</p>
<p>For example, SHGetFileInfo receives flags specifying what items the caller wishes to retrieve. If the caller asks for two things (e.g., the icon and the display name), do you get the icon first and save it &quot;off to the side&quot; while you get the second &#8211; and only if both things work do you put the answer in the output buffer? You can&#8217;t determine whether you can get the icon until you actually get it, because there&#8217;s always the possibility of an &quot;out of memory&quot; error just as you call ExtractIcon.</p>
<p>(File copying is a change of topic. I&#8217;m talking about output buffers on failure not changes to storage.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302513">
				<div id="div-comment-302513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302513">
			September 1, 2005 at 1:53 pm</a>		</div>

		<p>I often catch myself getting the registry&#8217;s key/value terminology wrong even though I know better. The problem is that I tend to use the word &quot;key&quot; to describe the left-hand part of a (key, value) pair. The value (obviously) is the value.</p>
<p>Unfortunately the registry is not a map structure. It&#8217;s a tree of map structures. For some reason someone decided that each of these map structures should be called a key. So what do we call the left hand part of the (key, value) pair? The best name I&#8217;ve come up with so far is &quot;the value name&quot;. It would have been far better to call the map structures &quot;folders&quot;, especially since the standard registry editor visually represents them that way.</p>
<p>I do have a theory about why it ended up this way, though. Windows 3.1 (and probably earlier versions; I was still in Amiga land at that point) had a much more stunted registry whose purpose was to store the file extension mappings and presumably also the OLE stuff. From what I remember that old registry only stored one value for each point in the tree, so rather than a tree of map structures it was a heirarchical map structure. Under this scheme the name &quot;key&quot; makes sense. As I understand it, the old singleton value lives on in and beyond as the &quot;(Default)&quot; entry in the registry editor, still used all over the HKEY_CLASSES_ROOT key presumably for reasons of backwards compatibility. I also assume that this is the reason for the rather awkward schema adopted in that area, where three different kinds of thing are all shoved in at the top level and distinguished only by naming convention.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302523">
				<div id="div-comment-302523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302523">
			September 1, 2005 at 1:57 pm</a>		</div>

		<p>&quot;As an extreme example, a function to copy a file should make every effort to ensure that it can perform the requested task before copying the first byte.&quot;</p>
<p>The problem with that philosphy is that the answer can change between the time you do your pre-verification and the time you do the actual operation.  It&#8217;s simpler and better, IMHO, to do only minimum sanity testing and handle errors occuring in the actual operation as you go &#8211; which you have to do anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302533">
				<div id="div-comment-302533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302533">
			September 1, 2005 at 2:04 pm</a>		</div>

		<p>raymond wrote:  &quot;For example, a function that computes a string can&#8217;t build the string directly into the output buffer; it has to build it in a separate buffer, and then only when everything is successful (including determining whether the buffer is big enough) copy the result into the output buffer. Do you write your functions this way?&quot;</p>
<p>While I agree that the caller shouldn&#8217;t expect the buffer to be untouched upon error, it seems reasonable to avoid undefined outcomes.  So if building the string fails, it should do something reasonable to the buffer like setting it to a properly terminated empty string in addition to returning the appropriate error code.</p>
<p>A similar problem exists with GetLastError.  Some functions that purport to return additional failure information via GetLastError don&#8217;t actually update the error code in all cases.  Thus, occasionally, you have to use SetLastError to something your recognize (e.g., 0) before calling the unreliable function.</p>
<p>Chapters 5 and 6 of <em>Writing Solid Code</em> by Steve Maguire (Microsoft Press) recommend avoiding undefined behaviors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302553">
				<div id="div-comment-302553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302553">
			September 1, 2005 at 2:59 pm</a>		</div>

		<p>I think 10 or more years ago you could rely on your documentation omitting details because it should be obvious why you wouldn&#8217;t want to things that way.  These days, however, the programmer audience is more diverse and the machines are more complex and more forgiving (if you do something inefficiently, are you ever going to notice?).  No, these days if you have such a diverse audience like the Windows platform you have to spell out everything or you&#8217;ll suffer in the long run.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302563">
				<div id="div-comment-302563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302563">
			September 1, 2005 at 3:24 pm</a>		</div>

		<p>Why not improve the documentation?</p>
<p>For any function that takes an output parameter as an argument, it should clearly specify what happens to it on failure:<br />
<br />A. Leaves it untouched.<br />
<br />B. Initializes it to some value.<br />
<br />C. Unspecified.</p>
<p>Don&#8217;t let people assume.</p>
<p>Furthermore, better documenting the function&#8217;s contract is better for both sides of the fence: anyone modifying that function&#8217;s internals are given a clear requirement on how the function needs to behave to the outside world.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302583">
				<div id="div-comment-302583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.foxyshadis.com' rel='external nofollow' class='url'>foxyshadis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302583">
			September 1, 2005 at 3:31 pm</a>		</div>

		<p>Ben: Thanks, I never knew that. I&#8217;d always wondered why the stuff in HKCR seemed so inefficiently built with only one value per key.</p>
<p>Also, regedit itself calls them value name and value data, so you&#8217;re in good company.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-302593">
				<div id="div-comment-302593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302593">
			September 1, 2005 at 3:36 pm</a>		</div>

		<p>I am but one person. To update all the documentation myself would take years.</p>
<p>At what point does one finally decide to leave things unsaid? Should every function also say &quot;All pointers must point to valid memory; otherwise the behavior is undefined&quot;? How about &quot;If you pass the wrong number of parameters to this function, the behavior is undefined.&quot; Or &quot;Do not use memory after freeing it.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302603">
				<div id="div-comment-302603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302603">
			September 1, 2005 at 3:49 pm</a>		</div>

		<p>Fatal Error: The operation completed successfully.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302613">
				<div id="div-comment-302613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302613">
			September 1, 2005 at 4:00 pm</a>		</div>

		<p>&quot;Should every function also say &quot;All pointers must point to valid memory; otherwise the behavior is undefined&quot;? How about &quot;If you pass the wrong number of parameters to this function, the behavior is undefined.&quot; Or &quot;Do not use memory after freeing it.&quot;&quot;<br />
<br />Saying something for every function is easy, you could just write it once and get docs for all functions to include it, not that I&#8217;m suggesting you write this sort of stuff of course</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302623">
				<div id="div-comment-302623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302623">
			September 1, 2005 at 4:09 pm</a>		</div>

		<p>Ben: I got that one too once</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-302663">
				<div id="div-comment-302663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302663">
			September 1, 2005 at 5:13 pm</a>		</div>

		<p>Ivan: Would a single &quot;Ground rules for documentation&quot; page suffice? Or does every page have to have an explicit link to the &quot;ground rules&quot; page?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302673">
				<div id="div-comment-302673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302673">
			September 1, 2005 at 5:28 pm</a>		</div>

		<p>In a great many cases (especially anything involving hardware access) race conditionsmean that you can never be absolutely certain that an operation will succeed before you start. You should check if it&#8217;s definately impossible (assuming that&#8217;s achievable) but you should never rely on operations being guranteed to succeed.</p>
<p>Assumption is the mother of all subtle access violations waiting for an unlikely series of events to occur when you demo the software to a major potential customer before it occurs for the first time.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com000300008195987d even thread-even depth-1" id="comment-302683">
				<div id="div-comment-302683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Spire' rel='external nofollow' class='url'>Spire</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302683">
			September 1, 2005 at 6:54 pm</a>		</div>

		<p>I think it would be best if every page had an explicit &#8212; and prominent &#8212; link to the  &quot;ground rules&quot; page.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302693">
				<div id="div-comment-302693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302693">
			September 1, 2005 at 8:10 pm</a>		</div>

		<p>Thursday, September 01, 2005 1:57 PM by Mike<br />
<br />[quoting Reinder]<br />
<br />&gt;&gt; &quot;As an extreme example, a function to copy<br />
<br />&gt;&gt; a file should make every effort to ensure<br />
<br />&gt;&gt; that it can perform the requested task<br />
<br />&gt;&gt; before copying the first byte.&quot;<br />
<br />&gt;<br />
<br />&gt; The problem with that philosphy is that the<br />
<br />&gt; answer can change between the time you do<br />
<br />&gt; your pre-verification and the time you do<br />
<br />&gt; the actual operation.</p>
<p>That&#8217;s exactly why Reinder said &quot;every effort&quot; even though it&#8217;s not perfect.  Suppose you want to copy a directory and all its subdirectories etc. onto an external hard drive for backup, Windows Explorer sits there for a while preparing, Windows Explorer can compute that this is 2.53 GB of files and the destination drive has 2.51 GB of free space, wouldn&#8217;t you want to be informed that the only way this is going to succeed is not only for the answer to change between the time of preparation and time of completion, but in fact it depends on some very lucky kinds of changes?</p>
<p>Yes you do have to continue doing stringent error checking at every stage, exactly as you said, but advance notification has a purpose.</p>
<p>Thursday, September 01, 2005 2:04 PM by Adrian<br />
<br />&gt; A similar problem exists with GetLastError.<br />
<br />&gt; Some functions that purport to return<br />
<br />&gt; additional failure information via<br />
<br />&gt; GetLastError don&#8217;t actually update the error<br />
<br />&gt; code in all cases. Thus, occasionally, you<br />
<br />&gt; have to use SetLastError to something your<br />
<br />&gt; recognize (e.g., 0) before calling the<br />
<br />&gt; unreliable function.</p>
<p>Well yes and no.  When LoadImage() fails, sometimes it returns a return value of 0 (failure) and GetLastError() returns 0 (ERROR_SUCCESS).  I didn&#8217;t check if this could be solved by calling SetLastError to something other than 0 before calling LoadImage, but if it can be, 0 isn&#8217;t a useful value to use.</p>
<p>Thursday, September 01, 2005 3:36 PM by oldnewthing<br />
<br />&gt; I am but one person. To update all the<br />
<br />&gt; documentation myself would take years.</p>
<p>Of course.  I understand that&#8217;s why you no longer solicit bug reports about MSDN pages.  But as your base note here shows, you remember why it&#8217;s important for the spec to be reliable.  (After all you can&#8217;t expect users to rely on an unreliable spec, at least not for long.  Besides, think of how much more appcompat work you&#8217;ll get to do if they do.)</p>
<p>So PLEASE persuade your colleagues in the MSDN arena that they should act on bug reports.  It isn&#8217;t enough to send a reply saying that MSDN content is acquired by MSDN.  Get the specs fixed, maybe with a timeframe of less than a year.</p>
<p>Also PLEASE persuade your colleagues who aren&#8217;t in the MSDN arena that, even though they&#8217;re not responsible for fixing MSDN, that doesn&#8217;t mean they should post publicly that MSDN bugs don&#8217;t need fixing.  They should learn that MSDN bugs DO need fixing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302703">
				<div id="div-comment-302703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mihai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302703">
			September 1, 2005 at 8:13 pm</a>		</div>

		<p>I usualy try to accomplish the following (in the  order listed):<br />
<br />&#8211; Strong guarantee<br />
<br />&#8211; NoThrow guarantee<br />
<br />&#8211; Basic guarantee<br />
<br />I know that Windows precedes these concepts, but this is something that was intuitively followed by many programmers for a long time.</p>
<p>I also realize that a big buffer cannot be preserved. But for &quot;cheap&quot; object (like a HANDLE, which is usualy an int) I kind of expect to be preserved. Especially from an OS, which is supposed to be way more reliable than a game, or browser, or whatever.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302713">
				<div id="div-comment-302713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mihai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302713">
			September 1, 2005 at 8:31 pm</a>		</div>

		<p>It seems like the discution moves towards MSDN. </p>
<p>Guys, it seems you never tried to use the Mac OS documentation. Same functionality provided by 4-5 functions, all but one being obsolete. But this is not documented, you need someone who was a long time Mac programmer to tell you which one is the new one.<br />
<br />You can read some of my Mac adventures here <a rel="nofollow" target="_new" href="http://www.mihai-nita.net/m200506.shtml" rel="nofollow">http://www.mihai-nita.net/m200506.shtml</a></p>
<p>I don&#8217;t say the MSDN doc is perfect, or that I would not like to see it getting better, but man, try doing at least browsing the Mac documentation (freely available online).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302723">
				<div id="div-comment-302723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302723">
			September 1, 2005 at 9:42 pm</a>		</div>

		<p>here&#8217;s a pretty reasonable chunk of documentation for a pretty well-known unix api:</p>
<p><a rel="nofollow" target="_new" href="http://www.openbsd.org/cgi-bin/man.cgi?query=read&amp;apropos=0&amp;sektion=0&amp;manpath=OpenBSD+Current&amp;arch=i386&amp;format=html" rel="nofollow">http://www.openbsd.org/cgi-bin/man.cgi?query=read&#038;apropos=0&#038;sektion=0&#038;manpath=OpenBSD+Current&#038;arch=i386&#038;format=html</a></p>
<p>note that it doesn&#8217;t make mention of the state of the buffer on error.</p>
<p>who would ever implement read() in such a way that it buffers received data in a secondary buffer, just in case there might be an error reading from whatever the heck it is you&#8217;re reading from?  who would expect it?  who would want it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302733">
				<div id="div-comment-302733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302733">
			September 1, 2005 at 10:05 pm</a>		</div>

		<blockquote><p>
  Let&#8217;s ignore for now that the documentation<br />
  <br />&gt; uses registry terminology incorrectly; the<br />
  <br />&gt; parameter specified is a value name, not a<br />
  <br />&gt; key name.)</p>
<p>You have to ask, which team of rocket scientists chose &quot;key&quot;, &quot;value&quot;, and &quot;data&quot;? How guaranteed is that, to cause confusion? (&quot;The value of the value was &#8230; no, erm, the data of the value &#8230; um ..&quot;</p>
<p>TC
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302743">
				<div id="div-comment-302743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302743">
			September 1, 2005 at 10:14 pm</a>		</div>

		<blockquote><p>
  &quot;The value of the value was&quot;</p>
<p>the pellet with the poison&#8217;s in the vessel with the pestle; the chalice from the palace has the brew that is true!<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302753">
				<div id="div-comment-302753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302753">
			September 2, 2005 at 12:39 am</a>		</div>

		<p>I call it &quot;value name&quot; and &quot;value value&quot;. Just like the Disney characters &#8211; Goofy is a &quot;man dog&quot; and Pluto is a &quot;dog dog&quot;. But maybe it&#8217;s just me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302773">
				<div id="div-comment-302773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sandman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302773">
			September 2, 2005 at 7:39 am</a>		</div>

		<p>raymond wrote: &quot;I am but one person. To update all the documentation myself would take years.&quot;</p>
<p>Absolutely. But it the documentation of the windows API which is I find to microsoft&#8217;s weakest point.<br />
<br />Phaps instead of blogging about problems like this when you find them you could also take time to fix that function. It doesn&#8217;t all have to happen all at once , and every little helps.</p>
<p>I don&#8217;t know of any way of folks outside MS provide patches either.</p>
<p>You probably didn&#8217;t submit a patch to the OSS project you picked on &#8211; but if you did you could of held up the before and after as an example of how it is supposed to be done.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-302803">
				<div id="div-comment-302803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302803">
			September 2, 2005 at 10:51 am</a>		</div>

		<p>My favourite MSDN cock-up is in the CreateFile documentation.  It looks like someone has run a spellchecker: the console-input pseudo-files have changed from CONIN$ and CONOUT$ to COIN$ and COPOUT$.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-302953">
				<div id="div-comment-302953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302953">
			September 2, 2005 at 12:34 pm</a>		</div>

		<p>&quot;Phaps instead of blogging about problems like this when you find them you could also take time to fix that function.&quot; </p>
<p>I do not have the authority to edit the documentation directly. I can send suggestions to the doc teams (note: plural) and they will consider them. Sometimes they accept my suggestions, sometimes they don&#8217;t. It&#8217;s their call not mine. </p>
<p>One suggestion of mine was accepted with &quot;That&#8217;s a great idea. Why don&#8217;t you go do it send the diffs to us&quot;. Of course this was a large-scale change that I suggested, so it&#8217;ll take me hundreds of hours to do it. Hundreds of unpaid hours I could be spending on something else, like, say, having fun reading the latest Harry Potter book. What&#8217;s my incentive?</p>
<p>I just heard back from the doc people on the COPOUT$ thing. There was a batch of edits that had a high regression rate that they are still trying to dig out from under and this was one of them. (Another example: Somebody went in and &quot;fixed&quot; Itanium -&gt; Titanium.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-303043">
				<div id="div-comment-303043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303043">
			September 2, 2005 at 3:01 pm</a>		</div>

		<p>dave wrote: &quot;here&#8217;s a pretty reasonable chunk of documentation for a pretty well-known unix api:</p>
<p><a rel="nofollow" target="_new" href="http://www.openbsd.org/cgi-bin/man.cgi?query=read&amp;apropos=0&amp;sektion=0&amp;manpath=OpenBSD+Current&amp;arch=i386&amp;format=html" rel="nofollow">http://www.openbsd.org/cgi-bin/man.cgi?query=read&#038;apropos=0&#038;sektion=0&#038;manpath=OpenBSD+Current&#038;arch=i386&#038;format=html</a></p>
<p>note that it doesn&#8217;t make mention of the state of the buffer on error.&quot;</p>
<p>That&#8217;s because it&#8217;s untouched in that case.</p>
<p>&quot;who would ever implement read() in such a way that it buffers received data in a secondary buffer, just in case there might be an error reading from whatever the heck it is you&#8217;re reading from? who would expect it? who would want it?&quot;</p>
<p>That &quot;secondary buffer&quot; is commonly known as a &quot;disk cache&quot;. They are fairly commonly used&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-302903">
				<div id="div-comment-302903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/mgrier' rel='external nofollow' class='url'>Michael Grier [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-302903">
			September 2, 2005 at 12:17 pm</a>		</div>

		<p>Fun topic.</p>
<p>I think that the more fundamental mistake here is to think that the (basic) contract varies depending on success and failure.</p>
<p>This does not require double buffering to make it work correctly.</p>
<p>The first thing is to understand the data flow direction.  If you can&#8217;t understand the data flow direction easily, you have a badly designed API (and yes I&#8217;ve designed some bad ones myself).</p>
<p>The OSF/DCE RPC IDL syntax is entirely ignorant of failure vs. success and forms a good starting point for anaysis.</p>
<p>For example, there are three patterns of data flow: in, in/out, out.</p>
<p>For &quot;in&quot; data, the value passed in must be (syntactically) legal.  By this I mean that, for example, pointers have to either be NULL or point to a valid region of memory with the correct size/extent/type.  The syntactic legality follows through any pointer chasing.</p>
<p>For &quot;in/out&quot; data, the value passed in must be legal as specified in &quot;in&quot;, but is also subject to change.  The thing I dislike most about &quot;in/out&quot; is that for a nontrivial structure (say an array of pointers to structs where some fields in the structs are read and some are written to) it&#8217;s very hard to annotate the &quot;subflow&quot;.  However empirical evidence suggests that this kind of complex flow is bug-prone and while it may seem elegant on one level (fewer formal paramters), in practice it isn&#8217;t a good idea.</p>
<p>&quot;out&quot; is interesting.  Out data flow specifically says that the memory that the pointer refers to is uninitialized and that the callee will initialize it.  Unconditionally.  Any caller who depends on &quot;out&quot; data to be preserved is fundamentally broken.</p>
<p>This still leaves the registry example ambiguous since while &quot;[out] char **stringout&quot; would certainly be expected to be initialized thus: &quot;*stringout = NULL;&quot;, buffers with sizes are subject to more complex rules.  Again IDL has set a decent standard for shallow data structures with size_is and length_is.</p>
<p>Unfortunately, [out] does not mix with C++ objects; they by definition have to be [in, out] so things get more complex.  You&#8217;re left with [out] only applying to things like raw memory buffers or simple scalars (including pointers).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-303113">
				<div id="div-comment-303113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303113">
			September 3, 2005 at 2:03 am</a>		</div>

		<p>Carlos wrote:</p>
<p>&gt; My favourite MSDN cock-up is in the<br />
<br />&gt; CreateFile documentation. It looks like<br />
<br />&gt; someone has run a spellchecker: the<br />
<br />&gt; console-input pseudo-files have changed<br />
<br />&gt; from CONIN$ and CONOUT$ to COIN$ and COPOUT$.</p>
<p>What an absolute bottler! :-))</p>
<p>Recently, a user of my main aplication (which has been running successfully for several years), reported that he could not enter the asian surname &quot;Teh&quot;. &quot;Your software keeps changing it to &#8216;The&#8217;!&quot;. I said words to the effect of, what drugs are you on, and where can I get some.</p>
<p>Oops! MS Access applied MS Office Autocorrect /BY DEFAULT/ to all of the text fields in my application! Hey, there&#8217;s a neat idea. Let&#8217;s spelling-correct all the Product Codes!</p>
<p>I&#8217;m a great fan of MS software. It has revolutionized several aspects of software development in the 30+ years that I have been in the game. But I look at some decisions, such as, the decision to automatically spelling-correct every text field in a database application (!), and I wonder what level of oversight is applied to these decisions within MS? How could any experienced database software developer, have ever signed-off that one?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-303143">
				<div id="div-comment-303143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jerry Pisk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303143">
			September 3, 2005 at 5:20 am</a>		</div>

		<p>Ben,</p>
<p>read() is used to read data from a lot more types of objects than just physical disks. Consoles, network devices are just two of things you can read with read() that can fail at any time, even half way through a read (so can caches, you cannot expect a disk cache to act as a double buffer, if you read more than one cache page than the first does not have to be available by the time your second comes in). If you lookup POSIX standard references you will see that:</p>
<p>It seems fairly clear from paragraph 7 that at least for EINTR the contents must be considered undefined, since the OS may return -1 anyway after data has been transferred.<br />
<br />(<a rel="nofollow" target="_new" href="http://standards.ieee.org/reading/ieee/interp/1003-1-90_int/pasc-1003.1-76.html" rel="nofollow">http://standards.ieee.org/reading/ieee/interp/1003-1-90_int/pasc-1003.1-76.html</a>)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-303203">
				<div id="div-comment-303203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303203">
			September 4, 2005 at 5:35 am</a>		</div>

		<blockquote><p>
  At what point does one finally decide to leave<br />
  <br />&gt; things unsaid? Should every function also say<br />
  <br />&gt; &quot;All pointers must point to valid memory;<br />
  <br />&gt; otherwise the behavior is undefined&quot;? How about<br />
  <br />&gt; &quot;If you pass the wrong number of parameters to<br />
  <br />&gt; this function, the behavior is undefined.&quot; Or<br />
  <br />&gt; &quot;Do not use memory after freeing it.&quot;</p>
<p>Of course not.  Those things are already implicit from the standard C language specification.</p>
<p>If you&#8217;re writing an API function, it&#8217;s your (in the general sense, not you Raymond Chen specifically =) ) duty to specify a contract with its callers.</p>
<p>I&#8217;m okay with the &quot;if it&#8217;s not documented, it&#8217;s obviously unspecified, duh&quot; approach, but obviously it&#8217;s proven to be problematic.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-303253">
				<div id="div-comment-303253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303253">
			September 5, 2005 at 2:36 am</a>		</div>

		<p>Eric says &quot;What&#8217;s my incentive?&quot;</p>
<p>Why, the greater good, of course!  Making the world a better place!  ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-303263">
				<div id="div-comment-303263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303263">
			September 5, 2005 at 2:40 am</a>		</div>

		<p>As for &quot;At what point does one finally decide to leave things unsaid?&quot;, it&#8217;s halfway between &quot;All pointers must point to valid memory&quot; and &quot;On failure, the output buffer will contain&#8230;&quot;</p>
<p>You don&#8217;t need to say &quot;All pointers must point to valid memory&quot;.  Obviously we know that.  With how great your blogs are generally, I wonder what possessed you to say this&#8211;it&#8217;s clear that you&#8217;re not serious. </p>
<p>But some indication of what we can expect the output buffer to contain, if anything, on failure might be useful.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-303563">
				<div id="div-comment-303563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303563">
			September 6, 2005 at 9:21 am</a>		</div>

		<p>Jerry Pisk wrote: &quot;It seems fairly clear from paragraph 7 that at least for EINTR the contents must be considered undefined, since the OS may return -1 anyway after data has been transferred.&quot;</p>
<p>This was changed in the 2001 version of POSIX:</p>
<p>&quot;If a read() is interrupted by a signal before it reads any data, it shall return -1 with errno set to [EINTR].&lt;/p&gt;</p>
<p>&quot;If a read() is interrupted by a signal after it has successfully read some data, it shall return the number of bytes<br />
<br />read.&quot;</p>
<p>(from <a rel="nofollow" target="_new" href="http://www.opengroup.org/onlinepubs/009695399/functions/read.html" rel="nofollow">http://www.opengroup.org/onlinepubs/009695399/functions/read.html</a> &#8211; free registration required)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-303543">
				<div id="div-comment-303543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303543">
			September 6, 2005 at 7:43 am</a>		</div>

		<p>&gt; some indication of what we can expect<br />
<br />&gt; the output buffer to contain, if anything,<br />
<br />&gt; on failure might be useful. </p>
<p>* Why *  ?</p>
<p>Can you give an example?</p>
<p>I just can&#8217;t see it. If you ask for &#8216;X&#8217;, and don&#8217;t get it, who cares what you got instead? It&#8217;s not a food-type situation, where you ask for a burger, but would probably be satisfied with a pie instead &#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-303973">
				<div id="div-comment-303973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303973">
			September 6, 2005 at 9:28 pm</a>		</div>

		<p>Tuesday, September 06, 2005 7:43 AM by TC<br />
<br />&gt; I just can&#8217;t see it. If you ask for &#8216;X&#8217;, and<br />
<br />&gt; don&#8217;t get it, who cares what you got<br />
<br />&gt; instead?</p>
<p>Here&#8217;s a reason for caring.  It helps in situations where the results are documented and doesn&#8217;t help in situations where the results aren&#8217;t documented, but it helps show why it could be useful to define and document and implement meaningful behaviours in some cases which aren&#8217;t at present.</p>
<p>Some calls to Windows APIs can get error returns with a status code saying that more data are available.</p>
<p>If the output buffer included accurate data up to the limit of either the size of the output buffer or the maximum size that Windows is willing to fill in one call, and if MSDN says that the caller can repeat the call to obtain subsequent portions of the data and the caller can concatenate the results together, then the caller can eventually get everything they needed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-303983">
				<div id="div-comment-303983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-303983">
			September 6, 2005 at 11:58 pm</a>		</div>

		<p>David Walker wanted to know what was in a buffer after a call had &quot;failed&quot;. I still see no benefit for knowing that. Your example is not a &quot;failure&quot; in that sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-304263">
				<div id="div-comment-304263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-304263">
			September 7, 2005 at 10:44 pm</a>		</div>

		<p>OK, IF MSDN says that the caller can repeat the call to obtain subsequent portions of the data THEN the error return saying that more data are available isn&#8217;t exactly a &quot;failure&quot;.  But if MSDN doesn&#8217;t say so then the error return still is a failure.  It would be useful for some of these failure cases to be changed into non-failures.  The reason it would be useful is that the caller has reasons to ask for the data in the first place.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-304273">
				<div id="div-comment-304273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050901-17/?p=34343#comment-304273">
			September 8, 2005 at 12:23 am</a>		</div>

		<p>Norman, that&#8217;s still not a good example IMHO.</p>
<p>If you are saying that a call returns partial data, but this is not documented, then, this is either (a) fortuitous, ie. you can&#8217;t expect it to keep happening in future, or (b) a simple error in the documentation.</p>
<p>I&#8217;m after examples of what at least one previous poster seemed to be wanting: information on the content of an output item, after a call has failed /absolutely/.</p>
<p>An &quot;absolute&quot; failure in this context would be something like &quot;file not found&quot; &#8211; ie. an error with no if&#8217;s, but&#8217;s or maybe&#8217;s about it.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>