<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-642283">
				<div id="div-comment-642283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642283">
			June 27, 2008 at 11:29 am</a>		</div>

		<p>Nice analysis.</p>
<p>I never knew about the algorithm identifier in the GUID. &nbsp;I remember when there was a privacy concern since GUIDs could be tracked back to the machine that generated them (by the network card address). &nbsp;As I understand it, the algorithm used by Windows was changed. &nbsp;It&#8217;s neat to see that GUIDs generated by different algorithms can&#8217;t collied.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642293">
				<div id="div-comment-642293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.jtenos.com/' rel='external nofollow' class='url'>Joe Enos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642293">
			June 27, 2008 at 11:42 am</a>		</div>

		<p>Wouldn&#8217;t a truly random GUID generator be better suited? &nbsp;If all 128 bits are random, then you could take a subset of them and still be reasonably unique &#8211; not as unique as the full 128, but still pretty good.</p>
<p>The non-random GUID doesn&#8217;t really make a lot of sense to me. &nbsp;If truly random, the odds of finding a duplicate are incredibly ridiculously low &#8211; if you have it based on a timestamp, network card, etc., you can run into duplicates much easier, especially as CPUs get faster, and as more and more pieces of hardware get added to the global network.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642303">
				<div id="div-comment-642303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">..</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642303">
			June 27, 2008 at 12:08 pm</a>		</div>

		<p>You basically cannot implement a truly random generator without specific hardware support.</p>
<p>You can always improve your 128bit UUID adding a random generated number to it (of at least 64bit itself.. remember birthday paradox); adding a second random number to an already random number will not improve the situation that much unless taken from a completely different generator.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642313">
				<div id="div-comment-642313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nate</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642313">
			June 27, 2008 at 12:09 pm</a>		</div>

		<p>Ok, say it with me:</p>
<p>&quot;GUIDs are not defined to be random; they are defined to BE UNIQUE in space &amp; time!&quot;</p>
<p>Joe, the customer didn&#8217;t ask for a random number, they asked for a unique number and more specifically about chopping a GUID in half. &nbsp;Raymond explained why that was a bad idea. And he gave a way to generate a CLUSTER unique number with 0 risk of a collision when taken within the customer specified spatial and temporal domains.</p>
<p>Also, using a pseudo-random number generator doesn&#8217;t help with uniqueness if all the computers use the same seed &nbsp;(through the use of time or some other error of coding).</p>
<p>My $0.02.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-642323">
				<div id="div-comment-642323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642323">
			June 27, 2008 at 12:11 pm</a>		</div>

		<p>The &quot;random&quot; GUIDs have an &quot;algorithm identifier&quot; of 0100 (4), FWIW.</p>
<p>Don&#8217;t get me started on the KSDATAFORMAT_SUBTYPE_PCM and KSDATAFORMAT_SUBTYPE_IEEE_FLOAT pseudo-GUIDs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642343">
				<div id="div-comment-642343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642343">
			June 27, 2008 at 12:39 pm</a>		</div>

		<p>Even better. &nbsp;Sorry, didn&#8217;t know the time interval off the top of my head. :-)</p>
<div class=post>[<i>I didn&#8217;t either, but I bothered to follow the link to the GUID spec. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-nathan_works even thread-even depth-1" id="comment-642353">
				<div id="div-comment-642353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/nathan_works' rel='external nofollow' class='url'>nathan_works</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642353">
			June 27, 2008 at 12:49 pm</a>		</div>

		<p>Looks like they are up to algorithm 5, according to a newer spec than the one Raymond linked to: <a rel="nofollow" target="_new" href="http://www.faqs.org/rfcs/rfc4122.html" rel="nofollow">http://www.faqs.org/rfcs/rfc4122.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642363">
				<div id="div-comment-642363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642363">
			June 27, 2008 at 1:03 pm</a>		</div>

		<p>It&#8217;s all fine and dandy until someone builds the 140,737,488,355,328th network card.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642373">
				<div id="div-comment-642373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642373">
			June 27, 2008 at 1:16 pm</a>		</div>

		<p>@josh:</p>
<p>&quot;Not bad if I say so myself.&quot;</p>
<p>So, you&#8217;re the creator of the GUID generation algorithm? :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642413">
				<div id="div-comment-642413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ron Parker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642413">
			June 27, 2008 at 1:55 pm</a>		</div>

		<p>@Josh:</p>
<p>Where do you get the number 16 from? &nbsp;That seems to come from the 4-bit clock sequence number Raymond suggested for the 64-bit cluster-unique ID. &nbsp;GUID algorithm 1 uses 14 bits for the clock sequence number, for 16,384 unique GUIDs per MAC address per 100ns interval, no?</p>
<p>(Provided, of course, that your clock never goes backward. &nbsp;If it does, and you&#8217;re generating GUIDs at a rate of 16,384 every 100ns, your risk of collision rises to near 100%.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642423">
				<div id="div-comment-642423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">njkayaker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642423">
			June 27, 2008 at 1:58 pm</a>		</div>

		<p>[I didn&#8217;t either, but I bothered to follow the link to the GUID spec. -Raymond]</p>
<p>Great! A well that will never run dry!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642443">
				<div id="div-comment-642443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642443">
			June 27, 2008 at 2:19 pm</a>		</div>

		<blockquote><p>
  Provided, of course, that your clock never goes backward
</p></blockquote>
<p>Stupid clock correction in Windows makes it possible, unfortunately.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642453">
				<div id="div-comment-642453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642453">
			June 27, 2008 at 2:21 pm</a>		</div>

		<p>&gt;[Actually, it&#8217;s 16 guaranteed unique GUIDs per 100-nanosecond interval, or 160 million unique GUIDs per second. -Raymond]</p>
<p>You mean your tick rate is 10 MHz? 100 ns is just kernel time unit, not actual resolution, or rate at which it changes. It only changes about 15 times per second, depending on HAL.</p>
<div class=post>[<i>If you read the GUID spec (which I linked to) you can see how you can generate timestamps with greater precision than the clock tick. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642473">
				<div id="div-comment-642473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642473">
			June 27, 2008 at 2:33 pm</a>		</div>

		<p>@Ron Parker:</p>
<p>The clock sequence field is not intended to be used to allow more than one GUID to be generated within a 100ns interval. &nbsp;The clock sequence field is specifically intended to handle the situation where the clock &#8216;goes back in time&#8217; (due to a resetting the clock, restarting the machine or whatever).</p>
<p>What Raymond calls 56 bits of time stamp with 4 bits of &#8216;uniquifier&#8217; is really a 60 bit time stamp field with 100ns resolution. What&#8217;s being described as 56 bit of timestamp with 4 bits uniquifier is probably that the clock being used to get the timestamp does not have a 100ns resolution, and the implementation is using a technique like the one described in RFC 4122 section 4.2.1.2 to get up to 16 UUID&#8217;s per native clock tick.</p>
<p>Basically with algorithm 1 (according to RFC4122) for a single generator instance, you get at most one UUID per 100ns interval. If you need more, the RFC suggests adding more MAC addresses so you can have several instances of the UUID gen going concurrently. &nbsp;If you can&#8217;t do something like that you have to stall or return an error.</p>
<p>See RFC 4122 4.2.1.2.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642483">
				<div id="div-comment-642483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ron Parker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642483">
			June 27, 2008 at 2:42 pm</a>		</div>

		<p>@Alexandre:</p>
<p>If you can get anything that runs Windows to generate 16,384 GUIDs every 100ns, tell me what the stock market looks like there in the 160+ GHz future. &nbsp;And where do you store them all? &nbsp;If you&#8217;re not generating them at a sustained rate that&#8217;s a significant fraction of that, the risk of collision goes way down, even if the clock goes backwards.</p>
<p>RFC 4122 actually has a provision for clocks that don&#8217;t tick every 100ns, allowing you to use the lower bits of the timestamp as a serial number. &nbsp;It&#8217;s not clear to me on first reading how that serial number interacts with the time sequence number, so the number of GUIDs you can generate on such a system without causing collisions might not be quite as high.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642493">
				<div id="div-comment-642493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ron Parker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642493">
			June 27, 2008 at 2:50 pm</a>		</div>

		<p>@mikeb:</p>
<p>I see. &nbsp;The RFC says &quot;If the state was available, but the saved timestamp is later than the current timestamp, increment the clock sequence value&quot; but Raymond said &quot;When time appears to have stood still &#8230; or gone backward &#8230; the uniquifier is incremented.&quot; &nbsp;When I read the RFC, I missed the subtle difference. &nbsp;So at most one GUID every 100ns it is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642513">
				<div id="div-comment-642513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642513">
			June 27, 2008 at 3:02 pm</a>		</div>

		<p>[If you read the GUID spec (which I linked to) you can see how you can generate timestamps with greater precision than the clock tick. -Raymond]</p>
<p>But you can&#8217;t generate timestamps with a higher resolution than 100ns &#8211; that&#8217;s what the timestamp field is defined to be. &nbsp;So the spec discusses, for example, how to deal with the fact that your clock can only generate ticks with 10 microsecond resolution and you want your generator to be able to generate more than one UUID within the span of 10 microseconds.</p>
<p>If you need to generate more than one UUID within a 100ns span (on average), you either need to have addition MAC addresses to &#8216;uniquify&#8217; the node ID field or you need to have your generator stall or return an error.</p>
<p>On the whole though, I don&#8217;t think there are too many people having problems with generating too many GUIDs in too short a time period. &nbsp;My machine has less than a 4GHz clock &#8211; so that&#8217;s fewer than 400 clock cycles per 100ns interval here (if my cipherin&#8217; is correct).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642523">
				<div id="div-comment-642523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642523">
			June 27, 2008 at 3:30 pm</a>		</div>

		<p>some other interesting notes about GUIDs that try to use MAC addresses as unique values:</p>
<p>1) many network cards and devices now allow you to set the MAC address to whatever you want; some cable modems and that kind of thing rely on this functionality, apparently.</p>
<p>2) for a while, at least, the dummy network adaptors created by Windows for dial-up connections and the like all had the same MAC address (i think it was &quot;DEST  &quot; or something). &nbsp;there were a lot of GUIDs floating around that had that decidedly non-unique value&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642533">
				<div id="div-comment-642533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642533">
			June 27, 2008 at 3:38 pm</a>		</div>

		<p>A related post by Larry Osterman:</p>
<p>UUIDs are only unique if you generate them&#8230;</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/larryosterman/archive/2005/07/21/441417.aspx" rel="nofollow">http://blogs.msdn.com/larryosterman/archive/2005/07/21/441417.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642573">
				<div id="div-comment-642573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">eff Five</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642573">
			June 27, 2008 at 4:53 pm</a>		</div>

		<p>@Thor</p>
<p>Very nicely put. I’m adding “what are the requirements on which a solution is based and can any of them be relaxed” to the “words to code by” list. I especially like it because its got understanding the requirements baked in</p>
<p>Similar items on the list</p>
<p>“never fix a bug you don’t understand” &#8211;<a rel="nofollow" target="_new" href="http://www.links.org/?p=327" rel="nofollow">http://www.links.org/?p=327</a></p>
<p>And</p>
<p>“A cache with a bad policy is another name for a memory leak” &#8211; <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/05/02/588350.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/05/02/588350.aspx</a></p>
<p>“Random number generation is hard. [..] leave it to the experts. &#8211; <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2004/04/12/111596.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2004/04/12/111596.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642583">
				<div id="div-comment-642583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Judge Dredd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642583">
			June 27, 2008 at 6:00 pm</a>		</div>

		<blockquote><p>
  &gt; “never fix a bug you don’t understand” &#8211;<a rel="nofollow" target="_new" href="http://www.links.org/?p=327" rel="nofollow">http://www.links.org/?p=327</a>
</p></blockquote>
<p>I disagree with the post..</p>
<p>Better is</p>
<p>Never leave ambiguous &quot;bug-smelling&quot; code around, at least not uncommented, and never rely on undetermined system behavior (OpenSSL relies on the memory being uninitialized.. which is a false assumption because it&#8217;s not part of any contract and both OS, the loader, libc et al are free to zero-out &#8211; or something else &#8211; the uninit. memory).</p>
<p>If it smells like a bug, it&#8217;s a bug, at least in form. Correct code should never raise a suspect.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642333">
				<div id="div-comment-642333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642333">
			June 27, 2008 at 12:26 pm</a>		</div>

		<p>@Joe:</p>
<p>Because there is a *chance* of collision, even with pure randomness. &nbsp;Remember, the birthday problem (aka birthday paradox) means that the time before unacceptably high probability of collision is much lower than the number of possible options. &nbsp;e.g. For truly random 128 bit numbers (3.4e38 options), you&#8217;d have a 50% chance of collision after generating about 22 quintillion GUIDs (2.17e19). &nbsp;Problem is, this assumes we are *really* random. &nbsp;And generating numbers that are truly random, to the point of uniqueness, is nearly impossible. &nbsp;For example, one means of generating very good random numbers is having an antenna count ticks in the cosmic background radiation over time. &nbsp;If an odd number of ticks occur in a time frame, you get a 1, even, a 0, continue until the number is long enough. &nbsp;But what if two antennas are generating at the same time in close proximity? &nbsp;Odds of collision increase greatly. &nbsp;And of course, it would take a while to collect the arbitrary randomness. &nbsp;Virtually every form of random number generation would be in some way dependent on the time and location at which it was generated. &nbsp;And any less extensive randomness generator is likely to be slightly non-random, leading to collisions occurring *much* more often.</p>
<p>The non-random GUID, if you read the description, allows for any given machine to pump out 16 *guaranteed* unique GUIDs per second. &nbsp;And it even manages to conserve 6 bits that aren&#8217;t part of the uniqueness, to allow for future advances in GUID design. &nbsp;Not bad if I say so myself. &nbsp;Keep in mind, this isn&#8217;t &#8220;based on&#8221; a timestamp or network card, it is a time stamp and specific network card ID. &nbsp;You can permanently remove a whole block of GUIDs from existence by smashing network cards. &nbsp;No risk of duplicates, period.</p>
<div class=post>[<i>Actually, it&#8217;s 16 guaranteed unique GUIDs per 100-nanosecond interval, or 160 million unique GUIDs per second. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642593">
				<div id="div-comment-642593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miles Archer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642593">
			June 27, 2008 at 8:39 pm</a>		</div>

		<p>Judge Dred,</p>
<p>I hope you don&#8217;t work on any of my projects. There&#8217;s a risk to fixing any code. If you don&#8217;t weigh the risk vs reward you&#8217;re asking for trouble. If you worked on my project and fixed code that &quot;smells&quot; without justification, their would be hell to pay.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642543">
				<div id="div-comment-642543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642543">
			June 27, 2008 at 4:01 pm</a>		</div>

		<p>Beyond the specifics of the GUID generation, I love the initial problem statement. &nbsp;(I am fairly new to the blog and haven&#8217;t finished going back and reading them all but this must be a pattern.) &nbsp;</p>
<p>The customer&#8217;s basic question is&#8211; &quot;for this problem, there is a solution, but I want it for less&quot;. </p>
<p>Without changing the a basic requirement (like local uniqueness versus global uniqueness in this example), it seems the only way this would be possibile is if the original solution was suboptimal. &nbsp;While I frequently think that a given solution seems suboptimal, I almost always find that, no, whoever found it knew *tons* more about the problem than I had any idea existed.</p>
<p>Granted questioning an optimal solution is how technology improves, but in a case like this, unless you are master of the intricacies of unique number generation, the chances seem quite slim that you will achieve the requirement (unique) with fewer resources (half the byters). &nbsp;</p>
<p>So, the root of the question pattern may be&#8211; what are the requirements on which a solution is based and can any of them be relaxed?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-642613">
				<div id="div-comment-642613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642613">
			June 27, 2008 at 11:21 pm</a>		</div>

		<p>&quot;OpenSSL relies on the memory being uninitialized&quot;</p>
<p>If you&#8217;re referring to the &quot;Debian incident&quot;, that is not true &#8211; OpenSSL does not rely on memory being uninitialized.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642643">
				<div id="div-comment-642643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff Tyrrill</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642643">
			June 27, 2008 at 11:30 pm</a>		</div>

		<p>I really do wish hardware random number generators were standard order in modern processors, so we didn&#8217;t have to rely on these elaborate algorithms simply to guarantee uniqueness, which are riddled with privacy implications. (I realize newer algorithms are much improved from the one in this post, but the point remains that not having access to guaranteed entropic data means a slew of pragmatic assumptions must be made and carefully weighted in the development of any unique number generation algorithm.)</p>
<p>Using a cryptographic PRNG and guaranteed entropic source data, you don&#8217;t need silly constructs like an &quot;algorithm&quot; counter to prevent collisions between &quot;algorithms&quot;. The size of the bitspace (128 bits) is guarantee enough, even with arbitrarily many algorithms, as long as they all have entropic source data and are reliable CSPRNGs.</p>
<p>(Whatever the probability of number collision, it will be higher with a less entropic algorithm than a cryptographic PRNG anyway, so even if 128 bits isn&#8217;t enough bitspace, you&#8217;re still better off using a CSPRNG. A CSPRNG satisfies a greater requirement than uniqueness, but it <em>does</em> satisfy uniqueness also.)</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" rel="nofollow">http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642653">
				<div id="div-comment-642653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642653">
			June 28, 2008 at 2:28 am</a>		</div>

		<p>Similarly, hashing 2 7-byte values aren&#8217;t as secure as hashing 1 14-byte value, as the LM hash showed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642673">
				<div id="div-comment-642673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Narr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642673">
			June 28, 2008 at 4:24 am</a>		</div>

		<blockquote><p>
  Whatever the probability of number collision,</p>
<p>  it will be higher with a less entropic</p>
<p>  algorithm than a cryptographic PRNG anyway
</p></blockquote>
<p>Global registry? <em>That</em> would actually guarantee uniqueness. A 1:1, one-way hashed hardware ID + timestamp comes pretty close, too.</p>
<blockquote><p>
  A CSPRNG satisfies a greater requirement than</p>
<p>  uniqueness, but it <em>does</em> satisfy uniqueness also.
</p></blockquote>
<p>How? It&#8217;s entirely possible for a collision to occur, so there&#8217;s no guarantee, and it trivially does not satisfy. Also, what is your &#8216;greater requirement&#8217;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xepol even thread-even depth-1" id="comment-642703">
				<div id="div-comment-642703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Xepol' rel='external nofollow' class='url'>Xepol</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642703">
			June 28, 2008 at 6:12 pm</a>		</div>

		<p>Or they could stop being data-cheap and just use a GUID&#8230;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642713">
				<div id="div-comment-642713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642713">
			June 29, 2008 at 3:28 am</a>		</div>

		<p>From mikeb:</p>
<p>&quot;</p>
<p>But you can&#8217;t generate timestamps with a higher resolution than 100ns &#8211; that&#8217;s what the timestamp field is defined to be.</p>
<p>&quot;</p>
<p>On my computer, QueryPerformanceCounter has 10ns accuracy (the function call time itself is irrelevant). It uses the on-board clock which runs at approximatively 100Mhz.</p>
<p>Why would you use GetTickCount?</p>
<p>From Jeff Tyrrill:</p>
<p>&quot;</p>
<p>I really do wish hardware random number generators were standard order in modern processors, so we didn&#8217;t have to rely on these elaborate algorithms simply to guarantee uniqueness</p>
<p>&quot;</p>
<p>On Linux, there&#8217;s /dev/random, based on keystrokes entropy, and things like noise recorded from the sound card.</p>
<p>Birthday&#8217;s paradoxes remain.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642753">
				<div id="div-comment-642753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642753">
			June 29, 2008 at 4:46 pm</a>		</div>

		<p>@Jeff Tyrrill</p>
<p>&quot;I really do wish hardware random number generators were standard order in modern processors, so we didn&#8217;t have to rely on these elaborate algorithms simply to guarantee uniqueness&quot;</p>
<p>If your random numbers are unique, your random number generator is broken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642783">
				<div id="div-comment-642783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642783">
			June 29, 2008 at 10:58 pm</a>		</div>

		<p>@SuperKoko:</p>
<blockquote><p>
  &gt; On my computer, QueryPerformanceCounter has 10ns accuracy &lt;&lt;
</p></blockquote>
<p>That&#8217;s nice, but it doesn&#8217;t solve the theoretical problem of generating more than one UUID every 100ns (on average) &#8211; the timestamp field in the UUID is in units of 100ns.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642803">
				<div id="div-comment-642803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pZy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642803">
			June 30, 2008 at 2:23 am</a>		</div>

		<p>German Wikipedia says for privacy reasons newer versions of Windows would not make use of the MAC address for creating GUIDs.</p>
<p>Otherwise it would be possible to draw conclusions about the creator.</p>
<p>Unfortunatley I didn&#8217;t find that statement in the english wiki.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642853">
				<div id="div-comment-642853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642853">
			June 30, 2008 at 11:22 am</a>		</div>

		<p>&quot;</p>
<p>That&#8217;s nice, but it doesn&#8217;t solve the theoretical problem of generating more than one UUID every 100ns (on average) &#8211; the timestamp field in the UUID is in units of 100ns.</p>
<p>&quot;</p>
<p>That&#8217;s still better than one GUID every 10 milliseconds with GetTickCount.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642933">
				<div id="div-comment-642933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-642933">
			June 30, 2008 at 1:46 pm</a>		</div>

		<p>@SuperKoko:</p>
<blockquote><p>
  &gt; That&#8217;s still better than one GUID every 10 milliseconds with GetTickCount. &lt;&lt;
</p></blockquote>
<p>But you&#8217;re not limited to a single UUID per 10ms tick, even if that&#8217;s the hardware clock you might be stuck with. That&#8217;s one of the things that section 4.2.1.2 of RFC 4122 discusses:</p>
<hr />
<p>A high resolution timestamp can be simulated by keeping a count of the number of UUIDs that have been generated with the same value of the system time, and using it to construct the low order bits of the timestamp. &nbsp;The count will range between zero and the number of 100-nanosecond intervals per system time interval.</p>
<hr />
<p>So you can still get a 10000 unique UUIDs per 10ms tick. &nbsp;But my point wasn&#8217;t what timer resolution is best to use, but that by definition you can&#8217;t get better resolution than 100ns resolution using Algorithm 1 to generate UUIDs. &nbsp;Oh, and that the clock sequence field is not intended to be used to simulate a higher resolution &#8211; it&#8217;s intended to deal with clocks getting out of &#8216;sync&#8217; (or going back in time).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-643053">
				<div id="div-comment-643053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.cwa.me.uk/2008/07/01/the-morning-brew-126/' rel='external nofollow' class='url'>Reflective Perspective - Chris Alcock &raquo; The Morning Brew #126</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-643053">
			July 1, 2008 at 3:04 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://blog.cwa.me.uk/2008/07/01/the-morning-brew-126/" rel="nofollow">http://blog.cwa.me.uk/2008/07/01/the-morning-brew-126/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-643073">
				<div id="div-comment-643073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sqldev.wordpress.com/2008/07/01/the-guid-guide/' rel='external nofollow' class='url'>The GUID Guide &laquo; SQL Dev&#8217;s Playground</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-643073">
			July 1, 2008 at 3:46 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://sqldev.wordpress.com/2008/07/01/the-guid-guide/" rel="nofollow">http://sqldev.wordpress.com/2008/07/01/the-guid-guide/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-644173">
				<div id="div-comment-644173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andy R</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-644173">
			July 3, 2008 at 6:03 am</a>		</div>

		<p>Your reduced GUID format is a good idea, not used often enough, but it makes one more assumption&#8230; that there is only one thread or process running on each computer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-644523">
				<div id="div-comment-644523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-644523">
			July 3, 2008 at 6:29 pm</a>		</div>

		<p>&quot;</p>
<p>Your reduced GUID format is a good idea, not used often enough, but it makes one more assumption&#8230; that there is only one thread or process running on each computer.</p>
<p>&quot;</p>
<p>No. It just assumes that you use only one generator function (e.g. in a dynamic or static library). In that case, it&#8217;s free to use shared variables and mutexes to safely manager GUIDs generation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-645483">
				<div id="div-comment-645483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.dirteam.com/blogs/mjohnson/archive/2008/07/09/interesting-links-7-09-2007.aspx' rel='external nofollow' class='url'>Matt Johnson's Technical Adventures</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823#comment-645483">
			July 9, 2008 at 8:38 am</a>		</div>

		<p>The list is a little longer today because of not posting last week. Enjoy! Microsoft Advanced Windows</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>