<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (30)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-286653">
				<div id="div-comment-286653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286653">
			June 24, 2005 at 9:18 am</a>		</div>

		<p>Is it possible to use WM_PAINT instead, in order to &quot;cheat&quot; those apps that doesn&#8217;t support WM_PRINT? MSDN says WM_PAINT should not be send directly, but how would window proc knows whether it is sent directly or via UpdateWindow()?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286663">
				<div id="div-comment-286663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286663">
			June 24, 2005 at 9:19 am</a>		</div>

		<p>That&#8217;s why Windows has all those funky artifacts when moving windows around, and just goes to heck when a window hangs (ever see the hall of mirrors?) Makes sense for Win3.1 and maybe Win95 with limited memory machines of the time, but in the age of 2000 and XP, it&#8217;s pretty lame. Longhorn will finally fix that by keeping track of a full bitmap of each window in memory and compositing a final single window in the GPU&#8217;s memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286673">
				<div id="div-comment-286673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286673">
			June 24, 2005 at 9:26 am</a>		</div>

		<p>Feng Yuan&#8217;s famous article about this: <a rel="nofollow" target="_new" href="http://www.fengyuan.com/article/wmprint.html" rel="nofollow">http://www.fengyuan.com/article/wmprint.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286683">
				<div id="div-comment-286683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JT</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286683">
			June 24, 2005 at 9:34 am</a>		</div>

		<p>Ha!  Does anybody else remember that the original PC BIOS had a function for  scraping character codes (OCR&#8217;ing) from the pixel buffer memory?  The PC BASIC&#8217;s screen text editor used this feature!  You could </p>
<p>1. Put the screen into graphics mode.<br />
<br />2. LIST your program<br />
<br />3. Move the cursor into the text<br />
<br />4. Change something<br />
<br />5. And finally press ENTER</p>
<p>and BASIC would record the changed line in the program.  (Of course, the line had to start with a line number (and there were rules about line continuation that I cannot recall).)</p>
<p>BUT if between 2 and 3 you drew a line through the text, the edit would fail.  The OCR required exact pixel-for-pixel matches to character bitmaps.  I don&#8217;t remember how the FG/BG pixel coloring affected all this.</p>
<p>I&#8217;m quite sure that the earlY MS Windows designers were aware of BASIC&#8217;s pixel scraping habits.  I also bet that they never seriously considered doing anything like it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286703">
				<div id="div-comment-286703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">kalleboo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286703">
			June 24, 2005 at 9:39 am</a>		</div>

		<p>It&#8217;s interesting to see that MacOS X has the opposite approach, but then again look at how much RAM it enjoys to use&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286723">
				<div id="div-comment-286723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BillG</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286723">
			June 24, 2005 at 9:47 am</a>		</div>

		<p>640KB should be enough for anybody.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286733">
				<div id="div-comment-286733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286733">
			June 24, 2005 at 10:33 am</a>		</div>

		<blockquote><p>
  it possible to use WM_PAINT instead, in order to &quot;cheat&quot; those apps that doesn&#8217;t support WM_PRINT? </p>
<p>No, applications use BeginPaint in WM_PAINT to obtain where to draw.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286743">
				<div id="div-comment-286743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.foxyshadis.com' rel='external nofollow' class='url'>foxyshadis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286743">
			June 24, 2005 at 10:34 am</a>		</div>

		<p>&quot;Longhorn will finally fix that by keeping track of a full bitmap of each window in memory and compositing a final single window in the GPU&#8217;s memory.&quot;</p>
<p>Gee, just what I want, every maximized app using another 4 megs. (I run almost everything maximized, 32bit, 1280&#215;800, often 6-7 apps at once, sometimes dozens.) And that&#8217;s if MDI apps are all one image. Yeah, great &#8216;fix&#8217;. Let&#8217;s rename it to OS L. =D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-rosyna even thread-even depth-1" id="comment-286763">
				<div id="div-comment-286763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rosyna</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286763">
			June 24, 2005 at 10:45 am</a>		</div>

		<p>For the person that mentioned OS X, it uses compositing and if a window is fully obscured for a while, it&#8217;s data will be compressed. Then if it goes even longer without being unobscured, it&#8217;ll be swapped to disk, thereby taking up no RAM. If another app wants to access the contents of the window, it&#8217;ll be swapped back into main memory and decompressed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286773">
				<div id="div-comment-286773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mihai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286773">
			June 24, 2005 at 12:00 pm</a>		</div>

		<p>&quot;If the window isn&#8217;t visible on the screen, then the pixels simply don&#8217;t exist.&quot;</p>
<p>What if the window class has (the long forgoten) CS_SAVEBITS stlyle. Yes, I know this is probably never the case, but just curious.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-286783">
				<div id="div-comment-286783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286783">
			June 24, 2005 at 12:23 pm</a>		</div>

		<p>CS_SAVEBITS is a strange case because the bits it saves are thrown away at the slightest provocation. (And those bits aren&#8217;t saved with the window being covered; they&#8217;re saved with the &gt;covering&lt; window.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286793">
				<div id="div-comment-286793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286793">
			June 24, 2005 at 1:10 pm</a>		</div>

		<p>To make things more complicated there are layered windows and the WS_EX_LAYERED style.  Layered windows basically draw everything to a GDI-supplied backbuffer and then get composed to the screen.  The bits are persistent in this case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286803">
				<div id="div-comment-286803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasmusic.com' rel='external nofollow' class='url'>Joshua Schaeffer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286803">
			June 24, 2005 at 1:26 pm</a>		</div>

		<p>Why does OS X go through the labor of compressing and swapping out a window&#8217;s contents when it could just have the window repaint itself when needed again?</p>
<p>Otherwise, the increased memory usage of fully buffered windows can be discounted by the fact that video cards now come with more than enough of their own RAM to hold it all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mgrier odd alt thread-odd thread-alt depth-1" id="comment-286823">
				<div id="div-comment-286823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MGrier' rel='external nofollow' class='url'>MGrier</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286823">
			June 24, 2005 at 1:41 pm</a>		</div>

		<p>Search the web for the debates about whether X11 should have provided guaranteed server side backing for windows.  Lots of arguments for, lots of arguments against.</p>
<p>What&#8217;s interesting is that almost all the arguments &quot;for&quot; were around making it easier for programs.  The arguments &quot;against&quot; were about efficiency, scalability and the fact that programs could be authored to use a drawing library that maintained a client-side bitmap cache and easily respond to redraw messages.</p>
<p>Sounds like a familliar debate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286843">
				<div id="div-comment-286843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://bryanzak.blogspot.com' rel='external nofollow' class='url'>Bryan Pietrzak</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286843">
			June 24, 2005 at 2:08 pm</a>		</div>

		<p>Joshua asks &quot;why have backing store, why not just let app repaint?&quot;</p>
<p>Lots of reasons! Performance of the the composited graphics system is a big one &#8211; no time to wait for apps to redraw content when you&#8217;re trying to deal with windows that have shadows and non 1.0 alphas, etc. </p>
<p>Functionality is another one. Since the OS always has access to a window&#8217;s backing store it makes things like Expos&#232; really easy &#8211; likewise with animated minimizing. Apps just draw to their backing store and the OS takes care of the transformations on screen without the app having to know anything.</p>
<p>Another is sexiness &#8212; OS X looks smoother simply because you NEVER get windows with big blank spaces or outlines because the content isn&#8217;t there (at all, or yet).</p>
<p>Tearing, and flickering are evil. Many many apps already double buffer to avoid that, so with OS X rather than have every app do that themselves (at least the apps that care about their appearance) OS X does it for them automatically and offers a bunch of new features like compression and paging of &quot;old&quot; backing stores.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286853">
				<div id="div-comment-286853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.livejournal.com/users/merle_/' rel='external nofollow' class='url'>Merle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286853">
			June 24, 2005 at 2:15 pm</a>		</div>

		<p>&quot;Longhorn will finally fix that by keeping track of a full bitmap of each window in memory and compositing a final single window in the GPU&#8217;s memory.&quot;</p>
<p>I agree with foxyshadis; that&#8217;s obscene.</p>
<p>So when I&#8217;m coding at 1600x1200x24bits, that&#8217;s 5.7M per window.  With a mere ten windows, 60M is eaten up.</p>
<p>Talk about bloat.  Just so a minimized window can know what it looks like?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286863">
				<div id="div-comment-286863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286863">
			June 24, 2005 at 2:30 pm</a>		</div>

		<p>Mike, </p>
<p>WS_EX_LAYERED windows uses WM_PRINT in order to dump the content into a backbuffer. As far as I know, backbuffer isn&#8217;t keeped, so one still have no access to window&#8217;s bits. Beside, we&#8217;re talking about hidden/obscured windows, which aren&#8217;t displayed on screen at the moment, so WS_EX_LAYERD doesn&#8217;t matter</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286883">
				<div id="div-comment-286883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">R. Bemrose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286883">
			June 24, 2005 at 2:37 pm</a>		</div>

		<p>&quot;&quot;Longhorn will finally fix that by keeping track of a full bitmap of each window in memory and compositing a final single window in the GPU&#8217;s memory.&quot;</p>
<p>I agree with foxyshadis; that&#8217;s obscene.</p>
<p>So when I&#8217;m coding at 1600x1200x24bits, that&#8217;s 5.7M per window. With a mere ten windows, 60M is eaten up.</p>
<p>Talk about bloat. Just so a minimized window can know what it looks like?&quot;</p>
<p>If this is in Longhorn, I&#8217;d think it more likely that they&#8217;d use LZ77 (used by DEFLATE, GZIP, PNG) or something similar to do lossless compression of the stored bitmap.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286893">
				<div id="div-comment-286893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286893">
			June 24, 2005 at 2:53 pm</a>		</div>

		<p>Layered windows do keep thier backbuffer until the window size is changed (including minimizing it) at which time it&#8217;s discarded.  It&#8217;s easy enough to test &#8211; have your favorite GUI skeleton code use layered windows and you pretty much never see WM_PAINT unless you force it or resize the window.</p>
<p>Although I just tried have one app try to read the client area of a different app that used layered windows but had it&#8217;s window covered by still a third app.  It didn&#8217;t work &#8211; there was no output at all.  GDI returned no errors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286903">
				<div id="div-comment-286903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286903">
			June 24, 2005 at 3:03 pm</a>		</div>

		<p>Some of you are forgetting that the full-on Aero Glass mode of Longhorn recommends at least 128MB of video RAM. That&#8217;s where all this &quot;bloat&quot; is supposed to go.</p>
<p>1600x1200x32 rounded up to the next MB for overhead is 16 full screen windows in 128MB. And the LH graphics subsystem can virtualize VRAM so if your card is low-speced the excess can spill over into system RAM if needed.</p>
<p>And if you don&#8217;t like it you can turn it off.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286933">
				<div id="div-comment-286933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JamesW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286933">
			June 24, 2005 at 6:48 pm</a>		</div>

		<p>@buffer doubters</p>
<p>Windows got it right when this system was designed &#8211; memory was precious and you certainly didn&#8217;t want to be using it storing invisible stuff. But in the brave new translucent twenty first century, where gobs of memory is cheap, the tables have turned: Mac OS X does it right and apparently Longhorn will too.</p>
<p>It&#8217;s not just about cutesy GUIs either. Real world example: I have a list box whose data set updates frequently and I want it to display new data dynamically. On Windows it is flicker city &#8211; so I spend a day implementing my own double buffering and it more or less works. Problem is a colleague has already been hacking away at the list view header control and whatever he&#8217;s done thwarts my code&#8230; Meanwhile on OS X &#8211; IT JUST WORKED IN THE FIRST PLACE. This is important: I don&#8217;t need &#252;ber skills to get flicker free GUI &#8211; the OS provides it.</p>
<p>Doubters, the equation has shifted: burn some RAM for a better GUI; it&#8217;s worth it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286953">
				<div id="div-comment-286953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.livejournal.com/users/merle_/' rel='external nofollow' class='url'>Merle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286953">
			June 24, 2005 at 7:07 pm</a>		</div>

		<p>R. Bemrose: &quot;If this is in Longhorn, I&#8217;d think it more likely that they&#8217;d use LZ77 (used by DEFLATE, GZIP, PNG) or something similar to do lossless compression of the stored bitmap.&quot;</p>
<p>Maybe so &#8212; but then you&#8217;re losing some of the speed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286963">
				<div id="div-comment-286963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286963">
			June 24, 2005 at 8:06 pm</a>		</div>

		<p>I also don&#8217;t the point in compressing the bitmap when you minimize or page out the memory after a certain amount of time. A window is expected to redraw reasonably fast when you&#8217;re resizing it so that that speed resizing it is about the same speed you get when needing to uncover it in those situations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-286873">
				<div id="div-comment-286873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286873">
			June 24, 2005 at 2:36 pm</a>		</div>

		<p>Perhaps Longhorn, *would* implement such behaviour for *certain* windows, not all. Sometimes this would make sense &#8211; for example if the window contains complex drawing or something. Some sort of WS_BACKBUFFER flag can do the trick. Currently, applications with complex drawings should either repaint themselves or implement such backbuffering &#8211; that isn&#8217;t very hard. Modern video adapters has hundreds of MB, and even on 32MB adapters couple 5MB can fit in video memory that is not currently in use.</p>
<p>However, all of the above (in this post) is pure theory and speculation. We should simply wait for longhorn and see, and/or download a (beta) SDK (if any) and see what it says about that matter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-286973">
				<div id="div-comment-286973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zzz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-286973">
			June 24, 2005 at 11:13 pm</a>		</div>

		<p>Instead of claiming Longhorn doing this or that, I&#8217;ll claim that by the time it ships, every shipping $1000+ laptop will have either 128 MB of suitably fast memory for the needs of LH.</p>
<p>But it wouldn&#8217;t surprise me if LH worked just fine on a bit older laptops aswell. Like those of whose buyers were smart enough to look for PS2 support in their laptops display adapter.</p>
<p>Mine runs Battlefield 2 &#8211; get that ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-287003">
				<div id="div-comment-287003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sierra</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-287003">
			June 25, 2005 at 4:02 pm</a>		</div>

		<p>I know I am writing at a wrong place. I am a new memeber and need to post a comment (actually a query) to &#8216;oldnewthing&#8217; about spam emails. How do I do that?<br />
<br />Again, very sorry for interrupting this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-287043">
				<div id="div-comment-287043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">R. Bemrose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-287043">
			June 26, 2005 at 4:03 pm</a>		</div>

		<p>Merle:  You may be right.  I&#8217;ve never tried balancing large amounts of data compression in real time.</p>
<p>Then again, I also hadn&#8217;t considered that Windows might use the display adapters memory to store them until after I posted that, either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-287053">
				<div id="div-comment-287053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-287053">
			June 26, 2005 at 6:55 pm</a>		</div>

		<p>Backing store really isn&#8217;t that horribly expensive. It was used by default in AmigaOS, where the feature was called &quot;smart refresh&quot;, and that was running on very small systems, though with comparatively generous amounts of video RAM (in fact in the smaller systems there was nothing but video RAM). It made for quite snappy windowing even on a 68000.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-287103">
				<div id="div-comment-287103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://wind.codepixel.com' rel='external nofollow' class='url'>Antonio Vargas</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-287103">
			June 27, 2005 at 8:03 am</a>		</div>

		<p>On AmigaOS, smart refresh was optional by setting  a suitable flag on the window creation call, but it was so useful that people soon patched the CreateWindow function to force it everywhere smart refresh.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-287713">
				<div id="div-comment-287713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.borland.com/abauer' rel='external nofollow' class='url'>Allen Bauer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050624-46/?p=35203#comment-287713">
			June 29, 2005 at 4:55 pm</a>		</div>

		<p>Uh.. excuse me?  I&#8217;ve recently tried using the PrintWindow API, and for me if I use it on a partially clipped child window, it doesn&#8217;t actually paint the clipped (by the parent window or other children) portions of the window on my DC.  Is this a limitation I&#8217;ve encountered or is it actually intended to only be used for top-level windows only?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>