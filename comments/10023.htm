<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-927483">
				<div id="div-comment-927483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Blake</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927483">
			July 29, 2011 at 7:12 am</a>		</div>

		<p>Always mount a scratch monkey.</p>
<p>(And more seriously &#8211; yes, fail fast, always.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927493">
				<div id="div-comment-927493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927493">
			July 29, 2011 at 7:13 am</a>		</div>

		<p>I think this (yet again) illustrates the failure of the &#39;one size fits all&#39; approach. An intelligent solution needs to look at what exactly is at stake, and what (if anything) could be done about the error.</p>
<p>An application that presented a message like &#39;A fatal error has occurred. Press OK to quit. All unsaved changes will be lost.&#39; when all you did was try to save over a read-only file would be quite annoying. On the other hand, in the kind of scenario Raymond refers to above it is obvious that blindly continuing is the last thing you want to do. Context is everything.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927503">
				<div id="div-comment-927503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927503">
			July 29, 2011 at 7:17 am</a>		</div>

		<p>Log files would help with the &quot;you&#39;ll have no idea how it got that way&quot; scenario. &nbsp;Silently ignore errors for the user, but log them.</p>
<p>Of course behavior should be based on the severity of the error. &nbsp;When in QA, make every error act like the most severe one. &nbsp;When shipping, only errors that would leave the application in an unpredictable or dangerous state should result in an application crash&#8230; otherwise just only clean up what malfunctioned and try to give the user back control so they can restart the failed task.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927523">
				<div id="div-comment-927523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger Lipscombe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927523">
			July 29, 2011 at 7:24 am</a>		</div>

		<p>And why would I want the build that QA&#39;s testing to be different from the one I ship? That way, you&#39;re not actually testing what the customer gets. Sure, I&#39;d want the ability to get more diagnostics out of it, but I might need that in a production environment anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927533">
				<div id="div-comment-927533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CarlD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927533">
			July 29, 2011 at 7:26 am</a>		</div>

		<p>Surely &quot;the right thing&quot; also varies with the nature of the program, and the ability of the user to ascertain the impact of an error. &nbsp;For example, a simple bitmap editor like MSPaint has little &quot;live data&quot; other than a bitmap &#8211; and that entire bitmap is visible to the user. &nbsp;If a program error caused, for example, a circle to be drawn when a rectangle was requested, the user will recognize this and act according to their own needs and desires. &nbsp;They might try invoking the &quot;Undo&quot; operation &#8211; which might actually succeed. &nbsp;</p>
<p>I&#39;m generally not in favor of continuing after an error without at least giving the user a heads-up that something might be amiss, but I&#39;m willing to accept that there may be circumstances where doing so would in fact be acceptable behavior. &nbsp;I suspect those circumstances are a tiny minority.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927543">
				<div id="div-comment-927543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927543">
			July 29, 2011 at 7:30 am</a>		</div>

		<p>&quot;Isn&#39;t this backwards? Shouldn&#39;t we be more sensitive to problems with live data than problems with test data?&quot;</p>
<p>I don&#39;t see why you mention that here. Are you saying that assert() should not be used? Or that every kind of verification code must also be part of the released version?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927553">
				<div id="div-comment-927553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">creaothceann</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927553">
			July 29, 2011 at 7:35 am</a>		</div>

		<p>This is why I leave overflow checking etc. enabled even for release builds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927563">
				<div id="div-comment-927563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny Moules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927563">
			July 29, 2011 at 7:36 am</a>		</div>

		<p>@CarlD &quot;If a program error caused, for example, a circle to be drawn when a rectangle was requested&quot; And then tries to put data related to a rectangle into a circle object which causes an overflow causing junk to spill into unprotected memory and possibly corrupting the machine&#39;s permanent state meaning it won&#39;t boot&#8230;</p>
<p>I&#39;m not saying your point is moot but your example is certainly flawed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927583">
				<div id="div-comment-927583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bobmiddlbury1</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927583">
			July 29, 2011 at 8:02 am</a>		</div>

		<p>I always test the same application I am releasing, now thats just me.. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927593">
				<div id="div-comment-927593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927593">
			July 29, 2011 at 8:12 am</a>		</div>

		<p>@Gabe:</p>
<p>You are aware that if your error can affect your document, saving said document might very well persist the corruption already incurred? Remember: users are idiots. Rather than letting your users save it over the older non-corrupt copy, I&#39;d hope you&#39;d save to a special crashed-document file and implement a crash recovery modus that at least prevents users from nuking their own documents. (Word does this, for example.) If you don&#39;t, and just say &#39;AppX has encountered an unknown error and needs to be restarted. Please save your documents, yadayada.&#39;, users will blame you for telling them to save.. or if you were to leave that sentence out, they would blame you for giving them the chance to save a corrupted file over their good one.</p>
<p>If your car engine is very likely to blow up any minute now, would you want the car to just muzzle it up and play russian roulette without your knowing? Even if you could freeze to death outside the car in a matter of hours, I am sure it would be preferable to getting blown to pieces in an instant. The former gives one a chance of survival at least.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927603">
				<div id="div-comment-927603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927603">
			July 29, 2011 at 8:15 am</a>		</div>

		<p>Gabe:</p>
<p>Testing an application which is different from the user puts some uncertenty into it. It is like how sometimes bugs occurs only or release builds because the Debug CRT and Windows manages to stop the bugs manifesting in Debug builds. The same could happen with this situation. If the code written for QA happens to move the stack variables just ever so slightly, and a stack corruption bug occurs, then it could very well corrupt a different stack variable in the QA code than in the end user&#39;s code. This could completely hide the problem if it is a QA only variable or if it is a variable which gets set to a sane value after it is corrupted.</p>
<p>This is why I am for giving the QA team and the end users the exact same program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927613">
				<div id="div-comment-927613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/James-Sutherland/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>james@deadnode.org</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927613">
			July 29, 2011 at 8:44 am</a>		</div>

		<p>I&#39;ve seen a few people now advocating that the &#39;debug&#39; build of an application should, at least in most respects, be the released version as well. I&#39;m inclined to agree, too: if you put an assert(x!=NULL) in at some point, shouldn&#39;t you be checking for x being null in the released build too? Maybe it &quot;shouldn&#39;t&quot; happen &#8211; but then, it shouldn&#39;t have happened in the debug version either! Obviously you strip symbols out, things like that &#8211; but I would say error checking should very much stay in place in the release version too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927633">
				<div id="div-comment-927633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miles Archer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927633">
			July 29, 2011 at 9:59 am</a>		</div>

		<p>Power Plant Control Room software error strategies might need to be a little bit different from web browser error strategies, to state the obvious. (what Ian said)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927643">
				<div id="div-comment-927643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927643">
			July 29, 2011 at 11:51 am</a>		</div>

		<p>I should point out that I&#39;m advocating only that something NOT crash if it doesn&#39;t HAVE to. That&#39;s why your car has a &quot;limp home&quot; mode. The limp home mode doesn&#39;t keep the engine working when it&#39;s about to blow up; it keeps the engine working within safe parameters when something unexpected but noncatastrophic happens. If you&#39;re driving down a narrow mountain road and your engine decides to shut down because of a bad sensor reading, you&#39;ll probably die because your power steering and power brakes stop working.</p>
<p>I&#39;m merely suggesting that programs should also have a limp home mode. In fact, VS and IE frequently pop up error messages saying that some part of the program has caused an exception. I&#39;m always relieved when I can click the OK button and keep working!</p>
<div class="post">[<i>The difference is that with physical objects, you can perform physical isolation so that one broken part cannot affect another. But if somebody crashed with a bad pointer, you have no idea what else got corrupted before they crashed. (The software version of physical isolation is process isolation, which is what IE uses.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927653">
				<div id="div-comment-927653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zondrac</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927653">
			July 29, 2011 at 1:48 pm</a>		</div>

		<p>are people still using windows? lol</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927573">
				<div id="div-comment-927573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927573">
			July 29, 2011 at 7:45 am</a>		</div>

		<p>I would suggest that it&#39;s not actually backwards. The QA department is generally running your program for the express purpose of finding bugs, not for using the program for its intended purpose. If your program didn&#39;t crash for QA, there&#39;s no point in even having that department. On the other hand, your users are presumably using your program to get work done, not for finding bugs. Since crashing is generally the opposite of getting work done, I don&#39;t think there is much value in crashing for a user who is trying to actually *use* your program.</p>
<p>Of course, there&#39;s nothing wrong with taking action (logging the exception, showing an error dialog), but once the program has gotten to the user, you can&#39;t debug it anymore. If you find yourself actually debugging on a user&#39;s system then by all means put it in QA mode where it crashes instantly, but otherwise there&#39;s no point in giving a user an error that they can&#39;t do anything about.</p>
<p>Consider a car, for example. A car&#39;s engine computer detects a misfire, indicating a potential problem &#8212; who knows, maybe the engine is about to blow up. As a manufacturer, you can say that the car isn&#39;t mission critical; if it fails, a driver can use their cell phone to call for a tow truck to get the car looked at and in the mean time use a cab or rent a car. In reality, though, the car may be mission-critical to the driver. A driver could be driving along a dark country road where there&#39;s no help available, or driving in the middle of winter when it&#39;s so cold that an engine failure could mean the driver dies within hours, or driving down an evacuation route such that the stopped car causes thousands of people behind it to be unable to evacuate a natural disaster. So wouldn&#39;t you say that it&#39;s much better to log the exception, maybe turn on a &quot;check engine&quot; light, and keep going?</p>
<p>Similarly, you may not consider your program mission-critical, but your users might. If I&#39;m a reporter trying to get a story in, I&#39;ll be pretty upset if the word processor crashes just before deadline! I could even lose my job as a result. You may think that an error in the spellchecker could mean that the anything is corrupted and it&#39;s safer to just immediately shut down the whole program. I would say that I don&#39;t even care about the spell checker, so just shut that down and let me keep working. Now, that *could* mean that the error will somehow affect my document and cause untold problems, but crashing immediately will *also* affect my document and cause untold problems! If the problem could affect my data, just let me know so I can save my document and restart at least.</p>
<div class="post">[<i>If the car detects a misfire, then it knows that it encountered a misfire, and the engineers know the scope of damage a misfire can cause and can perform appropriate recovery. (Which might be &quot;log an error and keep going, but if it keeps happening, turn on the Check Engine light and go into safe mode&quot;). But what does a car do when <span style="text-decoration:underline;">the fuel injectors crash</span>? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927623">
				<div id="div-comment-927623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim Lyon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927623">
			July 29, 2011 at 8:55 am</a>		</div>

		<p>I always advise people design for errors with steps like the following:</p>
<p>1. Figure out how the user recovers if the system crashes. Implement it.</p>
<p>2. Figure out how the user recovers if your process crashes. For machines intended to run a single app, crashing the system may be the right answer.</p>
<p>3. Check the return code from *every* API call. Crash if someone returns an error code that you don&#39;t understand.</p>
<p>4. Having done (1) through (3), it&#39;s now your job to make sure that your program understands those error returns that are likely to be encountered in real life, if you can do something more useful than crashing.</p>
<p>(4) means that you&#39;ll probably code for ERROR_FILE_NOT_FOUND from an open call when the user typed a file name. It means that you almost certainly won&#39;t try to recover from an ERROR_INVALID_HANDLE return from close.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927693">
				<div id="div-comment-927693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927693">
			July 29, 2011 at 6:34 pm</a>		</div>

		<p>Incidentally, I&#39;ve managed some rather serious memory corruption in kernel mode before. It&#39;s surprising how well some things limp along despite damage to kernel file tables. I&#39;m convinced that most of the time you can limp on a bad pointer for quite awhile. But yeah, there&#39;s always that one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927703">
				<div id="div-comment-927703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927703">
			July 29, 2011 at 6:53 pm</a>		</div>

		<p>Btw, in 64-bit environment, does Windows reuse handles as frequent as before?</p>
<p>Say, if there&#39;s good chance that Windows will not reuse the handle within a day or even a month, wouldn&#39;t it make sense to allow the application to walk pass the error and just prompt whoever user to save things (as recovery copies like what JW said) as fast as possible and restart?</p>
<p>I recalled that 2 months ago, when my company&#39;s AD fails and cannot restarts, I found that since there&#39;s no new account records be added for a long time, it might be safe to delete the transaction log and rebuild it, and it works! Sometimes if your application can give us remains of whatever I was working on before the crash, we might be able to figure out what to do to recover the file or even application state before bad things happened.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927713">
				<div id="div-comment-927713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fritz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927713">
			July 30, 2011 at 9:54 am</a>		</div>

		<p>I actually get pushback from testers when I let unexpected exceptions go and let the program crash. &nbsp;Test automation is easier to write if the program doesn&#39;t crash. :) &nbsp;Of course, just because I get pushback from testers does not mean I put in blanket exception handling.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927723">
				<div id="div-comment-927723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927723">
			July 30, 2011 at 12:40 pm</a>		</div>

		<p>zondrac:</p>
<p>And what was the point of this post? But it is a well known fact that the top 3 Operating System usage is Windows in number 1, Mac OSx in number 2 and iOS (iPhone) in number 3. I suppose you are just some fanboy who doesn&#39;t like this.</p>
<p>Cheong:</p>
<p>How would stepping past the error help when the nature of the error is an AV because somehow the pointer to your data got corrupted? How would stepping past the error help when the error is that the data itself is corrupted. The fact is, at the point of error the program is in an inconsistant state and you just don&#39;t know what is good and what isn&#39;t. So if you do allow saving, you just can&#39;t guarantee that you can save or that the data you are saving is good.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927743">
				<div id="div-comment-927743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927743">
			July 30, 2011 at 2:51 pm</a>		</div>

		<p>Crescens2k: Do you have any statistical data to show whether data loss is more likely to occur by crashing or by continuing? If not, then why assume that crashing immediately is going to lead to less corruption?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927753">
				<div id="div-comment-927753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Christian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927753">
			July 31, 2011 at 2:53 am</a>		</div>

		<p>The principle to crash quickly once an access violation has happened or random address space is to be overwritten is fine. But it&#39;s not good if programmers apply this hard rule to .NET or similar environments: I find that most often these programms will continue to run fine after an exception. So every button handler or menu entry should simply wrap everything in a try/catch/log&amp;MsgBox.</p>
<p>And why would a native programm need to crash for every unexpected error code of any api function? It should just show a message and continue or abort the current function. The programmer cannot anticipate every error code and it&#39;s nice to be able to run a programm in an environment it was not meant for, e.g. an old app which does stuff only admins can do and which are not really necessary would continue to work or it might even work if some api is absent (think of a cd burning programm which fails somewhere because the codecs or the cd-labeling third party malware was uninstalled)</p>
<p>I would not like to see programms which force crashs upon me unless strictly necessary, but it really depends on the context</p>
<div class="post">[<i>You&#39;re confusing external errors (which you need to defend against) with internal logic errors (&quot;The program should never have gotten into this state&quot;). -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927763">
				<div id="div-comment-927763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Spock</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927763">
			July 31, 2011 at 7:55 am</a>		</div>

		<p>I continue to be amazed at the number of people who propose the &quot;let&#39;s keep running in an unplanned corrupted state&quot; approach. As if somehow crashing is worse than corrupting your data, or pouring molten steel on someones head. You can be a little more robust to unforeseen errors, but &quot;ignore them and continue&quot; is not one of the ways. Creating redundant processes, for example, is one such method. Now, an external factor may trigger the same bug in both processes, but you improve your reliability. Put those processes on two separate bits of hardware, and you have hardware redundancy too. Break your application up into separate processes depending on task and you improve your robustness further. Once something has gone bang in a process though, it&#39;s time to stop. When something falls off from under your car, it&#39;s not a good idea to just keep driving hoping everything will be ok.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927773">
				<div id="div-comment-927773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927773">
			July 31, 2011 at 9:49 am</a>		</div>

		<p>@Gabe: The second law of thermodynamics.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927783">
				<div id="div-comment-927783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927783">
			July 31, 2011 at 6:24 pm</a>		</div>

		<p>My point (and I think some others&#39;s too) is that if the resource (handles, memory regions, thread, etc.) is well compartmented, unexpected state of one region of application shouldn&#39;t require the whole application to restart. At the worst case your application should be able to just destory that part of application (or withhold any suspected used handle and prevent them to be reused) and restart that part at the user&#39;s choice to make it continue to run. Those suspected unreliable resources can be marked as &quot;defunct&quot; state and be reclaimed at the next reboot.</p>
<p>It&#39;s good to allow the user know which part of resource is still in &quot;known good&quot; condition and allow them to save the reliable work if they think it is appropiate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927793">
				<div id="div-comment-927793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Spock</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927793">
			August 1, 2011 at 1:06 am</a>		</div>

		<p>@Cheong</p>
<p>There is a simple practical way to compartmentalise your resources. The name for it in Windows is a &quot;process&quot;. If you receive an unexpected system exception in one of these compartments, it is perfectly expectable to destroy that component, and start it up again. In fact, the Windows operating system is very kind in giving you all sorts of guarantees about what happens to those resources in this case. To try and do the same from within a process is simply foolish, especially when you are simply re-inventing the operating system provided wheel.</p>
<p>As a simple example; if my process receives a memory access violation exception, is there any way I can safely continue? Do I have any way to know what parts of my heap/stack are now valid or invalid? No I do not! If the exception has occurred I must crash that process, or risk completely random behaviour. Well OK then, you might say, I will crash on memory access violations, but continue to run on others. Continue down this path and where does it logically lead? To creating a white list of exceptions that you can return to a known good state from. This is the only sane way to handle exceptions. Other than that, let the process crash. If you need to be robust in the face of crashes, then divide your application up in to relevant processes and restart them on a crash.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927803">
				<div id="div-comment-927803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927803">
			August 1, 2011 at 3:54 am</a>		</div>

		<p>@Spock: That wouldn&#39;t be a problem if windows wasn&#39;t 1000x slower than unix at starting processes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-927823">
				<div id="div-comment-927823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gechurch</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927823">
			August 1, 2011 at 7:42 am</a>		</div>

		<p>@640k</p>
<p>Windows takes, what &#8211; a couple of milliseconds to create a process. Even if that was, as you incorrectly state, 1000x slower than Unix it still wouldn&#39;t matter because it is so far below the threshold that humans can perceive. I guess if your process was crashing several per second this could conceivably be an issue, but if your process is crashing several times per second you&#39;ve got a lot bigger problems than how quickly Windows can restart your process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927863">
				<div id="div-comment-927863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim Lyon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927863">
			August 1, 2011 at 8:18 am</a>		</div>

		<p>Re FailFast:</p>
<p>My suggestions are based on two observations over the long term:</p>
<ol>
<li>If you die when an unexpected error occurs, the odds are much higher that the underlying bug will get fixed before you ship. Thereby sparing your customers the pain of finding it.</li>
<li>
<p>The &quot;muddle on regardless&quot; philosophy too often leads to systems entering the &quot;all lights on but nobody home&quot; state. It hasn&#39;t crashed, but isn&#39;t doing anything useful either. This usually results in a long delay before somebody reboots/restarts it, with the corresponding hit to availability.</p>
</li>
</ol>
<p>Remember, availability = MTBF / (MTBF + MTTR). One can argue that FailFast decreases MTBF (I don&#39;t believe it, but I understand the argument). However, in real life FailFast substantially decreases MTTR.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jader3rd even thread-even depth-1" id="comment-927893">
				<div id="div-comment-927893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jader3rd' rel='external nofollow' class='url'>jader3rd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927893">
			August 1, 2011 at 9:08 am</a>		</div>

		<p>Always crash immediatly (and get the proper report to the proper channels).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-927963">
				<div id="div-comment-927963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-927963">
			August 1, 2011 at 11:58 am</a>		</div>

		<p>Imagine what would happen if, whenever a mutation was found in a strand of DNA, an organism is immediately killed. You could easily argue that any particular corrupted gene could cause untold damage &#8212; it might cause an animal to grow a second head, or even make a person turn Evil! Any mutation must be stopped before the corrupt DNA gets a chance to propagate. If you need another such organism, just create a new one from scratch with fresh DNA, right?</p>
<p>Well, it turns out that mutations happen all the time. There are so many bits of DNA and each one is largely inconsequential. What are the odds that a mutation will actually express itself in a noticeable way? They&#39;re actually pretty slim. So if you killed all organisms with mutations, you&#39;d have essentially no organisms. The fact that there are so many organisms on the planet indicates that most mutations can be safely ignored.</p>
<p>In the same way, your process&#39;s address space has billions of bits in it. What are the odds that a few bad ones will cause corruption of user data without killing it, or that the corruption will propagate as the process continues to live? Remember, most bugs in your program are inconsequential &#8212; if they weren&#39;t, you&#39;d fix them. Heck, most bugs in your program probably haven&#39;t even been detected yet.</p>
<p>It&#39;s no longer kosher to keep running after an AV (like accessing a null pointer) due to the risk that the corrupted bits could cause your process to turn Evil, but even so, most null pointer problems are probably harmless. I base my claim on the frequency with which unhandled exception dialogs in JavaScript and .NET apps can be dismissed without causing problems.</p>
<div class="post">[<i>JavaScript and .NET contain frameworks which are designed to contain the damage of a bad pointer. (For example, a &quot;pointer to freed memory&quot; is impossible to generate in those environments. Well, okay, if you use interop you can cause arbitrary damage.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-928013">
				<div id="div-comment-928013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-928013">
			August 1, 2011 at 6:06 pm</a>		</div>

		<p>@Gabe: I&#39;d have to disagree with your argument too. If mutation to your DNA happens, for the most of time your immune system will kill the mutated cells first (i.e.: our body chooses &quot;fail fast&quot; strategy by default.</p>
<p>If mutated cell somehow survived the attack from immune system, you either successfully mutates, have deformed organs (not necessarily dead), or have cancer. Just to remind you that the possibility of successful mutation is much much lower than the other two.</p>
<p>On the other hand, killing abnormal process on a multiprocess application is like modern surgery &#8211; cutting abnormal parts out to save normal parts.</p>
<p>What I&#39;m unsure of, is that whether there&#39;s way to implement thread-based resource isolation because Windows favours multithreading more than multiprocessing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-928023">
				<div id="div-comment-928023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-928023">
			August 1, 2011 at 6:11 pm</a>		</div>

		<p>This reminds me of some code I ran into years ago. &nbsp;It looked kind of like this:</p>
<p>&nbsp;Dim SQL As String = &quot;Delete from Orders &quot;</p>
<p>&nbsp; &nbsp;SQL &amp;= GetWhereClause()</p>
<p>&#8230;</p>
<p>Private Function GetWhereClause() As String</p>
<p>&nbsp; &nbsp;Dim rv As String = &quot;&quot;</p>
<p>&nbsp; &nbsp;Try</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&#39;lots of code here.</p>
<p>&nbsp; &nbsp;Catch ex As Exception</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;MsgBox(ex.ToString)</p>
<p>&nbsp; &nbsp;End Try</p>
<p>&nbsp; &nbsp;Return rv</p>
<p>End Function</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-928083">
				<div id="div-comment-928083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Spock</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-928083">
			August 2, 2011 at 7:07 am</a>		</div>

		<p>@Gabe</p>
<p>For an interesting study comparing the Linux kernel with the ecoli bacteria genome see: <a rel="nofollow" target="_new" href="http://www.physorg.com/news192128818.html" rel="nofollow">http://www.physorg.com/news192128818.html</a>. The quick take home is that DNA is more reliable due to massive specialization (I.e. Zero code re-use), and enormous numbers of iterative cycles to have weeded out the issues. The specialization leaves the organism robust to mutation (as there are no generic routines), and obviously the &quot;billions&quot; of users (organisms) over billions of iterations (death/reproduction) weeds out the problems. Neither of these things are remotely pratical from a software development view point. I&#39;m always amazed at people that think &quot;evolution&quot; should be copied as a software development process. We don&#39;t have millions of years to get our products right, and our customers are none to pleased to take on the role of improving &quot;fitness&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-928543">
				<div id="div-comment-928543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-928543">
			August 3, 2011 at 12:33 am</a>		</div>

		<p>Raymond: As I said, continuing after an AV is no longer kosher like it was in Win3.x, but when you talk about &quot;errors&quot; or &quot;problems&quot; in general, things are different.</p>
<p>Cheong: Your immune system will only attack the mutated cell if it can detect the problem (i.e. the mutation is such that the cell appears to not be a part of you). Your immune system doesn&#39;t do a DNA comparison; it does something much more complicated like binding to proteins. The mutation would have to affect the proteins that your immune system recognizes in order for it to attack. The cell will only turn into cancer if the mutation is something that causes the cell to divide unchecked without triggering your immune system. A deformed organ is only going to happen if the right mutation happens before the organ is formed.</p>
<p>In reality, mutations happen all the time. You&#39;re constantly bombarded with radiation (cosmic rays, sunlight, decaying of isotopes like C14 and K40) that can cause DNA mutations. Most of those mutations will be in genes that have already expressed themselves, will never express themselves (most recessive traits), or will express in harmless ways.</p>
<p>An interesting experiment would be to write a program that flips random bits in the address space of some running app (say, a word processor), then see how long it takes before you notice. Then do it many, many times to see how often it results in a crash, how often it results in corruption of the file, etc. I&#39;m fairly confident that you will rarely notice it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-928783">
				<div id="div-comment-928783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110729-00/?p=10023#comment-928783">
			August 4, 2011 at 4:23 am</a>		</div>

		<p>Most people here are speculating only over bad pointers / access violations. Ok, it is very bad that C compilers don&#39;t support all the array index checking, overflow checking and value range checking, that Delphi can compile into the code. With this, many things are checked at runtime just like in managed code.</p>
<p>(Side note: Because &quot;string&quot; is a built-in managed type in Delphi, pointers for string-handling can be completely avoided. This is a very big advantage.)</p>
<p>Because all of this constant checking of everything indexed access and every assignment makes the programs slower and bigger, you can disable this checks in the release build.</p>
<p>This changes the point of view: During development, I do get AVs very seldom. Objects are referenced by pointers, so AVs *are* possible, but most of the time, there are index or range violations, or (because most of our programs are database-centric) database-related errors.</p>
<p>All this non-AVs don&#39;t leave the program in an unknown global state. If there is some bad array index, its really save to let the resulting ERangeError exception propagate to the top-level window procedure, where it is automatically catched and displayed.</p>
<p>(Of course, you must use try-finally constructs everywhere to free-up allocated resources. Try-catch is used seldom, and the exception should be reraised at the end of the exception handling code.)</p>
<p>Because AVs are extremly seldom, and most of the data is stored in a database (which usess referential and check constraints as much as possible), the policy is to let every exception propagate to the top level window. In most cases, the exception text is a big help in locating the bug (development) or in troubleshoting (customer support).</p>
<p>So its an fail-fast strategy, but its not crashing fast.</p>
<div class="post">[<i>That&#39;s a really big &quot;of course&quot; you stuck in parentheses there. Because it applies not only to you but also to all the libraries you consume. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>