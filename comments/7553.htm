<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (47)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-986813">
				<div id="div-comment-986813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986813">
			May 23, 2012 at 7:07 am</a>		</div>

		<p>Using GUIDs for randomness is like using a chainsaw to hammer in a nail.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-986823">
				<div id="div-comment-986823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986823">
			May 23, 2012 at 7:17 am</a>		</div>

		<p>@RP: Or a glass bottle or an old shoe (<a rel="nofollow" target="_new" href="http://weblogs.asp.net/alex_papadimoulis/archive/2005/05/25/408925.aspx" rel="nofollow">weblogs.asp.net/&#8230;/408925.aspx</a>).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-986843">
				<div id="div-comment-986843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986843">
			May 23, 2012 at 7:19 am</a>		</div>

		<p>Run the generated GUID through MD5 once.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-986853">
				<div id="div-comment-986853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986853">
			May 23, 2012 at 7:20 am</a>		</div>

		<p>Man!. Who uses a guid for anything but a guid!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-986863">
				<div id="div-comment-986863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986863">
			May 23, 2012 at 7:45 am</a>		</div>

		<p>If one wants unpredictable values, using a type-4 GUID that is generated by a cryptographically random method should be fine, though, right? So a customer asking for the generation algorithm for a particular GUID generator function seems like a perfectly reasonable question. An answer of &quot;pseudo-random enough so that they&#39;re unique, not random&quot; is a good answer, meaning that they&#39;d then look for a different generating function that had a &quot;cryptographically random&quot; answer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-986873">
				<div id="div-comment-986873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Charlie Schmidt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986873">
			May 23, 2012 at 7:45 am</a>		</div>

		<p>Anyone know if this invalidates the commonly given advice that using &quot;ORDER BY NEWID()&quot; in T-SQL for returning the query in a random order? &nbsp; I&#39;m sure its close enough for government work, but any thoughts?</p>
<p><a href="http://stackoverflow.com/questions/191342/random-record-from-a-database-table-t-sql" target="_new" rel="nofollow">stackoverflow.com/&#8230;/random-record-from-a-database-table-t-sql</a> for example</p>
<div class="post">[<i>The <a href="http://msdn.microsoft.com/library/aa276822.aspx" rel="nofollow">example in the documentation</a> gives a result that is of type D. So it&#39;s not guaranteed to be type 4. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-986883">
				<div id="div-comment-986883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986883">
			May 23, 2012 at 7:48 am</a>		</div>

		<p>@pc: I&#39;d argue that anyone wise enough to even ask the question &quot;Is the type-4 GUID generation algorithm cryptographically random?&quot; would also be wise enough to avoid GUIDs in the first place and go straight to a cryptographic RNG.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-986893">
				<div id="div-comment-986893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986893">
			May 23, 2012 at 7:55 am</a>		</div>

		<p>I have code that uses Java&#39;s java.util.UUID.randomUUID() to make an identifier that I would expect would not be predictable by others. I think this is fine because the documentation says that it&#39;s cryptographically strong, and should have enough bits of entropy for our purposes. I suppose it could use a different cryptographically random generator, but it was quick, easy, and should be fine. Though a comment there saying that it&#39;s only okay since it&#39;s a cryptographically secure generator might be a wise note to somebody looking at it in the future.</p>
<div class="post">[<i>If your GUID generator is documented as being cryptographically strong, then that&#39;s great! But GUIDs in general are not. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-986903">
				<div id="div-comment-986903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/skgtefe_4000_live.ucl.ac.uk/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>skgtefe@live.ucl.ac.uk</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986903">
			May 23, 2012 at 8:08 am</a>		</div>

		<p>@alegr1: Predictable GUID in = predictable MD5 hash out. It&#39;s still not random, I&#39;m not sure what you&#39;re trying to achieve.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-986913">
				<div id="div-comment-986913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986913">
			May 23, 2012 at 8:34 am</a>		</div>

		<p>E Featherstone: If I can look at your GUID and figure out your MAC address and timestamp, it&#39;s trivial to guess what other GUIDs you might have generated. If I can only see an MD5 hash of your GUID, I can&#39;t make any assumption about what your MAC address is or when it was generated, so I can&#39;t predict other GUIDs in the series.</p>
<p>That said, I recently generated a GUID for use as a password. Since it was type 4 and used in isolation, there&#39;s no chance of predicting another password based on it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-joshuaganes even thread-even depth-1" id="comment-986923">
				<div id="div-comment-986923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Joshua+Ganes' rel='external nofollow' class='url'>Joshua Ganes</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986923">
			May 23, 2012 at 8:41 am</a>		</div>

		<p>RP and Adam Rosenfield &#8211; I liken it more to using a sledge hammer to drive finishing nails. If you do everything just right, it could work. It&#39;s easy to mess it up and create some big holes. There&#39;s a much better tool for that. Why not use it instead?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-986933">
				<div id="div-comment-986933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986933">
			May 23, 2012 at 8:52 am</a>		</div>

		<p>@pc:</p>
<p>&quot;If one wants unpredictable values, using a type-4 GUID that is generated by a cryptographically random method should be fine, though, right?&quot;</p>
<p>If you have access to a cryptographically strong RNG then why use it to create a GUID? Just generate a random number from it and use that. (I&#39;m assuming of course that software is sensible and access to the RNG isn&#39;t restricted in some way.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-986953">
				<div id="div-comment-986953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeffdav</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986953">
			May 23, 2012 at 9:27 am</a>		</div>

		<p>I found this code once in a project that shall remain nameless:</p>
<p>DWORD SHRandom() {</p>
<p>&nbsp;GUID g = CoCreateGuid();</p>
<p>&nbsp;string s = GuidToString(g);</p>
<p>&nbsp;return HashData(s);</p>
<p>}</p>
<p>(Pseudocode because I&#39;m pre-coffee.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-986983">
				<div id="div-comment-986983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986983">
			May 23, 2012 at 10:13 am</a>		</div>

		<p>@Maurits: That&#39;s just a variation of the Fisherâ€“Yates Shuffle. &nbsp;It&#39;s equivalent to starting with an array of N 1&#39;s and (M-N) 0&#39;s and shuffling that, just with slightly different bookkeeping.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987003">
				<div id="div-comment-987003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987003">
			May 23, 2012 at 12:12 pm</a>		</div>

		<p>@PC Seems like quite the unnecessary complicated way to use the perfectly simple SecureRandom class in Java. Although I assume if you needed a string representation, it saved you converting it to base64 and since Java&#39;s support for that is a bit weak (well Java5 does have it built in, but not in an especially obvious place), I can actually understand that.</p>
<p>But then Fisher-Yates is a trivial algorithm that really anybody with a CS degree should&#39;ve heard of, so the whole &quot;generate random numbers and sort it&quot; approach is quite worrying. Heck most sensible languages have a shuffle implementation in their standard library.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987013">
				<div id="div-comment-987013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987013">
			May 23, 2012 at 12:23 pm</a>		</div>

		<p>You all are so silly. :) &nbsp;Just use the cryptographically secure random number generator and move on with life!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-986943">
				<div id="div-comment-986943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-986943">
			May 23, 2012 at 8:56 am</a>		</div>

		<p>The assign-a-random-number-to-each-element-then-sort trick is clever, but it has two potential weaknesses (even assuming that the random number generator has sufficient strength for the application.)</p>
<p>1) There&#39;s a non-zero probability of collisions.</p>
<p>2) It&#39;s kinda slow (O(M log M) for the sort.)</p>
<p>Here&#39;s another algorithm which is O(M)</p>
<p>// left as an exercise</p>
<p>// returns a random number uniformly distributed between 0 and 1</p>
<p>float rand01();</p>
<p>// chosen is an array of M bools, all initially set to false</p>
<p>// on exit, precisely N of the bools are set to true</p>
<p>// all (M choose N) arrangements are equally likely</p>
<p>// it is assumed that 0 &lt;= N &lt;= M</p>
<p>void chooseNofM(bool *chosen, int M, int N) {</p>
<p>	for (; N; chosen++, M&#8211;) {</p>
<p>		// choose the element we&#39;re looking at</p>
<p>		// with probability N/M</p>
<p>		if (M * rand01() &lt;= N) {</p>
<p>			*chosen = true;</p>
<p>			N&#8211;;</p>
<p>		}</p>
<p>	}</p>
<p>}</p>
<p>If M is large and N is small, there are other algorithms that are better.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-987063">
				<div id="div-comment-987063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987063">
			May 23, 2012 at 8:06 pm</a>		</div>

		<p>@Adam: That&#39;s an awesome article.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com even thread-even depth-1" id="comment-987073">
				<div id="div-comment-987073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987073">
			May 23, 2012 at 8:18 pm</a>		</div>

		<p>So do GUIDs generated by GUIDGen.exe happen to be secure?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-987023">
				<div id="div-comment-987023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987023">
			May 23, 2012 at 4:01 pm</a>		</div>

		<p>To be fair:</p>
<p>Fisher-Yates may look trivial, but it&#39;s quite easy to get wrong in subtle ways. &nbsp;You can end up with a shuffler where any given element is equally likely to end up in any finishing position, but yet where some ending combinations are more likely than others.</p>
<p>Worse, it can be quite difficult to tell whether the implementation is correct just by looking at the code, since correct code looks very similar to subtly-wrong code.</p>
<p>So the &quot;sort by a random tag&quot; algorithm has the benefit of being *obviously* correct.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987053">
				<div id="div-comment-987053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987053">
			May 23, 2012 at 4:28 pm</a>		</div>

		<p>@Maurits Huh? I mean Fisher-Yates is a 3liner, with the only important thing to not swap values that have already been set. Yes you can get it wrong by allowing to swap every number, but then the only interesting thing of the algorithm is the statistical analysis why you may not do that (which is not completely intuitive), so I&#39;d hope that&#39;d stick in mind. But yes, *testing* whether the algorithm is correct is always a problem for these things.</p>
<p>And as we can see you can get the &quot;add random tag to data&quot; algorithm wrong as well &#8211; although I agree you have to work a bit harder there ;)</p>
<div class="post">[<i>Fisher-Yates assumes a continuously uniform random number generator, which does not exist in reality. If M/N &gt; <code>RAND_MAX</code>, then there are some people who will never be selected, and even if you are well under <code>RAND_MAX</code>, the selection will not be perfectly fair. (For example, if <code>RAND_MAX = 32767</code> and there are 16383 people, then one unlucky guy will be called to jury duty twice as often as his peers.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987123">
				<div id="div-comment-987123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987123">
			May 24, 2012 at 4:03 am</a>		</div>

		<p>The point of Fisher-Yates is that it attempts to uniformly choose one of M!/(M-N)! permutations. A common error is to generate M^N permutations and then map them to one of the M!/(M-N)! permutations. Of course, if your random number generator isn&#39;t up to uniformly choosing one of M!/(M-N)! permutations then you&#39;re going to fail anyway, but at least with Fisher-Yates you&#39;re not adding your own bias to that of your random number generator.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987133">
				<div id="div-comment-987133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CodesInChaos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987133">
			May 24, 2012 at 5:21 am</a>		</div>

		<p>TC is right. Even with cryptographic PRNGs predicting the output from the internal state is possible. But you can&#39;t efficiently find out that internal state by just observing outputs. To avoid this predictability you need to reseed regularly from real entropy.</p>
<p>My main doubt about the windows GUID creator is that it&#39;s unclear how private it is. AFAIK MS switched to V4 GUIDs to avoid the MAC-Address and creation time leak from V1 GUIDs. But depending on what is used to seed the PRNG, there might be privacy issues even with random looking V4 GUIDs. I&#39;m not aware of any documentation clearly stating what privacy related guarantees the generator has.</p>
<p>So my recommendation is to create your own V4 GUIDs based on <code>CryptGenRandom</code> / <code>RNGCryptoServiceProvider</code>.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987103">
				<div id="div-comment-987103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987103">
			May 23, 2012 at 10:59 pm</a>		</div>

		<p>&gt; &quot;The Wikipedia article for GUID contains primary research which suggests that future and previous GUIDs can be predicted based on knowledge of the random number generator state, since the generator is not cryptographically strong.&quot;</p>
<p>Is that what it actually says?</p>
<p>It says: &quot;Cryptanalysis of the WinAPI GUID generator shows that, since the sequence of V4 GUIDs is pseudo-random, given full knowledge of the internal state, it is possible to predict previous and subsequent values.&quot;</p>
<p>Surely if you know a PRNG&#39;s internal state, you can predict all of its the following outputs &#8211; even if it is cryptographically secure (ie. a CSPRNG)? Whereas the difference between a normal PRNG, and a cryptographically secure PRNG (CSPRNG), as I understand it, is whether you can or can&#39;t predict the next output(s) from some number of *previous outputs* &#8211; not from a &quot;full knowledge of the generator&#39;s internal state&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987173">
				<div id="div-comment-987173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RandomsArentGuids</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987173">
			May 24, 2012 at 10:24 am</a>		</div>

		<p>I like the corollary &#8211; random numbers aren&#39;t GUIDs. I&#39;ve seen developers generate really long random numbers and then call those &quot;GUIDs&quot;. When told that that is not a GUID, the response is &quot;it&#39;s unlikely for there ever to be a collision, so it&#39;s good enough&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf odd alt thread-odd thread-alt depth-1" id="comment-987193">
				<div id="div-comment-987193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987193">
			May 24, 2012 at 11:53 am</a>		</div>

		<p>What I don&#39;t get is is WHY a GUID has to be &quot;secure&quot; and &quot;such that it&#39;s impossible to predict the next one.</p>
<p>It may be because I have only ever used them for COM, but to me these &quot;security&quot; issues sound like someone is using a GUID as something else than an ID.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-andycadley2 even thread-even depth-1" id="comment-987263">
				<div id="div-comment-987263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/AndyCadley' rel='external nofollow' class='url'>AndyCadley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987263">
			May 24, 2012 at 1:58 pm</a>		</div>

		<p>@xpclient: Only if you constantly reassure them that they&#39;re fine as children.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987293">
				<div id="div-comment-987293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987293">
			May 24, 2012 at 3:43 pm</a>		</div>

		<p>@Raymond True, so you need at least Log2(N!/(M-N)!) bits of internal state in your generator, because otherwise one can obviously not generate all possible permutations. That&#39;s quite a large number for even small sets &#8211; hush, that&#39;s why I don&#39;t implement statistical libraries ;)</p>
<p>Not sure about your example though: Yes, just taking the modulo will result in biased values, but we don&#39;t have to use <code>nextRand() % maxSize</code> to produce a number (although even the correct solution that doesn&#39;t introduce bias, still reduces the internal state a bit, so it&#39;s back to point 1)</p>
<p>Still the algorithm is simple to implement correctly &#8211; it may just not do what one would hope it to.. those &quot;bugs&quot; are much worse to find in practice though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987313">
				<div id="div-comment-987313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Buchan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987313">
			May 24, 2012 at 4:43 pm</a>		</div>

		<p>@RandomsArentGuids: Actually, a 128-bit random number from a high-quality RNG is perfectly suitable as a unique ID (but don&#39;t call it a GUID, cause it&#39;s not).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987333">
				<div id="div-comment-987333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987333">
			May 24, 2012 at 6:49 pm</a>		</div>

		<p>This reminds me of a &quot;classic&quot; post by Jeff Atwood:</p>
<p><a rel="nofollow" target="_new" href="http://www.codinghorror.com/blog/2007/12/shuffling.html" rel="nofollow">http://www.codinghorror.com/&#8230;/shuffling.html</a></p>
<p>Specifically the bottom bit:</p>
<blockquote><p>
  We&#39;ll just sort by a random number&#8211; in this case, a GUID.</p>
<p>  var cards = Enumerable.Range(0, 51);</p>
<p>  var shuffledcards = cards.OrderBy(a =&gt; Guid.NewGuid());
</p></blockquote>
<p>Unfortunately for Jeff&#39;s readers, he doesn&#39;t follow Raymond&#39;s good example of reminding everyone that what he posts is not designed to be copy-pasta&#39;d into production code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-987343">
				<div id="div-comment-987343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987343">
			May 24, 2012 at 6:57 pm</a>		</div>

		<p>@Simon Buchan: A truly random number generator has to have some chance of generating the same number consecutively (because each number is generated independently, you cannot deny the chance of (1/n)^2 the same number be produce on consecutive trials, where n is the number of possible outputs. Granted the chance is small, it&#39;s not impossible.). So by defination, a good RNG is not a suitable source of unique number unless you put additional measure to prevent that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-987393">
				<div id="div-comment-987393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987393">
			May 24, 2012 at 8:25 pm</a>		</div>

		<p>I thought this problem sounded familiar &#8211; it&#39;s the subject of Column 12 and Column 13 in Jon Bentley&#39;s classic &quot;Programming Pearls&quot; (an excellent book.)</p>
<p>The &quot;better algorithm&quot; (better than Fisher-Yates, in particular) he gives for the case when N is much less than M is as follows:</p>
<p>set&lt;int&gt; S;</p>
<p>while (S.size() &lt; N) s.insert(randomly selected item);</p>
<p>// where s.insert is given to be a no-op if the element is already in the set.</p>
<p>Note that a conspiratorial random number generator can make this into an infinite loop, but under the assumption that N is much less than M this will almost surely run in O(M log M) time and use O(M) space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-987403">
				<div id="div-comment-987403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987403">
			May 24, 2012 at 9:30 pm</a>		</div>

		<p>er, I mean O(N log N) time and O(N) space, of course (Bentley reverses N and M and I confused myself)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987413">
				<div id="div-comment-987413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Buchan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987413">
			May 24, 2012 at 10:07 pm</a>		</div>

		<p>@cheong00: OK, so now go compute how many GUIDs it would take to make collision feasible, and how many it&#39;s feasible to generate before programming is obsolete :). There&#39;s a reason type 4 GUIDs are just RNG output other than the type tag.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-987443">
				<div id="div-comment-987443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987443">
			May 25, 2012 at 12:10 am</a>		</div>

		<p>@Simon Buchan: Since all generations are random, you can just get two random numbers once and found they are the same. The &quot;number of generation to make it feasible&quot; is irrelevent (or I should say, incorrect fundamentally), it is the &quot;number of generation to make sure it&#39;s impossible to NOT collide&quot;. Statistical randomness need to ensure no recognisable pattern in number it generated, and we know uniqueness is a known pattern. So if you run 65536 trials to such a RNG, you can predict to see some number have zero counts, most has one and a few has two or even three occurance.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-987453">
				<div id="div-comment-987453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987453">
			May 25, 2012 at 12:12 am</a>		</div>

		<p>Oh, I&#39;ve forgotten to add the condition of &quot;16-bit strength&quot; to my last comment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-987483">
				<div id="div-comment-987483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987483">
			May 25, 2012 at 12:57 am</a>		</div>

		<p>@Nick: This looks like the sort key of a given item would vary over time, which is a big no-no (IIRC, the CRT throws or asserts when it encounters that). Was that the point?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987533">
				<div id="div-comment-987533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987533">
			May 25, 2012 at 4:56 am</a>		</div>

		<p>@cheong00: &quot;Since all generations are random, you can just get two random numbers once and found they are the same.&quot;</p>
<p>Yes, with a 1 in $BIGNUM (excuse me, that&#39;s $BIGBIGBIGNUM) probability! &nbsp;Who cares?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987553">
				<div id="div-comment-987553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987553">
			May 25, 2012 at 7:31 am</a>		</div>

		<p>The original problem is about shuffling a jury pool, so there is no need for cryptography, passwords or any such thing. If using C/C++, rand() would work just fine. Just walk the list, exchanging each entry with a random entry. No need to sort or actually assign a number.</p>
<div class="post">[<i>It may not need to be cryptographically secure, but it definitely needs to be unbiased. The jury pool probably exceeds the resolution of <code>rand()</code>, so you&#39;re going to have systematic bias in your selection. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-987613">
				<div id="div-comment-987613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987613">
			May 25, 2012 at 8:44 am</a>		</div>

		<p>This gives me an idea for an interview question: using a rand() function with RAND_MAX = 32767, write a function which returns 1, 2, or 3 with equal probability.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987673">
				<div id="div-comment-987673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987673">
			May 25, 2012 at 11:06 am</a>		</div>

		<p>@Maurits: Not to toot my own horn, but see <a rel="nofollow" target="_new" href="http://stackoverflow.com/questions/137783/expand-a-random-range-from-1-5-to-1-7/" rel="nofollow">stackoverflow.com/&#8230;/expand-a-random-range-from-1-5-to-1-7</a> for some interesting solutions to that (several correct, many wrong) with different numbers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987503">
				<div id="div-comment-987503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987503">
			May 25, 2012 at 4:10 am</a>		</div>

		<p>@Raymond, Can I suggest that you fix the error that I pointed out in your summary of the Wikipedia article?</p>
<p>&gt; &quot;The Wikipedia article for GUID contains primary research which suggests that future and previous GUIDs can be predicted based on knowledge of the random number generator state, since the generator is not cryptographically strong.&quot;</p>
<p>Wrong. The predictability does not occur because the generator is not cryptographically strong. Nor does the referenced article say that. It occurs because if you can obtain the full internal state of *any* PRNG &#8211; cryptographically strong or otherwise &#8211; you can certainly predict all following outputs, and possible the previous ones.</p>
<p>So an accurate summary would be more like this: &quot;The Wikipedia article for GUID contains primary research which suggests that the sequence of V4 GUIDs is pseudo random, ie. based on a deterministic PRNG. Therefore, given full knowledge of the internal state, it is possible to predict all previous and subsequent values.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-987683">
				<div id="div-comment-987683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987683">
			May 25, 2012 at 11:36 am</a>		</div>

		<p>Interesting indeed.</p>
<p>I notice that:</p>
<p>5^1 mod 7 = 5 but is less than 7 so we can&#39;t use that</p>
<p>5^2 mod 7 = 4 so we have 4 &quot;repeat&quot; results</p>
<p>5^3 mod 7 = 6 so we have 6 &quot;repeat&quot; results</p>
<p>5^4 mod 7 = 2 so we have 2 &quot;repeat&quot; results</p>
<p>5^5 mod 7 = 3 so we have 3 &quot;repeat&quot; results</p>
<p>5^6 mod 7 = 1 so we have only one &quot;repeat&quot; result</p>
<p>5^7 mod 7 = 5 and it repeats from there</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987723">
				<div id="div-comment-987723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CodesInChaos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987723">
			May 26, 2012 at 6:03 am</a>		</div>

		<p>@cheong00 &nbsp;</p>
<p>You can&#39;t distinguish &quot;impossible&quot; from &quot;extremely unlikely&quot; in this universe. That distinction only exists in mathematics.</p>
<p>You can&#39;t construct a computer that always gives the same result. And you can&#39;t construct a computer which produces two random numbers of sufficient length that happen to collide. Random errors happen, you can just make them so unlikely it doesn&#39;t matter.</p>
<p>There are some situations where random 128 bit numbers have a non negligible chance of happening. It&#39;s unique enough for many applications, but there are many scenarios where it&#39;s not enough.</p>
<p>256 bit collisions are already almost impossible for several decades even using all the computational power of earth. That&#39;s the level you practically use if a powerful adversary can create many ids, and wins if any pair of them collides.</p>
<p>And finally barring major advances of technology(say the invention of reversible computing, or humanity becoming a type III civilization), 512 bit random numbers are unique enough forever.</p>
<p>So I disagree with you. Random numbers make fine unique numbers, as long as you make sure they&#39;re long enough for your use-case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987743">
				<div id="div-comment-987743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@CodesInChaos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987743">
			May 26, 2012 at 10:46 am</a>		</div>

		<blockquote><p>
  &gt;You can&#39;t construct a computer that always gives the same result.&lt;&lt; If so than the hardware is broken. If you mean that aspects of software execution may depend on timing, then its a property of this software (if undesired then its a bug), not a philosophical principle. I expect my washing machine to always do the same thing in the same situation, no matter what.
</p></blockquote>
<p>If you need a unique identifier as primary key for something, better do not use pure random numbers. Otherwise, the random collisions can cause absolute &quot;impossible&quot; behavior.</p>
<p>Do you propose to use your principle for software used to control vital functions of a nuclear power plant? Really?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-987773">
				<div id="div-comment-987773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CodesInChaos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987773">
			May 27, 2012 at 8:34 am</a>		</div>

		<blockquote><p>
  &gt;You can&#39;t construct a computer that always gives the same result.</p>
<p>  If so than the hardware is broken.
</p></blockquote>
<p>In that case there is no computer that isn&#39;t broken. You can make the error probability very small, but not absolutely zero. Cosmic ray hits your RAM, flips a bit,&#8230;</p>
<p>Random numbers are perfectly fine for unique ids, if you&#39;re sure that the RNG is good enough. In practice PRNGs are often seeded badly, so I&#39;d be very careful. But if I were sure that the RNG is good enough, and the random number large enough, I wouldn&#39;t hesitate to bet critical functions on it.</p>
<p>The chances of a bug or random hardware failure are so much larger than the chance that two independently generated 512 bit numbers are the same, that I certainly wouldn&#39;t worry about that.</p>
<p>Also what alternative schemes for ID generation do you propose that are more robust? Most other schemes require some persistent state keeping track of which IDs to produce. It&#39;s very easy to make a mistake when managing this, for example when cloning a VM or restoring from backup. I&#39;m sure that the chances of such failures are much larger than random number collisions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-987793">
				<div id="div-comment-987793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120523-00/?p=7553#comment-987793">
			May 27, 2012 at 8:49 pm</a>		</div>

		<p>Medinoc: The sort key for an item is computed only once, so even a random key won&#39;t change during the sort operation.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>