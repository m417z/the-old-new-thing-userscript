<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (25)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1319585">
				<div id="div-comment-1319585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319585">
			January 3, 2018 at 7:08 am</a>		</div>

		<p>And, as many folks know, &#8221; a 32-bit value representing &#8230; seconds since January 1, 1970 UTC&#8221; is the traditional &#8220;Unix time&#8221; that has been abandoned by everyone who remembers &#8220;Y2K&#8221;.  It will be rolling back to 1970 in about 20 years.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-jeremytais odd alt depth-2" id="comment-1319595">
				<div id="div-comment-1319595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/SimonRev' rel='external nofollow' class='url'>SimonRev</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319595">
			January 3, 2018 at 7:13 am</a>		</div>

		<p>Actually, as it is a signed 32 bit integer, it will be rolling back to 1902 or somewhere thereabouts.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-odd thread-alt depth-1 parent" id="comment-1319596">
				<div id="div-comment-1319596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319596">
			January 3, 2018 at 7:29 am</a>		</div>

		<p>at least as of n4659 6.5.3.3 says: <i>An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage. All other namespaces have external linkage.</i> I know that MSVC didn&#8217;t use to respect this but as far as I&#8217;m aware as of VS 2013 this was being respected IIRC.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1319616">
				<div id="div-comment-1319616" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319616">
			January 3, 2018 at 8:14 am</a>		</div>

		<p>And I am quite sure that Windows is not built using MSVC. It might be something based on MSVC, but the compiler would be different for internal consumption only.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1319645">
				<div id="div-comment-1319645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319645">
			January 3, 2018 at 9:14 am</a>		</div>

		<p>As far as I am aware, the NT kernel (and I could list the other important bits of Windows, but I won&#8217;t) are indeed built by the compiler that sits underneath MSVC.  And tested against that compiler.  And indeed debugged against that compiler (I have done this on occasion).</p>
<p>I&#8217;m not entirely sure why anybody would think otherwise.  The timelines might be different: my group was stuck on VS10 for quite a lot of years, mostly because the tool-set for builds hadn&#8217;t caught up and/or been signed off, and the actual build tools are based on the command line rather than on a GUI (this is hardly a surprise), but &#8212; nope, the compiler is the compiler.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-koldude odd alt depth-4" id="comment-1319675">
				<div id="div-comment-1319675" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319675">
			January 3, 2018 at 9:33 am</a>		</div>

		<p>Peeking at the headers for ntdll and gdi32 it shows the linker version as 14.10 which would be a VS2013 update, as far as I know the external linkage for unnamed namespaces was fixed prior that version (I removed a lot of <code>static</code> function prefixes when I migrated and verified this wasn&#8217;t happening any more). I would not be surprised if insider builds are testing against newer compiler versons. Even windows devs want new C++ features. Given that parts of the vNext release SDK depends on compiler version 15.3 or later (c++ coroutines in the CppWINRT sdk components) this may be changing.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1319667">
				<div id="div-comment-1319667" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319667">
			January 3, 2018 at 9:29 am</a>		</div>

		<p>Okay, then lambdas. Or template functions which take as type parameters types in unnamed namespaces.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1319605">
				<div id="div-comment-1319605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319605">
			January 3, 2018 at 7:39 am</a>		</div>

		<p>I&#8217;m curious about the reason behind needing reproducible builds, given all the challenges involved. Is it a trust thing, where somebody has audited a particular version of the source code, and needs to make sure that they can create the same compiled bits that are deployed somewhere? If so, I think you&#8217;d need a compiler that was also made from a reproducible build, preferably at least two from different vendors so that you can check their work with each other to ensure that there isn&#8217;t anything nefarious hidden inside the compiler.</p>
<p>Seems like quite the challenge, though I know some fields (gambling machines, cryptocurrency back-ends, and so forth) find it worth the hassle.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1319615">
				<div id="div-comment-1319615" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319615">
			January 3, 2018 at 8:12 am</a>		</div>

		<p>One example is the gaming (gambling) industry.  Gaming machines (slot machines, etc.) get their software certified by a commission who tests that the software is &#8220;fair&#8221;.  Any change to that software must be recertified (which is an expensive process).  As a result, you need a way to rebuild the same source into a PE file with the same hash as the original build.  I assume there are other industries with similar rules</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1319625">
				<div id="div-comment-1319625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319625">
			January 3, 2018 at 8:16 am</a>		</div>

		<p>Reproducible outputs also have the side effect of ensuring compiler always hits the same bug, in case it has any.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1319665">
				<div id="div-comment-1319665" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319665">
			January 3, 2018 at 9:18 am</a>		</div>

		<p>Which makes it massively easier to debug the problem, reason about the bug, and fix it.</p>
<p>Sans a provably bug-free release of any program whatsoever, I can&#8217;t see why you feel this is a worrying feature.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1319975">
				<div id="div-comment-1319975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319975">
			January 5, 2018 at 9:59 pm</a>		</div>

		<p>How did you arrive at the conclusion that I think it is a worrying feature? It is a very good feature.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1319627">
				<div id="div-comment-1319627" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319627">
			January 3, 2018 at 8:30 am</a>		</div>

		<p>Right. I guess what I was asking was whether they needed to do this because there are, for example, some slot machine manufacturers that want their product to run on Windows 10, though I suppose that&#8217;s not a question that I&#8217;m going to actually get an answer to here.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1319636">
				<div id="div-comment-1319636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.differentpla.net/' rel='external nofollow' class='url'>Roger Lipscombe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319636">
			January 3, 2018 at 9:11 am</a>		</div>

		<p><a href="https://reproducible-builds.org/" rel="nofollow">https://reproducible-builds.org/</a> has a pretty good explanation of the motivation behind reproducible builds: primarily that you can be sure that a given set of binaries comes from a given set of source files (and toolchain). If the binary changes each time you rebuild the source (even if it&#8217;s unchanged), you lose the ability to make that determination.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1319655">
				<div id="div-comment-1319655" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319655">
			January 3, 2018 at 9:17 am</a>		</div>

		<p><a href="https://www.chromium.org/developers/testing/isolated-testing/deterministic-builds" rel="nofollow">Reproducible builds are essential for build caches</a> and <a href="http://blog.paranoidcoding.com/2016/04/05/deterministic-builds-in-roslyn.html" rel="nofollow">reducing testing time</a>. Hash all the inputs to a build tool, see if you&#8217;ve built that thing already, if so, then grab the precompiled result. Consider: You added a #define to windows.h, so every C file needs to recompile, but almost nobody uses that #define, so the OBJ files are nearly all the same, and therefore you still get tons of cache hits on the linker. And nearly all of the resulting EXEs are byte-for-byte identical, so you don&#8217;t need to re-test them. If the output of the compiler were not reproducible, then you wouldn&#8217;t get a cache hit on the OBJ files, and you end up having to rebuild and re-test the entire system, for a #define that almost nobody uses!</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1319685">
				<div id="div-comment-1319685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319685">
			January 3, 2018 at 9:46 am</a>		</div>

		<p>Wow, that&#8217;s interesting.  I hadn&#8217;t thought of those aspects &#8212; not having to re-test binaries that are byte-identical with a tested binary.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1319705">
				<div id="div-comment-1319705" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319705">
			January 3, 2018 at 12:54 pm</a>		</div>

		<p>Thank you very much for the reply. I was trying to figure out if there was any motivation beyond just the legal/trust ones, and those links show me that there&#8217;s a lot with the build process of large systems that can benefit.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1319715">
				<div id="div-comment-1319715" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319715">
			January 3, 2018 at 5:52 pm</a>		</div>

		<p>Same here.  In the security field we specifically want non-reproducible builds, or at least builds that are as different to each other as possible, because having everything laid out exactly identically in each build of a binary makes things much easier for attackers.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1319765">
				<div id="div-comment-1319765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319765">
			January 4, 2018 at 8:59 am</a>		</div>

		<p>You also want that when building DirectX for the xbox, to prevent someone from patching the games to use desktop windows dll&#8217;s</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1320245">
				<div id="div-comment-1320245" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://ted.mielczarek.org/' rel='external nofollow' class='url'>Ted Mielczarek</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1320245">
			January 9, 2018 at 10:41 am</a>		</div>

		<p>On top of what everyone else has said, we&#8217;ve found that for our work on Firefox having a reproducible build makes reasoning about changes to the build much easier. If you can generate the same exact binaries from the same source, then you can diff the build outputs when you make changes to the build and you don&#8217;t get lost in a sea of noise.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1319725">
				<div id="div-comment-1319725" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319725">
			January 4, 2018 at 2:44 am</a>		</div>

		<p>This seems like it&#8217;s throwing out a number of fairly useful things for &#8220;reproducable builds&#8221; which are of little or no interest to most people.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd odd alt thread-even depth-1" id="comment-1319926">
				<div id="div-comment-1319926" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319926">
			January 5, 2018 at 11:53 am</a>		</div>

		<p>For people who have been trying to reverse engineer the PDB format, this little tidbit finally explains a problem: why module timestamps were so non-sensical in Windows 10.</p>
<p>For a while i wondered if it was changed so that 1 tick is 2 seconds, and the high-bit is set to indicate this custom behavior.</p>
<p>This is nice to have.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-odd thread-alt depth-1" id="comment-1319965">
				<div id="div-comment-1319965" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319965">
			January 5, 2018 at 6:19 pm</a>		</div>

		<p>The timestamp was once used to identify the PDB file and to store it on a symbol server. These days it&#8217;s a GUID combined with generation (&#8220;age&#8221;) count. The &#8220;age&#8221; counter increments every time the binary gets built. The GUID persists until you delete the whole build directory. When you build a binary from scratch, the PDB gets a new GUID.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1320005">
				<div id="div-comment-1320005" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1320005">
			January 7, 2018 at 5:29 pm</a>		</div>

		<p>When was it ever a good decision to include this much random noise into a compiled binary? What were you thinking? If you would have been a bit more careful before implementing these noise generators in your tool chain, you wouldn&#8217;t have needed to refactor your whole tool chain from scratch. Of course, even with a tool chain claiming to generate reproducible results, there&#8217;s no guarantees, noone can count on it, you have the assume worst-case anyway, i.e. random noise in every other byte.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1320555">
				<div id="div-comment-1320555" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://randomascii.wordpress.com/' rel='external nofollow' class='url'>Bruce Dawson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1320555">
			January 11, 2018 at 3:20 pm</a>		</div>

		<p>What about the GUID/age that are embedded in the binary? Are these also reproducible, or are they exempted from the reproducibility checking?</p>
<p>&gt; The timestamp is really a unique ID that tells the loader</p>
<p>Well, that is *one* use of the timestamp. Another use is as part of the unique ID used when inserting PE files into a symbol server, as described here:<br />
<a href="https://randomascii.wordpress.com/2013/03/09/symbols-the-microsoft-way/" rel="nofollow">https://randomascii.wordpress.com/2013/03/09/symbols-the-microsoft-way/</a></p>
<p>In particular note that the path for a PE file on a symbol server is generated like this:</p>
<p>    “%s\%s\%s%s\%s” % (serverName, peName, timeStamp, imageSize, peName)</p>
<p>Since the peName stays the same for a particular binary, and the imageSize frequently stays the same, the timeStamp *must* be different for every build to avoid collisions. And, 32 bits isn&#8217;t really enough &#8211; if you hit about 60,000 builds of the same binary on the same symbol server you have to start worrying about collisions, or hope that the file size is growing.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>