<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (60)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1147553">
				<div id="div-comment-1147553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147553">
			September 4, 2014 at 7:03 am</a>		</div>

		<p>I agree that there is no point in asking the question. &nbsp;However, I need to point out that there are 128 bit systems. &nbsp;AS/400 (and S/38 before that) all deal with 128 bitness at the MI level. &nbsp;It&#39;s been that way since 1981 &#8212; 1/3 of a century ago. &nbsp;So, there could be a future version of Windows that is 128 bit and runs 64 bit programs for so-called legacy code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147563">
				<div id="div-comment-1147563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147563">
			September 4, 2014 at 7:16 am</a>		</div>

		<p>Actually there is one. The #ifdef ladder ends at 16 bit but 64 bit code might yet run. The only way to tell is to thunk to 32 bit code and then dynamically call IsWow64Process to check. This is far more likely to work than some hyphetical 32 bit Windows knowing how to run 64 bit code.</p>
<p>Actually I lied. This isn&#39;t hypothetical at all. The 64+32+16 is implemented by Wine.</p>
<div class="post">[<em>I don&#39;t know what you mean by &quot;64 bit code might yet run&quot;. A 64-bit application is in the _WIN64 branch. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147573">
				<div id="div-comment-1147573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147573">
			September 4, 2014 at 7:19 am</a>		</div>

		<p>There is no point to asking for 99.9% of software. &nbsp;For that .1% that really need to know &#8211; they&#39;ll have to figure that out when 128 bit windows comes out.</p>
<p>For the rest of us &#8211; it is generally a really bad sign that your desktop software is worrying about such things &#8211; as you&#39;re fighting the OS rather than allowing it to do its job.</p>
<p>64 bit trees either are emulated well enough that the difference doesn&#39;t matter, or poorly enough so it does &#8211; in which case the issue is the emulator, not the well-behaved software that relies on 64 bit trees.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147593">
				<div id="div-comment-1147593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mott555</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147593">
			September 4, 2014 at 7:40 am</a>		</div>

		<p>My current company produces hardware along with an SDK so I&#39;ve seen this stuff quite a bit. The 32-bit version of our SDK needs to detect the bit-ness of Windows so it knows which device driver to connect to. But for us, this &quot;flaw&quot; isn&#39;t an issue until 128-bit Windows becomes a thing in which case we&#39;ll simply update our code. And hopefully by then 32-bit will be long dead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147623">
				<div id="div-comment-1147623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147623">
			September 4, 2014 at 7:48 am</a>		</div>

		<p>Interestingly we had a batch file yesterday that actually cared. &nbsp;We started getting reports that an internal installer had suddenly become 64 bit only. &nbsp;Considering we hadn&#39;t modified the build chain in years we had to go spelunking through the tools. &nbsp;Turns out there was a batch file that calls IExpress. &nbsp;When the build tools were run on a 64 bit machine, that invoked the 64 bit version of IExpress and produced a 64 bit only installer. &nbsp;So that batch file did have to care, if only so it could invoke the 32 bit version of IExpress.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147633">
				<div id="div-comment-1147633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147633">
			September 4, 2014 at 7:54 am</a>		</div>

		<p>What&#39;s the next step going to be &nbsp;128bit? &nbsp; Who needs that much address space? &nbsp;</p>
<p>I suppose the wide registers might come in handy for some things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147643">
				<div id="div-comment-1147643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147643">
			September 4, 2014 at 8:02 am</a>		</div>

		<p>@ Mc &#8212; single level store is tailor made for 128 bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147653">
				<div id="div-comment-1147653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio &amp;#39;Grijan&amp;#39;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147653">
			September 4, 2014 at 8:19 am</a>		</div>

		<p>If Moore&#39;s Law grow rate (twice the memory every two years) keeps its pace, it will be about 50 years before we have to start worrying about switching to 128 bits. But memory growth has slowed down lately, so that time may be longer. And maybe in half a century computers will work very differently (compare today&#39;s PCs and tablets to the mainframes of the 60s!) and architectural details won&#39;t make such a difference to the end user.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147683">
				<div id="div-comment-1147683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147683">
			September 4, 2014 at 9:52 am</a>		</div>

		<p>SimonRev: If I understood correctly, the batch file doesn&#39;t need to care, because it always has to run the 32-bit IExpress anyway (or always both 32-bit and 64-bit if you&#39;re releasing both versions).</p>
<p>IanBoyd: (curious, not argumentative) But why does the program need to know? What decisions will the application take based on this? I suppose some specific runtime optimizations could be one case, but I&#39;d like more concrete examples if you or anyone else can provide them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147693">
				<div id="div-comment-1147693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147693">
			September 4, 2014 at 10:05 am</a>		</div>

		<p>@J: &nbsp;The problem is that the batch file does need to care. &nbsp;If the batch file is running as 32 bit, it would run &lt;system 32 dir&gt;iexpress.exe. &nbsp;If running as 64 bit it has to run &lt;windows&gt;SysWOW64iexpress.exe.</p>
<p>The original batch file just ran iexpress.exe and relied on the path to pull it from system32. &nbsp;However when running as 64 bit, that will run the 64 bit version.</p>
<p>In the end this is just a special case of IanBoyd&#39;s problem &#8212; programs that don&#39;t know if they are running as 64 bit or not because the code is agnostic. (in his case IL, in mine batch)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147703">
				<div id="div-comment-1147703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dalek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147703">
			September 4, 2014 at 10:16 am</a>		</div>

		<p>@mott555</p>
<p>&gt; And hopefully by then 32-bit will be long dead.</p>
<p>Due to hardware getting cheaper and more prolific all the time I think there will be far more legacy/custom 32 bit applications than DOS and 16 bit Windows applications (some of which are still being used 22 years after Windows 3.11 was released). I would not be surprised if 32 bit applications would still have to be supported in 2050&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147713">
				<div id="div-comment-1147713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147713">
			September 4, 2014 at 10:16 am</a>		</div>

		<p>@IanBoyd: in .NET for example you have Marshal.SizeOf(typeof(IntPtr)).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147723">
				<div id="div-comment-1147723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">The Marshal Plan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147723">
			September 4, 2014 at 10:36 am</a>		</div>

		<p>@IanBoyd: Similar to Azarien&#39;s response, in .NET you may have to P/Invoke to a proprietary DLL from an IL program, and you need to know whether to load the 32-bit or 64-bit version. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147733">
				<div id="div-comment-1147733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147733">
			September 4, 2014 at 10:36 am</a>		</div>

		<p>&quot;&#8230;and let the emulation layer of the hypothetical future version of Windows&#8230;&quot;</p>
<p>There&#39;s no hypothetical here. It&#39;s called virtual machine. I run W7 64 bit inside a vmware machine on a W7 32 bit host all the time. On same W7 32 bit host system I run 64 bit MacOsX Mountain Lion, also W8 64 bit, Ubuntu 64 bit virtual machines. All works just fine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147743">
				<div id="div-comment-1147743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147743">
			September 4, 2014 at 10:40 am</a>		</div>

		<p>There&#39;s no clear benefit in going 64-bit for most applications. Most probably, at some point VS will produce 64-bit code by default, and Windows will no longer ship in x86 version, but 32-bit applications will still be used for a long time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-john-ludlow odd alt thread-odd thread-alt depth-1" id="comment-1147753">
				<div id="div-comment-1147753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/John+Ludlow' rel='external nofollow' class='url'>John Ludlow</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147753">
			September 4, 2014 at 10:45 am</a>		</div>

		<p>That .1% of software that needs to actually care likely to be installation-related. It could be that it needs to know specifics about what architecture of Windows is in use (regardless of the bitness of the program itself) in order to install the correct components. It might also need to drop the right files into the right places, again regardless of its own architecture.</p>
<p>Of course, there are no current 128-bit Windows systems, but a 32-bit (or even 16-bit) process is often used to do this in our current 64-bit world because it can run on the widest number of environments. Even if your application doesn&#39;t support the environment, your install needs to give a sensible error, rather than just splurging a &quot;bad image format&quot; error onto the screen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147763">
				<div id="div-comment-1147763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147763">
			September 4, 2014 at 11:10 am</a>		</div>

		<p>[I don&#39;t know what you mean by &quot;64 bit code might yet run&quot;. A 64-bit application is in the _WIN64 branch. -Raymond]</p>
<p>I believe this to be obvious. If you drop a 64 bit .exe file, can you start it?</p>
<div class="post">[<em>The fact that code in the 64-bit EXE file is running (in order to detect whether it is running on a 64-bit system) implies that the answer is &quot;tautologically, yes.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147783">
				<div id="div-comment-1147783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147783">
			September 4, 2014 at 12:44 pm</a>		</div>

		<p>I want a 65-bit version of Windows. &nbsp;Twice the addressing space of 64 bit Windows!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147793">
				<div id="div-comment-1147793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147793">
			September 4, 2014 at 12:52 pm</a>		</div>

		<p>@DWalker: Windows 8.1 has 16 times the address space of Windows 8.0 =)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147803">
				<div id="div-comment-1147803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ajanata</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147803">
			September 4, 2014 at 12:58 pm</a>		</div>

		<p>SimonRev: %PROCESSOR_ARCHITECTURE% is AMD64 on my 64-bit Windows 8.1 box (and I&#39;m pretty sure I&#39;ve seen this before Windows 8 as well). I suspect it will be something else on 32-bit Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mngoldeneagle even thread-even depth-1" id="comment-1147813">
				<div id="div-comment-1147813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147813">
			September 4, 2014 at 1:36 pm</a>		</div>

		<p>@ajanata: Environment variables aren&#39;t always a good way of identifying characteristics of a machine, since they&#39;re trivial to modify or spoof. &nbsp;You could detect it in code by measuring the size of the IntPtr type (or equivalent), or use WMI to get the system architecture type, or write a custom program that detects it for you (in the event you need bitness logic in a batch file).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147833">
				<div id="div-comment-1147833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147833">
			September 4, 2014 at 1:53 pm</a>		</div>

		<p>@DWalker: Oh, you mean the IA64 build of Windows? &nbsp;<a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/19/60162.aspx">blogs.msdn.com/&#8230;/60162.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147843">
				<div id="div-comment-1147843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147843">
			September 4, 2014 at 2:00 pm</a>		</div>

		<p>[The fact that code in the 64-bit EXE file is running (in order to detect whether it is running on a 64-bit system) implies that the answer is &quot;tautologically, yes.&quot; -Raymond]</p>
<p>Oh wow. I was referring to a case of 16 bit code trying to decide if the host is a 64 bit host or not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147853">
				<div id="div-comment-1147853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147853">
			September 4, 2014 at 2:15 pm</a>		</div>

		<p>@Joshua: &nbsp;As usual, you are making almost no sense. &nbsp;I am shocked that Raymond even bothers to respond. &nbsp;How is anybody supposed to know you are talking about running 16-bit code when you say something like &quot;If you drop a 64 bit .exe file, can you start it?&quot;? &nbsp;What the heck does that even mean?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147863">
				<div id="div-comment-1147863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147863">
			September 4, 2014 at 2:24 pm</a>		</div>

		<p>@DWalker,</p>
<p>The hardware gives you three times the address space &#8211; if the OS would give you access to it. But it won&#39;t. Code, data and stack &#8211; even on the x84 the hardware can address 3 x 4GBytes of virtual address space. But for the OS to e.g. determine whether the 32 bit address causing a page fault was a code, data or stack access would make code more complex, and not the least: More bound to a specific architecture. So the OS desginers found it easier to give you four billions times as much logical address space than just three times.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147873">
				<div id="div-comment-1147873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147873">
			September 4, 2014 at 2:25 pm</a>		</div>

		<p>I suppose you could be a system information tool who wants to display the real bitness of the system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147883">
				<div id="div-comment-1147883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147883">
			September 4, 2014 at 2:37 pm</a>		</div>

		<p>Interesting. I worked on the versions of Mac OS X that supported both 32 and 64-bit x86 userspace applications with a 32-bit supervisor mode (kernel and drivers). The systemcall, interrupt etc. trampolines performed mode switches. There were some odd edge cases like having to transition to 64-bit mode within supervisor mode briefly (with interruptions masked) in order to save the full floating point/SIMD states, switch pagedirectory bases etc., but it worked fine and we shipped it. This approach was used to preserve supervisor mode compatibility (for drivers), for a gradual 64-bit transition. </p>
<p>I&#39;m not sure when windows went 64-bit, but I&#39;ve wondered if Microsoft internally considered this approach and rejected it for complexity/validation reasons or&#8230;? As far as I know, nothing besides Mac OS used this hybrid approach. Of course, for the last couple of releases, Mac OS X has used a 64-bit kernel.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147903">
				<div id="div-comment-1147903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio &amp;#39;Grijan&amp;#39;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147903">
			September 4, 2014 at 3:05 pm</a>		</div>

		<p>@Brian: technically, you are right. But it applies directly to RAM size, because the number of transistors in a memory chip is directly proportional to its capacity (in dynamic RAM, one transistor per bit, plus some selection logic for each word, row and column). And RAM size determines the need for address bus width and, thus, architecture bitness. So yes, you can use Moore&#39;s Law to model bitness changes (and the proof is that it works pretty well for past changes).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147913">
				<div id="div-comment-1147913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Will</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147913">
			September 4, 2014 at 3:07 pm</a>		</div>

		<p>@Derek &#8211; I was also thinking of OS-X when I was reading this post about a hypothetical non-64 bit OS running a 64 bit app. &nbsp;OTOH, there were very few apps that actually needed to care. &nbsp;Basically, things like driver installer utilities. &nbsp;If a driver was sanely made, it would provide the same sort of API for the 64 bit kernel or the 32 bit kernel, so apps that needed to talk to the device usually didn&#39;t have an issue one way or another. &nbsp;(Though I vaguely recall some nonsense with some SDI output cards in Mac Pros.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147923">
				<div id="div-comment-1147923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gordo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147923">
			September 4, 2014 at 3:11 pm</a>		</div>

		<p>If you drop a 64-bit .EXE file, it will probably say &quot;ouch&quot;. Depending on how far the fall is, of course.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd even thread-even depth-1" id="comment-1147663">
				<div id="div-comment-1147663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147663">
			September 4, 2014 at 8:26 am</a>		</div>

		<p>&gt; If you are a 64-bit program, then you are running on 64-bit Windows, because 32-bit Windows cannot run 64-bit programs</p>
<p>The problem comes up when i don&#39;t know if my **program** is 64-bit or 32-bit. My Windows program is neither Intel x64 or x86, but it IL.</p>
<p>It is the user&#39;s computer which will decide at runtime if my program will be running as 64-bit or 32-bit (or 128-bit, or ARM for that matter).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147943">
				<div id="div-comment-1147943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147943">
			September 4, 2014 at 4:47 pm</a>		</div>

		<p>@Joshua: Are you suggesting that you would write a 16-bit program that uses 64-bit processor features? That&#39;s the only use case I can see, and it doesn&#39;t make any sense to me; making a 16-bit program in this day and age seems odd as there&#39;s almost no support for that mode anymore. Any other 16-bit program would be legacy only and maybe would check for 386/Windows 95, tops.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman even thread-even depth-1" id="comment-1147773">
				<div id="div-comment-1147773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147773">
			September 4, 2014 at 11:56 am</a>		</div>

		<p>@Antonio: Moore&#39;s Law (which is really an assertion/observation and not a physical law) states that the number of *transistors* doubles every two years.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1147973">
				<div id="div-comment-1147973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">IdahoJacket</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147973">
			September 4, 2014 at 8:32 pm</a>		</div>

		<p>I think the more interesting question is should IsWow64Process return true or false for 32 bit code running on hypothetical 128 bit Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1147983">
				<div id="div-comment-1147983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DebugErr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1147983">
			September 5, 2014 at 3:13 am</a>		</div>

		<p>@IdahoJacket There will probably be no 32-bit emulation layer on 128-bit Windows anyways.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148003">
				<div id="div-comment-1148003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148003">
			September 5, 2014 at 6:34 am</a>		</div>

		<p>@Joshua </p>
<p>&quot;Oh wow. I was referring to a case of 16 bit code trying to decide if the host is a 64 bit host or not.&quot;</p>
<p>It&#39;s not: <a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/896458">support.microsoft.com/&#8230;/896458</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148023">
				<div id="div-comment-1148023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalekr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148023">
			September 5, 2014 at 7:48 am</a>		</div>

		<p>@j b: &nbsp;huh? &nbsp;I was comparing a hypothetical 65-bit version of Windows (or any OS) with a 64-bit version. &nbsp;One extra bit gives you twice the addressing space. &nbsp;And you mentioned &quot;the x84&quot;, at which point I got lost.</p>
<p>@Adam R: &nbsp;Wow, that&#39;s interesting. &nbsp;A 65th bit to signal &quot;valid or not&quot;. &nbsp;Cool.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148053">
				<div id="div-comment-1148053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148053">
			September 5, 2014 at 10:21 am</a>		</div>

		<p>@DWalekr,</p>
<p>&quot;x84&quot; was typo for &quot;x86&quot; &#8211; I guess my brain mixed in &quot;64&quot; when I was going to type the 6. :-)</p>
<p>I referred to x86 because I don&#39;t know the 64-bit architecture wel. I _guess_ is is similar, but the x86 I KNOW that code, data and address spaces are in principle independent; they run from logigal addresses 0 to 4G; code address X may have different contents from data address X and stack address X. There is never doubt about which of the three content values to use, even if X is the same. So the x86 architecture provides each process with 12 GB of address space (assuming ideal balance between code, data and stack requirements).</p>
<p>I _guess_ that the x64 architecture is similar, giving a process three 64-bit address spaces, without adding a 65th address bit. I never checked it up.</p>
<p>If each process had three independent address spaces, each filling the entire address range, the OS would e.g. for DMA see them as three different entities (compare it to three different processes!). It would have to take (slightly) different actions e.g. when paging depending on whether the page fault for logical page X occurred in the process&#39; code, data or stack area. This would be specific to CPUs distinguishing code, data and stack accesses. Addressing-wise, most don&#39;t, and those that do, do it in different ways. Originally, NT ran on a significant number of CPUs, and it was much easier to lay all three address spaces on top of each other, assigning any given address to either code, data or stack &#8211; not all three of them.</p>
<p>Splitting the 4G address range into a &quot;system&quot; part and a &quot;user&quot; part is partly a result of NT development having a fair share of people with VAX/VMS background appearently unfamiliar with the kind of mechanisms provided by the 386 MMS. 386 allowed the appplication to occupy the entire 4G address space; any OS call (or other supervisor) might cause a jump into a completely independent 4G address space, fully controlled by the OS. Obviously, this would give the OS dramatically better protection against malbehaved application code, simply by its data not being addressable from application code. But the performance penalty was considered too high (a function call crossing address spaces WAS expensive), and also: Not every CPU architcture provided such mechanism. So instead of giving the OS and application fully independent address spaces, OS code was squeezed into application space, and protection enforced not through adressability, but by restricting access to certain areas of the address space through page/segment protection. (From an architectural point of view, this is a tragic defeat, even though it can very well be understood on pragmatical grounds!)</p>
<p>Sometimes, I am happy NOT to be an Intel 386 MMS architect. It must be somewhat depressing seeing all the great ideas being put into that memory management system. amd seeing two thirds of it ignored, wasted&#8230;</p>
<div class="post">[<em>No, x86 does not get a theoretical 12GB of address space because the code, data, and stack selectors all point into the same shared 4GB address space. Enough people make this mistake that I think I&#39;ll need to do a separate article on it. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148113">
				<div id="div-comment-1148113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148113">
			September 5, 2014 at 12:02 pm</a>		</div>

		<p>@j b:</p>
<p>The way it works is:</p>
<p>&#8211; linear address = segment descriptor base address + offset</p>
<p>&#8211; if PG = 0 (paging disabled), physical address = linear address</p>
<p>&#8211; if PG = 1, perform TLB/page table lookup and translate linear address to physical address</p>
<p>Incidentally, the Motorola 68k family, which had a flat address space, could do something like what you are suggesting, using the processor&#39;s Function Code pins, although it would need assistance from external logic. I was reading some 68k documentation a little while ago, and IIRC, the 68010 introduced an instruction to move data between address spaces.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148133">
				<div id="div-comment-1148133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148133">
			September 5, 2014 at 1:45 pm</a>		</div>

		<p>&quot;the code, data, and stack selectors all point into the same shared 4GB address space&quot;</p>
<p>Yes, that is how it is _used_ to make it simpler for the OS. But virtual address X (in either code, data or stack space) does NOT have to map to the same linear-space address X. There is a offset that might place three virtual address X into three different linear space addresses.</p>
<p>It is used in such a way that code, data and stack address X all points to the same linear space address. If neither code, data nor stack size never exceeded 1G, address X in the three spaces could map to 0+X, 1G+X and 2G+X, as perfectly independent spaces. If linear space was, say, 64G large, they could map into 0+X. 15G+X and 32G+X respectively, and could grow to 4 G each without interfering with each other. In the original 386, and today&#39;s chips in 386 mode, linear addresses are 32 bits, but that has no influence on the principal independence of the three virtuall address ranges &#8211; they still could map to distinct linear addresses, if the OS chose to. But as you say, they choose NOT to. That&#39;s the OS&#39; choice.</p>
<p>The linear adddress is not visible to application code. We might argue whether a 32 bit linear address size is considered &quot;architecture&quot; or &quot;implemementation&quot;. Increasing it to some arbitrary larger value (say, a 36 bit address) would be invisible to any application code, and would not require changes in addressing structure, just a size increase. From that point of view it is just an implementation detail. Obviously, the OS would have to be aware of the larger linear address size, so from an OS point of view you might argue that it is more than an implemetentation difference. In my book, chamging a dimension is certainly a minor architectural change. OSes have to adopt to more significant implementation choices than that, while still continue referring to it as within the same architectural framework.</p>
<div class="post">[<em>The linear address space on x86 is 32-bit. The operating system does not have a choice here. &quot;If linear space was, say, 64G large&quot; is a counterfactual. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148193">
				<div id="div-comment-1148193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148193">
			September 6, 2014 at 4:12 am</a>		</div>

		<p>First: If you really WANTED to, you could provide 12G virtual space to a 32 bit process, duplicating the paging mechanisms at the linear address space level: Like an access to a physical page not in RAM cause another page to be thrown out to make room for the required one, access to a virtual address segment not mapped to linear space could cause another segment to be unmapped to make room in virtual space. (I am talking about the mapping to linear space, managed by the OS &#8211; the application would be unaffected.) Well, that requires using segments less than 4G, which I have understood is difficult to comprehend. But the 386 MMS allows it, from its very first implementation.</p>
<p>&quot;If linear space was, say, 64G large&quot; is a counterfactual. &#8230; No, it is not. It is not a claim of anything at all. Quite to the contrary. &quot;If it was&quot; implies that it isn&#39;t, and that certainly is a true fact, in this case. &quot;If we add two more segment register to the next chip generation&#8230;&quot;, would you label that as &quot;counterfactual&quot;, too? Is there a fundamental difference between extending the range of valid register numbers and extending the range of valid linear space locations, making one &quot;if&quot; counterfactual, and the other one not?</p>
<p>Obviously, the 80386 was limited to 32 bits linear space. But should we consider this an _architectural_ limitation? If Intel made a new chip with the linear space extended to 36, 48 or 64 bits, and everything else identical, would it be considered a completely new and different architecture? Methinks not. Lots of extensions have been made to the original 80386, like new instructions, new registers, new physical addressing capabilities. Yet no one calls it a diversion from the x86 architecture. Nor would an extension of the linear address space be. At most you could call it an extension of the architecture, but bordering on being an architecture _implementation_ detail.</p>
<p>What IS an architectural aspect, is that address X is mapped to different linear addresses, depending on whether it it a stack, data or code address. That some OS decide to set up the segment tables so that the mappings end up at the same linear address is a software matter; from the MMS point of view, they are still distinct, independent mappings.</p>
<p>An _OS programmer_ works with _implementations_ of the architecture, and might be affected by the address length. Just like the carpenter who builds my house is concerned whether the wooden planks are six or eight inches wide: You won&#39;t have a new architect make a new house even if you decide to change the width of the planks &#8211; that is not &quot;architecture&quot;.</p>
<p>I guess I am confused from reading description of the architecture of the x86 chip&#39;s MMS &#8211; my mind isn&#39;t geared to, or limited to, how Windows make use of a selection of the facilities provided, as they appear in specific implementations. It is difficult for me discussing this matter further, as I am not that familiar with all the limitations Windows developers put on the use of the hardware. So I won&#39;t make further contributions to the discussion.</p>
<div class="post">[<em>&quot;If we used two more segment register&#8230;&quot; is a counterfactual. Two more segment registers don&#39;t exist, so you are assuming a falsehood. What&#39;s the point of writing an operating system that takes advantages of CPU features that don&#39;t exist? (It&#39;s not just an architecture implementation detail. The size of the linear address space and the number of registers is part of the CPU&#39;s public surface. It&#39;s a contractual change, not an implementation detail.) Besides, your math doesn&#39;t add up. &quot;That requires using segments less than 4G&quot; which means that your total virtual space is less than 12G, because adding together three numbers less than 4G will give you a total that is less than 12G. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148203">
				<div id="div-comment-1148203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148203">
			September 6, 2014 at 5:13 am</a>		</div>

		<p>@Raymond</p>
<p>[The linear address space on x86 is 32-bit. The operating system does not have a choice here. &quot;If linear space was, say, 64G large&quot; is a counterfactual. -Raymond]</p>
<p>Pentium Pro onwards supports 36-bit (i.e. 64G).</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Physical_Address_Extension">en.wikipedia.org/&#8230;/Physical_Address_Extension</a></p>
<p>Some Microsoft operating systems support it as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148213">
				<div id="div-comment-1148213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148213">
			September 6, 2014 at 5:26 am</a>		</div>

		<p>@smf</p>
<p>That&#39;s support for larger physical addresses, not larger linear addresses.</p>
<p>The 386 and later do their MMU work in two conceptual stages when in 32 bit paged mode:</p>
<p> 1. Take segment base register, add offset, to get linear address (32 bit number).</p>
<p> 2. Take linear address (regardless of which segment it came from), and translate to a physical address (32 bit number if no PAE, 36 bit if PAE, up to 48 bits if &nbsp;64 bit OS).</p>
<p>Your virtual address space is constrained by the size of linear address space; even if you have three different segments in use, this is still 32 bits in x86 32 bit land. The benefit of PAE is twofold:</p>
<p> 1. Systems running large numbers of processes can map the linear address space for each process onto different 36 bit physical addresses, so you can give processes real RAM (not page file) even when the total memory demand on the system exceeds 4 GiB.</p>
<p> 2. Specially written processes can drive paging so that they use more than 4 GiB of RAM, by using a window into the physical memory in a fashion similar to DOS-era overlays and EMS; under Windows, you&#39;d use Address Windowing Extensions to do this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148233">
				<div id="div-comment-1148233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Owen SHepherd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148233">
			September 6, 2014 at 10:12 am</a>		</div>

		<p>Also note that lots of software uses the linear address wraparound for its&#39; own purposes. The Linux x86 TLS ABI, for example, uses &quot;negative&quot; offsets from GS</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148243">
				<div id="div-comment-1148243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148243">
			September 6, 2014 at 11:17 am</a>		</div>

		<p>Raymond,</p>
<p>I think your comment is a good enough explanation why I don&#39;t want to follow up this discussion.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148253">
				<div id="div-comment-1148253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148253">
			September 6, 2014 at 2:11 pm</a>		</div>

		<p>@j b. &quot;I think your comment is a good enough explanation why I don&#39;t want to follow up this discussion.&quot;</p>
<p>Thanks, because I can see this turning into a rehash of your <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2013/06/28/10429807.aspx#10430835">blogs.msdn.com/&#8230;/10429807.aspx</a> etc&#8230; postings.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148383">
				<div id="div-comment-1148383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">HagenP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148383">
			September 8, 2014 at 2:26 am</a>		</div>

		<p>You need to know the platform variant(32/64bit) if you want to install drivers. Not for the driver package itself &#8211; the INF file can take care of it &#8211; but for calling the correct &quot;Driver Package Installer&quot; introduced by MS &quot;to provide a better user experience&quot; (quote by memory &#8211; the WinHEC2008 presentation CON-T532_WH08.pptx seems not to be available anymore).</p>
<p>But how can you select the &quot;correct&quot; &#8211; 32bit or 64bit &#8211; DPinst.exe version? MS kindly provides a HowTo document: </p>
<p><a rel="nofollow" target="_new" href="http://download.microsoft.com/download/7/E/7/7E7662CF-CBEA-470B-A97E-CE7CE0D98DC2/32-64bit_install.docx">download.microsoft.com/&#8230;/32-64bit_install.docx</a></p>
<p>This states &quot;A platform-specific version of DPInst must be provided for each target platform that the INF supports.&quot;. Obviously it is not possible to make a single DPinst binary for driver installation on 32/64bit OS variants&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148393">
				<div id="div-comment-1148393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">HagenP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148393">
			September 8, 2014 at 2:44 am</a>		</div>

		<p>@ j b</p>
<p>&gt; code, data and address spaces are in principle independent</p>
<p>On some processors you can &quot;see&quot; the memory access type (e.g. supervisor / user) externally on some pins (e.g. FC0/1/2 on an 68000). With them you can make address types map to different address spaces, and you can make them &nbsp;(partially) independent.</p>
<p>But x86 processors do not provide external signals to tell apart the different address types. There is no &quot;data access&quot; pin or a &quot;stack access&quot; pin.</p>
<p>-&gt; Without this information you cannot make the &quot;address spaces&quot; independent. Everything maps to the same 32bit address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman even thread-even depth-1" id="comment-1148433">
				<div id="div-comment-1148433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148433">
			September 8, 2014 at 6:17 am</a>		</div>

		<p>@JB:</p>
<p>It&#39;s obvious you don&#39;t understand how the physical hardware works, so let a hardware guy who designs microprocessor systems for a living tell you: you&#39;re wrong.</p>
<p>The x86 architecture is Von Nueman Architecture. What you describe would require Harvard Architecture. Go educate yourself on these terms.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148543">
				<div id="div-comment-1148543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148543">
			September 8, 2014 at 9:25 am</a>		</div>

		<p>&gt;Splitting the 4G address range into a &quot;system&quot; part and a &quot;user&quot; part is partly a </p>
<p>&gt;result of NT development having a fair share of people with VAX/VMS background </p>
<p>&gt;appearently unfamiliar with the kind of mechanisms provided by the 386 MMS. </p>
<p>A few of them at least were experienced enough with the PDP11 that they</p>
<p>would be well familiar with having the OS have its very own address</p>
<p>space (on the PDP11, it&#39;s because 64KB is not enough to share).</p>
<p>I too am familiar enough with the PDP11 and VAX that having the OS</p>
<p>have its own address space is a pain in the rear, at least in </p>
<p>directive/syscall processing, where you need access to </p>
<p>both spaces.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148553">
				<div id="div-comment-1148553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148553">
			September 8, 2014 at 9:27 am</a>		</div>

		<p>@HagenP and Brian EE (and Raymond as well):</p>
<p>You all completely ignore the segmenting mechanisms of the 386 MMS. You defines three 4GB segments, perfectly aligned from address zero, and then forget all about segmenting, pretending it isn&#39;t there. Yes, if you do it that way (and that seems to be the only way that is acceptable in this forum), then you have discarded the option to distinguish between the three address spaces. I accept that attitude, and understand that any statement in this forum about the 386 MMS capabilities must make the assumption that the segmenting part of the MMS is not used. (And also that there is no distinction between an architecture and a specific implmenetations.)</p>
<p>I tend to look at ALL the available facilites, and I tend to distinguish architecture from implementation. I feel it silly continuing a discussion as if half of the processor was missing, and as if an architecture can never be extendended. Therefore I feel it silly continuing this dicussion.</p>
<div class="post">[<em>Okay, so that&#39;s the point of confusion. You are talking about the x86 architecture that <span style="text-decoration:underline;">could exist in the future</span>; I&#39;m talking about the x86 architecture <span style="text-decoration:underline;">as it exists today</span>. I think it&#39;s silly continuing a discussion that assumes the architecture can be extended, because that doesn&#39;t help you write an operating system <span style="text-decoration:underline;">today</span>. In the future, please make it clear that you are making counterfactual statements (statements that are not true today). -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148683">
				<div id="div-comment-1148683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148683">
			September 8, 2014 at 11:18 am</a>		</div>

		<p>No, Raymond.</p>
<p>The distinction between virtual data, stack and code addresses has existed since the very first 80386. </p>
<p>The only reason why one would require a future processor is that you (and others) insist that there both code, data and stack segments are 4 GB large, and there is a single of each. THEN, because you at any time will need all three kinds of segments, will you need a larger linear space. 386 was made to handle multiple segments of each kind, according to need. You appearently refuse to recognize that mechanism. THEN you need more linear space.</p>
<p>That&#39;s one point. Another point is that talking about &quot;an x86 _architecture_ that could exist in the future&quot; &#8211; you fail to distinguish beteween architecture and implementation. Extending an address field in a way that is invisible to the application program, keeping everything else as before, certainly is not a &quot;new&quot; architecture. It is the same architecture with a wider address field, which is about as architecturally significant as the number of physical address lines. Which is 99,5% an implementation detail, not an architectural aspect.</p>
<p>What IS an architectural aspect is that the processor makes completely independent mappings of data, code and stack addresses. There is a single reason why address X ends up at the same linear address: Because your software has chosen to set up the segment descriptors that way (so that you can forget them!). The architecture has the capability of doing otherwise, even if you choose to do identical mappings in all three cases. That&#39;s your choice, and it is obvious that you insist not to ever consider any other alternative. Another OS could do differently, even if Windows guys do not want to. Even with 32 bits linear space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148693">
				<div id="div-comment-1148693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148693">
			September 8, 2014 at 11:20 am</a>		</div>

		<p>@Brian EE,</p>
<p>This has nothing to do with physical hardware but with conceptual mapping from a program&#39;s virtual address to a linear address &#8211; even before it is mapped down to a physical address. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148703">
				<div id="div-comment-1148703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148703">
			September 8, 2014 at 11:25 am</a>		</div>

		<p>@HagenP,</p>
<p>The mapping we are talking about takes place within the CPU&#39;s MMS, before the address delivered to the paging system for mapping. The CPU selects a segment, depending on the kind of access, which is mapped into linear space &#8211; _that&#39;s_ the mapping we are talking about. No physical pin is required for the chip-internal MMS to make the distinction. (But to understand that, you must look at the segment system, and not, as most people around here do, simply set up three 4 GB segments and put them on top of each other, so the can completely forget the segment system.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148573">
				<div id="div-comment-1148573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148573">
			September 8, 2014 at 9:50 am</a>		</div>

		<p>@Brian_EE: &quot;The x86 architecture is Von Nueman Architecture. What you describe would require Harvard Architecture. Go educate yourself on these terms.&quot;</p>
<p>I think von Neumann vs Harvard is a red herring, and saying his (apparently-mistaken) view of how x86 works requires Harvard is wrong. Those models don&#39;t take into account virtual memory, and the process by which virtual addresses are mapped to physical ones is the linchpin to whether and how JP is right or wrong. If each selector got a separate page table, then JP would be right. But that wouldn&#39;t make x86 a Harvard architecture, because whether it looked like Harvard or von Neumann would depend on how the page tables were set up: if you pointed code and data at disjoint physical spaces, it would look like Harvard. If you pointed them at the same place, it would look like von Neumann. If they overlapped but not completely&#8230; well, it looks like some weird third category. So which is that hypothetical version of x86? Both? Neither?</p>
<p>That&#39;s the hypothetical x86 that works differently from the real one. So what about the real one? Well, turns out that I *think* you can do something vaguely similar. On processors that didn&#39;t have support for the NX bit, PaX was able to emulate it by taking advantage of the separate instruction and data TLBs. By asking the CPU to trigger page faults when the page wasn&#39;t in the ITLB (even if it was in the DTLB) they could check to make sure that the faulting address wasn&#39;t NX. They could have similarly prevented reading data from the code segment, but there&#39;s not really a security reason to and probably that would break programs. I&#39;m not sure about this, but I suspect you could hypothetically even let execution proceed in those cases in such a way that the TLBs would have different contents. Voila, stock x86 that acts like a Harvard machine.</p>
<p>So&#8230; you&#39;re right, but I would argue it&#39;s not for the reason you say.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148883">
				<div id="div-comment-1148883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel Rose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1148883">
			September 9, 2014 at 3:20 am</a>		</div>

		<p>@ajanata, @MNGoldenEagle</p>
<p>%processor_architecture% does not always return AMD64 on a 64bit machine. If you are running a 32-bit process, it will return x86. See <a rel="nofollow" target="_new" href="http://stackoverflow.com/questions/1738985/why-processor-architecture-always-returns-x86-instead-of-amd64">stackoverflow.com/&#8230;/why-processor-architecture-always-returns-x86-instead-of-amd64</a></p>
<p>Similarly, sizeof(IntPtr) will tell you the pointer size of the process you are running, not the machine&#39;s pointer size.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1149063">
				<div id="div-comment-1149063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1149063">
			September 9, 2014 at 8:17 am</a>		</div>

		<p>@jb: I still don&#39;t understand how you can have three segments that address 12GB at the same time:</p>
<p>CS: base=00000000h, limit=FFFFFFFFh</p>
<p>DS: base=????????h, limit=FFFFFFFFh</p>
<p>SS: base=????????h, limit=FFFFFFFFh</p>
<p>What values should the DS and SS base addresses be?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1149383">
				<div id="div-comment-1149383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1149383">
			September 9, 2014 at 1:33 pm</a>		</div>

		<p>I thought that the difference with a Harvard architecture machine was that it has two physical data paths: one for data and one for instructions (the Harvard computer had a paper tape for the instructions and electromechanical counters to hold data).</p>
<p>The problem with a von Neumann machine is the &quot;von Neumann bottleneck&quot; &#8212; the instructions and data are fighting for memory bandwidth. If your data and instructions are coming from the same RAM but just have different address spaces, you still have the von Neumann bottleneck, so it&#39;s still a von Neumann architecture.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1149413">
				<div id="div-comment-1149413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1149413">
			September 9, 2014 at 3:07 pm</a>		</div>

		<p>@EricF,</p>
<p>As long as you insist on there being a single 4GB code segment, a single 4GB data segment, and a single 4GB stack segment. set them up when the process is started, and then you forget everything about segments, you have a problem (with the current implemnetations of the architecture). But that&#39;s not the only way to use the 386 MMS. Note that the segment selector is a 14 bit number. That is for a reason! But to utilize it, you must recognize that the segment mechanism is there.</p>
<p>I know very well that it is far from Politically Correct to point out that the segmentation mechanisms could have a very positive value; the Proper Attitute is to pretend that it isn&#39;t there, by setting up three maximum size segments, fully overlapping, and then forget about segments. Yes, that does simplify a few things (not the least for the OS programmer, and certainly if he wants the memory management design to be portable to several architectures). The simplistic, non-segmented approach IS simpler &#8211; no question about that. But if you would recognize the segmenting mechanims and its uses, you could utilize the processor architecture in ways that is not possible in the single-segment approach. I get a very clear impression that most people around here has no interest whatsoever in going beyond the simplistic approach. I&#39;ll accept that &#8211; but I will for my own part continue to recognize all the capabilities of the 386 memory management system.</p>
<div class="post">[<em>Basically, you&#39;re suggesting using a segmented 32-bit model, which is the 32-bit version of 16-bit protected mode. If you had said that, then everybody would have understood. Instead, you talked about having a 64GB line address space, and then you started losing people. Yes, you could use a segmented 32-bit model, where all pointers are 48-bit and segments were swapped in and out of the 4GB linear address space. There was an extension to Windows 3.1 that did this (called WINMEM32, as I recall). Nobody used it. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1149443">
				<div id="div-comment-1149443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140904-00/?p=73#comment-1149443">
			September 9, 2014 at 4:27 pm</a>		</div>

		<p>[&#8230; segmented 32-bit model &#8230;]</p>
<p>I always thought that should work. Same way the 32 bit kernel can have &gt; 4GB disk cache. Why bother now that most new processors are 64 bit. Topic finished.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>