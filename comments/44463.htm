<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (13)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-themann even thread-even depth-1" id="comment-1180103">
				<div id="div-comment-1180103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zhila' rel='external nofollow' class='url'>Zhila</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180103">
			March 16, 2015 at 7:11 am</a>		</div>

		<p>Yay! CLR Week! (Or at least a CLR day.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1180113">
				<div id="div-comment-1180113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Boris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180113">
			March 16, 2015 at 7:31 am</a>		</div>

		<p>A CLR Week would be pointless now that Raymond has begun using more and more C# examples in his other blog posts. Unless a C# example would only work on the Windows Runtime, every week is potentially a CLR week.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-even depth-1" id="comment-1180123">
				<div id="div-comment-1180123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180123">
			March 16, 2015 at 8:05 am</a>		</div>

		<p>I cheated&#8230; <a rel="nofollow" target="_new" href="https://github.com/dotnet/coreclr/search?utf8=%E2%9C%93&amp;q=CoInitializeEx">github.com/&#8230;/search</a> nice thing about open source&#8230; we can just go look now instead of having to badger Raymond</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1180173">
				<div id="div-comment-1180173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jason</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180173">
			March 16, 2015 at 2:06 pm</a>		</div>

		<p>GetTickCount is a red herring. The first unmanaged call is in the internals of System.Console.WriteLine, not GetTickCount.</p>
<p>The mscorlib classes use P/Invoke internally for almost everything involving the system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1180183">
				<div id="div-comment-1180183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180183">
			March 16, 2015 at 4:43 pm</a>		</div>

		<p>RE: &quot;code is not intentionally written to be impossible to understand&quot;</p>
<p>Serious question that I&#39;ve been too afraid to ask for too long&#8230; what about the c++ STL? &nbsp;Why hasn&#39;t new code that&#39;s been added to the STL followed more modern naming practices? &nbsp;Why hasn&#39;t the older code been changed after re-work for c++11/14 anyhow?</p>
<p>As it stands, it still looks like a bunch of academics sat around at a table 25 years ago and decided to code things up on compilers that only support 6 character names while being purposely obtuse and over protective of naming conflicts.</p>
<p>Or does this fall outside of the &quot;generally&quot; bucket?</p>
<div class="post">[<em>Yeah, that code is nuts. Part of it is that private identifiers must begin with an underscore and capital letter in order to avoid conflicting with anything defined by the application. Though I have to admit, after staring at it for a while, it actually becomes almost readable. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1180203">
				<div id="div-comment-1180203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">vs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180203">
			March 17, 2015 at 3:35 am</a>		</div>

		<p>Hello Raymond,</p>
<p>sorry for the OFFTOPIC question, but the Suggestions Box 4 comments are long time closed.</p>
<p>Would you be willing to explain the reasons behind MSI GUID Compression?</p>
<p><a rel="nofollow" target="_new" href="http://www.symantec.com/connect/articles/brief-note-installer-guids">http://www.symantec.com/&#8230;/brief-note-installer-guids</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-even depth-1" id="comment-1180233">
				<div id="div-comment-1180233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180233">
			March 17, 2015 at 7:15 am</a>		</div>

		<p>@Rodger The standard library code must be done extremely defensively. It will be (ab)used everywhere and tested to the limit. Common (stupid) things developers do that are allowed by the standard are overloading operator, and operator&amp;. Or defining their own std namespace with conflicting names and then doing a using namespace std;</p>
<p>Perhaps Raymond can get STL (Stephan T. Lavavej) to do a guest post about it.</p>
<div class="post">[<em>Also, the standard library code has to be careful never to use an identifer that an app may have #define&#39;d, which is why all the internal identifiers are horrible-looking. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1180303">
				<div id="div-comment-1180303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180303">
			March 17, 2015 at 9:45 am</a>		</div>

		<p>vs:</p>
<p>The GUID compression isn&#39;t the weirdo, GUIDs are:</p>
<p> &nbsp;<a rel="nofollow" target="_new" href="http://stackoverflow.com/a/277107/37923">stackoverflow.com/&#8230;/37923</a></p>
<p>The word DWORD 0xD0F23C3F is actually stored as the byte sequence 3F 3C F2 D0, so that&#39;s how the &quot;compressed&quot; GUID starts. The only thing compressed about it is removing the hyphens and braces.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1180373">
				<div id="div-comment-1180373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180373">
			March 18, 2015 at 12:53 am</a>		</div>

		<p>@vs:</p>
<p>&gt; Would you be willing to explain the reasons behind MSI GUID Compression?</p>
<p>&quot;GUID compression&quot; is pretty simple. A GUID is defined as a DWORD-WORD-WORD-WORD-WORD-BYTE-BYTE-BYTE-BYTE-BYTE-BYTE. In LittleEndian this means that the GUID &quot;D0F23C3F-CA74-460F-9ADB-49CBD57F9688&quot; is stored by the byte sequence 3D3CF2D074CA0F46DB9A49CBD57F9688, which is the format the MSI installer uses.</p>
<p>Tl;dr: &quot;GUID compression&quot; within installers is just the little-endian bytewise representation of a GUID, expressed in hexadecimal form.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1180383">
				<div id="div-comment-1180383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180383">
			March 18, 2015 at 2:18 am</a>		</div>

		<p>&gt; That the implementation behaves this way is not surprising. After all, the CLR does not have insight into the Get足Tick足Count function. It does not know a priori whether that function will create any COM objects. After all, we could have been p/invoking to SHGet足Desktop足Folder, which does use COM. Given that the CLR cannot tell whether a native function is going to use COM or not, it has to initialize COM just in case.</p>
<p>Wouldn&#39;t a better solution have been to say if you want to PInvoke SHGetDesktopFolder, you need to PInvoke CoInitializeEx first? If we can expect programmers in the Win32 context to call CoInitializeEx before they call SHGetDesktopFolder, why can&#39;t the CLR team expect C# programmers to PInvoke CoInitalizeEx before they PInvoke SHGetDesktopFolder?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1180423">
				<div id="div-comment-1180423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180423">
			March 18, 2015 at 8:16 am</a>		</div>

		<p>@Matt: Except that according to the Symantec blog post, it swaps not just bytes, but nibbles as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1180563">
				<div id="div-comment-1180563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180563">
			March 18, 2015 at 2:37 pm</a>		</div>

		<p>&gt; Given that the CLR cannot tell whether a native function is going to use COM or not, it has to initialize COM just in case.</p>
<p>These functions&#39; native callers are smart enough to call CoInitializeEx if they need to. There are a million unsafe things you can do if you misuse P/Invoke &#8211; why does this one in particular have training wheels on?</p>
<div class="post">[<em>The CLR already has to manage its own use of COM. So you&#39;re saying that there should be two different people both trying to manage COM? What if they disagree? (E.g., you p/invoke to CoInitializeEx(MTA), but the thread is marked [STA].) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1180683">
				<div id="div-comment-1180683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150316-00/?p=44463#comment-1180683">
			March 19, 2015 at 8:23 am</a>		</div>

		<p>Medinoc: you&#39;re right, I forgot that step. It actually swaps the nibbles of every byte, and as it doesn&#39;t swap the first two bytes of the second half, I&#39;m guessing it&#39;s not just reversing strings). Here&#39;s an example from my machine:</p>
<p>GUID {E5B21F11-6933-4E0B-A25C-7963E3C07D11}</p>
<p>Bytes 11 1F B2 E5 33 69 0B 4E A2 5C 79 63 E3 C0 7D 11</p>
<p>Product 11F12B5E3396B0E42AC597363E0CD711</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>