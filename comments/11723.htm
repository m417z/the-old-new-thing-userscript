<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (44)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-889253">
				<div id="div-comment-889253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889253">
			January 19, 2011 at 7:22 am</a>		</div>

		<p>IIRC the net command in Windows for Workgroups did not allow you to run it under the MS-DOS Prompt, you needed to exit Windows first. &nbsp;Now I know why.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889263">
				<div id="div-comment-889263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889263">
			January 19, 2011 at 7:44 am</a>		</div>

		<p>In case you haven&#39;t already seen it, <a rel="nofollow" target="_new" href="http://apollo13.spacelog.org/" rel="nofollow">http://apollo13.spacelog.org/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889273">
				<div id="div-comment-889273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chad Chisholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889273">
			January 19, 2011 at 7:52 am</a>		</div>

		<p>The space shuttle can&#39;t get anywhere near the moon.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889283">
				<div id="div-comment-889283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889283">
			January 19, 2011 at 7:52 am</a>		</div>

		<p>Perhaps a better question is why winipcfg wasn&#39;t ported to NT. The ipconfig program requires you to start a command prompt and then run ipconfig, sometimes multiple times (/release,/renew). Heaven forbid that your console window&#39;s buffer is smaller than the command&#39;s outpu. And you can&#39;t just tell somebody &quot;Click Start, click Run, enter ipconfig&quot; because it will immediately close the console window! Determining somebody&#39;s IP address over the phone is far more complicated than it was in the olden days.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889293">
				<div id="div-comment-889293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889293">
			January 19, 2011 at 8:00 am</a>		</div>

		<p>Which still leaves the question &quot;Why didn&#39;t Windows 3.1 have a console subsytem, distinct from the DOS Box, when such a system had proved its worth a million times over in NT&quot;?</p>
<div class="post">[<i>Why didn&#39;t they use the Space Shuttle to rescue the Apollo 13 astronauts? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn odd alt thread-odd thread-alt depth-1" id="comment-889313">
				<div id="div-comment-889313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889313">
			January 19, 2011 at 8:11 am</a>		</div>

		<p>@Gabe: why what could prevent you from copy wincfg.exe to your NT?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889323">
				<div id="div-comment-889323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Topley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889323">
			January 19, 2011 at 8:11 am</a>		</div>

		<p>@GWO Perhaps because Windows 3.1 predated Windows NT?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889333">
				<div id="div-comment-889333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889333">
			January 19, 2011 at 8:13 am</a>		</div>

		<p>@GWO: doesn&#39;t Windows 3.1 predate NT?</p>
<p>Personally I&#39;d have poked a tiny hole in the VM where a certain invalid instruction would have been an API call, but that&#39;s just me.</p>
<p>BTW, the Windows application can call XCreateWindow if it knows its address (the VM we use has more holes than the DOS Box VM, and XCreateWindow is somewhere in kernel address space).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889343">
				<div id="div-comment-889343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889343">
			January 19, 2011 at 8:31 am</a>		</div>

		<p>@GWO: doesn&#39;t Windows 3.1 predate NT?</p>
<p>Developmentally, they are contemporaries, but point taken &#8212; though VMS, which heavily influenced NT&#39;s design had a console subsystem &#8212; and almost every successful multi-user operating system in the entire history of the world did too &#8212; proving its worth about a zillion times over, from the early 1970s. Now .. why didn&#39;t Windows 95 have a console subsystem?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-889353">
				<div id="div-comment-889353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889353">
			January 19, 2011 at 8:45 am</a>		</div>

		<p>Actually there was INT 2F AX=1685 which allowed you to call between virtual machines. It would be pretty useless for this purpose however, since it does the call at interrupt time and requires that you already have an known address to call.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889363">
				<div id="div-comment-889363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mathieu Garstecki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889363">
			January 19, 2011 at 8:49 am</a>		</div>

		<p>GWO: because AFAIK, Windows 3.1 didn&#39;t even have the notion of subsystems. Win95 and 98 neither, they emulated the DOS console if I remember well. Subsystems are a core feature of the NT architecture, and were probably too hard to port back tn the &quot;old&quot;, DOS-based architecture.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889373">
				<div id="div-comment-889373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889373">
			January 19, 2011 at 8:51 am</a>		</div>

		<p>@Joshua</p>
<p>They did that already &#8211; they used ARPL I believe.</p>
<p>It was certainly possible (in Win 3.1 and Windows 9x) to write a VxD which provided an interface to DOS clients running in a VM. This could have provided the information for a ipconfig-like client. But it seems like an awful lot of work to go through compared to the choosen solution.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889383">
				<div id="div-comment-889383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skyborne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889383">
			January 19, 2011 at 8:53 am</a>		</div>

		<p>@Joshua re calling XCreateWindow: in the systems I am familiar with, this is part of Xlib or perhaps XCB in these modern times; both are libraries running in userspace that&#39;s linked into your app. &nbsp;Calling XCreateWindow is nowhere near issuing a syscall (into either the guest&#39;s or host&#39;s kernel), and in the end, the X server that handles the request&#8230; also runs in userspace.</p>
<p>I would further claim that, even if you swap XCreateWindow for an actual syscall, if your virtual machine manager lets guest userspace call host kernel code with a single CALL instruction, it&#39;s failing at being a virtual machine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-889393">
				<div id="div-comment-889393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889393">
			January 19, 2011 at 8:54 am</a>		</div>

		<p>Easiest way to rescue the astronauts: keep them on the ground in the first place.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889403">
				<div id="div-comment-889403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rupert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889403">
			January 19, 2011 at 9:25 am</a>		</div>

		<p>IP-Addresses are only 15 chars long, not 16.</p>
<div class="post">[<i>Don&#39;t make me bring back the nitpicker&#39;s corner. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889413">
				<div id="div-comment-889413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889413">
			January 19, 2011 at 9:32 am</a>		</div>

		<p>IP Addresses are 4 bytes long. &nbsp;They are typically represented as a string of dot-delimited decimal numbers but they can be stored in a 32-bit integer easily enough. &nbsp;Of course I think official APIs all take strings anyway (possibly to accept other forms of addresses like IPv6 or hostnames?).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889423">
				<div id="div-comment-889423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889423">
			January 19, 2011 at 9:38 am</a>		</div>

		<p>@rupert: &nbsp;I expect that he was counting the n at the end.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889433">
				<div id="div-comment-889433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889433">
			January 19, 2011 at 9:40 am</a>		</div>

		<p>@rupert: that depends how to look at it. For example: char buf[15] will NOT BE ABLE to hold some of IP-addresses. char buf[16] on the other hand WILL hold all of them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889443">
				<div id="div-comment-889443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889443">
			January 19, 2011 at 10:16 am</a>		</div>

		<p>PC Magazine experimented with DPMI and a Windows helper app to allow a DOS program to call into Windows. It worked for simple cases, but the conclusion was that while DPMI was an adequate memory manager, it left a lot to be desired for any serious use. ISTR that the best solution to the &quot;I need a console program for Windows 3.1&quot; was to use the fake consoles that were provided by the compilers at the time (QuickWin from Microsoft and Easy Win from Borland.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889453">
				<div id="div-comment-889453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889453">
			January 19, 2011 at 10:32 am</a>		</div>

		<p>@Skybourne, I believe Raymond blogged about a similar condition.</p>
<p>A pure VM would have been a bad solution. We wanted to interact with the host filesystem and desktop. Oh, and our VM doesn&#39;t actually emulate memory protection, just memory mapping, so the userspace code can execute a jmp to kernel.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889463">
				<div id="div-comment-889463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skyborne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889463">
			January 19, 2011 at 11:16 am</a>		</div>

		<p>@Joshua: the core definition of VM as I understand it is that it hides the host environment from the guest one. &nbsp;If you can call host code directly from the guest, then you don&#39;t have a VM, because you&#39;re interacting with the un-virtualized machine. &nbsp;Like a process.</p>
<p>Also, if your system isn&#39;t running unmodified Windows as a guest, then it doesn&#39;t meet the conditions Raymond established in the comparison to begin with, regardless of how you define VM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889473">
				<div id="div-comment-889473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889473">
			January 19, 2011 at 11:16 am</a>		</div>

		<p>@GWO: From a different perspective, because Windows 95 wasn&#39;t a multi-user operating system, and the most successful single-user OS at that point was Macintosh, which had no command line environment at all. So using your same logic, but applying it to single-user OSes, Windows 95 should have had no CLI.</p>
<p>@Raymond: Maybe you should start a &quot;totally missed the point&quot; box and feature Chad Chisholm.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889503">
				<div id="div-comment-889503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ebyrob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889503">
			January 19, 2011 at 12:22 pm</a>		</div>

		<p>So um&#8230; this is probably totally off-topic and all that but I&#39;m unable to find another place to post&#8230;</p>
<p>I hit &quot;Contact Me&quot; and it goes to &quot;Suggestion Box 4&quot; link is &#8211; <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2010/07/20/10040074.aspx" rel="nofollow">blogs.msdn.com/&#8230;/10040074.aspx</a></p>
<p>Unfortunately that article is apparently sealed to comments&#8230;</p>
<p>I wouldn&#39;t ordinarily care but I&#39;d really like to comment on a snippet of code in &quot;Cleaner, more elegant, and harder to recognize&quot; which of course is closed since it&#39;s really old.</p>
<p>My question is, what&#39;s wrong with the first version of the C# example?</p>
<p>NotifyIcon CreateNotifyIcon()</p>
<p>{</p>
<p>NotifyIcon icon = new NotifyIcon();</p>
<p>icon.Text = &quot;Blah blah blah&quot;;</p>
<p>icon.Visible = true;</p>
<p>icon.Icon = new Icon(GetType(), &quot;cool.ico&quot;);</p>
<p>return icon;</p>
<p>}</p>
<p>I mean, I&#39;m running it in a debugger (console C# app) and it seems to work just fine. &nbsp;If an exception is thrown nothing appears on the screen and my test app goes on it&#39;s merry way. &nbsp;Is there some memory getting allocated here that isn&#39;t properly cleaned up that isn&#39;t immediately obvious? &nbsp;(it is interesting to Note that when the application exits the icon doesn&#39;t go away, but that only occurs when there&#39;s no exception)</p>
<p>As to the other case of adding an item to a collection BEFORE properly initializing it&#8230; &nbsp;That&#39;s a multi-thread problem as well as an exception problem. &nbsp;(Purposely storing partially initialized data is wrong in any language, especially a managed language!!)</p>
<p>But really, I&#39;m very very confused by this example. &nbsp;What&#39;s wrong with the original &#39;bad&#39; CS code?!?!?! &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889513">
				<div id="div-comment-889513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889513">
			January 19, 2011 at 1:05 pm</a>		</div>

		<p>People complain that Winipcfg is not a console program, but a nice little window? Man.</p>
<p>Nowadays as far as I can tell, the information it shows is available in the dialogues in the network connections folder in the control panel.</p>
<p>Still, I think that a determined idiot might have been able to establish a Windows &lt;-&gt; DOS box communication channel via a file.</p>
<p>@ebyrob: the link you posted doesn&#39;t appear to lead to anything relevant to your question.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889523">
				<div id="div-comment-889523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JJJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889523">
			January 19, 2011 at 1:13 pm</a>		</div>

		<p>@ebyrob: &nbsp;You didn&#39;t get the hint from the closed suggestion box?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889533">
				<div id="div-comment-889533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Me</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889533">
			January 19, 2011 at 1:20 pm</a>		</div>

		<p>@ebyrob: The bad example shows the notification icon before setting the .Icon property. &nbsp;If new Icon() throws an exception, you&#39;ll end up with an blank icon on the task bar. &nbsp;In other words, it&#39;s fairly obvious when you&#39;re not checking error conditions from error-code-based code, and not so obvious when you&#39;re using exception-based-code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889543">
				<div id="div-comment-889543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Teo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889543">
			January 19, 2011 at 2:02 pm</a>		</div>

		<p>I don&#39;t remember the exact details, but I have a vague idea that the dosbox inside Windows had quite many holes. For sure, it could use int 31h to talk to the DPMI server (which essentially was the Windows VMM, right?). It also could use extended int 21h functions to query Windows version. And I think that the whole (or substantial) part of Win API was accessible through int 2fh, but I am not sure if that was in win 3.1 or win 95. Raymond, I&#39;d be very happy if sometime in the future you write a cool article about what windows functionality was accessible to dos programs back in the good old days.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889563">
				<div id="div-comment-889563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AP&#178;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889563">
			January 19, 2011 at 4:01 pm</a>		</div>

		<p>&quot;I wonder how well DOOM would have worked if it restricted itself to stdin/stdout.&quot;</p>
<p>Not that bad, actually: <a rel="nofollow" target="_new" href="http://doom.wikia.com/wiki/Text_Mode_Doom" rel="nofollow">doom.wikia.com/&#8230;/Text_Mode_Doom</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-889573">
				<div id="div-comment-889573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889573">
			January 19, 2011 at 5:04 pm</a>		</div>

		<p>[And in fact reading stdin/stout was what Windows 2.0 did. The problem is that very few DOS apps actually restrict themselves to stdin/stdout. Most of them use the BIOS or access video memory directly. (I wonder how well DOOM would have worked if it restricted itself to stdin/stdout.) -Raymond]</p>
<p>Which killed the non-IBM PC compatible MS-DOS machines. Trivia: DOS was originally developed on a S-100 8086 machine by SCP, probably before the IBM PC project even existed. And was painful for Digital Research who had the multi-tasking MP/M.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-889583">
				<div id="div-comment-889583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889583">
			January 19, 2011 at 5:11 pm</a>		</div>

		<p>[And in fact reading stdin/stout was what Windows 2.0 did. The problem is that very few DOS apps actually restrict themselves to stdin/stdout. Most of them use the BIOS or access video memory directly. (I wonder how well DOOM would have worked if it restricted itself to stdin/stdout.) -Raymond]</p>
<p>And BTW, how did Windows 2.x multitask DOS apps? </p>
<div class="post">[<i>Co&ouml;peratively. You have enough information in this very comment to fill in the rest. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889593">
				<div id="div-comment-889593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889593">
			January 19, 2011 at 5:52 pm</a>		</div>

		<p>I&#39;m kind of confused regarding the context of discussion&#8230;</p>
<p>Is there even TCP/IP exist in the days of Win3.1? I think all we have is IPX/SPX, AppleTalk, etc&#8230;</p>
<p>Actually there seems to be a limited version of ipconfig in DOS LAN Manager v2.2+ (not supporting any of the switches).</p>
<p>Also, if that&#39;s what Microsoft want, they can expose Windows features in VM as interrupt extensions.</p>
<p>But yes, it would be bad if I have to exit all other programs to free enough memory to run the program to find my ip address (or whatever basic information.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889603">
				<div id="div-comment-889603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889603">
			January 19, 2011 at 6:16 pm</a>		</div>

		<p>Cheong:</p>
<p>Windows 3.x supported TCP/IP by means of vendor supplied stacks. This means that it was available but not as a built in part of Windows itself. It wasn&#39;t until around 1994 that Microsoft themselves provided a supported TCP/IP stack for Windows 3.x, and full support was added to Windows 95.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889483">
				<div id="div-comment-889483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889483">
			January 19, 2011 at 11:22 am</a>		</div>

		<p>GWO: Windows 3.1 didn&#39;t have a console subsystem probably for the same reason that the X Window System doesn&#39;t. They are both just programs that you already run from a console. The idea being, if you wanted to run a &quot;console app&quot;, you wouldn&#39;t write it as a windowed application! But what if you want to run an app that doesn&#39;t know how to make a window from within the windowing environment? Just write a windowed app that sends keystrokes to the console apps&#39; stdin and displays stdout in a window. In Unix you would call this windowed app &quot;xterm&quot;. So why didn&#39;t Windows include an xterm-equivalent? The whole point of Windows was to *elminate* obscure command lines, not encourage them!</p>
<div class="post">[<i>And in fact reading stdin/stout was what Windows 2.0 did. The problem is that very few DOS apps actually restrict themselves to stdin/stdout. Most of them use the BIOS or access video memory directly. (I wonder <a href="http://games.softpedia.com/progScreenshots/ASCII-Doom-Screenshot-12616.html" rel="nofollow">how well DOOM would have worked if it restricted itself to stdin/stdout</a>.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889613">
				<div id="div-comment-889613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">keithmo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889613">
			January 19, 2011 at 8:46 pm</a>		</div>

		<p>&quot;&#8230;and provided a way for MS-DOS programs to call WinSock APIs.&quot;</p>
<p>I did exactly this way back in 1994 during the Wolverine Project (TCP/IP-32 for WFW). It began as an experiment to see if I could write an MS-DOS app that communicated with the WinSock VXD. It was surprisingly easy to create the plumbing necessary to connect a real-mode library to the VXD entry points. I even had ipconfig working.</p>
<p>Ultimately, the changes were never committed to the source tree. There was no interest in a technology enabling one to create real-mode MS-DOS apps that could only run in Windows enhanced mode.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-889623">
				<div id="div-comment-889623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889623">
			January 19, 2011 at 8:52 pm</a>		</div>

		<p>keithmo: Not to mention that the support for Win32 console applications that had full access to most of the Win32 APIs made it obsolete.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889633">
				<div id="div-comment-889633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889633">
			January 20, 2011 at 1:54 am</a>		</div>

		<blockquote><p>
  There was no interest in a technology enabling one to create real-mode MS-DOS apps that could only run in Windows enhanced mode.
</p></blockquote>
<p>Wasn&#39;t this exactly what Microsoft TCP/IP for Windows 3.1 did? I know it has both ping.exe and ipconfig.exe, which are MS-DOS executables, but will not work unless you start them from a DOS box.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889643">
				<div id="div-comment-889643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889643">
			January 20, 2011 at 5:12 am</a>		</div>

		<p>As usual; great article; great sense of humor,&#8230; ;-)</p>
<p>And I finally bought your book, after following the blog for a couple of years now I thought it was time to get more juicy details!</p>
<p>Thanks for the great articles Raymond!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-889653">
				<div id="div-comment-889653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889653">
			January 20, 2011 at 5:20 am</a>		</div>

		<p>@ebyboy: the icon hangs around after you close the application because icon cleanup is handled by NotifyIcon&#39;s Dispose method, which is never called. Explorer doesn&#39;t test that icons are valid until the user interacts with them, i.e. it has to send messages to the window that owns them. If it discovers that the window no longer exists it removes the icon.</p>
<p>Because it&#39;s derived from System.ComponentModel.Component, it inherits that class&#39;s finalizer. The finalizer will call Dispose(false), which merely does internal cleanup, rather than notifying Explorer to remove the icon. The window that &#39;owns&#39; the icon, and handles the messages from Explorer, is in fact controlled by the NotifyIcon object, and is destroyed by the call to Dispose(false).</p>
<p>While the app is still running, the icon will behave unpredictably. After the first GC, the object will still be around because it&#39;s been moved to the freachable queue, so the icon will still work. As the finalizer thread processes the queue, to run the finalizers, it will eventually reach the NotifyIcon object&#39;s finalizer, run it, and the icon will stop working &#8211; but won&#39;t disappear until the user interacts with it.</p>
<p>If you had subscribed to any of the NotifyIcon&#39;s events, the object would have a back-link to the object implementing the event handlers, and then the GC behaviour would depend on the lifetime of that other object.</p>
<p>For proper behaviour, decide which window the icon represents, and add it to that Form&#39;s &#39;components&#39; collection (assuming you&#39;re coding with Visual Studio, whose designer will have created a &#39;components&#39; field of type System.ComponentModel.Container). The Container class calls IDisposable.Dispose on all of the objects that have been added to it, when it is itself disposed. VS generates code to Dispose the &#39;components&#39; object in the form&#39;s (or UserControl&#39;s) implementation of Dispose. When you drop a non-visual component implementing IDisposable onto the form surface, it generates code to add the component to the &#39;components&#39; collection. If you&#39;re coding by hand, you can choose to do this, or you can add a member variable to the form (or other component that should own it) and dispose it yourself when the form is disposed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889703">
				<div id="div-comment-889703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889703">
			January 20, 2011 at 7:54 am</a>		</div>

		<p>@Alexcohn: licensing issues might prevent you from copying parts of one Windows operating system to another computer. &nbsp;Wincfg is licensed for the computer on which it was originally installed. &nbsp;If wincfg was from a retail version, you could maybe uninstall the entire operating system from the computer that wincfg was on, and then copy wincfg to NT. &nbsp;If it was from an OEM version, you&#39;re not allowed to do that (legally).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-889773">
				<div id="div-comment-889773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889773">
			January 20, 2011 at 8:29 am</a>		</div>

		<blockquote><p>
  Coöperatively
</p></blockquote>
<p>&lt;3</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889823">
				<div id="div-comment-889823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889823">
			January 20, 2011 at 9:31 am</a>		</div>

		<p>Why wasn&#39;t ipconfig called ifconfig?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889913">
				<div id="div-comment-889913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889913">
			January 20, 2011 at 3:45 pm</a>		</div>

		<p>640k: &quot;Why wasn&#39;t ipconfig called ifconfig?&quot;</p>
<p>Right. &quot;Let&#39;s have two completely different and incompatible programs with the same name.&quot; See how far you get with that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-889753">
				<div id="div-comment-889753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ebyrob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889753">
			January 20, 2011 at 8:24 am</a>		</div>

		<p>@Me:</p>
<p>&gt; &#8230;you&#39;ll end up with an blank icon on the task bar&#8230;</p>
<p>Ya, OK. &nbsp;Except it doesn&#39;t behave that way. &nbsp;You get nothing in the task-bar when setting .Visible until .Icon is set. &nbsp;(.Net 2.0.50727 sp2, I tested two code-paths, valid icon and non-existent icon is there another code-path with a more interesting failure?) &nbsp;Note: If .Visible caused an empty icon to display before .Icon were set you&#39;d actually have a timing glitch.</p>
<p>@JJJ &#8211; What so the author doesn&#39;t ever want to be reached?</p>
<p>@Mike Dimmick &#8211;</p>
<p>&gt; &#8230;While the app is still running, the icon will behave unpredictably&#8230; </p>
<p>Well, so NotifyIcon is disposable, that actually makes all the CS examples really obviously incorrect. &nbsp;Except the &#39;broken&#39; CS example is actually pretty darn functionally correct since dispose isn&#39;t needed until .Icon property is set and that&#39;s the very last thing that happens before return. &nbsp;Moving .Visible below .Icon is probably more risky since it&#39;s clearly got some logic behind it.</p>
<p>Hmm&#8230; &nbsp;What if all .Net System.ComponentModel.Component objects were guaranteed not to require .Dispose() till after they were added to a live window?</p>
<p>The note about the icon not going away was really just a jab at the OS bug surrounding task-bar icons&#8230; (file handles, by contrast, *do* get cleaned up on process exit.)</p>
<p>&gt; &#8230;and the icon will stop working&#8230;</p>
<p>Mine keeps displaying &quot;blah blah blah&quot; on hover after I force-run the garbage collector&#8230; &nbsp;(Although I always wonder which versions of .Net will implement GC calls like this {})</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-889983">
				<div id="div-comment-889983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110119-00/?p=11723#comment-889983">
			January 20, 2011 at 11:09 pm</a>		</div>

		<p>Shouldn&#39;t be more confusing than &quot;System32&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>