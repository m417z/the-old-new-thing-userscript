<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (22)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1355895">
				<div id="div-comment-1355895" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodr√≠guez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355895">
			August 8, 2018 at 9:09 am</a>		</div>

		<p>In the mid-to-late 90s we entered the post-RISC epoch. RISC architectures got more complex while CISC ones migrated to RISC back ends with CISC-to-RISC translation units as front ends (if you read documentation about the Pentium Pro or any newer x86/x64 architecture, make a mental s/micro-op/RISC instruction/). And both introduced advanced techniques such as out-of-order execution, register renaming, branch prediction and speculative execution at about the same time. In the end, the biggest architectural difference between both families is the presence (or absence) of the translation unit.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-koldude odd alt depth-2 parent" id="comment-1355935">
				<div id="div-comment-1355935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355935">
			August 8, 2018 at 11:26 am</a>		</div>

		<p>Actually not even that, many &#8216;RISC&#8217; machines have translation units so they can run different internal microarchitectures.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1355955">
				<div id="div-comment-1355955" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355955">
			August 8, 2018 at 11:40 am</a>		</div>

		<p>All right, they might have translation units but the intention is completely different. In a x86 like CISC architecture, translation unit&#8217;s job is to punch out simpler micro-instructions which are easier to implement, pipeline etc. In processors like MIPS, the translation unit provides architectural emulation and some times bug for bug compatibility.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1355905">
				<div id="div-comment-1355905" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355905">
			August 8, 2018 at 10:13 am</a>		</div>

		<p>If they&#8217;re going to do that with r0 they should have gone all the way and hardwired r0 to 0</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1355965">
				<div id="div-comment-1355965" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">HiTechHiTouch</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355965">
			August 8, 2018 at 11:58 am</a>		</div>

		<p>The IBM way is/was to pass function return values in R0.  Thus R0 was kept accessible for holding stuff.  </p>
<p>The traditional rule is that when address arithmetic (calculation) is involved, R0=constant zero=omitted from the calculation.  Zero in the register field of instructions that directly use the ALU (arithmetic, logical, compare, etc.) refer to the register contents.  In other instructions, a zero in the register field could be used for signaling instruction variations. </p>
<p>Note that I&#8217;m speaking about architectures previous to PowerPC which influenced the designers.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1356375">
				<div id="div-comment-1356375" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://peeterjoot.com' rel='external nofollow' class='url'>Peeter Joot</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356375">
			August 12, 2018 at 6:10 am</a>		</div>

		<p>A commenter wrote: &#8220;The IBM way is/was to pass function return values in R0.&#8221;</p>
<p>That isn&#8217;t the case on AIX.  function return values (and the first param) are always in r3.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1355945">
				<div id="div-comment-1355945" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355945">
			August 8, 2018 at 11:37 am</a>		</div>

		<p>Raymond, reduced in &#8220;RISC&#8221; means reduced complexity not reduced number of instructions. If that were the case, most CISC ISA would be called RISC instead.</p>
<p>I hope your bonus chatter was intentional and you are checking how attentive your readers are.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1355975">
				<div id="div-comment-1355975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355975">
			August 8, 2018 at 1:25 pm</a>		</div>

		<p>&gt; The second operand is subtracted from the third operand; in other words, the two operands are backwards. [and other quotes from previous articles]</p>
<p>Sometimes I wonder if people who design assembly languages deliberately make them awful because it makes them feel more like a Real Programmer.</p>
<p>&lt;flamebait&gt; See also: AT&amp;T syntax for x86 &lt;/flamebait&gt; :-)</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1356045">
				<div id="div-comment-1356045" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fabian Giesen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356045">
			August 9, 2018 at 1:00 am</a>		</div>

		<p>The &#8220;subtract from&#8221; thing is actually there for a reason, namely the immediate variants! Note that &#8220;addi&#8221; has a signed immediate. There&#8217;s no need to have a &#8220;subtract immediate&#8221; instruction because to say subtract 123 from r0, you can just add -123 to it.</p>
<p>However, the variant you can&#8217;t do with a signed &#8220;add immediate&#8221; is &#8221; &#8211; register&#8221;. Which is, conveniently, exactly what &#8220;subfi&#8221; does. For register-register variants, it doesn&#8217;t really matter which convention you choose (regular sub is &#8220;a + ~b + 1&#8221;, subtract-from is &#8220;~a + b + 1&#8221;), but IBM picked the one that makes the immediate forms more useful, while also keeping the instruction encoding regular. PPC is one of relatively few architectures that let you do this in one instruction; on most, you need two instructions (either a load immediate follow by a register-register subtract, or a negate followed by an add-immediate). The only other example I can think of off the top of my head is 32-bit ARM which has &#8220;rsb&#8221; (reverse subtract). (The 64-bit A64 encoding removes it.)</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1356145">
				<div id="div-comment-1356145" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356145">
			August 9, 2018 at 9:31 am</a>		</div>

		<p>I&#8217;m not talking about the actual operations that are accessible or what the processor does, and don&#8217;t dispute that something like &#8220;subfi&#8221; is be useful in a semantic sense. I&#8217;m just talking about the concrete assembler syntax.</p>
<p>In the case of the sub instructions, the question would be why the &#8216;subf&#8217; form are the &#8220;native&#8221; instructions while the &#8216;sub&#8217; forms are the synthetic instructions. But that&#8217;s just the most recent example. Yesterday there was the &#8220;only a processor&#8217;s mother could love&#8221; comment about <i>crand   4*cr3+eq, 4*cr2+lt, 4*cr6+gt</i> vs <i>crand   14, 8, 25</i>, but even the first of those is pretty terrible compared to something with a more &#8220;native&#8221; syntactic support in the assembler. Even the fact that, in &#8220;native&#8221; syntax, you can&#8217;t tell immediates from register names without knowing what the instruction does because &#8220;r3&#8221; is just written &#8220;3&#8221;.</p>
<p>And you may say this doesn&#8217;t matter because you can just write the asm in the way you want with macros and using the <i>sub</i> synthetic instructions instead of the &#8220;native&#8221; <i>subf</i>, but I think that this is a woefully incomplete solution. It means that all code you might want to read should be written that way, but in reality that won&#8217;t be true. I&#8217;m probably biased by my own uses of assembly, but nearly all ways *I* use it are reading what is produced either by <i>-S</i> to the compiler or by a disassembler. And guess what it will produce? Not <i>sub</i>, but <i>subf</i>. GNU objdump <i>does</i> apparently produce by default the alias-based things like <i>4*cr3+eq</i>, and uses &#8220;r&#8221; prefixes for registers; Raymond earlier wrote that the Windows disassembler substitutes some, but not all, of those symbolic names. (And like I said, even &#8220;4*cr3+eq&#8221; is pretty awful, especially if the assembler would accept a mistaken &#8220;cr3+eq&#8221; thing.) Apparently neither GCC nor Clang do either of these things with <i>-S</i> however, by default. (I didn&#8217;t play around with options.)</p>
<p>You might argue that it&#8217;s closer to the actual instruction encoding, but I don&#8217;t think this is a great argument either. Again I&#8217;m probably biased by my own uses of assembly, but I (i) use asm a lot, especially if you include reading, and (ii) almost never care about the actual physical encoding in machine code. I suspect that&#8217;s pretty typical.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1356435">
				<div id="div-comment-1356435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vas Crabb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356435">
			August 12, 2018 at 11:08 pm</a>		</div>

		<p>PowerPC is regular enough that you can disassemble a lot of it mentally (provided you can &#8220;see&#8221; bitfields in your head).  You just need to remember the fields are 6-5-5-5-10-1 for most instructions.  The fields three 5-bit fields line up with the three instruction operands.  This gives you a bit of inconsistency like stores having the source register (officially the &#8220;target register&#8221;) on the left, and the &#8220;subtract from&#8221; syntax, but it makes dealing with the machine code by hand easier.  Contrast this with SPARC where the order of operands in the assembly language differs from the order of fields in the instruction encoding.  PowerPC is easier to deal with if you need to actually deal with the instruction encoding.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-3" id="comment-1356175">
				<div id="div-comment-1356175" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fabian Giesen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356175">
			August 9, 2018 at 1:34 pm</a>		</div>

		<p>This got a bit mangled due to careless markup on my side. It was intended to read &#8220;immediate &#8211; register&#8221;, but I foolish put the word &#8220;immediate&#8221; in angle brackets. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1356205">
				<div id="div-comment-1356205" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356205">
			August 10, 2018 at 6:22 am</a>		</div>

		<p>&#8220;The ‚Äúsubtract from‚Äù thing is actually there for a reason.&#8221;</p>
<p>The assembler syntax (in this case, the order of source and destination of the OP) should be consistent, regardless of how the bits in the actual instruction are assigned.</p>
<p>For an extreme example of instruction encoding, see 4.6.12 T4, an ARM Thumb-2 instruction: <a href="http://read.pudn.com/downloads159/doc/709030/Thumb-2SupplementReferenceManual.pdf" rel="nofollow">http://read.pudn.com/downloads159/doc/709030/Thumb-2SupplementReferenceManual.pdf</a>  (taken from <a href="https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html" rel="nofollow">https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html</a>). It&#8217;s the job of the assembler to put it all together in the right form and order.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bbanelli odd alt thread-even depth-1 parent" id="comment-1355995">
				<div id="div-comment-1355995" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/bbanelli' rel='external nofollow' class='url'>bbanelli</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1355995">
			August 8, 2018 at 1:59 pm</a>		</div>

		<p>Well, except &#8220;reduced&#8221; doesn&#8217;t really implies bare number of instructions, rather their complexity (or simplicity, that is), right?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1356125">
				<div id="div-comment-1356125" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wear</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356125">
			August 9, 2018 at 7:33 am</a>		</div>

		<p>One would assume that implementing 1 instruction is simpler than implementing 2 which in turn means that reduced complexity would imply reduced number of instructions.</p>
<p>Also it&#8217;s Bonus snark which would imply it&#8217;s not serious.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1356035">
				<div id="div-comment-1356035" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vas Crabb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356035">
			August 9, 2018 at 12:57 am</a>		</div>

		<p>Ah, the tricksy r0.  The Apple assembler actually required you to use r0, r1, r2, etc. when referring to registers, and 0 for constant zero.  It would throw an error if you wrote r0 when a zero that field represents constant zero, and vice versa, to help avoid confusion.  On the other hand, the IBM assembler doesn&#8217;t accept r0, r1, r2, etc. and requires you to just use numbers everywhere.  You could make macros, but that wouldn&#8217;t get you you the safety benefit.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1356245">
				<div id="div-comment-1356245" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356245">
			August 10, 2018 at 8:37 am</a>		</div>

		<p>&#8220;The IBM assembler doesn&#8217;t accept r0, r1, etc.&#8221;  </p>
<p>Which IBM assembler are you talking about?  I wrote a lot of code in IBM S/370 and S/390 assembler (Assembler G, Assembler H, etc.) for many years.  We absolutely used R0, R1, etc. in our code.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1356495">
				<div id="div-comment-1356495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356495">
			August 13, 2018 at 8:19 am</a>		</div>

		<p>Of course, you might have been talking about &#8220;the IBM assembler for PowerPC&#8221;.  In which case you may well be right.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1356565">
				<div id="div-comment-1356565" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vas Crabb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356565">
			August 13, 2018 at 8:32 pm</a>		</div>

		<p>Yeah, I was talking about the IBM POWER/PowerPC assembler for AIX on RS/6000 (and similarly the Apple PowerPC assembler) back in the &#8217;90s.  It&#8217;s a bit of a weird implementation choice given they already allowed rN syntax on S/390 etc.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1356075">
				<div id="div-comment-1356075" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356075">
			August 9, 2018 at 5:15 am</a>		</div>

		<p>Subtract from? Are these guys looking through microcode-coloured glasses?</p>
<p>I tried to work out what the difference between &#8220;add minus one extended&#8221; and a hypothetical &#8220;subtract zero extended&#8221; (which is the operation I&#8217;d want to use) but I can&#8217;t tell whether the carry semantics are the same.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1356115">
				<div id="div-comment-1356115" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vas Crabb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356115">
			August 9, 2018 at 7:18 am</a>		</div>

		<p>Yes, that&#8217;s the whole point of it.  It&#8217;s to apply the borrow when you want to subtract a 32-bit value from a 64-bit value.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1356285">
				<div id="div-comment-1356285" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180808-00/?p=99445#comment-1356285">
			August 10, 2018 at 12:54 pm</a>		</div>

		<p>Even today, is there any compiler that can use that much instruction variations for such simple operations like integer addition/subtraction?</p>
<p>Also: Did they cut the more useful features, because they wasted too much OP codes for every thinkable variation of things like that?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>