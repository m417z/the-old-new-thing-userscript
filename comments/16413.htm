<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (12)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-776943">
				<div id="div-comment-776943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-776943">
			October 12, 2009 at 9:28 am</a>		</div>

		<p>There&#8217;s something very screwy going on with your autoposter (in case you hadn&#8217;t noticed).</p>
<div class=post>[<i>This is all fallout from the systems upgrade last Friday. Hopefully the dust will settle soon. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-776963">
				<div id="div-comment-776963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-776963">
			October 12, 2009 at 10:31 am</a>		</div>

		<p>The answer &quot;why you need import libraries&quot;:</p>
<ol>
<li>
<p>You can combine multiple import libraries into one LIB, along with &quot;real&quot; OBJs.</p>
</li>
<li>
<p>You can make an import library from a DEF file, even if you don&#8217;t have a real DLL at hand.</p>
</li>
<li>
<p>You could provide only public exports in a LIB, leaving private exports out.</p>
</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-776973">
				<div id="div-comment-776973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-776973">
			October 12, 2009 at 10:33 am</a>		</div>

		<ol>
<li>You can make 2 DLLs cross-link each other, without trying to solve egg-chicken dilemma.</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-776983">
				<div id="div-comment-776983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-776983">
			October 12, 2009 at 10:36 am</a>		</div>

		<p>&quot;This goes back to the classical model for linking. This model existed for decades before Microsoft was even founded, so at least this time you don&#8217;t have Bill Gates to kick around. &quot;</p>
<p>And thus is not even unique to Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-776993">
				<div id="div-comment-776993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-776993">
			October 12, 2009 at 1:56 pm</a>		</div>

		<p>C++ compilers use name decoration to avoid name collisions of overloaded functions. That&#8217;s the main reason.</p>
<p>Some compilers (e.g. Borland C++) don&#8217;t include the return type in the decored named, because functions cannot be overloaded on their return types.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777003">
				<div id="div-comment-777003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.embarcadero.com/pawelglowacki' rel='external nofollow' class='url'>Paweł Głowacki</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-777003">
			October 12, 2009 at 2:45 pm</a>		</div>

		<p>I love your mentioning one-pass compiler &#8211; yeah: it is Delphi Programming for ever and ever (now with Win7 and multitouch in the VCL):-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777013">
				<div id="div-comment-777013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David M</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-777013">
			October 12, 2009 at 4:10 pm</a>		</div>

		<p>Delphi still has a one-pass compiler, and is still blazingly fast. &nbsp;It now includes a linker step, but the object files (DCUs) are smarter than OBJs (pretty much raw compiler output, the format changes with every compiler revision, and the linker can load them straight in) and so the performance there is good too. &nbsp;It&#8217;s still not uncommon for a large program to build in a few seconds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777023">
				<div id="div-comment-777023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-777023">
			October 12, 2009 at 4:26 pm</a>		</div>

		<p>Good post.</p>
<p>External used to be limited to SIX characters (at least when C was first standardized by ANSI), which is why strncpy wasn&#8217;t called strcpyn.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777033">
				<div id="div-comment-777033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://henning.makholm.net/' rel='external nofollow' class='url'>Henning Makholm</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-777033">
			October 12, 2009 at 6:24 pm</a>		</div>

		<p>And even C decorates names these days, for functions with stdcall (aka WINAPI) calling convention,</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777043">
				<div id="div-comment-777043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-777043">
			October 12, 2009 at 10:09 pm</a>		</div>

		<p>Actually, C name decoration is a x86 artifact. Other architectures let you get away without WINAPI and other stuff like PASCAL or cdecl because they have a calling convention. (I&#8217;ve had code that compiles fine on ARM and MIPS but dies on x86 because of a missed WINAPI). x86 doesn&#8217;t, which leaves us with a million ways of calling a function.</p>
<p>Anyhow, a peculiarity of Win32 is that all executables (DLL&#8217;s, EXE&#8217;s and others of the sort) must have symbols resolved, even if the symbol is in another file. ELF doesn&#8217;t, and lets you do wierd things like have unresolved symbols in dynamic libraries. (Executables can&#8217;t, for obvious reasons, but the linker just needs proof that there&#8217;s something somewhere during linking that will provide it). Fun things happen when you link with one library, but provide another during runtime (cross-compiling &#8211; you need a &quot;proof&quot; library during linking, but the actual one used during execution can be different).</p>
<p>But since an ELF shared object can have dangling references, you don&#8217;t find out until you run and load&#8230; (this way stuff like C libraries are linked on load).</p>
<p>It does have a fun aspect. I wrote a utility that built in a library of functions client libraries had to use. Those libraries linked fine, and they linked back to the executable when the executable loaded them. When someone ported it to win32, they had to break out those functions as a DLL on its own linked by both.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777063">
				<div id="div-comment-777063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nitpicker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-777063">
			October 13, 2009 at 5:29 am</a>		</div>

		<p>&gt; the compiler merely agreed </p>
<p>&#8230; &#8220;merrily agreed&#8221;?</p>
<div class=post>[<i>Not a typo, but now that you mention it, I wish I had written &#8220;merrily.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777793">
				<div id="div-comment-777793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jared</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091012-00/?p=16413#comment-777793">
			October 14, 2009 at 10:40 am</a>		</div>

		<p>Just for the record, the major mainframe architecture had no limitations on character set, and there were products which took advantage of that fact to encode limited information into external names in the early 1970s, if not before.</p>
<p>(FWIW, I was one of the owners of the IEWLxxx code.)</p>
<p>Virtually everything I&#8217;ve seen in the PC world has an analogue in early computing. &nbsp;Today&#8217;s problems were recognized and addressed and the solutions &quot;lost&quot; to the newer generation who have re-invented the wheel. &nbsp;</p>
<p>Pioneers recognized the consequences of some choices and deliberately avoided them (c.f. null terminated strings discussion) not because of resource restrictions, but because of foresight.</p>
<p>Many, many &quot;software patents&quot; have granted since the internet took off which are not &quot;new art&quot; &#8212; pioneers already used the idea in systems long forgotten by history and now reinvented for the PC.</p>
<p>If Google can&#8217;t find it, it must not exist, right?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>