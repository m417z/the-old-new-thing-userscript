<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (56)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-573413">
				<div id="div-comment-573413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jachymko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573413">
			December 3, 2007 at 10:10 am</a>		</div>

		<p>What geeky stuff used to be in the AX register in Windows 2.0, if I may ask? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573423">
				<div id="div-comment-573423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.vibrant3d.net' rel='external nofollow' class='url'>Mark Mullin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573423">
			December 3, 2007 at 10:15 am</a>		</div>

		<p>Uggh &#8211; having horrible flashbacks to DS != SS errors</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573443">
				<div id="div-comment-573443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Idiot</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573443">
			December 3, 2007 at 10:28 am</a>		</div>

		<p>&quot;If it were called main, people would take C programs designed for a console environment, throw them into their Windows compiler, and then run them, with disastrous results.&quot;</p>
<p>You can only idiot-proof things so much; in the end, the idiot always wins.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573453">
				<div id="div-comment-573453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bahbar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573453">
			December 3, 2007 at 11:55 am</a>		</div>

		<p>@jachymko: geeky stuff in the AX register</p>
<p>42?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573473">
				<div id="div-comment-573473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.starkeith.net/coredump/' rel='external nofollow' class='url'>Keithius</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573473">
			December 3, 2007 at 12:41 pm</a>		</div>

		<p>This is one of the best articles I have ever read here. It&#8217;s geeky and historical in a way that is just intensely satisfying.</p>
<p>And that last comment brought a very geeky smile to my face. ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573503">
				<div id="div-comment-573503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573503">
			December 3, 2007 at 2:44 pm</a>		</div>

		<p>Most of these excuses for why Win16 programs didn&#8217;t fit well with normal C programs could have been solved with a little bit of work &#8211; take a look at the WinIO/WinDOS library that Andrew Schulman (et al?) came up with:</p>
<p><a rel="nofollow" target="_new" href="http://www.digitalmars.com/rtl/winio.html" rel="nofollow">http://www.digitalmars.com/rtl/winio.html</a></p>
<p>I suspect that the main reasons that this did not occur at Microsoft are (of course the following is complete speculation):</p>
<p>1) Windows was originally viewed as something that ran on top of DOS, not as an OS in its own right</p>
<p>2) these changes would have required some sort of cooperation form the compiler team, and the effort/clout/whatever did not exist. &nbsp;It&#8217;s even possible that the reason might have been that the compiler was still OEM&#8217;ed from a different company (Lattice C) and therefore was largely controlled by Lattice at that time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573513">
				<div id="div-comment-573513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thoe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573513">
			December 3, 2007 at 2:45 pm</a>		</div>

		<p>Nice to see you use present tense when speaking about 16-bit applications. I spend 30-50% of my time maintaining an old C++ 16-bit application, so I still live with all the joys of 64K limits :-)</p>
<p>Thinking about the good old &quot;Interrupt 21&quot; days &#8211; made me think: Is there still a benefit in writing &quot;raw code&quot;? Back then you could beat the compiler by an order of magnitude, writing assembly in critical places. Can you beat the compiler today by writing CIL directly?</p>
<p>(I don&#8217;t think I will take the asm-route, modern CPU&#8217;s seems to complicated)</p>
<p>And if you can beat the compiler &#8211; where is the great guide that shows how?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573523">
				<div id="div-comment-573523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573523">
			December 3, 2007 at 2:51 pm</a>		</div>

		<p>I&#8217;ve got no experience with low-level windows stuff, so this might be a stupid question, but what is the purpose of &quot;HINSTANCE hinst, HINSTANCE hinstPrev and int nCmdShow&quot; and why do they need to be included in the main function ?</p>
<p>&quot;If it were called main, people would take C programs designed for a console environment, throw them into their Windows compiler, and then run them, with disastrous results.&quot;</p>
<p>How come ? wouldn&#8217;t they just run as a console program ? GUI and CL applications start exactly the same in a normal OS. What is so different in Windows that a normal main() function is not enough ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573533">
				<div id="div-comment-573533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573533">
			December 3, 2007 at 3:02 pm</a>		</div>

		<p>I&#8217;m often baffled that some people were disturbed WinMain vs main. &nbsp;From my point of view, writing a Windows app was already not pure character mode &quot;C&quot; code, and with many GUI toolkits it was typical that the &#8216;main&#8217; was in the library and not your code. &nbsp;The name of that one startup function doesn&#8217;t matter.</p>
<p>In any case, I seem to remember that Borland C++ detected you used &#8216;main&#8217; in your stdio app and linked with EasyWin instead, which created a GUI window and handled printf/scanf, everything for your character-mode C app to run in Windows 3.1. &nbsp;</p>
<p>For Microsoft VC++ 1.x, it was offered by a library called &quot;QuickWin&quot;</p>
<p>In both cases your standard C app became a GUI Windows 3.x app with a basic menu and MDI window.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573543">
				<div id="div-comment-573543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573543">
			December 3, 2007 at 3:02 pm</a>		</div>

		<p>&quot;Is there still a benefit in writing &quot;raw code&quot;? Back then you could beat the compiler by an order of magnitude, writing assembly in critical places. Can you beat the compiler today by writing CIL directly?&quot;</p>
<p>Probably not. Since the CIL code is not native code there will always be a compiler or interpreter between you and the hardware. &nbsp;The JIT can do runtime optimization so at least in theory it could be faster that native compiled code because it can analyse the running system and adapt it&#8217;s optimizations, and it can optimize for the actual CPU you&#8217;re using instead of a class of cpu&#8217;s.</p>
<p>Furthermore, you cannot assume to know what kind of CPU architecture the application wil run on. (I know .NET is not as portable as MS says it is, but still)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573553">
				<div id="div-comment-573553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573553">
			December 3, 2007 at 3:03 pm</a>		</div>

		<p>&quot;How come ? wouldn&#8217;t they just run as a console program ? GUI and CL applications start exactly the same in a normal OS. What is so different in Windows that a normal main() function is not enough ?&quot;</p>
<p>Because of the funky way the Windows executable format works. There are bits in it that you can set to indicate that the program is a console program or a GUI program. If you set the &#8216;console program&#8217; bit, Windows will pop up a console when the program is launched. The compiler is supposed to set that bit if the program has a main() function, and set the GUI program bit if it has a WinMain function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573563">
				<div id="div-comment-573563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573563">
			December 3, 2007 at 3:07 pm</a>		</div>

		<p>&quot;I&#8217;ve got no experience with low-level windows stuff, so this might be a stupid question, but what is the purpose of &quot;HINSTANCE hinst, HINSTANCE hinstPrev and int nCmdShow&quot; and why do they need to be included in the main function ?&quot;</p>
<p>I was going to go back to my Win16 programming books to look it up again, but as it so happens Raymond wrote about it:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2004/06/15/156022.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2004/06/15/156022.aspx</a></p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2004/06/14/155107.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2004/06/14/155107.aspx</a></p>
<p>The above should give some explanation for the previous instance handle at least. &nbsp;I thought I knew what the cmdshow thing was but it is escaping me at the moment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573583">
				<div id="div-comment-573583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573583">
			December 3, 2007 at 3:11 pm</a>		</div>

		<p>Aaargh!, Triangle, I think you&#8217;re both confused with Win32 newness. &nbsp;This is Windows 3.1 &nbsp;that we&#8217;re talking about, a GUI environment that ran on top of DOS, and dos executable. It wasn&#8217;t an operating system. &nbsp;There was no console mode windows 16-bit application, that&#8217;s all new in Win32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573593">
				<div id="div-comment-573593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573593">
			December 3, 2007 at 3:14 pm</a>		</div>

		<p>&#8220;There are bits in it that you can set to indicate that the program is a console program or a GUI program. If you set the &#8216;console program&#8217; bit, Windows will pop up a console when the program is launched.&#8221;</p>
<p>What if you want a GUI program with a console ? (e.g. for debug output while developing) And what happens to the programs stdin/stderr/stdout if there is no console ? Are they still connected to something ?</p>
<div class=post>[<i>I don&#8217;t know what you folks are talking about. There was no such thing as a &#8216;console program&#8217; in 16-bit Windows. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573603">
				<div id="div-comment-573603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573603">
			December 3, 2007 at 3:17 pm</a>		</div>

		<p>&quot;There was no console mode windows 16-bit application, that&#8217;s all new in Win32.&quot;</p>
<p>IIRC it was possible to open a shell in Win 3.11 and you could run console applications from there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573613">
				<div id="div-comment-573613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573613">
			December 3, 2007 at 3:21 pm</a>		</div>

		<p>&quot;IIRC it was possible to open a shell in Win 3.11 and you could run console applications from there.&quot;</p>
<p>But there were no Windows Executable files in windows 3.11, it used COM files. So Ulric is right about the impossibility of that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573623">
				<div id="div-comment-573623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thoe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573623">
			December 3, 2007 at 3:23 pm</a>		</div>

		<blockquote><p>
  I&#8217;ve got no experience with low-level windows</p>
<p>  stuff, so this might be a stupid question, but</p>
<p>  what is the purpose of &quot;HINSTANCE hinst,</p>
<p>  HINSTANCE hinstPrev and int nCmdShow&quot; and why</p>
<p>  do they need to be included in the main</p>
<p>  function ?
</p></blockquote>
<p>Well &#8211; this is a 15 year old design, running on very small PC&#8217;s. (With applications only multitasking, when they asked for it). Knowing what is my reference-number (hinst), who started me (hinstPrev) and how should I show my main windows? &#8211; are pretty critical in the start-up &#8211; So giving that as parameters probably seemed logical.</p>
<blockquote><p>
  How come ? wouldn&#8217;t they just run as a console</p>
<p>  program ? GUI and CL applications start</p>
<p>  exactly the same in a normal OS. What is so</p>
<p>  different in Windows that a normal main()</p>
<p>  function is not enough ?
</p></blockquote>
<p>In Windows 3.1 a program were either a semi-multitasking Windows program or an exclusive DOS/console program &#8211; DOS didn&#8217;t multitask! &#8211; Win16-programs could only multi-task, when they were event-driven or very cooperative.</p>
<p>Of course Win32 changed this (with &nbsp;preemptive multitasking), and allowed console applications as equals to GUI-applications &#8211; But by then winmain was popular, and couldnt be ignored&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573633">
				<div id="div-comment-573633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573633">
			December 3, 2007 at 3:28 pm</a>		</div>

		<p>&gt;&gt; There was no console mode windows 16-bit application, that&#8217;s all new in Win32.</p>
<p>Again, that was mere oversight or laziness (see the above link to WinIO/WinDOS). &nbsp;It did not take rocket science to come up with a library that implemented stdio function calls that placed the output in a window.</p>
<div class=post>[<i>There&#8217;s nobody stopping you from using that external library. That&#8217;s the 16-bit Windows way. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573643">
				<div id="div-comment-573643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thoe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573643">
			December 3, 2007 at 3:39 pm</a>		</div>

		<p>&quot;&quot;Is there still a benefit in writing &quot;raw code&quot;?&quot;&quot;</p>
<p>&quot;Probably not. Since the CIL code is not native code there will always be a compiler or interpreter between you and the hardware.&quot;</p>
<p>I know that&#8230;</p>
<ul>
<li>I am not trying to beat the CIL to native code. (Which I am sure is possible, the compiler can&#8217;t know exactly the most effective code for each CPU &#8211; but it is probably close enough)</li>
</ul>
<p>I want to know, if I can write better CIL than the C# to CIL compiler&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573653">
				<div id="div-comment-573653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573653">
			December 3, 2007 at 4:01 pm</a>		</div>

		<p>&quot;I want to know, if I can write better CIL than the C# to CIL compiler&#8230;&quot;</p>
<p>The question is if there is such a thing as &#8216;better&#8217; CIL code. If you write an algorithm say in C# and compile that to CIL, and then you write the exact same algorithm in &#8216;optimized&#8217; CIL. Shouldn&#8217;t both result in the exact same machine code after the CIL-to-native compiler/optimizer is done with it ? And is one really better than the other ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573663">
				<div id="div-comment-573663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573663">
			December 3, 2007 at 4:07 pm</a>		</div>

		<p>Maybe C wasn&#8217;t always the center of the software development universe?</p>
<p>Windows was created in the mid-80s. People were still using Pascal, Fortran, and assembly language when it suited them. There were a lot of people who didn&#8217;t trust compilers to generate good code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573673">
				<div id="div-comment-573673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573673">
			December 3, 2007 at 4:08 pm</a>		</div>

		<blockquote><p>
  &gt; There was no console mode windows 16-bit application, that&#8217;s all new in Win32.</p>
<p>  Again, that was mere oversight or laziness</p>
<p>  (see the above link to WinIO/WinDOS).
</p></blockquote>
<p>Stop trying to plug WinIO.. :) I&#8217;ve already written about Microsoft&#8217;s own QuickWin and Borland EasyWin. &nbsp;These are separate libraries that allow making Windows app by recompiling against them without changing your code. &nbsp; In 90s, Microsoft did not create Windows so that you would code with &#8216;printf&#8217; and &#8216;scanf&#8217;. That was already a solved problem: you could compile your app as a DOS application and it runs inside a DOS box. &nbsp;The point of Windows was the mouse, event &#8211; driven programming, graphics. &nbsp;If you weren&#8217;t interested in that, you wouldn&#8217;t make a Windows app, you&#8217;d make a DOS app. Duh.</p>
<p>Window 3.x could run DOS apps in a virtual box, and with preemptive multi-tasking at that. &nbsp;But that does not make these DOS apps Windows app. As well, running DOS apps in VMWare on a Mac doesn&#8217;t mean that DOS apps are OS X application.</p>
<p>A Win32 console application, however, is a true Windows 95 application with full support from and access to the API.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573683">
				<div id="div-comment-573683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573683">
			December 3, 2007 at 4:23 pm</a>		</div>

		<p>&gt;&gt; There&#8217;s nobody stopping you from using that external library. </p>
<p>Of course I realize that &#8211; I&#8217;m not saying that Microsoft needs to go back and change the Win16 programming model. &nbsp;I think it&#8217;s clear that my point is that nothing prevented Microsoft from doing something similar.</p>
<div class=post>[<i>You don&#8217;t write a feature because you can&#8217;t think of a reason not to do it. Don&#8217;t forget, Windows 1.0 had to run off two floppy drives. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573693">
				<div id="div-comment-573693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573693">
			December 3, 2007 at 4:37 pm</a>		</div>

		<blockquote><p>
  &gt; Stop trying to plug WinIO.. :) I&#8217;ve already written about Microsoft&#8217;s own QuickWin and Borland EasyWin.
</p></blockquote>
<p>I&#8217;m not plugging WinIO. Raymond made some points about how problematic using main() as the user&#8217;s program starting point would be. &nbsp;I&#8217;m just using that library (which I will refrain from naming again) as an example that shows that the several paragraphs pointing out problems of having Win16 support stdio and main() are somewhat misleading. &nbsp;It&#8217;s wonderful that you&#8217;ve pointed out a couple other libraries that indicate the same &#8211; good for you!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573753">
				<div id="div-comment-573753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573753">
			December 3, 2007 at 6:53 pm</a>		</div>

		<p>&gt;&gt; You don&#8217;t write a feature because you can&#8217;t think of a reason not to do it. Don&#8217;t forget, Windows 1.0 had to run off two floppy drives</p>
<p>So the reasons for &#8220;Why wasn&#8217;t the application entry point called main?&#8221; don&#8217;t really have to do with conflicts in the parameters passed to main(). &nbsp;I guess they have to do with saving space?</p>
<div class=post>[<i>Nice job, you change the subject (from &#8220;How did 16-bit Windows programs start up?&#8221; to &#8220;Why didn&#8217;t 16-bit Windows have a console subsystem?&#8221;), I give an explanation for the changed subject (&#8220;Among other reasons, there wasn&#8217;t disk space&#8221;) and then you say &#8220;Aha, so that&#8217;s the real reason why the entry point wasn&#8217;t called main!&#8221; (A third topic.) I need to use that trick. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-573763">
				<div id="div-comment-573763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573763">
			December 3, 2007 at 7:03 pm</a>		</div>

		<p>&quot;I guess they have to do with saving space?&quot;</p>
<p>I think you&#8217;re arguing two different points. From the webpage you liked to about winio:</p>
<p>&quot;WINIO is an easy-to- use, higher level library built on top of the standard Windows 3.x API&quot;</p>
<p>That the &quot;standard Windows 3.x API&quot; decided to make &quot;WinMain&quot; the conventional entry-point is totally unrelated to whether SOME OTHER application library did not.</p>
<p>If you&#8217;re trying to figure out the reason why Microsoft decided to use &quot;WinMain&quot; as the convention instead of &quot;main&quot;, then the answer could just as well be &quot;to annoy mikeb&quot; &#8212; it really doesn&#8217;t MATTER. What advantages would there have been to naming &quot;WinMain&quot; as &quot;main&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573773">
				<div id="div-comment-573773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Steward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573773">
			December 3, 2007 at 7:20 pm</a>		</div>

		<p>Triangle: NE (.exe) was the executable format used for all Windows applications.</p>
<p>Thoe: Windows 1.0 SDK&#8217;s are hard to find, but it&#8217;s probably 22 years.</p>
<p>mikeb: if you&#8217;re suggesting using QuickWin for all program startup, how would you justify the &quot;bloat&quot; of parsing the command line and creating a window with menus for stdin/out? &nbsp;You&#8217;d need a new way (i.e. WinMain) for programs that wanted to opt out. &nbsp;Well, why not make WinMain the default, and try to shed some of this back-compat cruft? ;-)</p>
<p>Ulric: The entry point is the value of CS:IP in the NE header. &nbsp;EntryPoint is the entry point from the OS&#8217;s POV. &nbsp;WinMain is the entry point from the user/programmers&#8217;s point of view.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573783">
				<div id="div-comment-573783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Steward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573783">
			December 3, 2007 at 7:41 pm</a>		</div>

		<p>P.S. I thought this issue was put to rest last year:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/1205831.aspx#1229735" rel="nofollow">http://blogs.msdn.com/1205831.aspx#1229735</a></p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/1205831.aspx#1265954" rel="nofollow">http://blogs.msdn.com/1205831.aspx#1265954</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573793">
				<div id="div-comment-573793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573793">
			December 3, 2007 at 8:19 pm</a>		</div>

		<p>Seems that I have been unclear about some of my points. &nbsp;Let me try to be clear, then I&#8217;ll drop this.</p>
<p>1) Raymond made some remarks about &#8220;Why wasn&#8217;t the application entry point called main?&#8221;. &nbsp;I believe that most of the problems pointed out about this are really non-problems. &nbsp;main() could have been used as the user starting point just as easily as WinMain(), with the Windows specific parameters provided in some other way. &nbsp;I&#8217;m not saying that MS&#8217;s decision to use WinMain() was improper. &nbsp;I&#8217;m just saying that the reasons that Raymond gave for not using main() weren&#8217;t particularly strong reasons.</p>
<p>2) other people started talking about consoles. &nbsp;I simply mentioned that the same library I had mentioned before showed that getting stdio working in Win16 was not rocket science.</p>
<p>So at this point I&#8217;d like to claim that I didn&#8217;t change subjects &#8211; I responded to 2 separate subjects. &nbsp;As for my &#8216;third topic&#8217;, I was being sarcastic since I interpreted your remark about the 2 floppy limit as being a reason for using WinMain() instead of main(); the loss of that intonation is an unfortunate side-effect of my (lack of) prose writing skills. &nbsp;I&#8217;m sorry for misunderstanding your meaning.</p>
<div class=post>[<i>Sure, the entry point could&#8217;ve been called &#8220;main&#8221; with the GUI information passed some other way. But it&#8217;s a whole new programming model; give it a new name to emphasize that new rules apply, especially in real-mode Windows, where memory could move at almost any time. Your average C program&nbsp;from a textbook would corrupt memory pretty quickly.&nbsp;-Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573813">
				<div id="div-comment-573813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573813">
			December 3, 2007 at 9:35 pm</a>		</div>

		<p>&quot;But it&#8217;s a whole new programming model; give it a new name to emphasize that new rules apply, especially in real-mode Windows, where memory could move at almost any time. Your average C program from a textbook would corrupt memory pretty quickly. -Raymond&quot;</p>
<p>What about GlobalLock and co. ?</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2004/11/04/252258.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2004/11/04/252258.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573823">
				<div id="div-comment-573823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573823">
			December 3, 2007 at 9:42 pm</a>		</div>

		<p>There was no particular reason when Windows was created, to expect that that it would ever become its own OS. That just happened to be the only option left for Microsoft after the IBM partnership and the Unix standardization process both flopped.</p>
<p>Just imagine the howls of protest if Windows had been ported to Unix with a nonstandard main declaration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573833">
				<div id="div-comment-573833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Steward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573833">
			December 3, 2007 at 9:54 pm</a>		</div>

		<p>Triangle: so your suggestion is GlobalLock everything?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573843">
				<div id="div-comment-573843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.followsteph.com' rel='external nofollow' class='url'>Stephane Grenier</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573843">
			December 3, 2007 at 9:55 pm</a>		</div>

		<p>Hi Raymond,</p>
<p>I&#8217;m trying to contact you in regards to a book I&#8217;m writing for which I&#8217;d like to interview you. I can&#8217;t seem to locate anywhere your contact information therefore this is the only way I could see to reach you. If you&#8217;re interested please contact me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dcook odd alt thread-odd thread-alt depth-1" id="comment-573703">
				<div id="div-comment-573703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Doug+E.+Cook' rel='external nofollow' class='url'>Doug E. Cook</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573703">
			December 3, 2007 at 4:55 pm</a>		</div>

		<p>Important point to note (and still true today) is that contrary to what you might think after reading MSDN, your process does NOT start at</p>
<p> &nbsp; &nbsp;int main(int argc, char** argv);</p>
<p>nor does it start at</p>
<p> &nbsp; &nbsp;WinMain(&#8230;);</p>
<p>It starts at</p>
<p> &nbsp; &nbsp;void EntryPoint(void); // Name doesn&#8217;t matter.</p>
<p>The &quot;EntryPoint&quot; symbol is provided via an offset in the executable&#8217;s header, and that is set by the linker based on the /ENTRY parameter.</p>
<p>Windows does NOT provide you with a parsed command line. Nor does it provide you with the Show command value. Your program has to get them itself. Luckily, if you&#8217;re using a &quot;runtime&quot;, the runtime usually hides this from you.</p>
<p>It just so happens that if you let the compiler and linker do their thing without trying to get too smart and overriding the default, the linker will use &quot;mainCRTStartup&quot; (for console programs) or &quot;winmainCRTStartup&quot; (for GUI programs) as the entry point. These functions are defined in the CRT library. They use various Windows APIs like GetCommandLine and GetStartupInfo to figure out the command line and Show command, then they call your program&#8217;s &quot;main&quot; or &quot;WinMain&quot; with the results. They also do nice things like initialize the CRT, call your static initializers, call static destructors at program exit, and shut down the CRT.</p>
<p>So contrary to MSDN, &quot;main&quot; and &quot;WinMain&quot; are not actually process entry points. They&#8217;re just established convention that is aided by the currently available C Runtime.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573723">
				<div id="div-comment-573723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573723">
			December 3, 2007 at 5:43 pm</a>		</div>

		<p>&quot;What if you want a GUI program with a console ? (e.g. for debug output while developing) And what happens to the programs stdin/stderr/stdout if there is no console ? Are they still connected to something ?&quot;</p>
<p>To create a console, use AllocConsole. Or just make a console program, and have it create windows in the usual fashion.</p>
<p>(The debug builds of my GUI programs are routinely console apps. They call WinMain from main, after constructing a suitable command line from argc/argv and retrieving the instance handle via GetModuleHandle(0). I do this purely because the console provides a handy scrollable colourized TTY that you can manipulate whilst your program is frozen in the debugger.)</p>
<p>If you have a non-console program, stdout/stderr/stdin don&#8217;t appear to be attached to anything useful. I guess the C runtime doesn&#8217;t set them up &quot;properly&quot; in that case. You can however use WriteConsole with GetStdHandle(STD_OUTPUT_HANDLE) &#8212; or STD_ERROR_HANDLE &#8212; and no doubt stdin has equivalent functionality too &#8212; and have it interact with the console as you might expect. These handles also work just as you&#8217;d imagine in an ordinary console program too, so you can write code that works the same in both situations.</p>
<p>(There *is* some cleverness you can do in the non-console case to manually point stdout/stderr/stdin to your newly-created console window, but I don&#8217;t recall offhand what it is, as I personally haven&#8217;t yet had the need to do this.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573733">
				<div id="div-comment-573733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573733">
			December 3, 2007 at 6:39 pm</a>		</div>

		<p>dcook :</p>
<p>&gt; The &quot;EntryPoint&quot; symbol is provided via </p>
<p>&gt;an offset in the executable&#8217;s header, and </p>
<p>&gt;that is set by the linker based on the /ENTRY &gt; parameter.</p>
<p>True for Win32 PE executables, but this blog entry is about 16-bit Windows.</p>
<p>Also, the blog entry above links to an entry from Raymond that already said &quot;The name WinMain is just a convention&quot;</p>
<p>&gt; So contrary to MSDN, &quot;main&quot; and &quot;WinMain&quot; are not actually process entry points. </p>
<p>MSDN says its &quot;the WinMain function is the conventional name for the user-provided entry point&quot;</p>
<p>Tom_:</p>
<p>&gt;If you have a non-console program, stdout/stderr/stdin don&#8217;t appear to be </p>
<p>&gt;attached to anything useful. </p>
<p>if you need to make an app that has a console, write a console app (linker setting: /subsystem:console) and get one for free. &nbsp;It can create UI, call MFC, etc.</p>
<p>If you want to create the console yourself with AllocConsole, you&#8217;ll have to use this code to remap STDIO to it:</p>
<p>		int hCrtOut = _open_osfhandle( (INT_PTR) GetStdHandle(STD_OUTPUT_HANDLE), &nbsp;_O_TEXT );</p>
<p>		*stdout	= *( _fdopen( hCrtOut, &quot;w&quot; ) );</p>
<p>		int hCrtErr = _open_osfhandle( (INT_PTR) GetStdHandle(STD_ERROR_HANDLE), &nbsp;_O_TEXT );</p>
<p>		*stderr	= *( _fdopen( hCrtErr, &quot;w&quot; ) );</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cornedbee even thread-even depth-1" id="comment-573873">
				<div id="div-comment-573873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CornedBee</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573873">
			December 4, 2007 at 4:28 am</a>		</div>

		<p>I think the main criticism of WinMain today is really that it makes cross-platform GUI programs just that bit more awkward.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573803">
				<div id="div-comment-573803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">oj</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573803">
			December 3, 2007 at 9:27 pm</a>		</div>

		<p>&quot;How do 16-bit programs start up?&quot;</p>
<p> &nbsp; &nbsp; &nbsp; &#8230;who the f*** cares any more?</p>
<p>Except maybe to prove that the OS was just as f***ed up by its designers as Vista is today.</p>
<p>oj</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573883">
				<div id="div-comment-573883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.johntopley.com/' rel='external nofollow' class='url'>John Topley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573883">
			December 4, 2007 at 5:33 am</a>		</div>

		<p>&quot;But there were no Windows Executable files in windows 3.11, it used COM files.&quot;</p>
<p>What are you talking about? As Mark Steward said, Windows 3.1 used the NE (New Executable) format.</p>
<p>&quot;This is Windows 3.1 that we&#8217;re talking about, a GUI environment that ran on top of DOS, and dos executable. It wasn&#8217;t an operating system.&quot;</p>
<p>Actually, Windows 3.x ran MS-DOS in V86 mode within a hidden System VM. Go and read Andrew Schulman/Matt Pietrek&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573853">
				<div id="div-comment-573853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573853">
			December 3, 2007 at 9:59 pm</a>		</div>

		<p>&quot;&quot;How do 16-bit programs start up?&quot;</p>
<p> &nbsp; &nbsp; &nbsp;&#8230;who the f*** cares any more?</p>
<p>Except maybe to prove that the OS was just as f***ed up by its designers as Vista is today.</p>
<p>oj&quot;</p>
<p>Oh boy, lets all jump on the hate parade for Vista! /snark</p>
<p>You&#8217;re probably too young to realize the benefit of studying the past. &nbsp;Or maybe you just don&#8217;t appreciate learning as much as you should.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573923">
				<div id="div-comment-573923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://flatpack.microwavepizza.co.uk/' rel='external nofollow' class='url'>Ben A L Jemmett</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573923">
			December 4, 2007 at 7:35 am</a>		</div>

		<p>Just as a side note to the &quot;WinMain vs. main&quot; debate that seems to be happening &#8212; Windows wasn&#8217;t the only environment to provide its own equivalent to main. &nbsp;DRI&#8217;s GEM used &quot;void GEMAIN()&quot; as the C entrypoint &#8212; the (vanilla DOS) executable&#8217;s entry point was a small chunk of assembly that did some tidying up, checked for the presence of GEM&#8217;s AES (~ Windows&#8217;s USER) by making sure the INT EFh handler had a certain signature, and then jumped to GEMAIN.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-573933">
				<div id="div-comment-573933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SRS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573933">
			December 4, 2007 at 7:44 am</a>		</div>

		<p>&#8230;and what happened to the return value in AL once int 21/4c got called? From what I remember there was no way to pick up a process exit code in win3.x api.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-574003">
				<div id="div-comment-574003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rdamiani</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574003">
			December 4, 2007 at 11:09 am</a>		</div>

		<p>I thought main vs. WinMain came from the need for an MS-DOS stub at the beginning of Windows programs. I seem to recall that there were a small number of programs (Sidekick?) that actually did useful work with the stub when in MS-DOS, and did different things when run in Windows.</p>
<div class=post>[<i>If that were true, then console apps couldn&#8217;t have stubs. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-574063">
				<div id="div-comment-574063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574063">
			December 4, 2007 at 12:57 pm</a>		</div>

		<blockquote><p>
  I think the main criticism of WinMain today</p>
<p>  is really that it makes cross-platform</p>
<p>  GUI programs just that bit more awkward.
</p></blockquote>
<p>if that&#8217;s the &#8216;main criticism&#8217;, I have never heard it. :) &nbsp;I have heard only nit pickers say, &quot;main is the C standard!&quot; &nbsp;Winmain is often hidden in toolkits, and is an issues we run into with cross-plateform GUI apps.</p>
<blockquote><p>
  &gt; &quot;This is Windows 3.1 that we&#8217;re talking</p>
<p>  &gt; about, a GUI environment that ran on top</p>
<p>  &gt; of DOS, and dos executable. It wasn&#8217;t</p>
<p>  &gt;an operating system.&quot;</p>
<p>  Actually, Windows 3.x ran MS-DOS in V86 mode &gt;within a hidden System VM. Go and read</p>
<p>  Andrew Schulman/Matt Pietrek&#8230;
</p></blockquote>
<p>nit picking?</p>
<p>WinMain dates from the first Windows, a graphic toolkit onto DOS and it&#8217;s not a full OS. &nbsp;Windows 3.x is used to signify anything prior to &nbsp;Win95.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-574113">
				<div id="div-comment-574113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.johntopley.com/' rel='external nofollow' class='url'>John Topley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574113">
			December 4, 2007 at 1:19 pm</a>		</div>

		<p>I prefer to think of it as accuracy rather than nitpicking.</p>
<p>&quot;Windows 3.x is used to signify anything prior to Win95.&quot;</p>
<p>Oh right. Silly me. I didn&#8217;t realise that Windows 3.x encompassed Windows 1.0, Windows 2.0, Windows/286 etc. Where was that rule defined again?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-574143">
				<div id="div-comment-574143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://moskalyuk.name/937' rel='external nofollow' class='url'>???????????????? 16-???????????? ???????????????? at alexmoskalyuk</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574143">
			December 4, 2007 at 1:40 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://moskalyuk.name/937" rel="nofollow">http://moskalyuk.name/937</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573903">
				<div id="div-comment-573903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://K.Hagan@thermoteknix.com' rel='external nofollow' class='url'>Ken Hagan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573903">
			December 4, 2007 at 6:25 am</a>		</div>

		<p>&quot;Actually, Windows 3.x ran MS-DOS in V86 mode within a hidden System VM. Go and read Andrew Schulman/Matt Pietrek&#8230;&quot;</p>
<p>Good advice. Windows 3.x actually contained two products. The first was a DOS extender which turned real mode DOS into an arbitrary number of (DOS-extended) VMs. The second was Windows, *all of which* which ran as a single DOS process in the first of those VMs.</p>
<p>Windows itself could be considered two products as well. There was the kernel, which offered a truly amazing way of managing memory in real-mode or protected mode 16-bit x86 using the NE file format, and the GUI which was a Windowing system built on top.</p>
<p>Either or both of the DOS extender or the kernel could have been sold as separate products, since they delivered real benefits compared to ordinary DOS. However, it made more commercial sense to bundle the lot.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-574373">
				<div id="div-comment-574373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574373">
			December 4, 2007 at 6:21 pm</a>		</div>

		<p>&quot;This is Windows 3.1 &nbsp;that we&#8217;re talking about, a GUI environment that ran on top of DOS, and dos executable. It wasn&#8217;t an operating system.&quot;</p>
<p>NE executable files were used from the first version of Windows 1.0. IIRC, there was a backwards compatibility break somewhere that made Windows 3.11 for worksgroup unable to execute Windows 1.0 executables, even though they were NE executables (maybe something related to real mode vs 16 bits protected mode).</p>
<p>Moreover, Windows 3.1 is not synonymous of Windows 1.0 or Windows 2.0.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573983">
				<div id="div-comment-573983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pietje</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-573983">
			December 4, 2007 at 10:40 am</a>		</div>

		<p>About nCmdShow: it&#8217;s the integer to pass to ShowWindow so you&#8217;re doing what the user wants. Try opening the properties of a shortcut to an application and change on the 2nd tab (where the icon and path can be changed) the combobox with &quot;Normal&quot;, &quot;Minimized&quot; and &quot;Maximized&quot;. If the app behaves correctly then you can make it start minimised or maximised if you like.</p>
<p>But you really don&#8217;t need it anymore, because the first call to ShowWindow *ALWAYS* uses this default, as if you wrote ShowWindow(hwnd, SW_SHOWDEFAULT). If you&#8217;re using mainCRTStartup or WinMainCRTStartup, you can get this int by calling GetStartupInfo. But since there&#8217;s SW_SHOWDEFAULT calling GetStartupInfo for this is pointless unless you&#8217;re writing a runtime library and need to call the users WinMain function correctly.</p>
<p>In my program, I&#8217;m doing this after creating the main window (and making sure its size is correct, setting the icon, etc.):</p>
<p>ShowWindow(hwnd, SW_SHOWDEFAULT);</p>
<p>ShowWindow(hwnd, SW_SHOW);</p>
<p>The SW_SHOWDEFAULT is merely there to point out that it&#8217;s using the default there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-574573">
				<div id="div-comment-574573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574573">
			December 5, 2007 at 9:33 am</a>		</div>

		<p>IIRC, the only difference between Windows 1.0 and 2.0 executable files was the resource format &#8211; if you opened a Windows 1.0 executable file in a resource editor that supported it, and then saved it with resources converted to new format, the file would still run in XP (32bit of course) &#8211; except that the program would appear titlebar-sized at top-left of the screen, since in Win1.0 the window manager would take care of window sizes automatically.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-574903">
				<div id="div-comment-574903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574903">
			December 5, 2007 at 6:15 pm</a>		</div>

		<blockquote><p>
  I mean, that&#8217;s four sectors of I/O off a floppy disk!
</p></blockquote>
<p>Priceless!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-574863">
				<div id="div-comment-574863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.peteandcarol.com' rel='external nofollow' class='url'>Pete</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-574863">
			December 5, 2007 at 5:10 pm</a>		</div>

		<p>Actually, in your discussion of &#8220;main()&#8221;, you neglected the &#8220;envp&#8221; parameter which was introduced either in (1) System II v7, (2) System III, or (3) BSD Unix (I don&#8217;t remember which; in fact, maybe it was even earlier). &nbsp;So the actual defininiton of main() was</p>
<p>void main(int argc, char *argv[], char *envp[])</p>
<p>where envp was a null-terminated array of pointers to the environment strings.</p>
<p>I know &#8220;envp&#8221; pre-dates Win 1.0, and I think it pre-dates MS-DOS, too.</p>
<div class="post">[<i>I linked to envp in the article. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-575043">
				<div id="div-comment-575043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-575043">
			December 6, 2007 at 4:42 am</a>		</div>

		<p>[I don&#8217;t know what you folks are talking about. There was no such thing as a &#8216;console program&#8217; in 16-bit Windows. -Raymond]</p>
<p>While true, it was possible to write an MS-DOS application that called the Windows API (I remember writing such an application in Borland&#8217;s Turbo Pascal). </p>
<p>From the end-user&#8217;s perspective, this is identical to a console program in more modern versions of Windows.</p>
<div class="post">[<i>How can an MZ program call, say, user!CreateWindow? I&#8217;m guessing you&#8217;re just talking about MS-DOS programs running in a virtual machine and a handful of int 2F calls. That&#8217;s hardly calling the &#8220;Windows API&#8221;. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-575163">
				<div id="div-comment-575163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Elliott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-575163">
			December 6, 2007 at 11:39 am</a>		</div>

		<p>The other thing that may stop Windows 1.x programs running under recent Windowses is that they don&#8217;t have the subsystem field populated in the NE header, causing the loader to try and run them under the OS/2 subsystem rather than the Win16 one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-575253">
				<div id="div-comment-575253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-575253">
			December 6, 2007 at 1:55 pm</a>		</div>

		<p>BTW, what was the version of the linker that came with the Windows 1.0 SDK?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-575883">
				<div id="div-comment-575883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071203-00/?p=24323#comment-575883">
			December 7, 2007 at 8:03 pm</a>		</div>

		<p>It appears from the DDKs that a Windows 95 16-bit SDK could be created to allow 16-bit programs to use some of the new features of Windows 95.</p>
<div class="post">[<i>16-bit Windows programs (not 16-bit MS-DOS programs) can use thunks to access 32-bit functions in Windows 95. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>