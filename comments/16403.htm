<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (43)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-777093">
				<div id="div-comment-777093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777093">
			October 13, 2009 at 7:41 am</a>		</div>

		<p>Wait a minute&#8230; why is type information (outside of the header files or whatever other language-specific thing that the compiler used to call the functions the right way) needed for normal use of a DLL?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777133">
				<div id="div-comment-777133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777133">
			October 13, 2009 at 8:23 am</a>		</div>

		<p>I&#8217;ll also take this opportunity to apologies for framing my question in an unclear and ambiguous fashion. I do appreciate the information in the posts you have made, even if they&#8217;re not what I intended to ask for! Thanks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777143">
				<div id="div-comment-777143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777143">
			October 13, 2009 at 8:46 am</a>		</div>

		<p>I&#8217;m with Random832 here: From what I understood of what you said yesterday, all the Linker had to do its job was the name of the symbols to resolve; and that&#8217;s precisely what DLLs have, don&#8217;t they? (unless the symbol is exported under a different name, such as the undecorated one. If that&#8217;s the flaw, my reasoning will have to admit defeat)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777163">
				<div id="div-comment-777163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777163">
			October 13, 2009 at 9:17 am</a>		</div>

		<blockquote><p>
  &gt; undecorated
</p></blockquote>
<p>That&#8217;s the nub of it. Even a simple &quot;int foo(int)&quot; can appear with a different export name in the table &quot;foo&quot; or &quot;_foo@4&quot;, the correct information gets put in the lib for the &quot;__imp__foo&quot; entry which points to the correct one.</p>
<p>It used to be that given a DEF file you could produce an import library ( think Win16 or OS/2), with Win32 even for simple C entries you need to write a stub C piece of code with the correct number arguments and correct calling type to build the import library.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777173">
				<div id="div-comment-777173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matthew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777173">
			October 13, 2009 at 9:41 am</a>		</div>

		<p>@Random832:</p>
<p>&quot;Wait a minute&#8230; why is type information (outside of the header files or whatever other language-specific thing that the compiler used to call the functions the right way) needed for normal use of a DLL?&quot;</p>
<p>It&#8217;s not. Normal use &#8211; i.e., loading and accessing exported items, a la LoadLibrary and GetProcAddress &#8211; of a DLL doesn&#8217;t require import libraries either.</p>
<p>But if you want to hook up directly to DLL, so that your code treats the imported functions the same as those internal to the current module, you will need that type information.</p>
<p>DLLs contain the ordinal, name, and location of exported symbols. They do not contain type information about those symbols. Thus, if you want to be able to use that type information, you need something more &#8211; like an import library, which is created with access to the original type information used to create the DLL in the first place.</p>
<p>If you want to run things yourself &#8211; using LoadLibrary et al &#8211; then it&#8217;s all up to you to make sure you know what you&#8217;re doing. If you want to use the language to ensure correctness (etc.), then you need to be able to provide it (compiler/linker) with the extra information to perform such checks. Which isn&#8217;t available from the DLL itself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777183">
				<div id="div-comment-777183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777183">
			October 13, 2009 at 9:45 am</a>		</div>

		<p>Chiming in with Random832 and Medinoc: If I can call LoadLibrary and GetProcAddress to get all I need to be able to execute a DLL function, why can&#8217;t the linker?</p>
<div class=post>[<i>Please re-read yesterday&#8217;s article about the classical model for linking. Code injection is not part of the classical model. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777203">
				<div id="div-comment-777203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matthew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777203">
			October 13, 2009 at 9:54 am</a>		</div>

		<p>@rs:</p>
<p>To properly execute it, you need outside knowledge. What form of function pointer is being returned by GetProcAddress? You have no idea what arguments it is expecting &#8211; if any &#8211; and zero clue about the return value &#8211; if any.</p>
<p>To properly use the function, you would need to know the specification of the function &#8211; its type information. Information that doesn&#8217;t exist in the export header of a DLL.</p>
<p>Same with the linker; if the linker is supposed to match potentially overloaded functions, it needs to know about the arguments. Which it cannot possibly gather from the DLL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777233">
				<div id="div-comment-777233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777233">
			October 13, 2009 at 10:24 am</a>		</div>

		<p>Matthew, Raymond: Thanks for the comments. I had been under the impression that for C functions the library didn&#8217;t include any information not in the DLL. But it actually does include the size of the parameter block, allowing the compiler can do some minimal type checking.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777293">
				<div id="div-comment-777293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777293">
			October 13, 2009 at 11:04 am</a>		</div>

		<p>don&#8217;t have the parameters, their types, or any documentation. -Raymond]&#8221; yeah, but the linker doesn&#8217;t (or shouldn&#8217;t) need those, and as I understand it aren&#8217;t present in import libraries (as opposed to &nbsp;type libraries). That&#8217;s the compiler&#8217;s concern, and it can get them from the header file (or whatever other language-specific mechanism).</p>
<p>It seems like the question you&#8217;re answering isn&#8217;t really the same one that was asked.</p>
<p>If the issue is that the decorated name (either with type info for C++, or with the @N for C stdcall functions) isn&#8217;t included in the dll (and just what name <em>is</em> included in the dll if you have multiple overloaded functions by the same name), the question remains: why not?</p>
<div class=post>[<i>All the linker sees is that CALLFOO.OBJ is looking for the function _foo@12. If it looks at FOO.DLL it sees a function called &#8220;Foo&#8221;. Since the strcmp fails, the linker says &#8220;No match.&#8221; The import library&#8217;s job is to provide the missing link to the linker: &#8220;When somebody asks for _foo@12, send them to FOO.DLL function Foo.&#8221; Why isn&#8217;t the decoration included in the DLL? (1) Why should it? The information isn&#8217;t needed at run time, and the principle of <a href="http://blogs.msdn.com/oldnewthing/archive/2009/02/16/9425124.aspx" rel="nofollow">don&#8217;t keep track of information you don&#8217;t need</a> applies. (2) If you really want to, go ahead and export the decorated names. And then <a href="http://blogs.msdn.com/oldnewthing/archive/2006/07/27/679634.aspx" rel="nofollow">your DLL compiled with Compiler&nbsp;X cannot be used with Compiler&nbsp;Y</a> because they have different decoration algorithms. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777353">
				<div id="div-comment-777353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matthew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777353">
			October 13, 2009 at 11:56 am</a>		</div>

		<p>@Random832</p>
<p>&quot;and just what name <em>is</em> included in the dll if you have multiple overloaded functions by the same name&quot;</p>
<p>Anything. Including nothing.</p>
<p>The external symbol name (the exported one visible in the DLL) is not restricted by the name of the internal function that it references. In fact, as Raymond has already mentioned, you don&#8217;t need any name &#8211; you can export something with only an ordinal.</p>
<p>To perform ANY type of checking, the build system NEEDS to have a way to translate between the internal symbols and the exports.</p>
<p>Headers only (typically) declare the internal symbology of some exported feature. The mapping from internal to external is still missing, hence the need for additional information.</p>
<p>For example, you can declare a function as exported in a header, but later give it an alias during actual export. There is no way to convey this information afterwards with only the ouput (DLL). Maybe the original internal function was named &quot;Func1&quot; but then you alias-ed it to &quot;Func123&quot; on export. The linker wouldn&#8217;t identify the two as being related if you only had the externally-visible DLL name (&quot;Func123&quot;) and were comparing against the internal name (&quot;Func1&quot;). Unresolved external (since the only externally-visible name doesn&#8217;t match the now &#8216;missing&#8217; function)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777363">
				<div id="div-comment-777363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Clinton L. Warren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777363">
			October 13, 2009 at 12:31 pm</a>		</div>

		<p>Tiny C for Windows (<a rel="nofollow" target="_new" href="http://bellard.org/tcc/" rel="nofollow">http://bellard.org/tcc/</a>) let&#8217;s you link against a .def file. &nbsp;It also includes a utility to create a .def file from a .dll file. &nbsp;</p>
<p>So, it&#8217;d seem like it&#8217;s possible to omit the .lib step. &nbsp;I myself have linked against sqlite3.dll using only a tcc-generated .def file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777403">
				<div id="div-comment-777403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://arnshea.blogspot.com' rel='external nofollow' class='url'>arnshea</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777403">
			October 13, 2009 at 1:45 pm</a>		</div>

		<p>God I love this blog, thanks for the compiler linker refresh.</p>
<p>Preconditions and post-conditions move us a little further along in the direction of &quot;What does &#8216;bool foo&#8217; mean?&quot; but at some point you bump up against Godel&#8217;s Incompleteness Theorem. &nbsp;Given that programs are clearly more expressive than simple algebra, there&#8217;s a limit to how much meaning the system can self-describe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777423">
				<div id="div-comment-777423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Al Urker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777423">
			October 13, 2009 at 2:41 pm</a>		</div>

		<p>From the category &#8216;the more things change, the more they stay the same&#8217;: &nbsp;The clr dream allows the same assembly to be used for the entire lifecycle: you can code, design, link, and run against the same CLR assembly. But many .NET SDKs include asmmeta assemblies for you to code, design and link against. Asmmeta assemblies contain type info and no code &#8211; similar to a lib &amp; header file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777123">
				<div id="div-comment-777123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777123">
			October 13, 2009 at 8:15 am</a>		</div>

		<p>OK, I realise it&#8217;s a bit late for this now as you will have written these posts a couple of years ago, but my main concern was not with *types* not being stored in DLLs, but with things as basic as *function names* not being stored by default. You generally can&#8217;t link to a DLL if you don&#8217;t have the LIB because for there&#8217;s generally not even a symbol table available.</p>
<p>As referenced in my question, your July 18 post talks about problems arising from *this* issue, and doesn&#8217;t have much to do with types.</p>
<p>&lt;<a href="http://blogs.msdn.com/oldnewthing/archive/2006/07/18/669668.aspx%3E" target=_new rel=nofollow rel="nofollow">&#8220;>http://blogs.msdn.com/oldnewthing/archive/2006/07/18/669668.aspx&gt;</a></p>
<div class=post>[<i>Exported function names are <u>included</u> by default, but you can remove them with the NONAME attribute. But even if you have the name, that still doesn&#8217;t tell you enough &#8211; you don&#8217;t have the parameters, their types, or any documentation. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777463">
				<div id="div-comment-777463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://lambert.geek.nz/' rel='external nofollow' class='url'>Miral</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777463">
			October 13, 2009 at 3:25 pm</a>		</div>

		<p>&#8220;(2) If you really want to, go ahead and export the decorated names. And then your DLL compiled with Compiler X cannot be used with Compiler Y because they have different decoration algorithms.&#8221;</p>
<p>Isn&#8217;t that one of the ideas behind stdcall, though? That it mandates a particular decoration algorithm? (And parameter/return/stack conventions, of course.)</p>
<p>(Of course, stdcall didn&#8217;t show up until Win32, which is fairly late in the game as far as DLLs are concerned.)</p>
<div class=post>[<i>Another problem is that stdcall <a href="http://blogs.msdn.com/oldnewthing/archive/2004/01/12/57833.aspx" rel="nofollow">decorates differently on different platforms</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777323">
				<div id="div-comment-777323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nathan_works</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777323">
			October 13, 2009 at 11:09 am</a>		</div>

		<p>Shoot yourself in the foot ? Wasn&#8217;t (is*) there a huge market for the old &quot;windows xx api uncovered&quot; books where various folks found, poked/prodded/debugged those functions to guess at the parameters ? Like the guy who wrote up all the ZwXX functions (via a vis the NtXXX flavors) etc ?</p>
<p>*is, in the sense that because of said books and the consumers of those books writing code to use the undocumented functions does give Raymond plenty of topics to post about..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777513">
				<div id="div-comment-777513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777513">
			October 13, 2009 at 6:40 pm</a>		</div>

		<blockquote><p>
  &gt; For there was a platform that had it all: &nbsp;the Code Fragment Manager on classic Mac OS (post-PowerPC and pre-OS X).
</p></blockquote>
<p>Not quite all, you are missing AIX and it&#8217;s shared libraries, it supports two types, one which is simply an COFF object file and the other which is a library containing object files and you can link to a specific object within that library. So the library can contain both a 32bit and 64bit objects, it can also contain an exports definition file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777523">
				<div id="div-comment-777523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777523">
			October 13, 2009 at 7:17 pm</a>		</div>

		<p>One issue I have with this entry, is that I believe, that all the C++ decoration issues were nowhere on the radar when design decision about import libraries were was made. &nbsp;So it looks to me like this is &quot;retcon&quot;-ing history.</p>
<p>Way back in the early 90s, there was only C and Pascal calling convention, and I don&#8217;t recall that there were any decoration in the export names. &nbsp;Therefore, &quot;how do you encode the types?&quot; never came up. &nbsp;We never had the types, just the symbol names. &nbsp;</p>
<p>Also, it seems a bit of a sidetrack to bring in CLR and Typelibs, since they don&#8217;t use import libraries either. Import libraries is something specific to Microsoft C.</p>
<p>Finally, as you know there are no import libraries on unix, the .so has everything.</p>
<p>It works just fine! &nbsp;Can you mix C++ .so with other languages? No! But import libraries do not solve that problem either.</p>
<p>Unix .so implements what this entry suggests the DLLs could not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777533">
				<div id="div-comment-777533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.metamatt.com' rel='external nofollow' class='url'>Matt G</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777533">
			October 13, 2009 at 8:05 pm</a>		</div>

		<p>Right (to ulric).</p>
<p>All you need from the import library (or the .so, or the .dll itself if things worked that way) should be the symbol-&gt;address mappings.</p>
<p>Sure, that doesn&#8217;t work for name-mangled symbols, but not everyone needs name mangling, and if they do, there are multiple ways around it (predict the mangling, use the same compiler everywhere, or import libraries).</p>
<p>Sure, that doesn&#8217;t give you the type information for the parameters and return values, but neither does the import library! In the C calling convention the calling code sets up and cleans up the stack and it&#8217;s on that code to get it right/wrong. Typically that information is encoded in the header file. In any case, the import library wasn&#8217;t helping with this part of the problem anyway.</p>
<p>Sure, that doesn&#8217;t work for functions exported by ordinal only with NONAME (to save a few bytes back when raptors roamed the earth), but ordinals aren&#8217;t magic, they&#8217;re just a different (cheaper) way of encoding the name. You can&#8217;t use GetProcAddress with those, either. Oh wait, yes you can &#8212; you just pass the name in the magic way that encodes the ordinal. The import library does help here (retaining a name-&gt;ordinal mapping that the .dll itself doesn&#8217;t encode), but if you know the ordinal (which is necessary to use GetProcAddress) you could still get by without the import library.</p>
<p>The classic linker model only needs the symbol-&gt;address mapping, and AFAIK that&#8217;s all the import library provides &#8212; import libraries are a lot less magic than this post, and about half the comments, imply.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777383">
				<div id="div-comment-777383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://K.Hagan@thermoteknix.com' rel='external nofollow' class='url'>Ken Hagan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777383">
			October 13, 2009 at 1:25 pm</a>		</div>

		<p>This whole thread has got me very confused. Raymond has answered &#8220;Why can&#8217;t all the type information be encoded in the export table?&#8221;. However, that was Adam&#8217;s second question and it is not actually relevant to his first (and main) question.</p>
<p>You don&#8217;t need type information to link. What you need to link is a description of the DLL&#8217;s interface (entry points) and the traditional model of programming separated interface from implementation. In fact, if memory serves, there was an IMPLIB tool that would generate a LIB file from a (text format) DEF file, so you could link against a DLL that didn&#8217;t actually exist yet.</p>
<p>That&#8217;s actually a surprisingly common state of affairs. Any DLL that is updated &#8220;in the field&#8221; falls into this category, as does any DLL that has to expose a particular set of entry points to conform to a plug-in or driver architecture. Between them, these scenarios cover *most* reasons for using a DLL.</p>
<p>You do need type information to compile but the exact information you need is language specific. Embedding type information in the actual DLL is only useful if you can be sure that all your clients are using a compatible language and it is wasteful when you have more than one DLL with the same interface.</p>
<div class=post>[<i>Note also when a function is exported both by name and by ordinal, it&#8217;s not clear which one the author intended for you to use. (I wonder what algorithm Tiny C uses to decide.) And if you guess wrong and link by ordinal when the author intended for you to link by name, <a href="http://support.microsoft.com/kb/75245" rel="nofollow">you end up calling the wrong function</a>. <a href="http://blogs.msdn.com/oldnewthing/archive/2006/07/18/669668.aspx" rel="nofollow">The DirectX team curses people who generate their own input library instead of using the one provided in the SDK</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777413">
				<div id="div-comment-777413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777413">
			October 13, 2009 at 1:47 pm</a>		</div>

		<p>In the old times, the exports were encoded with ordinals, to save on the file size. The DLL might not even have names. This was already a good enough reason to use import libraries.</p>
<p>You say: &quot;Because the linker doesn&#8217;t have that information when it generates the DLL file&quot;. When the linker generates the DLL file, it *has* ALL that information, because it has ALL the object files, and also an optional .DEF file which describes a mapping of OBJ symbols to export names and/or ordinals.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777493">
				<div id="div-comment-777493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://gdrprivate.blogspot.com/' rel='external nofollow' class='url'>Leif Strand</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777493">
			October 13, 2009 at 5:19 pm</a>		</div>

		<p>As I see it, all this talk about type information and decorated names is beside the point.</p>
<p>If I may take the liberty of rephrasing Adam&#8217;s original question: &nbsp;Why can&#8217;t I put a DLL on the linker&#8217;s command line? &nbsp;More precisely, why don&#8217;t DLLs and LIBs share the same file format? &nbsp;This is not crazy; in fact, this is precisely how it works on ELF platforms: &nbsp;&#8220;-lfoo&#8221; on the link line will, by default, search for libfoo.so before it searches for libfoo.a &#8212; i.e., it will search for the very same .so file that is used by the dynamic linker at runtime, and use that .so file to resolve symbols (decorated or not). &nbsp;Indeed, in my experience, this question comes from people with a Unix/ELF background.</p>
<p>So the real question is, why doesn&#8217;t Windows work the way ELF platforms do? &nbsp;There is only one other platform &#8212; that I know of &#8212; that works the same way Windows does, where there are both &#8220;import libraries&#8221; and separate &#8220;shared libraries&#8221;, and they are not in the same format and therefore not interchangeable: &nbsp;that platform is AIX.</p>
<p>The reasons for import libraries were neatly summarized in the responses to Raymond&#8217;s previous post. &nbsp;But, none of these reasons justify the use of distinct file formats, and the oil and water separation between import libraries and DLLs.</p>
<p>For there was a platform that had it all: &nbsp;the Code Fragment Manager on classic Mac OS (post-PowerPC and pre-OS X).</p>
<p>CFM shared libraries and CFM import libraries were in the same file format. &nbsp;In fact, a CFM &#8220;import library&#8221; was simply a shared libary stripped of its code, so that only the linker&#8217;s symbols remained. &nbsp;There were .def files as well&#8230; presumably you could do most of the things you can do with import libraries on Windows, like separate public interfaces from private, or create cyclic dependencies.</p>
<p>I&#8217;ve always assumed there must be historical reasons why AIX and Windows don&#8217;t work in the same, sane fashion that CFM did. &nbsp;But it must be a reason (or set of reasons) other than the ones suggested so far.</p>
<p>My theory &#8212; for Windows specifically &#8212; is twofold:</p>
<p>1) OBJ and LIB files came first, and the current DLLs/EXEs format (PEF) was developed later. &nbsp;As I recall, they are all COFF at the bottom, so this part is hard to justify, but it is not that hard to imagine that PEF was optimized for the runtime loader, and it was considered too much trouble, or a waste of time, to make the dev tool chain read the new PEF files.</p>
<p>2) The format of OBJ and LIB files are MSVC-specific anyway. &nbsp;The idea that there is a single format for libraries and object files is a very Unix-minded point of view. &nbsp;On pre-OS-X-Mac and Windows, there is no single &#8220;system&#8221; compiler; there are multiple compilers from multiple vendors, and (potentially) multiple formats for OBJ and LIB files. &nbsp;Since there no single linker format that PEF could adhere to, they didn&#8217;t bother adhering to any of them.</p>
<p>I&#8217;m not satisfied with this theory, and am eager to hear better ones. &nbsp;But my point is, DLLs *could* be in a format recognized by the linker, and they *could* contain &#8220;redundant&#8221; symbolic information for use only by the build-time linker. &nbsp;It has been done before.</p>
<div class=post>[<i>They may all be COFF at the bottom today, but that&#8217;s not how they were back in 1983 when these rules were invented. (Where did I put my time machine?) To link directly against a DLL, you&#8217;d have to break the classical rules: The linker would do some pattern matching to realize that the unresolved symbol _foo@12 corresponds with FOO.DLL!foo (breaking the classical rule that all the linker does is strcmp), and then it needs to autogenerate a stub function _foo@12 that does a &#8220;call [__imp__foo]&#8221;, and then it needs to autogenerate an import variable __imp_foo, and then it has to decide whether __imp_foo should bind by name or ordinal (and it had better not guess wrong). Classically speaking, the linker does not use fuzzy logic or autogenerate code or data. LIBs are for the code and data that glue the two parts together (and which also remove the need for fuzzy logic). And of course you don&#8217;t want to have to include all your DLLs in your SDK when all that&#8217;s needed to link is the import information. (Would the Platform SDK have to include an XP copy of shell32.dll, a Vista copy of shell32.dll, and a windows 7 copy of shell32.dll? Would security patches also have to patch your SDK?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777503">
				<div id="div-comment-777503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.henning.makholm.net/' rel='external nofollow' class='url'>Henning Makholm</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777503">
			October 13, 2009 at 6:31 pm</a>		</div>

		<p>Hm, I could have sworn that the DLLs I build export things with their fully decorated names (*). I know I have caught instances of forgotten extern &quot;C&quot; by noticing that there were decorated names in the export table.</p>
<p>(*) And wouldn&#8217;t doing things otherwise require the linker to know about all programming languages such that it could un-decorate the names correctly while creating the DLL?</p>
<p>The point that (in a more frugal time) DLLs used to export things solely by ordinal makes sense, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777593">
				<div id="div-comment-777593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777593">
			October 14, 2009 at 3:57 am</a>		</div>

		<p>On Win16 you could import directly on your DEF file e.g. ENABLESCROLLBAR=USER.482 if you were targeting Windows 3.1 using a Windows 3.0 SDK.</p>
<p>I don&#8217;t know what might be involved in making it possible to link without import libraries on Win32 but possibly you could create an extension e.g. __declspec(dllimport(user32,EnableScrollBar)) which would direct the compiler to create the import stub.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777603">
				<div id="div-comment-777603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777603">
			October 14, 2009 at 6:25 am</a>		</div>

		<p>Regarding your answer to Ken Hagan: Is the format of a Visual Studio import library documented?</p>
<p>If it is, then it should be no trouble for any other compiler vendor to write a converter and build its own import library from the official ones instead of from the DLL. But if it&#8217;s not, that makes it a no-win situation&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777643">
				<div id="div-comment-777643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777643">
			October 14, 2009 at 7:47 am</a>		</div>

		<p>&lt;i&gt;And if that&#8217;s not good enough, you can turn to the CLR&lt;/i&gt;</p>
<p>And if that&#8217;s still not good enough, you can turn to pascal/delphi, where linking a library is just &#8220;function Whatever(params, params): result; stdcall; external &#8216;libname.dll&#8217;;&#8221;. If only things were like this in C++ world, at least for function imports&#8230;</p>
<p>After all, it seems pretty logical. If you can LoadLibrary, GetProcAddress and cast it to whatever function pointer you want, why do you have to go to all the troubles to tell compiler to do just that, only automatically?</p>
<div class=post>[<i>I think you&#8217;re confusing the compiler and the linker. Remember, under the classical model, the linker does not generate code. (The linker also doesn&#8217;t know what language you wrote your program in.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777723">
				<div id="div-comment-777723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777723">
			October 14, 2009 at 8:40 am</a>		</div>

		<p>&#8220;because you&#8217;ve made it possible to link C++ modules from different vendors.&#8221;</p>
<p>In the article you just linked, you made &#8220;or if you intend them to be able to use your DLL from a language other than C/C++ or use a C++ compiler different from Microsoft Visual Studio&#8221; sound like a worthy &#8211; or at least achievable &#8211; goal.</p>
<p>And for that matter wasn&#8217;t that the entire point of having the undecorated names exported from a dll, which was the entire point of having an import library to map the decorated name used in the object module to the undecorated name exported from the DLL, which led us to this question?</p>
<p>If this shouldn&#8217;t be possible, then the objection that decorated names are compiler-specific and so shouldn&#8217;t be exported evaporates.</p>
<p>And there already is a way to define undecorated [or at least, undecorated enough. There&#8217;s still that weird stdcall thing] function names in C++. It&#8217;s called extern &#8220;C&#8221;.</p>
<div class=post>[<i>By convention, the standardized name is the undecorated name, and these undecorated names follow Win32 ABI rules (not C++ rules or Delphi rules or anything else). The job of the import library is to bridge the gap between the decorated name imported by the compiler and the undecorated name exported by the DLL. Think of it as a thunk library. Why doesn&#8217;t the linker auto-generate these thunks? Because under the classical model, <u>linkers do not generate code</u>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777743">
				<div id="div-comment-777743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777743">
			October 14, 2009 at 9:07 am</a>		</div>

		<p>Why is it necessary to generate code to bridge a gap between a stdcall function in a dll that takes an int and returns an int, and code outside the dll that calls such a function? Even with an import library and using undecorated names in the dll, all you&#8217;re doing is mapping foo to _foo@4 &#8211; that&#8217;s not code generation. At most it&#8217;s &#8220;breaking the classical rule that all the linker does is strcmp&#8221;, but putting _foo@4 in the dll in the first place would eliminate even that.</p>
<p>If some language doesn&#8217;t provide a language-specific (i.e. put in the header file or equivalent for the compiler to understand, not an import library) way to call a stdcall function, that&#8217;s that language&#8217;s problem. Maybe they need something like an import library, to put thunks in.</p>
<p>And &#8220;by convention&#8221; automatically raises the question of why again. What benefit is there to having &#8220;foo&#8221; in the dll when any code, compiled from any language that knows how to call a stdcall function, is going to ask for &#8220;_foo@4&#8221; (ignoring, for the moment until you bring up again the fact that stdcall decoration is different on different platforms, the question of why stdcall actually needs the size in the symbol)</p>
<div class=post>[<i>A call to an imported function isn&#8217;t hooking up the _foo@4 placeholder to foo. You may need to generate a stub, and you definitely need to generate the IAT and related adata. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777773">
				<div id="div-comment-777773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777773">
			October 14, 2009 at 10:29 am</a>		</div>

		<p>&quot;The type information was lost a long time ago.&quot;</p>
<p>The linker generates two outputs &#8211; one is the DLL and the other is the import library so it has all the information needed (the decorated symbol and the exported symbol).</p>
<p>The decoration needed to link with Win32 is standardized for the platform (otherwise you would need an SDK for Visual C and SDK for Borland C etc. &nbsp;</p>
<p>So why isn&#8217;t the decorated name exported? &nbsp;Probably so that you could call GetProcAddress(handle, &quot;foo&quot;) in a portable way. &nbsp; Decorations on different platforms are different.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777803">
				<div id="div-comment-777803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jared</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777803">
			October 14, 2009 at 10:50 am</a>		</div>

		<p>The predominate mainframe architecture linker knew what compiler generated the object modules &#8212; the compiler included that information in the object module.</p>
<p>The decision to ignore it was deliberate &#8212; &quot;special cases&quot; for a specific compiler would not be supported but instead a general mechanism would be provided instead.</p>
<p>Assistance was provided so that a compiler could pass information about the compilation through the linker for use by the linked code at run time.</p>
<p>Again, there&#8217;s very little under the sun which is truly new.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777813">
				<div id="div-comment-777813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matthew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777813">
			October 14, 2009 at 11:03 am</a>		</div>

		<p>@anonymous:</p>
<p>&quot;So why isn&#8217;t the decorated name exported? &nbsp;Probably so that you could call GetProcAddress(handle, &quot;foo&quot;) in a portable way. &nbsp; Decorations on different platforms are different.&quot;</p>
<p>The exported name can be ANYTHING you want, including nothing (ordinal only).</p>
<p>It could be the decorated name. It could be an undecorated name. It could be a completely different name.</p>
<p>There is absolutely no reason I can&#8217;t have an export-marked function called &#8216;foo&#8217; (internally) and then alias it to &#8216;gobbledygook&#8217; when it actually gets exported (as in what is visible from the DLL).</p>
<p>(Go look up the EXPORTS syntax for module definition files on MSDN. You&#8217;ll find that it will tell you exactly how to arbitrarily map internal to external symbol names.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777833">
				<div id="div-comment-777833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Don Munsil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777833">
			October 14, 2009 at 11:26 am</a>		</div>

		<p>I remember having exactly this discussion back in 1990.</p>
<p>Import libraries exist specifically because you may need (in fact, often need) to generate two DLLs that call each other. Without some sort of intermediate external dependencies file, you can&#8217;t have DLL 1 and DLL 2 have dependencies on each other, because neither can be completed until the other is completed. The import library, on the other hand, can be generated before the DLL is fully linked.</p>
<p>Given that you&#8217;ve got to create some kind of imports file, it made a lot of sense to produce it in the same format the linker uses, name decoration and all. Doing that was lots easier than changing the existing linker to understand a new format like DEF or something similar.</p>
<p>So the specifics of the format are to some extent accidents of history. The linker had a format already for linking stuff. DLLs needed import libraries to solve the chicken and egg problem. Voila.</p>
<p>And of course you could change the linker to allow linking directly to finished DLLs. There&#8217;s just not a lot of incentive to do so, since that wouldn&#8217;t remove the necessity for import libraries.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777653">
				<div id="div-comment-777653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matthew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777653">
			October 14, 2009 at 7:57 am</a>		</div>

		<p>The big point is still being lost for the most part.</p>
<p>DLLs don&#8217;t contain any kind of mappings primarily because they don&#8217;t need them.</p>
<p>The mappings are completely meaningless and entirely useless at runtime. They are only useful for compile/link time. As such, you are bloating your modules by including elements which serve absolutely no purpose at runtime, just so that you don&#8217;t have to have an additional file during compile/link time.</p>
<p>The only thing that matters at runtime is that ordinal X or *externally-visible* name Y corresponds to address A. Nobody at runtime cares that &#8216;Y&#8217; is an alias for internal name &#8216;ABCDEFG@$#BBQ&#8217;. It doesn&#8217;t matter what it used to be called during development; at runtime, you only care about what it is called *right now*.</p>
<p>As Raymond says, you don&#8217;t keep track of information that you don&#8217;t need.</p>
<p>Also, @Matt G:</p>
<p>&quot;&#8230;but if you know the ordinal (which is necessary to use GetProcAddress) you could still get by without the import library.&quot;</p>
<p>This isn&#8217;t about explicit linking. Explicit linking doesn&#8217;t require squat. All responsibility is on the developer to ensure that everything they do makes sense (e.g., that if a symbol they expect doesn&#8217;t exist, they know what to do, and that if it does, that they know the appropriate form to cast to).</p>
<p>Import libraries are only used for implicit dynamic linking, whereby you are already tying in to an external symbol during link instead of waiting until runtime to determine anything and everything.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777673">
				<div id="div-comment-777673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777673">
			October 14, 2009 at 8:00 am</a>		</div>

		<p>&#8220;[Another problem is that stdcall decorates differently on different platforms. -Raymond]&#8221;</p>
<p>&#8220;The linker would do some pattern matching to realize that the unresolved symbol _foo@12 corresponds with FOO.DLL!foo&#8221;</p>
<p>Again it comes back to the question of why. It is clear enough now that a number of decisions* have been made that make it necessary to have an import library; what is not clear is what benefit those decisions bring (or were perceived to bring) that is worth the extra complexity, as compared to standardizing name decoration** and putting the decorated names in the dll and using the decorated names for linking to the DLL at both compile time and runtime.</p>
<p>And having a different name on a different platform isn&#8217;t really insurmountable when you need both a different dll and a different exe to run on a different platform, but in principle you could standardize it to the point where this isn&#8217;t necessary.</p>
<p>*including, for that matter, decorating stdcall at all. I&#8217;ve always taken this for granted, but the reason this should be necessary is not obvious.</p>
<p>**you don&#8217;t need to use the same compiler everywhere to decorate names the same way, just like you don&#8217;t need to use the same compiler to pass arguments the right way round on the stack.</p>
<p>Ditto @Henning Malkolm: How exactly does the DLL get the undecorated names anyway, when the object modules it is built from only contain decorated names?</p>
<div class=post>[<i>Standardized decoration would have been great, but which vendor&#8217;s decoration scheme do you standardize on? And once you have standardized decoration, you have to have standardized C++ object layout, because you&#8217;ve made it possible to link C++ modules from different vendors. Your Win32 ABI now encompasses all of C++. (And now every other language compiler needs to understand C++ in order to decorate its symbols correctly. But what if a language [e.g. Managed C++] has a feature that doesn&#8217;t exist in C++? How do you decorate that?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777693">
				<div id="div-comment-777693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matthew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777693">
			October 14, 2009 at 8:14 am</a>		</div>

		<p>@asd:</p>
<p>&quot;After all, it seems pretty logical. If you can LoadLibrary, GetProcAddress and cast it to whatever function pointer you want, why do you have to go to all the troubles to tell compiler to do just that, only automatically?&quot;</p>
<p>That&#8217;s what import libraries are for. To provide all of the necessary translation &#8211; including from internal symbols to the exported, visible symbols, the necessary casting and calling conventions to apply to the address when it is actually called, etc.</p>
<p>Without such added information, it would be downright magical. There is no way of knowing how your internally-defined external reference maps along the symbol chain, or if it needs to be accessed by ordinal. If it could do all of this, then yes, it could apply your prototype to cast the function pointer appropriately &#8211; but you can&#8217;t get to that point without knowning the absolute mapping, which is not contained in the DLL.</p>
<p>See Raymond&#8217;s response to the comment by Leif Strand.</p>
<p>Another general comment:</p>
<p>People need to realize that *why* they get certain output is more important than that they got it. What do I mean? Well, like the comment on how they get decorated symbols as export names. That&#8217;s all fine and dandy, but why? Because the spec requires it? NO. It&#8217;s because the default options on that particular build environment chose to output it in that way.</p>
<p>It&#8217;s like those who assert that &#8216;++i&#8217; and &#8216;i++&#8217; are always equivalent in efficiency when used in a standalone statement, simply because the machine code generated by their build environment is identical. Just because your compiler works in a certain way (in this case, optimizing postfix increment into prefix increment when it doesn&#8217;t matter) doesn&#8217;t mean that all compilers are mandated by a standard to operate in that way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-777893">
				<div id="div-comment-777893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777893">
			October 14, 2009 at 3:25 pm</a>		</div>

		<blockquote><p>
  &gt; Import libraries exist specifically because you may need (in fact, often need) to generate two DLLs that call each other.
</p></blockquote>
<p>Another excellently layered architecture!</p>
<p>NetBSD will happily segment trap over circular library references, try using ldd on one.</p>
<p>If you have a circular reference, how do you unload them?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-777903">
				<div id="div-comment-777903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">HagenP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-777903">
			October 14, 2009 at 3:50 pm</a>		</div>

		<p>&quot;[&#8230;] all you get are the function parameter types and return type [&#8230;]&quot;</p>
<p>With COM, you also get the names of the parameters. So you can better aim (for shooting yourself in the foot).</p>
<p>(Side note: After studying MSDN for three days exporting a COM interface from a .NET public interface becomes really simple. What happened to one-page samples that teach you the same thing in 15 minutes?)</p>
<p>&quot;[&#8230;] Would security patches also have to patch your SDK?&quot;</p>
<p>Well, yes. That&#8217;s exactly what KMDF/UMDF are trying to do with their co-installer system. &nbsp;Newer framework libraries shall be able to replace older ones &#8211; even for already installed drivers. One major reason for this are security fixes for drivers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-778043">
				<div id="div-comment-778043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-778043">
			October 15, 2009 at 12:10 am</a>		</div>

		<p>&gt;&gt; [I think you&#8217;re confusing the compiler and the linker. Remember, under the classical model, the linker does not generate code. (The linker also doesn&#8217;t know what language you wrote your program in.) -Raymond]</p>
<p>Isn&#8217;t it possible for the compiler to automatically generate an additional &#8220;auto-imports&#8221; file, which would contain references to the imported functions mentioned in code? Then linker would link everything just fine, not even knowing about the trick. This way you don&#8217;t break the two-layered architecture.</p>
<p>Of course that probably won&#8217;t work with exported classes and such, as compiler has nowhere to get their link info from, but they&#8217;re rarely exported this way. So if anybody uses them, he might as well use import libraries.</p>
<div class=post>[<i>How does the compiler know that the imported named &#8220;_bar&#8221; is coming from FOO.DLL and not another file BAR.C in your project? And how does it know that _bar maps to FOO.DLL? Remember, we&#8217;re in the old days before __declspec. Oh, and if FOO.C and BAZ.C both imported FOO.DLL!_bar, then the linker will raise a &#8220;multiply defined symbol&#8221; error. (Under the classical model, a symbol could be defined only once. COMDAT didn&#8217;t exist back then.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-778053">
				<div id="div-comment-778053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-778053">
			October 15, 2009 at 12:37 am</a>		</div>

		<p>&gt;&gt; That&#8217;s what import libraries are for. To provide all of the necessary translation &#8211; including from internal symbols to the exported, visible symbols, the necessary casting and calling conventions to apply to the address when it is actually called, etc.</p>
<p>No, wait, sorry, I still don&#8217;t get it. Are you saying that this is impossible to implement auto-imports for functions specifically in a separate compiler/linker architecture? Because we already have a working example of how the mixed compiler/linker actually manages to auto-import functions perfectly fine, that&#8217;s Delphi:</p>
<p>function abcd(params): result; call_convention; external &#8216;dllname&#8217; name &#8216;exportname&#8217;/index export_index;</p>
<p>(I&#8217;m sure there are more examples, I&#8217;m just too lazy to google for them)</p>
<p>This works. In other words, just like one would think after learning that we have LoadLibrary/GetProcAddress, it&#8217;s possible to teach compiler or linker or both (as in delphi) to do function imports automatically, from only header info and just a bit more (import name or import ordinal).</p>
<p>I bet it&#8217;s possible to implement this even in a separate compiler/linker scheme. I suggested one way in a previous post, and even if it&#8217;s flawed, there could be other ways to do the same without heavily modifying the linker.</p>
<p>The problem with the import library scheme is just that you have to have both header and import library. This seems like an overkill. After all, you don&#8217;t need import library to do GetProcAddress and cast a result to your type, right? You only need a function type, which can be declared in a header just fine, and a function name, which can be declared there too. So the requirement to have an additional file to do the same automatically seems strange.</p>
<p>Just to make things clear, I don&#8217;t argue with that you need import library for accessing things in dll other than exported functions. Also, if your/Raymonds point was just in explaining &#8220;why the things went this way&#8221; instead of proving this was the only way to go, I have nothing to object too.</p>
<p>(p.s. Oh, but then, another reason why things might have went that way is probably compatibility to C++ standards. Although I&#8217;m not sure what in particular could have caused this. Attributes? I believe Microsoft already has Microsoft C++ specific attributes anyway.)</p>
<div class=post>[<i>N</i><i>ow you&#8217;re proposing changes to the language, which was something the originally design specifically avoided. That way you didn&#8217;t need a special &#8220;Windows-enabled&#8221; version of your compiler; you could keep using your old one and link it to the import LIBs. Important when&nbsp;there didn&#8217;t exist a &#8220;Windows-enabled&#8221; version of your compiler in the first place. If&nbsp;were allowed to change the language, then I could add a keyword dllimport(&#8220;FOO.DLL&#8221;). &nbsp;Oh, and then I&#8217;d go back in time and invent COMDAT so I wouldn&#8217;t get &#8220;multiply defined&#8221; errors. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-778113">
				<div id="div-comment-778113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ikk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-778113">
			October 15, 2009 at 8:11 am</a>		</div>

		<p>[quote]That way you didn&#8217;t need a special &#8220;Windows-enabled&#8221; version of your compiler;[/quote]</p>
<p>Now that&#8217;s a whole different story. We are used to Windows-enabled compilers, with __declspec, __stdcall and whatever.</p>
<p>If there was a requirement of keeping the same linker AND the same compiler I can say I understand. On the other hand, if you can change the compiler, it is possible to push the parameters as the DLL requires (no need for a stub, and no need for a linker that generates code) and call the funcion directly, even if some name remapping is needed.</p>
<div class=post>[<i>Well, except that functions imported from DLLs are not called directly, remember? (How can they, since the address is not known until runtime.) Direct calls work great for statically-linked functions; not so great for dynamically-linked functions.</i>]</div>
<p>[quote]How does the compiler know that the imported named &#8220;_bar&#8221; is coming from FOO.DLL and not another file BAR.C in your project?</p>
<p>And how does it know that _bar maps to FOO.DLL? Remember, we&#8217;re in the old days before __declspec.[/quote]</p>
<p>Again, i guess most readers didn&#8217;t get it (including me) because we are taking __declspec for granted. FOO.DLL could be treated just like BAR.OBJ, that is just another object file. If there are functions with the same name, there will be an error like &#8220;multiply defined symbol&#8221;.</p>
<p>[quote]Oh, and if FOO.C and BAZ.C both imported FOO.DLL!_bar, then the linker will raise a &#8220;multiply defined symbol&#8221; error.[/quote]</p>
<p>Why? The symbol is defined only once, that is in the DLL. You seem to assume that a stub is necessary. Just think of the DLL as a special object file.</p>
<p>I think that with __declspec and maybe other compiler features, import libraries are not needed. You can specify everything in the header file and the compiler does the rest.</p>
<div class=post>[<i>The symbol _bar doesn&#8217;t actually exist in FOO.DLL (because FOO.DLL is not an object library). The compiler would have to autogenerate the import table entry (in Win32, the __imp_bar variable), and it&#8217;s that metadata that would be multiply defined. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-778123">
				<div id="div-comment-778123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-778123">
			October 15, 2009 at 8:38 am</a>		</div>

		<p>The problem is, we&#8217;re *not* in the old days before &#8211; well for my argument it&#8217;s mainly __stdcall. Compilers today *are* windows-enabled. When that happened, import libraries could have been removed from the model (since we&#8217;re all more or less in agreement that the contents of import libraries are compiler-specific, right?).</p>
<p>So the question is, why didn&#8217;t that happen.</p>
<p>In the classical model, as you&#8217;ve said the linker *resolves symbols* (between multiple object modules and static libraries).</p>
<p>In the current model on unix systems (which is where several people in this discussion are getting their point of view on this), the linker resolves the symbols *against the .so* at link time, and once again at runtime. It&#8217;s not clear [other than decorated names in some cases] what information a .so has in it that a .dll does not.</p>
<div class=post>[<i>Yes, it could have changed, but one of the principles of Win32 was to be as similar to Win16 as possible to ease the transition. It just strikes me as awfully heavyweight to carry a 23MB DLL around just because you need 12KB of information from it. I guess the SDK could come with &#8220;stub DLLs&#8221; that are good only for linking. (And woe unto you if you run a program which accidentally dynamically loads the stub DLL instead of the real one!) And then modify the linker so it does the fuzzy logic to map _Foo@12 to the export named &#8220;Foo&#8221;. That&#8217;s an awful lot of work (and risk) to change something that had been working fine up until now. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-778163">
				<div id="div-comment-778163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-778163">
			October 15, 2009 at 12:25 pm</a>		</div>

		<p>I guess that&#8217;s the core difference in philosophy here. On linux the link-time linker actually resolves against the *real* .so files &#8211; that is, the same ones that are used at runtime, the ones installed on the system. The equivalent would be for the SDK to not ship with any dlls, but rather to just use the installed ones (in System32 for the windows API itself, or installed wherever you normally install third-party dlls otherwise).</p>
<p>I guess the windows model would be more space-efficient for something like a cross-compilation scenario, where the system compiling a program is not expected to be capable of running it.</p>
<p>Thanks, I think this answers the question.</p>
<p>&#8216;And then modify the linker so it does the fuzzy logic to map _Foo@12 to the export named &quot;Foo&quot;.&#8217; Well, that or name the export _Foo@12. But I do see your point, one way or another that&#8217;s another aspect that would have to be changed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-778533">
				<div id="div-comment-778533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091013-00/?p=16403#comment-778533">
			October 16, 2009 at 6:53 pm</a>		</div>

		<p>@Random832</p>
<p>&gt;linux the link-time linker actually resolves against the *real* .so files</p>
<p>you can link with the .so, but you don&#8217;t have to.</p>
<p>On unix you can compile your application or .so so that symbols that will only be resolved at run time. &nbsp;This is how you can compile two .so that use each other.</p>
<p>The runtime linker will pick up the symbols wherever they are exported from, in any shared library</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>