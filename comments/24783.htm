<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (66)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-559043">
				<div id="div-comment-559043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559043">
			October 15, 2007 at 10:40 am</a>		</div>

		<p>I suspect (though I&#8217;m not sure) that he was thinking of symlinks to files (which a junction point can&#8217;t do), and was wondering why you have to go through all the COM hoops to do anything with a shortcut (create a WshShell, call CreateShortcut and pass the .lnk filename, set the returned IWshShortcut&#8217;s TargetPath, Arguments, and Description, then Save() it &#8212; and it&#8217;s even worse in C/C++ than when I did it in VB6, because the shell interface was written for a scripting language).</p>
<p>That&#8217;s compared to Unix, where you just symlink(&quot;/path/to/target/file&quot;, &quot;/path/to/link/name&quot;); &#8212; one function call. &nbsp;And getting the path that a symlink points to is as simple as calling readlink() a couple times (to ensure your buffer is large enough) &#8212; where on Windows, you have to make another WshShell, get a namespace for the folder, get an item for the shortcut, call GetLink(), and then use the Path property.</p>
<p>Now, you could create a similar single function that did all the heavy shell lifting for you for each case (and in fact that&#8217;s what I did last time I had to make an installer that added its own shortcuts). &nbsp;OTOH, should every programmer have to reinvent the wheel?</p>
<p>On the third hand, though, shortcuts can certainly do a lot more than symlinks &#8212; change the current directory when they get invoked, for instance. &nbsp;So that&#8217;s probably part of the reason for the added complexity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559053">
				<div id="div-comment-559053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Win32</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559053">
			October 15, 2007 at 10:55 am</a>		</div>

		<p>Hi, I&#8217;m reading some topics from the Suggestion box and I would like to provide two answers:</p>
<p>Commenter Mike Sax asks:</p>
<p>&quot;How does the Task Manager determine that an application is &quot;Not responding&quot;?&quot;</p>
<p>Hi, Mike, Task Manager determines this by using the IsHungAppWindow API (<a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/ms633526.aspx" rel="nofollow">http://msdn2.microsoft.com/en-us/library/ms633526.aspx</a>).</p>
<p>Commenter J-F asks:</p>
<p>&quot;What reason was it made that only files name &quot;setup.exe&quot; brought up a Run as dialog, and isn&#8217;t there any code or API to do with without naming it &quot;setup.exe&quot;?&quot;</p>
<p>Hi, J-F, In your HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionApp Paths registry key there are some subkeys called &quot;Setup.exe&quot;, &quot;Install.exe&quot;, &quot;Winnt32.exe&quot;, etc. If the value &quot;RunAsNonAdminInstall&quot; is set to &quot;1&quot; then XP will ask you for admin privileges. Vista&#8217;s heuristic is completely different, but I assume you&#8217;re talking about XP.</p>
<p>Sorry if this is a bit off-topic, but I enjoy answering questions from the Suggestion box!</p>
<p>Have a nice day!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559063">
				<div id="div-comment-559063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sab39.netreach.com/' rel='external nofollow' class='url'>Stuart Ballard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559063">
			October 15, 2007 at 10:55 am</a>		</div>

		<p>My understanding was that NTFS hardlinks and junction points had different semantics than the unix equivalents, that made them significantly less useful.</p>
<p>I&#8217;m going on rumor here, so feel free to tell me I&#8217;m completely wrong. But I&#8217;d heard that if you create a junction point to a folder, and then use windows explorer to delete the junction point (or one of its parent directories), you&#8217;ll end up deleting the target directory instead.</p>
<p>In Unix, creating a symlink to a file or directory has no significant downside &#8211; it&#8217;s a no-brainer. If my understanding of the NT semantics are correct, creating a junction point to a folder is effectively playing russian roulette with the contents of that folder.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559073">
				<div id="div-comment-559073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559073">
			October 15, 2007 at 11:12 am</a>		</div>

		<p>I always missed the good old &quot;Aliases&quot; used by Apple. OS X doesn&#8217;t seem to handle them any better than Windows, but Mac Classic was great at always keeping them pointed to the right location, even when that location changed paths or drives.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559083">
				<div id="div-comment-559083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559083">
			October 15, 2007 at 11:15 am</a>		</div>

		<p>On a related note &#8211; as NTFS and the NT kernel[0] support hard links, they presumably maintain a link count for filesystem objects. Given this, can you open a file in such a way that it can be deleted while held open? Perhaps with the FILE_SHARE_DELETE or FILE_FLAG_POSIX_SEMANTICS flags? The MSDN documentation for CreateFile() just got a bit confusing surrounding the FILE_SHARE_DELETE flag (opening a file /in order/ to delete it?). Can anyone else shed light?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559093">
				<div id="div-comment-559093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JohnW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559093">
			October 15, 2007 at 11:21 am</a>		</div>

		<p>Another reason is that the tools are not bundled with Windows, to be used anytime by administrators or end users. &nbsp;The alternative is to download unsupported tools, or code it yourself.</p>
<p>Junctions are used as one of the ways to provide application compatibility in Vista. &nbsp;Perhaps we&#8217;ll see more of them going forward.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559103">
				<div id="div-comment-559103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559103">
			October 15, 2007 at 11:31 am</a>		</div>

		<p>Is it just me, or do the terms &quot;reparse point&quot; and &quot;junction point&quot; sound like really heavyweight constructs that you wouldn&#8217;t want to use very often? Compared to, say, &quot;shortcut&quot; or &quot;link&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559123">
				<div id="div-comment-559123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559123">
			October 15, 2007 at 11:50 am</a>		</div>

		<p>Yes, &quot;reparse point&quot; is a horrible name for a link to a file (or other object). &nbsp;</p>
<p>The name makes it sound complicated to use.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559133">
				<div id="div-comment-559133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://thehungersite.com' rel='external nofollow' class='url'>AndyB</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559133">
			October 15, 2007 at 11:52 am</a>		</div>

		<p>@Stuart Ballard:</p>
<p>I&#8217;ve just tried it, and no, creating a junction to a folder then deleting the junction in explorer doesn&#8217;t delete the target folder. Try it yourself (download a copy of junction.exe from sysinternals and use it in a cmd prompt)</p>
<p>The junction does work like symlinks, if you delete the target folder and try to access the junction, you get a &#8216;target inaccessible&#8217; type error.</p>
<p>Or to put it another way, don&#8217;t believe the FUD those linux people put out :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559143">
				<div id="div-comment-559143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Will</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559143">
			October 15, 2007 at 11:58 am</a>		</div>

		<p>Here&#8217;s a couple of decent shell extensions for creating/manipulating hard links:</p>
<p><a rel="nofollow" target="_new" href="http://sourceforge.net/projects/ntfslinkext" rel="nofollow">http://sourceforge.net/projects/ntfslinkext</a></p>
<p><a rel="nofollow" target="_new" href="http://schinagl.priv.at/nt/hardlinkshellext/hardlinkshellext.html" rel="nofollow">http://schinagl.priv.at/nt/hardlinkshellext/hardlinkshellext.html</a></p>
<p>The first app is a bit more user-friendly, while the second one has a bit more functionality (like the ability to clone an entire directory tree).</p>
<p>There is a danger in creating a hard link to a directory &#8211; if you ask Explorer to delete it, it will naturally delete the contents, instead of unlinking the folder. &nbsp;NTFS Link has a pretty nice feature which allows you to unlink a folder using the context-menu. &nbsp;NTFS Link also creates an icon overlay which indicates whether a file or folder has multiple hard links associated with it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559163">
				<div id="div-comment-559163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559163">
			October 15, 2007 at 12:20 pm</a>		</div>

		<p>&#8220;There is a danger in creating a hard link to a directory &#8211; if you ask Explorer to delete it, it will naturally delete the contents, instead of unlinking the folder.&#8221;</p>
<p>So deleting and unlinking are two distinct operations on Win32 ? On Unix the file is deleted when the link count becomes 0. </p>
<p>So is a hard link a special construction in NTFS or is it a &#8216;real&#8217; hard link as in that is is indistinguishable from the original link ? And does a delete find look for al the hardlinks to the file or does it just leave them dangling ?</p>
<div class="post">[<i>People are confusing two issues. 1: Deleting a link, 2: Whether you should recurse through links when deleting a directory tree. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559213">
				<div id="div-comment-559213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559213">
			October 15, 2007 at 1:13 pm</a>		</div>

		<p>One thing worth mentioning is that LNK files don&#8217;t technically work in filesystem-space, but in Explorer&#8217;s IDLIST space. &nbsp;Explorer keeps an object-system around rooted at &quot;Desktop&quot; that lets you also create shortcuts to Control Panels, Printers, My Computer, and other things that have no filesystem equivalents.</p>
<p>Just something to throw out there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559263">
				<div id="div-comment-559263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559263">
			October 15, 2007 at 2:32 pm</a>		</div>

		<p>@David Walker</p>
<p>&quot;Yes, &quot;reparse point&quot; is a horrible name for a link to a file (or other object).&quot;</p>
<p>There is a reason for this (though not a particularly good one for it to propagate up to the user&#8217;s view), which has to do with Windows file system implementation.</p>
<p>The FS driver (FSD) entry point for NtCreateFile can return a couple things, including STATUS_SUCCESS or FILE_NOT_FOUND (or something like this), but also one called STATUS_REPARSE. In this case conceptually the FSD also returns a new file name. When this happens, the I/O subsystem tries to open it again, this time with the new file name. I haven&#8217;t actually tried to verify this, but I would bet any money things like junction points are implemented through this STATUS_REPARSE.</p>
<p>@Aaargh!</p>
<p>&quot;Making a hard link to a directory is a really, really bad idea, you have the chance that suddenly your directory tree is no longer a tree but graph. With cycles.&quot;</p>
<p>To be honest, I was always surprised that the Unix-folk have issues with this danger. It seems to me more in the Unix philosophy more to give the user the power to make such links and let them beware of the consequences of doing so. ;-)</p>
<p>Besides, the two ideas aren&#8217;t necessarily incompatible. For instance, you could check for cycles either at link creation time (I don&#8217;t know how efficiently, but I bet you could do something with topological numbering) or traversal time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559283">
				<div id="div-comment-559283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DriverDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559283">
			October 15, 2007 at 3:06 pm</a>		</div>

		<p>No, I almost certain even NTFS can&#8217;t have hard links to directories. You&#8217;d need to use a junction point and those behave more like symlinks.</p>
<p>Explorer&#8217;s problem is that it doesn&#8217;t understand junction points (or didn&#8217;t, Vista apparently now does) &nbsp;UNIX, from day one, has symlinks and hard links in their filesystem, and all the utilities were written with that in mind. A symlink is not a directory and rm knows the difference. But Explorer has a simplified view that junctions to directories are the same as a real directory, and therefore recurses and deletes the contents of the target. (As others have pointed out, Vista has learned the difference)</p>
<p>In a sense, Apple also designed a lot of metadata stuff into their filesystem and Finder since the beginning.</p>
<p>Microsoft tried to add these features on top of a filesystem and UI that wasn&#8217;t designed for any of this.</p>
<p>It&#8217;s about time. :=)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559293">
				<div id="div-comment-559293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DriverDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559293">
			October 15, 2007 at 3:13 pm</a>		</div>

		<p>[It seems to me more in the Unix philosophy more to give the user the power to make such links and let them beware of the consequences of doing so.]</p>
<p>Consequences be damned&#8230; there are some UNIX that lets root create links to directories and even unlink (rm) non-empty directories.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559303">
				<div id="div-comment-559303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559303">
			October 15, 2007 at 3:22 pm</a>		</div>

		<p>Just to clear up a bit of confusion, NTFS works just like UFS in how it handles links. Each file is just an entry in the database, and its names are just directory entries (and attributes on that file). Creating a hard link just gives the file an additional filename. As far as I know, it is not possible to create multiple filenames on a directory. Deleting a file will remove filename and its corresponding directory entry. Once a file has no more filenames, it is actually deleted.</p>
<p>Instead of Unix&#8217;s unlink() operation, you delete a file (i.e. remove its filename) by opening the file with DELETE_ACCESS, then setting its disposition to deleting, and closing the file handle. You can delete a file that is already open if it was opened with FILE_SHARE_DELETE access.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559313">
				<div id="div-comment-559313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">history buff</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559313">
			October 15, 2007 at 3:54 pm</a>		</div>

		<p>DriverDude, UNIX has NOT had symlinks from day 1. If you believe the man page, symlinks were first available in 4.2BSD, which puts it somewhere between 1983 and 1986. First Edition UNIX came out in 1971, so it was over 10 years from when UNIX was first released until some version had symlinks. It wasn&#8217;t until some years later that AT&amp;T UNIX actually had that feature, though. And in reality, MULTICS had that feature in the mid-60s, so it was over 15 years before it appeared in UNIX.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559323">
				<div id="div-comment-559323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559323">
			October 15, 2007 at 5:41 pm</a>		</div>

		<p>&quot;No, I almost certain even NTFS can&#8217;t have hard links to directories.&quot;</p>
<p>I just gave it a try, and no, apparently you can&#8217;t. It gives access denied. That&#8217;s somewhat of a pity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559333">
				<div id="div-comment-559333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559333">
			October 15, 2007 at 6:49 pm</a>		</div>

		<p>Junction.exe from SysInternals: <a rel="nofollow" target="_new" href="http://www.microsoft.com/technet/sysinternals/FileAndDisk/Junction.mspx" rel="nofollow">http://www.microsoft.com/technet/sysinternals/FileAndDisk/Junction.mspx</a></p>
<p>My gripe with junctions is Explorer does not have a different graphic for them (I haven&#8217;t checked this under Vista), which means you have to drop to CMD.exe to check &#8212; rather than &quot;&lt;DIR&gt;&quot; they&#8217;re listed as (IIRC) &quot;&lt;JUNCTION&gt;&quot;.</p>
<p>Under XP, junctions are for most purposes just another directory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559153">
				<div id="div-comment-559153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559153">
			October 15, 2007 at 12:19 pm</a>		</div>

		<p>I think it depends on which version of Explorer we&#8217;re talking about.</p>
<p>In XP, Explorer didn&#8217;t know a junction (or whatever) from a real directory and would recursively delete its contents before deleting the junction itself. The original directory might have been left but the *contents* of it would be gone, which wasn&#8217;t good.</p>
<p>However, in Vista, Explorer now knows about junctions (and symlinks) and won&#8217;t recursively delete their contents. (Or will warn/ask you. I can&#8217;t remember exactly.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-559343">
				<div id="div-comment-559343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559343">
			October 15, 2007 at 7:33 pm</a>		</div>

		<p>steveg: On Vista, junctions have the little &quot;shortcut&quot; icon, though unlike regular shortcuts, they&#8217;re sorted with the folders&#8230; it&#8217;s rather confusing if you ask me :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559173">
				<div id="div-comment-559173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559173">
			October 15, 2007 at 12:38 pm</a>		</div>

		<p>@Karallen, David Walker: &nbsp;&quot;Reparse points&quot; are a lot more than just links &#8212; you can effectively stick any information in those that you want. &nbsp;I&#8217;ve seen reparse points used for everything from folder junctions to eliminating redundant files to storing data offline to making automatic backups. &nbsp;Lord only knows what additional weird stuff third-party developers have used them for. &nbsp;In effect, if you&#8217;re coming from a Un*x world, don&#8217;t think of reparse points as equivalent to symbolic links: &nbsp;Think of them closer to block/character special files.</p>
<p>That said, Vista now uses reparse points &quot;under the hood&quot; to implement Un*x-like symbolic links. &nbsp;Of course, if you&#8217;re not on Vista, these aren&#8217;t available to you.</p>
<p>*sigh* &nbsp;How many different link-like constructs are there now in Windows, anyway? &nbsp;Junctions, mount points, SIS, Shortcuts, NTFS links, offline storage, and symbolic links are the ones I can think of offhand. &nbsp;It&#8217;s a real shame Microsoft can&#8217;t deprecate a few of those and simplify the design of the OS a little.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559223">
				<div id="div-comment-559223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559223">
			October 15, 2007 at 1:52 pm</a>		</div>

		<p>I guess I didn&#8217;t read it properly before, but a hard link to a *directory* ? And that&#8217;s actually a legal operation in Win32 ? </p>
<p>Making a hard link to a directory is a really, really bad idea, you have the chance that suddenly your directory tree is no longer a tree but graph. With cycles. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559363">
				<div id="div-comment-559363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559363">
			October 15, 2007 at 9:12 pm</a>		</div>

		<p>I like sorting shortcuts-to-folders amoung folders, and also being able to see the type and &#8212; most useful of all &#8212; target of shortcuts, symlinks and junctions:</p>
<p><a rel="nofollow" target="_new" href="http://www.pretentiousname.com/temp/ShortcutTypesAndTargets.png" rel="nofollow">http://www.pretentiousname.com/temp/ShortcutTypesAndTargets.png</a></p>
<p>I doubt that most users know or care much about these things, especially when most of the junctions are hidden by default in Explorer and it isn&#8217;t easy (or recommended) to go around making new ones. If you&#8217;re one of the few who do care about such details then Explorer probably isn&#8217;t the best tool to be using in the first place.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559383">
				<div id="div-comment-559383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559383">
			October 16, 2007 at 3:12 am</a>		</div>

		<p>&quot;To be honest, I was always surprised that the Unix-folk have issues with this danger. It seems to me more in the Unix philosophy more to give the user the power to make such links and let them beware of the consequences of doing so. ;-)&quot;</p>
<p>Sure, but this is not a case of giving more control to a user, this is a case of bad FS design.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559393">
				<div id="div-comment-559393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.1060.org/blogxter/publish/5' rel='external nofollow' class='url'>Steve Loughran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559393">
			October 16, 2007 at 3:36 am</a>		</div>

		<p>These comments are all really interesting, it boils down to &quot;Vista has symlinks&quot;. We only need a decent API to make it easy to create/unlink and you are laughing.</p>
<p>Oh, and for MSI files to handle setting up symlinks as part of the declarative part of the install, something you dont need to write script for and to use some third party installer. Why? Because checking symlinks point to files that exist is a way of verifying the state of an install. Later at uninstall time, the uninstaller should only remove the link if it points to the original destination.</p>
<p>Certainly the RPM packages I&#8217;ve done in linux tend to do the ln -sf and link rm operations in bits of script; its always the hardest part to get right (especially during package upgrades)</p>
<p>Anyway, we, the Linux users, welcome Vista to the 1990&#8217;s :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559353">
				<div id="div-comment-559353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Will</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559353">
			October 15, 2007 at 9:03 pm</a>		</div>

		<p>Quote: [No, I almost certain even NTFS can&#8217;t have hard links to directories. You&#8217;d need to use a junction point and those behave more like symlinks.]</p>
<p>Sorry, when I wrote &quot;hard link to directory&quot;, I really should&#8217;ve written &quot;junction point&quot;. &nbsp;The utilities I linked to create *hard links to files* and *junction points to directories*.</p>
<p>I believe one of the differences is that a hard link is indistinguishable from the file itself, whereas a junction point is NOT exactly the same as the directory itself. &nbsp;So when I said there&#8217;s an issue with &quot;unlinking a hard link to a directory&quot;, I really should&#8217;ve said &quot;unlinking a junction point&quot;. </p>
<p>steveg: If you want junctions to look different in Explorer (XP), get NTFS Link (Ext) (URL is in my above post). &nbsp;It will create icon overlays for junction points, and for files with more than 1 hard link. &nbsp;It will also attempt to update junction points for directories that have been moved, renamed, or deleted (which is something Windows doesn&#8217;t do, AFAIK).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559373">
				<div id="div-comment-559373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Will</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559373">
			October 15, 2007 at 9:17 pm</a>		</div>

		<p>Just to clarify my above posts: The issue with junction points is that, as someone mentioned, they *mostly* behave like symlinks, *until* you try to delete them in Explorer. &nbsp;When you do that, the contents of the target directory are deleted (at least under 2K and XP).</p>
<p>But NTFS Link will intercept delete operations so that the junction point will be deleted, and not the target directory. &nbsp;And again, it also provides a handy right-click option to manually unlink junction points.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559403">
				<div id="div-comment-559403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AntiCom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559403">
			October 16, 2007 at 4:55 am</a>		</div>

		<p>What is stupid is simply that for links (and many many others things) you have to call cryptic COM interfaces instead of just a plain good-old C procedure. This would be not too bad (maybe even a good thing) if COM was just usable; however COM is full of traps, error-prone and just hard to use, shifting the programmer&#8217;s focus from object management to its crappy syntax.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559413">
				<div id="div-comment-559413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559413">
			October 16, 2007 at 4:57 am</a>		</div>

		<p>&quot;Those who do not understand Unix are condemned to reinvent it, poorly.&quot;</p>
<p>&#8211;Henry Spencer</p>
<p>Maybe in a few decades, Windows will finally be a Unix.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559423">
				<div id="div-comment-559423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559423">
			October 16, 2007 at 5:17 am</a>		</div>

		<p>Junctions are rather more like Linux&#8217;s bind-mounts than symbolic links.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559433">
				<div id="div-comment-559433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559433">
			October 16, 2007 at 5:21 am</a>		</div>

		<p>In my understanding, shortcuts and (sym)links serve completely different purposes. Shortcuts are intended to launch programs (optionally supplying them with parameters), while links are just different pointers to the same file (or directory).</p>
<p>Also, the symlinks on Vista don&#8217;t look like junctions to me &#8211; I played with them a little, and also created some symlinks on a share served by Windows XP x64, and from XP the symlinks looked like 0-byte inaccessible files (however I&#8217;ve heard there&#8217;s a driver that makes the Vista symlinks work in XP). Another interesting thing is, that Vista distinguishes between file and directory symlinks &#8211; something that Unix doesn&#8217;t do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559443">
				<div id="div-comment-559443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.universityupdate.com/Technology/Windows-Vista/5242874.aspx' rel='external nofollow' class='url'>University Update - Windows Vista - Why aren't shortcuts as easy as unix links?</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559443">
			October 16, 2007 at 5:46 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.universityupdate.com/Technology/Windows-Vista/5242874.aspx" rel="nofollow">http://www.universityupdate.com/Technology/Windows-Vista/5242874.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559463">
				<div id="div-comment-559463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559463">
			October 16, 2007 at 6:43 am</a>		</div>

		<p>For everyone: the Windows NT line has always supported hardlinks in the kernel; symlink support came in Windows 2000 (&quot;reparse&quot; logic in the object manager). NTFS has always supported hardlinks, as well, but Win32 didn&#8217;t have a convenient API until Windows 2000; NTFS started supporting mount points (which could be abused as directory symlinks with absolute destination paths) in Windows 2000, and finally got full support for symlinks in Windows Vista. The outstanding difference with UNIX is that symlinks in Windows can be, in turn, either directories or files, because Win32 cares about that (you can choose whether you care or not when you open a file, though)</p>
<p>Aaargh!: Windows has been a part-time UNIX since about Windows 2000. In my experience, you can run NetBSD wonderfully on Windows, just download the bootstrapper and you&#8217;re go: <a rel="nofollow" target="_new" href="http://www.netbsd.org/docs/pkgsrc/platforms.html#interix" rel="nofollow">http://www.netbsd.org/docs/pkgsrc/platforms.html#interix</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559473">
				<div id="div-comment-559473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559473">
			October 16, 2007 at 6:47 am</a>		</div>

		<p>Correction: actually, the kernel always supported symbolic links, just not when opening/creating files (the parse routines for device objects didn&#8217;t know what to do with a return code of STATUS_REPARSE from an IRP_MJ_CREATE I/O request)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559483">
				<div id="div-comment-559483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559483">
			October 16, 2007 at 6:53 am</a>		</div>

		<p>Almost forgot: Windows doesn&#8217;t have an equivalent of unlink: you can mark a file as pending deletion, but that won&#8217;t free up the directory entry. An unlink would be the equivalent of renaming a file to an empty name, but NTFS doesn&#8217;t like that. The closest you can go is move the file to a temporary directory, and mark it as pending removal. You&#8217;ll see Interix creates a weird directory at the root of some drives: that&#8217;s where files unlinked while they were in use stay until they are closed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559493">
				<div id="div-comment-559493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559493">
			October 16, 2007 at 7:22 am</a>		</div>

		<p>Services for Unix (Applications) is similar to cygwin when it comes to symlinks &#8211; from normal Win32, they appear as files (with the system attribute set). The Linux cifs driver also supports symlinks (and devices, pipes) on Windows shares in the same way as SFU.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559503">
				<div id="div-comment-559503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559503">
			October 16, 2007 at 7:40 am</a>		</div>

		<p>Interix can&#8217;t always unlink files that are in use. Although something like</p>
<p>rm ~/foo &gt; ~/foo</p>
<p>works, you can&#8217;t do</p>
<p>cp /bin/rm ~/rm; ln ~/rm ~/foo; ~/rm -f ~/foo</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559513">
				<div id="div-comment-559513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559513">
			October 16, 2007 at 7:51 am</a>		</div>

		<p>Neil: executables used as the main executable of a process are specifically locked down by the kernel so they cannot be deleted or otherwise moved/renamed. Nothing Interix can do about that&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559533">
				<div id="div-comment-559533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.1060.org/blogxter/publish/5' rel='external nofollow' class='url'>Steve Loughran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559533">
			October 16, 2007 at 9:56 am</a>		</div>

		<blockquote><p>
  executables used as the main executable of a process are specifically locked</p>
<p>  down by the kernel so they cannot be deleted or otherwise moved/renamed.
</p></blockquote>
<p>I think you may be able to flip a bit in the header of an exe telling the OS to copy it to swap before running. That&#8217;s the problem you see -the OS wants to page bits in on demand. Linux deals with by allowing you to unlink the program from the filesystem, while retaining a link the executable from the process: the running code runs the old executable.</p>
<p>I dont know which is better architecturally; Windows does at least guarantee that all programs loading the same COM DLL are going to get the same version. What linux does let you do is update swathes of the system while the apps are running, which is good for sysadmin.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559553">
				<div id="div-comment-559553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nksingh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559553">
			October 16, 2007 at 10:24 am</a>		</div>

		<p>@Steve:</p>
<p>I&#8217;m not sure leaving apps running while updating them is a great idea, because then you can&#8217;t be sure that the updates have been consistently applied. &nbsp;I think the UNIX approach works for a certain set of sysadmins who are willing to futz around with their box to check the updates were actually consistently applied. &nbsp;If two programs are interacting and have different versions of a link-library because they were started at different times, you have a potentially hard to figure out reliability problem. &nbsp;</p>
<p>Rebooting/restarting for an update is not such a tragedy&#8230; it ensures that your system updates correctly in a less error-prone way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559583">
				<div id="div-comment-559583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559583">
			October 16, 2007 at 10:50 am</a>		</div>

		<p>@Aaargh!</p>
<p>&quot;Maybe in a few decades, Windows will finally be a Unix.&quot;</p>
<p>Geez, I hope not. Unix is almost as bad as Windows, just in entirely different ways. ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559603">
				<div id="div-comment-559603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559603">
			October 16, 2007 at 11:00 am</a>		</div>

		<p>@nksingh:</p>
<p>Or, instead of rebooting/restarting the system, you could just restart all the services.</p>
<p>One way to do this is to restart each service individually by calling its init.d script with the &quot;restart&quot; parameter. If you&#8217;ve got some extra dependencies (such as web stuff that depends on a database and can&#8217;t deal with it dropping out) you could do something like the following:</p>
<p>/etc/init.d # ./apache2 stop &amp;&amp; ./postgresql restart &amp;&amp; ./apache2 start</p>
<p>Another way would be to drop to runlevel S/1 which will stop all services in the normal shutdown order, and then go back to your normal runlevel (probably 3 or 5) which will start them all up again in the correct order.</p>
<p>Both of these will produce a lot less downtime than a reboot due to not needing to unmount filesystems, stop hardware, go through BIOS POST, run bootloader, load kernel, mount filesystems, maybe get network lease, etc&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559613">
				<div id="div-comment-559613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559613">
			October 16, 2007 at 11:25 am</a>		</div>

		<p>Suraj Barkale &#8212; I doubt it. &nbsp;I suspect there&#8217;s no reason to document the format anyway, since you can ask the shell for a COM interface that gives you access to everything in the file already.</p>
<p>Documenting the format means it can never change in the future (e.g. when a new feature is added to shortcuts (like the &quot;run as another user&quot; flag) and an IWshShortcut2 interface is created, or whatever other interface(s) people use).</p>
<p>There is documentation for the WshShell.CreateShortcut function (which I&#8217;ve just found out doesn&#8217;t overwrite the LNK file if a shortcut already exists; wish I&#8217;d have seen that earlier), and its returned IWshShortcut interface, though. &nbsp;(Also for the classes that implement that interface: both WshShortcut and WshURLShortcut.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559643">
				<div id="div-comment-559643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jelovic.com' rel='external nofollow' class='url'>Dejan Jelovic</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559643">
			October 16, 2007 at 12:01 pm</a>		</div>

		<p>Raymond,</p>
<p>Bull.</p>
<p>If shell links were designed by an Unix programmer then they would be text files that programmers could learn to create simply by taking a look at a few of them.</p>
<p>(Or if this was done today these would be XML files.)</p>
<p>But what did you do instead? You created a freakin COM API that saves into a binary format. Creating shortcuts now requires browsing through MSDN and then copying &amp; pasting code from there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559753">
				<div id="div-comment-559753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://fluff.info/blog' rel='external nofollow' class='url'>B</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559753">
			October 16, 2007 at 12:46 pm</a>		</div>

		<p>Don&#8217;t XP and Vista claim to be POSIX compliant? Given that the ln command (and ln -s) are part of the POSIX standard, it seems that both hard and soft links &nbsp;would be requisite.</p>
<p>I just skimmed the comments to this point, but from my perspective, the real problem is not about the relative merits of different link types or when using a link is shooting yourself in the foot, but whether a POSIX-compliant script can run on a POSIX-compliant OS. That&#8217;s the whole point of having a standard&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559783">
				<div id="div-comment-559783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559783">
			October 16, 2007 at 1:17 pm</a>		</div>

		<p>@B</p>
<p>&quot;Don&#8217;t XP and Vista claim to be POSIX compliant? Given that the ln command (and ln -s) are part of the POSIX standard, it seems that both hard and soft links &nbsp;would be requisite.&quot;</p>
<p>NT is only POSIX-compliant from within the POSIX Subsystem/Interix/SUA/whatever you want to call it.</p>
<p>It&#8217;s possible to create links with ln and ln -s that behave correctly from within SUA even in Windows 2000, and very possibly before then. However, to programs running in the Windows subsystem, links created by SUA&#8217;s ln appear as files.</p>
<p>There are other differences too; for instance SUA presents [can present] a case-sensitive view of NTFS file systems, which means you can create c:test and c:TEST, and only one of them will be accessible to any program that uses the Windows subsystem (and doesn&#8217;t &quot;cheat&quot; and make native system calls directly).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559793">
				<div id="div-comment-559793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559793">
			October 16, 2007 at 1:20 pm</a>		</div>

		<p>Steve: it only applies to modules loaded implicitely by CreateProcess; DLLs can, as a rule, be renamed while in use</p>
<p>Dejan: the UNIX equivalents are, in fact, INI files: <a rel="nofollow" target="_new" href="http://standards.freedesktop.org/desktop-entry-spec/latest/" rel="nofollow">http://standards.freedesktop.org/desktop-entry-spec/latest/</a></p>
<p>B: &quot;compliant&quot; doesn&#8217;t mean &quot;usable&quot;. You have to jump through a few hoops to get an UNIX environment on Windows. I found NetBSD&#8217;s pkgsrc tree to help immensely, though</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559833">
				<div id="div-comment-559833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559833">
			October 16, 2007 at 1:46 pm</a>		</div>

		<p>&quot;UNIX, from day one, has symlinks and hard links in their filesystem, and all the utilities were written with that in mind.&quot;</p>
<p>IMO, &quot;Hacked to sort-of-work with them&quot; is a better description. From the man page for cp on my Mac (10.4):</p>
<p>&quot;Note that cp copies hard linked files as separate files. &nbsp;If you need to preserve hard links, consider using tar(1), cpio(1), or pax(1) instead.&quot;</p>
<p>Yes, even today, the Unix copy tool can not reliably copy a directory tree. I have no reason to believe that other Unices are better in this respect.</p>
<p>From a Linux page describing cp:</p>
<p>&quot;Symbolic and hard links are copied as files. That can be good because, at the destination, a symbolic link might point to the wrong place. It can be bad if the link pointed to a really big file; the copy can take a lot of disk space.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559883">
				<div id="div-comment-559883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wesha</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559883">
			October 16, 2007 at 2:58 pm</a>		</div>

		<p>&gt; But neither of these features is available on FAT (or CD-ROMs or Novell Netware or email), which meant that Windows 95 couldn&#8217;t use them.</p>
<p>Yeah suuuuuure. Long names werent available on FAT either but somehow Windows 95 was able to use them, y&#8217;know. A tiny little backwards compatible extension to the directory structure, and viola! Please please don&#8217;t tell me symlinks couldn&#8217;t have been done the same way! </p>
<div class=post>[<i>What should a downlevel client see when they encounter a FAT symlink? (FAT LFNs get a short file name for backward compability. But how should a FAT symlink appear to, say, your camera?) And even if you solve this, there are still all the other reasons that are still outstanding. (How do you email somebody a symlink?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559523">
				<div id="div-comment-559523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Suraj Barkale</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559523">
			October 16, 2007 at 9:30 am</a>		</div>

		<p>Out of curiosity, is there any *official* documentation of shortcut file format? A quick google search got me to <a rel="nofollow" target="_new" href="http://mediasrv.ns.ac.yu/extra/fileformat/windows/lnk/shortcut.pdf" rel="nofollow">http://mediasrv.ns.ac.yu/extra/fileformat/windows/lnk/shortcut.pdf</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560033">
				<div id="div-comment-560033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560033">
			October 16, 2007 at 6:48 pm</a>		</div>

		<p>Windows come up with all this strange names (reparse point &amp; junction point) because naming them link or shortcut would indicate unix was right all the time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-559673">
				<div id="div-comment-559673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Not Jerry and Larry</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559673">
			October 16, 2007 at 12:21 pm</a>		</div>

		<p>Re: First commenter&#8217;s &quot;on the third hand&quot;</p>
<p>That would be the *gripping* hand.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560103">
				<div id="div-comment-560103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timbojones</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560103">
			October 16, 2007 at 9:47 pm</a>		</div>

		<p>I have encountered a problem with junctions on XP, in that they don&#8217;t work properly with the recycle bin. &nbsp;If you attempt to delete a file under a junction through explorer, it complains that it cannot find the file. &nbsp;Shift-delete to permanently delete without hitting the recycle bin works fine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560123">
				<div id="div-comment-560123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ubuntero</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560123">
			October 16, 2007 at 10:52 pm</a>		</div>

		<p>@Timbojones</p>
<p>If you research a little about the recycle bin, you will find out it has a lot of &quot;by design&quot; problems with hard resolution. The most annoying for me is that it can get corrupted in a hardly recoverable state and that the underlying filesystem object can&#8217;t be deleted (to resolve corruption with a brand new recycle bin).</p>
<p>BUT you can format your FAT32 partition and, instead of using a backup disk, you can move your stuff there and recover afterwards because of its static-priviledged i-node status in the filesystem. No need to buy discs, cheap backups when reinstalling.</p>
<p>I believe recycle bin deserves a topic and some explanations somewhere.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-559933">
				<div id="div-comment-559933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://nevali.net' rel='external nofollow' class='url'>Mo</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-559933">
			October 16, 2007 at 3:55 pm</a>		</div>

		<p>I think the question being answered isn&#8217;t necessarily the one that was supposed to be asked (it&#8217;s somewhat ambiguous).</p>
<p>Probably a better way of putting it might be “given that shortcuts are very much like symlinks with metadata, did nobody at Microsoft think that conceptually this was very powerful and would best serve the development community by being wrapped up into a very straightforward Win32 API instead of forcing people to jump through the shell&#8217;s COM interface hoops to manipulate them?”.</p>
<p>In short, you do it like UNIX, but with additional metadata capabilities and emulated with .lnk files on filesystems that don&#8217;t support them. You bump the CIFS/SMB version number and pay attention to the version information resources in executables (which things do anyway). Older clients (local or remote) see the links as ordinary files; newer clients see them as a new type of entity (siblings to files, directories, and so forth).</p>
<p>It&#8217;s worth noting that Cygwin creates its symlinks *as* .lnk files (and presents shortcuts as symlinks, handily), and that *most* UNIX applications don&#8217;t need to be remotely “symlink-aware”. There are some additional APIs for performing operations on the links themselves instead of the targets (lchown, lchmod, lstat), and rename() and unlink() always operate on the links, but any attempts to *traverse* the links behave as though you&#8217;d attempted to access the target (and you get the usual errors if it doesn&#8217;t exist/can&#8217;t be read/is the wrong type of object).</p>
<p>It&#8217;s difficult to believe that in the time between Windows 95 and the present, nobody thought that treating the shortcut files, junction points, hard links and so forth as a filesystem-dependent implementation detail of “links with possible metadata” would be a good idea, and if they did that they hadn&#8217;t figured out how to make it work long before now. It&#8217;s not something people haven&#8217;t been talking about since August 1995, either.</p>
<p>As an aside (because several commenters brought it up): UNIX lets you “delete” a file that&#8217;s in use because it has an internal link count as well as an on-disk link count. The file isn&#8217;t actually removed from disk until both hit zero. When a file is opened, the internal count is bumped, and when it&#8217;s closed it&#8217;s decremented again. Even though sections of libraries and such aren&#8217;t necessarily mapped or loaded when an executable is first launched, they will be opened, and you&#8217;ll note that any packaging tools will always either rename or unlink files before replacing them (rather than just opening the files for write access, which would be disasterous). Basically, on UNIX, save for I/O errors and exceptional circumstances “if you have a valid file handle, the file exists, even if you can never open it again [you can duplicate the handle and pass it to child and—on some systems, via local sockets—other processes].</p>
<p>The fact that Windows hasn&#8217;t (I don&#8217;t recall if Vista does) worked this way for as long as it&#8217;s existed is a bone of contention for a great many users and developers alike, and the “but things might get corrupted” argument only applies if either your loader or your packaging tools are really _really_ stupid. Given that the loader is part of Windows, and that most packaging tools—even on Windows—aren&#8217;t remotely that stupid, the biggest barrier seems to be the semantics of NTOS and the filesystem layer/drivers itself. I don&#8217;t know if there&#8217;s some major complicating factor here that I&#8217;m missing—or even if it&#8217;s already been quietly resolved—but part of the reason it&#8217;s so frustrating is because it SEEMS like another of those issues that could have been resolved a very long time ago with a little thought and research into the competition. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560143">
				<div id="div-comment-560143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MadQ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560143">
			October 17, 2007 at 12:29 am</a>		</div>

		<p>Man, I miss assignments in AmigaOS. Just assign foo: to any location you want, then use foo: to access said location.</p>
<p>I guess you can kinda fake it with environment variables, but %foo% is a lot harder to type.</p>
<p>On the other hand, I really don&#8217;t miss the .info files all over the place.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560173">
				<div id="div-comment-560173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560173">
			October 17, 2007 at 2:40 am</a>		</div>

		<p>I think it&#8217;s funny that people complain about how Explorer mis-handles junctions, when just as many seem to complain that shortcuts should be handled transparently by the OS. What most don&#8217;t realize is that once you have transparent directory links, all of your old file management programs break because they don&#8217;t know that there can be cycles in the graph. In fact, any program that performs recursion on the filesystem (dir/s, findstr/s, xcopy/s, and so on) can end up handling directory links wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560193">
				<div id="div-comment-560193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560193">
			October 17, 2007 at 7:48 am</a>		</div>

		<p>&quot;What most don&#8217;t realize is that once you have transparent directory links, all of your old file management programs break because they don&#8217;t know that there can be cycles in the graph. In fact, any program that performs recursion on the filesystem (dir/s, findstr/s, xcopy/s, and so on) can end up handling directory links wrong.&quot;</p>
<p>Then you fix those programs. Unixy systems get along mostly fine. ;-)</p>
<p>(This &quot;too ideal for reality&quot; message brought to you by the We Ignore Third Party Applications, Inc.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560343">
				<div id="div-comment-560343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560343">
			October 17, 2007 at 12:53 pm</a>		</div>

		<p>[What should a downlevel client see when they encounter a FAT symlink? (FAT LFNs get a short file name for backward compability. But how should a FAT symlink appear to, say, your camera?) And even if you solve this, there are still all the other reasons that are still outstanding. (How do you email somebody a symlink?) -Raymond]</p>
<p>The same way pre-Vista Windows see symlinks (a zero-byte file that gives an error when you try to access it)? Or maybe not see them at all?</p>
<p>As for e-mailing a symlink, you don&#8217;t &#8211; you e-mail a file it&#8217;s pointing to (if you try to resolve a symlink from a system that doesn&#8217;t support symlinks, that&#8217;s dealt elsewhere; note that I&#8217;ve received shortcuts in e-mails and on floppy discs several times &#8211; what would be the difference with symlinks?).</p>
<div class="post">[<i>Oh, I thought you were arguing that shortcuts should be symlinks. If a downlevel program couldn&#8217;t see a symlink, a directory that contained a symlink would be undeletable. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560513">
				<div id="div-comment-560513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560513">
			October 17, 2007 at 4:46 pm</a>		</div>

		<p>Evan: I can email somebody a link to a printer or a directory on a file share. I can&#8217;t even create a symlink to a printer, and I can&#8217;t very well email somebody a whole directory on a fileserver.</p>
<p>As for emailing shortcuts to files, I hate when people send me huge attachments, particularly to files that are already available on the network. I much prefer that somebody send me a link to the file (or a shortcut if the file&#8217;s on a share rather than a web server).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560543">
				<div id="div-comment-560543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://nevali.net' rel='external nofollow' class='url'>Mo</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560543">
			October 17, 2007 at 9:23 pm</a>		</div>

		<p>Evan: Well, no. Not if you rely on version information in the apps. Old apps written to the old APIs with no knowledge of symlinks see files. New apps written to the new APIs see links. If you didn&#8217;t want to rely on version information, you change the API symbols (though that&#8217;s more fragile, as just recompiling against the new SDKs would imply—wrongly—that your app understood symlinks).</p>
<p>It&#8217;s really not as hard as some people are making out, though some of the comments I&#8217;ve read have convinced me that perhaps yes, nobody at Microsoft DID think it would be a good idea to do it.</p>
<p>If your e-mail program really really needs to be able to let you send links+metadata to other people (because, say, a textual representation [e.g., a URL or UNC path] isn&#8217;t sufficiently rich), then you&#8217;ve hit the rare case of where it might being beneficial to not be “symlink aware” (i.e., the e-mail program just sees a .lnk file which it attaches). It would probably be more sensible, though, for the e-mail client to be link-aware, but just give you the option of attaching the target or creating a hyperlink/inserting a URL/UNC path. The idea of e-mailling an attachment which is a shortcut file is a horrible one in the first place, and far from being a feature is more just a by-product of API situation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560783">
				<div id="div-comment-560783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560783">
			October 18, 2007 at 2:03 pm</a>		</div>

		<p>I would just like to know why certain older setups took ages to create shortcuts in Start Menu (you could watch them appearing slowly one by one in an Explorer window they popped open).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560793">
				<div id="div-comment-560793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-560793">
			October 18, 2007 at 2:05 pm</a>		</div>

		<p>That and why we can&#8217;t have shortcuts to the particular position in video and sound files.</p>
<div class="post">[<i>You seem to have difficulty with the concept of the suggestion box. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561483">
				<div id="div-comment-561483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-561483">
			October 20, 2007 at 8:09 pm</a>		</div>

		<p>Igor: because they used the Program Manager DDE API. DDE is based on message broadcasts to all top-level windows to locate the server of a conversation, and if a top-level window is owned by a thread that sleeps or spins without pumping messages, you&#8217;ll get slowdowns. Raymond already blogged about this, I think</p>
<p>Shortcuts to parts of files: OLE supports that in principle (&lt;file path&gt;!&lt;part name&gt; syntax), but I doubt the shell does, and if it does, I doubt any program (save for Excel) bothers to define document parts</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561493">
				<div id="div-comment-561493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071015-00/?p=24783#comment-561493">
			October 20, 2007 at 8:15 pm</a>		</div>

		<p>640k: the name &quot;symbolic link&quot; was already taken, because Windows always supported symbolic links. Just not on filesystems. The I/O manager has always been a poor fit for an object manager subsystem</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>