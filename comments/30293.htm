<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (48)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-404703">
				<div id="div-comment-404703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anthony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404703">
			July 31, 2006 at 10:13 am</a>		</div>

		<p>Being an old timer, I&#8217;m very comfortable with windows messages and the like, but very uncomfortable with the mapping between them and events under .NET</p>
<p>While I think I understand the goals, I feel uneasy without seeing the source code (I know I can see some of what&#8217;s going on with the ILDASM, but that seems like hard work). &nbsp;Especially as, if it&#8217;s ever to be notionally platform independent using Control.WndProc to do something is probably not the right thing to do.</p>
<p>I hope you&#8217;ll show us how to &quot;stop worrying and learn to love the bomb&quot; this week.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404713">
				<div id="div-comment-404713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lauren Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404713">
			July 31, 2006 at 10:27 am</a>		</div>

		<p>While I sympathize with Anthony Wieser&#8217;s feeling that something is missing when you hand over fine-grained control to the framework, the benefits of having someone else take the reins so that you can work on the important stuff is very tempting. Hence automatic transmissions, scripting languages, and the VS resource editor.</p>
<p>If the performance gap is negligble, the only drawback is having to learn the new system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404723">
				<div id="div-comment-404723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404723">
			July 31, 2006 at 10:39 am</a>		</div>

		<p>As an &quot;old skool&quot; programmer, I am not put out in the slightest by writing custom allocators or other data structures &#8212; I find it quite enjoyable, in fact. &nbsp;I often shun the STL due to its slowness and it&#8217;s over-reliance on memory allocation to solve everything. &nbsp;I will often use Win32 APIs instead of CRT calls in cases where I can get better performance with a custom solution versus the &quot;general case&quot; implemented in the CRT.</p>
<p>However, I must say that I am most impressed with the CLR version. &nbsp;The fact that such good performance can come from a simple translation of the original &quot;slow&quot; version of the application is, quite simply, amazing.</p>
<p>A couple of things I would like to know, though: &nbsp;what is the memory footprint of both versions, and what was the application startup time? &nbsp;One of my pet-peeves about Java (another managed and GC&#8217;d environment mentioned only because I have no .NET experience) is it&#8217;s huge start-up costs in both class loading and initial memory size. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404733">
				<div id="div-comment-404733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.brentnewbury.com/' rel='external nofollow' class='url'>Brent Newbury</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404733">
			July 31, 2006 at 10:46 am</a>		</div>

		<p>Wow, what a week this is gona be! I&#8217;m looking forward to it :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404743">
				<div id="div-comment-404743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lionell Griffith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404743">
			July 31, 2006 at 10:47 am</a>		</div>

		<p>I have refused to use MFC because of its countless bugs and even worse documentation. &nbsp;What it does for me can be replaced by two pages of reusable source code &#8211; half of which are comments. &nbsp;</p>
<p>.Net appears to be built on top of MFC. &nbsp;It contains all the bugs of MFC and more. &nbsp;What&#8217;s worse, its implemented by an un-testable 30 meg runtime of uncertain quality (already in its second version with more to come).</p>
<p>If all you need to do is create nonfunctional kluge software, then I suppose its OK. However, I need to create tight, fast, and reliable code that provides lasting value for users. </p>
<p>Why would I want to use .NET? &nbsp; </p>
<p>PS: &nbsp;I have been developing Windows software since 1990.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404753">
				<div id="div-comment-404753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">davidacoder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404753">
			July 31, 2006 at 10:55 am</a>		</div>

		<p>.Net is not build on top of MFC. No relation between the two at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404783">
				<div id="div-comment-404783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Ritchie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404783">
			July 31, 2006 at 12:06 pm</a>		</div>

		<p>Part of .NET is PInvoke. &nbsp;You&#8217;re still doing the .NET community a service by providing clarity to win32 constructs that can still be used in .NET applications.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404813">
				<div id="div-comment-404813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404813">
			July 31, 2006 at 12:30 pm</a>		</div>

		<p>Anthony, if you haven&#8217;t seen reflector, you probably want to give it a try:</p>
<p><a rel="nofollow" target="_new" href="http://www.aisto.com/roeder/dotnet/" rel="nofollow">http://www.aisto.com/roeder/dotnet/</a></p>
<p>Also download the FileDisassembler plugin:</p>
<p><a rel="nofollow" target="_new" href="http://www.denisbauer.com/NETTools/FileDisassembler.aspx" rel="nofollow">http://www.denisbauer.com/NETTools/FileDisassembler.aspx</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404823">
				<div id="div-comment-404823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Scott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404823">
			July 31, 2006 at 12:41 pm</a>		</div>

		<p>I&#8217;ll second that, reflector is utterly invaluable if you want to see what the framework is doing. &nbsp;It&#8217;s even easy to use.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404853">
				<div id="div-comment-404853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404853">
			July 31, 2006 at 12:52 pm</a>		</div>

		<p>In response to Tom<br />
<br />[quote]<br />
<br />As an &quot;old skool&quot; programmer, I am not put out in the slightest by writing custom allocators or other data structures &#8212; I find it quite enjoyable, in fact. &nbsp;<br />
<br />[/quote]<br />
<br />Ok you might find a few bit&#8217;s annoyingly out of your control &#8211; but a fringe benefit of managed code is lighting fast memory allocation so long as:<br />
<br />1)you are not bound by zeroing the memory<br />
<br />2)you don&#8217;t allocate memory very often (thus the amortized cost of GC tends to zero&#8230;</p>
<p>If 1) is an issue drop to CLI (or managed C++ if you&#8217;re &#8216;Old School&#8217; ;)</p>
<p>[quote]<br />
<br />A couple of things I would like to know, though: &nbsp;what is the memory footprint of both versions,<br />
<br />[/quote]<br />
<br />Depends how you measure it :)<br />
<br />Considerable savings exist by having more than one app running with .net at once &#8211; especially in .net 2.0 where lot&#8217;s of effort was expended to reduce the number of private pages. This may be no use to you if you will only ever have on app running on a machine but I notice the benefit.<br />
<br />Verses Java there is a notable benefit to not referencing dlls you don&#8217;t need (possible in java by not referencing some of the jars but these are much more coarsely grained than in .Net). Also Java cannot (natively) share the jitted code in the api. Ngenning (plus storing in the GAC does allow for this &#8211; though at a considerable deployment hassle cost if you are changing your code often)</p>
<p>[quote]<br />
<br />and what was the application startup time?<br />
<br />[/quote]<br />
<br />Much improved &#8211; there may be finagling going on behind my back in windows to make this faster than java can do it but the ngenning can make a lot of difference (to the extent of not needing to load the jit code at all if the whole thing has been ngened)<br />
<br />Even without ngen I notice a significant improvement over java (I haven&#8217;t tried 1.5 in so long I don&#8217;t know if sun improved it significantly)</p>
<p>P.S &#8211; I have no idea how to verbify ngening (as should be obvious). I apologise the the butchery of the english language this post perpetrates</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404883">
				<div id="div-comment-404883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gsr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404883">
			July 31, 2006 at 1:14 pm</a>		</div>

		<p>Raymond,<br />
<br />Can you please change your blog title for this week to be &quot;Not actually a WinFX blog&quot; :)</p>
<p>Recently i saw a job posting from a company say that &quot;candidates &nbsp;should dislike .NET&quot; :) </p>
<p>-Gsr</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404893">
				<div id="div-comment-404893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404893">
			July 31, 2006 at 1:30 pm</a>		</div>

		<p>For the lazy and/or apparently helpless, the memory usage of the managed vs unmanaged app is here:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/ricom/archive/2005/05/20/420614.aspx" rel="nofollow">http://blogs.msdn.com/ricom/archive/2005/05/20/420614.aspx</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404903">
				<div id="div-comment-404903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lyle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404903">
			July 31, 2006 at 2:05 pm</a>		</div>

		<p>&quot;(I&#8217;m told there&#8217;s one company that has decided against using managed code because &quot;If Raymond doesn&#8217;t even want to mention the .NET Framework then why should we bother to look at it?&quot; What a strange argument. I don&#8217;t mention IPsec; does that mean you shouldn&#8217;t use it either?)&quot;</p>
<p>Yes! We can finally deploy IPsec now that Raymond has mentioned it!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404913">
				<div id="div-comment-404913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Swaim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404913">
			July 31, 2006 at 2:12 pm</a>		</div>

		<p>(Comments on comments)<br />
<br />Application startup time still seems to be slow with .net 2.0, and .net applications seem to be piggy w/ respect to memory. I believe that part of that is that the framework won&#8217;t try to reclaim memory very often if there&#8217;s no memory pressure, they can &quot;bloat.&quot; If you&#8217;re running multiple .net apps, then they can share the framework as shared dlls. (And 2.0&#8217;s much better about that.)</p>
<p>For native code, there&#8217;s always Delphi. From what I&#8217;ve heard, D2006 is pretty good. Plus with the spinoff, they&#8217;re going to be focusing on developer tools again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404933">
				<div id="div-comment-404933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cory</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404933">
			July 31, 2006 at 3:21 pm</a>		</div>

		<p>I just have to say that I think there are a lot of people who love .NET &#8230; AND who love your blog.</p>
<p>I am one of them.</p>
<p>What is the definition of old-skool? Is it someone who has been developing for a certain amount of time? Or is it someone who is likes a particular technology over newer stuff out there?</p>
<p>I&#8217;m probably old school if it&#8217;s the first.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404943">
				<div id="div-comment-404943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404943">
			July 31, 2006 at 3:28 pm</a>		</div>

		<blockquote><p>
  System.Net.Mail (SMTP AUTH was a requirement)</p>
<p>You might want to check out <a rel="nofollow" target="_new" href="http://support.microsoft.com/default.aspx?scid=kb;en-us;555287" rel="nofollow">http://support.microsoft.com/default.aspx?scid=kb;en-us;555287</a> &#8212; that shows which CDOSYS fields you can set to which values to enable various SMTP AUTH methods with System.Web.Mail. &nbsp;I&#8217;ve set smtpauthenticate to cdoNTLM (=2) in a .Net 1.1 program we use here, to authenticate against Exchange using the currently-logged-on user&#8217;s credentials, and it works fine. &nbsp;(Of course then you don&#8217;t set the sendusername or sendpassword fields.)</p>
<p>Not that this will convince you to abandon .Net 2.0 (better UI and BackgroundWorker sound like a good enough reason to use 2.0 in themselves), but it is possible in 1.1.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404953">
				<div id="div-comment-404953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">macbirdie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404953">
			July 31, 2006 at 4:01 pm</a>		</div>

		<p>Wow, some .NET sweetness on a not exacly a .NET blog. New scratch program coming? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404963">
				<div id="div-comment-404963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404963">
			July 31, 2006 at 5:24 pm</a>		</div>

		<p>My definition of &quot;old-skool&quot; is someone who has been programming since the mid eighties. &nbsp;That style of programming typically involved C (or Pascal if you were into that sort of thing) and Assembly. &nbsp;There was no OOP (unless you were using Smalltalk, but you couldn&#8217;t find that on most low-end PCs available then), so you were stuck with structured programming. &nbsp;Libraries were hard to come by, so you had to write everything. &nbsp;Memory was tight, so you had to write small, or use overlays or EMM. &nbsp;These modern day &quot;Operating Systems&quot; make it too easy. &nbsp;In my day, you memorized the algorithtm to compute square roots and LIKED IT!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404973">
				<div id="div-comment-404973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.steve.org.uk/' rel='external nofollow' class='url'>Steve Kemp</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404973">
			July 31, 2006 at 6:01 pm</a>		</div>

		<p>Personally I&#8217;m an old-school programmer in the sense that I used to write bits of code using the Win32 API a good few years ago and only flirted with the MFC towards the end of the time I developed under Windows.</p>
<p>Nowadays I&#8217;m a sysadmin rather than a developer, and I&#8217;ve switched to Linux based systems. &nbsp;(After a brief segue into Solaris-land).</p>
<p>Perhaps it isn&#8217;t suprising that I&#8217;m not so interested in the &quot;newer&quot; technology given that I don&#8217;t have the time or the current grasp of the Windows world to use it.</p>
<p>But I do read this blog (and a couple of other MSDN people like Jenson Harris/Larry Osterman/Eric Lippert) precisely because Raymond explains the historical things so wonderfully well.</p>
<p>Several of the &quot;bug&quot; discussions (or &quot;don&#8217;t do it like this&quot;) are things I can recall fighting in my past life. &nbsp;I&#8217;m also incredibly impressed at the efforts Microsoft makes to allow backwards compatability and find the evolution of different systems, such as the recently covered DLL pieces/linker, very informative.</p>
<p>If we&#8217;re honest 99% of developers won&#8217;t care how linkers used to work in the 16 bit world, but for me it is both educational and a little bit nostalgic.</p>
<p>Steve</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404763">
				<div id="div-comment-404763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404763">
			July 31, 2006 at 11:17 am</a>		</div>

		<p>For the past five years, Microsoft has been working hard to ensure .NET performs well and offers all the functionality of Win32. It would be possible to improve the performance and environment for unmanaged Win32/C++, but that&#8217;s not in Microsoft&#8217;s plans. Unfortunately, all the competition is pretty much dead now, so Win32 development is in stasis&#8211;which has both good and bad implications. </p>
<p>I can ship a Win32 product that weighs only a megabyte or two but does wonderful things. It can leverage platform components like WebBrowser and allow customization through script engines. I can find plenty of examples all over the net. Sure, those examples and APIs have bugs, but both have been around long enough that the problems are *documented*. </p>
<p>If I tried the same thing with .NET, the first decision is which version of the runtime to use, the widely deployed 1.1 or the emerging 2.0? If I head for the bleeding edge, I can be sure that many if not most customers will not have the latest .NET runtime, so my duty will be to haul 30MB of Microsoft bits over to their system. Then I will deal with the inevitable bugs that spring up with fresh Microsoft code that is just seeing the light of reality. </p>
<p>I&#8217;m staying old-school for now. </p>
<div CLASS=post>[<i>In that case, you should probably unsubscribe for this week. See you next Monday! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-404993">
				<div id="div-comment-404993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404993">
			July 31, 2006 at 6:39 pm</a>		</div>

		<p>I guess I&#8217;m old school. &nbsp;Programming professionally since 1985. &nbsp;</p>
<p>I have used WinAPI, MFC, ATL, WTL, OWL, Borland&#8217;s C++ of builder, straight C, Forth, C++ with and without STL.</p>
<p>I am finding .NET to be a very nice framework to write software. &nbsp;I just wish 2.0 was around two years ago when we decided to create our current software in MFC.</p>
<p>I just use what is best for the company that pays me. &nbsp;I don&#8217;t care what it is as long as it gets the job done well.</p>
<p>BTW, I don&#8217;t have problems with bugs in MFC. &nbsp;Over the years, the people who seem to have problems with MFC (and any other framework) are those who try to bend (and usually break) a framework into doing things your way instead of its way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404843">
				<div id="div-comment-404843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://geekswithblogs.net/jbrayton/' rel='external nofollow' class='url'>Jeremy Brayton</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-404843">
			July 31, 2006 at 12:52 pm</a>		</div>

		<p>*A couple of things I would like to know, though: &nbsp;what is the memory footprint of both versions, and what was the application startup time?*</p>
<p>I have a basic app which doesn&#8217;t do much in .NET 2.0 with a memory footprint hovering at about 26 megs, running for about 6 days straight now. It&#8217;s a GUI app that uses a timer to poll a database and send email notifications. Yes, I violate a good bit of the Raymond rules of conduct but it serves it&#8217;s purpose at this point.</p>
<p>My understanding is that the first time .NET code is ran the CLR is loaded and stays resident for X so that after the first application is loaded, subsequent applications take no time at all to fire up. I&#8217;m no expert and this is only what I can remember in my little noggin. I may have it totally wrong in that it just prefetches and appears to be quicker. The CLR is loaded once and shared among all .NET applications running on that platform too, so no duplication in the memory footprint there. </p>
<p>My reasoning for picking 2.0 was pretty simple. Better UI controls, BackgroundWorker, System.Net.Mail (SMTP AUTH was a requirement), and the fact that I could literally get away with it. 30 meg installer? The company I work for has a T1 so 30 megs is chump change. 2.0 HAS been tested, by those companies who are early adopters. VS 2005 had more community feedback than any other MS product I know of (though I believe it was the first that exposed it&#8217;s bug database to the world) so it was clear someone out there other than myself was dogfooding this stuff EARLY. Hell, VS 2005 was largely built with .NET code so they had to make sure the foundation was pretty solid to begin with (though I&#8217;m sure people will argue &quot;That&#8217;s why 2005 has so many issues&quot;).</p>
<p>There are some things managed code will not be able to do well now, or may be able to do at all. There will always be late adopters and people holding onto Win32 for dear life. Microsoft&#8217;s stance on backcompat will most likely make sure those people have a job for at least another decade if not more. Most of the people not even willing to get their hands dirty with .NET are doing so for religious reasons. You don&#8217;t have to use it in production but why not get your hands dirty with something simple that only appeals to you? You can stay current by updating your code and just witnessing how it fairs instead of just saying (insert new MS technology here) isn&#8217;t quite what I&#8217;m looking for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405003">
				<div id="div-comment-405003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405003">
			July 31, 2006 at 8:50 pm</a>		</div>

		<p>Monday, July 31, 2006 5:24 PM by Tom<br />
<br />&gt; My definition of &quot;old-skool&quot; is someone who<br />
<br />&gt; has been programming since the mid eighties.</p>
<p>LOL. &nbsp;That must be the new old thing.</p>
<p>&gt; That style of programming typically involved<br />
<br />&gt; C (or Pascal if you were into that sort of<br />
<br />&gt; thing) and Assembly.</p>
<p>C and Pascal weren&#8217;t invented yet at the time of &quot;old-skool&quot; programming. &nbsp;Lisp was, but it depended on lots of impractical expensive operations like garbage collecting so no one could really use it. &nbsp;The style of programming was either Cobol (if you wanted a good salary) or a combination of Fortran and Assembly.</p>
<p>Then IBM invented PL/I. &nbsp;They polished up PL/I very nicely both technically and in documentation, so everyone was forced to move to PL/I and had to forget about Fortran and Cobol.</p>
<p>Building on the success of IBM&#8217;s experience, Microsoft polished up C# so everyone was forced to forget about VC++ and VB.</p>
<p>Lots of end users won&#8217;t have to download the .Net framework because it&#8217;s built into Smartphones and Pocket PCs. &nbsp;So theoretically some of us could use .Net without worrying about the impact on customers. &nbsp;But VC++2005 refuses to target it. &nbsp;So some of us either really do have to choose between moving to C# or continuing to study middle-aged-skool Win32 style programming.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405023">
				<div id="div-comment-405023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405023">
			July 31, 2006 at 9:51 pm</a>		</div>

		<p>@ Norman Diamond: &nbsp;Not invented yet? &nbsp;They&#8217;ve been around since the 70&#8217;s! &nbsp;Unless you&#8217;re thinking Ancient School which most certainly was FORTRAN and Assembly (probably some straight machine code, too &#8212; for the hard core in the bunch). &nbsp;I have actually had the mispleasure of working on some FORTRAN from the 50&#8217;s. &nbsp;Granted, it was a text-file port of the original Hollerith punch cards, but it is just as spaghetti today as it was back then. &nbsp;Those were the days&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405033">
				<div id="div-comment-405033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lionell Griffith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405033">
			July 31, 2006 at 10:02 pm</a>		</div>

		<p>&quot;Over the years, the people who seem to have problems with MFC (and any other framework) are those who try to bend (and usually break) a framework into doing things your way instead of its way.&quot;</p>
<p>I don&#8217;t know about you but for me the problem to be solved determines the solution and not the other way around. &nbsp;</p>
<p>MFC says all problems are documents to be processed.</p>
<p>.NET says all problems are documents to be processed on the internet.</p>
<p>Highly man-machine and machine-machine interactive &nbsp;engineering, scientific, real time, process control, image processing and the like appications are NOT document processors. </p>
<p>For the few problems I have that are documents, I can use Word, Excel, Power Point or other off the shelf software. &nbsp;</p>
<p>Again, why would I want to use .NET if it doesn&#8217;t match the problem set I must solve?</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-405043">
				<div id="div-comment-405043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405043">
			July 31, 2006 at 10:12 pm</a>		</div>

		<blockquote><p>
  MFC says all problems are documents to be processed.<br />
  <br />&gt; .NET says all problems are documents to be processed on the internet. </p>
<p>While that may be true of MFC, .NET is more than just WinForms (and WinForms is more than just &quot;MFC.NET&quot; &#8211; I&#8217;d say that WinForms maps more directly to the native controls than MFC does&#8230; sometimes painfully so).
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405053">
				<div id="div-comment-405053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405053">
			August 1, 2006 at 2:58 am</a>		</div>

		<p>&#8220;lighting fast memory allocation so long as:<br />
<br />2)you don&#8217;t allocate memory very often&#8221;</p>
<p>Woot. &nbsp;;)</p>
<div CLASS=post>[<i>It&#8217;s actually the other way around. GC is faster the more memory you allocate that has a short lifetime. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405063">
				<div id="div-comment-405063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Nahr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405063">
			August 1, 2006 at 3:26 am</a>		</div>

		<p>&quot;.NET says all problems are documents to be processed on the internet.&quot;</p>
<p>This is so laughably wrong. Your idea that .NET is somehow the same as MFC has no basis whatsoever in reality. Do you think you could stop making a fool of yourself in public forums?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405073">
				<div id="div-comment-405073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nksingh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405073">
			August 1, 2006 at 3:46 am</a>		</div>

		<p>Chris Nahr:<br />
<br />Ouch! &nbsp;I&#8217;m sure you showed that guy!</p>
<p>Geez, chill out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405083">
				<div id="div-comment-405083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405083">
			August 1, 2006 at 4:55 am</a>		</div>

		<p>I consider myself a newbie on the programming scene. I have been programming c &amp; c++ for merely 10 odd eyars now.</p>
<p>During the time ive been ignoring, or actively avoiding c# and .net, its gone from 1.0 to 1.1 to 2.0 &#8211; each revision being incompatible with the last.</p>
<p>Perhaps I will switch when it shows some signs of stability.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405093">
				<div id="div-comment-405093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">XRay</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405093">
			August 1, 2006 at 5:18 am</a>		</div>

		<blockquote><p>
  &gt; During the time ive been ignoring, or actively avoiding c# and .net, its gone from 1.0 to 1.1 to 2.0 &#8211; each revision being incompatible with the last. </p>
<p>&gt;&gt; .NET says all problems are documents to be processed on the internet.&quot; </p>
<p>It&#8217;s funny to see how many urban legends spread over .NET .. </p>
<p>All deprecated APIs are still supported by 2.0 and work ok. And above all, they will not require any major rework to reimplement with the newer versions.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405103">
				<div id="div-comment-405103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.snakebomb.com/' rel='external nofollow' class='url'>Iain</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405103">
			August 1, 2006 at 6:22 am</a>		</div>

		<p>Old-School? Phaw! &nbsp;Real Programmers use FORTRAN! &nbsp;Actually, Real Programmers write in machine code. &nbsp; &nbsp;See: The Story of Mel:<br />
<br /><a rel="nofollow" target="_new" href="http://www.pbm.com/~lindahl/mel.html" rel="nofollow">http://www.pbm.com/~lindahl/mel.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405113">
				<div id="div-comment-405113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.lorenzostoakes.co.uk' rel='external nofollow' class='url'>Lorenzo</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405113">
			August 1, 2006 at 7:41 am</a>		</div>

		<p>I have read through Raymond&#8217;s frankly fantastic blog for a few months now, and have always wondered how he feels about .NET being touted as win32&#8217;s successor.</p>
<p>Raymond, do you feel win32 is obsoleted now, or is there still a place for it in Windows Development (aside from porting code previously written for the win32 api)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405143">
				<div id="div-comment-405143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nate</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405143">
			August 1, 2006 at 9:36 am</a>		</div>

		<blockquote><p>
  .NET says all problems are documents to be processed on the internet. </p>
<p>Can you elaborate on this? &nbsp;.NET has none of the document-centric bloat that is in MFC. &nbsp;Sure, it would be easy to add, but when you make a laughable statement like this, at least try to back it up.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405173">
				<div id="div-comment-405173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.zabkat.com' rel='external nofollow' class='url'>nikos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405173">
			August 1, 2006 at 10:35 am</a>		</div>

		<p>i guess it&#8217;s a natural reaction of old dogs to revolt against anything new that overrides all one has spent so much time and effort to learn :)</p>
<p>but as far as windows programming goes, one will always need a knowledge and understanding of low down procedures, if only to fix/workaround the plethora of bugs and features present in the API, windows controls etc.</p>
<p>only today i discovered a fix for that age old scrolling mess of listview control with gridlines under XP, which involves overriding scrolling messages. Can you do such patches natively in .NET? i wouldn&#8217;t have thought so &amp; i&#8217;m sticking with C++/WTL for as long as i can :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405183">
				<div id="div-comment-405183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405183">
			August 1, 2006 at 10:43 am</a>		</div>

		<p>nikos &#8212; yes, I believe you can. &nbsp;You can make a class that inherits any existing control&#8217;s class (e.g. ListBox, or Form), then override the protected WndProc member function. &nbsp;(As long as you use WinForms, that is &#8212; you can&#8217;t override WndProc in the Compact Framework, at least not in v1.1.) &nbsp;Make sure you call the base class WndProc as needed, though; otherwise everything else breaks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405223">
				<div id="div-comment-405223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jstanley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405223">
			August 1, 2006 at 10:56 am</a>		</div>

		<p>A few years ago, my company was looking at using &quot;Managed C++&quot; to write the user interface for a product. &nbsp;This UI would have to be compiled against thousands of lines of portable C++ backend code (which we compile regularly using VS71 and gcc). &nbsp;After whipping together a barebone UI, I was puzzled by odd behavior that made me question my sanity. &nbsp;A C++ function returned false; the UI acted as if it had returned true. &nbsp;Eventually I examined the assembly output, and found this was a bug in the compiler&#8211;C++ thinks a bool is one byte, and sets the return value in AL, while .NET thinks a bool is 4 bytes, and examines the entire contents of EAX. &nbsp;It is beyond me how something as trivial as bool marshaling could have been broken in a released product&#8211;and I was even more amazed to find that the bug had been known about for TWO YEARS and not fixed. &nbsp;My conclusion was, the .NET framework is a toy, not ready for prime time. &nbsp;Have things improved any in the past two years?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405233">
				<div id="div-comment-405233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.sheepguardingllama.com' rel='external nofollow' class='url'>Scott Alan Miller</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405233">
			August 1, 2006 at 10:56 am</a>		</div>

		<p>That was why I didn&#8217;t use IPSec, so it&#8217;s okay to use then? &nbsp;;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405253">
				<div id="div-comment-405253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel Salters</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405253">
			August 1, 2006 at 11:11 am</a>		</div>

		<p>GC is faster the more memory you allocate that has a short lifetime. -Raymond </p>
<p>Popular misconception, but you can wrap a deterministic memory allocator interface (malloc/free) around a GC one. malloc just gets the memory. free adds it to the list that the GC considers for collection. Because that set now doesn&#8217;t require trawling, the GC doesn&#8217;t have to work as hard. It&#8217;s also more likely to be in cache. The GC can still clean up the free()d memory in its own background thread. </p>
<p>True, this is not the MSVC CRT implementation of malloc/free, so GC (in some cases) may be faster than that, but it will be slower in others. I guess the current CRT is tuned for smaller and less allocations. If the GC allocator turns out to be better in all cases, its algorithm is also available to GP allocators (GP=Garbage Prevention)</p>
<div CLASS=post>[<i>That was obviously a generalization on my part. Of course you can come up with scenarios where it fails to hold, but the question is whether the effort to reach that point is worth the benefit. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405293">
				<div id="div-comment-405293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://endothermal.blogspot.com' rel='external nofollow' class='url'>e.thermal</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405293">
			August 1, 2006 at 11:52 am</a>		</div>

		<blockquote><p>
  &gt; .NET says all problems are documents to be processed on the internet.&quot; </p>
<p>I thought I heard it all, until now, that has to be the worst conceptualization of a framework I have ever seen. &nbsp;A large part of my job is architecting/designing solutions to business problems with technology. &nbsp;A large part of that is dealing with misconceptions like &quot;My bank uses it, so it must be good?&quot;. &nbsp;In my role I have to be very non-theistic in my solutions and since .net has come around I have had a very hard time finding a reason not to use it. &nbsp;There are some very good technical reasons for not using .net and using c++ native or some other solution like java, but those situations are so rare in the businesses that I have worked. &nbsp;
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405343">
				<div id="div-comment-405343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">That one Ian guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405343">
			August 1, 2006 at 12:30 pm</a>		</div>

		<p>Oh no you didn&#8217;t!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405413">
				<div id="div-comment-405413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DriverDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405413">
			August 1, 2006 at 5:46 pm</a>		</div>

		<p>&quot;What a strange argument. I don&#8217;t mention IPsec; does that mean you shouldn&#8217;t use it either?&quot;</p>
<p>Actually yes, according to my network admin friends, I shouldn&#8217;t use IPsec (there are better and easier choices, they say)</p>
<p>People will cling to the most foolish reasons to justify their beliefs. Most people I know of who disdain .NET have not actually used it. Some use MFC, so it&#8217;s not as if they&#8217;re all anti-Windows. Go figure.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405243">
				<div id="div-comment-405243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405243">
			August 1, 2006 at 11:10 am</a>		</div>

		<p>@nikos &#8211; By the time WinFX hits, well, it *looks* like enough stuff at that point is going to be written natively in .net that you will have to do a substantial portion, if not all, your hacking inside the .net framework.</p>
<p>I, personally am hoping that WinFX will be built upon a rational (but secret) C API, but I don&#8217;t hold out that much hope for that. A full ground up implementation in .NET however is a very good second best, because the current hybrid system us pooer c/c++ developers are exposed to is, well, appalling.</p>
<p>The current situation, where Com controls &#8211; based in theory on &quot;nice&quot; OO friendly interfaces, cannot hide the fact that, at the core of every interface exposing COM control, is a HWND driven WindowProc. The obsessive compulsive core of my being &#8211; which on one hand gave me the drive to be a programmer &#8211; dispairs that COM was never finished enough to totally abstract away the non-COMness of (COM)controls.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405323">
				<div id="div-comment-405323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405323">
			August 1, 2006 at 12:05 pm</a>		</div>

		<p>&quot;lighting fast memory allocation so long as:<br />
<br />2)you don&#8217;t allocate memory very often&quot;</p>
<p>Woot. &nbsp;;)</p>
<p>[It&#8217;s actually the other way around. GC is faster the more memory you allocate that has a short lifetime. -Raymond]</p>
<p>I phrased it wrong &#8211; I meant that, like any other memory allocation method with a finite pool if you avoid actually allocating memory it&#8217;s quick :). Even given that any allocation in gen 0 which doesn&#8217;t fill it is very fast (since it is basically incrementing the pointer by the amount of memory used) and, if your use of new objects is sufficiently small you can avoid even the (very) fast gen 0 collections once you hit steady state.<br />
<br />.Net make this *much* easier to achieve.<br />
<br />Obviously whether this is a useful thing to do is dependent on your app. If you are unwilling to take the occasional hit of a full GC (especially under load) when responding to something like say, market data ticks then structs and if need be use of stackalloc can make avoiding new much easier than say java where many api&#8217;s force you to trigger memory allocation as they have no other option if the available primitives don&#8217;t fit their problem domain&#8230;</p>
<p>In my experience I find the occasional log statement triggers some allocation but the gen 0 collections this causes can be soaked up easily without any measurable affect on throughput and latency in my app. I expect no more than 1 gen 2 collection in 3-4 hours of use &#8211; and this is with a steady allocation of immortal objects.</p>
<p>This is all without fancy tuning parameters to the runtime (something I was always forced to do when handling vm&#8217;s in java over 512MB)</p>
<p>I used to really like java for it&#8217;s simplicity &#8211; ever since I have had to write higher performance code I have loved c# and .net.</p>
<p>Matt </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ricom even thread-even depth-1" id="comment-405363">
				<div id="div-comment-405363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ricom' rel='external nofollow' class='url'>ricom</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405363">
			August 1, 2006 at 1:13 pm</a>		</div>

		<p>&gt;&gt;I expect no more than 1 gen 2 collection in 3-4 hours of use &#8211; and this is with a steady allocation of immortal objects. </p>
<p>I don&#8217;t know that this pattern is *typical* but it is achieveable. &nbsp;I&#8217;ve helped several fortune 50s to do just this for real-time data processing&#8230; it&#8217;s all about managing your allocation rates and making sure you have good lifetime.</p>
<p>I&#8217;ll be talking at Gamefest (<a rel="nofollow" target="_new" href="http://www.microsoftgamefest.com" rel="nofollow">http://www.microsoftgamefest.com</a>) about doing the same thing in the context of a game.</p>
<p>It&#8217;s not that hard to do, it just needs to be part of your thought process. &nbsp;And under these circumstances garbage collected memory is a sweet deal.</p>
<p>After gamefest I&#8217;ll write a blog covering the topic as well.</p>
<p> &nbsp; &nbsp;-Rico</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-405463">
				<div id="div-comment-405463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405463">
			August 1, 2006 at 9:36 pm</a>		</div>

		<p>Monday, July 31, 2006 9:51 PM by Tom<br />
<br />&gt; I have actually had the mispleasure of<br />
<br />&gt; working on some FORTRAN from the 50&#8217;s.</p>
<p>Then you KNOW why I LOLled at your assertion that 80&#8217;s programming was &quot;old-skool&quot;. &nbsp;Same goes for the 70&#8217;s.</p>
<p>At least when a card reader destroyed my file it let me know which file it was destroying. &nbsp;If it was a source file I could punch replacement cards, and if it was an object file I could recompile the source.</p>
<p>On the other hand, you have more experience than I do! &nbsp;I&#8217;ve only had to READ Fortran from the 50&#8217;s. &nbsp;The oldest I had to upgrade was from the 60&#8217;s.</p>
<p>Tuesday, August 01, 2006 10:56 AM by jstanley<br />
<br />&gt; I was even more amazed to find that the bug<br />
<br />&gt; had been known about for TWO YEARS and not<br />
<br />&gt; fixed. &nbsp;My conclusion was, the .NET framework<br />
<br />&gt; is a toy, not ready for prime time. &nbsp;Have<br />
<br />&gt; things improved any in the past two years?</p>
<p>No, the .Net framework isn&#8217;t a toy, Microsoft&#8217;s handling of bugs is a toy. &nbsp;Microsoft&#8217;s treatment of customers is not ready for prime time. &nbsp;No, things have not improved in the past fifteen years.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-405503">
				<div id="div-comment-405503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-405503">
			August 2, 2006 at 5:33 am</a>		</div>

		<p>regarding ricom&#8217;s reply &#8211; I look forward to that immensely.<br />
<br />Agreed the scenario is not typical.</p>
<p>Amusingly this kind of usage occasionally makes me pine for macros (and I *hate* reading macros in c / c++) for the common operation</p>
<p>if (Log.IsDebugEnabled)<br />
<br />{<br />
<br /> &nbsp; &nbsp;Log.Debug(/* some thing that, to be useful will inevitably build a new string*/);<br />
<br />}</p>
<p>becoming<br />
<br />LogDebugIfEnabled(/*the code*/);</p>
<p>I know this makes me a bad person.</p>
<p>Any chance of a lazy keyword</p>
<p>public void Foo(lazy string text)<br />
<br />{<br />
<br /> &nbsp; &nbsp;if (/* I don&#8217;t need to do this */)<br />
<br /> &nbsp; &nbsp;{<br />
<br /> &nbsp; &nbsp; &nbsp; &nbsp;return;<br />
<br /> &nbsp; &nbsp;}<br />
<br /> &nbsp; &nbsp;/* do something with text. */ &nbsp; &nbsp;<br />
<br />}</p>
<p>obviously you would need to use something like</p>
<p>Foo(lazy { /* expression evaluating to s */ });</p>
<p>Ensuring that the only reference was inside the method which triggered it&#8217;s evaluation.</p>
<p>Obviously all sorts of issues with executing contexts and multiple threads (not to mention the work required to pass the lazy reference itself).</p>
<p>Come to think of it this idea probably makes me a worse person than wanting macros :)</p>
<p>p.s. This post is not terribly serious<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-408103">
				<div id="div-comment-408103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael J.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060731-15/?p=30293#comment-408103">
			August 11, 2006 at 12:19 pm</a>		</div>

		<blockquote><p>
  For native code, there&#8217;s always Delphi.<br />
  <br />&gt; From what I&#8217;ve heard, D2006 is pretty good.<br />
  <br />&gt; Plus with the spinoff, they&#8217;re going to be<br />
  <br />&gt; focusing on developer tools again.</p>
<p>Delphi was and still is the best IDE + library for Win32.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>