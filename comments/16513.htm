<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (44)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-773483">
				<div id="div-comment-773483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773483">
			October 2, 2009 at 10:13 am</a>		</div>

		<p>On the other hand, when a thread stack is reserved, it gets committed in a single page increments (there is initial size committed, though). If the system is running low on memory, stack commit may fail for a thread with big stack usage (and the thread will get crashed).</p>
<div class="post">[<i>Not sure what&#39;s so &quot;on the other hand&quot; about this. The failure happens at commit, because that&#39;s when the promise is made. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773513">
				<div id="div-comment-773513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773513">
			October 2, 2009 at 11:07 am</a>		</div>

		<blockquote><p>
  But what if I turn off paging by disabling my page file?
</p></blockquote>
<p>In the net circles I travel in, there is a common misunderstanding that &quot;no page file&quot; equals &quot;turning off paging&quot;.</p>
<p>Not so, of course. (1) Stuff still gets allocated to real memory in page-sized pieces, which is the real meaning of &quot;memory paging&quot;, and (2) Pages can still be evicted from memory as long as they are backed by something other than the page file (like, for example, the .exe file the program code is running from).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773523">
				<div id="div-comment-773523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773523">
			October 2, 2009 at 11:08 am</a>		</div>

		<p>P.S. &nbsp;Kudos for saying &quot;page frame&quot;.</p>
<p>I hate the locution &quot;physical page&quot;. It is a contradiction in terms. Pages are virtual, page frames are physical.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773533">
				<div id="div-comment-773533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bahbar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773533">
			October 2, 2009 at 11:15 am</a>		</div>

		<p>I&#8217;m wondering what triggered that post. After all, you don&#8217;t care at all what physical memory you get when user-land code. Was the original question specifically for kernel-mode ?</p>
<div class=post>[<i>I forget the exact situation but it was something like &#8220;I allocated half a gigabyte of memory but Task Manager&#8217;s &#8216;Physical Memory Free&#8217; didn&#8217;t go down.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773543">
				<div id="div-comment-773543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bahbar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773543">
			October 2, 2009 at 11:17 am</a>		</div>

		<p>@dave</p>
<p>&quot;pages are virtual&quot;</p>
<p>Well, not in my book. Ahah :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773553">
				<div id="div-comment-773553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.timestreamtech.com/' rel='external nofollow' class='url'>Michael Dwyer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773553">
			October 2, 2009 at 11:39 am</a>		</div>

		<p>Does Windows allow you to overcommit memory?</p>
<p>Under Linux, you can ask for more memory than exists in both physical and swap memory. &nbsp;The OS will happily commit to giving it to you, even though it can&#8217;t possibly service that request. &nbsp;It isn&#8217;t till you actually try to write to that memory that the manager goes out to try to find where to store it.</p>
<p>This made for some interesting crashes where a machine would run for weeks, but after a while enough pages were dirtied up that the machine would suddenly run out of memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773593">
				<div id="div-comment-773593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773593">
			October 2, 2009 at 12:21 pm</a>		</div>

		<p>&quot;Does Windows allow you to overcommit memory?&quot;</p>
<p>Reading Raymond&#8217;s post, it would seem that no, you can&#8217;t&#8230; else what promise would be made exactly?</p>
<p>To try?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773603">
				<div id="div-comment-773603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Echobeach</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773603">
			October 2, 2009 at 12:42 pm</a>		</div>

		<p>I wonder how ReadyBoost fits in to all of this. Is it considered to be &quot;as good&quot; as real memory? Or swap?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773643">
				<div id="div-comment-773643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773643">
			October 2, 2009 at 1:47 pm</a>		</div>

		<p>IIRC, ReadyBoost provided memory is a partial mirror of the page file, not a supplement. &nbsp;Everything that goes to a ReadyBoost cache is also written to the page file. &nbsp;As such, it has no effect; the ReadyBoost swap is a partial mirror of the page file, but from the point of view of the memory manager, it&#8217;s equivalent to swap space.</p>
<p>The reason it mirrors part of the page file instead of supplementing it is that users are prone to yanking USB sticks at the drop of a hat. &nbsp;If you paged to the ReadyBoost drive only, your program would suddenly lose access to all memory paged there. &nbsp;The speed boost from ReadyBoost is from the advantages to short, random reads, writes are still constrained by the hard disk.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773673">
				<div id="div-comment-773673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773673">
			October 2, 2009 at 2:41 pm</a>		</div>

		<p>“Under Linux, you can ask for more memory than exists in both physical and swap memory. &nbsp;The OS will happily commit to giving it to you, even though it can&#8217;t possibly service that request. &nbsp;It isn&#8217;t till you actually try to write to that memory that the manager goes out to try to find where to store it.”</p>
<p>That sounds like the totally logic thing to do &#8230; what are the Linux devs smoking??</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773683">
				<div id="div-comment-773683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">me</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773683">
			October 2, 2009 at 2:48 pm</a>		</div>

		<p>My impression was that you could always circumvent the page file limitation (and not respect the user&#8217;s settings) by allocating memory in your own &quot;page file&quot;:</p>
<p>pData = MapViewOfFile(CreateFileMapping(CreateFile(tempfile, GENERIC_READ|GENERIC_WRITE|DELETE, FILE_SHARE_DELETE, 0, CREATE_NEW, FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE, 0), 0, PAGE_READWRITE, 0, bytes, 0), FILE_MAP_ALL_ACCESS, 0, 0, 0);</p>
<p>The memory is released by unmapping it and closing the two handles created.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773693">
				<div id="div-comment-773693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773693">
			October 2, 2009 at 3:00 pm</a>		</div>

		<p>I mentioned the stack commit failure because it introduces a bit of indeterministic behavior, almost as bad as overcommit: random exception in the low memory conditions.</p>
<p>Though I believe there is now &quot;stack commit failure imminent&quot; exception. For this, an extra guard page is allocated.</p>
<p>I think if you run POSIX application under the corresponding subsystem, you could run into overcommit if you do fork().</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773753">
				<div id="div-comment-773753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773753">
			October 2, 2009 at 4:31 pm</a>		</div>

		<p>&quot;</p>
<p>“Under Linux, you can ask for more memory than exists in both physical and swap memory. &nbsp;The OS will happily commit to giving it to you, even though it can&#8217;t possibly service that request. &nbsp;It isn&#8217;t till you actually try to write to that memory that the manager goes out to try to find where to store it.”</p>
<p>That sounds like the totally logic thing to do &#8230; what are the Linux devs smoking??&quot;</p>
<p>Well, if you google around for 5 minutes, you find that a lot of apps allocate tons of memory and then don&#8217;t use it. It&#8217;s configurable, so you can turn it off or even tell the kernel how much overcommit is allowed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773763">
				<div id="div-comment-773763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.flickr.com/photos/ajgelado/' rel='external nofollow' class='url'>Antonio Rodr&#237;&#173;guez</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773763">
			October 2, 2009 at 5:15 pm</a>		</div>

		<blockquote><p>
  Well, if you google around for 5 minutes, you find that a lot of apps</p>
<p>  allocate tons of memory and then don&#8217;t use it. It&#8217;s configurable,</p>
<p>  so you can turn it off or even tell the kernel how much overcommit</p>
<p>  is allowed.
</p></blockquote>
<p>Looks like a case of asking for a bug as a feature. If the default kernel settings allow processes to allocate chunks larger than available memory, programmers will certainly do it: it&#8217;s a lot simpler and easier to allocate, let&#8217;s say, 2 GB of memory and then use them as you need, than to allocate them in 1 MB blocks when you need them. The main reason not to allocate all the memory at once is to avoid your petition to get turned down (well, playing it fair with other processes is another good reason). IMHO, allowing overcommiting shouldn&#8217;t be allowed because of that, and thus, enabling it by default is a design bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773773">
				<div id="div-comment-773773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773773">
			October 2, 2009 at 5:37 pm</a>		</div>

		<p>And a lot of apps predate linux or run on multiple unix OSes, so it&#8217;s possible they do it because they can get away with it most times.</p>
<p>Another reason may well be ulimit: in unix, if you want to constrain a user&#8217;s resource usage, just run ulimit and their consumption of memory, processes, etc are limited. At this point, you go allocate 2G of ram as per common practice, then actually use malloc to get real memory &#8211; since you have VM, all this is easy and since you have ulimit in case something bad happens, no worries.</p>
<p>Call it a different design philosophy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773623">
				<div id="div-comment-773623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773623">
			October 2, 2009 at 1:05 pm</a>		</div>

		<p>&gt; &#8220;I allocated half a gigabyte of memory but Task Manager&#8217;s &#8216;Physical Memory Free&#8217; didn&#8217;t go down.&#8221;</p>
<p>An allocation like:</p>
<p>&gt;&gt; unsigned char *p = new unsigned char[512*1024*1024];</p>
<p>doesn&#8217;t make the physical allocation before the application write to the allocated memory.</p>
<div class=post>[<i>Is there an echo in here? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773833">
				<div id="div-comment-773833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773833">
			October 2, 2009 at 8:15 pm</a>		</div>

		<p>Alexandre Grigoriev</p>
<blockquote><p>
  there&#8217;s now &quot;stack commit failure imminent&quot; exception.</p>
<p>  For this, an extra guard page is allocated.
</p></blockquote>
<p>Ah, so that&#8217;s how it is. We were wondering about that extra guard page for a while.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773843">
				<div id="div-comment-773843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773843">
			October 2, 2009 at 8:18 pm</a>		</div>

		<p>You have to support overcommit if you support fork(). A fork could essentially double the amount of process private committed memory. Unix and Linux cope with that by using copy on write strategy. When a page is modified, another page is allocated. If such allocation fails, bad luck.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773863">
				<div id="div-comment-773863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773863">
			October 2, 2009 at 8:27 pm</a>		</div>

		<p>@Alexandre Grigoriev, you could still fail the fork if there&#8217;s not enough memory. Sucks if you were just going to exec() though&#8230;</p>
<p>Maybe block the parent until it&#8217;s clear whether or not the child is going to exec.</p>
<p>Or maybe just go ahead and really commit the memory, and anyone who doesn&#8217;t like it can use vfork or posix_spawn instead of fork/exec.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773883">
				<div id="div-comment-773883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773883">
			October 2, 2009 at 8:39 pm</a>		</div>

		<p>The general solution is that if you don&#8217;t have enough memory to run a program, buy more memory.</p>
<p>Overcommit just lets you use memory that nobody else is actually using, even though they said they were going to. &nbsp;Plus, if you start actually running out, tools like swapon give you more swap space. &nbsp;Magic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773653">
				<div id="div-comment-773653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773653">
			October 2, 2009 at 1:53 pm</a>		</div>

		<p>Am I correct to assume that if paging file is off, couple processes can prevent *other* process to commit memory?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773903">
				<div id="div-comment-773903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://billy-oneal.com/' rel='external nofollow' class='url'>Billy O'Neal</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773903">
			October 2, 2009 at 9:30 pm</a>		</div>

		<p>@Alex: Or just allow commits only to the value allowed by swap. No magic required. You can still use a swap file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773723">
				<div id="div-comment-773723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773723">
			October 2, 2009 at 3:44 pm</a>		</div>

		<p>waleri wrote:</p>
<p>&quot;Am I correct to assume that if paging file is off, couple processes can prevent *other* process to commit memory?&quot;</p>
<p>Yes, they could. Of course, they can do that if the page file is on as well.</p>
<p>If the phsyical RAM and page file reach their limits then you can&#8217;t allocate any more memory, whether or not the page file limit is zero.</p>
<p>A process can also run out of available memory addresses (obviously much more of a problem for 32-bit processes than 64-bit).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773913">
				<div id="div-comment-773913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773913">
			October 2, 2009 at 11:05 pm</a>		</div>

		<p>I was going to ask the same question as bahbar. Thanks for the reply to his comment, Raymond. It&#8217;s nice to have an example where you can see the theory expressing itself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773933">
				<div id="div-comment-773933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773933">
			October 2, 2009 at 11:40 pm</a>		</div>

		<p>&quot;When you commit memory, you get a commitment to receive memory when you need it, but no sooner&quot;</p>
<p>ok. &nbsp;but why does it matter?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773953">
				<div id="div-comment-773953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773953">
			October 3, 2009 at 12:40 am</a>		</div>

		<p>Raymond, yes, I was complaining about overcommitment. I would hope the whole point of doing it the way Windows does is so that you get null from malloc() instead of an exception in some other module that&#8217;s unlucky enough to be the first to try to write into that page that can&#8217;t be committed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773993">
				<div id="div-comment-773993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lawrence</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773993">
			October 3, 2009 at 3:55 am</a>		</div>

		<p>Cooney: &quot;And a lot of apps predate linux or run on multiple unix OSes, so it&#8217;s possible they do it because they can get away with it most times.&quot;</p>
<p>Umm, if you have an app that &quot;predates&quot; Linux (&lt;~1991?), it really shouldn&#8217;t be allocating memory blocks big enough to scare any modern OS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774003">
				<div id="div-comment-774003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774003">
			October 3, 2009 at 4:02 am</a>		</div>

		<p>The more I think about it, the sillier the Linux design looks. Say you have some long-running calculation, that may require up to 2GB of memory. There is only 1GB left. On Windows, this fails outright. On Linux, this fails severel hours later (unless there&#8217;s some activity that frees up memory, and I doubt that on a system that does a calculation over several hours).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773943">
				<div id="div-comment-773943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-773943">
			October 3, 2009 at 12:08 am</a>		</div>

		<p>The problem with only committing memory when you go to ask for it is that you don&#8217;t know you&#8217;re out of memory until it&#8217;s too late to do anything about it. You want to get a null returned from malloc(), not a segfault in the middle of some random transaction.</p>
<p>Who would want a program that crashes and loses all their data instead of just giving them an error message?</p>
<div class=post>[<i>A non-NULL return from malloc() comes with a commitment that the memory will be there when you access it. The point is that the memory is not required to be there *before* you access it. (Or are you complaining about overcommittment?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774053">
				<div id="div-comment-774053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774053">
			October 3, 2009 at 2:57 pm</a>		</div>

		<p>@Anon &quot;You could easily throw fork out of the window in favour of a more sensible way to start a subprocess.&quot;</p>
<p>That&#8217;s the problem &#8211; you can&#8217;t. &quot;Unixy&quot; OSes have just as bad of a legacy problem as windows; being open-source doesn&#8217;t change the fact that all the old APIs have to be supported at the source code level. But what they could do is require forked processes to use real memory, and new apps should use either vfork or posix_spawn. [fork/exec is a broken pattern anyway; most programs that use it leak file descriptors. That is why posix_spawn was created.]</p>
<p>Or maybe even only &quot;overcommit&quot; memory that came from fork and is probably going to go away as soon as exec is done.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774033">
				<div id="div-comment-774033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774033">
			October 3, 2009 at 8:16 am</a>		</div>

		<p>I&#8217;m dabbling into Linux myself; just a little bit, but enough to know that most Linux *users* fall into two categories: those who don&#8217;t know what overcommit is, and those who hate it. Understandable, because there are few things as annoying as all your windows disappearing on you.</p>
<p>Now, the developers say they want overcommit because they need fork, but I&#8217;ve always considered that a non-argument. You could easily throw fork out of the window in favour of a more sensible way to start a subprocess.</p>
<p>By the way, I think it may be possible to get into an overcommit situation in Windows if you happen to write to lots of pages with copy-on-write access. I don&#8217;t know if it&#8217;s possible to prevent this situation under all circumstances (doesn&#8217;t the image loader use this?) and I wonder how much Windows does to guard you from this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774063">
				<div id="div-comment-774063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774063">
			October 3, 2009 at 5:06 pm</a>		</div>

		<p>Also remember that even with overcommit on, you can touch all those pages before you do an hour of work to make sure there is enough ram. &nbsp;Or set the overcommit flag off.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774083">
				<div id="div-comment-774083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774083">
			October 3, 2009 at 10:46 pm</a>		</div>

		<blockquote><p>
  I think it may be possible to get into an</p>
<p>  overcommit situation in Windows if you</p>
<p>  happen to write to lots of pages with</p>
<p>  copy-on-write access.
</p></blockquote>
<p>No, it&#8217;s not possible. When a process maps a copy-on-write view of a file or a pagefile section, Windows charges commit for the entire view.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774173">
				<div id="div-comment-774173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774173">
			October 5, 2009 at 12:04 am</a>		</div>

		<blockquote><p>
  &gt; Maybe block the parent until it&#8217;s clear whether or not the child is going to exec.
</p></blockquote>
<p>Or use vfork() when are going to exec() or use fork() when you want the traditional behaviour.</p>
<p>Hey, wait that&#8217;s what the functions already do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774213">
				<div id="div-comment-774213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Petr Kadlec</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774213">
			October 5, 2009 at 8:08 am</a>		</div>

		<p>“The fire department promises that if there&#8217;s a fire in your house, they will come to try to put it out. But that doesn&#8217;t mean that there&#8217;s a tank of water at the fire station with your name on it.”</p>
<p>And your bank promises that when you come back for your savings, they’ll give your money back… if not too many people come. Linux is not the only one to overcommit. ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774233">
				<div id="div-comment-774233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaron G</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774233">
			October 5, 2009 at 9:27 am</a>		</div>

		<p>[I forget the exact situation but it was something like &quot;I allocated half a gigabyte of memory but Task Manager&#8217;s &#8216;Physical Memory Free&#8217; didn&#8217;t go down.&quot; -Raymond]</p>
<p>Doesn&#8217;t the task manager have a &quot;Commit Size&quot; column? &nbsp;If that was [similar to] the original question, then it sounds like whomever asked it must have been pretty lazy not to have found that option.</p>
<p>Although I guess you&#8217;d already have to have a pretty lazy mind to not immediately see the difference between committing to doing some work and actually doing the work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774253">
				<div id="div-comment-774253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bill</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774253">
			October 5, 2009 at 10:07 am</a>		</div>

		<p>Having worked on Solaris boxes with overcommit disabled (or maybe just unavailable at all) I can say that I know what it is and I miss it when it isn&#8217;t there. That said it was in a situation with fork()ed processes requiring 4GB of physical ram when really about 800k would suffice with copy-on-write and overcommit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774293">
				<div id="div-comment-774293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774293">
			October 5, 2009 at 12:23 pm</a>		</div>

		<p>&quot;Pages are virtual&quot;. &nbsp;Not if it&#8217;s a page who works for the king, whose job it is to keep track of things. &nbsp;See Note 1.</p>
<p>The Thing King and the Paging Game</p>
<p>Rules</p>
<p>1.Each player gets several million things.</p>
<p>2.Things are kept in crates that hold 4096 things each. Things in the same crate are called crate-mates.</p>
<p>3.Crates are stored either in the workshop or the warehouses. The workshop is almost always too small to hold all the crates.</p>
<p>4.There is only one workshop but there may be several warehouses. Everybody shares them.</p>
<p>5.Each thing has its own thing number.</p>
<p>6.What you do with a thing is to zark it. Everybody takes turns zarking.</p>
<p>7.You can only zark your things, not anybody else’s.</p>
<p>8.Things can only be zarked when they are in the workshop.</p>
<p>9.Only the Thing King knows whether a thing is in the workshop or in a warehouse.</p>
<p>10.The longer a thing goes without being zarked, the grubbier it is said to become.</p>
<p>11.The way you get things is to ask the Thing King. He only gives out things by the crateful. This is to keep the royal overhead down.</p>
<p>12.The way you zark a thing is to give its thing number. If you give the number of a thing that happens to be in a workshop it gets zarked right away. If it is in a warehouse, the Thing King packs the crate containing your thing back into the workshop. If there is no room in the workshop, he first finds the grubbiest crate in the workshop, whether it be yours or somebody else’s, and packs it off with all its crate-mates to a warehouse. In its place he puts the crate containing your thing. Your thing then gets zarked and you never know that it wasn’t in the workshop all along.</p>
<p>13.Each player’s stock of things have the same numbers as everybody else’s. The Thing King always knows who owns what thing and whose turn it is, so you can’t ever accidentally zark somebody else’s thing even if it has the same thing number as one of yours.</p>
<p>Notes</p>
<p>1.Traditionally, the Thing King sits at a large, segmented table and is attended to by pages (the so-called “table pages”) whose job it is to help the king remember where all the things are and who they belong to.</p>
<p>2.One consequence of Rule 13 is that everybody’s thing numbers will be similar from game to game, regardless of the number of players.</p>
<p>3.The Thing King has a few things of his own, some of which move back and forth between workshop and warehouse just like anybody else’s, but some of which are just too heavy to move out of the workshop.</p>
<p>4.With the given set of rules, oft-zarked things tend to get kept mostly in the workshop while little-zarked things stay mostly in a warehouse. This is efficient stock control.</p>
<p>(Attributed to Jeff Barryman, 1972, reprinted in &quot;Expert C Programming&quot; by Peter van der Linden.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774303">
				<div id="div-comment-774303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774303">
			October 5, 2009 at 12:26 pm</a>		</div>

		<p>So, the title says that when I &#8220;do commit&#8221;, I &#8220;get a commitment&#8221;?</p>
<p>Sounds really strange. How&#8217;s that?</p>
<p>The concept of &#8220;committing memory&#8221; is completely new to me.</p>
<p>I always saw it as &#8220;asking for a commitment&#8221; from the part of the memory manager, not that I was &#8220;commiting&#8221; memory. It was the memory manager who was making that promise.</p>
<p>I do not &#8220;commit&#8221; a portion of memory. How could I?</p>
<div class=post>[<i>I&#8217;ll assume you&#8217;re not a native English speaker, because this sort of bidirectional transitivity is common in English. Committing memory means creating a commitment, and it is the kernel that provides the commitment that the application creates. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774323">
				<div id="div-comment-774323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774323">
			October 5, 2009 at 12:35 pm</a>		</div>

		<p>Here&#8217;s a 5th note for David Walker&#8217;s allegory:</p>
<ol>
<li>Sometimes even the warehouses get full. The Thing King then has to start piling things on the dump out back. This makes the game slower because it takes a long time to get things off the dump when they are needed in the workshop. A forthcoming change in the rules will allow the Thing King to select the grubbiest things in the warehouses and send them to the dump in his spare time, thus keeping the warehouses from getting too full. This means that the most infrequently-zarked things will end up in the dump so the Thing King won&#8217;t have to get things from the dump so often. &nbsp;This should speed up the game when there are a lot of players and the warehouses are getting full.</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774343">
				<div id="div-comment-774343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774343">
			October 5, 2009 at 12:55 pm</a>		</div>

		<p>Gabe, it&#8217;s not MY allegory. &nbsp;I just remembered it, found it, and posted it here. &nbsp;But yes, I do remember note 5 from way back.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774423">
				<div id="div-comment-774423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">George Jettson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-774423">
			October 5, 2009 at 8:56 pm</a>		</div>

		<p>Wow &#8211; have things really changed so little since 1972? No wonder I don&#8217;t have my jet pack and flying car yet. &nbsp;Come on people, clearly we need some major innovating!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-775813">
				<div id="div-comment-775813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mbghtri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-775813">
			October 7, 2009 at 6:46 pm</a>		</div>

		<p>@George Jettson &#8211; &quot;Wow &#8211; have things really changed so little since 1972? No wonder I don&#8217;t have my jet pack and flying car yet. &nbsp;Come on people, clearly we need some major innovating!&quot;</p>
<p>Change? The workshop and warehouses are bigger by several orders of magnitude, the path from the warehouses to the workshop is now immensely wider, and some Thing Kings run many workshops at the same time. The dump doesn&#8217;t even have to be in the same city anymore, it can be in the clouds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-775853">
				<div id="div-comment-775853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">LionsPhil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091002-00/?p=16513#comment-775853">
			October 7, 2009 at 8:34 pm</a>		</div>

		<p>The worst, &lt;em&gt;worst, &lt;strong&gt;worst&lt;/strong&gt;&lt;/em&gt; part about Linux overcommitting is that there&#8217;s no guarantee as to which poor process(es) will get violently terminated once the kernel realises it&#8217;s got itself into a pickle. It&#8217;s down to &lt;a href=&quot;<a rel="nofollow" target="_new" href="http://lxr.linux.no/#linux+v2.6.31/mm/oom_kill.c&quot;&gt;a" rel="nofollow">http://lxr.linux.no/#linux+v2.6.31/mm/oom_kill.c&quot;&gt;a</a> filthy &quot;badness&quot; heuristic&lt;/a&gt;.</p>
<p>&lt;code&gt;fork()&lt;/code&gt; is no argument. You can commit &lt;em&gt;and&lt;/em&gt; have copy-on-write. Remember: the whole point of this post is that commits are not physical &lt;em&gt;allocations&lt;/em&gt;; they&#8217;re book-keeping of promises.</p>
<p>What this is is typical UNIX lazyness, and the empowering thereof.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>