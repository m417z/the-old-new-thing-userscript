<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (38)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-640833">
				<div id="div-comment-640833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frederik Slijkerman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640833">
			June 23, 2008 at 11:28 am</a>		</div>

		<p>Of course, if the newly allocated string happens to contain no null characters at all.</p>
<div class=post>[<i><a href="http://msdn.microsoft.com/en-us/library/ms221069.aspx" rel="nofollow">Try again</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-nathan_works odd alt thread-odd thread-alt depth-1" id="comment-640843">
				<div id="div-comment-640843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/nathan_works' rel='external nofollow' class='url'>nathan_works</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640843">
			June 23, 2008 at 11:32 am</a>		</div>

		<p>If you don&#8217;t write the &quot;new&quot; and the &quot;delete&quot;, you don&#8217;t know what&#8217;s happening with the memory you are handling.. For better or worse..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-640853">
				<div id="div-comment-640853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://wizou.fr' rel='external nofollow' class='url'>Wizou</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640853">
			June 23, 2008 at 11:41 am</a>		</div>

		<p>taken from MSDN SysAllocStringLen :</p>
<p>cch = The number of characters to be copied from pch. A null character is placed afterwards, allocating a total of cch plus one characters.</p>
<p>so SysStringLen will stop on that null character and won&#8217;t return a larger value.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-640883">
				<div id="div-comment-640883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://codewiz51.blogspot.com' rel='external nofollow' class='url'>Old Coder</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640883">
			June 23, 2008 at 12:12 pm</a>		</div>

		<p>Sorry Wizou, but pch in the example is NULL. pch is never copied; the string is never initialized and no null terminator is appended. I have, in fact, expertly performed several catastrophic buffer overflows in my lifetime using similar logic, much to my chagrin.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-640893">
				<div id="div-comment-640893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dgt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640893">
			June 23, 2008 at 12:25 pm</a>		</div>

		<p>wouldn&#8217;t</p>
<p>CComBSTR bstr = ::SysAllocStringLen(NULL, 100);</p>
<p>magically fix the problem?</p>
<p>I always hated extra lines.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-640923">
				<div id="div-comment-640923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.crammerz-inc.net/thunk' rel='external nofollow' class='url'>Wil</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640923">
			June 23, 2008 at 12:47 pm</a>		</div>

		<p>The format of a BSTR starts with a 4-byte length specifier so if he allocated 100 characters, it would be 200 or 0x00 00 00 00 C8 and since wcslen accepts a null-terminated string&#8230;</p>
<p>And if that doesn&#8217;t stop it the documentation says that the data segment may contain embedded nulls so you have a slight chance of stopping beforehand. ( about 1-(2^16-1)^100/2^16^100?)</p>
<p>And if that still doesn&#8217;t stop wcslen, it&#8217;s null-terminated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-640933">
				<div id="div-comment-640933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hans</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640933">
			June 23, 2008 at 12:51 pm</a>		</div>

		<p>@dgt No, this would be the same behavior.</p>
<p>As Raimond explained, the cause is the compiler does not know the argument is a BST (he sees OLECHAR*).</p>
<p>@Old Coder</p>
<p>Wizou is correct, SysAllocStringLen initializes the final null terminator, even if input string is NULL and thus the chars before the final null terminator are garbage.</p>
<p>For _bstr_t there is an extra ctor with copy flag _bstr_t(BSTR s, bool copy), and from the code it uses the BSTR length of s, not wcslen.</p>
<p>So this would also correct the original problem.</p>
<p>Just another question is if uninitialized strings are good style ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-640953">
				<div id="div-comment-640953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Khedron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640953">
			June 23, 2008 at 12:59 pm</a>		</div>

		<p>For some reason, Raymond&#8217;s exercise reminds me of the &quot;Microsoft vs Psychic Friends Network&quot; story floating around on the internet.</p>
<p>&quot;You have a problem? Could it be that it&#8217;s your computer that&#8217;s your problem? I sense&#8230; is it an unintentional buffer overflow due to misuse of smart pointers?&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-640963">
				<div id="div-comment-640963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wizou</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640963">
			June 23, 2008 at 1:01 pm</a>		</div>

		<p>@myself:</p>
<p>I meant wcslen, of course &#8230; not SysStringLen</p>
<p>@Wil:</p>
<p>The pointer to a BSTR points to the first character of the data string, not to the length prefix.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-640973">
				<div id="div-comment-640973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640973">
			June 23, 2008 at 1:07 pm</a>		</div>

		<p>From the docs for SysAllocStringLen():</p>
<p>&quot;If pch is NULL, a string of the requested length is allocated, but not initialized.&quot;</p>
<p>Sounds like there&#8217;s no guarantee that the buffer will be terminated with anything, much less a L&#8217; &#8217;, which is what&#8217;s required by the CComBSTR::operator=( LPOLESTR) operator.</p>
<p>There you go &#8211; instant buffer overflow opportunity.</p>
<p>However, I&#8217;m not sure that this is really a smart pointer problem &#8211; this could happen without smart pointer just as easily, I think. If you&#8217;re using raw pointers and throwing around uninitialized data structures, you&#8217;re still going to get bad results unless you&#8217;re really careful. &nbsp;It seems to me the problem is in the misunderstood/incorrect use of SysAllocStringLen(), not the CComBSTR class.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jamescurran even thread-even depth-1" id="comment-640993">
				<div id="div-comment-640993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Garry Trinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640993">
			June 23, 2008 at 1:56 pm</a>		</div>

		<p>@BrianK</p>
<p>Try Again. &nbsp;In dgt&#8217;s example, CComBSTR::operator=() is not being used. &nbsp;</p>
<p>CComBSTR bstr = ::SysAllocStringLen(NULL, 100);</p>
<p>is the equivalent of</p>
<p>CComBSTR bstr = CComBSTR(::SysAllocStringLen(NULL, 100));</p>
<p>This will lead to the same problem, but via a different route.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641003">
				<div id="div-comment-641003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://justin-michel.spaces.live.com/' rel='external nofollow' class='url'>Justin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641003">
			June 23, 2008 at 2:12 pm</a>		</div>

		<p>I think the point dgt is trying to make is that</p>
<p>CComBSTR bstr = ::SysAllocStringLen(NULL, 100);</p>
<p>does NOT call operator=. It&#8217;s an initialization statement, and therefore it will use a constructor. &nbsp;The above line is essentially just another way to say this&#8230;</p>
<p>CComBSTR bstr(::SysAllocStringLen(NULL, 100));</p>
<p>Whether this works around the problem, I have no idea.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641013">
				<div id="div-comment-641013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641013">
			June 23, 2008 at 2:25 pm</a>		</div>

		<p>Nasty code you&#8217;ve got there.</p>
<p>I blame the language&#8230;and the platform. There has to be a better way to do this stuff that doesn&#8217;t require .NET. In the previous example I&#8217;m not sure why that CComBSTR class can&#8217;t just be replaced by a string class built off of BSTRs. It would handle the icky job of managing the lifetime of the string.</p>
<p>This, of course, is complicated by other scenarios: when you have to take over the lifetime of other BSTRs, or you want to release your internal BSTR for others, but this is well-trodden territory. Since strings are so common, it makes sense to use a higher level of abstraction when dealing with them so there is less chance of programmer error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641043">
				<div id="div-comment-641043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641043">
			June 23, 2008 at 5:05 pm</a>		</div>

		<blockquote><p>
  CComBSTR bstr(::SysAllocStringLen(NULL, 100));</p>
<p>  Whether this works around the problem, I</p>
<p>  have no idea.
</p></blockquote>
<p>No, Of course it doesn&#8217;t.</p>
<p>And you know this because you could write:</p>
<p>CComBSTR bstr(L&quot;Hello&quot;);</p>
<p>No one is freeing that memory allocated by SysAllocStringLen and passed to the contructor.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641063">
				<div id="div-comment-641063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641063">
			June 23, 2008 at 5:23 pm</a>		</div>

		<p>That&#8217;s c++ for you, it&#8217;s impossible by design to avoid all the cases.</p>
<p>For example, developers invariably try to make functions that return COM object pointers as returned values, instead of parameters</p>
<p>Example:</p>
<p>CComPtr&lt;IUnknown&gt; spObj = ::CreateMyObject();</p>
<p>instead of</p>
<p>::CreateMyObject( &amp;spObj);</p>
<p>Same problem, it leaks. &nbsp;Mixing C and C++ is deadly, you still have to know how these things works.</p>
<p>The best way it to not mix the coding style, like it happens with the CComBSTR and ::SysAllocString example.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641113">
				<div id="div-comment-641113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisMcB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641113">
			June 23, 2008 at 7:08 pm</a>		</div>

		<p>I once tracked down a similar problem:</p>
<p>void function(CComBSTR oldGuy)</p>
<p>{</p>
<p>CComBSTR newGuy;</p>
<p>newGuy = oldGuy.copy();</p>
<p>&#8230; }</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641123">
				<div id="div-comment-641123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">st</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641123">
			June 23, 2008 at 7:12 pm</a>		</div>

		<p>Chris Ashton? The conlanger that created Vendi? The world is so small.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-640943">
				<div id="div-comment-640943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-640943">
			June 23, 2008 at 12:55 pm</a>		</div>

		<p>dgt: Absolutely *not* (&#8230;I don&#8217;t think; C++ has been confusing for a very long time now).</p>
<p>The whole problem is that you&#8217;re assigning the result of ::SysAllocStringLen() to a CComBSTR, and using operator= to do it. &nbsp;That operator= call resolves to the overload that takes an LPCOLESTR, so the operator= code uses wcslen, which probably returns the wrong value, since the string contains garbage. &nbsp;(Exactly as the original post said.)</p>
<p>Doing the assignment in a single line doesn&#8217;t make any difference: you&#8217;re still calling operator=, and you&#8217;re still calling it with an LPCOLESTR &#8212; as far as the compiler knows, anyway.</p>
<p>You *need* to use CComBSTR::Attach to hook a CComBSTR up to a BSTR that you happen to have, otherwise you *will* get the wrong answer. &nbsp;Or, you can skip the API call entirely, as in the second correct example above, and call the CComBSTR constructor that takes a length.</p>
<p>Wil: Yes, a BSTR starts with a 4-byte length specifier, but that length specifier is *BEFORE* the address that the BSTR pointer contains. &nbsp;So if you get a BSTR pointer whose value is 0x12345678, then the length is the four bytes at 0x12345674. &nbsp;The first character of the string is (the two bytes starting) at 0x12345678.</p>
<p>So as long as there aren&#8217;t any embedded pairs of zero bytes (there can be single zero bytes, because this is a UTF-16 string), wcslen would work fine when passed the BSTR variable&#8217;s value. &nbsp;But as you said, the contents of the string are uninitialized: if there are any pairs of zero bytes in the garbage, wcslen will stop too early.</p>
<p>The link that Raymond provided above to the definition of a BSTR claims that there&#8217;s always a zero terminator after cch characters&#8217; worth of bytes (200 here). &nbsp;So that will stop wcslen, you&#8217;re right there. &nbsp;Unless it&#8217;s off by one, I don&#8217;t think wcslen can return more bytes than ::SysAllocStringLen(NULL, x); passed for &quot;x&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641023">
				<div id="div-comment-641023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom Ritchford</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641023">
			June 23, 2008 at 3:03 pm</a>		</div>

		<p>While I agree with your claim, the argument justifying it is dubious at best. </p>
<p>The problem is that the semantics and the syntax of this smart-pointer class are opaque and fragile. &nbsp;</p>
<p>While you need to understand smart pointers before you use them, the class designer should give at least a little thought to making the correct usage &quot;simple&quot; and making incorrect usage &quot;hard&quot;. &nbsp;boost&#8217;s various smart pointers are a perfectly good example.</p>
<p>The specific problem in the current example is the assignment operator=(). &nbsp;</p>
<p>*Unless = can be made work in a completely intuitive fashion that will never trip you up, you should simply not implement it.* &nbsp;It&#8217;s a trap waiting to happen &#8211; you&#8217;d use and forget &quot;=&quot; (and never notice it while code reviewing) whereas that would never happen if you had a non-const method on your class, SetFromWideString().</p>
<p>There&#8217;s also the other stupidity that BSTR and LPCOLESTR are the same so you never know looking at a function call whether you&#8217;re making the terrible mistake of passing a wide char string to a short string routine or vice versa.</p>
<p>If you were using standard STL, you&#8217;d be using two different classes, basic_string&lt;char&gt; and basic_string&lt;wchar&gt;, so there&#8217;d be no chance of passing one to the other.</p>
<p>(I don&#8217;t really know these MS things so forgive me if I&#8217;m not understanding something obvious because I lack context&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641143">
				<div id="div-comment-641143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://cashto@microsoft.com' rel='external nofollow' class='url'>Chris Ashton</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641143">
			June 24, 2008 at 1:35 am</a>		</div>

		<p>To tsas yei nahc. &nbsp;That&#8217;s me. &nbsp;:-)</p>
<p>Internet is much smaller than world, btw.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641153">
				<div id="div-comment-641153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://wizou.fr' rel='external nofollow' class='url'>Wizou</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641153">
			June 24, 2008 at 3:52 am</a>		</div>

		<p>@mikeb: Raymond is pointing out [url=<a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms221069.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/ms221069.aspx</a>]this &nbsp;MSDN page[/url] which states that a BSTR consists of a length prefix, a data string, and a terminator.</p>
<p>So I guess we can assume that BSTR-allocating functions always enforce this null terminator. Even for a non-initialized data string.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641163">
				<div id="div-comment-641163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dog</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641163">
			June 24, 2008 at 4:15 am</a>		</div>

		<blockquote><p>
  Matt Green: I blame the language&#8230;
</p></blockquote>
<p>Please don&#8217;t blame C++ for this. It&#8217;s not C++&#8217;s fault that certain vendors decided to build huge APIs on it long before it was standardised and had many of its most useful features developed (Templates, STL, Exceptions, etc). (Yes, I realise that CComBSTR is part of the ATL (oddly named since most of its classes are not actually templates)).</p>
<p>And despite the headline, CComBSTR isn&#8217;t really a smart pointer at all. It&#8217;s a wrapper class for a data structure. It&#8217;s no more a smart pointer than std::string.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641183">
				<div id="div-comment-641183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641183">
			June 24, 2008 at 6:13 am</a>		</div>

		<p>The same kind of problem happens with the Standard C++ Library smart pointer, std::auto_ptr&lt;&gt;.</p>
<p>If you try to operator= it with a raw pointer, or even =-initialize it with a raw pointer, woe is you: You must explicitly use the constructor and the reset() member function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641203">
				<div id="div-comment-641203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641203">
			June 24, 2008 at 6:22 am</a>		</div>

		<p>@Ulric : I think the CComPtr&lt;&gt; class lacks a non-addref-ing constructor.</p>
<p>The MFC class COleDispatchDriver allows you to addref or not, and by default its constructor from LPDISPATCH doesn&#8217;t.</p>
<p>This discrepancy between the different smart pointer classes is also a source of problems (I assumed CComPtr&lt;&gt; didn&#8217;t AddRef() and had to check its source code to make sure).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641223">
				<div id="div-comment-641223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.martinparry.com' rel='external nofollow' class='url'>Martin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641223">
			June 24, 2008 at 8:05 am</a>		</div>

		<p>A good point well made.</p>
<p>I believe it was Scott Meyers, in Effective C++ [1], who said &quot;Smart pointers add at least as much complexity as they remove&quot;.</p>
<p>And I think Spolsky&#8217;s Law [2] is pertinent too.</p>
<p>[1] <a rel="nofollow" target="_new" href="http://www.amazon.com/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0321334876" rel="nofollow">http://www.amazon.com/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0321334876</a></p>
<p>[2] <a rel="nofollow" target="_new" href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html" rel="nofollow">http://www.joelonsoftware.com/articles/LeakyAbstractions.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641233">
				<div id="div-comment-641233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641233">
			June 24, 2008 at 8:48 am</a>		</div>

		<p>JamesCurran:</p>
<blockquote><p>
  is the equivalent of</p>
<p>  CComBSTR bstr = CComBSTR(::SysAllocStringLen(NULL, 100));
</p></blockquote>
<p>Ack. &nbsp;This is (part of the reason) that I hate C++. &nbsp;In other languages, that would simply call the equivalent of operator=, using the overload that takes an LPOLESTR, since that&#8217;s what you wrote. &nbsp;But no, because this is C++, and because the call happens to be in an initializer (&#8230;what?!?!), it goes on some crazy trip through a temp variable whose constructor takes the BSTR (actually probably LPOLESTR?), and then through the &nbsp;operator= that takes a CComBSTR. &nbsp;(I think.)</p>
<p>This is part of what I meant by &quot;C++ has been confusing for a very long time now&quot; &#8212; this kind of dependence on (to me, non-obvious) context is hard to keep track of.</p>
<p>So, OK, dgt: Let me take that back. &nbsp;Of course, you&#8217;ll still (most likely) leak the original BSTR, and the constructor that takes an LP(C)OLESTR will probably get it wrong as well by not using SysStringLen, but that code doesn&#8217;t use the operator= that takes an LPCOLESTR.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641323">
				<div id="div-comment-641323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">st</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641323">
			June 24, 2008 at 10:48 am</a>		</div>

		<p>std::auto_ptr operator= ought to delete the thing that the std::auto_ptr is pointing to before assigning a new raw pointer to it &#8211; if it doesn&#8217;t do that, I think there is something wrong with your standard library implementation. Now assigning and std::auto_ptr to another std::auto_ptr is where the fun starts. It does have its place though &#8211; I use it sometimes for function arguments to indicate that I am taking ownership of the pointer that is being passed in and the caller should not touch it again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641343">
				<div id="div-comment-641343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">no one in particular</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641343">
			June 24, 2008 at 10:51 am</a>		</div>

		<p>Construction is when you create a variable that had not been there before.</p>
<p>Assignment is when you change the value of an existing variable.</p>
<p>Construction always uses constructors, hence the name ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641383">
				<div id="div-comment-641383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641383">
			June 24, 2008 at 12:06 pm</a>		</div>

		<p>@Wizou: I&#8217;m not sure what Raymond is intending by his &quot;try again&quot; link. &nbsp;The fact is that the docs for SysAllocStringLen() says that if a NULL is passed in, the returned string is not initialized. &nbsp;If you rely on some undocumented behavior that does initialize the string then, as Raymond has pointed out in previous articles, your code may break when MS changes the implementation to some other behavior that still respects the documented interface.</p>
<p>In fact, on WinXP SP2 SysAllocStringLen() does place a single null wchar at the end of the allocated buffer (in the case of the SysAllocStringLen( NULL, 100) call, it places the null char just after where the 100th character would go). &nbsp;But I see that as MS programming defensively &#8211; not part of the SysAllocStringLen() interface.</p>
<p>Also, I&#8217;m not sure, but I think that the page Raymond linked to may have an error &#8211; it indicates that BSTRs are terminated with two null characters, which would be 4 null bytes (since BSTRs consist of wchars). Is this correct, or do BSTRs normally terminate with a single null wchar?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641393">
				<div id="div-comment-641393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641393">
			June 24, 2008 at 12:09 pm</a>		</div>

		<p>I still don&#8217;t see how the problem Chris Ashton had anything to do with smart pointers (except incidentally). &nbsp;The same problems would have existed if the result from SysAllocStringLen() had been passed to a normal C function that copied the BSTR into a normal C struct. &nbsp;The problem was that he was asking some other entity to copy a BSTR that had (at best) only been partially initialized, and was never freeing the buffer returned from the SysAllocStringLen() call.</p>
<p>And why has auto_ptr&lt;&gt; been brought into this? CComBSTR behaves nothing like auto_ptr&lt;&gt;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641213">
				<div id="div-comment-641213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641213">
			June 24, 2008 at 6:27 am</a>		</div>

		<p>*** correction about my previous message ***</p>
<p>COleDispatchDriver&#8217;s constructor from LPDISPATCH never AddRefs. It merely allows you the option not to release it either, which turns it into a non-smart pointer. Dangerous, I&#8217;d say.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641243">
				<div id="div-comment-641243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">no one in particular</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641243">
			June 24, 2008 at 9:45 am</a>		</div>

		<p>@Medinoc</p>
<p>Since the arrival of boost::smart_ptr, there is no need to use the std::auto_ptr any more. Even the standards-people admit its design being flawed.</p>
<p>@BryanK</p>
<p>Javaist ;-)</p>
<p>But the mnemonic is quite straightforward: &quot;When ist constructs, it uses a constructor. When it assigns, it uses assignment.&quot;</p>
<p>There is a c&#8217;tor accepting a BSTR (rather its equivalent LPCOLESTR), and the Compiler uses that instead of first initializing an empty variable using the default c&#8217;tor and subsequently overwriting it.</p>
<p>Constructing a variable will *never* use a member function. Whose member, in the first place?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641303">
				<div id="div-comment-641303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641303">
			June 24, 2008 at 10:25 am</a>		</div>

		<p>Actually, no: Pythonist. &nbsp;A pox on the kingdom of nouns! &nbsp;;-P</p>
<p>As far as the mnemonic: That&#8217;s great (apart from being recursive), but it doesn&#8217;t actually help me much. &nbsp;How am I supposed to know what &quot;constructs&quot; and what &quot;assigns&quot; in the first place? &nbsp;It looks like the line that dgt posted is doing an assignment, to me, but apparently it&#8217;s doing a construction? &nbsp;Or something?</p>
<p>&gt; Whose member, in the first place?</p>
<p>I generally think of the constructor as a member function.</p>
<p>Unless you&#8217;re asking which object&#8217;s operator= call? &nbsp;I was thinking it&#8217;d be an object that was created using the no-argument constructor (of course, I&#8217;m assuming that one of those exists for CComBSTR). &nbsp;Yes, now you&#8217;re creating multiple instances and copying stuff around, so maybe that&#8217;s not what happens.</p>
<p>(Maybe it treats it like a single constructor call, so you only ever get a single instance? &nbsp;That seems to match your middle paragraph&#8217;s description. &nbsp;But that&#8217;s even *less* obvious from the code, I think. &nbsp;Oh well; obviously I don&#8217;t know enough of the intricacies of C++. &nbsp;Which is sort of my point. &nbsp;;-) )</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641503">
				<div id="div-comment-641503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Older Newer thing</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641503">
			June 24, 2008 at 6:56 pm</a>		</div>

		<p>As Raymond indicated, the BSTR will be null terminated (the null terminator is part of the data type, as opposed to a char*).</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms221069.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/ms221069.aspx</a> does say that on an Apple Mac the data string consists of a single byte string. On the Mac (pre os X?) platform, would wcslen still interpret this string as a wide character string? If that were to happen, we would probably have a read overflow unless the string happens to contain a continuous sequence of two null bytes starting at even offsets (0, 2, 4) or a sequence of three continuous nulls.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-641423">
				<div id="div-comment-641423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Weeble</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641423">
			June 24, 2008 at 1:29 pm</a>		</div>

		<p>Did somebody give a correct answer? I find the documentation Raymond linked to with his &quot;Try Again&quot; unclear: it says that if a NULL argument is passed, the returned string is &quot;allocated, but not initialized&quot;. One would *assume* that this means the length prefix and terminator are still set, just that the data part is uninitialized, because it would be a bit useless otherwise, but making assumptions doesn&#8217;t seem a particularly good idea.</p>
<p>If it does indeed set the terminator, then I can&#8217;t see a predictable way for wcslen to return a higher value than SysStringLen would, although I think the behaviour is undefined if there&#8217;s insufficient memory for SysAllocStringLen, resulting in a NULL argument to wcslen, but I don&#8217;t think that&#8217;s what Raymond&#8217;s looking for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-641633">
				<div id="div-comment-641633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ash</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-641633">
			June 25, 2008 at 10:29 am</a>		</div>

		<p>Let&#8217;s assume the string returned by SysAllocString happens to have a 0 whcar_t before the end of the buffer. Then bstr will actually get a buffer that is less than 100 characters in length. Now, when subsequent code uses the buffer (assuming 100 characters of space are available), memory corruption can happen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-642263">
				<div id="div-comment-642263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-642263">
			June 27, 2008 at 9:32 am</a>		</div>

		<p>obviously the problem comes down to 1 thing: type safety.</p>
<p>the moment that class decided a BSTR was something else (a LPCTSTR), things started to go wrong.</p>
<p>the moral of this is: always enforce strong typing. Do not use #define to &#8216;reuse&#8217; another type, create a class and give it a few conversion operators.</p>
<p>CComBSTR b = (LPCTSTR)mybstr; is at the very least obvious that you&#8217;ve taken responsibility for the leak, if there were 2 operator= for LPCTSTR and BSTR, then this issue would never arise.</p>
<p>The other thing you could do is remember that CComBSTR is not a smart pointer class, it is a helper for BSTRs like CString is a helper for c-strings. It is not equivalent to CComPtr.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-642383">
				<div id="div-comment-642383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080623-00/?p=21883#comment-642383">
			June 27, 2008 at 1:36 pm</a>		</div>

		<p>&gt;&gt; the moment that class decided a BSTR was something else (a LPCTSTR), things started to go wrong. &lt;&lt;</p>
<p>The class didn&#8217;t decide the BSTR was an LPCTSTR. Someone at Microsoft decided a BSTR was an OLECHAR*.</p>
<p>// from afxwin.h:</p>
<p>typedef OLECHAR* BSTR;</p>
<p>What would you define it as?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>