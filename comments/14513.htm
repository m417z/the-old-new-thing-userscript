<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-821353">
				<div id="div-comment-821353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821353">
			March 23, 2010 at 7:13 am</a>		</div>

		<p>But does this cache thing on the other hand mean, that one could logon on on a machine with an old password as long as it is in the cache? So if you are the only user on this particular machine it would be possible that you could use your old password for ages?</p>
<div class=post>[<i>Check out those links. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-821373">
				<div id="div-comment-821373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821373">
			March 23, 2010 at 8:12 am</a>		</div>

		<p>See also &#8220;tarpitting.&#8221;</p>
<p><a href="http://en.wikipedia.org/wiki/Tarpit_(networking)" target=_new rel=nofollow rel="nofollow">http://en.wikipedia.org/wiki/Tarpit_(networking)</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821383">
				<div id="div-comment-821383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821383">
			March 23, 2010 at 8:45 am</a>		</div>

		<p>My memory is fuzzy but I think the &quot;the bizarro technical support calls&quot; situation did used to happen with NT4 and the screen-lock password.</p>
<p>If you changed your password but then didn&#8217;t log-out and back in, the screenlock continued to require your old password. (Or something like that. It may have only happened when changing it on another machine or via an API taht didn&#8217;t tell the GINA component.)</p>
<p>Long fixed, but a pain (and a good way to instantly forget your new password) at the time.</p>
<p>I&#8217;ve noticed that navigating to non-existent UNC shares also seems to take ages to return an error. If I mis-type a path I can wait a long time, while typing it properly returns it instantly. Not sure if that&#8217;s on purpose or if there&#8217;s a complex series of accidents, in the code and/or my LAN setup, conspiring to make it happen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821403">
				<div id="div-comment-821403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821403">
			March 23, 2010 at 9:38 am</a>		</div>

		<p>So if you&#8217;re not connected to the corporate network and the password cache is disabled it means you can&#8217;t unlock your workstation?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821433">
				<div id="div-comment-821433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pierre B.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821433">
			March 23, 2010 at 10:06 am</a>		</div>

		<p>Joe, I suspect the answer to your second question is also &quot;Check out those links.&quot; I excuse you, because I did check out those links and confronted with those walls of text, I went tl;dr.</p>
<p>(Of course, if I really needed the answer, I&#8217;d Google^H^H^H Bing it instead, in the vain hope someone already distilled the information to a simple answer. Assuming the answer is simple.My hunch is that it depends on obscure policy settings, some registry keys, which version of Windows you use and phases of the moon.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821443">
				<div id="div-comment-821443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">R. Bemrose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821443">
			March 23, 2010 at 10:07 am</a>		</div>

		<p>I recall that Linux (or one of the other UNIX derivatives) used to have a related bug that trying a username that didn&#8217;t exist would return faster than trying a username that does exist with an incorrect password.</p>
<p>Meaning that you could find out whether a user exists by how long it took to return.</p>
<p>As I recall, the developers had to introduce a delay to correct the problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821503">
				<div id="div-comment-821503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy O'Neal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821503">
			March 23, 2010 at 12:24 pm</a>		</div>

		<p>Joe: That is correct. This has happened to me before. I had to login as a local user and connect to the VPN before my domain password would be accepted again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821533">
				<div id="div-comment-821533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pplu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821533">
			March 23, 2010 at 12:53 pm</a>		</div>

		<p>Tarpitting doesn&#8217;t work in all scenarios. It stops working, and actually can hurt you more if the offending party starts to do the queries in parallel&#8230; If their cost to maintain a connection is low, they will just open more connections, and query on one connection while the other ones are waiting. Now you have YAP (Yet Another Problem): the added concurrency :'(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821543">
				<div id="div-comment-821543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821543">
			March 23, 2010 at 1:16 pm</a>		</div>

		<p>Maybe I don&#8217;t get it, but the last paragraph sounds like something you really shouldn&#8217;t rely on.</p>
<p>So you can&#8217;t use the windows login screen, but nobody stopps you from writing your own software to send the necessary data to the controller and see what it says, right?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821553">
				<div id="div-comment-821553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821553">
			March 23, 2010 at 1:34 pm</a>		</div>

		<p>Voo: There&#8217;s nothing stopping the domain controller from not answering you for some amount of time. It could have a delay based on the source or based on the user being queried.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821573">
				<div id="div-comment-821573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://arnshea.blogspot.com/' rel='external nofollow' class='url'>arnshea</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821573">
			March 23, 2010 at 1:43 pm</a>		</div>

		<p>@pplu, imho It&#8217;s all about defense-in-depth. &nbsp;No need to make it easy for password crackers even if there are ways around the delay. &nbsp;Also, as @gabe mentioned, a delay enforced at the server could mitigate an attempt to get around the delay by issuing simultaneous requests.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821593">
				<div id="div-comment-821593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Keith B</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821593">
			March 23, 2010 at 2:03 pm</a>		</div>

		<p>I seem to recall hearing that with some password authentication systems, there&#8217;s also a computational delay involved. Normally, the password database just stores a hash, which it checks against the password, but if that fails, it does some other (high-cost) processing to check another way, just in case. Or something like that.</p>
<p>I could be misremembering, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821613">
				<div id="div-comment-821613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fuzzy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821613">
			March 23, 2010 at 2:30 pm</a>		</div>

		<p>@Keith, you might be thinking about how authentication systems don&#8217;t return immediately after finding an incorrect character in the password. If they did, then a hacker can keep track of the computation times and figure out when he&#8217;s found a matching character (the return time will be slightly higher, since the system has to crunch through at least one more character).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821623">
				<div id="div-comment-821623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821623">
			March 23, 2010 at 3:05 pm</a>		</div>

		<p>@Fuzzy and Keith:</p>
<p>Password-based authentication on Windows is not done by comparing the &quot;cleartext&quot; password that the user enters against the expected value. (So there is no risk of returning quickly and giving an attacker a clue as to which character in the password was invalid).</p>
<p>Passwords are hashed and then stored on the domain controller (and in the local cache too). When a user logs in, the computer checks the hash of the password against the expected hash value. Sometimes the hash is used as input for a second round of hashing, with salt and a random &quot;challenge&quot; value added, so someone can&#8217;t just sniff the network traffic traffic and later authenticate as another user.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821633">
				<div id="div-comment-821633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pplu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821633">
			March 23, 2010 at 3:10 pm</a>		</div>

		<p>@arnshea. Loking a door when the window is open will have no effect. Although the server enforces a delay, the client can still open more connections, thus leaving you with the downside of tarpitting: the added concurrency</p>
<p>Much care has to be taken when implementing effective tarpitting. The game goes this way: the offender will open connections in parallel because these are cheap for him. This will let him get over the delays. On the other hand, the server has to assign the offender a thread or process per connection. Server processes/threads are a precious resource, and are normally limited by configuration to a max clients setting. The offender will cope the delays with parallelism.</p>
<p>If the server delays the &quot;denied&quot; responses&#8230; it will have idle worker threads/processes doing NOTHING, just sleeping, while there are clients that may be wanting to connect, making your memory occupation go up in f(x) of the time you tarpit the clients.</p>
<p>Sometimes it&#8217;s just better to give the &quot;incorrect password&quot; response inmediately, and use alternative (cheaper) tecniques to mitigate attacks: count the number of denied login attempts per unit of time for a client. If the count reaches a threshold you can do better things than delaying the response: drop the connection, LIE to the client and just deny all login attempts, etc.</p>
<p>I&#8217;ve seen systems max out their connections when tarpitting (causing a DOS for the legitimate clients that want to connect), and return to normal when disabling the tarpit.</p>
<p>Note: some servers can attend connections without the costs of a thread or process per connection. In this case the game turns around: the cost of the server maintaing the connection drops, and tarpitting can become effective again</p>
<p>Just my 2cents</p>
<p>Pplu</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821653">
				<div id="div-comment-821653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Absotively</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821653">
			March 23, 2010 at 3:14 pm</a>		</div>

		<p>Pplu: Is there some reason you couldn&#8217;t just not accept multiple connections from the same source?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821673">
				<div id="div-comment-821673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pplu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821673">
			March 23, 2010 at 3:30 pm</a>		</div>

		<p>@Absotively: Yes! Two main reasons:</p>
<p>1- Two different client connections behind a router will appear to come from the same source (you cannot distinguish one from the other).</p>
<p>2- You&#8217;re a service that must accept parallel legitimate connections from the same source. Db servers, HTTP servers, SMTP servers, etc must accept more than one connection from the same source simultaneously. It&#8217;s really hard to think of a service without that requirement.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821683">
				<div id="div-comment-821683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SteveM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821683">
			March 23, 2010 at 5:18 pm</a>		</div>

		<p>That link for how to disable password caches also contains some really misleading information about how caching is such a security risk. That author needs to take a look at this&#8230;.</p>
<p><a rel="nofollow" target="_new" href="http://technet.microsoft.com/en-us/magazine/2009.07.windowsconfidential.aspx" rel="nofollow">http://technet.microsoft.com/en-us/magazine/2009.07.windowsconfidential.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821463">
				<div id="div-comment-821463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821463">
			March 23, 2010 at 10:25 am</a>		</div>

		<p>&gt;&gt; So if you&#8217;re not connected to the corporate network and the password cache is disabled it means you can&#8217;t unlock your workstation? &lt;&lt;</p>
<p>Well, since there&#8217;s no way to validate the domain credentials without a connection to the domain controller in that case, then the logical answer would be that you can&#8217;t unlock your workstation *using domain credentials*.</p>
<p>It&#8217;s still possible to unlock the machine using a machine local account.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821703">
				<div id="div-comment-821703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821703">
			March 23, 2010 at 6:53 pm</a>		</div>

		<p>@pplu: The first reason doesn&#8217;t really matter.</p>
<p>In coparate network environment, there&#8217;s usually only one SMTP server allow to go outside. (A policy to prevent infected computer putting company&#8217;s IP on blacklist)</p>
<p>If it&#8217;s general environment where a few home computer running local SMTP servers, the amount of mail is low and the emails can wait in the mail queue for a few days, so they&#8217;ll eventially be sent. (Usually in this condition the retry will occur very soon, so the delay caused by this tops at about 1-2 hours even in dorm-like environment&#8230; anyway, most ISPs come with their SMTP server service for their users at no extra charge&#8230;)</p>
<p>For the second reason, SMTP of course. (Plus a few FTP servers and a few others for good reason.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821733">
				<div id="div-comment-821733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821733">
			March 23, 2010 at 8:37 pm</a>		</div>

		<p>@Alexander: [quote]2- You&#8217;re a service that must accept parallel legitimate connections from the same source. Db servers, HTTP servers, [b]SMTP servers[/b], etc must accept more than one connection from the same source simultaneously. It&#8217;s really hard to think of a service without that requirement.[/quote]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821743">
				<div id="div-comment-821743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821743">
			March 23, 2010 at 8:49 pm</a>		</div>

		<p>@Alexander: Btw, I&#8217;ll admit that I was in the mindset of &quot;SMTP tarpuit&quot; after reading the wiki like above.</p>
<p>Back on the topic, I agree that it make sense for accepting parallel connection from single source, but it also make sense to set limit for maximum allowed connection from single source so it doesn&#8217;t block others to connect.</p>
<p>It doesn&#8217;t really make sense to allow single IP to block &gt;20% of total allowed connections on usual cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821753">
				<div id="div-comment-821753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821753">
			March 23, 2010 at 9:07 pm</a>		</div>

		<p>The way to protect against a DoS caused by a tarpit is to just disallow multiple connections from a source trying lots of bad passwords. A legitimate connection is extremely unlikely to have even 10 bad passwords consecutively, while an illegitimate connection will have thousands, so it&#8217;s extremely easy to differentiate them.</p>
<p>With an SMTP tarpit you differentiate based on spaminess. The more spam you encounter from a host, the slower you communicate with it, and the fewer connections you allow from it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821763">
				<div id="div-comment-821763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821763">
			March 23, 2010 at 9:31 pm</a>		</div>

		<p>@Gabe: Yes. I remember that something like Bastille firewall from NASA in some very old distro can read verious logs and add IPs for logon failure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821803">
				<div id="div-comment-821803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pplu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821803">
			March 24, 2010 at 1:50 am</a>		</div>

		<p>@Alexander</p>
<p>Why are the progams that follow this way of handling connections &quot;amateurish&quot;? Does the Apache web server appear in your list of &quot;amateurish&quot; software? I think you have called a very big percent of actual server software &quot;amateurish&quot;&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821723">
				<div id="div-comment-821723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821723">
			March 23, 2010 at 8:20 pm</a>		</div>

		<p>@Pplu,</p>
<p>*Sane* applications are not using a thread or process per TCP/IP connection. Only amateurish do.</p>
<p>@Cheong,</p>
<p>Where SMTP came up from? Nobody even mentioned it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821833">
				<div id="div-comment-821833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Wooding</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821833">
			March 24, 2010 at 3:38 am</a>		</div>

		<p>@pplu</p>
<p>I&#8217;ve no idea why you think that handling multiple connections on different threads (or even different processes) means that you can&#8217;t tarpit incorrect passwords effectively. &nbsp;It&#8217;s a simple matter of maintaining a single, properly synchronized tarpit penalty per user.</p>
<p>(I also can&#8217;t really see why nobody else has mentioned this.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821903">
				<div id="div-comment-821903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821903">
			March 24, 2010 at 8:57 am</a>		</div>

		<p>@pplu,</p>
<p>A thread requires certain virtual address space reserved for its stack. Let&#8217;s say, 1MB by default. Then you&#8217;re limited by &lt;2000 threads per process. That is 2000 connections per process. In the very best case. There are also other considerations that will just kill performance with such architecture.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821933">
				<div id="div-comment-821933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">The right way to do it</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821933">
			March 24, 2010 at 10:14 am</a>		</div>

		<p>Usually login tries are handles by 1 process/thread. When a connection is authenticated it spawns a new process/thread which handles the connection from that point.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-821953">
				<div id="div-comment-821953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">does not compute</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821953">
			March 24, 2010 at 10:19 am</a>		</div>

		<p>@Mark: Password-based authentication on Windows is not done by comparing the &quot;cleartext&quot; password that the user enters against the expected value. (So there is no risk of returning quickly and giving an attacker a clue as to which character in the password was invalid).</p>
<p>The hash comparation has the same timing problems as a password comparation. It can not be compared in a atomic operation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-821843">
				<div id="div-comment-821843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JonK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-821843">
			March 24, 2010 at 4:03 am</a>		</div>

		<p>@pplu</p>
<p>Let&#8217;s assume we&#8217;re talking about server applications on Windows. Now, no-one in their right mind builds a server application on the Windows platform using the one-thread-per-connection model and pretty much all the worthwhile advice given in the last fifteen years has reinforced this point: for maximum throughput you should use overlapped IO or completion ports and the thread pool. Thread-per-connection kills you in about eighteen different ways when you&#8217;re operation at scale, among them the cumulative size of all those thread stacks, and the conniptions you cause the Executive (create, say, 3000 runnable threads and watch how the scheduling latency rise), the horrendous impact on memory locality, the cache trashing, yadda yadda yadda. </p>
<p>Sadly, there&#8217;s lots of software that&#8217;s been ported to Windows without making the necessary architectural changes: to pick an example, Asterisk (the VoIP server) is such a horrorshow on Windows because it goes with a two-threads-per-conversation model, which scales really well&#8230; to about twenty concurrent conversations.</p>
<p>So yes, &quot;amateurish&quot; is pretty much the perfect description because a professional software developer won&#8217;t leave until the job&#8217;s done *properly*.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822023">
				<div id="div-comment-822023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pplu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-822023">
			March 24, 2010 at 12:04 pm</a>		</div>

		<p>@Mark Wooding</p>
<p>I haven&#8217;t said that you can&#8217;t tarpit because of using threads/processes per connection.</p>
<p>@Jonk</p>
<p>I&#8217;m more from the unix world, but saying that a server software is amateurly written because it doesn&#8217;t use techique A or B is a bit offensive. I&#8217;ll just wait a while for the next techinques in writing server software to appear. After that I&#8217;ll call the ones that use &quot;overlapped IO or completion ports and the thread pool&quot; amateurish.</p>
<p>@The right way to do it</p>
<p>Yeah&#8230; it&#8217;s a way of lowering the cost of maintaining a connection, and thus making tarpitting &quot;profitable&quot; again. I already said that ;)</p>
<p>@Alexandre</p>
<p>Since you have a limited number of available threads to create, the more you pause your threads in idle time (delaying a response) the less connections will be available for the rest of legitimate clients. That&#8217;s why I wouldn&#8217;t tarpit in that scenario.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822143">
				<div id="div-comment-822143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-822143">
			March 24, 2010 at 3:32 pm</a>		</div>

		<p>@Pplu,</p>
<p>There is a reason select() exists&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822153">
				<div id="div-comment-822153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pplu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-822153">
			March 24, 2010 at 4:06 pm</a>		</div>

		<p>In unix it&#8217;s proven that few threads with async IO/kqueue or similar mechanisms scale orders of magnitude better than one connection per thread/process. IMHO the servers that are written with the old techniques are not amateur. Of course it&#8217;s only my opinion.</p>
<p>I&#8217;m sorry to hear that in Windows the thread per connection scheme doesn&#8217;t scale well enough. I&#8217;ll read a bit about it&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822113">
				<div id="div-comment-822113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-822113">
			March 24, 2010 at 2:18 pm</a>		</div>

		<p>&quot;I&#8217;m more from the unix world, but saying that a server software is amateurly written because it doesn&#8217;t use techique A or B is a bit offensive.&quot;</p>
<p>No, we&#8217;re saying that it&#8217;s amateurishly written because it uses technique C, which is known to not scale. You cannot expect to write (or port) a server without looking at how it will run under load on the OS(es) you&#8217;re targeting &#8212; that&#8217;s the amateurish part. If your server is targeting Windows, then using a thread-per-connection model is acceptable exactly never. Not even if everybody promises it will never handle more than a few connections at a time, ever. Such promises usually turn out to be based on wishful thinking and not enforced architectural constraints.</p>
<p>&quot;I&#8217;ll just wait a while for the next techinques in writing server software to appear. After that I&#8217;ll call the ones that use &quot;overlapped IO or completion ports and the thread pool&quot; amateurish.&quot;</p>
<p>That dog won&#8217;t hunt. On Windows, we&#8217;re talking orders of magnitude difference of scaling between thread-per-connection and overlapped/completion port I/O. New techniques may very well be faster, but probably not orders of magnitude. Even if they are, it will be the case that for most purposes, the existing ones are good enough. Thread-per-connection stops being good enough *very* quickly. As in, you should have seen this during your initial load tests before a single client ever tried to connect.</p>
<p>I&#8217;m not philosophizing from my armchair here, I&#8217;m coming out of a two-day broom closet session where I had to write a (rudimentary) server from scratch to replace our existing one which used a thread-per-connection model (two threads per connection, actually). As it turns out, having 400 threads in your process is&#8230; suboptimal. Aside from ridiculous memory and CPU usage, throughput on this thing is horrendous.</p>
<p>To somewhat get back to the original topic, the kicker is the mechanism implemented to make sure very fast clients don&#8217;t overload the server: a configurable delay applied before sending back each response. Not quite tarpitting, but close. Of course, making your worker threads sleep in the middle of processing just hurts overall throughput even more.</p>
<p>Amateurish or not &#8212; it&#8217;s not pretty.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822173">
				<div id="div-comment-822173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-822173">
			March 24, 2010 at 11:34 pm</a>		</div>

		<p>I absolutely refuse to believe that in any modern system you could reliably detect the difference between comparing a whole password and just part of a password.</p>
<p>A technique you could actually use is to store the password at the end of a memory page where the following page isn&#8217;t valid. Then you could detect a page fault and know that the password is correct up to the last byte in the memory page.</p>
<p>Obviously this whole point is moot because nobody would implement password validation this way anymore, but I believe one system was vulnerable to the page fault detection method once upon a time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822623">
				<div id="div-comment-822623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.org/' rel='external nofollow' class='url'>Bob Bobson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100323-00/?p=14513#comment-822623">
			March 26, 2010 at 9:35 pm</a>		</div>

		<p>An increasing delay on each incorrect password certainly sounds practical and like a good idea, but unfortunately it’s actually kind of specious. Just like teachers who think that theirs is the only class you have (or the only important one), and so assign you lots of homework irrespective of other homework you may already be assigned, every site, company, and device thinks of itself as the only entity in existence, as though they are the only thing in your life, and so you can focus all of your mental faculties on memorizing a long and arcane password. However theirs is not the only password you have to remember, and so most people tend to forget at least the less-frequently used ones.</p>
<p>I’ve been quite frustrated by the delays and limited-attempt features of some sites and such that required logging in. I can understand if my bank’s site makes it a hassle to keep trying, but an online forum? Even the bank is a huge pain in the butt if I have to sodding call them and go through a 30 min. interview and vetting just to get my account unlocked and get a new password (which I have to change to something else anyway). Blerg!</p>
<p>Unfortunately biometrics are not good either, so we are back at square-zero: we need a better way of authenticating logins and nobody seems to have a safe and practical way to do it. :(</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>