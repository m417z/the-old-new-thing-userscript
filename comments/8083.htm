<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (44)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-joshuaganes even thread-even depth-1" id="comment-972683">
				<div id="div-comment-972683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Joshua+Ganes' rel='external nofollow' class='url'>Joshua Ganes</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972683">
			March 16, 2012 at 7:58 am</a>		</div>

		<p>I remember reading a Joel on Software article where Joel describes fixing a bug related to this issue: <a rel="nofollow" target="_new" href="http://www.joelonsoftware.com/articles/fog0000000306.html" rel="nofollow">http://www.joelonsoftware.com/&#8230;/fog0000000306.html</a> &nbsp;Thanks to your description, I think I finally understand what he was talking about.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972693">
				<div id="div-comment-972693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972693">
			March 16, 2012 at 8:07 am</a>		</div>

		<p>What appalling advice today. &nbsp; If you ask for 13 bytes then you can use 13 bytes. &nbsp;No more.</p>
<p>And if Create­Stream­On­HGlobal uses more than the allocated size then the bug is there, &nbsp;not later on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972703">
				<div id="div-comment-972703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tobi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972703">
			March 16, 2012 at 8:10 am</a>		</div>

		<p>Man, this is nasty API behavior. Very easy to misuse.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972713">
				<div id="div-comment-972713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Karas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972713">
			March 16, 2012 at 8:13 am</a>		</div>

		<p>Wow. &nbsp;I think I have written that mistake before. &nbsp;I am glad to have usually relied on helper functions as at least they provide a central place to fix things. &nbsp;But ouch that is a nasty gotcha.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972723">
				<div id="div-comment-972723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/bombsoft_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>bombsoft@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972723">
			March 16, 2012 at 8:25 am</a>		</div>

		<p>@Adam Rosenfield.</p>
<p>I was thinking it had a nice Welsh ring to it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jader3rd odd alt thread-odd thread-alt depth-1" id="comment-972733">
				<div id="div-comment-972733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jader3rd' rel='external nofollow' class='url'>jader3rd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972733">
			March 16, 2012 at 9:05 am</a>		</div>

		<p>One more reason I prefer managed code over native.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972743">
				<div id="div-comment-972743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouse</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972743">
			March 16, 2012 at 9:16 am</a>		</div>

		<p>Argument passed to HeapReAlloc is insufficient.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972753">
				<div id="div-comment-972753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972753">
			March 16, 2012 at 9:32 am</a>		</div>

		<p>@jader3rd: Why? Is it so terrible to get more bytes than you requested? Or that if you ask for the size of a block, you can use all bytes within that size? Or that you should be consistent when asking for zeroed memory? This is all well-documented and the runtime libraries for managed code contain similar contracts and rules that you have to stick to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972763">
				<div id="div-comment-972763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972763">
			March 16, 2012 at 9:54 am</a>		</div>

		<p>Anonymous Coward: My guess is that the answer is &quot;all of the above&quot;. That doesn&#39;t mean that there&#39;s anything terrible about the rules, or even that they&#39;re difficult to follow.</p>
<p>However, every moment spent thinking about memory allocation is a moment that could otherwise be spent thinking about business logic (you know, the reason the program exists in the first place). Writing managed code drastically reduces the cognitive load of housekeeping. Instead of perhaps 5% of code dedicated to resource management in a language like C (where getting it wrong likely means long debug sessions and potential security disasters), a typical C# program might have 0.05% of its code doing resource management.</p>
<p>Of course, the fact that Raymond has to write posts like this means that maybe there is something wrong with the rules, and that they are probably hard to follow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972773">
				<div id="div-comment-972773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972773">
			March 16, 2012 at 10:04 am</a>		</div>

		<p>The clipboard data is an HGlobal. I&#39;m not aware that there is any way to find out how large it is except to call GlobalSize. Have I missed something?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972783">
				<div id="div-comment-972783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972783">
			March 16, 2012 at 10:22 am</a>		</div>

		<p>@Jon: The system is telling you how much it gave you. Though it would be safe to -not- use those bytes, depending on how you use your memory exactly, it&#39;s not like you&#39;re in unallocated memory land. The memory manager is in on those extra bytes, and even wants you to know. Just keep some cases around to account for when you get those &quot;bonus bytes&quot; and move on with life.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972793">
				<div id="div-comment-972793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972793">
			March 16, 2012 at 10:30 am</a>		</div>

		<p>I&#39;ve never understood why someone would create a heap allocator that does not contractually zero out all memory it allocates before returning. &nbsp;That&#39;s just asking for all kinds of trouble.</p>
<p>(And before anyone even thinks about replying and saying &quot;performance,&quot; please test your assumption. Write up a simple routine that allocates a GB or two of RAM, then uses a simple FOR loop to zero it. &nbsp;Time it, and realize that this is a very small amount of time for a very large amount of memory. &nbsp;And keep in mind that a simple FOR loop is a very naive way to zero memory, and there are optimization tricks that can make it even faster.)</p>
<p>Second attempt at posting this&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972813">
				<div id="div-comment-972813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972813">
			March 16, 2012 at 12:33 pm</a>		</div>

		<p>@Mason: &quot;And before anyone even thinks about replying and saying &quot;performance,&quot; please test your assumption. Write up a simple routine that allocates a GB or two of RAM, then uses a simple FOR loop to zero it.&quot;</p>
<p>I&#39;ll do one better.</p>
<p>I&#39;ve written an LD_PRELOAD library that wraps malloc() and calls memset(). I&#39;m measuring the performance of a program/library I&#39;ve worked on with (1) no interposition, (2) interposing but not doing anything, and (3) interposing and memsetting the region to 0.</p>
<p>I actually don&#39;t have much of an idea of what I&#39;ll find&#8230; I would guess that I&#39;ll be able to measure a noticeable performance hit though. We&#39;ll see.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972823">
				<div id="div-comment-972823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972823">
			March 16, 2012 at 12:36 pm</a>		</div>

		<p>@Mason: Suppose a program allocates a large scratch buffer but only ends up using a small portion of that. &nbsp;If you don&#39;t zero out the scratch buffer, then the pages for most of that buffer never get committed and it&#39;s just like you allocated a much smaller buffer. &nbsp;If you do zero it out, you might cause something else to page to disk that wouldn&#39;t otherwise, and paging is definitely not fast.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972833">
				<div id="div-comment-972833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972833">
			March 16, 2012 at 1:20 pm</a>		</div>

		<p>@Mason: &nbsp;Today I would agree with you, but back in the time before time the performance implications were measurable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972843">
				<div id="div-comment-972843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972843">
			March 16, 2012 at 1:21 pm</a>		</div>

		<p>@Adam: In that case, your problem isn&#39;t the allocator; it&#39;s the programmer who went and allocated a buffer that was far larger than he actually needed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972873">
				<div id="div-comment-972873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Not a complaint</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972873">
			March 16, 2012 at 4:43 pm</a>		</div>

		<p>The blog software now requires scripts from aspnetcdn.com to show comments&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-972883">
				<div id="div-comment-972883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972883">
			March 16, 2012 at 5:46 pm</a>		</div>

		<p>If you give a mouse a cookie&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972803">
				<div id="div-comment-972803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972803">
			March 16, 2012 at 11:13 am</a>		</div>

		<p>@Mason: would you care to test *your* assumption on an early C compiler and repeated allocations of small amounts of memory, instead of a big block once? Preferrably on a processor where there are no &quot;optimization tricks&quot; that allow for anything faster than a simple loop?</p>
<p>C sacrifices all manner of things any modern language takes for granted, because it was conceived in an era much different from ours. Although a lot of allocators are from later days, a lot aren&#39;t, and even those that are are just following the philosophy. I for one wouldn&#39;t bet money on the cost of zeroing out memory being insignificant on an 80386 running Windows 95.</p>
<p>I am not advocating that returning uninitialized memory is a good idea in modern times, by the way &#8212; if nothing else, security concerns should override the performance concern. I&#39;m also not saying anything about the HeapAlloc() way of returning more bytes than you asked for, because my mother always told me I should say nothing if I have nothing nice to say.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-972893">
				<div id="div-comment-972893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972893">
			March 16, 2012 at 7:26 pm</a>		</div>

		<p>@Mason: Reading random bytes from non-zeroed memory allocation is a common way for cryptographic functions to gain &quot;salt&quot; in their algorithm for better randomization. Making the default behaviour to zero out memory &quot;will&quot; break these applications.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972913">
				<div id="div-comment-972913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972913">
			March 16, 2012 at 8:03 pm</a>		</div>

		<p>@cheong00: It is a bad way, since that non-zeroed memory can be quite predictable (computers are deterministic), and what non-predictability it has can mask bugs where the RNG is not being seeded properly (as in the infamous Debian OpenSSL fiasco, where the only source of randomness left was the process ID). It made sense in the old days before we could ask the kernel for good-quality randomness (/dev/random, CryptGenRandom, and similar functions), but nowadays it is plain bad coding.</p>
<p>@Evan: your memset is prefaulting the pages. Depending on the allocation and access patterns, this could make a difference. Try reading a single byte every 4k (the most common page size) instead of a memset, and see what effect it has. Also try MADV_WILLNEED instead and see what happens.</p>
<p>It could be the processor caches, but I think prefaulting is a more likely explanation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972853">
				<div id="div-comment-972853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972853">
			March 16, 2012 at 1:25 pm</a>		</div>

		<p>@John: I&#39;m not so sure. &nbsp;Bear in mind that memory and CPU speed tend to increase together. &nbsp;Back in the day, when it would have taken a long time to zero out a gig or two of memory, computers didn&#39;t *have* that much memory, and it wouldn&#39;t have taken long to zero out what they did have.</p>
<p>And now I&#39;m curious as to what the actual effect would have been. &nbsp;Maybe when I get home I&#39;ll have to pull out an ancient Turbo Pascal install and test it out on a DOSBox set up to emulate an 8086&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972863">
				<div id="div-comment-972863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972863">
			March 16, 2012 at 2:07 pm</a>		</div>

		<p>OK, so here are my performance numbers, which are&#8230; surprising. There are two highly-related programs under test, doing two very different operations on related data structures. I ran each program with two inputs. Each was run in three different configurations: (1) normally, (2) with an LD_PRELOAD library wrapping malloc() but not doing anything, and (3) with the wrapper calling memset() after each allocation. This was done on Linux because I have it conveniently available right now and I&#39;m not sure how to interpose on allocations in Windows.</p>
<p>The programs themselves are C++. I&#39;m not positive, but I think most allocations are done by the default STL allocators (which apparently call down to malloc eventually, fortunately), usually by things like sets and maps. The allocations tend to be small but not tiny, being in the area of 60 bytes.</p>
<p>The main number reported below is the median of 5 runs. There was more variation between runs (within a configuration) than I&#39;d expect, so I also give the min and max.) They are the &#39;user&#39; component of what&#39;s reported by the time utility, but the amount spent in other components is trivial.</p>
<p>I don&#39;t claim that this program is representative of all, but I definitely did *not* pick it because I thought it would give any particular output.</p>
<p>Anyway:</p>
<p>Program A, input A:</p>
<p>1. No interposition: 6.40 sec. (Range: 6.17-7.26)</p>
<p>2. Null interposition: 7.49 sec. (Range: 6.21-8.01)</p>
<p>3. Zeroing interposition: 6.49 sec. (Range:6.36-7.19)</p>
<p>(This allocates a total of 559 MB in 9.5 million allocations.)</p>
<p>Program A, input B:</p>
<p>1. No interposition: 160 sec (Range: 133-166)</p>
<p>2. Null interposition: 163 sec (Range: 145-173)</p>
<p>3. Zeroing interposition: 134 sec (Range: 134-166)</p>
<p>(Total: 6.473 GB across 105 million allocations.)</p>
<p>Program B, input A:</p>
<p>1. No interposition: 15.4 sec (Range: 14.7-16.0)</p>
<p>2. Null interposition: 15.3 sec (Range: 14.8-16.0)</p>
<p>3. Zeroing interpositon: 16.2 sec (Range: 15.3-16.7)</p>
<p>(Total: 4.120 GB across 55 million allocations.)</p>
<p>Program B, input B:</p>
<p>1. No interposition: 19.8 sec (Range: 19.7-20.2)</p>
<p>2. Null interposition: 19.9 sec (Range: 19.6-21.2)</p>
<p>3. Zeroing interposition: 20.2 sec (Range: 20.0-20.6)</p>
<p>(Total: 982 MB across 15 million allocations.)</p>
<p>So for program A, the version that called memset was actually *faster* than the null interposition configuration. For program B, it was only slightly slower (by 5% in the worse of the two inputs.)</p>
<p>My guess as to what is going on in program A is that there&#39;s some cache effect. The memset could be causing cache lines to be prefetched (due to the nice, predictable linear pattern) which would cause cache misses under the no interposition version.</p>
<p>If anyone wants the programs and inputs used, I can make them available. If you want to play with this yourself, the wrapper library is at <a rel="nofollow" target="_new" href="http://pastebin.mozilla.org/1522723" rel="nofollow">pastebin.mozilla.org/1522723</a>. (There are some vestigal headers and stuff from another project I copied it from.) You can uncomment the modifications to num_allocations and size_allocations if you want those statistics, and comment out the call to memset() if you want the null interposition configuration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972953">
				<div id="div-comment-972953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">No</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972953">
			March 17, 2012 at 2:38 am</a>		</div>

		<p>Raymond, I&#39;m not going to write programs that assume &quot;bonus bytes&quot; will ever be possible again. They were a bad idea to start with, and they&#39;re an even worse idea today. We&#39;ll never re-enable the feature, and we both know it. I&#39;m not going to waste my time writing code that reacts to cases that won&#39;t happen in reality, and you&#39;re doing disservice to your readers suggesting that they waste their own time. You might as well ask them to prepare for a big-endian Windows, or to maintain the elaborate fiction that CloseHandle doesn&#39;t work on sockets.</p>
<p>No. My code assumes that the OS slowly transitions from insane to sane, and I&#39;m not going to bother preparing programs to run on an OS less sane than the present one. If the OS becomes more insane, that&#39;s a _bug_.</p>
<div class="post">[<i>Then make sure never to use the BSD library, or more generally, <span style="text-decoration:underline;">any other heap library</span>, because if you look closely, <a href="http://tigcc.ticalc.org/doc/alloc.html#HeapSize" rel="nofollow">they all have bonus bytes</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972903">
				<div id="div-comment-972903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972903">
			March 16, 2012 at 7:47 pm</a>		</div>

		<p>@cheong00: &quot;Making the default behaviour to zero out memory &quot;will&quot; break these applications.&quot;</p>
<p>No it won&#39;t. What it *will* do is highlight that those programs are already broken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972923">
				<div id="div-comment-972923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972923">
			March 16, 2012 at 8:06 pm</a>		</div>

		<p>By the way, let me justify that statement a bit.</p>
<p>First, there are already in the field several allocators which zero memory. Windows&#39;s fault-tolerant heap does, I think OpenBSD&#39;s allocator does (or can), and I think the more researchy DieHard does (or can).</p>
<p>Second, there are several situations where even if your allocator doesn&#39;t normally memzet to zero, it can still give you a bunch of zeroes. One obvious one is if that&#39;s what was there last, but arguably that&#39;s just entropy. But one less obvious one is if you&#39;re on Windows and malloc is grabbing actual, fresh memory. When your program requests a new page, it&#39;s at least somewhat likely (I&#39;m not sure *how* likely&#8230; would be an interesting measure) to get a page of all zeroes. Windows has the zero-page thread which does basically what it sounds (memsets unmapped physical pages to 0 when the system isn&#39;t bothering to do anything else), and will prefer to give you a page which has been zeroed out. Voila; your allocation is all zeros with reasonably high priority.</p>
<p>(To my knowledge, Linux doesn&#39;t do this. Personally, I think it&#39;s absurd that OSes will hand out non-zeroed memory to processes. Even Windows will do this if the ZPT can&#39;t keep up with demand. I wouldn&#39;t be surprised if you could come up with a reliable exploit based on the fact that they don&#39;t. In fact, I&#39;d be surprised if you couldn&#39;t.)</p>
<p>Third, even things which are arbitrary are often still deterministic. How much entropy does that uninitialized block of memory have, after all? There&#39;s *no way* to know that. It could be completely-deterministically set! And then it&#39;s buying you nothing.</p>
<p>Fourth, the C standard makes no guarantee about what malloc gives you. An implementation is entirely within its rights to zero out the blocks. If you assume that it doesn&#39;t, you&#39;re not portable. (And as the first point says, this is more than a theoretical concern.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972963">
				<div id="div-comment-972963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972963">
			March 17, 2012 at 4:05 am</a>		</div>

		<p>[Blog software ate my comment]</p>
<p>I always thought it was odd of C not to let you know how many bonus bytes you got (realloc seems to need to know).</p>
<p>I notice that sqlite actually wants to know the number of bonus bytes in advance, although it only seems to need it to avoid computing memory statistics for a realloc which is likely to return the original memory block.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972933">
				<div id="div-comment-972933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972933">
			March 16, 2012 at 9:23 pm</a>		</div>

		<p>OK, one more post for me for the night. Hopefully this isn&#39;t a double post.</p>
<p>It looks like I was sort of off base with this claim: &quot;To my knowledge, Linux doesn&#39;t do this. Personally, I think it&#39;s absurd that OSes will hand out non-zeroed memory to processes. Even Windows will do this if the ZPT can&#39;t keep up with demand. I wouldn&#39;t be surprised if you could come up with a reliable exploit based on the fact that they don&#39;t. In fact, I&#39;d be surprised if you couldn&#39;t.&quot;</p>
<p>Linux *does* only give out zeroed pages, which is good. This is definitely true for mmap() (at least the manpage says so anyway), and by experimentation is true for malloc() as well. In my defense, the man page for mmap() explicitly says that memory is initialized to zero because of the security implications. :-) (There is a configuration to turn off the zeroing, but it&#39;s not on by default.) I just think it probably does it on allocation, rather than in the background like Windows&#39;s ZPT.</p>
<p>I&#39;m not sure what the story is on Windows. You can definitely call malloc() and get back non-zero memory, but I&#39;m not sure it&#39;s coming through from another process unmodified. I was looking at some memory dumps and there are patterns in it that I wouldn&#39;t expect if that were the case. I was also unable to read some stale data from another process (which I&#39;d have expected to be able to do), even if I allocated and searched all physical memory.</p>
<p>@@Cesar: &quot;what non-predictability it has can mask bugs where the RNG is not being seeded properly (as in the infamous Debian OpenSSL fiasco, where the only source of randomness left was the process ID)&quot;</p>
<p>That&#39;s sort of accurate, but not quite. What happened was that OpenSSL was using some uninitialized buffers to possibly increase entropy. (However, at no point did they *rely* on that being the case, and their implementation would have been fine with a zeroing malloc.)</p>
<p>Valgrind whined about this, at a couple calls to a function MD_Update(). One of those calls could be safely removed, and it was actually surrounded by &#39;#ifndef PURITY&#39; for that reason. However, the Debian maintainer removed *both* calls&#8230; and the other call could *not* be safely removed. But that&#39;s exactly what happened.</p>
<p>(The reason the second call could not be removed has nothing to do with the fact that it was reading uninitialized memory some of the time.) See <a rel="nofollow" target="_new" href="http://research.swtch.com/openssl" rel="nofollow">research.swtch.com/openssl</a> for a good description of the problem.</p>
<p>So it wasn&#39;t really that the uninitialized reads were masking a problem, it was that the Debian maintainer went too far in removing the uninitialized reads and removed critical code as well. This removed the uninitialized reads, but also removed the actual randomization. :-)</p>
<p>@Cesar: &quot;our memset is prefaulting the pages. Depending on the allocation and access patterns, this could make a difference&quot;</p>
<p>I&#39;ll check out your options too.</p>
<p>If anyone has ideas of how to interpose on Windows programs too, I can try it there as well. (Detours maybe?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-972973">
				<div id="div-comment-972973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/analisnudesette_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>analisnudesette@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972973">
			March 17, 2012 at 6:07 am</a>		</div>

		<p>&quot;I&#39;m not going to bother preparing programs to run on an OS less sane than the present one.&quot;</p>
<p>I&#39;m not looking forward to Windows 8 either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972983">
				<div id="div-comment-972983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972983">
			March 17, 2012 at 8:40 am</a>		</div>

		<p>&quot;I&#39;m not going to bother preparing programs to run on an OS less sane than the present one.&quot;</p>
<p>So you program by happenstance? Or are you the recognized ultimate authority on sanity? There might be tradeoffs you are unaware of, or which don&#39;t touch you because you dedicated your whole computer to running your freecell-clone. Even if there was no tradeoff involved, you expect to figure everyone to be aware of all the ripples a slight optimization/security fix might have somewhere &#39;obviously&#39; unrelated, which then still work according to contract, maybe even better, but not quite the same? There might be sound reason behind those restrictions.</p>
<p>By the way, what about covariant return types? Want to forbid that too? Those objects don&#39;t react quite the same&#8230; Isn&#39;t that insane? And that works in VM-languages too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-973003">
				<div id="div-comment-973003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973003">
			March 17, 2012 at 10:15 am</a>		</div>

		<p>@Evan: Great link. The point I was trying to make is also expressed in it: &quot;Throwing the pid into the entropy pool on each call to RAND_bytes isn&#39;t actually helping create entropy, but it does keep the buggy Debian version from being completely deterministic. If it had been completely deterministic, the bug would likely have been noticed much sooner&quot;. The same could happen if you add the junk you got in memory from a malloc() call; it is quite possible that this junk has only a few bits of entropy, but these few bits would prevent it from returning the same result every time, thus masking the bug (it would be quite obvious if the same result happened every time).</p>
<p>And yeah, the Linux kernel will always return a zeroed page when you actually access pages newly allocated from user space. In kernel space, of course, it is a different story; there you have to request a zeroed page explicitly (not unlike what you have to do with malloc versus calloc, or going back to the original subject with HeapAlloc).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-973013">
				<div id="div-comment-973013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973013">
			March 17, 2012 at 10:43 am</a>		</div>

		<p>@Raymond: &quot;Note that this gotcha is not specific to Windows.&quot;</p>
<p>A lot of the things you talk about are not specific to Windows. That is probably why you seem to have so many non-Windows developers following your blog. Even when you talk about a Windows function, the underlying issues often also exist elsewhere.</p>
<p>But this particular problem is probably less common on Unix-style systems. At least as far as I can see, the POSIX standard does not have a malloc_size() or malloc_usable_size() function. People wanting to be portable will thus avoid depending on these functions.</p>
<p>A quick search for malloc_usable_size tells me, on the first page, that it is buggy on glibc when MALLOC_CHECK_ (a debugging aid) is enabled, that it does not exist on uclibc, and that it used to exist but does not anymore on Android&#39;s libc (all three are different implementations of the standard C library for Linux). So depending on it will only bring you headaches.</p>
<div class="post">[<i>But it does exist in BSD, and BSD is a pretty common baseline. Many other heap implementations expose bonus bytes. If your policy is &quot;do not call functions that expose bonus bytes&quot;, then you can add this article to your collection of reasons why. it also means you can tell people who ask &quot;How can I figure out the size of an allocated heap block?&quot; that they&#39;re screwed. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-973023">
				<div id="div-comment-973023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973023">
			March 17, 2012 at 11:12 am</a>		</div>

		<p>@Evan Interesting results for your runs. And yes I&#39;d be interested in your programs, although personally getting the runtimes and not only min-max-avg ranges would be good enough for me too (5 runs per config is better than most people bother, but the usual recommendation is more 20-30; but obviously that takes lots of time). Seems to me your std will probably be pretty high and the differences aren&#39;t that big.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-973033">
				<div id="div-comment-973033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">No</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973033">
			March 17, 2012 at 1:51 pm</a>		</div>

		<p>Raymond, while other heap libraries provide &quot;bonus bytes&quot;, none of them is insane enough to make these bonus bytes affect user-visible behavior. That&#39;s the insane part, and that&#39;s what I refuse to accommodate in my programs.</p>
<div class="post">[<i>Um, <code>malloc_size</code> exposes the bonus bytes, and once the bonus bytes are exposed, you have this problem. Or is <code>malloc_size</code> just a figment of my imagination? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-973043">
				<div id="div-comment-973043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nobugz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973043">
			March 17, 2012 at 2:49 pm</a>		</div>

		<p>Oh, nice trap! &nbsp;One optimization too many, but sure, hind-sight is 20-20. &nbsp;Been running into that a lot lately, the C++ compiler committed that sin and it seems hard to un-sin it. &nbsp;/vm has been quite troublesome again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-972993">
				<div id="div-comment-972993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Buchan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-972993">
			March 17, 2012 at 8:51 am</a>		</div>

		<p>@Evan: Windows guarantees that freshly accessed private pages are demand-zeroed &#8211; the zero page thread is filling the zero page *cache* so demand-zeroed pages can be satisfied faster. I would be horrified if Linux didn&#39;t do the same: it&#39;s obviously a huge security hole.</p>
<p>I like the free bytes in theory, but I hardly ever bother with *Size() except as an optimization for implementing (my)vector::reserved() (in toy projects, not production!) Is nice to point out that *ReAlloc() doesn&#39;t zero the spare bytes for you, but I *would* lay the blame at not matching memory was zeroed myself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-973053">
				<div id="div-comment-973053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jolyon Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973053">
			March 18, 2012 at 4:44 pm</a>		</div>

		<p>@Gabe &#8211; managed code encourages you to think less about things that sometimes you cannot avoid having to think about. &nbsp;The overall effect of managed code is therefore to increase the opportunity for accidental error, NOT to reduce it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-973063">
				<div id="div-comment-973063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973063">
			March 19, 2012 at 6:07 am</a>		</div>

		<p>If Raymond is right, then the description of HEAP_ZERO_MEMORY in the HeapRealloc documentation (<a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366704%28v=vs.85%29.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa366704%28v=vs.85%29.aspx</a>) is misleading or incomplete. The MSDN descriptions of the heap allocation functions all refer only to the size the application requests, so my expectation is that HeapRealloc will zero out any new memory outside the size given before to HeapAlloc() or HeapRealloc(). There is no hint that you are supposed to not &quot;mix&quot; the usage of HEAP_ZERO_MEMORY.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-973073">
				<div id="div-comment-973073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973073">
			March 19, 2012 at 6:32 am</a>		</div>

		<p>[Um, malloc_size exposes the bonus bytes, and once the bonus bytes are exposed, you have this problem. Or is malloc_size just a figment of my imagination? -Raymond]</p>
<p>But the HeapRealloc() behaviour does not use a user-provided size. HeapRealloc() does the equivalent of a HeapSize() when deciding what to zero, and that&#39;s wrong. The programmer should only be bitten by the existence of bonus bytes if they&#39;ve explicitly asked about them, and used the result. &nbsp;</p>
<p>If I call malloc_size() and use the result, I&#39;m acknowledging that I want the bonus bytes, if I don&#39;t call malloc_size(), the existence of those bonus bytes should be invisible to me. &nbsp;In not honoring that HeapRealloc() breaks that principle. &nbsp;If I ask for 13 bytes, the allocator can assign me as big a block as it likes, but must behave in a way consistent with having given me 13. &nbsp;HEAP_ZERO_MEMORY does not do that, and the documentation does not mention that &quot;original size&quot; means &quot;size originally allocated&quot; and not &quot;size originally requested&quot;. It&#39;s a bug. And if OSX offers a reallocation function with the same semantics and documentaion, that&#39;s a bug too.</p>
<div class="post">[<i>So you&#39;re saying that <code>HeapRealloc</code> should change its behavior depending on whether <code>malloc_size</code> has ever been called on that block? That seems awfully strange. &quot;I have a bug that goes away when I turn on debugging.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-973503">
				<div id="div-comment-973503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tsss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973503">
			March 20, 2012 at 5:23 am</a>		</div>

		<p>To use HeapSize() or malloc_size() is a WTF. If some application needs to use the allocation overhead: How will it work when an allocator provides very small overhead, or no overhead at all? What is a good usage of this unpredictable, but small amount of extra memory? Sounds complicated to me, and makes automatic validation of dynamic memory usage hard (after all, the application is expected to access only the requested memory, but not to touch memory beyond that size).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-973723">
				<div id="div-comment-973723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973723">
			March 20, 2012 at 11:56 am</a>		</div>

		<p>@Evan IIRC, what Linux does is it has a &quot;master&quot; zero page, and all allocated pages are born as copy-on-write from that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-973733">
				<div id="div-comment-973733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973733">
			March 20, 2012 at 12:10 pm</a>		</div>

		<p>In the code</p>
<p>BYTE *ReallocAndZero(BYTE *bytes, SIZE_T newSize)</p>
<p>{</p>
<p> SIZE_T oldSize = HeapSize(GetProcessHeap(), bytes);</p>
<p> BYTE *newBytes = (BYTE*)HeapReAlloc(bytes, GetProcessHeap(),</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0, size);</p>
<p> if (newBytes &amp;&amp; newSize &gt; oldSize) {</p>
<p> &nbsp;ZeroMemory(newBytes + oldSize, newSize &#8211; oldSize);</p>
<p> }</p>
<p> return newBytes;</p>
<p>}</p>
<p>should size be newSize?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-973813">
				<div id="div-comment-973813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973813">
			March 21, 2012 at 12:27 am</a>		</div>

		<p>I believe Windows also gives out zeroed pages. If the ZPT is empty, then allocations manually zero it.</p>
<p>This is for security and other reasons. However, it&#39;s still possible to get a non-zeroed buffer since the page may have been given to you earlier and recycled. So Windows will give a process a new zeroed page. But that page can be scribbled upon by the process long before the code using it checks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-973893">
				<div id="div-comment-973893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083#comment-973893">
			March 21, 2012 at 12:30 pm</a>		</div>

		<p>@Evan:</p>
<p>| I&#39;m not sure what the story is on Windows. You can definitely call malloc()</p>
<p>| and get back non-zero memory, but I&#39;m not sure it&#39;s coming through from</p>
<p>| another process unmodified.</p>
<p>malloc() is a routine provided by the C runtime library, not the Win32API.</p>
<p>For the latter, see <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/aa366781.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa366781.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>