<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (17)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-210653">
				<div id="div-comment-210653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210653">
			September 15, 2004 at 7:11 am</a>		</div>

		<p>Shouldn&#8217;t that while condition be &quot;!= lOriginal&quot;?  I thought InterlockedCompareExchange returned the initial value of the destination, and we want to keep looping if the result wasn&#8217;t what we expected.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210663">
				<div id="div-comment-210663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210663">
			September 15, 2004 at 7:35 am</a>		</div>

		<p>D&#8217;oh! You&#8217;re right.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210673">
				<div id="div-comment-210673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210673">
			September 15, 2004 at 7:42 am</a>		</div>

		<p>Spelled Interlocked wrong in title:<br />
<br />&gt;Inerlocked&lt; operations don&#8217;t solve everything </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210733">
				<div id="div-comment-210733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Seth McCarus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210733">
			September 15, 2004 at 10:32 am</a>		</div>

		<p>Okay, two simple and probably stupid questions:</p>
<p>Why is there not InterlockedAssign function?  (I guess InterlockedExchange could be used there, but still&#8230;)</p>
<p>How can one iterate a list created with InitializeSListHead?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210753">
				<div id="div-comment-210753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210753">
			September 15, 2004 at 10:45 am</a>		</div>

		<ol>
<li>Please read the linked page that opens the article.<br />
<br />2. You can&#8217;t walk a linked list atomically.</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210763">
				<div id="div-comment-210763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Seth McCarus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210763">
			September 15, 2004 at 11:04 am</a>		</div>

		<p>What about on a multiprocessor system?  If two CPUs try to write to the same memory location &quot;simultaneously,&quot; would there not be problems?</p>
<p>Maybe synchronization is performed on a hardware level??</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210783">
				<div id="div-comment-210783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jordan Russell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210783">
			September 15, 2004 at 11:09 am</a>		</div>

		<p>An &quot;InterlockedAssign&quot; function would be handy because while writes to aligned 32-bit variables are always atomic, they&#8217;re not always <em>ordered</em> on non-x86 platforms as explained at &lt;<a target="_new" href="http://msdn.microsoft.com/library/en-us/dllproc/base/synchronization_and_multiprocessor_issues.asp&gt;" rel="nofollow"></a><a href="http://msdn.microsoft.com/library/en-us/dllproc/base/synchronization_and_multiprocessor_issues.asp&#038;gt" rel="nofollow">http://msdn.microsoft.com/library/en-us/dllproc/base/synchronization_and_multiprocessor_issues.asp&#038;gt</a>;. That article suggests using InterlockedExchange instead of a direct assignment, but that seems like overkill on platforms where writes are always ordered, e.g. x86.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210823">
				<div id="div-comment-210823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210823">
			September 15, 2004 at 2:03 pm</a>		</div>

		<p>The MSDN article that Jordan referred to is not quite correct, by the way:</p>
<p><a target="_new" href="http://groups.google.com/groups?selm=3f79e7ee%241%40news.microsoft.com&amp;output=gplain" rel="nofollow">http://groups.google.com/groups?selm=3f79e7ee%241%40news.microsoft.com&#038;output=gplain</a></p>
<p>Win32 should have provided a memory barrier macro/intrinsic that is guaranteed to be respected by both the compiler and hardware. As far as I know, there&#8217;s still no such thing (there are various bits and pieces like the MemoryBarrier macro but nothing that prevents both CPU and compiler reordering).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210833">
				<div id="div-comment-210833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.foxyshadis.com' rel='external nofollow' class='url'>foxyshadis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210833">
			September 15, 2004 at 2:11 pm</a>		</div>

		<p>Interestingly, one of the best explanations of ABA google came up with was in this blog.</p>
<p><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2004/08/17/215682.aspx#217600" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2004/08/17/215682.aspx#217600</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210723">
				<div id="div-comment-210723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jeffdav' rel='external nofollow' class='url'>jeffdav</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210723">
			September 15, 2004 at 10:23 am</a>		</div>

		<p>I came across someone who really did not understand InterlockedIncrement() once.  I had to remove the following:</p>
<p>/* Synchronization */<br />
<br />#define InterlockedIncrement(plong) (++(*(plong)))<br />
<br />#define InterlockedDecrement(plong) (&#8211;(*(plong)))</p>
<p>I was sad.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210773">
				<div id="div-comment-210773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.trilithium.com/' rel='external nofollow' class='url'>Johan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210773">
			September 15, 2004 at 11:06 am</a>		</div>

		<p>It&#8217;s not clear to me what the intended memory access/ordering semantics of the plain (non-*Acquire/*Release) Interlocked* operations are. The documentation says nothing about it, but there&#8217;s an IA64-specific note indicating an associated *full* memory barrier. Is that the intended semantics? Or was that fence just added to avoid breaking all the existing code which assumes an x86-like memory model?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210873">
				<div id="div-comment-210873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lowercase josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210873">
			September 16, 2004 at 3:12 am</a>		</div>

		<p>If I&#8217;m not mistaken, what you have to lock for the critical section to work is the data, not the code.  If all access to that data goes through the same critical section, that first InterlockedMultiply would work correctly.  To me, &quot;critical section&quot; seems to imply a &quot;section&quot; of code, but you nearly always want to lock the data.  :/</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210883">
				<div id="div-comment-210883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210883">
			September 16, 2004 at 6:00 am</a>		</div>

		<p>Why are they called the interlocked functions rather than the atomic functions? ie AtomicIncrement etc. That would be a slightly more intuitive name (albiet, doesn&#8217;t sound as cool :)</p>
<p>Seth: yes the sync is done with hardware.</p>
<p>InterlockedCompareExchange() is some assembly like this:</p>
<p>lock cmpxchg a, b</p>
<p>The lock prefix causes the CPU to perform a &quot;bus assert&quot; which basically locks the bus. It prevents other processors from accessing memory while the bus is held. At least this is my understanding.</p>
<p>After a bus assert I suppose the CPU clears the dcache but now I&#8217;m just guessing :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210893">
				<div id="div-comment-210893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MikeF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210893">
			September 16, 2004 at 6:38 am</a>		</div>

		<p>Possibly silly question: What is the &quot;critical section bottleneck&quot;, and why is looping over a cmpxchg better?</p>
<p>My understanding is that a pure critical section approach (a) lets the OS sleep the blocked thread, and (b) wastes less time than the cmpxchg loop anyway.</p>
<p>I&#8217;m almost certainly missing something here but I can&#8217;t see what. Is the overhead on critical sections particularly big?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210913">
				<div id="div-comment-210913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Seth McCarus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210913">
			September 16, 2004 at 7:11 am</a>		</div>

		<p>Thanks for your answers, Raymond and Mike.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210953">
				<div id="div-comment-210953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-210953">
			September 16, 2004 at 8:10 am</a>		</div>

		<p>Mike wrote: &quot;After a bus assert I suppose the CPU clears the dcache but now I&#8217;m just guessing :)&quot;</p>
<p>That would take far too long. Actually processors in SMP systems obey a cache coherency protocol which ensures that memory that&#8217;s been modified in cache but not yet written back is forwarded from processor to processor (possibly by writing it back to memory first) and memory that&#8217;s about to be modified by one processor is invalidated in the caches of the others.</p>
<p>The problems of memory coherence are not due to caching but to reordering of instructions in the processor core and of memory operations issued by the processor core to its cache(s).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-211193">
				<div id="div-comment-211193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Trent Glascock</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040915-00/?p=37863#comment-211193">
			September 16, 2004 at 12:35 pm</a>		</div>

		<p>MikeF: Waiting on a critical section is an expensive operation.  So expensive that on multi-processor systems you can elect to &quot;spin&quot; before waiting on the critical section.  The code  in the original post could loop through a hundred iterations and still come out ahead of waiting on a busy critical section.</p>
<p>See InitializeCriticalSectionAndSpinCount</p>
<p><a target="_new" href="http://msdn.microsoft.com/library/en-us/dllproc/base/initializecriticalsectionandspincount.asp" rel="nofollow">http://msdn.microsoft.com/library/en-us/dllproc/base/initializecriticalsectionandspincount.asp</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>