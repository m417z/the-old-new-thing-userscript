<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (26)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-882903">
				<div id="div-comment-882903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vilx-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882903">
			December 17, 2010 at 7:50 am</a>		</div>

		<p>Does this not fall in the category of &quot;undocumented implementation-specific hacks that you should avoid&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-882913">
				<div id="div-comment-882913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882913">
			December 17, 2010 at 8:17 am</a>		</div>

		<p>Nice. By using the prefix rule this even avoids undefined behavior in C98.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-882923">
				<div id="div-comment-882923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Francis Gagne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882923">
			December 17, 2010 at 8:19 am</a>		</div>

		<p>@Vilx-</p>
<p>If this is a hack, then object-oriented programming (and virtual functions, in particular) is a hack. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-882933">
				<div id="div-comment-882933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882933">
			December 17, 2010 at 8:57 am</a>		</div>

		<p>Reminds me of async I/O in classic Mac OS, where people did the same thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-882943">
				<div id="div-comment-882943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882943">
			December 17, 2010 at 9:31 am</a>		</div>

		<p>Isn&#39;t everything passed in Win API by address?</p>
<p>Looks like it &#8212; however, there is PtInRect()&#8230; weird exception.</p>
<div class="post">{<i>The point is that it is both passed <span style="text-decoration:underline;">and returned</span> by address. You are basically using a lookup table where the lookup key is the address itself. It turns out that implementing such a table is easy since it&#39;s a nop. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-882953">
				<div id="div-comment-882953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882953">
			December 17, 2010 at 9:40 am</a>		</div>

		<p>@yuhong2: IIRC (it&#39;s been awhile for obvious reasons) Mac Classic not only &quot;allowed&quot; you to do this, but it was officially supported, if you were coding in C.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-882963">
				<div id="div-comment-882963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882963">
			December 17, 2010 at 10:17 am</a>		</div>

		<p>Seems like this technique would be vulnerable to slicing, especially if there&#39;s a filter driver in the middle which assumes the OVERLAPPED pointer points to, um, an OVERLAPPED-size chunk of memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-882973">
				<div id="div-comment-882973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882973">
			December 17, 2010 at 10:28 am</a>		</div>

		<p>@Maurits, well in that case the application programmer will wring the filter driver programmer&#39;s neck.</p>
<p>Slicing only happens if the address changes, which also causes the lookup table and other reasonable methods to break.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-882993">
				<div id="div-comment-882993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882993">
			December 17, 2010 at 10:32 am</a>		</div>

		<p>@Maurits: that wouldn&#39;t be slicing, which would be trying to force an OVERLAPPEDEX sized struct through an OVERLAPPED size hole. As it happens, pointers to either of these types do actually point to an OVERLAP-sized chunk of memory.</p>
<p>On the other hand, and as Raymond pointed out, anyone who wants to use the -EX information has to know that the pointer actually points to something thats OVERLAPEX sized, via some mechanism, including any intermediate filter drivers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883023">
				<div id="div-comment-883023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883023">
			December 17, 2010 at 11:18 am</a>		</div>

		<p>@vilx:</p>
<p>The GetQueuedCompletionStatus documentation says explicitly that it returns the same OVERLAPPED address that was passed for the IO operation call. Thus, it&#39;s not an implementation-specific hack.</p>
<p>@Maurits, waleri:</p>
<p>Drivers don&#39;t even see or care about OVERLAPPED. It&#39;s IO manager concept, hidden from the drivers. And it&#39;s associated with the original IRP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-883033">
				<div id="div-comment-883033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883033">
			December 17, 2010 at 1:01 pm</a>		</div>

		<p>Sure&#8230; I&#39;d just be a lot more comfortable expanding the size of a structure if it was a bona fide variable-sized structure (like SP_DEVINFO_DATA, say) with a .cbSize member that said how big the chunk of memory was.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883043">
				<div id="div-comment-883043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883043">
			December 17, 2010 at 2:20 pm</a>		</div>

		<p>@Maurits</p>
<p>You&#39;re missing the point. This is no different from the C example (where the variables just happen to follow the OVERLAPPED) it just saves typing and the need to use CONTAING_RECORD macro. The ReadFile etc. functions don&#39;t carre that you&#39;ve expanded the structure. They just use the bit that&#39;s for them and ignore the rest. It&#39;s perfectly safe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883053">
				<div id="div-comment-883053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">scorpion007</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883053">
			December 17, 2010 at 3:40 pm</a>		</div>

		<p>@Kyle, do you also shudder when casting from an int to a float generates code for the conversion? Surely you do this all the time (perhaps without realising it).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-883063">
				<div id="div-comment-883063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883063">
			December 17, 2010 at 4:17 pm</a>		</div>

		<p>They (ReadFile, WriteFile, DeviceIoControl) happen not to care today, but there&#39;s nothing in the interface declaration that says they will continue not to care forever. &nbsp;Plenty of functions take members by reference and then marshal the memory; passing extended blocks of memory to such functions will suffer from slicing. &nbsp;If you&#39;re lucky you&#39;ll AV when the &quot;wrong&quot; memory is accessed; if you&#39;re unlucky you&#39;ll stagger on for a while with garbage data being passed around.</p>
<p>Now that Raymond has outed this technique, I suppose the likelihood that a future version will break this drops substantially.</p>
<div class="post">[<i>Even if the OVERLAPPED is marshalled, the documentation says that the lpOverlapped passed to the completion function or the completion port is numerically identical to the one passed to ReadFile/WriteFile/whatever. So say it&#39;s marshalled. The marshaller copies only sizeof(OVERLAPPED) bytes into kernel mode. Kernel mode operates on sizeof(OVERLAPPED) bytes. When the call completes, kernel mode copies sizeof(OVERLAPPED) bytes back to the original buffer. You then receive a pointer to that original buffer, and you can access the bonus data you stored immediately after it. As far as the kernel is concerned, your bonus data is totally unrelated to the OVERLAPPED structure. It just happens to occupy adjacent memory. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883083">
				<div id="div-comment-883083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thorsten</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883083">
			December 17, 2010 at 5:15 pm</a>		</div>

		<p>@Maurits,the documentation already explicitly states that the pointer you get back is the same pointer that was passed in. This automatically excludes any possibility of slicing. There is absolutely nothing new in Raymond&#39;s post here except explicitly stating the consequences of the documented API behaviour and the pattern this behaviour enables for the few people that can&#39;t figure it out on their own.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883093">
				<div id="div-comment-883093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883093">
			December 17, 2010 at 5:16 pm</a>		</div>

		<p>I dont think that some of you understand.</p>
<p>When you pass the pointer by its value (memory offset to where it points), there is no way for the called function to alter your codes perception of that value (where it points) unless it is the returned value of the function.</p>
<p>For example, x = foo(x)</p>
<p>The C abstract machine does not pass changes to parameters back to the caller, regardless of what they are. When you wish to do that sort of thing, you pass the value of a pointer and then the function can write to the memory it points to but cannot change the callers pointer value itself (you would need a pointer to a pointer&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-883103">
				<div id="div-comment-883103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883103">
			December 17, 2010 at 5:56 pm</a>		</div>

		<p>I see, the sample here (which counts as documentation) relies on this:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/aa365601(v=VS.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa365601(v=VS.85).aspx</a></p>
<p>&quot;The parameters of the ReadFileEx and WriteFileEx functions specify a completion routine and a pointer to an OVERLAPPED structure. This pointer is passed to the completion routine in its lpOverLap parameter. Because the OVERLAPPED structure points to the first member in the structure allocated for each pipe instance, the completion routine can use its lpOverLap parameter to access the structure for the pipe instance.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-882983">
				<div id="div-comment-882983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kyle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-882983">
			December 17, 2010 at 10:30 am</a>		</div>

		<p>@Francis</p>
<p>Yeah, and multiple inheritance would be *really* hacky. &nbsp;I shudder at the thought of type-casting actually resulting in code generation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883013">
				<div id="div-comment-883013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883013">
			December 17, 2010 at 10:53 am</a>		</div>

		<p>I don&#39;t think filter driver would be a problem, because:</p>
<p>a) Driver will simply pass same OVERLAPPED* to the next driver</p>
<p>b) Will create another (own) instance of OVERLAPPED, pass it along and upon completion will notify the original OVERLAPPED*</p>
<p>I believe, in terms of drivers, IRP is the word and it is pretty much the same logic</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883113">
				<div id="div-comment-883113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883113">
			December 17, 2010 at 11:49 pm</a>		</div>

		<p>@Joseph: Sorry, but it appears that you didn&#39;t understand the topic&#8230; at all. What you say has nothing to do with the things discussed here. Nobody is even remotely arguing that e.g. ReadFile magically changes the pointer it was given as a parameter&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883123">
				<div id="div-comment-883123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ricardo Costa</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883123">
			December 18, 2010 at 12:02 am</a>		</div>

		<p>Raymond, I believe the C++ example is not correct since the position of the base class subobject in the derived class is unspecified according to ISO C++ 2003 Standard (10-3, page 168), and you assume that the base class subobject is always at the beginning. The C example would be fine in C++ too, so I&#39;d stick with it.</p>
<div class="post">[<i>The code does not make this assumption. That&#39;s why it&#39;s important to use static_cast instead of reinterpret_cast. Try it: Add a virtual method to OVERLAPPED (so a vtable goes in front) and observe what the compiler does. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883133">
				<div id="div-comment-883133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883133">
			December 18, 2010 at 12:40 am</a>		</div>

		<p>@Ricardo: You might also want to read up on chapter 9-2, point 17, where a pointer to a POD structure is guaranteed to be pointing to its first member.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883143">
				<div id="div-comment-883143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883143">
			December 18, 2010 at 1:25 am</a>		</div>

		<p>&quot;you assume that the base class subobject is always at the beginning.&quot; IIRC, if it&#39;s not, then the static_cast from one pointer type to another will alter the address accordingly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883223">
				<div id="div-comment-883223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883223">
			December 20, 2010 at 7:53 am</a>		</div>

		<p>static_cast&lt;&gt; is not intended for casting base types to derived. &nbsp;That&#39;s error prone. &nbsp;dynamic_cast&lt;&gt; does exactly what you&#39;d like, and as long you check for a null result, actually provides type-safety, which competent programmers consider to be a good thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883263">
				<div id="div-comment-883263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymouse</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883263">
			December 20, 2010 at 8:57 am</a>		</div>

		<p>GWO: You can&#39;t use dynamic_cast&lt;&gt; to cast from OVERLAPPED* to a derived class. &nbsp;This is because OVERLAPPED doesn&#39;t have any virtual members, so it doesn&#39;t have a virtual function table, so there&#39;s nowhere for the compiler to put the type information needed by dynamic_cast&lt;&gt;.</p>
<p>static_cast&lt;&gt; is the right thing to use here.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883303">
				<div id="div-comment-883303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101217-00/?p=11983#comment-883303">
			December 20, 2010 at 10:58 am</a>		</div>

		<p>In DDK, there is a macro (can&#39;t remember the name right now) that calculates address of a base type from a member address. Same can be used in this case. Not as safe as dynamic_cast&lt;&gt; but pretty fast.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>