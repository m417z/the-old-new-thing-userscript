<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (52)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1084763">
				<div id="div-comment-1084763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084763">
			October 25, 2013 at 7:08 am</a>		</div>

		<p>CREATE_SUSPENDED. That is all. Filler text to bypass spam filter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084783">
				<div id="div-comment-1084783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084783">
			October 25, 2013 at 7:26 am</a>		</div>

		<p>Shouldn&#39;t the call be &quot;CreateThread(nullptr, 0, WorkerThread, nullptr, 0, &amp;g_WorkerThreadId);&quot;?</p>
<p>Setting &quot;g_WorkerThreadId&quot; in two different places seems like such a kludge. A bigger question might be why does the same function have to do two different things, depending on which thread it&#39;s running on? If it&#39;s a matter of a thread-affinitied object or something like that, then the real test isn&#39;t whether the code is running on the worker thread, but whether it&#39;s on the original, affinitied thread. In which case, the global variable (yuck!) could just as easily be set to the original thread, and the test by &quot;IsRunningOnOriginalThread()&quot; instead of &quot;IsRunningOnWorkerThread()&quot;.</p>
<p>(Using CREATE_SUSPENDED has a more elegant feel to it as well, but unfortunately that solution suffers from a relative lack of practicality, in the sense that the extra line of code is more complicated than the original solution presented here. :( ).</p>
<div class="post">[<em>In this case, it was a global object that had the rule &quot;The worker thread is the only thread that can do X to the object.&quot; So in a sense the worker thread <span style="text-decoration:underline;">is</span> the original thread. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084793">
				<div id="div-comment-1084793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084793">
			October 25, 2013 at 7:29 am</a>		</div>

		<p>Since the function doesn&#39;t return the thread Id but sets the variable by pointer, it would be nicer of the API to guarantee that the value is set before the thread gets the chance to be scheduled. (The same obviously couldn&#39;t work for the returned handle).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084803">
				<div id="div-comment-1084803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084803">
			October 25, 2013 at 7:39 am</a>		</div>

		<p>AFAIK this is a data race which results in undefined behavior in recent C++ standards. The fact that the same value is written does not matter. It is undefined behavior.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084833">
				<div id="div-comment-1084833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084833">
			October 25, 2013 at 7:58 am</a>		</div>

		<p>@xor88: But if you&#39;re using the Windows API function CreateThread(), you obviously aren&#39;t writing portable C++ code. &nbsp;So you can take advantages of the additional memory model guarantees that are provided by Windows, or by the CPU architectures that Windows supports (x86, x86-64, and ARM).</p>
<p>I would assume that the code Raymond gave is safe on all CPU architectures currently supported by Windows. &nbsp;(I haven&#39;t checked &#8211; I&#39;m relying on Raymond having done that).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084843">
				<div id="div-comment-1084843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084843">
			October 25, 2013 at 8:04 am</a>		</div>

		<p>The compiler would have to make that guarantee. It doesn&#39;t. See <a rel="nofollow" target="_new" href="http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/why_undef.html">http://www.hpl.hp.com/&#8230;/why_undef.html</a> for why that is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084853">
				<div id="div-comment-1084853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084853">
			October 25, 2013 at 8:12 am</a>		</div>

		<p>@xor88: The memory model of the architecture makes that guarantee, so the compiler doesn&#39;t have to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jader3rd odd alt thread-odd thread-alt depth-1" id="comment-1084863">
				<div id="div-comment-1084863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jader3rd' rel='external nofollow' class='url'>jader3rd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084863">
			October 25, 2013 at 8:14 am</a>		</div>

		<p>I&#39;m with AC on this one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084873">
				<div id="div-comment-1084873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike.Shawaluk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084873">
			October 25, 2013 at 8:18 am</a>		</div>

		<p>To fit in with Raymond&#39;s comment in the post, the macro should be named CREATE_SUSPENDERS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084883">
				<div id="div-comment-1084883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xix</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084883">
			October 25, 2013 at 8:19 am</a>		</div>

		<p>minor correction</p>
<p>&quot;One way to address is is to add suspenders to your belt&quot;, double &#39;is&#39;.</p>
<p>Or it&#39;s a synchronization joke.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084893">
				<div id="div-comment-1084893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084893">
			October 25, 2013 at 8:26 am</a>		</div>

		<p>@Joshua, the compiler does not translate reads and writes 1:1 to CPU instructions. Therefore, both architecture memory model of the CPU as well as the compiler of the memory model need to make that guarantee. The compiler does not guarantee that. It can reorder or elide stuff at will. It is not hard to see that.</p>
<p>See <a rel="nofollow" target="_new" href="https://www.usenix.org/legacy/event/hotpar11/tech/final_files/Boehm.pdf">http://www.usenix.org/&#8230;/Boehm.pdf</a> and lots of other stuff.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084903">
				<div id="div-comment-1084903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084903">
			October 25, 2013 at 8:27 am</a>		</div>

		<p>@xor88: What makes you think the compiler doesn&#39;t make that guarantee?</p>
<p>Again, you&#39;re using Windows API functions so you&#39;ll be compiling your code on a compiler that supports Windows and targets a Windows-supported CPU architecture. &nbsp;So you&#39;re not restricted to the minimum level of guarantees found in the C++ standard, you can rely on Windows-specific or architecture-specific guarantees.</p>
<p>And Windows does in fact provide the guarantee you need. &nbsp;From <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684122(v=vs.85).aspx">msdn.microsoft.com/&#8230;/ms684122(v=vs.85).aspx</a></p>
<p>&quot;Simple reads and writes to properly-aligned 32-bit variables are atomic operations. In other words, you will not end up with only one portion of the variable updated; all bits are updated in an atomic fashion. However, access is not guaranteed to be synchronized. If two threads are reading and writing from the same variable, you cannot determine if one thread will perform its read operation before the other performs its write operation.&quot;</p>
<p>And <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2010/12/02/10097860.aspx">blogs.msdn.com/&#8230;/10097860.aspx</a> says that by default, DWORDs will be properly-aligned.</p>
<p>So any compiler that claims to support compiling Windows programs has to provide those guarantees.</p>
<p>So, there are three scenarios. Either one thread runs then the other:</p>
<p>&#8211; Thread A atomically writes variable</p>
<p>&#8211; Thread A atomically reads variable</p>
<p>&#8211; Thread B atomically writes variable</p>
<p>&#8211; Thread B atomically reads variable</p>
<p>Or both writes happen first:</p>
<p>&#8211; Thread A atomically writes variable</p>
<p>&#8211; Thread B atomically writes variable</p>
<p>&#8211; Thread A atomically reads variable } in either order</p>
<p>&#8211; Thread B atomically reads variable }</p>
<p>Or the compiler optimizes away the reads from the variable (which it&#39;s allowed to because it&#39;s not volatile) and thread A &quot;reads&quot; the value it wrote, and thread B &quot;reads&quot; the value it wrote.</p>
<p>And in all these cases, we get the desired behaviour.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084913">
				<div id="div-comment-1084913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">V-SHorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084913">
			October 25, 2013 at 8:28 am</a>		</div>

		<p>I&#39;m with pete.d, myself. Store the thread id of the main (or non-worker, whatever) thread, which can be known well in advance; then you don&#39;t have to race. If you have 20 million lines of code that use IsRunningOnWorkerThread(), you can still leave it named as such, just change the implementation to return GetCurrentThreadId() != g_MainThreadId;</p>
<div class="post">[<em>The object was affine to the worker thread, not the main thread. Therefore you really wanted to check if you are on the worker thread. (Because you might be on a third thread different from main and worker.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-1084943">
				<div id="div-comment-1084943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084943">
			October 25, 2013 at 8:38 am</a>		</div>

		<p>I see this pattern fairly often:</p>
<p>LaunchWorkerThread() {</p>
<p>HANDLE hStarted = CreateEvent(&#8230;);</p>
<p>HANDLE hThread = CreateThread(&#8230;, WorkerThreadProc, hStarted, &#8230;);</p>
<p>if (!hThread) { bail out }</p>
<p>WaitForSingleObject(hStarted, INFINITE);</p>
<p>&#8230; do some things&#8230;</p>
<p>}</p>
<p>WorkerThreadProc(void *pContext) {</p>
<p>HANDLE hStarted = pContext;</p>
<p>&#8230; do some things&#8230;</p>
<p>SetEvent(hStarted);</p>
<p>&#8230; do some more things&#8230;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084963">
				<div id="div-comment-1084963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">George</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084963">
			October 25, 2013 at 9:21 am</a>		</div>

		<p>I don&#39;t get it. Why use the same variable in both places? If the thread sets the variable always, then CreateThread can use a dummy local variable and ignore the result. This will avoid another race condition if we want the thread to clear the global variable when it ends.</p>
<div class="post">[<em>There was other code that ran on the main thread that checked the worker thread ID to see if the worker thread was started. If you set it only in the worker thread, then you would have the same race condition in reverse. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084973">
				<div id="div-comment-1084973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Clipboarder Gadget</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084973">
			October 25, 2013 at 10:39 am</a>		</div>

		<p>The code may not contain undefined behavior on Windows, but it relies on undocumented behavior. The documentation of CreateThread doesn&#39;t state that it sets the ThreadID atomically.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1084993">
				<div id="div-comment-1084993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084993">
			October 25, 2013 at 10:59 am</a>		</div>

		<p>The actual thread is created by some kernel call, which doesn&#39;t have to return the thread ID to the usermode location, because this would require exception handling and address validation. Then the tail of the syscall copies the ID back to the caller. You can clearly see that it&#39;s impossible to get the ID saved before the thread starts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-1085033">
				<div id="div-comment-1085033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085033">
			October 25, 2013 at 1:27 pm</a>		</div>

		<p>@Myria that&#39;s good feedback, but note that waiting on a thread handle and GetExitCodeThread require different security privileges. Waiting requires SYNCHRONIZE access, and GetExitCodeThread requires THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085043">
				<div id="div-comment-1085043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085043">
			October 25, 2013 at 2:03 pm</a>		</div>

		<p>Goodness, if there is one thing I hate more than unreasonably weak synchronisation guarantees, that&#39;s the fact that there are people defending them as being perfectly okay, &quot;just do proper sync on your own if you need it&quot; — I almost always need it, and I don&#39;t want to spend hours trying to prove manually that yes, I did it correctly, at least on this platform, and may the God have mercy on my soul if I ever need to port/rewrite it to something with a slighlty different memory model.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084813">
				<div id="div-comment-1084813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084813">
			October 25, 2013 at 7:41 am</a>		</div>

		<p>Except CreateThread isn&#39;t what creates the thread. Now all of a sudden the kernel has to be able to ensure that the thread ID is set before *it* actually does the heavy lifting and schedules the thread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084923">
				<div id="div-comment-1084923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084923">
			October 25, 2013 at 8:34 am</a>		</div>

		<p>anon, you are assuming a lot. Show me the page of documentation where it says that storing to the same location in a racy way produces a defined result. As long as you don&#39;t find that sentence, you are just assuming behavior.</p>
<p>The C++ standard explicitly and without doubt says that this is undefined. The compiler can, if it wishes to do so, make it defined. I don&#39;t think you have understood the concept of undefined behavior yet. It means that the compiler can compile this as:</p>
<p>if (race_detected())</p>
<p> format(&quot;C:&quot;);</p>
<p>It really can do that and be a conforming implementation. The architecture does not play a role in this (valid) transformation.</p>
<p>I hear you saying &quot;yes, but it wouldn&#39;t do that&quot;. Again, you are *assuming* stuff without reference for it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084953">
				<div id="div-comment-1084953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1084953">
			October 25, 2013 at 8:51 am</a>		</div>

		<p>&quot;The assertion can fire if the worker thread starts running before the call the Create­Thread returns.&quot;</p>
<p>Surely it only fires if the worker thread starts running *after* the call the^H^Ho CreateThread returns.</p>
<p>Or is the assertion backwards?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085063">
				<div id="div-comment-1085063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Niclas Lindgren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085063">
			October 25, 2013 at 4:43 pm</a>		</div>

		<p>Doing it like described is not a very good idea, not only do you have the problem with nothing when the thread is created and spawned, but even when you know the thread isn&#39;t created and spawned after &quot;g_WorkerThreadId&quot; has been written to by the main thread, there is absolutely no guarantee it is published (memory model speak).</p>
<p>Setting it in the thread though solves the issue, because it is an Atomic Update (not obvious that it is though) on a DWORD in a x86 arch. On other archs, like ARM, you might end up with a (for a split moment of time) half updated value, when the thread reads back the value.</p>
<p>This is just like the double check problem for singletons. Without proper memory barriers in place in the above code it will just randomly work or not work depending which CPU you end up running the different threads on.</p>
<p>If you have threads, do proper thread synch, never ever try to be clever, you will fail.</p>
<div class="post">[<em>Since the value is written by both the main thread and the worker thread, the value is observable in both. A third thread, however, may not see the result immediately. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085073">
				<div id="div-comment-1085073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085073">
			October 25, 2013 at 6:02 pm</a>		</div>

		<p>@Raymond: &#39;it was a global object that had the rule &quot;The worker thread is the only thread that can do X to the object.&quot; &#39;</p>
<p>Ah, okay.</p>
<p>Still, it seems like this is a good example of why OOP and better decoupling of code is a good thing. There&#39;s not really any fundamental reason why a) the main thread needs this global variable to track that the thread is created and running, b) the worker thread needs this global variable to know that it&#39;s the worker thread, nor c) that if some function is called legally only by the worker thread, that there even should be a code path that leads to it being called from some other thread.</p>
<p>I mean, no doubt in this particular implementation that&#39;s all the case. And I agree that writing the thread ID from the worker thread is a good solution. But the whole situation seems to call out for a better-compartmentalized design (based of course on the infinitessimal amount of information I actually have :) ).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085003">
				<div id="div-comment-1085003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085003">
			October 25, 2013 at 11:18 am</a>		</div>

		<p>I agree with Clipboarder: the code sample is taking for granted that CreateThread isn&#39;t, say, writing the thread ID a word at a time, since it isn&#39;t stated in CreateThread&#39;s documentation. &nbsp;I would instead have the code put CreateThread&#39;s result into a local variable, then copy it to g_WorkerThreadId, which *would* be atomic because you know that you&#39;re writing an aligned DWORD directly on a 32-bit-or-higher architecture. &nbsp;You&#39;d also want to declare g_WorkerThreadId as volatile and put _WriteBarrier() after the writes.</p>
<p>A minor reminder that&#39;s tangentially related: if you use GetExitCodeThread to get WorkerThread&#39;s return value, note the warning in MSDN about the STILL_ACTIVE return code. &nbsp;To perfectly determine whether a thread has terminated, call WaitForSingleObject(hThread, 0). &nbsp;I wish MSDN had a note saying what the correct solution to the GetExitCodeThread caveat is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-1085023">
				<div id="div-comment-1085023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085023">
			October 25, 2013 at 1:21 pm</a>		</div>

		<p>@Karellen: Assertions in general fire if their condition evaluates to false. In this particular case, the assertion will fire if GetCurrentThreadId() != g_WorkerThreadId.</p>
<p>The only way that can happen is if the assertion is evaluated *before* CreateThread updates g_WorkerThreadId; that is, if the thread function reaches the crucial point before CreateThread returns.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085093">
				<div id="div-comment-1085093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085093">
			October 26, 2013 at 2:12 am</a>		</div>

		<p>It&#39;s tough when you cannot even start a thread without running into race conditions.</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2009/05/22/9634511.aspx#9646180">blogs.msdn.com/&#8230;/9634511.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085103">
				<div id="div-comment-1085103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085103">
			October 26, 2013 at 2:40 am</a>		</div>

		<p>@Maurits &#8211; Thanks. I&#39;d somehow managed to get my understanding of &quot;assert()&quot; backwards. Something to do with using the verb &quot;to assert&quot; (e.g. &quot;the program assert()ed&quot;) to mean that the assert fired, and therefore getting muddled around thinking that the program was meant to assert if the predicate was true. Exposure to BUG_ON() probably hasn&#39;t helped.</p>
<p>Doh!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085113">
				<div id="div-comment-1085113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085113">
			October 26, 2013 at 11:06 am</a>		</div>

		<p>&gt;It&#39;s tough when you cannot even start a thread without running into race conditions.</p>
<p>If you are starting a thread you will run into race conditions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085123">
				<div id="div-comment-1085123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085123">
			October 26, 2013 at 6:02 pm</a>		</div>

		<p>To everyone who thinks that CreateThread should definitely assign pThreadId before the thread starts, perhaps you should think for a second what that would mean for a *wrapper* of CreateThread (e.g. CreateThread2, or a future CreateThreadEx, or a pthread_create). How would you preserve that kind of semantic to the parent function? You can&#39;t!.</p>
<p>Now consider that CreateThread IS the parent function of NtCreateThread, so the guarantee can&#39;t be made for anything more granular than NtCreateThread without implementing heavy communication between the thread&#39;s startup routine and the CreateThread API, which also has the effect that CreateThread will WAIT for the thread to start before returning (and the added complexity this would mean for CREATE_SUSPENDED).</p>
<p>No. Instead, CreateThread says &quot;I will start a thread for you, and you don&#39;t know when that thread will start. pThreadId is definitely assigned when CreateThread returns, but the thread might start before then. Deal with it.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085133">
				<div id="div-comment-1085133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085133">
			October 27, 2013 at 2:13 am</a>		</div>

		<p>&gt; but the thread might start before then. Deal with it.</p>
<p>(And if you don&#39;t want to deal with it: Then use CREATE_SUSPENDED. Which is exactly intended for such reasons)</p>
<p>IMO:</p>
<p>In this case CREATE_SUSPENDED is a way better solution, as it fixes the actual PROBLEM and doesn&#39;t simply change its effects.</p>
<p>From experience, applying fixes to EFFECTS of problems only leads to more undefined behavior later on</p>
<p>Let&#39;s just assume that the main thread says: On no. Lets stop worker thread 1 again and start a different worker thread. If you&#39;re very unlucky, the initialization of the global variable in thread 1 will run AFTER the initialization of thread 2&#8230; (Of course this can be patched too&#8230; but maybe that patch has side-effects too?).</p>
<p>&#8211;&gt; so do yourself a favor and fix the race condition (which can easily be done) instead of &quot;hotfixing&quot; its effects.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085153">
				<div id="div-comment-1085153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Niclas Lindgren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085153">
			October 27, 2013 at 11:00 am</a>		</div>

		<p>@Raymond &#8211; Yes it is observable in both, but that does not mean &nbsp;it is immediately observerable, meaning the value of the variable may or may not be cached in differently places, and the compiler might even keep it in register as there is nothing illegal doing such an optimisation when you have no locking semantics involved, in java you can for instance add the volatile keyword to the variable to say something about its synchronization, adding that i C++ will make sure the compilter doesn&#39;t optimize it into a register, but it won&#39;t add any locking semantics to it..</p>
<p>You need a memory barrier, everything else is just a guess.</p>
<p>Setting the variable in Thread A, does not make it immediately observable in Thread B, the access can be reordered, cached into a register, published whenever.</p>
<p>Again, trying to do synchronization without any semantics is in general a very bad idea as it is incredibly hard to get right.</p>
<div class="post">[<em>But certainly if thread A sets a value, it will observe that value. Imaging the craziness if that weren&#39;t true. You couldn&#39;t trust anything! In this case, both the main thread and the worker thread set the value, so the value is observable in both. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085163">
				<div id="div-comment-1085163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085163">
			October 27, 2013 at 11:42 am</a>		</div>

		<p>&gt;Setting the variable in Thread A, does not make it immediately observable in Thread B, the access can be reordered, cached into a register, published &gt;whenever.</p>
<p>The variable should probably be marked as volatile, so that caching into a register doesn&#39;t happen. But nobody uses volatile, even when they should.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1085173">
				<div id="div-comment-1085173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085173">
			October 27, 2013 at 8:15 pm</a>		</div>

		<p>&quot;But nobody uses volatile, even when they should.&quot;</p>
<p>Well, in C++11, it&#39;s very rare that you should. &nbsp;It&#39;s not for thread synchronization, it&#39;s for telling the compiler that its value can change from effects outside the program, such as connections to hardware, or via shared/mapped memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085183">
				<div id="div-comment-1085183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085183">
			October 27, 2013 at 11:26 pm</a>		</div>

		<p>@GregM: I would assume that the thread scheduling and updates of the processors&#39; caches are &quot;effects outside the program&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085223">
				<div id="div-comment-1085223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085223">
			October 28, 2013 at 7:09 am</a>		</div>

		<p>Niclas: and what&#39;s wrong (in the two-thread case) with storing it in a register?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085243">
				<div id="div-comment-1085243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085243">
			October 28, 2013 at 7:50 am</a>		</div>

		<p>Just to rehash Raymonds summary of the solution:</p>
<p>The uninitialized variable is 0, so unequal any thread. Good enough, there&#39;s no worker thread yet. (or at least it never did anything, so how would you know the difference?)</p>
<p>The variable is read as 0 or the workerthread-id: Good enough, you know you are not the worker-thread and you are not the creator of the workerthread.</p>
<p>The variable is read as the workerthread-id: You have no idea if you read the creators or the workerthreads write (its atomic per platform guarantees). Both have equal effect anyway.</p>
<p>So, there&#39;s no trouble at all, neither write nor read barriers needed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085283">
				<div id="div-comment-1085283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mal DeMer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085283">
			October 28, 2013 at 8:27 am</a>		</div>

		<p>@Joker_VD: I would assume that the thread scheduling and updates of the processors&#39; caches are &quot;effects outside the program&quot;.</p>
<p>Sure they are. But volatile in C++11 doesn&#39;t tell the compiler that it needs to ensure that synchronization occurs, only that the value might change. You don&#39;t get atomic access for volatile data: you need to explicitly use synchronization operations to get that. <a rel="nofollow" target="_new" href="http://stackoverflow.com/questions/12878344/volatile-in-c11">stackoverflow.com/&#8230;/volatile-in-c11</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085373">
				<div id="div-comment-1085373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085373">
			October 28, 2013 at 11:55 am</a>		</div>

		<p>In my opinion this should clearly be stated by the documentation for CreateThread to avoid confusion. The behavior is certainly not obvious and expecting explicit and accurate information about visibility, ordering, etc. is useful in any case for a concurrent API. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hankhein odd alt thread-odd thread-alt depth-1" id="comment-1085413">
				<div id="div-comment-1085413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Henri+Hein' rel='external nofollow' class='url'>Henri Hein</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085413">
			October 28, 2013 at 12:51 pm</a>		</div>

		<p>I once worked on a problem that did this one worse:</p>
<p>HANDLE hThread = CreateThread(nullptr, 0,</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WorkerThreadProc,</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullptr, 0,</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;g_WorkerThreadId);</p>
<p>while (WAIT_TIMEOUT == WaitForSingleObject(hThread, interval))</p>
<p> &#8230;</p>
<p>The code would literally check if the thread was running by examining hThread immediately after the call to CreateThread. &nbsp;Since WaitForSingleObject returns something other than WAIT_TIMEOUT when the thread has not started yet, this lead to some mysterious behavior.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1085423">
				<div id="div-comment-1085423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085423">
			October 28, 2013 at 1:16 pm</a>		</div>

		<p>&quot;I would assume that the thread scheduling and updates of the processors&#39; caches are &quot;effects outside the program&quot;.&quot;</p>
<p>Well, they are effects outside the program, but they don&#39;t change the value of a memory location. &nbsp;I suppose you could say that updates of the processor cache would change the value that the processor sees, but that applies to all memory locations, not just ones marked as volatile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085433">
				<div id="div-comment-1085433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel K.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085433">
			October 28, 2013 at 1:22 pm</a>		</div>

		<p>@Matt: &quot;How would you preserve that kind of semantic to the parent function? You can&#39;t!&quot;</p>
<p>Why not? Just pass the pointer given to the wrapper function to CreateThread. This cuts through all the layers. I don&#39;t exactly endorse this type of coding, but it&#39;s not impossible to do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1085443">
				<div id="div-comment-1085443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085443">
			October 28, 2013 at 4:43 pm</a>		</div>

		<p>@Henri Hein:</p>
<p>The code as shown is completely valid. The thread handle is immediately valid, and you can wait on it immediately. It doesn&#39;t matter whether the thread ever started to run. It only matters whether the thread object is valid (it is) and whether it&#39;s signaled yet.</p>
<p>If there was any problem, it should have been somewhere else.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1085453">
				<div id="div-comment-1085453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085453">
			October 28, 2013 at 4:45 pm</a>		</div>

		<p>@Marcel K:</p>
<p>&gt;Why not? Just pass the pointer given to the wrapper function to CreateThread.</p>
<p>That&#39;s not always possible for kernel code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085513">
				<div id="div-comment-1085513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel K.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085513">
			October 29, 2013 at 1:12 am</a>		</div>

		<p>@alegr1</p>
<p>Kernel code calling the user mode CreateThread function? I don&#39;t think this is a valid scenario.</p>
<div class="post">[<em>No, but kernel code would have to pass the raw original pointer to the dwThreadId variable all the way down into the object manager so it can set the thread ID at the exact moment the thread is created. And now you have a potential user-mode attack against the object manager if the user-mode code, say, changes page permissions from another thread. It can get even worse if the thread object is created in a different memory context. (E.g., via an asynchronous call.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1085853">
				<div id="div-comment-1085853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085853">
			October 29, 2013 at 1:38 pm</a>		</div>

		<p>@Raymond: Yes, how this could be done in kernel code or whether it&#39;s sensible at all I don&#39;t know. I guess it should be easy enough to always create the thread suspended, set the threadID and only then unfreeze it. But I&#39;m not a kernel level guy.</p>
<p>All I wanted to say is that if CreateThread gives this guarantee, then so can every function wrapped around CreateThread and thus &quot;it can&#39;t be wrapped&quot; is just not a valid argument against this feature.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1085913">
				<div id="div-comment-1085913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Niclas Lindgren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1085913">
			October 29, 2013 at 5:31 pm</a>		</div>

		<p>@Raymond &quot;[But certainly if thread A sets a value, it will observe that value. Imaging the craziness if that weren&#39;t true. You couldn&#39;t trust anything! In this case, both the main thread and the worker thread set the value, so the value is observable in both. -Raymond]&quot;</p>
<p>You misunderstand me, I am not saying your &quot;solution&quot; is flawed, of course what you mentioned above is true, but you speak of a race between the main thread and the worker thread. There is no race, but you imply there is. If we speak of a sync issues between the threads than my reasoning follows, so it should be seen in the light of that we actually have a sync issue. In this case the logic is flawed. All you need to do is set the variable in the worker thread and keep it 0 else, no race at all (however half baked). Also spawning multiple threads will lead to more odd behaviors. A better approach, still flawed, would be to set the variable to the Main threads ID before spawning the worker thread and check if the Id of the current thread is different from the main thread, which means it is a worker thread. If you have 2 &quot;main threads&quot; spawning workers you still have a problem.</p>
<p>What I am saying though, is, that because you now set the variable from 2 places, in theory, in the general sync 2 variables case, that is dangerous with no locking logic. In this particular case you set it to the same value in both places, so there is no &quot;half&quot; published value to be worried about, since even a half published value of the same two halves will be the correct value.</p>
<p>In general though, as advice to solve locking problems (which this isn&#39;t), don&#39;t be clever. In the case above, the best approach is to use a local variable and pass that to the DoSomething(TRUE), and from the main thread pass it DoSomething(FALSE). No race, no sync issues, and especially no global variables that only work as long as only one worker thread is spawned at a time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1086253">
				<div id="div-comment-1086253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1086253">
			October 30, 2013 at 2:32 pm</a>		</div>

		<p>&quot;All I wanted to say is that if CreateThread gives this guarantee, then so can every function wrapped around CreateThread and thus &quot;it can&#39;t be wrapped&quot; is just not a valid argument against this feature.&quot;</p>
<p>That&#39;s not what was asserted. &nbsp;What was asserted is that if CreateThread DOESN&#39;T give this guarantee, then a wrapper of CreateThread CAN&#39;T give this guarantee. &nbsp;Thus, by induction, CreateThread CAN&#39;T give this guarantee, because it is itself a wrapper of a NtCreateThread, and NtCreateThread doesn&#39;t give this guarantee.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1086263">
				<div id="div-comment-1086263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel K.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1086263">
			October 30, 2013 at 4:22 pm</a>		</div>

		<p>The point is, a wrapper can not only keep the promise the original function made, it can actually add it:</p>
<p>HANDLE WINAPI CreateThreadWithPromise(LPSECURITY_ATTRIBUTES sa, SIZE_T ss, LPTHREAD_START_ROUTINE start, LPVOID p, DWORD flags, LPDWORD lpThreadId) {</p>
<p>__HANDLE h = CreateThread(sa, ss, start, p, flags | CREATE_SUSPENDED, lpThreadId);</p>
<p>__if ((flags &amp; CREATE_SUSPENDED) == 0) {</p>
<p>____ResumeThread(h);</p>
<p>__return h;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1086273">
				<div id="div-comment-1086273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel K.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1086273">
			October 30, 2013 at 4:22 pm</a>		</div>

		<p>The point is, a wrapper can not only keep the promise the original function made, it can actually add it:</p>
<p>HANDLE WINAPI CreateThreadWithPromise(LPSECURITY_ATTRIBUTES sa, SIZE_T ss, LPTHREAD_START_ROUTINE start, LPVOID p, DWORD flags, LPDWORD lpThreadId) {</p>
<p>__HANDLE h = CreateThread(sa, ss, start, p, flags | CREATE_SUSPENDED, lpThreadId);</p>
<p>__if ((flags &amp; CREATE_SUSPENDED) == 0) {</p>
<p>____ResumeThread(h);</p>
<p>__return h;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1086283">
				<div id="div-comment-1086283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Niclas Lindgren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1086283">
			October 30, 2013 at 4:29 pm</a>		</div>

		<p>@Mark There is nothing wrong as long as you do a set in the worker thread as Raymond shows, but in the general case there are so many things wrong with that code, and that should be pointed out. Also to double set the variable, makes the code work, but it is still not a good solution to the problem. That is all I am saying. The programmer of that code needs education in many levels, what he or she doesn&#39;t need is a solution to the problem, because with the knowledge displayed, there will soon be another problem, much worse problem, with multithreading or other structural issues.</p>
<p>@GregM What do you mean it cannot be wrapped and create this guarantee, of course it can? </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1086613">
				<div id="div-comment-1086613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anil [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131025-00/?p=2833#comment-1086613">
			October 31, 2013 at 8:32 pm</a>		</div>

		<p>CreateProcessAsUser has this bit in the documentation:</p>
<p>The calling thread can use the WaitForInputIdle function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because CreateProcessAsUser returns without waiting for the new process to finish its initialization. For example, the creating process would use WaitForInputIdle before trying to find a window associated with the new process.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>