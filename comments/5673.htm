<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (68)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1029263">
				<div id="div-comment-1029263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">digiowl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029263">
			January 1, 2013 at 7:35 am</a>		</div>

		<p>in other words, the issue is not the FS but the write cache used to give the appearance of better responsiveness than there really is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029283">
				<div id="div-comment-1029283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029283">
			January 1, 2013 at 7:50 am</a>		</div>

		<p>Responsiveness is all about appearance. &nbsp;If it appears responsive, it IS responsive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029313">
				<div id="div-comment-1029313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">configurator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029313">
			January 1, 2013 at 8:20 am</a>		</div>

		<p>There must be a better way to design a filesystem than requiring the writer to set the size to create contiguous blocks (Not that I know why you&#39;d need contiguous blocks on a thumb drive).</p>
<p>My issue isn&#39;t with the copy not succeeding completing, it&#39;s with the intermediate state. A file copy should increase the file size as it&#39;s writing it &#8211; that way when &lt;anything&gt; happens, you&#39;d be able to continue copying at the point where you were interrupted. I&#39;m not saying that&#39;s the way the file system and shell operations should be implemented &#8211; clearly more than a few minutes thought would have to be put into the design &#8211; but I am saying these are the side effects I&#39;d want from a power outage. A partially copied file makes sense. A file of the same size as the original file but not the same contents seems wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029323">
				<div id="div-comment-1029323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">saveddijon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029323">
			January 1, 2013 at 8:36 am</a>		</div>

		<p>Truth is, USB devices ought to work just fine with any filesystem. The trick?</p>
<p>Removable devices of any kind should have the cache sync every 2 seconds worst-case. (Typical would be 30s-1min for a non-removable device.)</p>
<p>Then all you need to do is wait 2 seconds after any operation before yanking the drive.</p>
<p>AmigaDOS worked this way. There was a cache, but the flush time was on the order of 2 seconds. Therefore you never ran into an issue when, say, writing to a floppy.</p>
<p>And as the previous posters have noted, if the filesystem loses coherency (i.e. when it is recovered, the recovered state does not match any state the filesystem ever had in the past) then the filesystem design is wrong. &nbsp;Look at 4.4BSD for the right way to do this, and later versions with delayed ordered writes, which allow caching and coherency.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029333">
				<div id="div-comment-1029333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jernej_2D00_ms.live_4000_ena.si/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jernej-ms.live@ena.si</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029333">
			January 1, 2013 at 8:50 am</a>		</div>

		<p>@saveddijon: there&#39;s always a trade-off &#8211; full journaling is slower than just metadata journaling. And if you modify NTFS to support full journaling, you still haven&#39;t solved anything &#8211; as this would change the on-disk structures, older versions of Windows would not be able to read this filesystem, resulting in much lower usability (remember, when you have a portable drive, you want to be able to read it on any computer you come across).</p>
<p>I&#39;m more annoyed that most manufacturers mark USB pendrives as having removable media (they don&#39;t &#8211; that&#39;s intended for things like ZIP cartridges), and Windows paying attention to that and refusing to allow partitions on such drives (why?).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029343">
				<div id="div-comment-1029343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029343">
			January 1, 2013 at 9:57 am</a>		</div>

		<p>Repeat after me. Do not lazy flush buffers for removable drives. In fact, it&#39;s a whole lot better if you don&#39;t enable write-behind caching for removable drives in the first place.</p>
<p>@saveddijon: Ext3 has an option to journal data. It&#39;s so slow it is a non-solution even if Windows supported it.</p>
<p>@ender9: Perhaps setting that flag is the only way to convince Windows to not lazy-flush data.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029363">
				<div id="div-comment-1029363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Z.T.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029363">
			January 1, 2013 at 10:58 am</a>		</div>

		<p>How about making the file copy dialog do (the equivalent of) fsync()?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029373">
				<div id="div-comment-1029373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Noel Grandin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029373">
			January 1, 2013 at 11:11 am</a>		</div>

		<p>Once again MS is too lazy to do the right thing, which is to auto-disable the NTFS write-behind cache when working with removable drives.</p>
<div class="post">[<em>Um, it&#39;s disabled by default. This problem occurs when you <span style="text-decoration:underline;">override the default</span> and say &quot;I want dangerous write-behind caching on removable drives.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029383">
				<div id="div-comment-1029383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029383">
			January 1, 2013 at 11:37 am</a>		</div>

		<p>@Noel: But how does Windows know that it&#39;s a removable drive when the USB stick claims that it&#39;s a hard drive? Whether you like it or not, the Windows definition of &quot;removable drive&quot; is the kind that is in a 5.25&quot; or 3.5&quot; form factor that holds between 120KB and 2.88MB and has no partition table. The fact that USB drives present as &quot;block devices&quot; with no other information doesn&#39;t really help matters any either, in my opinion.</p>
<p>BTW, Windows is not the only operating system that wants you to safely remove USB devices: OS X gives you a scary error dialogue when you pull a USB drive out, and Unices really don&#39;t appreciate it when you pull a mounted filesystem out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029393">
				<div id="div-comment-1029393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Edward M. Grant</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029393">
			January 1, 2013 at 12:10 pm</a>		</div>

		<p>&quot;But how does Windows know that it&#39;s a removable drive when the USB stick claims that it&#39;s a hard drive?&quot;</p>
<p>And how does it know that disabling the cache is the right thing to do? Disabling the cache means I have to wait longer for the copy to &#39;complete&#39; to disk cache, when I might be waiting to do other work while it&#39;s physically being written to the USB drive before I remove it. There&#39;s simply no &#39;one right way&#39; to handle USB drives, because the user can pull them out at any time and the OS can&#39;t tell when we&#39;re going to do that.</p>
<p>All that said, I still stick to FAT32 on my USB drives because it&#39;s the only filesystem that every machine I use can reliably read and write.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-paulcoddingtonhotmail-com even thread-even depth-1" id="comment-1029413">
				<div id="div-comment-1029413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Paul+Coddington' rel='external nofollow' class='url'>Paul Coddington</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029413">
			January 1, 2013 at 12:49 pm</a>		</div>

		<p>This about covers the point I make when techies tell me that UPS is not necessary because NTFS is robust &#8211; an intact file system that is internally consistent is not the same as retaining data that was in the middle of being changed (at any given time, more can be changing than you think). &nbsp;Still, not as bad as the techies who once insisted that NT machines should always use FAT on their system disk &quot;as recommended by Microsoft&quot; (like heck it was).</p>
<p>I have seen CHKDSK discard hundreds, perhaps thousands of files on a damaged NTFS system drive in the process of making it pass all future CHKDSK operations with a perfect record. &nbsp;This should be a lesson to all &#8211; and a case in point as to why it is a bad idea to hide the CHKDSK progress report from the end user.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029433">
				<div id="div-comment-1029433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">gibwar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029433">
			January 1, 2013 at 1:35 pm</a>		</div>

		<p>@configurator: except now that didn&#39;t solve anything and added nothing but more work and more complexity. More work comes from how is the system to know that the file should be resumed? To properly implement it you&#39;ll now need to hash each block before copying it to see if its the same or not. If the hashes don&#39;t match then what? Also, what would happen if I had a file that was 2GB large and I copied another file with the same name (completely different contents) that was 2.5GB? If you implement hashing, you&#39;ll have to go through the entire file just to find out they aren&#39;t the same at all and throw the &quot;replace this file?&quot; dialog and have wasted tons of the users time on the operation just reading the file, not copying. If you don&#39;t implement hashing and just append the remaining 500MB on, well, I hope the program that uses the file is robust enough to determine that there is 500MB of unrelated junk tacked on the end of it for no apparent reason.</p>
<p>As for the &quot;why bother setting the size ahead of time&quot; that allows the filesystem to determine if there is enough space at the beginning of the copy and fail fast. Imagine if you had a 2GB drive and you started copying 4 1GB files on to it. Each one would fail at a different point, or maybe some of them wouldn&#39;t? By preallocating the space up front, the first two would be allowed to copy and the last two would be denied with &quot;not enough space is available.&quot; Personally, I prefer it the way its set up now, its predictable and user friendly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029463">
				<div id="div-comment-1029463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029463">
			January 1, 2013 at 3:37 pm</a>		</div>

		<p>Okay, so the maint point of the article makes sense. Just because NTFS is a journaling FS, doesn&#39;t mean you can just yank out an USB drive before the cashes are flushed. Agreed so far.</p>
<p>But what about the linked old article: Why do you need to &quot;have to promise to play friendly&quot; to format as NTFS?? I don&#39;t get that at all. Doesn&#39;t yanking out a drive formatted with the inferior FAT FS have the same problems? If &#39;optimize for quick removal&#39; means limiting the disk caching, why can&#39;t this be done for NTFS?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029303">
				<div id="div-comment-1029303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">metafonzie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029303">
			January 1, 2013 at 8:06 am</a>		</div>

		<p>@digiowl, You could simulate that behavior w/o any caching involved. &#8211; e.g. Yanking a high write latency storage device.</p>
<p>The issue *is* the FS and its a by design problem (i.e. not including data in the undo/redo transaction logs). If you don&#39;t like this tradeoff use some other file system :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1029543">
				<div id="div-comment-1029543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029543">
			January 1, 2013 at 8:26 pm</a>		</div>

		<p>Cache behaviors are implemented at the filesystem driver. FAT may honor the removable media/device property, while NTFS may not, because historically, hard drives haven&#39;t been removable for a while.</p>
<p>I remember Win2003 having horrible behavior with USB flash. If you forget to use safe removal, you&#39;ll get hit with some &quot;delayed write error&quot;, even if you HAVEN&#39;T MODIFIED A SINGLE FILE ON IT.</p>
<p>If you want better FS for a USB flash, use exFAT, not NTFS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029473">
				<div id="div-comment-1029473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Destroyer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029473">
			January 1, 2013 at 3:42 pm</a>		</div>

		<p>(pressed post but didn&#39;t receive the green confirmation :-|)</p>
<p>What an article to start 2013! It confirms my assumptions on this exact topic have been right :-)</p>
<p>I think some people are speculating here and don&#39;t actually have any real world experience with USB drives. There is NO problem with NTFS here as far as I am concerned, it is totally in the hands of the user/application*.</p>
<p>I believe in all recent versions of Windows (certainly 7 and 8) it does disable write cache to the USB drives or reduces it, at least this is from all my experience dealing with them (which is quite a lot). This can be verified by watching the activity light flash on the USB drive after pressing &quot;safely remove hardware&quot;, I have never, ever, seen any activity from pressing that button, confirming that there is no caching, when a USB flash drive is formatted as NTFS, even when pressing it almost instantly after a file copy in Windows.</p>
<p>Also, most modern USB flash drives continue to flash their activity light for several seconds after the write has completed on purpose to stop the user unplugging this, which further causes confusion as Windows will correctly report it is safe to remove the device (it is from its perspective), yet the device still flashes for another few seconds.</p>
<p>*The 2 second idea wouldn&#39;t help unfortunately imho, most of the time it is neither Windows or the application, it is the user. They will click log off then yank the flash drive out immediately, Windows is busy closing down all their applications that they couldn&#39;t be bothered to close down manually, and that &quot;bong&quot; message that they hear is a &quot;Delayed Write Failed&quot; error message telling them to re-save their document, oh but hang on they are logging off and probably are already walking away from the computer at that point. Windows has even TOLD them that the save was unsuccessful but they don&#39;t care. Yes, I know that it is a &quot;Delayed&quot; write, but it could be delayed write in the order of a few milliseconds, it makes no difference, even if the write wasn&#39;t delayed it would have probably been cut off in the middle anyway.</p>
<p>You can&#39;t have it both ways, users either treat the device with common sense or treat them like children so whenever they click save a big message appears and STOPS them doing whatever they were doing until the save is totally, absolutely, complete. Somehow I don&#39;t think they would be very amused with that.</p>
<p>The problem is most people are dealing with small document files so they very rarely see any problems until it all goes wrong. If you was working on a 4GB photoshop file etc you might think twice about pressing save and then pulling the USB drive out a second afterwards. Well, you might do it once, and probably learn your lesson.</p>
<p>I format all my flash drives as NTFS, it is far more reliable than FAT32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn even thread-even depth-1" id="comment-1029583">
				<div id="div-comment-1029583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029583">
			January 1, 2013 at 11:50 pm</a>		</div>

		<p>@Destroyer: I agree with your analysis, but there may be a very legitimate reason for the drive lights to flash for a while after Windows considers the transaction to have completed. A USB drive may use some internal cache to release the host quickly, but still need electric power to flush the data to slower flash memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029593">
				<div id="div-comment-1029593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029593">
			January 2, 2013 at 1:04 am</a>		</div>

		<p>@Joshua: no, USB harddrives aren&#39;t seen as removable, and still have write caching disabled by default.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029603">
				<div id="div-comment-1029603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RichB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029603">
			January 2, 2013 at 1:38 am</a>		</div>

		<p>Recent versions of NTFS not only support journaling, but transactions:</p>
<p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363764(v=vs.85).aspx" target="_new" rel="nofollow">msdn.microsoft.com/&#8230;/aa363764(v=vs.85).aspx</a></p>
<p>It&#39;s a shame more applications don&#39;t make use of them. It&#39;s also a shame this feature isn&#39;t publicized more in msdn blog posts.</p>
<div class="post">[<em>Transactions have their own cost, however. Suppose you have a USB drive with 1GB of disk space free, and there is a 2GB file on the drive that you want to overwrite with a 2GB file from your hard drive. If you tried to do this file copy via a transaction, you&#39;d get an &quot;out of disk space&quot; error. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029653">
				<div id="div-comment-1029653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Markus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029653">
			January 2, 2013 at 4:10 am</a>		</div>

		<p>@RichB: <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh802690(v=vs.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/hh802690(v=vs.85).aspx</a> (Alternatives to using Transactional NTFS):</p>
<p>&quot;Microsoft strongly recommends developers investigate utilizing the discussed alternatives (or in some cases, investigate other alternatives) rather than adopting an API platform which may not be available in future versions of Windows.&quot;</p>
<p>I agree, though, it&#39;s a shame.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029663">
				<div id="div-comment-1029663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029663">
			January 2, 2013 at 4:48 am</a>		</div>

		<p>To everyone who thinks that journaling data is a good thing, think about this.</p>
<p>I have a 1GB USB stick with a 500MB zip file on it. I replace the zip file with a 600MB zip file, and my OS says &quot;I can&#39;t do that, because the disk isn&#39;t big enough&quot; &#8211; you can&#39;t journal all of the 600MB to the disk and have a 500MB recovery space for the file incase anything goes wrong.</p>
<p>So what you&#39;ve reduced this to is a user saying &quot;Hang on &#8211; my disk have 1GB storage and yet I can&#39;t put a single 600MB file on it?! This is BS!&quot;.</p>
<p>Instead, Microsoft are optimising for the default (good) case where users click to remove their USB stick.</p>
<p>This is all a special case of &quot;don&#39;t optimise for the case where users are doing it wrong&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029683">
				<div id="div-comment-1029683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dirk gently</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029683">
			January 2, 2013 at 5:57 am</a>		</div>

		<p>The real WTF is that the file copy dialog says that &quot;the job is done&quot; before the data is flushed.</p>
<div class="post">[<em>The file copy dialog doesn&#39;t know about disk flushing. That occurs at a lower layer. Sometimes it happens in the hardware itself. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029713">
				<div id="div-comment-1029713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MS Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029713">
			January 2, 2013 at 7:55 am</a>		</div>

		<p>Does Windows 8&#39;s new file copy dialog and ability to pause transfers makes any difference at all compared to how it was done earlier? I&#39;ve yanked out drives while file copy was paused, used them elsewhere, then reinserted and managed to continue the transfer, but I don&#39;t know whether Microsoft has ever thought of and tested this sort of thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1029723">
				<div id="div-comment-1029723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029723">
			January 2, 2013 at 7:58 am</a>		</div>

		<blockquote><p>
  The real WTF is that the file copy dialog says that &quot;the job is done&quot; before the data is flushed.
</p></blockquote>
<p>Nope. For a USB flash, the file is flushed before the file copy dialog is closed. It&#39;s either done at CloseFile, or by explicit FlushFileBuffers call.</p>
<p>Vista/Win7Gold used to have a big problem with that. They didn&#39;t hesitate to cache A LOT of the file and issue A LOT of pending writes. If you have a large file, you could not easily abort the copy to USB, you had to wait until all those writes completed and data flushed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029773">
				<div id="div-comment-1029773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymous123</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029773">
			January 2, 2013 at 8:50 am</a>		</div>

		<p>Won&#39;t you get the same corruption also with FAT?</p>
<div class="post">[<em>Yes, but FAT isn&#39;t a journaling file system, so nobody expects it to work with FAT. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029823">
				<div id="div-comment-1029823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029823">
			January 2, 2013 at 10:47 am</a>		</div>

		<p>If you write to an NTFS-formatted flash drive, then let it site for 5 minutes on a mostly-idle system, and then do an unsafe removal &#8230; &nbsp;will the data be intact? &nbsp;I have done this a few times (not on purpose) and I have never seen missing data as a result. &nbsp;Was I just lucky, or should I expect that allowing the data to &quot;settle&quot; for a few minutes is sufficient?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029893">
				<div id="div-comment-1029893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029893">
			January 2, 2013 at 11:35 am</a>		</div>

		<p>&quot;The file is correctly set to the final size&quot;</p>
<p>I&#39;m surprised that you consider that the correct behaviour&#8230; an optimized behaviour maybe, but not a correct one!</p>
<p>IMHO the size should be set to a value lower than what was correctly transfered.</p>
<p>The fact that NTFS reserves the amount of space needed for the whole file (a good thing, as Gibwar explained) should not necessarily imply that it has to directly set the file size to its final value. On FAT (at least) the two notions (cluster chain reserved for the file vs. file&#39;s size in directory entry) were independent and I imagine NTFS would also support manipulating them independently.</p>
<p>The &quot;correct&quot; behaviour would imply updating regularly the file&#39;s size in the file&#39;s metadata. Obviously that would degrade performance a little bit, but so is keeping a journal&#8230;</p>
<p>From the designers POV, maybe they consider both cases to be equivalent (file is corrupted), but one is more treacherous (file&#39;s properties seem good) and I don&#39;t consider the performance gain to be worth it. (Performance could be made equivalent by setting the size also once, but at the end, like FAT did IIRC (I have memories of long downloads resulting in 0-byte files when interrupted))</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029903">
				<div id="div-comment-1029903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">digiowl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029903">
			January 2, 2013 at 11:58 am</a>		</div>

		<p>meh, starting to think that USB drives should have a mandatory button with a led. When you want to remove the drive, you press the button and the led starts flashing. When it goes from flashing to solid you can remove the drive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029923">
				<div id="div-comment-1029923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JJJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029923">
			January 2, 2013 at 12:16 pm</a>		</div>

		<p>&nbsp; (Not that I know why you&#39;d need contiguous blocks on a thumb drive).</p>
<p>When you overwrite data on a flash drive, you have to erase it first. &nbsp;The problem is when you erase even one single byte, the hardware requires you to erase an entire block of data (Could be any size. &nbsp;16 KB, 64 KB, 512 KB&#8230;). &nbsp;Then you have to write your new data and re-write the rest of the data in the block.</p>
<p>So you want your data to be contiguous to avoid writing single bytes to a block, which really results in an entire block being erased and re-written.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029973">
				<div id="div-comment-1029973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029973">
			January 2, 2013 at 12:46 pm</a>		</div>

		<p>@Nawak: How can you set the length of the file to be less than the data in the file? The length of the file is the number of sectors that have been allocated to it. Putting more data in the file than sectors are allocated to it means that you&#39;ve buffer-overflowed something on disk!</p>
<p>In NTFS, setting the file-size is a journalable and high-cost action. You set the length up-front in order to allocate the sectors and then write data into it. This way every WriteFile only needs to update the EndOfFile pointer in the file record and write the data itself to disk, rather than doing a full journalling action to allocate more sectors (which might shuffle stuff on disk or trigger a defragment etc) several times during the copy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029983">
				<div id="div-comment-1029983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@JJJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029983">
			January 2, 2013 at 12:47 pm</a>		</div>

		<p>The filesystem only writes in units of one or more blocks to the block device. Smaller writes are cached (that&#39;s what the filesystem cache is mainly for).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029993">
				<div id="div-comment-1029993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dnm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1029993">
			January 2, 2013 at 12:51 pm</a>		</div>

		<p>Oh wow! I wish i had read this last weekend when I screwed up my USB tyring to make a U-boot device using NTFS&#8230;.It had worked the first time when I did not yank it right away. And then I did not why this was not working. Thanks a ton Raymond for the insight</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030023">
				<div id="div-comment-1030023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030023">
			January 2, 2013 at 2:12 pm</a>		</div>

		<p>@digiowl &quot;meh, starting to think that USB drives should have a mandatory button with a led&quot;</p>
<p>I think the most reliable solution will be to add few teeth around USB socket that will hold device in mouth til it will be safe to remove it. Hope USB standard-developers will read this message. Name the new standard USSB &#8211; Universal Serial Shark Bus. And paint them in red, to avoid mess with bluetooth.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030063">
				<div id="div-comment-1030063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030063">
			January 2, 2013 at 3:13 pm</a>		</div>

		<p>@Matt:</p>
<p>I don&#39;t know about NTFS but on FAT FS at least, the space allocated is described in the FAT (by chaining clusters of disk sectors together) and the file&#39;s size is in the directory&#39;s entry for the file. The space allocated for the file is nearly always different from the file size, because the allocation is at least the file&#39;s size rounded up to the next cluster (often several kB). So the differentiation between space allocated and file size is built-in. It&#39;s even a founding principle. The logic would be that the file&#39;s allocation is always at most 1 cluster (minus 1 byte) larger than the file, but nothing prevents you from having a 1 byte file using a 1 GB allocation.</p>
<p>You can for instance use that technique to reduce the number of FAT writes so that a larger proportion of the writes serve for data and not for the FS bookkeeping.</p>
<p>(1 sector of 512 bytes describes the state of 128 clusters, so in the best case you can allocate 128 clusters at once, which is better than 128 successive writes)</p>
<p>Unused space is reclaimed at close() time or by a scandisk.</p>
<p>Anyway, as I said, I imagined that NTFS had a similar differentiation and that a file&#39;s size didn&#39;t have to change alongside with its allocation. If that&#39;s not the case then, well, the inconsistency that me react came for free with the FS design, and not from a particular decision about what would the &quot;correct&quot; behaviour be in the case exposed by Raymond.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030073">
				<div id="div-comment-1030073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Destroyer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030073">
			January 2, 2013 at 4:54 pm</a>		</div>

		<p>@David &#8211; yes, in fact, more like 5 seconds should be enough from what I have seen/do, at least when doing any copying functions in explorer or robocopy or Office suite. Other programs &#8211; who knows.</p>
<p>The problem with transactions is that we are dealing with loss of saved work most of the time, the only thing using an atomic write would do is mean the file is not there rather than there but corrupt. Yes it may stop the old copy getting corrupted but people shouldn&#39;t work from important files from a memory stick without a backup regardless!</p>
<p>It actually may cause the number of instances of corruption/loss of saved work to increase due to the increase in write time, and also, when users have pulled the disk out at least I can open up the .docx in notepad sometimes and get their typing back, yes the formatting is lost but that&#39;s tough. If it was using transactional NTFS there would be no corrupt .docx file there to try and recover!!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030113">
				<div id="div-comment-1030113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030113">
			January 3, 2013 at 1:51 am</a>		</div>

		<p>@Nawak: If you allocate the data upfront then you don&#39;t have to do so many resizes of the file when you hit inevitable boundaries.</p>
<p>It&#39;s like the difference in C# between</p>
<p>var q = new List&lt;int&gt;()</p>
<p>for(int i = 0; i &lt; 10000000; i++) q.Add(i);</p>
<p>and</p>
<p>var q = new List&lt;int&gt;(10000000)</p>
<p>for(int i = 0; i &lt; 10000000; i++) q.Add(i);</p>
<p>The second one is much faster because you allocated the right amount of space up front and never need to resize.</p>
<p>In NTFS you can of course open a file and start spitting data into it, but if you know how big it&#39;s gonna be when you close the handle after the write, you might as well give NTFS the opportunity to preallocate space on the disk for it (which is why CopyFile does that).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030153">
				<div id="div-comment-1030153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wound</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030153">
			January 3, 2013 at 3:54 am</a>		</div>

		<p>The solution here is clearly that the external case of the USB pendrive should be electrified to give the user a shock preventing them from removing it until the write has been completed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com odd alt thread-odd thread-alt depth-1" id="comment-1030723">
				<div id="div-comment-1030723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030723">
			January 3, 2013 at 10:32 pm</a>		</div>

		<p>More guidance needed from MS on whether NTFS or exFAT is better for flash memory. I mean NTFS has a number of feature advantages despite exFAT being optimized for wear leveling.</p>
<div class="post">[<em>The guidance is already built-in by the fact that you have no choice. By default, USB thumb drives cannot be formatted NTFS, and the system volume cannot be formatted exFAT. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030793">
				<div id="div-comment-1030793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dirk gently</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030793">
			January 4, 2013 at 2:10 am</a>		</div>

		<p>[The file copy dialog doesn&#39;t know about disk flushing. That occurs at a lower layer. Sometimes it happens in the hardware itself. -Raymond]</p>
<p>ok, so the problem is that the &quot;lower layer&quot; is not able to signal that the data has actually been flushed. The dialog waves happily to the user that the job is done, but from the user perspective the job is not done. What the user requested, is that data is written to the device, not to the device&#39;s volatile cache (which the user is probably even unaware of).</p>
<div class="post">[<em>The solution is to use the default setting of &quot;Optimize for quick removal.&quot; Remember, you got into this pickle because you changed a default, and the dialog box where you change the default says, &quot;To disconnect this device from the computer, click the Safely Remove Hardware icon in the taskbar notification area.&quot; You chose a dangerous setting and ignored the warning that came with it, and now you&#39;re blaming Windows. This is why we can&#39;t have nice things. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030803">
				<div id="div-comment-1030803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030803">
			January 4, 2013 at 2:20 am</a>		</div>

		<p>@Nawak: I think you are looking at the problem from the wrong level. Setting the length operation is an optimisation FOR ntfs made BY the CopyFile API in Windows.</p>
<p>In other words, CopyFile acts like this:</p>
<p>HANDLE hFrom := CreateFile(pFrom, GENERIC_READ);</p>
<p>SIZE_T hFromLength := GetFileSizeEx(hFrom);</p>
<dl>
<dt>HANDLE hTo := CreateFile(pTo, GENERIC_WRITE);</dt>
<dd>
NtSetInformationFile(hTo, hFromLength);
</dd>
</dl>
<p>CopyLoop(hFrom, hTo);</p>
<p>CloseHandles(hFrom, hTo);</p>
<p>From NTFS&#39;s point of view it&#39;s been asked to create an exactly X MB file of zeros and then every zero is then overwritten with data. If you stop halfway through, the rest of the file is zeroes because that&#39;s what CopyFile said it wanted, and because CopyFile&#39;s error path is to delete the destination file, assuming no power failures, memory corruptions or invasive monitoring you won&#39;t be able to tell the difference.</p>
<p>This optimisation is over not first setting the length, in which case NTFS would say that the length is however much data you&#39;ve written to it so far.</p>
<p>This isn&#39;t NTFS being clever, it&#39;s CopyFile being clever. And since nobody else should be looking (or caring) about the length of the destination file until you&#39;ve actually written it, and you get an important performance boost for the boring task of copying lots of big files to your thumb-drive, since power off kills your data anyway, and since the error path in CopyFile deletes the file, this isn&#39;t a normally observable optimisation, and hence is a good optimisation to take.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030763">
				<div id="div-comment-1030763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030763">
			January 4, 2013 at 12:42 am</a>		</div>

		<p>@Matt:</p>
<p>I guess you are proving my point. In your examples, what does the &quot;Count()&quot; method return if you stop the Add loop at 5000000? I guess it returns 5000000 in both cases, so it proves that allocation and size are considered different by this class, and that &quot;optimizing&quot; doesn&#39;t necessarily imply changing the observed behaviour of the Count() method.</p>
<p>My original point was that stopping the 2nd example in the middle should not make Count() return 10000000, because that&#39;s kind of what NTFS is doing in Raymond&#39;s example. IMHO, it shouldn&#39;t return the full size if the full write has been interrupted!</p>
<p>(And if Count() *does* return 10000000 instead of 5000000 when the loop is shorter than (initially) expected, well that would mean that NTFS&#39;s design is meeting everyone&#39;s &quot;natural&quot; expectations except mine, and that&#39;s really ok)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1030903">
				<div id="div-comment-1030903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030903">
			January 4, 2013 at 8:57 am</a>		</div>

		<p>@Nawak:</p>
<p>Besides from file length, NTFS maintains valid data length for a file. Any read beyound valid data length brings zeros; this is why you can&#39;t read old data this way. This makes it unnecessary to do an explicit zero-write pass. If you have enough privileges, you can modify valid data length and read the old data.</p>
<p>FAT doesn&#39;t have a valid data length. If you set file length, you may be able to read old data, or not, depending on whether you&#39;ve got pre-erased flash blocks. But this is OK, because FAT is not considered secure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030963">
				<div id="div-comment-1030963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030963">
			January 4, 2013 at 11:06 am</a>		</div>

		<p>@digiowl: &quot;meh, starting to think that USB drives should have a mandatory button with a led. When you want to remove the drive, you press the button and the led starts flashing. When it goes from flashing to solid you can remove the drive.&quot;</p>
<p>Mine has that. Of course, the button is in software, and instead of a flashing LED it pops up a little balloon that says it&#39;s now safe to remove. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030993">
				<div id="div-comment-1030993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030993">
			January 4, 2013 at 12:22 pm</a>		</div>

		<p>@Nawak: There&#39;s four reasons:</p>
<ol>
<li>&quot;Reserve&quot; isn&#39;t part of the quota system, length is. Consequently allowing people to have very large reserves (i.e. consuming lots of disk) with trivial quantities of quota being committed could be used maliciously.</li>
<li>
<p>&quot;Reserve&quot; is an implementation detail. In the current system NTFS (and other filesystems &#8211; NtSetInformationFile isn&#39;t NTFS specific) is allowed to ignore hints via NtSetInformationFile. If you make it contractual you start making life harder for future implementors who then have to be compatible with the concept of a &quot;reserve&quot; when it might not make sense to (e.g. network drives have no such concept). Although NTFS doesn&#39;t currently do this, it could in principle automatically reclaim &quot;reserve&quot; from files that don&#39;t need it. If the user specified that they wanted X amount of reserve and NTFS then did reclaim it, are you in breach of the API contract now?</p>
</li>
<li>
<p>You can&#39;t switch B and C in any model. The inode writeback always happens after the data has completed, otherwise there&#39;s a possibility that you&#39;ll update the commit length past where data has been written. If a power cut happens then and you remount you&#39;ll see garbage data at the end of the file, which might be part of another user&#39;s super-secret document. Note that this means that when there&#39;s a powercut, data you&#39;ve written might &quot;become&quot; garbage, but garbage will never &quot;become&quot; data in your file. Also filesize is always less than reserve (by the law of NTFS) and commit only changes in a journaled way, so the filesystem remains consistent in the even of a powercut &#8211; but the data in your file might not.</p>
</li>
<li>
<p>Most importantly, your solution doesn&#39;t actually present itself to the user as more intuitive or less annoying: Consider the two systems (the status quo and your suggestion) in the case where a 100MB transfer is interrupted at 4.5MB:</p>
</li>
</ol>
<p>In the status quo, the file is reported as 100MB. 100MB worth of actual space on the device is allocated to the file, and when you read it you get 4.5MB of good data and 95.5MB of zeroes. The user is angry because his presentation will not open in Powerpoint (i.e. &quot;stupid windows corrupted my file&quot;).</p>
<p>In your suggestion, the file is reported as 4.5MB. 100MB worth of actual space on the device is allocated to the file, and when you read it you get 4.5MB of good data and then the file ends. The user is still angry because his presentation still won&#39;t open in Powerpoint (i.e. &quot;stupid windows corrupted my file&quot;). Even more annoyingly, when he tries to copy a 450MB file next to it, he&#39;ll get a &quot;disk full&quot; error because 100MB is committed to the other file; but the user only thinks 4.5MB is on the USB stick. &quot;Stupid Windows. I have a 512 MB disk &#8211; why can&#39;t I put 450+4.5 = 454.5MB worth of files on it!&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1031003">
				<div id="div-comment-1031003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031003">
			January 4, 2013 at 12:31 pm</a>		</div>

		<p>To clarify in (2): NtSetInformationFile isn&#39;t a hint when setting file length (it is an instruction to change the file-length that must not be ignored). What&#39;s a hint is that the filesystem can use this opportunity to update the commit for the file. Currently it doesn&#39;t have to if it doesn&#39;t want to.</p>
<p>Also (4) is particularly insidious if a program allocates a 2GB reserve for a file and then crashes before it can put data in (e.g. your browser doing a big download and then crashes). When you start wondering why your disk is running low, no program &#8211; including the quota helper &#8211; will be able to help you &#8211; since all of these huge files are being reported by the filesystem as being really small! At least if you force the commit to be near the filesize you are able to detect these big corrupted files pretty quickly and can delete them if you no longer want them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031053">
				<div id="div-comment-1031053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jas71_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jas71@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031053">
			January 4, 2013 at 2:17 pm</a>		</div>

		<p>@configurator: &quot;Not that I know why you&#39;d need contiguous blocks on a thumb drive&quot;</p>
<p>Two reasons: first, it&#39;s still more efficient to read a single large block than multiple small ones (on the computer level, at least; within the drive itself, thanks to wear-levelling etc, it probably ends up as a series of non-consecutive blocks anyway); secondly, NTFS happens to encode data locations on disk as (start,length) tuples, so &quot;10Mb starting from 0x100&quot; is much more compact than &quot;1 block at 0x100, 1 block at 0x102, 3 blocks at 0x105, 1 block at 0x101&quot;. (There is also a free space bitmap, one bit per cluster,</p>
<p>@Paul Coddington: &quot;Still, not as bad as the techies who once insisted that NT machines should always use FAT on their system disk &quot;as recommended by Microsoft&quot; (like heck it was).&quot;</p>
<p>They&#39;d probably misinterpreted some of the early documentation about ARC (non-x86) systems requiring a FAT partition to boot from (x86 BIOS just executes the first 8k of the NTFS partition, which is $Boot, the boot loader; ARC boot loaders are a bit more complex, hence need a whole file system they can understand). The journalling point, I actually recall early IBM demos showing off their shiny new journelled AIX system with &quot;see, you don&#39;t need to do a proper shutdown, just pull the plug, because it&#39;s journalled&quot; &#8211; of course, in reality that takes a lot more than just a journalled file system to be a sane move to make.</p>
<p>@Nawak: Because of NTFS&#39;s extent-based structure, you could theoretically write the metadata for your file as &quot;this 10Gb file consists of 10Gb starting at sector 0x100&quot;, then go ahead and write the whole 10 Gb without touching that metadata again. (Or rather, to avoid exposing junk data, first you write out the 10 Gb, then you store that location in the Master File Table, then mark those data clusters and the MFT record as being occupied; with write-barriers to enforce ordering, removal or power failure before step 2 means there is no file; after step 2, the recovery process can set the usage bitmaps and index files appropriately when mounting, if needed.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1031063">
				<div id="div-comment-1031063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031063">
			January 4, 2013 at 3:26 pm</a>		</div>

		<p>Ultimately, on graceful close, the reserved allocation will be truncated to the current file length, even if there was a reservation.</p>
<div class="post">[<em>Um, the discussion is about what happens when there is <span style="text-decoration:underline;">not</span> a graceful close. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030873">
				<div id="div-comment-1030873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030873">
			January 4, 2013 at 7:38 am</a>		</div>

		<p>@Matt: I understand what you are saying, but where NTFS&#39;s &quot;fault&quot; lies is that NtSetInformationFile only offer to change a file&#39;s allocation by changing its size.</p>
<p>I agree that it is CopyFile being clever, but CopyFile could have been more clever if NTFS had proposed a service to only change allocation. As it is now, NTFS can consider itself right because what CopyFile instructs it to do is to actually do two &quot;data write passes&quot;:</p>
<p>A) One (invisible) write pass to set the file size: The EOF information is changed *and* all the data belonging to the allocated space is considered part of the file (that&#39;s why I call it a write pass). (An interesting note is that the doc doesn&#39;t say that the file is filled with zero, so you may end up with somebody else&#39;s data?)</p>
<p>B) One write pass to fill the file with the correct data. This pass doesn&#39;t change the file&#39;s size.</p>
<p>When NTFS is repairing the filesystem by looking at the journal, it doesn&#39;t revert the file&#39;s size since it was changed on step A and not step B (step A was correctly completed)</p>
<p>If I were to assign the blame (that&#39;s always the fun part of being a user), I would still blame NTFS. Yes even if I just said that it did what it was instructed to do! Because by not offering a service to change a file&#39;s allocation without changing its size, it forced CopyFile to worsen a case to get acceptable performance:</p>
<p>&#8211; either CopyFile didn&#39;t preallocate: the corruption caused by the unexpected drive removal would be more visible but the global performance would have sucked (too many file-info updates),</p>
<p>&#8211; or it did preallocate (by pre-sizing): the corruption caused by the unexpected drive removal is much less visible but the global performance is correct.</p>
<p>I think CopyFile ended up doing the right choice because the nominal case (no unexpected drive removal) is faster and the slower alternative wouldn&#39;t have made the corruption go away anyway.</p>
<p>(BTW, when I said in an earlier post that a wrong decision had been made regarding the performance vs the &quot;correct behaviour&quot;, I thought that it was NTFS being clever with what it had been asked to do, but now, knowing that one cannot allocate without resizing, I think that NTFS&#39;s wrong decision is actually to not have the allocation service!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1031093">
				<div id="div-comment-1031093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031093">
			January 4, 2013 at 5:11 pm</a>		</div>

		<p>Matt: The problem with having a corrupt file with the correct metadata is that it&#39;s not obvious that the file bits are corrupt. It&#39;s all too easy to see the correct size and timestamp and think it&#39;s the same file, only to find out the hard way that it&#39;s mostly zeros.</p>
<p>Perhaps a better thing to do is create the file under a different name, and only rename it to the proper name once the copy is complete. Of course this has the problem of what happens if somebody creates a file (or worse, directory) of that name while the copy is in progress.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030933">
				<div id="div-comment-1030933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030933">
			January 4, 2013 at 9:34 am</a>		</div>

		<p>@Nawak: CopyFile doesn&#39;t ask NTFS to do two data passes. Setting the information length allocates more blocks from the bitmap into the NTFS file structure. It doesn&#39;t write any data (other than the change to the file inode and journalling the change) to disk</p>
<p>I think perhaps you are confused about the NTFS file inode &#8211; each file has three key &quot;lengths&quot; with regards to data:</p>
<p>* A &quot;reserve&quot; capacity, which is the number of allocated blocks that the file has exclusive rights to use. Writing data to these blocks is not journalled, but changing the capacity up or down is journalled. Reserve capacity is measured in whole data chunks.</p>
<p>* A &quot;commit&quot; length, which is the number of bytes in the allocated blocks that have valid data. This pointer allows NTFS to avoid writing 10MB of zeroes when you allocate a new file and tell it via NtSetInformationFile that the file is 10MB big. Whenever someone in usermode asks for data after this length, NTFS returns zeroes instead of data from the disk.</p>
<p>* A &quot;filesize&quot; length, which is the reported length of the file.</p>
<p>Consequently we can see that the actual actions going on are:</p>
<p>1. CreateFile, which allocates the inode in the first place, is a journalled action and which sets the filesize to 0, commit to 0 and potentially allocates some reserve.</p>
<p>2. NtSetInformationFile, which sets the filesize to the size requested, sets the &quot;reserve&quot; capacity to equal than or bigger than the size, but does not modify the &quot;commit&quot; length (unless you shrink the file). This is journalled since allocating blocks from the bitmap is a journalable action.</p>
<p>3. WriteFile, which spits data into committed data chunks and updates the &quot;commit&quot; pointer.</p>
<p>If the NtSetInformationFile wasn&#39;t there, then whenever the &quot;commit&quot; pointer reached the &quot;reserve&quot; pointer, the filesystem would have to allocate more &quot;reserve&quot; for the file, suffering a massive delay for the journal and the filesystem lock. Since NTFS wants files to be small on disk, this happens depressingly often in a 10MB copy &#8211; hence why CopyFile chooses not to do it this way.</p>
<p>Note that because WriteFile isn&#39;t a journalled action, any power cut will either leave the file uncreated (before 1), created by zero size (before 2), or created with a correct destination size but with corrupted data (after 2).</p>
<p>If your suggestion of rolling back the length was implemented, you&#39;d suffer all of the same problems, except now you&#39;d lock and journal the filesystem much more often, but still wouldn&#39;t protect against the file being corrupted &#8211; since midway through the WriteFile after you&#39;ve committed, say 5MB of the 10MB file the power could go and you&#39;ll be left with a 5MB commit with 4.5MB of data in it, instead of a 10MB file with 4.5MB of data in it. </p>
<p>Note that from the user&#39;s perspective both of these are equivalent: The user asked you to copy a file, he took the stick out too early, and he ended up with a file on his USB stick that he can&#39;t open in MS Word when he gets to work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030973">
				<div id="div-comment-1030973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1030973">
			January 4, 2013 at 11:23 am</a>		</div>

		<p>@Matt and alegr1: thanks, yes, the &quot;commit&quot; field presence answers my question about reading old data. I was quite sure that there was something to prevent it, but it wasn&#39;t spelt out in the doc of NtSetInformationFile, hence my question.</p>
<p>@Matt: Why couldn&#39;t NtSetInformationFile also allow just modifying the &quot;reserve&quot; field? (With another flag, also keeping the current behaviour)</p>
<p>Then the scenario would be:</p>
<p>1. CreateFile =&gt; (reserve=X, commit=0, filesize=0) (X: unknown, implementation detail)</p>
<p>2. NtSetInformationFile =&gt; (reserve&gt;=FinalSize, commit=0, filesize=0)</p>
<p>3a. WriteFile =&gt; (reserve&gt;=FinalSize, commit=WriteSize, filesize=WriteSize)</p>
<p>3b. WriteFile =&gt; (reserve&gt;=FinalSize, commit=WriteSize*2, filesize=WriteSize*2)</p>
<p>etc.</p>
<p>This would still leave the strangeness of incomplete data and complete size, but only for the last write.</p>
<p>This is still solvable, even with WriteFile being unjournalled.</p>
<p>This is how I envision WriteFile&#39;s (simplified) operations:</p>
<p>A) Allocate space if necessary (update of &quot;reserve&quot; possible)</p>
<p>B) Write data into committed space</p>
<p>C) Update &quot;commit&quot; and &quot;filesize&quot; if necessary (if the write enlarged the file)</p>
<p>Now, without being a full journaled FS, NTFS could do these operations in this order (just to maintain the coherency that Nawak needs so much) but I understand that a good optimization is to do A+C in one disk write, and since you wouldn&#39;t want to lose track of sectors, you cannot order this way &quot;(A1)find space-&gt;(B)write data-&gt;(A2+C)update reserve&amp;commit&amp;filesize&quot;. So that optimization forces the order to A+C-&gt;B (ie, the order which can lead to what I called an &quot;incorrect&quot; behaviour)</p>
<p>But when A isn&#39;t necessary (space has already been allocated), the order could still be B-&gt;C instead of C-&gt;B with the same performance. Is it worth the added complexity? My opinion would have been yes but the NTFS team already has answered no!</p>
<p>PS:</p>
<p>I hope my answers don&#39;t show up as stubbornness. It is a subject I find very interesting and I take the opportunity of this blog post (and its comments) to clear my misconceptions! ;-)</p>
<p>You always learn a lot by reading rebuttals of your solutions!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com odd alt thread-odd thread-alt depth-1" id="comment-1031103">
				<div id="div-comment-1031103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031103">
			January 4, 2013 at 10:19 pm</a>		</div>

		<p>Now here&#39;s the thing. On Windows 8, my new 32 GB Transcend flash drive is set to &#39;Optimize for quick removal&#39; and yet the Format dialog lists NTFS, exFAT and FAT32 as available choices.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com even thread-even depth-1" id="comment-1031113">
				<div id="div-comment-1031113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031113">
			January 4, 2013 at 10:38 pm</a>		</div>

		<p>I checked that same drive on XP/Vista/7/8 and XP blocks NTFS if it&#39;s set for Quick Removal and allows NTFS if set for Performance but Vista and later OSes allow formatting it as NTFS irrespective of whether it&#39;s set for Quick Removal or Performance. Bug or by design?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031123">
				<div id="div-comment-1031123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031123">
			January 5, 2013 at 1:34 am</a>		</div>

		<p>@Gabe: Short of enforcing some sort of checksum on all the data and metadata, I don&#39;t see how you can tell if a file is corrupt simply by looking at its metadata anyways. Sure, if the file is significantly shorter or longer than you think it should be then there&#39;s probably a problem, but often the problem is that the file is missing the last 4KB of a 10MB file.</p>
<p>It is too bad that there is no locking mechanism in the USB physical spec. That would remove a lot of the problems that we are talking about (and magnify other problems, like the &quot;file is in use, therefore preventing removal&quot; error!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1031173">
				<div id="div-comment-1031173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031173">
			January 5, 2013 at 6:29 am</a>		</div>

		<p>Does Transcend present itself as a USB hard drive?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031193">
				<div id="div-comment-1031193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031193">
			January 5, 2013 at 6:42 am</a>		</div>

		<p>@xpclient: FAT32 can&#39;t be used for drives with more than 4GB. Windows8 will either choose NTFS or FAT32 for thumb drives, and since FAT32 is out of the question, you&#39;re stuck with NTFS regardless of how you choose to &quot;optimise&quot; the drive. If Windows8 blocked your drive from being formatted as NTFS and hence at all because you select &quot;optimise for quick removal&quot; or truncated your device to a 4GB FAT device then you&#39;d just complain about that instead.</p>
<p>@gabe: This suggestion doesn&#39;t get fixed by using Nawak&#39;s suggestion. Suppose CopyFile doesn&#39;t set the length up front and does 500 WriteFiles to transfer the data. In this case, NTFS will up the commit, say, 250 times on the file, journalling each time. At each write, NTFS is allowed to up the filesize before the data has reached disk, it just isn&#39;t allowed to update the commit before the data reaches the disk. Consequently it is possible that on the 500th WriteFile NTFS journalling ups the reserve, ups the file-length at the same time (i.e. coaleses the inode writeback) and then the power goes (or the disk gets removed) before the data from the final WriteFile reaches the disk.</p>
<p>In this case we&#39;re back to the status quo: The user can&#39;t open the file in Powerpoint (i.e. it is corrupt), the filesize is the same as the filesize from the file being copied and the attributes are correct. If you open the file on the other computer you&#39;ll see zeroes at the end because data writes aren&#39;t journalled.</p>
<p>A better way of solving this problem is to ask a different question: &quot;how can a user be sure the CopyFile succeeded?&quot;. If we&#39;re willing to ignore the fact that devices can also implement caches, the answer is simple: The only way to be sure that the data is still there is to ask NTFS to unmount the drive (to flush everything to the disk), remount it, open the file, read it all out and compare the bytes (or a hash of those bytes).</p>
<p>Now explorer could do this &#8211; but doing so would completely tank the performance for the user. Which leads us to the next question: Which would a user prefer: Being able to copy 100MB onto their disk in 2 minutes but require them to unmount the drive, or require the user to wait 5 minutes but not require them to? Bear in mind when answering this question that Microsoft&#39;s competitors might go for the 2 minutes solution and if Microsoft goes for the 5 minute one they might be berated in the press for &quot;having slow file copy times&quot; and for destroying your thumb-drives twice as quickly as their competitors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1031213">
				<div id="div-comment-1031213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031213">
			January 5, 2013 at 9:57 am</a>		</div>

		<p>@Matt:</p>
<p>FAT32 has much higher limit for partition size and 4GB limit is for files only.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com odd alt thread-odd thread-alt depth-1" id="comment-1031223">
				<div id="div-comment-1031223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031223">
			January 5, 2013 at 10:05 am</a>		</div>

		<p>@Matt Do you notice a tone of complaint in my comment? I asked a question. There is still exFAT so from what I read on <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/04/05/108205.aspx" rel="nofollow">blogs.msdn.com/&#8230;/108205.aspx</a> it can be inferred that NTFS is blocked unless &#39;Optimize for performance&#39; is set.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1031233">
				<div id="div-comment-1031233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031233">
			January 5, 2013 at 11:57 am</a>		</div>

		<p>FAT32 (artificial) volume size limit is 32 GB. Over than that, exFAT should be recommended. Actually, it makes sense to use exFAT for smaller drives, unless you plan to use the drive at systems where exFAT is not inbox, or not installed as update.</p>
<blockquote><p>
  how can a user be sure the CopyFile succeeded?
</p></blockquote>
<ol>
<li>
<p>Make sure CopyFile issues FlushFileBuffers for removeable volume.</p>
</li>
<li>
<p>For a removable volume, limit amount of write-back to 1-2 seconds worth of data, and have a short write-back idle delay. This is for applications that don&#39;t use CopyFile.</p>
</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031243">
				<div id="div-comment-1031243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@xpclient</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031243">
			January 5, 2013 at 12:34 pm</a>		</div>

		<blockquote><p>
  &gt;&gt; &quot;Do you notice a tone of complaint in my comment?&quot;.
</p></blockquote>
<p>Yes. Almost everything you say on Rayomond&#39;s blog is phrased in a critical way. Rather than &quot;Bug or feature?&quot; you could have phrased it less agressively, e.g. &quot;why is that?&quot; or &quot;am I missing something?&quot;, rather than just assuming that things not working as you expect is because the feature is broken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1031313">
				<div id="div-comment-1031313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">f0dder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031313">
			January 6, 2013 at 5:52 pm</a>		</div>

		<p>I was thinking that having an in-memory &quot;eventual filesize hint&quot; for NTFS could have been a nice thing &#8211; something that wouldn&#39;t be used in the on-disk structures, simply a best-effort thing for the driver to take into consideration while the operation is still running. If the process crashes, file size would be trimmed to the (journalled as normally) FS metadata updated by the last write.</p>
<p>But after pondering a bit:</p>
<p>1) starts at -1000, is probably hard to do right, and doesn&#39;t bring much to the table.</p>
<p>2) doesn&#39;t solve the &quot;file /contents/ might be corrupt&quot; problem.</p>
<p>2) while (likely) reducing fragmentation, you still get &quot;a zillion&quot; metadata updates, so the copy will be slower than really pre-allocating the output file size.</p>
<p>Bonus question: is there a way to pre-allocating a file size and then writing to an arbitrary location in it, without (NTFS) having to zerofill from the former last-valid location to the current random offset? Last time I played around with that was back on XP, and SetFileValidData() seemed a bit dangerous and privilege-hungry for general purpose. Sparse Files were obviously counterproductive to the goal of avoiding fragmentation :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031343">
				<div id="div-comment-1031343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031343">
			January 7, 2013 at 12:52 am</a>		</div>

		<p>@fodder: &quot;is there a way to pre-allocating a file size and then writing to an arbitrary location in it, without (NTFS) having to zerofill from the former last-valid location to the current random offset?&quot;</p>
<p>Yes. Sparse files.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1031393">
				<div id="div-comment-1031393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031393">
			January 7, 2013 at 7:56 am</a>		</div>

		<p>Raymond: &quot;Write-behind caching is disabled by default on removable drives. You get into this mess only if you override the default.&quot;</p>
<p>xpclient: &quot;I checked that same drive on XP/Vista/7/8 and XP blocks NTFS if it&#39;s set for Quick Removal and allows NTFS if set for Performance but Vista and later OSes allow formatting it as NTFS irrespective of whether it&#39;s set for Quick Removal or Performance.&quot;</p>
<p>There seems to be an underlying story here which I&#39;ve somehow missed. &nbsp;Did Windows Vista introduce support for NTFS and Quick Removal? &nbsp;Did prior versions of Windows not support that configuration?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031503">
				<div id="div-comment-1031503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">f0dder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031503">
			January 7, 2013 at 9:59 am</a>		</div>

		<p>@Matt: &quot;Yes. Sparse files.&quot;</p>
<p>You didn&#39;t read my entire post? Let me quote the relevant part: &quot;Sparse Files were obviously counterproductive to the goal of avoiding fragmentation :)&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1031473">
				<div id="div-comment-1031473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031473">
			January 7, 2013 at 9:18 am</a>		</div>

		<p>Raymond, I think the confusion arose because your first sentence says you need to do X to enable formatting as NTFS, while later on you talk about the write-behind cache. Frankly, I&#39;m still confused, even after your clarification :)</p>
<p>On my Win7, I was able to format a USB hard drive as NTFS without making any promises or agreeing to any warning dialogs. I assume the write caching is disabled, based on what you say about that being the default. Therefore, I should be safe to yank it and expect the just-copied *data* to survive too (not just filesystem metadata), right?</p>
<div class="post">[<em>If the rules changed in Windows 7, nobody told me about it. (Not that I expected them to.) But the point of discussion is &quot;If I yank a thumb drive before delayed writes are complete, why doesn&#39;t journaling fix the problem?&quot; The rules around delayed writes may have changed, but that doesn&#39;t affect the discussion. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031603">
				<div id="div-comment-1031603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031603">
			January 7, 2013 at 7:04 pm</a>		</div>

		<blockquote><p>
  But the point of discussion is &quot;If I yank a thumb drive before delayed writes are complete, why doesn&#39;t journaling fix the problem?&quot;
</p></blockquote>
<p>Oh, I see. This makes sense. May I humbly suggest that the title of this entry is somewhat misleading then? It <em>sounds</em> like you intend to discuss why you can&#39;t just yank an NTFS formatted USB drive: note the part where the title seems to assert that &quot;you have to be careful when using [NTFS] with a USB thumb drive&quot; &#8211; but you go on to clarify that this only applies if delayed writes are permitted.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1031593">
				<div id="div-comment-1031593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031593">
			January 7, 2013 at 1:42 pm</a>		</div>

		<p>&gt;&gt; Ultimately, on graceful close, the reserved allocation will be truncated to the current file length, even if there was a reservation.</p>
<p>&gt; [Um, the discussion is about what happens when there is not a graceful close</p>
<p>@Raymond: Indeed, but alegr1&#39;s remark can apply to the fsck done during the drive remount. Since the last operation didn&#39;t finish, the allocated space could be reclaimed. Also, reading back I think that alegr1&#39;s remark applied to Matt&#39;s second comment about some (apparently small) files&#39; allocation staying very large after a browser crash. In that case, the OS would do the graceful close (from the FS POV) on process exit, wouldn&#39;t it?</p>
<p>@Matt:</p>
<p>1) Reserve being part of quota: well, ok, but could as well be! I think including would still be fair (since reserved space isn&#39;t available to other users), so another decision I&#39;ll have to contest! ;-). Note that I don&#39;t advocate having a &quot;reserve&quot; marginally different from the &quot;size&quot; after a close (or remount). This would only be a hint for opened files.</p>
<p>2) Implementation detail? Let&#39;s call it optional functionality! If the reservation promise isn&#39;t kept then it&#39;s only a performance degradation for the offending FS. So I think every FS could return OK without doing anything. Reserve space qualify as a hint and isn&#39;t therefore contractual so no API would be broken in your case. If you want to talk about implementation details, being able to fill up a file with zeroes at no cost when resizing it, *that* is an implementation detail! And implementing this could be way harder for another FS than answering OK to a hint it didn&#39;t take.</p>
<p>3) You are right. So that&#39;s always A-&gt;B-&gt;C with A being optional. So if you implement a service that allocates and set the reserve, there&#39;s no extra cost at all, since you still have to at least update the commit at each write (commit+filesize in my solution, but maybe the informations aren&#39;t in the same physical places?)</p>
<p>4) I already acknowledged that. The benefit was that the corruption was more visible.</p>
<p>@Matt and others: Yes, none of what I propose would magically uncorrupt a file from a drive that has been removed before the end of the operation. The initial point was to make it more visible that something went wrong, even if I admit that not everyone knows what size a particular file should be&#8230; Wait! No, the start of all this was my surprise of seeing Raymond say that having the final size at the end of the auto-repair was the correct behaviour. I now know that it is indeed correct considering what CopyFile asked. Hilarity ensued when I asked for another service! ;-)</p>
<p>@f0dder:</p>
<p>&#8211; I agree that when an FS/API is already designed, coded and tested, that kind of service would have to gain a lot of points to justify the work. Still doesn&#39;t make the requested behaviour &quot;incorrect&quot; or wrong to examine.</p>
<p>&#8211; for your second &quot;2)&quot;: there wouldn&#39;t be more metadata updates than there already is. As Matt noted, you still have to change the commit size at each write. If my uninformed opinion is correct, you could update the size in the same write.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031623">
				<div id="div-comment-1031623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130101-00/?p=5673#comment-1031623">
			January 8, 2013 at 1:06 am</a>		</div>

		<p>@f0dder: &quot;You didn&#39;t read my entire post? Let me quote the relevant part: &quot;Sparse Files were obviously counterproductive to the goal of avoiding fragmentation :)&quot;</p>
<p>Well sparse files are the only way to achieve what you want &#8211; and the fragmentation of sparse files across disk is a fairly small problem &#8211; ranges are automatically collected and nearly full sparse files are automatically converted to non-sparse files by background tasks in Windows. Sparse files are ordered collections of &quot;ranges&quot; of blocks where blocks outside of those ranges are zero. All other files have a &quot;valid data&quot; pointer where the data before that value holds non-garbage data on disk.</p>
<p>Consequently if you want to write the last 4KB of a 1GB file without writing the other blocks to disk you have to either use sparse files, or suffer the large write of zeroes back to disk.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>