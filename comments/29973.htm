<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (39)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-larryosterman even thread-even depth-1" id="comment-413013">
				<div id="div-comment-413013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Larry+Osterman+%5BMSFT%5D' rel='external nofollow' class='url'>Larry Osterman [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413013">
			August 24, 2006 at 10:04 am</a>		</div>

		<p>I got into a two day long screaming match with one of the testers in Exchange because he was upset about this behavior and insisted that inherited ACEs shouldn&#8217;t change on a copy :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413023">
				<div id="div-comment-413023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413023">
			August 24, 2006 at 10:10 am</a>		</div>

		<p>Weird.</p>
<p>Any idea why inherited attributes aren&#8217;t calculated when the file is accessed?</p>
<p>That would eliminate the need for explicit requests for inherited attributes to be propagated, and remove the &quot;file exists in 2 locations&quot; dilemma, because even if it exists at 2 locations, it&#8217;s only accessed by one of them at a time. If you accessed it through DirA, you&#8217;d inherit permissions from DirA, and through DirB likewise.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413033">
				<div id="div-comment-413033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon Payne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413033">
			August 24, 2006 at 10:13 am</a>		</div>

		<p>Why does &quot;Use simple file sharing&quot; affect the ACLs of copied files? &nbsp;If I wanted to enable or disable this behaviour, I wouldn&#8217;t have guessed I needed to click on that check box.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413073">
				<div id="div-comment-413073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TKW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413073">
			August 24, 2006 at 10:41 am</a>		</div>

		<p>@Adam &#8211; speed, I&#8217;m sure, for one although there will be other, subtler, reasons as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413103">
				<div id="div-comment-413103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.gotdotnet.ru/personal/mihailik/PermaLink.aspx?guid=940b18e0-1a4b-4882-be5f-c4ec679312a2' rel='external nofollow' class='url'>Олег Михайлик</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413103">
			August 24, 2006 at 10:50 am</a>		</div>

		<p>Управление правами на файлы и папки в NTFS, то есть ACL, с самого начала задумыв</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413113">
				<div id="div-comment-413113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Asky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413113">
			August 24, 2006 at 10:51 am</a>		</div>

		<blockquote><p>
  &gt; All right, then. We have no choice but to decide that a file&#8217;s ACLs don&#8217;t change when you create a hard link. </p>
<p>Which brings to the question : why the ACLs are on the files and not on &quot;links&quot; in unix style ?<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413123">
				<div id="div-comment-413123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413123">
			August 24, 2006 at 10:56 am</a>		</div>

		<p>TKW : Speed shouldn&#8217;t be an issue, as when you try to access/execute/open a file, the kernel needs to check the ACLs of all the elements of the full path anyway to make sure you&#8217;re allowed to access it.</p>
<p>Yes, you might have read permission on the file &quot;c:dirreadme.txt&quot; according to that file&#8217;s ACL, but if you&#8217;re not allowed to read/list/access &quot;c:dir&quot;, the kernel has to enforce that.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413133">
				<div id="div-comment-413133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413133">
			August 24, 2006 at 11:03 am</a>		</div>

		<p>Asky : In Unix &amp; derivatives, attributes are on files, not links.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413173">
				<div id="div-comment-413173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.damieng.com/blog/' rel='external nofollow' class='url'>Damien Guard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413173">
			August 24, 2006 at 11:18 am</a>		</div>

		<p>Adam, they&#8217;ve have to store permissions in the link then and not the file itself. &nbsp;I guess this would be a big change.</p>
<p>What is more annoying is that VisualStudio.NET seems to use the file attributes of obj directories to create the binaries of bin</p>
<p>I guess it actually creates the binaries in obj and then moves them to bin and keeps the obj permissions.</p>
<p>[)amien</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413183">
				<div id="div-comment-413183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413183">
			August 24, 2006 at 11:20 am</a>		</div>

		<p>Asky, you are wrong, UNIX stores mode bits in the vnode, just like how Windows filesystems cache the security descriptor in the FCB. It&#8217;s so taken for granted that the specification doesn&#8217;t even mention it, and in any case how do you suppose fstat and fchmod would work?</p>
<p>(also note: storing and retrieving the security descriptor is left to the discretion of the filesystem. The I/O subsystem works on FILE_OBJECTs, and how do these map to the underlying files isn&#8217;t specified. So it COULD be done, if not for the blatant violation of the &quot;least surprise&quot; principle)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413223">
				<div id="div-comment-413223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413223">
			August 24, 2006 at 11:38 am</a>		</div>

		<p>Adam: &quot;the kernel needs to check the ACLs of all the elements of the full path anyway to make sure you&#8217;re allowed to access it&quot;</p>
<p>The kernel doesn&#8217;t usually bother. &nbsp;Users typically have the &quot;Bypass traverse checking&quot; privilege, which disables the check.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413243">
				<div id="div-comment-413243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://raw-output.org/' rel='external nofollow' class='url'>Jacobo</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413243">
			August 24, 2006 at 11:45 am</a>		</div>

		<p>Permissions are stored in the file, not in the link, to keep people from accessing/modifying/deleting files by just creating hard links to them with the appropriate permissions :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413313">
				<div id="div-comment-413313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sandman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413313">
			August 24, 2006 at 12:41 pm</a>		</div>

		<p>&quot;because a single file can have multiple parent folders, thanks to hard links&quot;</p>
<p>Yikes. Are you saying the windows kernel supports hardlinking directories.</p>
<p>Unix doesn&#8217;t allow this delibarately because it introduces to many corner cases &#8211; the worst being that you need prevent cycles in hardlinks hanging the kernel. The only easy way I can see to prevent this is a depth limit.</p>
<p>What does windows do? (Can anyone point me at a KB article on this?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413343">
				<div id="div-comment-413343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413343">
			August 24, 2006 at 12:56 pm</a>		</div>

		<blockquote><p>
  Permissions are stored in the file, not in the link, to keep people from accessing/modifying/deleting files by just creating hard links to them with the appropriate permissions :) </p>
<p>This seems easily solvable with a &#8220;create hardlink&#8221; permission in the ACL. &nbsp;That might not even be necessary because the attacker would need access to the file to create the link in the first place. </p>
<p>You are right though that people would have to be careful what permissions were inherited otherwise it would be easy to &#8220;lose&#8221; them.</p>
<div CLASS=post>[<i>This imaginary &#8220;create hardlink&#8221; permission would be a security hole. If you granted me &#8220;create hardlink&#8221;, I would create a hardlink, then edit the ACLs on my hardlink to grant me full control of the file. Bingo, I&#8217;ve elevated from &#8220;create hardlink&#8221; to &#8220;full control&#8221;. -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413363">
				<div id="div-comment-413363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413363">
			August 24, 2006 at 2:01 pm</a>		</div>

		<p>A file may live in multiple directories due to hard linking, but how would you trace all those links backwards? The reference is likely stored in the directory, and there&#8217;s no indexed way to get at it from the file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413393">
				<div id="div-comment-413393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kuwanger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413393">
			August 24, 2006 at 2:41 pm</a>		</div>

		<p>&#8216;[This imaginary &#8220;create hardlink&#8221; permission would be a security hole. If you granted me &#8220;create hardlink&#8221;, I would create a hardlink, then edit the ACLs on my hardlink to grant me full control of the file. Bingo, I&#8217;ve elevated from &#8220;create hardlink&#8221; to &#8220;full control&#8221;. -Raymond]&#8217; </p>
<p>So by your logic, &#8220;full control&#8221; is a security hole and not a permission setting?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413423">
				<div id="div-comment-413423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413423">
			August 24, 2006 at 3:29 pm</a>		</div>

		<p>Asky &#8211; you may be thinking of symlinks instead of hard links.</p>
<p>Adam &#8211; more on &quot;bypass traverse checking&quot;: <a rel="nofollow" target="_new" href="http://www.sysinternals.com/blog/2005/10/bypass-traverse-checking-or-is-it.html" rel="nofollow">http://www.sysinternals.com/blog/2005/10/bypass-traverse-checking-or-is-it.html</a></p>
<p>sandman &#8211; no, hard links are supported only for files. &nbsp;Read that again carefully: a <em>file</em> can have multiple parent folders because it can be linked from two different places in the directory tree.</p>
<p>Kuwanger &#8211; the hypothetical scenario is that hard links have their own ACLs, controlling access to the underlying file through them, and the underlying file has a &quot;create hardlink&quot; privilege required for anyone to create a new link to it. &nbsp;In that situatation, being able to elevate your own permissions from &quot;create hardlink&quot; to &quot;full control&quot; on a file you do not have the ability to set an ACL on (by setting an ACL on the link instead) is a security hole.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413443">
				<div id="div-comment-413443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">microbe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413443">
			August 24, 2006 at 3:32 pm</a>		</div>

		<p>It&#8217;s a long, confusing article to express something as simple as &#8220;security attributes are stored with inodes, not file anmes&#8221;. </p>
<p>What&#8217;s the inode equivalent in Windows?</p>
<div CLASS=post>[<i>But that simple sentence doesn&#8217;t actually explain <u>why</u> moving the inode doesn&#8217;t update the security attributes. (The Windows term for inodes is just &#8220;files&#8221;.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413473">
				<div id="div-comment-413473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413473">
			August 24, 2006 at 4:00 pm</a>		</div>

		<p>Random: Thanks for the link. Very useful.</p>
<p>I&#8217;m still unconvinced about whether &quot;bypass traverse checking&quot; is a security hole or not, but it sure sounds like an administrative nightmare. Given a heirarchy of folders and files with a mix of ACLs which, for a specific groups of users, include some files with read/write access, some with read-only access, and some with no access, imagine you want to temporarily revoke all access to the files to those users. (e.g. because you want to do an atomic snapshot of the tree, or even a restore, or because you suspect a break-in, whatever).</p>
<p>If users don&#8217;t have the bypass-traverse checks, you can just deny them access to the top level directory for a time. Bingo.</p>
<p>If users do have bypass-traverse checks, how do you easily backup just the ACLs of every single file in that heirarchy so you can replace them with &quot;no access&quot;, and then just restore all the orginal ACLs, whatever they were? Is there an easy way to do that with the administrative tools provided by the OS?</p>
<p>And you can&#8217;t disble bypass-traverse checking for the users, as they might be relying on it for access to some other part of the OS which you don&#8217;t want to change their access to.</p>
<p>And, AFAICT, there&#8217;s no way to disable it for a portion of the OS.</p>
<p>So, how do Windows admins solve this? Anyone?</p>
<p>(With apologies for the topic-wandering)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413483">
				<div id="div-comment-413483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413483">
			August 24, 2006 at 4:51 pm</a>		</div>

		<p>re: Why don&#8217;t they store the ACL with each name rather than with the file?</p>
<p>Well, because for a start it would give you problems when opening a file in such a way that you present no name at all ;-)</p>
<p>The file system allows one to open a file &#8216;by file id&#8217; (option FILE_OPEN_BY_FILE_ID in NtOpenFile).</p>
<p>This seems to be little used in Windows apps (I&#8217;m not even sure whether it can be expressed in Win32) although I used to use it all the time in VMS. &nbsp;The basic idea is that, once you&#8217;ve opened a file once, subsequent opens can be &#8216;by id&#8217; and then you don&#8217;t have to even think about what might happen if &quot;foo.bar&quot; turned out to refer to different objects between one open and the next.</p>
<p>Back to the main point though &#8211; it seems to me that protecting the name of an object rather than the object itself would be deeply confusing from a philosophical point of view.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413493">
				<div id="div-comment-413493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413493">
			August 24, 2006 at 4:54 pm</a>		</div>

		<blockquote><p>
  I&#8217;m still unconvinced about whether &quot;bypass<br />
  <br />&gt;traverse checking&quot; is a security hole or not.</p>
<p>It is not actually a hole, in that you can always attempt to open the target file without using any path (open-by-id, see above) and thus you&#8217;d be traversing nothing.</p>
<p>I guess it might be a little easier to deal with names rather than guessing file ids, so it might have some practical ramifications.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413503">
				<div id="div-comment-413503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Foolhardy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413503">
			August 24, 2006 at 5:14 pm</a>		</div>

		<p>Just to clairify, if you have a directory A with a file B inside it and you use the shell&#8217;s ACL editor to change inheritable ACEs on A, it&#8217;ll silently update B&#8217;s ACL (as long as B&#8217;s DACL isn&#8217;t marked protected) and any other children of A, recursively. You don&#8217;t need to check the &quot;Replace permission entries on all child objects&#8230;&quot; option: that option also clears explicit entries and overrides protected ACLs.</p>
<p>This behavior can be seen with filemon, and is probably because the shell calls SetNamedSecurityInfo, which as documented &quot;automatically propagates any inheritable access control entries (ACEs) to existing child objects, according to the rules of inheritance.&quot;<br />
<br />Rules of inheritance: <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/ace_inheritance_rules.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/ace_inheritance_rules.asp</a></p>
<p>This is not true if you call SetKenelObjectSecurity or SetFileSecurity, which can be a point of confusion: these functions only edit the specified object or file (without propogating inheritable entries).</p>
<p>What&#8217;s also confusing is that if you opt to replace child entries from the shell&#8217;s editor, a progress dialog displaying every file modified will be shown, but if you just do normal propogation, no such dialog is shown, even when the same set of files is modified. It can make it seem like only the override option actaully touches the child files.</p>
<p>In any case, I appreciate any articles that help dispell some of the mystery of how NT&#8217;s security system actually works.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413533">
				<div id="div-comment-413533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413533">
			August 24, 2006 at 6:25 pm</a>		</div>

		<p>Dave: But you point in your previous post that to open a file &quot;by id&quot;, you need to have already opened it once by name first. Therefore you will have to have passed an ACL check already to have got the id to re-open the file with.</p>
<p>Yeah, it&#8217;s not an issue if you try to open random files by their id, but &#8211; it seems weird on an FS that supports inherited permissions to allow a non-administrator to sidestep the very namespace (directory structure) that those permissions are inherited through.</p>
<p>Guess it&#8217;s a good job I&#8217;m not in FS design. :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413543">
				<div id="div-comment-413543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413543">
			August 24, 2006 at 7:03 pm</a>		</div>

		<p>The sysinternals comments also indicate that opening files by ID requires the Bypass Traverse Checking privilege anyway.</p>
<p>Adam, one common scenario for a hierachy with users at different privilege levels like that is with a Windows share. &nbsp;In that case you use the share permissions as if they were &quot;all or nothing&quot;, and use filesystem DACLs to control things in a fine-grained way. &nbsp;Since everyone is accessing it through the share, when you need to temporarily block access to a specific group you just deny them at the share level.</p>
<p>That is, of course, specific to a Windows fileserver scenario. &nbsp;I&#8217;m not sure how you would approach the general case.</p>
<p>And yes, while the NT security system is quite flexible and powerful, keeping it all straight is one hell of an administrative nightmare.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413303">
				<div id="div-comment-413303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413303">
			August 24, 2006 at 12:40 pm</a>		</div>

		<p>Carlos : *boggle*<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413583">
				<div id="div-comment-413583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">microbe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413583">
			August 24, 2006 at 9:52 pm</a>		</div>

		<p>&#8220;security attributes are stored with inodes, not file anmes&#8221;. </p>
<p>: [But that simple sentence doesn&#8217;t actually explain why moving the inode doesn&#8217;t update the security attributes. </p>
<p>No it does. Moving an inode doesn&#8217;t change the inode itself. It just changes directory entries (pathnames) that point to it. </p>
<p>Similar for hardlinks. When you create a hardlink you only creates a new directory entry, and updates the refcount on the inode, nothing else. </p>
<div CLASS=post>[<i>That&#8217;s explaining what happens, but not why. Why isn&#8217;t the rule for inodes &#8220;When you move an inode, it updates the security attributes&#8221;? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-413593">
				<div id="div-comment-413593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413593">
			August 24, 2006 at 9:52 pm</a>		</div>

		<p>Adam: As FoolHardy says, if you change the permission on the root folder, then everything which is set to &quot;inherit&quot; permissions is updated as well at that point. It&#8217;s only files/folder which AREN&#8217;T set to inherit that won&#8217;t be updated.</p>
<p>Besides, in order to get to C:FooBar.txt, you&#8217;ve usually got to navigate into C:Foo first, so if you don&#8217;t have permission to read that, then being able to read C:FooBar.txt isn&#8217;t going to help if you don&#8217;t already know the name.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-larryosterman odd alt thread-odd thread-alt depth-1" id="comment-413603">
				<div id="div-comment-413603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Larry+Osterman+%5BMSFT%5D' rel='external nofollow' class='url'>Larry Osterman [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413603">
			August 24, 2006 at 10:27 pm</a>		</div>

		<p>Btw, full control IS a security hole. &nbsp;The security guys file bugs regularly on ACLs that grant full control to resources (I know).</p>
<p>Granting Creator-Owner full control makes sense (after all, that&#8217;s the user that created the object), as does granting it to the administrator and SYSTEM (they have it already by virtue of having the take ownership privilege). &nbsp;</p>
<p>Beyond that, it doesn&#8217;t necessarily make a ton of sense, certainly not for random objects. &nbsp;Read Howard, Leblanc and Viega&#8217;s 19 Deadly Sins of Software Security, Sin #12 (Failing to Store and Protect Data Securely).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413613">
				<div id="div-comment-413613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413613">
			August 24, 2006 at 10:30 pm</a>		</div>

		<p>[But that simple sentence doesn&#8217;t actually explain why moving the inode doesn&#8217;t update the security attributes. (The Windows term for inodes is just &quot;files&quot;.) -Raymond]</p>
<p>The &quot;inode&quot; but is not moved or changed, only it&#8217;s directory entry is moved. (Since you explicitly use creation and deletion of hardlinks to model the move this operation can&#8217;t cross volumes, therefore the file itself is not moved.</p>
<p>BTW: KB article 310316 describes ForceCopyACLWithFile and MoveSecurityAttributes. The latter is evaluated from Explorer.exe only.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413683">
				<div id="div-comment-413683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413683">
			August 25, 2006 at 4:58 am</a>		</div>

		<p>So if you have a doubly-linked file, and you tick the &quot;Inherit from parent&quot; checkbox, I assume that API just uses the parent as defined by the path that you used to update the security settings on that file?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413693">
				<div id="div-comment-413693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://deadnode.org/' rel='external nofollow' class='url'>James</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413693">
			August 25, 2006 at 8:49 am</a>		</div>

		<p>Neil: the GUI does strange things on top of the API, as Foolhardy mentions &#8211; it tries to &quot;inherit&quot; things its own way, by copying ACLs where it thinks they would have been inherited from the thing you&#8217;re editing. It&#8217;s not a filesystem thing, or related to the real inheritance mechanism &#8211; think of it as like a search and replace on method names in your IDE, as opposed to actually inheriting methods.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413703">
				<div id="div-comment-413703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413703">
			August 25, 2006 at 9:49 am</a>		</div>

		<blockquote><p>
  What&#8217;s the inode equivalent in Windows?</p>
<p>A record in the MFT (file &quot;$Mft&quot;).</p>
<p>The mapping is fairly exact &#8211; the record contains or points to the file metadata, the record is identified by an index number, a directory entries contains that index number, etc.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413673">
				<div id="div-comment-413673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://deadnode.org/' rel='external nofollow' class='url'>James</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413673">
			August 25, 2006 at 4:53 am</a>		</div>

		<p>Raymond: &#8220;moving an inode&#8221; has no meaning &#8211; inodes have no location or name, they&#8217;re just blocks of data with permissions and timestamps. A directory is a set of name-&gt;inode mappings, which will tell you &#8220;raymond.pdf&#8221; is inode number 3892. Inode #3892, however, has no name information &#8211; and indeed may not have *any* name corresponding to it!</p>
<p>Cooney&#8217;s wrong about there being no way to reverse this mapping (on NTFS) though: unlike Unix inodes, NTFS File Records (which are the equivalent of inodes) *do* contain names (often multiple names, thanks to the existence of 8.3 names) along with the number of the parent directory&#8217;s file record (record number 5, if it&#8217;s in the root directory). In addition, there is no need to open a file by name first to determine its file ID.</p>
<p>As an aside, this makes it possible (with sufficient access privileges!) to scan the MFT (master file table) directly looking for a particular name, then convert that into a full path, as my little TFind utility does. All the speed of Unix&#8217;s &#8216;locate&#8217; &#8211; but using the current index, not one built overnight!</p>
<p>So in fact, yes, you *could* calculate the inherited permissions for a given file, even when opening by ID &#8211; except for the problem Raymond pointed out about &#8220;the current user&#8221;: a file can have multiple names, each in different directories!</p>
<div CLASS=post>[<i>I know what an inode is; I was just asking the same questions my article was trying to answer from the Windows side. Saying &#8220;Oh, the security is in the inode&#8221; doesn&#8217;t explain <u>why</u> the security isn&#8217;t updated when the inode is &#8220;moved&#8221;. (Where &#8220;moved&#8221; here is from the end-user&#8217;s viewpoint of moving a file from one directory to another.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413753">
				<div id="div-comment-413753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">microbe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413753">
			August 25, 2006 at 3:34 pm</a>		</div>

		<p>[That&#8217;s explaining what happens, but not why. Why isn&#8217;t the rule for inodes &#8220;When you move an inode, it updates the security attributes&#8221;? -Raymond] </p>
<p>Because it&#8217;s consistent with any other attributes stored with an inode, such as timestamps, owner, size, content, and almost everything else. </p>
<p>When you move something you are just renaming it, not changing the object itself. It&#8217;s like you go to change your legal name and your gender, age and hair color doesn&#8217;t change. :-) </p>
<p>It&#8217;s just a natural way to do things. I don&#8217;t think anybody would have a hard time understand it once they realize name (dir entry) and inode (file object) are totally separate entities.</p>
<div CLASS=post>[<i>Yet when the entirely analogous thing happens in Windows, people <u>are</u> confused. Go figure. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413803">
				<div id="div-comment-413803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://peeved.org/blog' rel='external nofollow' class='url'>Evan Anderson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413803">
			August 26, 2006 at 12:52 am</a>		</div>

		<p>The frustration I have w/ inherited ACEs moving when a file is moved mostly relates to the &quot;Advanced&quot; security dialog. The dialog shows the inherited permissions as still coming from &quot;Parent Object&quot;, even though they came from an object that is, potentially, no longer a parent.</p>
<p>I guess I feel like the UI design is trying to &quot;have it&#8217;s cake and eat it too&quot;, since permissions aren&#8217;t calculated at the time an access is performed, but all of the UI dialogs seem to be geared toward giving the user the impression that such a realtime calculation really is happening. The behaviour of the product is convincing enough to fool you into believing that permissions are calculated in realtime until you hit a gap in the facade like moving a file and having &quot;inhereited&quot; ACEs stick to it.</p>
<p>I don&#8217;t belive that your statment &quot;One (sic) the file is created, though, that&#8217;s the end of it. Inheritable permissions don&#8217;t have any effect any more.&quot; is strictly true, though. You can always add a new &quot;inheritable&quot; ACE at a parent folder that should alter the ACLs of child objects. This behaviour seems to be the source of another bit of frustration and curiosity to me.</p>
<p>I&#8217;ve had several cases where I&#8217;ve needed to add an ACE such as &quot;Authenticated Users &#8211; List Folder Contents &#8211; This Folder Only&quot; to a parent folder w/ several hundred-thousand subfolders and files in Windows 2000 and later version of Windows. (I should preface by saying that I haven&#8217;t tried to use any utilities to figure out what Windows is actually doing behind-the-scenes when this happens.) &nbsp;My workflow is to open the properties dialog on the parent folder, move to the security tab, click &quot;Add&quot; and enter &quot;Authenticated Users&quot; in the &quot;Select Users and Groups&quot; dialog, modify the permission in the lower portion of the security dialog to reflect &quot;List Folder Contents&quot;, click &quot;Advanced&quot; to get into the &quot;Advanced Security Settings&quot; dialog, locate and highlight the newly-added (but not yet &quot;Applied&quot;) &quot;Authenticated Users &#8211; Read and Execute&quot; permission, click &quot;Edit&quot; and alter the &quot;Apply onto&quot; line to read &quot;This folder only&quot;, click &quot;OK&quot; to return to the &quot;Advanced Security Settings&quot; dialog, and click &quot;OK&quot; again to apply the new settings to the filesystem and return to the parent folder&#8217;s properties sheet. When I do this I&#8217;m greeted by the properties sheet UI hanging for several minutes while, presumably, something is being done to ACLs of child objects. I&#8217;ve verified that the delay varies in proportion to the number of subfolders and files below the parent folder to which I make this modification. It makes no sense to me, though, since I&#8217;m applying the new ACE to &quot;This folder only&quot;, as to why the number of subfolders or files should matter.</p>
<p>I&#8217;m hypothesizing that we&#8217;re running thru a code path in SetNamedSecurityInfo that is processing (and, presumably, &quot;recalculating&quot;) ACLs on all of child objects, regardless of whether or not the newly-made change should actually change the child object ACLs. That would explain the delay I&#8217;m seeing even when the new ACE is set to apply to &quot;This folder only&quot;. (I would <em>love</em> if there were a method to add the ACE to the parent folder w/o having to wait for this &quot;recalculation&quot; on child objects&#8230;)</p>
<p>As a fun test scenario, I moved a couple of files with inherited ACLs into a subfolder of a parent folder that had an ACL with different &quot;inheritable&quot; permissions than the files&#8217; original parent folder. The files original &quot;inherited&quot; ACLs did &quot;stick&quot; like I expected them to. I then added a &quot;This folder only&quot; ACE to the top level folder, and verified that the moved files ACLs appeared to be reset to reflect the inheritable permissions of their present location, rather than the ACLs that &quot;stuck&quot; from when they were moved. This seems to validate my hypothesis regarding this &quot;recalculation&quot; of ACLs that happens when the ACL on a parent object is changed.</p>
<p>The document &lt;<a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/automatic_propagation_of_inheritable_aces.asp&gt;" rel="nofollow"></a><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/automatic_propagation_of_inheritable_aces.asp&#038;gt" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/automatic_propagation_of_inheritable_aces.asp&#038;gt</a>; seems to say all of this, but it doesn&#8217;t clearly spell out, in my opinion, what happens to these inherited ACLs when an ACE is added to a parent object. It also seems a bit non-orthagonal to me that adding an ACE to a parent object should cause these &quot;stuck&quot; inherited ACLs to be modified if the act of moving the file causes the inherited ACL to &quot;stick&quot; to the file in the first place. That just feels backwards.</p>
<p>Finally, it appears that Active Directory doesn&#8217;t operate the same way as NTFS w/ respect to inheritance of ACL&#8217;s when objects move between different OU&#8217;s that have different inheritable permissions set. W/o seeing the source, of course, I can only speculate wildly, but it does appear that AD is actually calculating the permission in realtime. In contrast to NTFS, that also could be a source of confusion.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-413843">
				<div id="div-comment-413843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://deadnode.org/' rel='external nofollow' class='url'>James</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413843">
			August 26, 2006 at 4:50 am</a>		</div>

		<p>Raymond: the complexity arises from two things &#8211; first, NTFS MFT record *do* have filenames and locations stored inside them, unlike Unix inodes, so &#8216;moving a file record&#8217; isn&#8217;t entirely meaningless, unlike &#8216;moving an inode&#8217;; secondly, the GUI&#8217;s behaviour differs from the underlying API, as Evan has discovered.</p>
<p>Evan: When you move a file, you&#8217;re seeing the file system&#8217;s own behavior; when you change permissions through Explorer, you&#8217;re seeing the behavior Explorer explicitly requests, overriding the underlying mechanisms. If you just added an ACE through the API, rather than using the GUI, you would see different results. Much as you&#8217;d get if you granted new rights to &#8216;CREATOR OWNER&#8217;, AIUI.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-413943">
				<div id="div-comment-413943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413943">
			August 27, 2006 at 11:01 pm</a>		</div>

		<blockquote><p>
  [Yet when the entirely analogous thing<br />
  <br />&gt; happens in Windows, people are confused.<br />
  <br />&gt; Go figure. -Raymond]</p>
<p>Here&#8217;s part of the reason it&#8217;s confusing:</p>
<p>It&#8217;s a checkbox that sets an option on a file (or folder), like the checkbox that sets the &quot;readonly&quot; option. &nbsp;This lends an impression that the option will be obeyed each time the file is accessed.</p>
<p>A button that can be clicked to do an action once, such as &quot;do some inheriting now&quot;, might help make the effect more obvious.</p>
<p>Meanwhile the facts described by Foolhardy ought to make it pretty obvious why the facts are pretty confusing.</p>
<p>In the scenario described by Evan Anderson, a few times I didn&#8217;t even guess that Explorer was working overtime to screw up my hard disk, I just thought Explorer hanged. &nbsp;When Explorer didn&#8217;t close by itself, I let the crash report tool send dumps to Microsoft. &nbsp;(Maybe it hasn&#8217;t been changed because the crash dumps weren&#8217;t sufficiently anonymous ^_?)</p>
<p>Thursday, August 24, 2006 10:27 PM by LarryOsterman<br />
  <br />&gt; Granting Creator-Owner full control makes<br />
  <br />&gt; sense (after all, that&#8217;s the user that<br />
  <br />&gt; created the object),</p>
<p>I still find that much confusing, and it&#8217;s not obvious to me that it makes sense. &nbsp;Usually it&#8217;s reasonable for the current owner to have full control. &nbsp;When the current owner isn&#8217;t the creator, usually it isn&#8217;t reasonable for the creator to have full control, but the creator and current owner might have agreed to transfer ownership while not transfering full control. &nbsp;Which of these people is the creator-owner and which of these people is something else, and what is that something else, beats me.</p>
<p>Proponents of DRM want to deny most rights to both the creator and the owner and grant all rights to the marketer.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-413953">
				<div id="div-comment-413953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-413953">
			August 27, 2006 at 11:39 pm</a>		</div>

		<blockquote><p>
  Proponents of DRM want to deny most rights to both the creator<br />
  <br />&gt; and the owner and grant all rights to the marketer.</p>
<p>Hahaha, that&#8217;s awesome! Perfect description of DRM :)
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-609043">
				<div id="div-comment-609043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.delphi-jedi.net/2008/03/11/moving-a-file-does-not-recalculate-inherited-permissions/' rel='external nofollow' class='url'>&nbsp; Moving a file does not recalculate inherited permissions&nbsp;by&nbsp;JEDI Windows API</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060824-16/?p=29973#comment-609043">
			March 11, 2008 at 10:15 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://blog.delphi-jedi.net/2008/03/11/moving-a-file-does-not-recalculate-inherited-permissions/" rel="nofollow">http://blog.delphi-jedi.net/2008/03/11/moving-a-file-does-not-recalculate-inherited-permissions/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>