<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-879943">
				<div id="div-comment-879943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mott555</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-879943">
			December 8, 2010 at 7:18 am</a>		</div>

		<p>I found a security vulnerability in the blogging software: I can type in the comment field! Someone could easily use this vulnerability to say stupid things and be offensive to other users! I demand Microsoft fix this vulnerability ASAP!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879963">
				<div id="div-comment-879963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Clovis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-879963">
			December 8, 2010 at 7:26 am</a>		</div>

		<p>Just how is an access violation exploitable? If it happens, Windows kills your process. Quite right too &#8211; in the same way as when a mouse sets off a mousetrap, the mouse needs to be terminated, not given a lump of cheese for being so clever.</p>
<p>In a previous life ABC Security Research Company would&#39;ve been ABC Compiler Validation Company, and the problem would&#39;ve been a bug in the compiler. At least we&#39;ve moved on a bit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879973">
				<div id="div-comment-879973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">POKE53280,0</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-879973">
			December 8, 2010 at 7:39 am</a>		</div>

		<p>I completely agree with this blog post.</p>
<p>Moreover, I&#39;d like to ask: why did Microsoft invent the safe CRT functions like e.g. strcpy_s? If strings are correctly validated by caller code (with respect to destination buffer sizes, too), &quot;classic&quot; CRT functions like strcpy are just fine.</p>
<p>Thanks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879983">
				<div id="div-comment-879983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marco Schramp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-879983">
			December 8, 2010 at 7:55 am</a>		</div>

		<p>Here we are discussing the same thing again: <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2006/03/20/555511.aspx" rel="nofollow">blogs.msdn.com/&#8230;/555511.aspx</a> If you break these rules, your program will fail. It&#39;s not a security issue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880003">
				<div id="div-comment-880003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pierre B.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880003">
			December 8, 2010 at 8:12 am</a>		</div>

		<p>[Exercise: Apply what you learned to this security vulnerability report.]</p>
<p>Easy one! What we&#39;ve learned is that submitting dubious security vulnerability will cost Microsoft&#39;s security team days of work. So the vulnerability is actually a DDoS on Microsoft, easily triggerable by submitting a large volume of bogus reports from valid-sounding &quot;genuinely concerned&quot; customers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880013">
				<div id="div-comment-880013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy O'Neal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880013">
			December 8, 2010 at 8:24 am</a>		</div>

		<p>@POKE53280,0: The safe functions don&#39;t guard against invalid lengths. The safe functions are there to guard against you making mistakes. Because we are all human, and we all make mistakes. By explicitly tracking the size of the buffer in which a string resides (and passing to the various _s functions) you have created a scenario which will fail explicitly when you make a mistake, instead of failing silently (and corrupting memory) when you make a mistake. The _s functions have absolutely nothing to do with parameter validation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880023">
				<div id="div-comment-880023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880023">
			December 8, 2010 at 8:25 am</a>		</div>

		<p>@POKE53280,0</p>
<p>The problem that the Safe CRT functions were addressing was when code received input from the other side of the airtight hatch (i.e. a URL is sent to a server from the internet). Ideally, the function handling the input should have validated it to begin with (i.e. for buffer overruns and what have you) but people didn&#39;t. The safe CRT functions always null-terminate a string and require to explicitly say how big your buffers are (for memcpy_s). Hence, they build the validation in. This makes exploits like overwriting the return address by overflowing a stack buffer harder.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880063">
				<div id="div-comment-880063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880063">
			December 8, 2010 at 8:38 am</a>		</div>

		<p>&quot;This is also paraphrased from an actual security report&quot;</p>
<p>Let me guess, the security company who made the report is out of business already?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880073">
				<div id="div-comment-880073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">POKE53280,0</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880073">
			December 8, 2010 at 8:45 am</a>		</div>

		<p>If one validates parameters before using string functions (which quality programmers should do), the &quot;safe&quot; functions have no reason to exist.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880093">
				<div id="div-comment-880093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880093">
			December 8, 2010 at 9:16 am</a>		</div>

		<p>@POKE53280,0</p>
<p>I agree. The fact is that people don&#39;t (or at least didn&#39;t) always validate correctly. It&#39;s easier in a code review (or during static analysis) to check for the safe functions than to check if people are using the standard functions incorrectly. It&#39;s also harder to get the safe functions incorrect since you have to tell them explicitly your buffer size (although admittedly people have lied about buffer sizes before see oldnewthings passim &#8211; that&#39;s more of a deliberate error that no one can save you from.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880113">
				<div id="div-comment-880113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880113">
			December 8, 2010 at 9:35 am</a>		</div>

		<p>Another interesting thing:</p>
<p>How should the XYZ function suppossedly protect itself from this &quot;security vulnerability&quot;?</p>
<p>Sure, it can check for NULL pointers but otherwise it&#39;s impossible to check if the input pointers are bogus or not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880123">
				<div id="div-comment-880123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880123">
			December 8, 2010 at 9:46 am</a>		</div>

		<p>Clovis:</p>
<p>An access violation in and of itself is benign, but access violations that are caused by a pointer derived from untrusted input can just as easily NOT trigger an access violation. Instead they could point to a very legal target location in the processes data segment, such as that untrusted data buffer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880163">
				<div id="div-comment-880163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880163">
			December 8, 2010 at 11:09 am</a>		</div>

		<p>Unlike ordinary APIs, COM API can be out-of-process, thus crashing another process. The called process can be located on a whole other server. Hello network exploit!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880173">
				<div id="div-comment-880173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880173">
			December 8, 2010 at 11:22 am</a>		</div>

		<p>Exploiting access violation?</p>
<p>See this: <a rel="nofollow" target="_new" href="http://www.securiteam.com/unixfocus/5BP0G1FFPY.html" rel="nofollow">http://www.securiteam.com/&#8230;/5BP0G1FFPY.html</a></p>
<p>Basically, a crash of a process with specifically mangled ELF module header could be used to get root privileges.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880183">
				<div id="div-comment-880183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880183">
			December 8, 2010 at 11:22 am</a>		</div>

		<p>@POKE53280,0:</p>
<p>I like the secure CRT functions because they force me to look at the documentation when I use them (at least the first time, anyways.) Some of the traditional functions are completely broken anyways: see gets() and friends, which are irredeemably bad!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880193">
				<div id="div-comment-880193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880193">
			December 8, 2010 at 11:41 am</a>		</div>

		<p>@POKE53280,0: &quot;If one validates parameters before using string functions (which quality programmers should do), the &quot;safe&quot; functions have no reason to exist.&quot;</p>
<p>If they help make the correctness more obvious &#8212; whether it be to the original programmer, other programmers maintaining the program, or static analysis tools &#8212; that is plenty of reason to exist and to use them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880203">
				<div id="div-comment-880203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Depressed</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880203">
			December 8, 2010 at 12:13 pm</a>		</div>

		<p>@640K</p>
<p>If you can create a malicious COM object and persuade a target application to load it then you could, from that module, call a function with invalid paramaters and thus cause the process to crash.</p>
<p>Or, perhaps, given that you&#39;ve already got the code running, you could call anything from ExitProcess() to StealCreditCardNumberThenKickPuppies() and be done with it.</p>
<p>&quot;A function crashes when called with invalid paramaters&quot; is not a damned security bug, no matter how clever you think you might be in getting the code loaded while using completely unrelated problems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880213">
				<div id="div-comment-880213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880213">
			December 8, 2010 at 12:31 pm</a>		</div>

		<p>@POKE53280,0: &quot;If one validates parameters before using string functions (which quality programmers should do), the &quot;safe&quot; functions have no reason to exist.&quot;</p>
<p>But validating the parameters for the standard string functions isn&#39;t trivial, and it&#39;s easy to get wrong. &nbsp;strncat doesn&#39;t take a buffer size; it takes the maximum number of characters to concatenate. &nbsp;strncpy might not NUL-terminate. &nbsp;The standard C99 version of snprintf is guaranteed to NUL-terminate, but that&#39;s not true for the Microsoft CRT _snprintf implementation.</p>
<p>Moreover, by adding the &quot;safe&quot; versions of the functions, the compiler can easily flag the standard counterparts as being potentially unsafe to force code inspection.</p>
<p>The &quot;safe&quot; versions are annoying when trying to write cross-platform code, but overall I think it&#39;s a good thing to make it easier for people to write code that&#39;s less susceptible to buffer overflows. (There&#39;s a proposal to make them standard in C1x anyway.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879953">
				<div id="div-comment-879953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-879953">
			December 8, 2010 at 7:24 am</a>		</div>

		<p>If a program wants to deny service, it can just crash by causing an intentional access violation (e.g. *(int*)0 = 0) or call ExitProcess().</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880283">
				<div id="div-comment-880283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MikeCaron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880283">
			December 8, 2010 at 5:14 pm</a>		</div>

		<p>Rule of thumb: It&#39;s not privilege escalation if no privileges are escalated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880103">
				<div id="div-comment-880103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880103">
			December 8, 2010 at 9:19 am</a>		</div>

		<p>&gt;Just how is an access violation exploitable? If it happens, Windows kills your process</p>
<p>But it doesn&#39;t. &nbsp;If an access violation happens, Windows *delivers an access violation exception* to the running thread. &nbsp;The handler-of-last resort may well end up deleting the process, but there&#39;s lots of chances on the way for other code to get involved.</p>
<p>A former method of choice was to have corrupted the stack in such a way that your nefarious code was entered in order to handle the exception.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880293">
				<div id="div-comment-880293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880293">
			December 8, 2010 at 5:34 pm</a>		</div>

		<p>I feel the exercise lacks some context about the function XYZ. If that function passes values to some kernal code (such as display driver) and can make the code hangs there, it could be a real concern.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880333">
				<div id="div-comment-880333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880333">
			December 8, 2010 at 6:46 pm</a>		</div>

		<p>Cheong: it&#39;s not a concern, because you could just copy the body of the function into your own program and run it yourself. It&#39;s your process that&#39;s running these instructions; importing from a library is just a convenience.</p>
<p>Alex Grigoriev: you of all people know that exploiting the core dump code is not exploiting the access violation, it&#39;s exploiting the kernel crash handler.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880343">
				<div id="div-comment-880343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880343">
			December 8, 2010 at 7:28 pm</a>		</div>

		<p>For the safe string functions, I have actually seen pleanty of examples of people getting those horribly wrong too.</p>
<p>The most common one is strcpy_s(dst, strlen(src), src); and doing that will negate all possible benefits this function can give. If you don&#39;t know why calling strcpy_s like that is bad then read the documentation on it again.</p>
<p>Then there are pleanty of occasions where the wrong size is just passed in as the destination buffer length. Sometimes it is an easy mess up (like forgetting to multiply by sizeof(TCHAR) or something like that) but there are also lots of cases of someone thinking they are being smart by passing in a count larger than the actual buffer and then wondering why they get access violations.</p>
<p>In the end, the _s functions make things easier to stop string buffer problems, but it doesn&#39;t fix everything. It is easy to say if people handle string buffers correctly then we wont need those functions, but people don&#39;t handle them correctly all the time, even with the _s functions. It can be easy to mess up, even with the extra care I put into my string handling, I&#39;ve messed &nbsp;up too and mostly just by a simple typo.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880353">
				<div id="div-comment-880353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880353">
			December 8, 2010 at 7:31 pm</a>		</div>

		<p>-_-; Messed up my last comment a bit. You should never need to multiply buffer sizes for the _s functions by sizeos(TCHAR). I was thinking about other Windows functions which take buffer sizes in bytes at that time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880363">
				<div id="div-comment-880363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880363">
			December 8, 2010 at 7:48 pm</a>		</div>

		<p>strcpy_s has another side-effect which is that the exception thrown is specially handled in such a way that generic &quot;unhandled exception&quot; handlers do not get to run. If your application performs &quot;black box&quot; style information gathering on a crash, it is something to be aware of.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880373">
				<div id="div-comment-880373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880373">
			December 8, 2010 at 9:41 pm</a>		</div>

		<blockquote><p>
  Depressed:</p>
<p>  If you can create a malicious COM object and persuade a target application to load it then you could, from that module, call a function with invalid paramaters and thus cause the process to crash.</p>
<p>  Or, perhaps, given that you&#39;ve already got the code running, you could call anything from ExitProcess() to StealCreditCardNumberThenKickPuppies() and be done with it.
</p></blockquote>
<p>The other process (ntoskrnl) which is executed by &quot;elevated user&quot; could load the malicious object into it&#39;s process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880383">
				<div id="div-comment-880383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880383">
			December 8, 2010 at 9:56 pm</a>		</div>

		<p>@Mark: It&#39;s a concern because &quot;crashing your program&quot; and &quot;freezing/bluescreen&quot; your computer is different.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880413">
				<div id="div-comment-880413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880413">
			December 9, 2010 at 12:26 am</a>		</div>

		<p>I wonder how MS breaks the news to these earnest &quot;security researchers&quot; about their &quot;vulnerability&quot; not being real. After all, these people think they&#39;re doing a valuable service and if you insult them it could lead to bad PR (&quot;MS ignores thousands of security vulnerabilities!&quot;).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880433">
				<div id="div-comment-880433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880433">
			December 9, 2010 at 2:53 am</a>		</div>

		<p>Gabe:</p>
<p>Probably how they do it on connect for VS, Closed (Wont fix) or Closed (Not reproducable). They do that everywhere else and it doesn&#39;t cause a fuss, so Windows should be fine too.</p>
<p>In all seriousness though, I would imagine that a nice detailed reason why it isn&#39;t a vulnerability would be the best way. Also thanking them for the hard work put in too. That is a constructive way of doing it because you are nicely telling them they were wrong and thanking them for doing the work at the same time.</p>
<p>640K:</p>
<p>COM objects don&#39;t get transferred over to the kernel side. They are always executed on the user side and individual members call code which could transfer over to the kernel side. Also, if a COM object is loaded into a process whith elevated privileges it is still not a security vulnrability, since the object will still be able to do only what it is allowed to by the user account running it. It only becomes a security vulnerability when the code becomes able to do something it shouldn&#39;t do. The problem here isn&#39;t that the object was loaded into the elevated program either, it is why that malicious object was actually created/sent in the first place. This hints that the system was already compramised in the first place.</p>
<p>Cheong:</p>
<p>The Windows API goes through a few user mode functions before it actually gets to the kernel, each one checking the parameters. For example, CreateFile ends up at NtCreateFile before it goes into kernel mode, so if it will crash, it will be more likely that it will be in user mode. Whats more, as I said already, COM objects don&#39;t get transferred to kernel mode. Each member call of a COM object will be in user mode so each action will follow user mode rules. So if the COM object isn&#39;t using any vulnerabilities and causes an unhandled exception, it will just happen in user mode. Passing an invalid/rouge object on it&#39;s own is just not enough to cause a real vulnerability.</p>
<p>It is too heavy for the limited kernel memory stack space. The same as why C++ objects aren&#39;t used in the kernel.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880443">
				<div id="div-comment-880443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880443">
			December 9, 2010 at 2:57 am</a>		</div>

		<p>I&#39;m thinking of giving up commenting. I&#39;ve had at least one mess up in all of my past 3 comments. Anyway, I really messed the last line up. It should be:</p>
<p>As to why you will never see COM objects in the kernel, it is too heavy for the limited kernel stack space. This is the same as why C++ objects aren&#39;t used in the kernel.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880463">
				<div id="div-comment-880463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">PorkBellyFutures</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880463">
			December 9, 2010 at 6:35 am</a>		</div>

		<p>POKE53280,0 is correct. This is not an actual security vulnerability any more than strcpy() is a security vulnerability. But it should still be fixed.</p>
<p>Every place where there is an API which, used in a certain improper way, would cause a vulnerability to appear, then you put the onus on developers not to use it that way. Sometimes it&#39;s more or less obvious (like the DeleteFile example), but it&#39;s easier to imagine developers writing code that calls an API with unfiltered input when it does not have any clear security implications, perhaps expecting an exception from the callee if there&#39;s something wrong with the data.</p>
<p>Essentially, every &#39;bug&#39; like this creates a new security tax that developers have to pay.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880473">
				<div id="div-comment-880473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880473">
			December 9, 2010 at 6:59 am</a>		</div>

		<p>@Crescens2k: I hope you&#39;re not serious about giving up commenting because you typed the wrong thing 3 times. &nbsp;You&#39;ve had some very interesting comments.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-880453">
				<div id="div-comment-880453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880453">
			December 9, 2010 at 4:37 am</a>		</div>

		<p>640k: The only way to get an interface pointer to a COM server in another process or on another server is to ask COM to get you one, either with CoCreateInstance/CoGetClassObject to create a new object, or CoGetObject to get a pointer to some existing object (or, of course, make some method call to a remote object that returns another interface pointer). When this happens, you get a pointer to a *proxy* which knows that it is representing the real object, not being the real object. When you make a method call, the proxy marshals the arguments into a buffer and sends them on to the *stub* running in the destination process. The stub unpacks (unmarshals) the arguments and calls the function, then repacks the results into a buffer and sends it back to the calling proxy.</p>
<p>Obviously the proxy and stub have to understand what the arguments are and how to pack them. Integers are straightforward, pointers to buffers less so, and pointers to buffers that themselves contain pointers even less so. The creator of the interface therefore has to provide the proxy and stub code to load into the client and the server. If you only use Automation-compatible types (things you can put in a VARIANT) you can use the Automation marshaller, by providing and registering a Type Library containing the type and interface descriptions. For non-Automation types it&#39;s most straightforward to get MIDL to generate the proxy/stub code (actually it just generates tables that are interpreted by the RPC runtime).</p>
<p>Proxies are also used in-process to marshal calls between different apartments or COM+ contexts, but that&#39;s unlikely to elevate privileges unless the other thread is impersonating a user with higher privileges than yours.</p>
<p>If you pass some other value to a function expecting a pointer to a proxy, that function will call through the pointer just as in Raymond&#39;s example. It won&#39;t magically transport it across to the remote object, because the connection is within the proxy that you just bypassed. You can&#39;t elevate your privileges.</p>
<p>Now, you could try to corrupt the proxy and see if you can invoke the remote methods out-of-order, or invoke a method on some other object altogether, but that would be a vulnerability in the remote object, not a fundamental issue with COM. If you wanted to do that you might as well just send DCE/RPC packets over the network or directly call through your own fake proxy, rather than trying to corrupt a standard proxy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880783">
				<div id="div-comment-880783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880783">
			December 9, 2010 at 2:09 pm</a>		</div>

		<p>PorkBellyFutures: You missed the part where there&#39;s nothing here establishing any possibility to send the invalid memory contents (and pointer to same) outside your process.</p>
<p>There is no precedent for applications to reasonably interpret remote input as a pointer to an address in their own process to be used as an in-process com object. Not doing that isn&#39;t a &quot;security tax&quot;, it&#39;s just sanity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880803">
				<div id="div-comment-880803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">PorkBellyFutures</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880803">
			December 9, 2010 at 2:58 pm</a>		</div>

		<p>@Random832:</p>
<p>Okay, you&#39;re right.</p>
<p>It&#39;s not at all plausible that an application would ever receive data from across a trust boundary and somehow assume it to be a valid COM object. That couldn&#39;t work.</p>
<p>Mea culpa, I misunderstood that bit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880953">
				<div id="div-comment-880953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DodoBird</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880953">
			December 10, 2010 at 12:48 am</a>		</div>

		<p>I have had many a &quot;bugs&quot; about my function crashing when the tester passes an invalid non-zero pointer as a parameter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880993">
				<div id="div-comment-880993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-880993">
			December 10, 2010 at 5:51 am</a>		</div>

		<p>@POKE53280,0: &quot;If one validates parameters before using string functions (which quality programmers should do), the &quot;safe&quot; functions have no reason to exist.&quot;</p>
<p>And if grasshoppers had machine guns, birds wouldn&#39;t eat them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-881323">
				<div id="div-comment-881323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Batman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-881323">
			December 11, 2010 at 9:38 am</a>		</div>

		<p>int main, not void main :(</p>
<div class="post">[<i>The exploit runs before main() returns, so who cares? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-881303">
				<div id="div-comment-881303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">POKE53280,0</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101208-00/?p=12093#comment-881303">
			December 11, 2010 at 7:12 am</a>		</div>

		<p>@Brian: Are you comparing *quality programmers* to grasshoppers?</p>
<p>:-)</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>