<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (22)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-338593">
				<div id="div-comment-338593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://denisbider.blogspot.com' rel='external nofollow' class='url'>denis bider</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338593">
			January 18, 2006 at 10:18 am</a>		</div>

		<p>This isn&#8217;t about trying too hard, it&#8217;s about trying the wrong way. Trying hard isn&#8217;t bad, trying the wrong way is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338603">
				<div id="div-comment-338603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve Bjorg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338603">
			January 18, 2006 at 10:58 am</a>		</div>

		<p>Consistent delivery of results is a the heart of six-sigma.  Maybe there is am opportunity here to research algorithms that perform well and are highly predictable in their performance, not just amortized.  Or, alternatively, provide a measure of &#8216;consistency&#8217; of performance for a problem of size &#8216;N&#8217;.  Just a thought.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338653">
				<div id="div-comment-338653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338653">
			January 18, 2006 at 11:58 am</a>		</div>

		<p>Raymond, I don&#8217;t know if I have isolated properly, but clicking on folders using Windows Explorer sometimes causes the &quot;desktop icons explosion&quot;. Have you posted anything about that yet? And btw, is there a fix?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338663">
				<div id="div-comment-338663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338663">
			January 18, 2006 at 12:40 pm</a>		</div>

		<p>Does anybody know why directory operations with NTFS are so slow on Windows when there are a lot of files in the directory (e.g. IE cache files)? I have some impression that directories are kept extremely fragmented and too spread around (And I admit I don&#8217;t know if it is fixed in the newest and latest incarnations).</p>
<p>Anybody knows more on the subject?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338683">
				<div id="div-comment-338683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.cpeterso.com/' rel='external nofollow' class='url'>Chris Peterson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338683">
			January 18, 2006 at 1:45 pm</a>		</div>

		<p>An old-timer once told me that computer science might have many fancy-pants data structures, real-world software development only has three: stack, queue, and hashtable. :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kjkhyperion odd alt thread-odd thread-alt depth-1" id="comment-338693">
				<div id="div-comment-338693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338693">
			January 18, 2006 at 1:45 pm</a>		</div>

		<p>AC: Explorer isn&#8217;t a good filesystem benchmark. In most cases, even displaying the list of files implies opening every single file and at least reading its attributes (at worst even some data). And remember that every instance of the shell is single-threaded and very little happens asynchronously. The &quot;dir&quot; command is a better indicator of directory enumeration speed</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338763">
				<div id="div-comment-338763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Moz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338763">
			January 18, 2006 at 4:27 pm</a>		</div>

		<blockquote><p>
  Explorer isn&#8217;t a good &#8230; even displaying the list of files implies opening every single file </p>
<p>This is something that annoys me. I&#8217;d love it if there was a way to turn the behaviour off, the way a bit of registry hacking can turn off the &quot;search inside zip files&quot; feature.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338773">
				<div id="div-comment-338773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Robert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338773">
			January 18, 2006 at 6:41 pm</a>		</div>

		<blockquote><p>
  The &quot;dir&quot; command is a better indicator of directory enumeration speed</p>
<p>Actually, the &quot;dir&quot; command spends most of its time scrolling and updating the console window.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338793">
				<div id="div-comment-338793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuliy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338793">
			January 18, 2006 at 7:49 pm</a>		</div>

		<blockquote><p>
  Actually, the &quot;dir&quot; command spends most of its time scrolling and updating the console window.</p>
<p>dir &gt; file
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338643">
				<div id="div-comment-338643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe Beda</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338643">
			January 18, 2006 at 11:58 am</a>		</div>

		<p>Hey Raymond,  I can&#8217;t go into details, but I *know* that there are other projects at Microsoft that used splay trees to great affect &#8212; so don&#8217;t give them too bad a rep.</p>
<p>But I agree with your thesis &#8212; understand all of the consequences of your algorithms and use the simplest one that will solve your problem.</p>
<p>Perhaps there is some sort of twist on occams razor: &quot;When presented with multiple ways of doing something, do the simplest.&quot; :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338703">
				<div id="div-comment-338703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">thosk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338703">
			January 18, 2006 at 2:19 pm</a>		</div>

		<p>NTFS perf involving folders with &quot;many&quot; files can also be impacted if the files do not conform to 8.3 convention *and* automatic 8.3 names have been created for the files.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338803">
				<div id="div-comment-338803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vince P</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338803">
			January 18, 2006 at 11:37 pm</a>		</div>

		<p>I know this is off-topic. but someone mentioned something about having Explorer browser a folder with a ton of files, and another person mentioned about how slow Windows gets with I/O</p>
<p>Can I say AMEN?</p>
<p>I wish computers/mouses came with shock absortion detection so that the O/S can be informed of how infuriated I&#8217;m getting waiting for it to do something that turned out to be not worth the wait.</p>
<p>Why can&#8217;t Task Manager have super-duper (to borrow language from the Alito hearings) Thread priority so that the CPU can cool its heels and give me enough cycles to kill something I want to die.</p>
<p>When Windows starts collapsing under its own virtual page file weight it&#8217;s the most annoying and aggravating experience. (Yes, I know CPU and Page File are not the same thing but either way, it prevents me from getting on with it)  I get where i want to take my laptop and fling it at someone.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338743">
				<div id="div-comment-338743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338743">
			January 18, 2006 at 3:49 pm</a>		</div>

		<p>Perhaps the team should focus more on on-disk stuff than on-memory stuff.</p>
<p>On-memory, Windows is quite fast, no problem there. On-disk, well, NTFS is the slowest thing you&#8217;ll find (except for directories will *lots* of files, where it can beat FAT, though it is held down by 8.3 conversions unless you have disabled them), followed by FAT, and then pretty much everything else.</p>
<p>In Vista, they have a lot of focus on &quot;covering&quot; this with more intelligent prefetching, which is good, but would be even better if NTFS was improved; and since I&#8217;ve heard no mention of it, I can&#8217;t have high hopes&#8230;</p>
<p>I hate to compare but I find this rather funny: in low-end machines, when Windows runs slow is mostly always because of I/O: you can hear the hard disk trashing badly (and it&#8217;s even more frustrating because of the noise). When linux runs slow, it&#8217;s mostly because the way it&#8217;s designed, with the X server running as another process and the protocol-based communication. It&#8217;s eerie to watch it run slowly, but not doing any disk I/O.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338813">
				<div id="div-comment-338813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.cpeterso.com/' rel='external nofollow' class='url'>Chris Peterson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338813">
			January 19, 2006 at 12:59 am</a>		</div>

		<p>Vince: I recently discovered a shareware utility called &quot;Process Tamer&quot;. It runs in the background and changes processes&#8217; priorities based on YOUR choice. So I set iTunes.exe and Firefox.exe to AboveNormal priority and my compiler and linker to Low priority, so I can still browse the web while compiling. And if any process runs at 100% CPU for N seconds, Process Tamer can proactively slam it to Low priority so it doesn&#8217;t lock up your PC. Why doesn&#8217;t Windows already do this?!</p>
<p><a rel="nofollow" target="_new" href="http://www.donationcoder.com/Software/Mouser/proctamer/" rel="nofollow">http://www.donationcoder.com/Software/Mouser/proctamer/</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338843">
				<div id="div-comment-338843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338843">
			January 19, 2006 at 6:07 am</a>		</div>

		<p>&quot;it&#8217;s mostly because the way it&#8217;s designed, with the X server running as another process and the protocol-based communication.&quot;</p>
<p>Did you actually /measure/ this effect, or are you, like so many before you, /assuming/ that you&#8217;re smarter than the people who designed X11 and thus don&#8217;t need to do your homework ?</p>
<p>Hint: The pixels only go through the protocol socket when destined for a remote server.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338863">
				<div id="div-comment-338863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338863">
			January 19, 2006 at 8:39 am</a>		</div>

		<p>Nick Lamb: That&#8217;s off-topic here, but anyway:</p>
<p>I know on localhost it uses &quot;more efficient transport means&quot;, but I always assumed that transport method aside, the X11 protocol is always used, and you have to encode/decode from it, on two separate processes.</p>
<p>Anyway, on a P3-800 Mhz, Windows is very fast as far as drawing windows is concerned, even with XP themes. Whereas linux is quite slower, some X11 apps can take seconds to start even from disk cache and screen redraws are noticeably slow. I don&#8217;t know who the culprit is, but I think it&#8217;s X11 on the basis that stuff like video playback or OpenGL games do run as fast as in Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-338873">
				<div id="div-comment-338873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">M Knight</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338873">
			January 19, 2006 at 8:41 am</a>		</div>

		<blockquote><p>
  AC: Explorer isn&#8217;t a good filesystem benchmark. In most cases, even displaying the list of files implies opening every single file and at least reading its attributes (at worst even some data).</p>
<p>I&#8217;ve read somewhere it takes about 31 I/O operations per file to display a file in the Explorer GUI
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-338823">
				<div id="div-comment-338823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-338823">
			January 19, 2006 at 2:11 am</a>		</div>

		<p>I seem to be missing something here.</p>
<p>&gt; Splay trees were developed in 1985 by<br />
<br />&gt; Sleator and Tarjan as a form of self-<br />
<br />&gt; rebalancing tree that provides O(log n)<br />
<br />&gt; amortized cost for locating an item in the<br />
<br />&gt; tree,</p>
<p>OK.  And surely rebalancing is done each time an item is inserted, right?</p>
<p>&gt; Unfortunately, when you sequentially access<br />
<br />&gt; all the elements in a splay tree in order,<br />
<br />&gt; this leaves the tree totally unbalanced.</p>
<p>Do you mean that anti-rebalancing is done each time an item is fetched?  If so, might you happen to have a reference to a statement by Sleator or Tarjan saying why they did it?</p>
<p>I&#8217;ve seen a few algorithms that reorder array elements on fetches when the structure is an array with no links[*], but other structures such as binary trees, threaded binary trees, hash tables, etc. were rebalanced when elements were inserted.</p>
<p>Even if rebalancing was performed when elements were fetched, if it was a rebalancing operation then it wouldn&#8217;t straighten out the entire structure, it would balance the structure.  Threading links would remain in place for anyone who wanted to do a sequential retrieval, but a random search wouldn&#8217;t use them.  What kind of anti-rebalancing operation, I just can&#8217;t imagine.</p>
<p>By the way balanced binary trees work better for structures in RAM than on disk.  They even work better for structures that stay in RAM than for structures that get paged out to the paging file.  Maybe if I try hard then I might be able to imagine why splay trees would have been invented with this kind of behaviour.  But more likely I think I&#8217;m just missing something with regard to how they were really designed.</p>
<p>[* Designed at a time when the average mainframe didn&#8217;t even have the amount of memory that Windows 1.0 would want to run in, but I kind of doubt whether it was ever worth while to avoid storing a reasonable amount of links.]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-339053">
				<div id="div-comment-339053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.cryptopunk.com' rel='external nofollow' class='url'>Per Vognsen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-339053">
			January 19, 2006 at 7:04 pm</a>		</div>

		<blockquote><p>
  OK. And surely rebalancing is done each time an item is inserted, right?</p>
<p>Err, no.</p>
<p>There is no balance invariant a la AVL or red-black trees, no. Every time an element is accessed in a splay tree, the corresponding node is rotated step by step to the root. It is exceedingly easy to prove that doing this to the elements in sorted order yields an entirely lop-sided tree; either left or right lop-sided, depending on whether the elements were in increasing or decreasing sorted order.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-reuvenlax odd alt thread-odd thread-alt depth-1" id="comment-339073">
				<div id="div-comment-339073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ReuvenLax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-339073">
			January 19, 2006 at 8:19 pm</a>		</div>

		<p>Yeah, Dan Lovinger told me that story a couple of years ago.  This is the cost of not understanding your tools.  Splay trees (actually any data structure with amortized time guarantees) work great if your batching lots of operations.  Unfortunately if latency of individual operations matters, it&#8217;s not the best solution.</p>
<p>The classic CS 101 algorithm of doubling an array to grow it has similar (though not as extreme) behavior.  Most of the time additions are very fast.  Every so often, you incur a large cost.  There are ways around this, however on modern architectures block memory copies are fast enough that it&#8217;s usually not a problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-339093">
				<div id="div-comment-339093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-339093">
			January 19, 2006 at 9:44 pm</a>		</div>

		<p>Thank you Mr. Vognsen and Mr. Lax.  It looks like I don&#8217;t need to spend time learning about splay trees ^_^  Hash tables, B-trees, etc., still seem to be enough.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-340023">
				<div id="div-comment-340023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">hartwil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060118-16/?p=32623#comment-340023">
			January 23, 2006 at 11:50 pm</a>		</div>

		<blockquote><p>
  Do you mean that anti-rebalancing is done each time an item is fetched?</p>
<p>Splay trees are not only well-balanced in many practical circumstances, but the most commonly accessed elements tend to be at the top.  This is one of the big benefits over red-black trees.  However, if you go through accessing all the elements, you mess up the structure that makes access of commonly used elements quick.  And if you do it in order, as pointed out by Per Vognsen, you severely unbalance the tree.</p>
<p>Something that seems to be overlooked here is that splay trees are not necessarily the wrong structure to use in the story above.  The problem is that the implementors failed to provide a function that walks the tree without splaying.  That way, you could have a tree that performs better than a simple binary tree for single operations (caveat: amortized, and only in the most common case of unevenly accessed elements), and also better than a simple binary tree for walking the tree (average case, although if the tree is never abused by walking it with the splay operations, you could probably say always).</p>
<p>Splay trees may even be better for cache performance, because finding a commonly accessed element should rarely require descending through an uncommonly accessed element.</p>
<p>Perhaps the moral of the story is not that those developers tried to be too clever, but rather (quoted from an old fried) &quot;you must be 10% smarter than an object to use it&quot;.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>