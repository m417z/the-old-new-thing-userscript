<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (24)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-822233">
				<div id="div-comment-822233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SSLaks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822233">
			March 25, 2010 at 7:11 am</a>		</div>

		<p>You have a mistake in your last sentence.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822243">
				<div id="div-comment-822243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carl D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822243">
			March 25, 2010 at 7:22 am</a>		</div>

		<p>Presumably you meant to name a different function in the last sentence&#8230;</p>
<div class=post>[<i>Um, I&#8217;m not seeing it&#8230; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822263">
				<div id="div-comment-822263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arno</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822263">
			March 25, 2010 at 7:29 am</a>		</div>

		<p>I found this function to be problematic. Any program making COM calls is often agnostic whether it is calling an in-process or out-of-process server. Dispatching synchronous out-of-process COM calls means running a modal loop, which triggers WaitForInputIdle to report that start-up is done :-( To know whether a program is making COM calls is tough in today&#8217;s environment of &quot;mash-up&quot; applications with add-ins and little system tools injecting DLLs into processes. In short, WaitForInputIdle is brittle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822273">
				<div id="div-comment-822273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822273">
			March 25, 2010 at 7:42 am</a>		</div>

		<p>If WaitForInputIdle should really be called WaitForProcessStartupComplete, does that mean it works for console applications without a message queue?</p>
<div class=post>[<i>Given that it&#8217;s a window manager function, it naturally applies only to GUI programs. I guess nitpickers would prefer that it be called <code>WaitForGUIProcessStartupComplete</code>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-822283">
				<div id="div-comment-822283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822283">
			March 25, 2010 at 7:49 am</a>		</div>

		<p>&quot;If WaitForInputIdle should really be called WaitForProcessStartupComplete, does that mean it works for console applications without a message queue?</p>
<p>Nope, WaitForInputIdle is only for GUI apps that uses window messages.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822293">
				<div id="div-comment-822293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ggeldorp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822293">
			March 25, 2010 at 7:56 am</a>		</div>

		<p>If you really do need to process some messages without unblocking the WaitForInputIdle() caller you can use PeekMessage with the PM_NOYIELD flag.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822303">
				<div id="div-comment-822303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.robertwray.co.uk/blog/' rel='external nofollow' class='url'>Rob</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822303">
			March 25, 2010 at 8:17 am</a>		</div>

		<p>@Arno, I think the quote &#8220;The WaitForInputIdle function assisted in the porting of these 16-bit applications&#8221; for Raymond&#8217;s article suggests, at least to me anyway, that WaitForInputIdle was intended to help applications migrating from Win16 to Win32, so probably isn&#8217;t the right answer for a &#8220;true&#8221; 32-bit app &#8211; especially in light of the points you&#8217;ve made..</p>
<div class=post>[<i>What he said. In fact, I wrote something even stronger: It&#8217;s to assist in porting 16-bit programs <u>which used DDE</u> to 32-bit. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822323">
				<div id="div-comment-822323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SSLaks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822323">
			March 25, 2010 at 8:31 am</a>		</div>

		<p>The last sentence states </p>
<p>Actually, the above analysis applies to WaitForInputIdle as well; we&#8217;ll pick up this discussion next time.</p>
<p>The whole article is already about WaitForInputIdle; what will you pick up next time?</p>
<div class=post>[<i>s/the above analysis/the analysis of the imaginary WaitForInputIdleAgain function in the previous paragraph/ -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822343">
				<div id="div-comment-822343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">gerald</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822343">
			March 25, 2010 at 8:58 am</a>		</div>

		<p>Probably that WaitForInputIdle doesn&#8217;t help you if the target application has more than one thread?</p>
<p>Really, the other comments suggest that Raymond wrote that sentence as it is on purpose. Let&#8217;s just be patient.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822383">
				<div id="div-comment-822383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822383">
			March 25, 2010 at 10:06 am</a>		</div>

		<p>There are also problems when some DLL (GDI+?)creates a thread with a message pump. That can cause premature return of WaitForInputIdle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822403">
				<div id="div-comment-822403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822403">
			March 25, 2010 at 10:32 am</a>		</div>

		<p>Isn&#8217;t WaitForInputIdle used by Windows Explorer to display a hourglass+cursor pointer during program startup?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822413">
				<div id="div-comment-822413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://llevicki.net/' rel='external nofollow' class='url'>Igor Levicki</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822413">
			March 25, 2010 at 11:02 am</a>		</div>

		<p>It must be that Windows 7 calls WaitForInputIdle() internally to determine whether the user is idle, because it happens to me that while I am in a full screen game reading some text the OS starts doing its background, performance killing tasks such as indexing, super-fetching, defragmenting, etc.</p>
<p>The problem with OS idle metrics in its current implementation is that it assumes that &quot;no input&quot; must mean &quot;no user in front of the computer, I can do whatever I want&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-822433">
				<div id="div-comment-822433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822433">
			March 25, 2010 at 11:31 am</a>		</div>

		<p>&quot;Dispatching synchronous out-of-process COM calls means running a modal loop, which triggers WaitForInputIdle to report that start-up is done&quot;</p>
<p>&quot;There are also problems when some DLL (GDI+?)creates a thread with a message pump. That can cause premature return of WaitForInputIdle.&quot;</p>
<p>The code doing the pumping could have avoided this by using PM_NOYIELD in the PeekMessage call.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822453">
				<div id="div-comment-822453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arno</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822453">
			March 25, 2010 at 12:43 pm</a>		</div>

		<p>Ah, now I remember why this breaking of WaitForInputIdle for COM made me a bit mad: COM does not set PM_NOYIELD, which IMO is simply wrong. When an application is waiting for a synchronous COM call to return, it has not finished startup yet, and COM should say so.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822463">
				<div id="div-comment-822463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JJJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822463">
			March 25, 2010 at 2:40 pm</a>		</div>

		<p>@Igor Levicki: &nbsp;The first half of today&#8217;s post was for Raymond to explain how WaitForInputIdle has absolutely nothing to do with determining whether a user is idle. &nbsp;So no. &nbsp;No, Windows 7 does not use WaitForInputIdle to determine whether a user is idle.</p>
<p>Way to use it to springboard into an off-topic gripe, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822473">
				<div id="div-comment-822473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822473">
			March 25, 2010 at 2:52 pm</a>		</div>

		<p>@youhong2,</p>
<p>PM_NOYIELD flag only exists for PeekMessage. It doesn&#8217;t exist for GetMessage or WaitMessage.</p>
<div class=post>[<i>And besides, how would COM know when to use PM_NOYIELD and when not to? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-822483">
				<div id="div-comment-822483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822483">
			March 25, 2010 at 4:41 pm</a>		</div>

		<p>@Arno: but COM is pumping messages while waiting for a reply from the out-of-process call. Any queued messages to do with window creation have been dispatched. Your application will receive DDE-related messages, therefore it is idle by Windows definition.</p>
<p>If you don&#8217;t want this behaviour, don&#8217;t make any outbound COM calls before you enter your main message pump. Or use COINIT_MULTITHREADED, I guess, but that won&#8217;t work very well if you use any COM objects on your initial thread.</p>
<p>Your application startup code should be endeavouring to get a window up and into the main message pump, responding to the user, as quickly as possible anyway.</p>
<p>@Igor Levicki: GetLastInputInfo() gives a session wide indicator of the last time input arrived. The game should probably be calling SetThreadExecutionState to tell Windows that it&#8217;s doing something important and now isn&#8217;t the time to be doing background tasks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822493">
				<div id="div-comment-822493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dolph</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822493">
			March 25, 2010 at 7:03 pm</a>		</div>

		<p>SuperKoko: no. &nbsp;see STARTF_FORCEOFFFEEDBACK in the documentation for STARTUPINFO</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822513">
				<div id="div-comment-822513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">M&#233;dinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822513">
			March 26, 2010 at 1:33 am</a>		</div>

		<p>&#8220;You know that the other process was sitting idle, because if it were busy, your code wouldn&#8217;t be running in the first place.&#8221;</p>
<p>What if said other process was in the middle of a SendMessage() call but had not yet started its own message loop?</p>
<div class=post>[<i>Think it through: Why would that DDE server send you a message at startup? It must have special knowledge about you, which means that you and the DDE server are in cahoots, in which case you have no need for WaitForInputIdle. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-822563">
				<div id="div-comment-822563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822563">
			March 26, 2010 at 11:23 am</a>		</div>

		<p>[And besides, how would COM know when to use PM_NOYIELD and when not to? -Raymond]</p>
<p>It is always OK, using it will have no effect if the application is already input idle.</p>
<div class=post>[<i>Um, but what about the other side-efects of not yielding? (Like, say, not yielding? The caller might be a 16-bit app.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822603">
				<div id="div-comment-822603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arno</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822603">
			March 26, 2010 at 2:18 pm</a>		</div>

		<p>@Mike Dimmick and @Raymond: </p>
<p>I guess the question hinges on whether 16-bit COM allowed receiving DDE calls while COM calls were dispatched. I guess the answer is no, because multitasking was cooperative, right? So while the COM call was processed elsewhere, the caller simply stood still. Thus, PeekMessage inside a COM modal loop should set PM_NOYIELD, or not?</p>
<div class=post>[<i>I think your attempt to address the symptom is killing the patient. Imagine what would have happened if 16-bit COM never yielded in its modal loop. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-822653">
				<div id="div-comment-822653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arno</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822653">
			March 27, 2010 at 3:26 pm</a>		</div>

		<p>I did some 16-bit Windows programming, but never with COM. I thought that the model when doing a COM call was simply to switch over to the process receiving the call, and on completion, switch back to the process that initiated the call. So of course a COM call yielded <em>to the receiver of the call</em>. But did it process incoming DDE requests?</p>
<div class=post>[<i>And how did it switch out and back? Window messages. The underlying question is moot. No sane app created cross-process COM objects as part of their startup code, so whether it worked or not is irrelevant. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-822673">
				<div id="div-comment-822673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arno</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-822673">
			March 29, 2010 at 2:20 am</a>		</div>

		<p>I don&#8217;t want to nit-pick, but the reason I had to abandon WaitForInputIdle was that a 3rd party Excel add-in did long (10 seconds and more) out-of-process COM calls in its start-up code, making Excel input-idle prematurely.</p>
<p>I understand that WaitForInputIdle is de-facto deprecated, in particular for applications that allow add-ins. Please encourage the documentation team to say so.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-823253">
				<div id="div-comment-823253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100325-00/?p=14493#comment-823253">
			March 30, 2010 at 7:24 am</a>		</div>

		<p>[Um, but what about the other side-efects of not yielding? (Like, say, not yielding? The caller might be a 16-bit app.) -Raymond]</p>
<p>No. Not in 64-bit windows which disallow 16-bit apps from executing. COM64 could do the right thing, but it doesn&#8217;t.</p>
<div class=post>[<i>&#8220;Hey, in order to encourage people to port their apps to 64-bit, let&#8217;s introduce more differences between 32-bit and 64-bit!&#8221; And wow, look at all those 64-bit apps we have! Um&#8230; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>