<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (16)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-907653">
				<div id="div-comment-907653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907653">
			April 15, 2011 at 7:52 am</a>		</div>

		<p>Ex 1: There&#39;s no ABA because even if the previous head of the list is replaced with a different head at the same address, the pointer in the new head is still correct.</p>
<p>Ex 2: A second call to SignalAll should only signal events added after the first call to SignalAll. &nbsp;If the S bit is already set then no extra events have been added, so there&#39;s nothing extra to signal, so no signals are lost.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907663">
				<div id="div-comment-907663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907663">
			April 15, 2011 at 7:56 am</a>		</div>

		<p>Maybe I can&#39;t count, and it&#39;s probably not crucial to the discussion&#8230; but aren&#39;t the bottom three bits (not two bits) zero for DWORD-aligned addresses?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-907673">
				<div id="div-comment-907673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907673">
			April 15, 2011 at 8:22 am</a>		</div>

		<p>Yeah, whatever. &nbsp;I&#39;m too dumb for all of this so I think I&#39;ll just stick with critical sections and the occasional mutex.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907693">
				<div id="div-comment-907693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John D'Oriocourt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907693">
			April 15, 2011 at 8:46 am</a>		</div>

		<p>I still find these articles fascinating, even if they are over my head. They at least give me some insight into how different things work. The points discussed in the articles or comments may pop up in my head if I work on something similar in the future, preventing errors in the program I&#39;m working on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-907703">
				<div id="div-comment-907703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tobi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907703">
			April 15, 2011 at 8:54 am</a>		</div>

		<p>This makes me wonder if there is a way to specify the requirements for a concurrent algorithm in some efficient format and have the computer synthesize an efficient implementation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907713">
				<div id="div-comment-907713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907713">
			April 15, 2011 at 8:58 am</a>		</div>

		<p>Thanks for this series, Raymond. Complicated topics like these are what make your blog compelling.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-907723">
				<div id="div-comment-907723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907723">
			April 15, 2011 at 8:58 am</a>		</div>

		<p>@tobi: I believe that is subject to the Turing incompleteness theorem.</p>
<p>I suppose if I were encountering this particular case I&#39;d see if I couldn&#39;t use a lock-free queue instead.</p>
<p>Lock free queue&#39;s exist. The implementation is left as an exercise to the reader.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907733">
				<div id="div-comment-907733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tobi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907733">
			April 15, 2011 at 9:12 am</a>		</div>

		<p>@Joshu: I have seen in microsoft research a project that was able to synthesize sequential programs when given constraints and a control flow template. Not usable in practical way but impressive. Also, you cannot argue that static analysis tools cannot exist because of Turings theorem. They do exist, just not complete.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-907743">
				<div id="div-comment-907743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pplu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907743">
			April 15, 2011 at 9:29 am</a>		</div>

		<p>I just can&#39;t wait to see a DailyWTF article that involves a file that starts with this comment:</p>
<p>// WARNING! IF YOU USE THIS CODE YOU ARE AN IDIOT &#8211; READ THE TEXT ABOVE</p>
<p>And of course: no text above ;) Well&#8230; at least they would know they are idiots XD</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907753">
				<div id="div-comment-907753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sukru</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907753">
			April 15, 2011 at 10:33 am</a>		</div>

		<p>I&#39;m trying to go over the code (yes today&#39;s is much more intensive, btw thanks for this great series).</p>
<p>I could not find the documentation for InterlockedReadAcquire on MSDN. Did I miss something?</p>
<p>Also the following comment from SList documentation makes a programmer much more humble:</p>
<p>&nbsp;&quot;SLists are straightforward to implement and use in 32-bit code. However, it is challenging to implement them in 64-bit code because the amount of data exchangeable by the native interlocked exchange primitives is not double the address size, as it is in 32-bit code. Therefore, SLists enable porting high-end scalable algorithms to Windows.&quot;</p>
<div class="post">[<i>The articles in the series build on each other. If you jump into the middle you&#39;re going to be confused. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-907763">
				<div id="div-comment-907763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sukru</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907763">
			April 15, 2011 at 10:53 am</a>		</div>

		<p>&quot;The articles in the series build on each other. If you jump into the middle you&#39;re going to be confused.&quot;</p>
<p>A bit of searching helped. I had actually read that article when it was published, but probably have forgotten about it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907773">
				<div id="div-comment-907773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907773">
			April 15, 2011 at 1:49 pm</a>		</div>

		<p>If there&#39;s a call to AddWait while the list is locked &#8211; won&#39;t this cause a dangling pointer? &nbsp; Am I missing something other than the all-caps comment at the beginning?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-907783">
				<div id="div-comment-907783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907783">
			April 15, 2011 at 3:44 pm</a>		</div>

		<p>That&#39;s some seriously cool code. This whole series has been fascinating, thanks!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907793">
				<div id="div-comment-907793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907793">
			April 16, 2011 at 2:21 am</a>		</div>

		<p>@David Walker &#8211; try counting again ;-) 2 bits have a range of 0-3 and a DWORD has 4 bytes&#8230;</p>
<p>Apart from that, very interesting series. Though I, too, will simply stick to critical sections and the like as I prefer &quot;is slower&quot; over &quot;occasionally doesn&#39;t work&quot;. But then I usually don&#39;t do high performance servers software or OS kernels anyway, where I can see the appeal for it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-907833">
				<div id="div-comment-907833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pete</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907833">
			April 16, 2011 at 1:42 pm</a>		</div>

		<p>We implemented ProcRun similarly in OS/2 1.1. &nbsp;We used a two-byte variable. &nbsp;The low byte was the &quot;busy&quot; byte and the high byte was the &quot;hand-off&quot; byte. &nbsp;The &quot;hand-off&quot; thread would perform the following sequence:</p>
<p>&nbsp; &nbsp;pushf</p>
<p>&nbsp; &nbsp;cli</p>
<p>&nbsp; &nbsp;mov &nbsp; &nbsp; al, 0FFh</p>
<p>&nbsp; &nbsp;xchg &nbsp; &nbsp;lockword.lobyte, al</p>
<p>&nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al, al</p>
<p>&nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;IAmTheWorkerNow</p>
<p>&nbsp; &nbsp;mov &nbsp; &nbsp; lockword.hibyte, al</p>
<p>&nbsp; &nbsp;popf</p>
<p>&nbsp; &nbsp;ret</p>
<p>IAmTheWorkerNow:</p>
<p>&nbsp; &nbsp;sti</p>
<p>Meanwhile, when the &quot;worker&quot; thread was done, it would do the following:</p>
<p>&nbsp; &nbsp;shr &nbsp; &nbsp; lockword, 8</p>
<p>&nbsp; &nbsp;jnz &nbsp; &nbsp; IHaveMoreWorkToDo</p>
<p>&nbsp; &nbsp;ret</p>
<p>The key was to let the bulk of ProcRun run with interrupts enabled. &nbsp;We ran on uniprocessor systems, and kernel code could be interrupted, but not preempted. &nbsp;Reenabling interrupts was a very expensive operation on some buggy chip steppings.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-907853">
				<div id="div-comment-907853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110415-00/?p=10923#comment-907853">
			April 17, 2011 at 11:37 pm</a>		</div>

		<p>Wow, Raymond. Could you have picked a more contentious issue to blog about?</p>
<p>;)</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>