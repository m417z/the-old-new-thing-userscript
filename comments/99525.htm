<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (12)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1356865">
				<div id="div-comment-1356865" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356865">
			August 20, 2018 at 7:54 am</a>		</div>

		<p>&#8230;And yet there are people who call IA-32 &#8220;outright bizarre compared to contemporary RISC-processors&#8221;. Holy fatcats. What is &#8220;sane processor architecture and coding conventions&#8221; then?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1356895">
				<div id="div-comment-1356895" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356895">
			August 20, 2018 at 11:05 am</a>		</div>

		<p>Sane is what you do, insane is what the other guy does :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1356915">
				<div id="div-comment-1356915" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fabian Giesen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356915">
			August 20, 2018 at 1:32 pm</a>		</div>

		<p>Oh IA-32 does a very similar rigmarole for position-independent code (PIC) on platforms that use the System V ABI (Linux, most other Unices). Namely, the GOT passed in ebx is equivalent to the PPC TOC passed in r12. See e.g. <a href="https://ewontfix.com/18/" rel="nofollow">https://ewontfix.com/18/</a>.</p>
<p>This doesn&#8217;t have much to do with PPC per se, it&#8217;s just that without PIC you have frequent fix-ups all over the place that force you to keep distinct copies of fixed-up pages for every process if a DLL gets relocated (the solution Windows chose on 32-bit x86), but with PIC and in absence of a nice way to do PC/RIP-relative addressing you get stuff like the above. Okay, the second half of the post anyway &#8211; the &#8220;branch too distant&#8221; glue functions/trampolines, not so much, because 32- and 64-bit x86 have 32-bit jump distances.</p>
<p>Newer architecture revisions (x86-64 and ARM AArch64) have learned their lesson and provide direct mechanisms for PC-relative addressing to make PIC easier. This is a blind spot for many RISC ISAs because most of them were designed before OSes did dynamic linking, which is when this suddenly started to matter: SunOS 4, which is I believe the first commercial Unix with dynamic linking support, came out in Dec 1988. Most of the major RISCs were already out by then &#8211; although nothing POWER-derived; PPC wasn&#8217;t a thing yet and the POWER1 shipped early in 1990.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1356955">
				<div id="div-comment-1356955" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356955">
			August 21, 2018 at 1:56 am</a>		</div>

		<p>By the way, do you or someone else know why &#8220;System V ABI&#8221; is called so? AFAIK, System V has never been ported to x64, so why call it &#8220;System V&#8221;?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1357025">
				<div id="div-comment-1357025" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fabian Giesen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1357025">
			August 21, 2018 at 3:13 pm</a>		</div>

		<p>I&#8217;m not sure!</p>
<p>It goes back to before POSIX and the SUS, so at the time the System V Interface Definition (SVID) was the primary standard for Unices. That might be the reason why the ABI is branded &#8220;System V&#8221;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-4" id="comment-1357045">
				<div id="div-comment-1357045" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1357045">
			August 21, 2018 at 7:18 pm</a>		</div>

		<p>ELF was introduced in System V Release 4. The processor-specific definitions for ELF binaries on new Linux architectures can still be considered as extensions of the System V ABI.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1356875">
				<div id="div-comment-1356875" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Oberholtzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356875">
			August 20, 2018 at 9:01 am</a>		</div>

		<p>First: &#8216;lr&#8217; is already holding something we need (the return address).  Even disregarding that, using &#8216;lr&#8217; instead of &#8216;ctr&#8217; sounds like a great way to completely desynchronize the return address predictor, killing your performance.</p>
<p>Second: Seeing as how the entire point of the glue function appears to be for saving and restoring the caller&#8217;s TOC, then because a tail call never returns to the caller, it seems that you can just skip the glue entirely, and simply loading the target&#8217;s TOC into r2 and then branching (without link).</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2" id="comment-1356985">
				<div id="div-comment-1356985" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356985">
			August 21, 2018 at 8:11 am</a>		</div>

		<p>Ah, but what if the target turns out to be a glue routine?</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1356925">
				<div id="div-comment-1356925" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Oberholtzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356925">
			August 20, 2018 at 1:57 pm</a>		</div>

		<p>I expect that people who complain about the madness of IA-32 (*especially* IA-32; IA-64 has a great deal more sanity) are referring to the fallout from the following: Going from 16-bit to 32-bit, and the increasing sophistication of CPUs.</p>
<p>The x86 instruction set is actually a pretty nice instruction set.  It has a lot of specialty instructions, especially for supporting loops, string handling, and function calls.</p>
<p>However, a number of things conspired to turn the elegance of the architecture into ugliness:</p>
<p>1. Going from 16-bit to 32-bit: The instruction set stayed pretty much the same, but all immediate values inside machine-word-sized instructions went from 16 bits to 32 bits.  Since a typical instruction with an immediate was 3-4 bytes in 16-bit mode, that meant it became 5-6 bytes in 32-bit mode: which is a 50-67% increase in the size of instructions that required an immediate.</p>
<p>   This was especially noticable for instructions that were loading small constants into registers.</p>
<p>2. Because there were so few registers, and because most useful instructions can directly reference memory, compilers (and assembly language programmers) would be forced to emit code that directly referenced memory addresses.</p>
<p>   When combined with #1, this means that in 32-bit mode, many instructions that are only 4 bytes on a RISC system are *more* than 4 bytes on IA-32.  Strike one.<br />
Furthermore, temporaries that would be stored in a register on a RISC system must be written to main memory, with all the latency and cache effects that implies.  Strike two.</p>
<p>3. Out-of-order execution was a death knell for a lot of the more fancy instructions.<br />
   OOE is crucial for a modern CPU to achieve anwhere near maximum performance; inversely, anything that prevents OOE must be avoided as much as possible.</p>
<p>	A great example of this is PUSH.  Because PUSH writes to SP, a series of PUSH instructions would create a dependency chain, preventing OOE and thus forcing the CPU to serialize the parameter setup phase.</p>
<p>	The choice became: small but slow code, or fast but big code.  Compilers would often choose the latter, and write MOV DWORD PTR [SP+x], y, for a whopping 6-byte instruction (for loading from a register) or a *10-byte* instruction (for a constant).</p>
<p>At this point, we&#8217;re in &#8220;crazy&#8221; territory: a large number of specialty instructions that aren&#8217;t used, and a common step (setting up a single argument for a subroutine call) that is a single 32-bit CPU instruction on a RISC machine, is more than twice as large on an x86.  And, on x86, *must* hit main RAM eventually, even if all the subroutine does is read the value in, add 8, and return it in EAX.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1356935">
				<div id="div-comment-1356935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fabian Giesen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356935">
			August 20, 2018 at 5:52 pm</a>		</div>

		<p>Dependency chains aren&#8217;t that bad and certainly don&#8217;t prevent OOE! Specifically, it&#8217;s totally fine to have a few long dependency chains as long as you have other stuff to do in between &#8211; like, say, the rest of the function. </p>
<p>PUSHes and POPs are an interesting case because they are quite common and have been getting special hardware acceleration for over 15 years now.</p>
<p>Even in a direct implementation of PUSH/POP (i.e. actual SP modified every instruction), that means a sequence of PUSH/POPs each depends on the previous one in the chain, but that only affects exactly those instructions (and others that access RSP explicitly or implicitly), it doesn&#8217;t prevent you from reordering anything else. Said direct implementation boils down to a SP decrement followed by a store for each PUSH, with subsequent PUSHes depending on the prior PUSH&#8217;s SP decrement. Assuming the SP decrement takes one clock cycle (i.e. same as a regular integer add), that limits you to one PUSH executed per clock cycle; but all currently shipping x86s execute at most one store per clock cycle anyway (because there&#8217;s only one, pipelined, store unit) so that is not a throughput hit by itself.</p>
<p>POPs are a bit more annoying in the direct implementation because current x86s can do two loads per cycle, so there the 1/cycle limit if you have to wait for the SP update hurts.</p>
<p>That&#8217;s where the aforementioned hardware acceleration helps: starting with the Pentium M, Intel put a &#8220;Stack Engine&#8221; in the renamer that internally turns sequences of stack-modifying operations into more efficient ones. Conceptually, the CPU frontend rewrites say</p>
<p>  PUSH rax<br />
  PUSH rcx<br />
  PUSH rdx</p>
<p>into something like the internal equivalent of</p>
<p>  MOV [rsp-8], rax<br />
  MOV [rsp-16], rcx<br />
  MOV [rsp-24], rdx<br />
  SUB rsp, 24</p>
<p>getting rid of most of the serial stack pointer updates entirely (similar for POPs). For PUSHes, this doesn&#8217;t decrease the total latency for the pushes to complete, but it does reduce the number of uops executed (leaving the integer execution units free to do more useful work). For POPs on the more recent CPUs supporting two loads/cycle (for Intel: Sandy Bridge and later), this also has the side effect of allowing two POPs to complete per cycle, but that&#8217;s more recent (~7 years ago).</p>
<p>(A bit more detail: what the stack engines do is make instructions such as PUSH, POP, CALL and RET use a virtual SP that has the form &#8220;virtual_SP = base_SP + offset&#8221;, where offset is a small integer, and base_SP is stored in a register. Most stack-using instructions only update the offset. Only when the offset gets too small, too large, an instruction wants to use RSP directly, or an interrupt/exception occurs, is an actual stack-pointer update inserted that makes the virtual SP agree with the &#8220;base SP&#8221; stored in a register and zeroes the offset. This occurs fairly rarely.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1356945">
				<div id="div-comment-1356945" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1356945">
			August 20, 2018 at 9:43 pm</a>		</div>

		<p>&gt;The x86 instruction set is actually a pretty nice instruction set. It has a lot of specialty instructions,<br />
&gt;especially for supporting loops, string handling, and function calls.</p>
<p>You left off the rest of the sentence:</p>
<p>&#8230; as implemented by the Pascal programming language.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1357055">
				<div id="div-comment-1357055" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180820-00/?p=99525#comment-1357055">
			August 21, 2018 at 9:13 pm</a>		</div>

		<p>Its a pitty IBM didn&#8217;t go with the Motorola 68000 as the CPU in the PC, having dabbled in 68000 assembler I find it a nice instruction set to work with (in part because it gives you that nice flat address space and doesn&#8217;t even have the idea of segments)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>