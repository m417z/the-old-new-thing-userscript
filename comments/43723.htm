<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1159083">
				<div id="div-comment-1159083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159083">
			October 31, 2014 at 7:25 am</a>		</div>

		<p>Raymond, when Microsoft does contact a third party about bugs in their code, generally speaking, how receptive are to fixing things?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159103">
				<div id="div-comment-1159103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159103">
			October 31, 2014 at 7:37 am</a>		</div>

		<p>To be fail, if I were the vendor I&#39;d fix that bug very quickly by calling GetLastError and SetLastError and be looking at a patch release the next day.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159113">
				<div id="div-comment-1159113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159113">
			October 31, 2014 at 7:39 am</a>		</div>

		<p>To be fair not to be fail. Stupid autocorrect</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159123">
				<div id="div-comment-1159123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jmac_the_man</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159123">
			October 31, 2014 at 7:40 am</a>		</div>

		<p>Raymond/Raymond&#39;s Microsoft Friends,</p>
<p>A while ago, you posted a story that briefly mentioned Use Case documentation that Microsoft uses in system design has a standardized set of names of the actors, and the actor&#39;s first name implies their skill level and role. (So, for example, if you&#39;re reading a use case and you see the name &quot;Bob,&quot; you know he&#39;s a mid-level user, whereas &quot;Charlie&quot; is the supervisor of the user with their hands on the keyboard of the program under study or whatever.)</p>
<p>Is there any chance there&#39;s documentation available on this? </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159133">
				<div id="div-comment-1159133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159133">
			October 31, 2014 at 7:52 am</a>		</div>

		<p>Ignoring the rogue DLL (which is poor form, I agree), to me the real bug still seems to be in CopyFile2, which is relying on CloseHandle not to mess with the last error on success, which does not seem to be contractually obligated. So hopefully that at least got logged as a bug to the appropriate team.</p>
<div class="post">[<em>I agree that CopyFile2 could be more defensive, but on the other hand, the people who maintain CopyFile2 are also the people who maintain CloseHandle, so they would just be defending against themselves. If they change CloseHandle to mess with the last error code, then they can also change CopyFile2. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159143">
				<div id="div-comment-1159143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Count Zero</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159143">
			October 31, 2014 at 7:55 am</a>		</div>

		<p>@12BitSlab &#8211; While you was asking Raymond, let me &quot;say&quot; my answer to that as a non-Microsoft developer. It strongly depends. There are project companies, which are asked and payed to produce some software or software component (usually by another development company which sells the finished product), and get no financial benefit from fixing errors in already finished (and paid) products. I have worked for some of those. Those companies are always overrun with work and deadlines therefore they would not even have resources to fix buggy code if they were intended to (and usually upper management definetly forbids such fixes unless they are paid for).</p>
<p>The other type of software development firm typically develops only a few products and directly profits after the sales of those, so they have a financial interest in fixing bugs as soon as possible. I&#39;m working for one of those nowadays. Theres is something more to the non-project companies: their connection to their software (source code). They know, like, and live in symbiosis with that. They are always up-to-date about one-or-another aspect of the programs, constantly testing and developing it so if it is buggy they happily fix it. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159153">
				<div id="div-comment-1159153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159153">
			October 31, 2014 at 8:59 am</a>		</div>

		<p>&quot;When it does, you can see who set the value. &quot;Oh, the value was copied from that other variable.&quot; Now you repeat the exercise with that other variable, and so on.&quot;</p>
<p>We want time-travelling debuggers!</p>
<p>When do we want them?</p>
<p>Yesterday!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159163">
				<div id="div-comment-1159163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159163">
			October 31, 2014 at 10:05 am</a>		</div>

		<p>Hooking CloseHandle, what a capital suggestion. Nothing could possibly go wrong with that. The only right hook here is the one the programmer&#39;s face deserves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159173">
				<div id="div-comment-1159173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159173">
			October 31, 2014 at 10:11 am</a>		</div>

		<p>@JM: I&#39;ve seen it before when somebody hooked CreateFile to create a virtual file system from userspace. It&#39;s nearly a bad idea as it sounds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159193">
				<div id="div-comment-1159193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159193">
			October 31, 2014 at 10:36 am</a>		</div>

		<p>@Evan: Given a time-travelling debugger, I&#39;d rip out the debugger and replace it with a bomb before dispatching the package to whoever first dreamt up the &quot;errno&quot; idiom for reporting errors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159203">
				<div id="div-comment-1159203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159203">
			October 31, 2014 at 10:39 am</a>		</div>

		<p>&quot;At least we can try to get them to fix their bug.&quot;</p>
<p>Perhaps they could fix it by hooking SetLastError() ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159213">
				<div id="div-comment-1159213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159213">
			October 31, 2014 at 10:51 am</a>		</div>

		<p>@Ken Hagan: I wrote a time traveling debugger when debugging a crash so bad it would bring the process down immediately because it was in so bad a state even the debugger couldn&#39;t function in the process anymore.</p>
<p>Unfortunately the technique involved is read-only. Writing to the past didn&#39;t propagate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159233">
				<div id="div-comment-1159233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159233">
			October 31, 2014 at 2:49 pm</a>		</div>

		<p>I&#39;m also of the opinion that the bug is in the CopyFile2 implementation. &nbsp;They took a dependency on an undocumented (if it is documented that &quot;Close&shy;Handle on a valid handle is not supposed to modify the thread error state&quot;, I&#39;d love to see it&#8230; but there is no such statement in CloseHandle&#39;s own MSDN page) implementation detail. &nbsp;And GetLastError explicitly says:</p>
<p>&gt; Most functions that set the thread&#39;s last-error code set it when they fail. However, some functions also set the last-error code when they succeed. If the function is not documented to set the last-error code, the value returned by this function is simply the most recent last-error code to have been set; some functions set the last-error code to 0 on success and others do not.</p>
<p>&gt; Functions executed by the calling thread set this value by calling the SetLastError function. You should call the GetLastError function immediately when a function&#39;s return value indicates that such a call will return useful data. That is because some functions call SetLastError with a zero when they succeed, wiping out the error code set by the most recently failed function.</p>
<p>When a hook conformed to the documented interface, the function relying on the implementation details started failing. &nbsp;That shouldn&#39;t surprise any readers of this blog &#8212; Raymond is always writing about the superhuman efforts needed to bring implementation details into the contract to avoid breaking application software. &nbsp;This is just the opposite perspective; if there are multiple implementers, making the contract more tolerant of users breaks existing implementers.</p>
<p>I don&#39;t see that being the implementer of the shipped version of CloseHandle makes it ok for the CopyFile2 developer to ignore the actual rules documented for GetLastError and rely on details of one particular CloseHandle implementation. &nbsp;Yes, I know both functions live in the same DLL, but it&#39;s not like Detours is some third-party approach. &nbsp;Things would be different if they called a non-public function (probable name: ZwForInternalUseOnlyThisIsTheRealCloseHandle), of course, but they didn&#39;t.</p>
<div class="post">[<em>And then people who detour Close&shy;Handle will say, &quot;Hey, when a file is copied, we never see the handle get closed! Now we have a huge memory leak.&quot; And then maybe they will find Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;Close&shy;Handle, and detour that, and you&#39;re back where you started. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159243">
				<div id="div-comment-1159243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Y</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159243">
			October 31, 2014 at 3:36 pm</a>		</div>

		<p>Wait, so the end result is that the file wasn&#39;t haunted after all? &nbsp;Every attempt to copy a file that would involve an overwrite would have had the same effect? &nbsp;(On an unrelated note: I suppose that as a side effect of this adventure, the function has been changed to grab the error code sooner?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159253">
				<div id="div-comment-1159253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159253">
			October 31, 2014 at 4:26 pm</a>		</div>

		<p>How about a TlsGetValueEx function that doesn&#39;t do that weird SetLastError behavior?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159183">
				<div id="div-comment-1159183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159183">
			October 31, 2014 at 10:31 am</a>		</div>

		<p>@Joshua &#8211; there are defendable reasons for doing so &#8211; for *individual apps* &#8211; but not for the whole system ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159263">
				<div id="div-comment-1159263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159263">
			October 31, 2014 at 8:34 pm</a>		</div>

		<p>Bob: Anybody aware enough to realize the value of calling TlsGetValueEx could just as easily save and reset the last error.</p>
<p>BTW, I&#39;ve been bitten by the TlsGetValue bug, too. Fortunately my bug was reasonably easy to spot once I remembered the behavior. It&#39;s easy to forget that TlsGetValue can fail, so it&#39;s easy to forget that it sets the last error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159273">
				<div id="div-comment-1159273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159273">
			October 31, 2014 at 9:33 pm</a>		</div>

		<p>People who say that CopyFile2 should get the error code sooner are correct, but missing the point. &nbsp;Consider if a rogue dll hooked CopyFile2 instead with code like this:</p>
<p>HRESULT Hook_CopyFile2()</p>
<p>{</p>
<p> HRESULT hr = Original_CopyFile2();</p>
<p> HookState *state = (HookState*)TlsGetValue(g_tlsHookState);</p>
<p> if (state &amp;&amp; state-&gt;someCrazyFlag) {</p>
<p>.</p>
<p> &#8230; crazy code that runs if the flag is set &#8230;</p>
<p> }</p>
<p> return hr;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159323">
				<div id="div-comment-1159323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159323">
			November 1, 2014 at 4:49 am</a>		</div>

		<p>@Evan &#8211; Here you go: <a rel="nofollow" target="_new" href="http://www.thewindowsclub.com/microsoft-time-travel-tracing-diagnostic">http://www.thewindowsclub.com/microsoft-time-travel-tracing-diagnostic</a></p>
<p>I&#39;ve used it before &#8211; not an easy tool to operate, but it does work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159333">
				<div id="div-comment-1159333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159333">
			November 1, 2014 at 6:37 am</a>		</div>

		<p>It seems like the real problem here is relying on a global variable to communicate information across function calls. &nbsp;Earth shattering news, Global Variables Are Bad. &nbsp;If something is a return value from a function call, return it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159353">
				<div id="div-comment-1159353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159353">
			November 1, 2014 at 7:56 am</a>		</div>

		<p>@Thomas: That hook is clearly broken, because it doesn&#39;t conform to the documented rules which I quoted directly from MSDN.</p>
<p>The thing about the case Raymond presented is that the hook DOES conform to the documented contract.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159363">
				<div id="div-comment-1159363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159363">
			November 1, 2014 at 9:19 am</a>		</div>

		<p>@Ben Voigt:</p>
<p>The thing is, you are quoting rules about hooks and saying that CopyFile2 is broken because of it. But the first hook itself clearly doesn&#39;t follow all the quoted rules. Specifically</p>
<p>&quot;Most functions that set the thread&#39;s last-error code set it when they fail. However, some functions also set the last-error code when they succeed. If the function is not documented to set the last-error code, the value returned by this function is simply the most recent last-error code to have been set; some functions set the last-error code to 0 on success and others do not.&quot;</p>
<p>Because it is not documented what happens on success, and it is clearly documented that the behaviour on success isn&#39;t pre-determined, the hook function is breaking the contract by not saving the error code. From the re&#39;d code that Raymond posted, they don&#39;t even attempt to save the error code at all. This is obviously going to change the behaviour of the function it hooked.</p>
<p>I also agree with Raymond on the &quot;they will be defending against themselves&quot; part. They control both sides here, and they right the implementation. So in this case, they are not relying on undocumented or implementation defined behaviour, they are relying on behaviour that they write themselves. I&#39;m sure any large software implementation has this somewhere, but it is easy to bash Microsoft here because there is a concrete case of something going wrong, and it&#39;s Microsoft.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159283">
				<div id="div-comment-1159283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jas88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159283">
			November 1, 2014 at 2:35 am</a>		</div>

		<p>At least this only gave an inaccurate error message &#8211; I was immediately reminded of a few hours of hair loss years ago when my userspace program was triggering a BugCheck &#8211; when I closed a file handle. It turned out the AV product I had installed at the time (not an MS one) was, for obvious reasons, hooking file access &#8211; and, somehow, screwed up the ZwClose/NtClose hook. It looked as if they were *usually* allocating a buffer when a file was opened, then *always* freeing it when that file was closed &#8211; I&#39;d hit the corner case where it didn&#39;t allocate the buffer, but still tried to free it later, breaking the system in the process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command odd alt thread-odd thread-alt depth-1" id="comment-1159373">
				<div id="div-comment-1159373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159373">
			November 1, 2014 at 12:23 pm</a>		</div>

		<p>Every time I read an article about a strange behavior in Windows components, the reason is always hooking/injection or plug-ins.</p>
<p>Is it illogical to think Windows needs to outlaw hooking and develop a plug-in model for Explorer instead?</p>
<div class="post">[<em>Um, Explorer has had a plug-in model since day one. Some people abuse this plug-in model in order to inject themselves in to Explorer so they can hook it. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159383">
				<div id="div-comment-1159383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159383">
			November 1, 2014 at 1:26 pm</a>		</div>

		<p>@Fleet Command: Considering the techniques currently used, documenting well how to do it is far more likely to bring real quality results. The only way to outlaw hooks is to outlaw debuggers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159403">
				<div id="div-comment-1159403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nitpicker (Corner?)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159403">
			November 1, 2014 at 8:46 pm</a>		</div>

		<p>@Fleet Command &#8211; As soon as I saw the name of the post, I said (out loud) &#39;buggy shell extension&#39;. I wasn&#39;t too far off.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1159423">
				<div id="div-comment-1159423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159423">
			November 2, 2014 at 2:13 pm</a>		</div>

		<p>If you want to save you some grief, don&#39;t assume that last error doesn&#39;t change across some function calls. If you&#39;ll need it, save it to the variable immediately after the call of interest. Because you may later add tracing calls, printfs, etc, and break your GetLastError() state, unless you&#39;ve saved it.</p>
<p>I suspect, such approach was the reason the defective component didn&#39;t cause catastrophic damage in most other cases of CloseHandle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159433">
				<div id="div-comment-1159433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alois Kraus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159433">
			November 2, 2014 at 2:22 pm</a>		</div>

		<p>I guess you had a TT Trace which makes debugging back and forth in time much easier. Otherwise I would not think that you could do such an analysis within a few hours. How about giving this power to the official Windbg version? </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159473">
				<div id="div-comment-1159473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Radosław Cybulski</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159473">
			November 3, 2014 at 2:30 am</a>		</div>

		<p>As Alois pointed out &#8211; the real question is: when time travel will be available to everyone? Because the problem with CopyFile2 is easy once You dig into source code &#8211; it relies on not-visible-in-code dependency about CloseHandle not changing error code, when successed. Once it does (for any reason) the code breaks. </p>
<p>It doesnt really matter, that both functions are managed by the same people. That sort of invisible dependency makes source code much, much harder to read and change. Just code defensively and read the error code into local variable. This is CopyFile2 bug, unless CloseHandle is defined as not changing error code, when successed.</p>
<p>This paragraph about emulating undocumented behavior is simply wrong. As long as such a dependency is invisible, there&#39;s no difference between some happy coder in India writing a hook and also happy coder in microsoft, working in another division. They both wont see it coming, make the same error and in both cases sh*t will hit the fan later on. Either make the dependency visible (ie document it) or remove it from the code (ie copy error value to local variable right after failure).</p>
<p>You can also it CopyFile2 from different perspective. It stores its success flag in two different places, fSuccess boolean flag (Hungarian notation is so 80&#8230;) and in global variable returned by GetLastError. Function makes decision based on first, but returns the second. Which caller makes decision on. You dont need to check any documentation about used calls to know this spells troubles. In such case there should be an assert on exit, making sure fSuccess and returned value both report either success or error. This would make Your debugging lasts maybe 3 seconds.</p>
<p>Also global variables.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159493">
				<div id="div-comment-1159493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EduardoS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159493">
			November 3, 2014 at 7:19 am</a>		</div>

		<p>I think the bug is in GetLastError/SetLastError, in the sense, they exists at all, how many bugs already appeared because of those functions writing global variables?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1159513">
				<div id="div-comment-1159513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159513">
			November 3, 2014 at 9:00 am</a>		</div>

		<p>– &quot;Um, Explorer has had a plug-in model since day one. Some people abuse this plug-in model in order to inject themselves in to Explorer so they can hook it. -Raymond&quot;</p>
<p>I mean a real deal: Plug-ins come in a package, there is a plug-in manager that can enable or disable them, etc. Like Chrome and Firefox. Current state is like IE: Individual components that each accomplish a non-atomic task are developed without any real tangible connection to form a bigger whole that remains abstract. So, overall, it does not have the properties of a model.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159523">
				<div id="div-comment-1159523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159523">
			November 3, 2014 at 9:27 am</a>		</div>

		<p>EduardoS: What do you suggest should have taken the place of GetLastError/SetLastError back in 1983?</p>
<p>Should every API have an out-parameter for the error? Or perhaps the return value from every function should be the return status and any returned value would have to be an out-parameter? Or maybe they should have invented structured exception handling?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159533">
				<div id="div-comment-1159533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Remko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159533">
			November 3, 2014 at 10:24 am</a>		</div>

		<p>That&#39;s why functions should return a boolean for succes or failure instead of calling getlasterror</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159553">
				<div id="div-comment-1159553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159553">
			November 3, 2014 at 10:54 am</a>		</div>

		<p>@Crescens2k: Good job cutting out the other half of the quote, the half that is pretty clear that the default contract has no postconditions on the thread last-error value when a function succeeds. &nbsp;If you define an interface as &quot;behaves exactly like the shipped implementation in all cases&quot;, that&#39;s no interface at all. &nbsp;A substitute implementation only has to abide by the documented contract; that&#39;s pretty fundamental to polymorphism.</p>
<p>@Raymond: &quot;maybe they will find Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;Close&shy;Handle, and detour that&quot; &nbsp;By non-public, I meant that it isn&#39;t even exported, and after optimization might not even exist as a separate entity. &nbsp;Besides, there&#39;s no memory leak the way I envision it, because you close handles with Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;Close&shy;Handle only if you opened them with Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;CreateFile (see: pairing of malloc=free, new=delete, new[]=delete[], CoTaskAlloc=CoTaskFree, etc), and the hook doesn&#39;t have any private data associated with the handle because it hasn&#39;t seen it. &nbsp;It is purely an implementation detail of CopyFile2. &nbsp;If hook developers get upset because hooks installed on the public interface don&#39;t catch all internal activities deep within kernel32.dll, too bad, they&#39;ve misunderstood what hooking a function does. &nbsp;Hooking CreateFile does not intercept all file access of any variety, anywhere, it intercepts calls to CreateFile.</p>
<div class="post">[<em>Then &quot;Why does CopyFile2 use undocumented APIs we cannot hook? We are hooking file I/O in order to implement our virtual file system.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159633">
				<div id="div-comment-1159633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159633">
			November 3, 2014 at 4:12 pm</a>		</div>

		<p>@Ben Voigt: If you&#39;re substituting a function that relies on global state, that global state is part of the contract too! I remember several TSRs that I used back in DOS days that didn&#39;t remember that and could crash the system in weird ways.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159823">
				<div id="div-comment-1159823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159823">
			November 4, 2014 at 4:55 am</a>		</div>

		<p>[Then &quot;Why does CopyFile2 use undocumented APIs we cannot hook? We are hooking file I/O in order to implement our virtual file system.&quot; -Raymond]</p>
<p>Anyone trying to do this should be forced to implement a real driver. Even and especially AV software should not hook into processes in some strange way, it should do it&#39;s real-time scanning by a filter driver, using the official interfaces.</p>
<p>So, from my point of view, your reason does not exist / is not justified.</p>
<div class="post">[<em>&quot;But there are some things you can&#39;t do in kernel mode, like display UI.&quot; Another scenario might be &quot;We are writing a diagnostic tool, and we want to log all I/O operations with stack traces and other metadata. Our traces do not include I/O due to file copying.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159843">
				<div id="div-comment-1159843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zack</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159843">
			November 4, 2014 at 6:17 am</a>		</div>

		<p>If I could go back to 1970 with a set of changes for Kernighan and Ritchie to implement in the very first version of C, along with mandatory prototyped function declarations, sane operator precedence, postfix unary *, and the extirpation of &lt;code&gt;gets&lt;code&gt;, I would seriously consider fixed-length, scalar-only multiple value return, so you could write</p>
<p>&lt;pre&gt;(err, fd) = open(&quot;path&quot;, flags);&lt;/pre&gt;</p>
<p>At the ABI level this is no more difficult than accepting multiple arguments to a single function, it eliminates all the problems with errno/GetLastError, and it doesn&#39;t have the yuck factor associated with out-parameters for the result the programmer actually wants.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159903">
				<div id="div-comment-1159903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EduardoS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159903">
			November 4, 2014 at 8:26 am</a>		</div>

		<p>@Gabe, I think it would be nice if they invented structured exception handling in 1983, but 1983 doesn&#39;t matter, nobody cares about Windows 1.0, by the time 32 bit Windows come there was another option, HRESULT with an out parameter for the result, instead, MS made no effort to deprecate the old API.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159913">
				<div id="div-comment-1159913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159913">
			November 4, 2014 at 8:39 am</a>		</div>

		<p>EduardoS: It sounds like you are suggesting that Microsoft should have created a whole new API for Win32 that is completely different from Win16. This would prevent people from easily porting their code to Win32, preventing the adoption of Win32. </p>
<p>Or are you suggesting that old APIs still have the old error return mechanism while all new ones would use HRESULTs? That would result in lots of confusion among developers, making reliable code harder to write.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1160003">
				<div id="div-comment-1160003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EduardoS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1160003">
			November 4, 2014 at 3:05 pm</a>		</div>

		<p>@Gabe, a mix of the two, there should be a easy way to port from Win16, but it is porting, 16 bitness had some weird things (Global*/Local*, cooperative to preemptive, etc) so some changes were required, it wouldn&#39;t be that bad if a bit more changes were required, and this porting helper (wich may not even be part of the actual API, rather, could be just a header) should not be the default way to write new applications, COM come about the same time Win32 come out creating a lot of confusion anyway, MS could have cleared a bit the confusion by saying THIS is the new way to write apps and, of course, providing the full API in this new way.</p>
<p>BTW, COM had it&#39;s own problems and was a bit boring to use, but some things just needs time and effort to evolve wich half attempts never get.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>