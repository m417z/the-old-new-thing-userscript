<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (31)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1129653">
				<div id="div-comment-1129653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129653">
			June 6, 2014 at 7:13 am</a>		</div>

		<p>Poor man&#39; link time code generation:</p>
<p>#include &quot;main.cpp&quot;</p>
<p>#include &quot;frame.cpp&quot;</p>
<p>#include &quot;func.cpp&quot;</p>
<p>#include &quot;account.cpp&quot;</p>
<p>#include &quot;advancer.cpp&quot;</p>
<p>#include &quot;audit.cpp&quot;</p>
<p>#include &quot;cpio.cpp&quot;</p>
<p>g++ -whole-program -o my books.exe -O3 includeall.cpp</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129663">
				<div id="div-comment-1129663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henke37</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129663">
			June 6, 2014 at 7:44 am</a>		</div>

		<p>How does the linker know which format the number should be in? The compiler told it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129673">
				<div id="div-comment-1129673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129673">
			June 6, 2014 at 7:47 am</a>		</div>

		<p>Good to know after all these years that the fabled Microsoft Temporal Mechanics department has started producing some results. &nbsp;That time machine must be just around the corner.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129683">
				<div id="div-comment-1129683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ace</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129683">
			June 6, 2014 at 8:01 am</a>		</div>

		<p>What do we want?</p>
<p>Time travel!</p>
<p>When do we want it?</p>
<p>It&#39;s irrelevant!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129703">
				<div id="div-comment-1129703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129703">
			June 6, 2014 at 9:44 am</a>		</div>

		<p>Or, as we could also call &quot;non-classical linking&quot; and &quot;whole program optimization&quot;: compilation.</p>
<p>It&#39;s only magic if you still think that what they did in the 70s was pretty heavy stuff. One man&#39;s separation of concerns is another man&#39;s stone knives and bearskins.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129733">
				<div id="div-comment-1129733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129733">
			June 6, 2014 at 10:31 am</a>		</div>

		<p>@ JM</p>
<p>IBM&#39;s mainframe implementation of PL/I in the 60&#39;s and 70&#39;s did some very heady memory optimizations. &nbsp;You could declare variables of type flag (i.e., a bit) and the PL/I optimizer would combine them into bytes along with the proper masking for read and write access. &nbsp;Along with some ASM, OS/360 ands its follow ons were written in PL/I.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129803">
				<div id="div-comment-1129803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129803">
			June 6, 2014 at 1:28 pm</a>		</div>

		<p>A &quot;whole program optimizer&quot; could easily be developed by running a few copy commands as a pre-build task to concatenate all source before the compiler is invoked. Why was a whole new toolchain developed instead? Crazy. Even crazier is that this feature is advertised as something advanced when it&#39;s unnecessary. I guess some clueless compiler developer wanted to increase the technical debt tenfold.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129813">
				<div id="div-comment-1129813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129813">
			June 6, 2014 at 1:39 pm</a>		</div>

		<p>Not quite 640k. &nbsp;Just concatenating the sources would cause all sorts compiling issues such as Macros that would normally die at the end of one module would now live into the next. &nbsp;Headers that have conditional compilation directives may be defined differently in different files could no longer be used. &nbsp;static and anonymous namespace durations would be unduly extended and undoubtedly conflict. &nbsp;I am sure there are a hundred other things that would also go wrong (anywhere the standard mentions &quot;compilation unit&quot; or whatever the current equivalent is would probably have issues).</p>
<p>There would probably be some upsides as well &#8212; if the ordering of the files is defined the global variable initialization order problem becomes solved.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129833">
				<div id="div-comment-1129833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129833">
			June 6, 2014 at 3:28 pm</a>		</div>

		<p>@128BitSlab: to be fair, I was specifically thinking of C (and by extension C++)&#39;s ludicrously primitive approach to modularity. As in, there isn&#39;t any beyond the use of &quot;static&quot;, just make sure you combine source files in appropriate ways. It&#39;s certainly true that people could do better even in the 70s&#8230; but it&#39;s also true that &quot;worse is better&quot; is a real thing for a reason.</p>
<p>I&#39;m not sure PL/I is the best of counterarguments, though. It went a little too far in the opposite direction when compared to C&#8230; as in, never mind the cost of implementation, just throw it all in and see what sticks. This didn&#39;t exactly have a good influence on its design either&#8230; So nice bitflag optimization, shame about the rest, I suppose. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129853">
				<div id="div-comment-1129853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129853">
			June 6, 2014 at 5:20 pm</a>		</div>

		<p>As I understand it and heard from others, the Xbox 360 had poor backward compatibility precisely because of Link-Time Code Generation. &nbsp;The original Xbox was a prime candidate for emulating games at a high level, since the NV2A calls were abstracted via DirectX. &nbsp;The 360 system software could have emulated the x86, intercepted the kernel calls, and found the DirectX routines within the executable, then simulated their effects, but LTCG made this difficult.</p>
<p>In release builds, the DirectX libraries for the original Xbox were compiled with /GL, as were the games by default, and it resulted in blurring of the boundaries between game code and DirectX library code. &nbsp;It made the games slightly faster on the Xbox, but later, when an emulator was desired for 360, it wasn&#39;t possible to perfectly distinguish where the DirectX API calls begin. &nbsp;The DirectX code got mixed into game code.</p>
<p>Later XDK builds supposedly had externally-visible tables of pointers to critical functions in the XDK to avoid this problem, but it was too late for the majority of games.</p>
<p>This is all from possibly-unreliable sources, but it seems logically-consistent.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129863">
				<div id="div-comment-1129863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy O'Neal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129863">
			June 6, 2014 at 7:29 pm</a>		</div>

		<p>Myria: The Xbox was an x86 machine, and the 360 is a PowerPC machine. The Xbox used an NVidia graphics chip, the 360 used an ATI graphics chip. Etc. Linking is the least of the problems of backcompat for the 360.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129913">
				<div id="div-comment-1129913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129913">
			June 7, 2014 at 3:26 am</a>		</div>

		<p>@myria</p>
<p>The rumour I heard was that by linking DirectX games to the games in that way was done on purpose to make it hard to run the games on a standard windows pc. If so it worked really well as people tried and they never succeeded. OTOH the emulator for the 360 is surprisingly good, they only whitelisted games that they actually tested and they didn&#39;t test all games. The developer boxes will run all games and it seems a lot of games work quite well. Sony have a similar issue and they just put more effort into testing (and in a lot of cases patching) games (they even have game specific patches for PS1 games running on a PS2 and they sold that as hardware backward compatibility, which it isn&#39;t completely).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129923">
				<div id="div-comment-1129923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129923">
			June 7, 2014 at 6:03 am</a>		</div>

		<p>@ JM</p>
<p>Largely, I agree with you. &nbsp;One thing that one has to keep in mind was that the optimizations associated with PL/I were more more concerned about memory usage as opposed to fast code. &nbsp;It did have optimizations for loop invariant code and things like that, but in the context of the time, memory was far more precious than was processor speed given the incredibly slow nature of I/O at the time. &nbsp;Remember, the first shipment of S/360&#39;s did not have disk drives. &nbsp;It was a card/batch system.</p>
<p>I wrote some PL/I back in the day. &nbsp;It was one of my least favorite tools to use. &nbsp;I felt more comfortable with ASM than PL/I and given the choice, would go with ASM everytime.</p>
<p>BTW, if I sound old, I just might be. &nbsp;I voted for Lincoln &#8212; when he ran for the Senate. &nbsp;He was such a nice young man.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129943">
				<div id="div-comment-1129943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129943">
			June 7, 2014 at 8:18 am</a>		</div>

		<p>If it invalidates it hopefully it just reports it as a diagnostic and dies (failure or justified).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129953">
				<div id="div-comment-1129953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">loreb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129953">
			June 7, 2014 at 1:35 pm</a>		</div>

		<p>@Joshua</p>
<p>Sqlite&#39;s amalgamation does more or less what you say, see <a rel="nofollow" target="_new" href="https://www.sqlite.org/amalgamation.html">http://www.sqlite.org/amalgamation.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn odd alt thread-odd thread-alt depth-1" id="comment-1129963">
				<div id="div-comment-1129963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129963">
			June 8, 2014 at 12:17 am</a>		</div>

		<p>@SimonRev: the static vars are easily handled by few curly brackets:</p>
<p>{</p>
<p>#include &quot;main.cpp&quot;</p>
<p>}{</p>
<p>#include &quot;frame.cpp&quot;</p>
<p>}{</p>
<p>#include &quot;func.cpp&quot;</p>
<p>}{</p>
<p>#include &quot;account.cpp&quot;</p>
<p>}{</p>
<p>#include &quot;advancer.cpp&quot;</p>
<p>}{</p>
<p>#include &quot;audit.cpp&quot;</p>
<p>}{</p>
<p>#include &quot;cpio.cpp&quot;</p>
<p>}</p>
<p>But silently redefining #defines across compilation units is evil, and to the extent that Joshua&#39;s approach can help expose it (unfortunately, not completely) &#8211; it is a strong reason to prefer it over LTCG.</p>
<p>But it is still a &quot;poor man&quot; palliative: the real thing allows working with static libraries, which is essential for large and/or distributed projects.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129993">
				<div id="div-comment-1129993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Quinlan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1129993">
			June 8, 2014 at 7:46 am</a>		</div>

		<p>IBM used PL/S (<a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/IBM_PL/S">en.wikipedia.org/&#8230;/S</a>) not PL/I for is systems level programming.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1130003">
				<div id="div-comment-1130003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130003">
			June 8, 2014 at 12:08 pm</a>		</div>

		<p>@Alex Cohn:</p>
<p>I don&#39;t think C/C++ allows that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130013">
				<div id="div-comment-1130013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130013">
			June 8, 2014 at 3:00 pm</a>		</div>

		<p>It would have if he did namespace { instead of {.</p>
<p>I agree cross-defined macros are evil.</p>
<div class="post">[<em>I just tried it. &quot;Unresolved symbol _main&quot; because main is now in an anonymous namespace. Also, nobody in main.cpp would be able to call any function in frame.cpp. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130033">
				<div id="div-comment-1130033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130033">
			June 8, 2014 at 3:39 pm</a>		</div>

		<p>One question: if I have modules written in different languages, will LTCG make cross-modular optimization possible?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130073">
				<div id="div-comment-1130073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">icabod</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130073">
			June 9, 2014 at 5:22 am</a>		</div>

		<p>On a large project, I often make small, single-file changes. &nbsp;LTCG would re-compile that one file and link it in. &nbsp;Using the &quot;#include everything into one unit&quot; approach would be slooooow, to the point where an actual time-machine would be quite handy.</p>
<p>Pre-emptive something: I&#39;ve had to do single-file changes on Release builds too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130083">
				<div id="div-comment-1130083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">icabod</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130083">
			June 9, 2014 at 6:10 am</a>		</div>

		<p>Regarding the evilness of &quot;redefining #defines across compilation units&quot;, ordinarily I would agree, but in the case of macros such as NDEBUG, it&#39;s written in the C++ standard how it should be used. &nbsp;This means defining it in one unit would have an unintentional knock-on effect when using the single-unit approach&#8230; unless you remember to #undef, which I would argue the use of is even eviller (!?).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130093">
				<div id="div-comment-1130093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130093">
			June 9, 2014 at 7:16 am</a>		</div>

		<p>Agreed that changing #defines across files is evil, it is nonetheless done. &nbsp;You still don&#39;t want #defines that are created in the .c or .cpp file (even if #defines are evil in C++, they still are used) to outlive that .cpp file. &nbsp; What if some .cpp file did a #define Test(a) ASSERT(a != 0), but some other cpp file had bool Test(int const &amp;x); &nbsp;Bad practice? &nbsp;Yes. &nbsp;But something that the compiler team has to deal with as it is valid C++. </p>
<p>More problematic are different compile options. &nbsp;What if I have one file that needs to be compiled with /clr? &nbsp;What if there are a few evil legacy files that still need /EHca?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130103">
				<div id="div-comment-1130103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130103">
			June 9, 2014 at 7:33 am</a>		</div>

		<p>@Joshua: &quot;It would have if he did namespace { instead of {.&quot;</p>
<p>It wouldn&#39;t be illegal C++ on its face, but it also doesn&#39;t solve the problem: you still can&#39;t repeat definitions of entities in the same file even if they are in different namespace{&#8230;} blocks. Nor does it help at all with C.</p>
<p>@Alex Cohn: &quot;But silently redefining #defines across compilation units is evil&quot;</p>
<p>Sometimes files have &quot;local&quot; macro definitions, because you want to use them for one specific purpose. I&#39;d say it&#39;s not just fine but even BETTER to define those at the point of use rather than globally across projects. And while I&#39;d prefer to see an #undef of them after, if you&#39;re near enough the bottom of the compilation unit, it&#39;s also pretty reasonable to omit the #undef.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130163">
				<div id="div-comment-1130163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130163">
			June 9, 2014 at 10:42 am</a>		</div>

		<p>@Evan: I never noticed any of these as I by habit keep local names unique.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130183">
				<div id="div-comment-1130183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rick C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130183">
			June 9, 2014 at 11:14 am</a>		</div>

		<p>&quot;Also, nobody in main.cpp would be able to call any function in frame.cpp.&quot;</p>
<p>To be fair, that specific issue is trivially fixable.</p>
<div class="post">[<em>You would have to find everything with external linkage and declare it outside the anonymous namespace. Whether this is trivial or not depends on how fancy your tools are. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130193">
				<div id="div-comment-1130193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130193">
			June 9, 2014 at 2:19 pm</a>		</div>

		<p>@Joshua: &quot;I never noticed any of these as I by habit keep local names unique.&quot;</p>
<p>Why would you put in the effort to even think about it? IMO 80% of the benefit of keeping names local is so that you don&#39;t have to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130233">
				<div id="div-comment-1130233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130233">
			June 10, 2014 at 7:04 am</a>		</div>

		<p>@Evan: If they&#39;re not unique they&#39;re harder to access via debugger.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130263">
				<div id="div-comment-1130263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130263">
			June 10, 2014 at 7:28 am</a>		</div>

		<p>@ Mr. Quinlan </p>
<p>You are correct that PL/I was an application language and that PL/S was the systems language. &nbsp;All of the shops I worked at used the term PL/I for all flavors of PL/*. &nbsp;</p>
<p>Contrary to popular belief, it was possible to get the PL/S compiler. &nbsp;A place I worked at needed to modify the OS so we could bring up a very early ATM system that went on to dominate the market in the Midwest. &nbsp;</p>
<p>The original OS/360 had a lot of PL/I (F compiler) code in it for things that did not have to deal with registers and the like. &nbsp;Later, that code was migrated to PL/S by IBM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130733">
				<div id="div-comment-1130733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130733">
			June 12, 2014 at 6:22 pm</a>		</div>

		<p>OK the anonymous namespace thing doesn&#39;t really work too well if the object is to be able to build the same code either way. It has something to do with being declared in one anon namespace and called in another.</p>
<p>I have a working scheme using named namespaces but it depends on specific project order.</p>
<p>It&#39;s probably easier to fix conflicting names via preprocessor. This isn&#39;t as hard SD it sounds as you can find all of them on the first pass if your error count limit is high enough. They raise duplicate definition error.</p>
<div class="post">[<em>So the way you compile your project is to compile it once to find all the name conflicts, then preprocess the source to rename the conflicts, then compile it a second time. I wonder if at this point 640k would admit that maybe this is better-fixed in the toolchain. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130773">
				<div id="div-comment-1130773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sven P</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140606-00/?p=793#comment-1130773">
			June 12, 2014 at 11:32 pm</a>		</div>

		<p>Instead of #include&#39;ing all C(++) files immediately, why not include their preprocessed versions?</p>
<p>This solves the changing #defines across files and all other kinds of preprocessor related problems.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>