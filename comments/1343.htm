<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1116733">
				<div id="div-comment-1116733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116733">
			April 2, 2014 at 7:06 am</a>		</div>

		<p>I&#39;ve seen these turn into exploitable DOS before so I&#39;m not inclined to knock it without knowing the API call.</p>
<p>Kind of like dividing the largest negative integer by -1. You don&#39;t think about it but the DOS guy did. Something like 50 DOS exploits that day.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116753">
				<div id="div-comment-1116753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116753">
			April 2, 2014 at 8:15 am</a>		</div>

		<p>@Mark: There&#39;s something about NULL and marshaling that has odd behavior. I&#39;ve seen cases where bad NULL could happen where bad non-NULL was excluded.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116763">
				<div id="div-comment-1116763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jason</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116763">
			April 2, 2014 at 8:22 am</a>		</div>

		<p>@Joshua: Have an example? &nbsp;And what does it have to do with marshaling? &nbsp;Does it only happen through COM or .net?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116783">
				<div id="div-comment-1116783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dominic</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116783">
			April 2, 2014 at 9:50 am</a>		</div>

		<p>This doesn&#39;t &quot;turn into a DoS&quot; no matter how many times the attacking code crashes. It&#39;s only a DoS if it corrupts system state such that the function call starts failing in well-behaved code.</p>
<p>And it&#39;s the responsibility of the reporter to make that link.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116793">
				<div id="div-comment-1116793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116793">
			April 2, 2014 at 10:12 am</a>		</div>

		<p>@Jason: It had something to do with SOAP marshaling. A bad SOAP request managed to pass NULL for a string where non-NULL was required; causing a NULL pointer deference when passed to the lower layer (the contents of the string had no interesting security consequences if you assume the right to edit data is the right to corrupt data). Had that not been wrapped in an exception handler, we would have lost the worker process along with all pending requests.</p>
<div class="post">[<em>But that was a crash at a different security level. The attacker is on the network, and the crash is in the worker process. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116743">
				<div id="div-comment-1116743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116743">
			April 2, 2014 at 7:54 am</a>		</div>

		<p>Joshua &#8211; those sort of issues may be exploitable if the code being run is the target of the privilege elevation. However, if someone made these API calls without first sanitising the data to check for null parameters, that&#39;s *their* bug. There&#39;s no way the code that makes the API call is elevating its privilege, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1116813">
				<div id="div-comment-1116813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116813">
			April 2, 2014 at 3:41 pm</a>		</div>

		<p>Try putting your hand on the last sentence (which only serves to make that person as overreacting) and read the whole thing again: With that sentence out of the way, my stance would be that am going to need more context to judge whether his concern was justified, or your dismissal.</p>
<p>Although the posts in this blog do not disclose the identity of the people but they still read like personal attacks, not like argument on problems. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116833">
				<div id="div-comment-1116833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116833">
			April 2, 2014 at 4:38 pm</a>		</div>

		<p>[XYZ(blah blah, DWORD *p, blah blah)]</p>
<p>I am actually claiming there is an inability to say DOS or no without knowing what XYZ is. I believe this relates to elevated COM servers.</p>
<div class="post">[<em>XYZ runs in-context, as evidenced by the fact that the access violation occurs in the same process that issued the rogue call. Let&#39;s say it&#39;s Heap&shy;Query&shy;Information. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116843">
				<div id="div-comment-1116843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116843">
			April 2, 2014 at 5:55 pm</a>		</div>

		<p>On the other hand, it IS a contractual violation if the parameter was listed as __in_opt rather than __in, because if you declare a parameter as __in_opt you are declaring to the world that callers of your function don&#39;t need to worry about passing you NULL; it has other valid meaning within the context of the function.</p>
<p>It&#39;s not quite a security bug, but it can have security consequences because the violation here means that static analysis tools will tell you that everything&#39;s OK when it&#39;s not, because the annotation is a lie.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-1116853">
				<div id="div-comment-1116853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116853">
			April 2, 2014 at 6:44 pm</a>		</div>

		<p>@Matt: maybe. For example, you might have a Foo(DWORD flags, in_opt LPCWSTR sid) where the sid parameter is formally optional, but a close reading of the contract states that sid becomes mandatory if the FOO_CUSTOM_SID flag is set.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116863">
				<div id="div-comment-1116863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116863">
			April 2, 2014 at 8:14 pm</a>		</div>

		<p>The semantic contract would hold then, sure, and the function is entirely at its liberty in such a case to fail to do the requested operation. But it shouldn&#39;t crash.</p>
<p>Here&#39;s why:</p>
<p>If you declare a parameter as __in_opt and the function is exposed directly or close to a security boundary, you MUST ensure that every path through the function can cope (i.e. avoid crashing) if a NULL is passed to that function in that parameter. The alternative is that an attacker may be able to coerce a caller into passing NULL instead of a valid DWORD* by controlling values sent over the security boundary. Despite Raymond&#39;s protestations, it&#39;s usually quite easy for an attacker to supply data-or-null to a function over a security boundary. In contrast, it&#39;s usually very hard to supply an invalid-non-null pointer over a security boundary.</p>
<p>A case in point is DCOM. Attackers can pass in any value they wish on the low-side of the security boundary and this gets wrapped in an interface for the high-side so that calls through the interface get marshalled back to the low-side for the low-side&#39;s implementation of that function to run. Now, if the high-side of the security boundary declares the parameter to be __in, an attacker passing NULL will be rejected by the DCOM layer before it hits the high-side code. All non-null values (valid and invalid) are converted to DCOM interfaces that are valid on the high-side and translate to invokes on the low-side. An attacker who sends a bad (non-null) pointer therefore only gets to crash his own process when the invoke comes back.</p>
<p>The salient point here is that if we had instead defined our high-side interface to be __in_OPT, the DCOM magic will translate NULLs on the low-side to NULLs on the high-side (and everything else is wrapped). If there is a path through the high-side that crashes if you pass it a NULL, even if that&#39;s semantically against the contract, that&#39;s a DOS across a security boundary.</p>
<p>So the TL;DR here is that it&#39;s normally much easier for an attacker to supply NULLs to a function than to supply invalid-non-NULLs, and if your function declares its parameters to allow __in_opts you should always handle the possibility of a NULL because tools and security layers rely on annotations. Your documentation might say that&#39;s against the contract, but attackers don&#39;t care what your documentation says if they can hit your function over a security boundary. They care about how your function actually behaves in response to their input.</p>
<p>So if Raymond is correct, and the function was HeapQueryInformation, and it crashes when you pass a NULL parameter for the first argument; that&#39;s a bug in HeapQueryInformation. It&#39;s either an annotation error or an invalidly validated parameter. But if they report was that the THIRD parameter was NULL, then it&#39;s a bug in whoever is calling HeapQueryInformation, since that parameter is marked __OUT and anyone who calls it with a NULL (or potentially-NULL) argument is in breach of contract.</p>
<div class="post">[<em>You&#39;re confusing &quot;shouldn&#39;t crash&quot; with &quot;is a security vulnerability.&quot; The crash (that arguably shouldn&#39;t have occurred) is at the same security level as the attacker. Therefore, the attacker gained nothing. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116803">
				<div id="div-comment-1116803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116803">
			April 2, 2014 at 1:20 pm</a>		</div>

		<p>[But that was a crash at a different security level. The attacker is on the network, and the crash is in the worker process. -Raymond]</p>
<p>True. As you recall I started out with &quot;not knowing the API call.&quot;</p>
<p>I also agree with Dominic about the reporter needs to make the link.</p>
<div class="post">[<em>It&#39;s like this: Given the function XYZ(blah blah, DWORD *p, blah blah) { blah blah; *p = value; blah blah; }, I call it as XYZ(nullptr) and it crashes! DoS! -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1116873">
				<div id="div-comment-1116873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116873">
			April 2, 2014 at 9:12 pm</a>		</div>

		<p>If the security boundary is an RPC interface, the attacker can invoke the RPC interface directly and pass whatever parameters they like. So marshalling in the client process can make life easy (or difficult) for well-meaning clients, but will not hamper a determined attacker.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116883">
				<div id="div-comment-1116883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116883">
			April 2, 2014 at 10:01 pm</a>		</div>

		<p>Haha, I call those &quot;my code crashed, it&#39;s YOUR problem&quot;. Happens all the time in collaboration (sic!) with other people.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116893">
				<div id="div-comment-1116893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116893">
			April 3, 2014 at 2:01 am</a>		</div>

		<p>I once reported a Sql injection vulnerability to a vendor and my example culminated in &quot;DROP DATABASE FOOBAR&quot;. To which the vendor replied, &quot;Because other people are logged on, the database won&#39;t be dropped, therefore it&#39;s not a security issue.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116913">
				<div id="div-comment-1116913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116913">
			April 3, 2014 at 6:01 am</a>		</div>

		<p>[You&#39;re confusing &quot;shouldn&#39;t crash&quot; with &quot;is a security vulnerability.&quot; The crash (that arguably shouldn&#39;t have occurred) is at the same security level as the attacker. Therefore, the attacker gained nothing. -Raymond]</p>
<p>About bloody time!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-davebacher even thread-even depth-1" id="comment-1116923">
				<div id="div-comment-1116923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116923">
			April 3, 2014 at 6:59 am</a>		</div>

		<p>Even if Microsoft prevents the crash, all they can do is return an error code.</p>
<p>Microsoft can catch this error and set a return code. &nbsp;That is of limited value, because the calling code still has to check that return value. &nbsp;And so if you look at the cases that are likely to make a pointer null just some of the time, it&#39;s pretty clear its not checking return codes as it stands. &nbsp;Therefore there&#39;s not a lot Microsoft can do here to make the call not fail.</p>
<p><!-- p>Side note: Thank whoever convinced Microsoft to bring back the start menu in update 1. &nbsp;
</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116963">
				<div id="div-comment-1116963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1116963">
			April 3, 2014 at 7:37 am</a>		</div>

		<p>And indeed HeapQueryInformation is not such a function where this could be turned into a DOS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117073">
				<div id="div-comment-1117073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117073">
			April 3, 2014 at 10:59 am</a>		</div>

		<p>ITT: &quot;Security&quot; minded folk.</p>
<p>I&#39;ve seen this from time to time at work, &quot;No way it could have been my code, it must have been sabotaged from above! Micro$oft lololol&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117083">
				<div id="div-comment-1117083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117083">
			April 3, 2014 at 11:21 am</a>		</div>

		<p>@Matt (long comment): you made several logical mistakes. You said that in the low-end parameter is in-opt, but that it is in on the high side. That&#39;s a case of a broken interface, so it does not count, and is not the case here anyhow. You also tried to involve a different security context, which is not the case either. The situation is very simple, much simpler than your analysis: it&#39;s a C interface, parameter is &quot;out&quot;, or &quot;in-out&quot;, but non-optional, and the caller broke that. It deserves to be punished. As Raymond would say, &quot;the alternative is worse&quot;: because C has no pass-by-ref, people use pointers all the time. Checking all those pointers and returning &quot;invalid parameter&quot; all the time has a maintenance and runtime cost we should rather avoid.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117143">
				<div id="div-comment-1117143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt [Visual C++ MVP]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117143">
			April 3, 2014 at 12:45 pm</a>		</div>

		<p>I feel like several commenters are discussing the WriteFile API:</p>
<p>lpNumberOfBytesWritten [out, optional]</p>
<p> &nbsp; &nbsp;A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter. WriteFile sets this value to zero before doing any work or error checking. Use NULL for this parameter if this is an asynchronous operation to avoid potentially erroneous results.</p>
<p> &nbsp; &nbsp;This parameter can be NULL only when the lpOverlapped parameter is not NULL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117153">
				<div id="div-comment-1117153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117153">
			April 3, 2014 at 3:13 pm</a>		</div>

		<p>There seems to be an inconsistency within Microsoft, because the security team seems to consider kernel code execution bugs that require Administrator access to be cases of being on the same side of the airtight hatchway, but the kernel and DRM teams do not, because they rely on driver signing and Secure Boot for &quot;security&quot;.</p>
<div class="post">[<em>They are different problems. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117163">
				<div id="div-comment-1117163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117163">
			April 3, 2014 at 6:22 pm</a>		</div>

		<p>OK.</p>
<p>@Maurits: No, if it&#39;s RPC, you can pass any parameter, but you can&#39;t pass invalid pointers (or rather, if you do, they cause the low side to crash, so don&#39;t buy the attacker anything). </p>
<p>@Goran: A security boundary by definition has two sides; a low-side and a high-side (and a marshaling interface between them). Over RPC an __in_opt parameter in an interface will marshal NULLs on the low-side to NULLs on the high-side, but if the interface is __in, it will fail to marshal the parameter. That is a different issue to static analysis. </p>
<p>In static analysis is a little different: passing a potentially null value to a definitely-not-null (__in) parameter is a potential-bug, but passing a potentially-null value to a potentially-null (__in_opt) parameter is not. Consequently if I run driver-verifier over my Windows 7 driver and it says &quot;Aha! You are passing that potentially-null variable into a function that Windows has declared to be __in, you have a bug&quot;, I should fix it. But if Windows declared that function as __in_opt, it won&#39;t. And if Windows declared it to be __in_opt and then crashes when my potentially-null value that I got from the user or network turns out to be /actually/ NULL, well, then my Windows7 driver has just exposed a massive local kernel EoP or remote DoS to the caller.</p>
<p>@Raymond: No, I&#39;m saying &quot;shouldn&#39;t crash OVER an interface you&#39;ve asserted is safe for those parameters&quot;. </p>
<p>Whilst NULL-dereferences are rarely major security bugs (except local kernel EoPs &lt;= Windows7), I&#39;ve seen critical security patches for bugs in IE where a Pinvoke in an Xbap looked safe in code, but under the Pinvoke is an integer overflow leading to a heap overflow.</p>
<p>Now, I&#39;m sure the authors of that API would have swore blind it&#39;s &quot;not over a security boundary&quot;, and at the time it wasn&#39;t. But it is now. Now it&#39;s stealing people&#39;s credit cards in IE and Firefox because there&#39;s a heap overflow accessible from the Internet.</p>
<p>Too many credit cards have been lost to people taking the attitude of dismissing functions that fail to uphold their own contractual violations as &quot;not a bug worth fixing&quot; and waiting until someone eventually exposes it over a security boundary (how many &quot;not a security boundary&quot; bugs were &quot;won&#39;t fixed&quot; in DirectX right up until WebGL and Miracast? How many &quot;not a security bug&quot;s were in the C/C++ compiler before they put it on the Internet as a service in Roslyn?).</p>
<p>Sending data in breach of a contract is undefined behavior. It&#39;s a bug. You should fix it. And if it&#39;s not a security bug now, it will be when you, your collegaues or your successors decide that exposing it to the Internet in future.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117203">
				<div id="div-comment-1117203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117203">
			April 4, 2014 at 2:55 am</a>		</div>

		<p>@Matt: Wait-wait-wait. Let&#39;s take that C/C++ compiler example. If its run under one user account, it can&#39;t do anything to meddle with others, unless there is an elevation bug&#8230; but that&#39;s not the bug inside the compiler, right?</p>
<p>And anything that takes input from a web-server better be run under a user who has absolutely minimum permissions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117213">
				<div id="div-comment-1117213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117213">
			April 4, 2014 at 5:28 am</a>		</div>

		<p>In the beginning the universe was created. This has made a lot of people angry and been widely regarded as a bad move.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117273">
				<div id="div-comment-1117273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117273">
			April 4, 2014 at 7:25 am</a>		</div>

		<p>@Joker_vD: What if the compiler is warning you that an object (like, maybe the result of an allocation by ExAllocatePoolWithTag) is being passed to a function that might dereference it because the parameter is marked as __in, instead of __in_opt? That&#39;s a bug.</p>
<p>And in Windows7, if a remote attacker or a local user-mode caller can arrange for that function to be called, that&#39;s either a local elevation issue or a remote denial of service vulnerability. The attacker just calls the function in a loop until eventually the bug triggers. Then the attacker has triggered a NULL dereference in the kernel from outside of the kernel, and can use that to take control of the kernel locally (by mapping the zero page) or to blue-screen a computer remotely if the function is exposed over a network.</p>
<p>And I didn&#39;t say &quot;web server&quot;. I said over a network. Think more along the lines of RDP, SMB and RPC than HTTP, although even there there is a bunch of parsing going on in TCPIP.sys and HTTP.sys.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117323">
				<div id="div-comment-1117323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117323">
			April 4, 2014 at 7:45 am</a>		</div>

		<p>@Matt: &quot;What if the compiler is warning you that an object (like, maybe the result of an allocation by ExAllocatePoolWithTag) is being passed to a function that might dereference it because the parameter is marked as __in, instead of __in_opt? That&#39;s a bug.&quot;</p>
<p>Are you saying its Microsoft&#39;s responsibility to fix developer&#39;s bugs? The compiler did its job and said &quot;Hey bro, this might be a problem&quot;.</p>
<p>The first person to invent a compiler that fixes programmers bugs will be heralded as a God amongst men and responsible for the termination of several (if not all) programmers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117343">
				<div id="div-comment-1117343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117343">
			April 4, 2014 at 7:53 am</a>		</div>

		<p>Matt: You don&#39;t have to worry about Roslyn. It&#39;s a C# and VB compiler, not a C/C++ compiler. While the pre-Roslyn C# compiler was written in C++, and thus potentially subject to buffer overflows, Roslyn is a complete rewrite in C#.</p>
<p>Regardless, they didn&#39;t put it on the Internet as a service. Well, they put it up on Codeplex as a service to mankind, but not as a web service. When they call it &quot;compiler as a service&quot;, that means you can invoke individual parts of it as a library (while previously you could just invoke the whole thing as a separate process). It does not mean some sort of cloud-based remote compilation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117373">
				<div id="div-comment-1117373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117373">
			April 4, 2014 at 10:41 am</a>		</div>

		<p>@Gabe: OK, it&#39;s not called Roslyn, but Microsoft does have a cloud-provided compiler: It takes attacker-provided code and then compiles it using the old C++ compiler into native ARM code for the Windows8 AppStore, so the point still stands. Also your point about C# not having buffer overflows makes some rather large assumptions that the JIT, GC and Pinvokes are all using platform APIs that adhere to their C/C++ contracts and not exposing buffer overflows when certain parameters (like a long string) are passed to them.</p>
<p>@John: If the developer works at Microsoft and just compiled a bug that allows an attacker running in low-integrity IE to run Ring0 kernel-mode code in Windows, then yes, that&#39;s Microsoft&#39;s problem. </p>
<p>Fixing annotations and adhering to contracts doesn&#39;t magically fix all security problems, but that&#39;s a strawman argument like saying giving our troops in theater bullet-proof vests doesn&#39;t stop the Taliban from shooting their legs and hence not worth investing in at all.</p>
<p>Adding and correctly implementing annotations via code-contracts allows tools developed by Microsoft and elsewhere to reliably find actual vulnerabilities that steal credit cards and destroy computers remotely with low false-positive rates, but if your code doesn&#39;t adhere to your contract, real bugs go undetected by such tools until it&#39;s too late.</p>
<p>If your function declares an __in_opt parameter and crashes when you pass it a NULL, change the contract, or change the code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117403">
				<div id="div-comment-1117403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117403">
			April 4, 2014 at 11:08 am</a>		</div>

		<p>@Matt: &nbsp;Why are you speculating and arguing about all these random tangents? &nbsp;Driver verifier? &nbsp;Web services? &nbsp;Marshalling into separate processes on computers halfway around the world? &nbsp;Raymond said, for the purpose of this discussion, that the function in question could be HeapQueryInformation, and that the call was in-process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117443">
				<div id="div-comment-1117443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117443">
			April 4, 2014 at 12:24 pm</a>		</div>

		<p>@Matt, etc.</p>
<p>The GNU guys declared the heap buffer overflow in bash to be a security bug. Gee, I wonder why.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117503">
				<div id="div-comment-1117503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117503">
			April 4, 2014 at 1:50 pm</a>		</div>

		<p>@ChrisR: Because HeapQueryInformation is a public interface, not a program, and besides, I&#39;m more disturbed by the cavalier &quot;code that violates code-contracts is OK so long as its not explicitly exposed over a security boundary&quot; notion.</p>
<p>Public APIs _are_ a security boundary. Look at this CVE (<a rel="nofollow" target="_new" href="http://www.cvedetails.com/cve/CVE-2013-3195/">http://www.cvedetails.com/&#8230;/CVE-2013-3195</a>) rated 10.0 &#8211; the highest possible rating &#8211; because COMCTL.dll!DSA_InsertItem had a public API that ended up being exposed to anyone that rendered a RTF &#8211; including Internet Explorer (via Xbaps), Firefox (via Xbaps), Word (via crafted Word files), ASP.NET via the RichEditControl and so on.</p>
<p>If HeapQueryInformation is stating that it contractually handles NULLs in a parameter and it doesn&#39;t, that&#39;s a bug, and it should be fixed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117523">
				<div id="div-comment-1117523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117523">
			April 4, 2014 at 2:17 pm</a>		</div>

		<p>@Matt: You are so far out in space and I don&#39;t feel like arguing with you. &nbsp;The referenced CVE has nothing to do with HeapQueryInformation. &nbsp;Nor is it a DoS attack against a server process via an access violation caused by some imagined contract violation in HeapQueryInformation. &nbsp;Of course the bug referenced by the CVE is a bad bug, but why are you arguing about things nobody else is talking about? &nbsp;Just to prove some point about how much you care about security? &nbsp;Go get your own blog please.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117533">
				<div id="div-comment-1117533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117533">
			April 4, 2014 at 3:14 pm</a>		</div>

		<p>@Chris: This post is about HeapQueryInformation, which defines a public interface which it fails to uphold &#8211; specifically it announces that it contractually succeed if passed any valid pointer to a SIZE_T or NULL, and fails if you pass it a NULL.</p>
<p>If it is ever exposed over a security boundary &#8211; say an RPC boundary &#8211; that is a security bug. And in the meantime, it&#39;s just a bug that makes static analysis tools ignore real bugs (false negatives) and report false bugs (false positives), which has real security implications on your codebase.</p>
<p>If you disagree, please tell me your company so I can avoid using your software, because probably 90% of actual security vulnerabilities are caused by API violations that were originally not over a security boundary and became a critical security bug when someone later put it over a security boundary.</p>
<p>That is all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117543">
				<div id="div-comment-1117543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117543">
			April 4, 2014 at 3:39 pm</a>		</div>

		<p>@Matt: Indeed it is about HeapQueryInformation; I&#39;m glad you finally understand that. &nbsp;The part you still don&#39;t get is that the bug reporter is talking about a local process AV, not a DoS via some RPC, so there is no security vulnerability in the bug report (as you state yourself).</p>
<p>I won&#39;t respond to your ad-hominem attacks against me or the company I work for, but thanks for playing!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1117423">
				<div id="div-comment-1117423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117423">
			April 4, 2014 at 12:10 pm</a>		</div>

		<p>Matt: dude, you&#39;re sounding a lot like Nicholas Lemonias here. You just said that it&#39;s Microsoft&#39;s problem if one of their developers compiles a bug. Yes, of course it is! But it has *nothing* to do with the problem described here, and there&#39;s no way that could make the problem described here a security bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1117633">
				<div id="div-comment-1117633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140402-00/?p=1343#comment-1117633">
			April 6, 2014 at 6:46 pm</a>		</div>

		<p>Nowhere in the original post does it say either that the last parameter is allowed to be null, or that the function is HeapQueryInformation. &nbsp;That function name only came up in a comment by later Raymond: &quot;Let&#39;s say it&#39;s Heap­Query­Information&quot;. &nbsp;That&#39;s just one possible function.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>