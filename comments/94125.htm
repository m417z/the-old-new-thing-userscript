<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (32)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1261315">
				<div id="div-comment-1261315" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">henke37</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261315">
			August 19, 2016 at 7:28 am</a>		</div>

		<p>The article summary is hilarious in how blunt it can be at times. &#8220;No&#8221;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1261325">
				<div id="div-comment-1261325" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pietro Gagliardi (andlabs)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261325">
			August 19, 2016 at 7:48 am</a>		</div>

		<p>I&#8217;ve read through the MSDN pages on SRW locks, but there&#8217;s still one thing I don&#8217;t know, and I&#8217;m not sure if I&#8217;m missing something elsewhere in the documentation or misread something: will the non-Try functions block until all holds of the other type release? For instance, if threads A and B call Acquire­SRW­Lock­Shared and thread C calls Acquire­SRW­Lock­Exclusive, will thread C be blocked until both thread A and B release their locks? And vice versa? My familiarity with RW locks in other languages tells me that this should be the case&#8230;</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1261335">
				<div id="div-comment-1261335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261335">
			August 19, 2016 at 8:08 am</a>		</div>

		<p>&#8220;When the lock has been acquired in exclusive mode, no other thread can access the shared resource until the writer releases the lock.&#8221; When thread C successfully gains exclusive access, threads A and B do not have access (which implies that they have left the lock). Though I can sort of see how this could be construed to say &#8220;Once you gain exclusive access, no *new* threads can access the resource (but existing threads with access still have access).&#8221; But if that were the case, then what would be the point of &#8220;exclusive&#8221; access?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1261355">
				<div id="div-comment-1261355" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pietro Gagliardi (andlabs)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261355">
			August 19, 2016 at 8:58 am</a>		</div>

		<p>Yeah, so I was misreading it, with a bit of not thinking as well =P Thanks.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1261345">
				<div id="div-comment-1261345" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rich</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261345">
			August 19, 2016 at 8:48 am</a>		</div>

		<p>MSDN has always been completely useless. Wouldn&#8217;t you at least have someone doing it capable of writing clearly and unambiguously?  I have high hopes that the new Stack Overflow Documentation project will render it redundant, and MS can pull the plug on the whole thing, rather than at present, where they just break all the links every few months.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1261365">
				<div id="div-comment-1261365" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261365">
			August 19, 2016 at 10:15 am</a>		</div>

		<p>&gt; MSDN has always been completely useless.</p>
<p>Not true, I find it way more descriptive and helpful than StackOverflow, &#8217;cause on MSDN people actually know what they are talking about.</p>
<p>A typical SO Question is : &#8220;how do I do this ?&#8221;. That&#8217;s fine, but the typical answer is : &#8220;Try this weird unrelated trick in order to do it ! It works on my end, dunno why lol&#8221;.</p>
<p>At times, MSDN is hard to read, but that&#8217;s because documenting everything clearly for everyone is hard, and always has been. Or perhaps the reader does not have the necessary informations / prior readings in his/her head.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1261385">
				<div id="div-comment-1261385" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pietro Gagliardi (andlabs)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261385">
			August 19, 2016 at 10:34 am</a>		</div>

		<p>I&#8217;d rather it not. SO Docs has a very different design and scope to MSDN, and its design does not satisfy every use case that&#8217;s needed. SO Docs is example-driven, with little in the way of introductory or expository material, and vaguely defined syntax or notes sections. Examples are great, and formal documentation is often sorely lacking in them, but they&#8217;re far from sufficient. The SO Docs design is great for some classes of documentation, but the people who want it to obsolete **all documentation ever** scare me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1261525">
				<div id="div-comment-1261525" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261525">
			August 19, 2016 at 4:35 pm</a>		</div>

		<p>Wow, you have high standards for something to escape being &#8220;useless&#8221;.  I&#8217;ve been using MSDN since the entire library was delivered to subscribers once a quarter on a single CD (when they went to 2 CDs, there were instructions on how to make the best of it, since CD players were expensive in those days.<br />
Yeah, MSDN documentation is written by humans, not all of whom have deep knowledge of every edge case of every call.  But, is it &#8220;useless&#8221; &#8211; I can&#8217;t imagine how you could call it that.  Even when something happens and the links get busticated, it&#8217;s usually not that hard to find what you are looking for using Google, Bing or some other search engine.<br />
And, it&#8217;s sooooo much better than what passed for docs before the .NET Framework shipped.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-tspeot-is even depth-2" id="comment-1261595">
				<div id="div-comment-1261595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ta.speot.is' rel='external nofollow' class='url'>ta.speot.is</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261595">
			August 21, 2016 at 3:30 am</a>		</div>

		<p>I have found the MSDN documentation to be quite comprehensive most of the time. In fact, one bug I was responsible for causing would have been avoided if I&#8217;d read &#8220;Remarks&#8221; for ShellExecute more closely. (ShellExecute will initialise COM if you haven&#8217;t already. So if you need a specific COM threading model you have initialise it before calling ShellExecute.)</p>
<p>Some documentation (like Remote Desktop Services Dynamic Virtual Channels) is extremely terse to the point of being almost unworkable.</p>
<p>Almost.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1261415">
				<div id="div-comment-1261415" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261415">
			August 19, 2016 at 11:17 am</a>		</div>

		<p>I wouldn&#8217;t assume a lock is recursive unless the documentation clearly said so&#8230; it seems like assuming a commuter car is amphibious and then complaining about the manual being unclear when you end up stuck in the lake.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-retep998 even thread-even depth-1 parent" id="comment-1261435">
				<div id="div-comment-1261435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Peter+Atashian' rel='external nofollow' class='url'>Peter Atashian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261435">
			August 19, 2016 at 1:21 pm</a>		</div>

		<p>Wait, am I seriously not allowed to call these recursively? Rust legitimately relies on being able to safely call any of the acquire methods at any time even if it is already acquired in the same thread. If it seriously results in memory unsafe undefined behavior then that is a huge deal.</p>
<p>According to a quick test, acquiring a shared lock when the thread already has a shared lock seems to simply work without issue. Meanwhile trying to acquire an exclusive lock when the thread has a shared lock or trying to acquire any lock when the thread has an exclusive lock will either deadlock or return WouldBlock depending on whether you used the Try versions or not.</p>
<p>So what you&#8217;re saying is that I cannot rely on this behavior at all and it is undefined behavior?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2 parent" id="comment-1261445">
				<div id="div-comment-1261445" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261445">
			August 19, 2016 at 1:30 pm</a>		</div>

		<p>The fact that they cannot be acquired recursively is what makes them slim! Attempting to acquire recursively results in undefined behavior. Mind you, std::shared_mutex has the same undefined behavior on recursive acquisition.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-retep998 even depth-3 parent" id="comment-1261455">
				<div id="div-comment-1261455" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Peter+Atashian' rel='external nofollow' class='url'>Peter Atashian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261455">
			August 19, 2016 at 1:48 pm</a>		</div>

		<p>Rust currently relies on them being memory safe. So if by undefined behavior you mean that memory unsafety can occur, this means Rust cannot rely on SRWLocks anymore and will have to change its implementation to something else, such as a custom implementation on top of NT Keyed Events. Are keyed events de facto stable at this point? Can Rust rely on their API continuing to exist in the future and not changing?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-4 parent" id="comment-1261475">
				<div id="div-comment-1261475" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261475">
			August 19, 2016 at 2:27 pm</a>		</div>

		<p>Not sure what you mean by &#8220;memory safe&#8221;; are we talking about memory barriers? The behavior is undefined. It might deadlock. It might succeed. It might (and probably will) cause the lock to fail to fulfil its contract in the future (e.g,. allow two simultaneous exclusive acquisitions). And since wait nodes are threaded on the stack, it can result in stack memory corruption. Keyed events are not documented and therefore come with no stability guarantee.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-retep998 even depth-5" id="comment-1261485">
				<div id="div-comment-1261485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Peter+Atashian' rel='external nofollow' class='url'>Peter Atashian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261485">
			August 19, 2016 at 2:46 pm</a>		</div>

		<p>Allowing simultaneous exclusive acquisitions and causing stack memory corruption are definitely unsafe by Rust&#8217;s definition, so Rust cannot use SRWLocks. And because keyed events have no stability guarantee this means that Rust cannot implement its own locks on top of them either. So basically Rust is screwed in this regard. Thanks Microsoft.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-5" id="comment-1261505">
				<div id="div-comment-1261505" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261505">
			August 19, 2016 at 2:57 pm</a>		</div>

		<p>Let me get this straight. You intentionally invoked undefined behavior, and now you&#8217;re upset that the undefined behavior isn&#8217;t undefined in the way that you like, and somehow that&#8217;s Microsoft&#8217;s fault.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-retep998 even depth-5" id="comment-1261515">
				<div id="div-comment-1261515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Peter+Atashian' rel='external nofollow' class='url'>Peter Atashian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261515">
			August 19, 2016 at 3:10 pm</a>		</div>

		<p>Nah, it is Rust&#8217;s fault for not reading the documentation fully enough and understanding all the consequences.</p>
<p>However, Rust does need to provide a safe RwLock that has safe behavior when attempting to lock it recursively, either deadlocking or returning an error, so it is Microsoft&#8217;s fault that we cannot use either keyed events or SRW Locks for it. So now we&#8217;re investigating what other options we have to implement RwLock safely.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-5" id="comment-1261535">
				<div id="div-comment-1261535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261535">
			August 19, 2016 at 5:33 pm</a>		</div>

		<p>Okay, so it&#8217;s Microsoft&#8217;s fault that it wrote a synchronization primitive that doesn&#8217;t exactly meets your needs. Gotcha.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-5" id="comment-1261585">
				<div id="div-comment-1261585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://harryjohnston.wordpress.com' rel='external nofollow' class='url'>Harry Johnston</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261585">
			August 20, 2016 at 8:48 pm</a>		</div>

		<p>Peter, why can&#8217;t you keep using SRW locks and just keep a separate (possibly thread-local) variable to tell you whether you&#8217;ve already acquired the lock or not?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1262155">
				<div id="div-comment-1262155" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy O'Neal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262155">
			August 24, 2016 at 12:40 pm</a>		</div>

		<p>@Peter: You can use SRWLock to do it, you just need something like struct { SRWLOCK lock; uint32_t owningThreadId; uint32_t recursionCount; };. Lock then becomes: if (owningThreadId == currentThreadId()) { ++recursionCount } else { AcquireSRWLockExclusive(lock); owningThreadId = currentThreadId(); recursionCount = 1; }. (The implementation I wrote for the next major version of the Visual C++ synchronization primitives (not necessarily the next version of Visual Studio) does this for std::recursive_mutex on Vista+)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-retep998 even depth-3 parent" id="comment-1261465">
				<div id="div-comment-1261465" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Peter+Atashian' rel='external nofollow' class='url'>Peter Atashian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261465">
			August 19, 2016 at 1:55 pm</a>		</div>

		<p>Also to clarify, Rust considers deadlocking to be safe. If undefined behavior merely means it might deadlock, then Rust is okay with that.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4 parent" id="comment-1261495">
				<div id="div-comment-1261495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pietro Gagliardi (andlabs)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261495">
			August 19, 2016 at 2:55 pm</a>		</div>

		<p>Are you sure SRWs and keyed events are your only options here? Windows has more synchronization objects than that&#8230;</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1261545">
				<div id="div-comment-1261545" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261545">
			August 19, 2016 at 7:17 pm</a>		</div>

		<p>&gt;Windows has more synchronization objects than that…</p>
<p>Exactly. Don&#8217;t blame Microsoft because someone apparently hasn&#8217;t heard of parts of the Windows API that have been around since the first version of Windows NT. &#8216;Fair&#8217; or &#8216;unfair&#8217; RW locks can be implemented as desired with other synchronisation objects.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zlynx odd alt depth-4" id="comment-1261615">
				<div id="div-comment-1261615" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zan+Lynx%27' rel='external nofollow' class='url'>Zan Lynx'</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261615">
			August 21, 2016 at 9:40 pm</a>		</div>

		<p>Ivan is right that you can implement your own RWLock. I&#8217;ve done it. It was _extremely_ slow.</p>
<p>Microsoft&#8217;s Mutex thing seems to be about 60x slower than a Linux futex. Could have done it faster with CriticalSections but I needed it to be inter-process. Tried the File Locking operations too, but they are no faster than Mutexes. Just sucked all around.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1261555">
				<div id="div-comment-1261555" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1261555">
			August 19, 2016 at 10:46 pm</a>		</div>

		<p>Wow, your car is sunk in a lake. Totally not your fault assuming all cars are boats&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-t_17_7 odd alt thread-odd thread-alt depth-1" id="comment-1262465">
				<div id="div-comment-1262465" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Tanzinul+Islam' rel='external nofollow' class='url'>Tanzinul Islam</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262465">
			August 29, 2016 at 4:15 am</a>		</div>

		<p>Maybe use &#8220;shall not&#8221; instead of &#8220;cannot&#8221;, with a link to <a href="https://www.ietf.org/rfc/rfc2119.txt" rel="nofollow">https://www.ietf.org/rfc/rfc2119.txt</a>?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1262666">
				<div id="div-comment-1262666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Gilbert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262666">
			August 30, 2016 at 11:01 am</a>		</div>

		<p>Hmm. Despite what the documentation says, is it in fact *possible* to design a SRW lock that a) uses exactly 1 pointer&#8217;s storage, no more, and b) behaves differently from a given starting state depending on which thread is making a request? As far as I can see, the documentation of the behaviour being undefined when e.g. recursively acquiring a read lock must be more butt-covering than warning of any specific misbehaviour. One might say that it&#8217;s keeping the door open for future changes in implementation, but unless those future changes expand the size of the lock&#8217;s state past the size of a single pointer, I don&#8217;t see a way for the behaviour to differ when a lock that is already acquired for read is acquired for read a second time, depending on whether it is the same thread or a different thread. There can be no concurrency concerns; a thread cannot be concurrent with itself. The lock is *already* safe with regard to concurrency between multiple threads, which is where the behaviour *is* defined. The more significant warning is that *because* the behaviour cannot differ depending on which thread is making the call, it isn&#8217;t possible for a thread to upgrade or downgrade its lock in-place &#8212; it must behave exactly as though the lock that it was trying to upgrade or downgrade was placed by any other thread in the process, which implies a deadlock.</p>
<p>I wonder whether Microsoft might be able to task someone to review the code more closely and determine conclusively whether it is safe to recursively acquire read locks &#8212; my *suspicion* is that it would require only a documentation change for that behaviour to be defined. :-)</p>
<p>(This is not an endorsement of assuming a specific variety of undefined behaviour under the current state of the documentation, mind you.)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2 parent" id="comment-1262675">
				<div id="div-comment-1262675" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262675">
			August 30, 2016 at 12:12 pm</a>		</div>

		<p>But said documentation change would encourage improper use of the object, wouldn&#8217;t it?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1262685">
				<div id="div-comment-1262685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Gilbert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262685">
			August 30, 2016 at 12:33 pm</a>		</div>

		<p>I don&#8217;t think so. If my theory is right, then the fact that it is improper to recursively acquire reader locks *is only part of the documentation*. If the underlying object is, in fact, perfectly capable of handling it, and a software engineer analyzes it closely and certifies that that is the case, then a documentation change that says that it is okay after all wouldn&#8217;t be breaking any rules. The allowable behaviour under the new documentation would be a strict superset of the old documentation, so any code that was following the old rules would also be following the new rules. Allowing recursive lock acquisition makes it much simpler to tie use of the lock to scopes in code, e.g. with a class that acquires the lock in the ctor and releases it in the dtor. Is there some philosophical reason why one should inherently not recursively acquire locks, or is it simply an implementation detail (or documentation detail) of this particular implementation?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-4 parent" id="comment-1262705">
				<div id="div-comment-1262705" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262705">
			August 30, 2016 at 5:33 pm</a>		</div>

		<p>Disallowing recursive acquisition is not an implementation detail, nor is it a documentation detail. it is a design detail. The lock was not designed to allow recursive acquisition, the code does nothing to explicitly support it, and recursive acquisition goes against the intended use of the lock. You seem to be arguing that the documentation should reflect the implementation, rather than the contract. I don&#8217;t see why it is incumbent upon the manufacturer of a screwdriver to document which types of nails it can be used to pound safely.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1262805">
				<div id="div-comment-1262805" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Gilbert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262805">
			August 31, 2016 at 9:49 am</a>		</div>

		<p>Sure, but the design is effectively another aspect of the documentation. The question is, is there anything gained by not speccing out recursive locks? If it turns out that the most straightforward implementation *does* handle them implicitly, then it isn&#8217;t out of the question to go back to the design and augment it. Of course, the majority of the time, adding a new requirement to the design means that significant new engineering work will need to be done, and new code needs to be written. In this case, though, *if my theory is right*, the current implementation already fully implements &#8212; correctly &#8212; the feature requirement for recursive locking. So, then the next question is, even though we might not need to do new engineering work or write new code, updating the design isn&#8217;t completely free; documentation would need to be changed, new automated tests written and verified and so on &#8212; is it worth this time and effort to support recursive locking? In my opinion, it *is* worth it. Explicitly supporting recursive locking allows for stronger, more reliable and more maintainable software development patterns to be used in code that uses this feature. It makes it a better feature, and it makes the code that uses the feature less likely to &#8220;do it wrong&#8221;. Fewer bugs is better for everyone. So, if the current implementation *already* provides the functionality, in my opinion the benefits outweigh the time and effort needed to update the contract and the documentation. I don&#8217;t expect my opinion to shift Microsoft&#8217;s priorities at this point, but I don&#8217;t think I&#8217;m wrong either. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-5" id="comment-1262815">
				<div id="div-comment-1262815" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160819-00/?p=94125#comment-1262815">
			August 31, 2016 at 9:58 am</a>		</div>

		<p>Determining whether the current implementation supports recursive acquisition would probably take a long time, seeing as it wasn&#8217;t designed in, and you would have to go back and redo all the correctness analysis. The code has likely not been modified in years, so the expertise is no longer in developer short-term memory; it&#8217;s in documents that need to be re-read and re-understood. And the original designers would likely argue that if your code does recursive acquisition, then it&#8217;s already doing it wrong, and we shouldn&#8217;t go around explicitly telling it&#8217;s people it&#8217;s okay to do something wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>