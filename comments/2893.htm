<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (44)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1083583">
				<div id="div-comment-1083583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083583">
			October 18, 2013 at 7:19 am</a>		</div>

		<p>What a LOVELY mess. The same thing can happen in the UNIX world. Not spawning processes from child threads seems to be the preferred solution. I&#39;ve seen radical solutions such as closing all handles &gt;2 in the child process.</p>
<p>Incidentally, I&#39;ll bet System.IO.Process.Start is vulnerable to this, and the .NET docs give absolutely no clue. At least my code will eventually terminate in that case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083593">
				<div id="div-comment-1083593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083593">
			October 18, 2013 at 7:30 am</a>		</div>

		<p>Handle inheritance is as dirty as fork is. In my opinion a historic accident. If resources are to be shared/passed that should be explicit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1083613">
				<div id="div-comment-1083613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083613">
			October 18, 2013 at 9:46 am</a>		</div>

		<p>&quot;If resources are to be shared/passed that should be explicit.&quot;</p>
<p>It was at least partially explicit, in that you had to both mark the handles as inheritable and pass the flag that says to inherit handles. &nbsp;It is now, or can be, completely explicit, as described in the post.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083623">
				<div id="div-comment-1083623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083623">
			October 18, 2013 at 9:52 am</a>		</div>

		<p>Neither handle inheritance nor fork are dirty tricks. But there&#39;s a huge impedance mismatch between the common use case and what they are actually good for.</p>
<p>That is the reason we have explicit handle inheritance and vfork.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hankhein even thread-even depth-1" id="comment-1083643">
				<div id="div-comment-1083643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Henri+Hein' rel='external nofollow' class='url'>Henri Hein</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083643">
			October 18, 2013 at 12:21 pm</a>		</div>

		<p>&quot;You&#39;d be surprised how big Web pages are nowadays.&quot;</p>
<p>No, I would not, but I agree that people whose job description does not involve taking them apart in order to troubleshoot how a product messed up something in one of them would. &nbsp;My jaw has seriously been in danger of dislocating while looking through sources of even some mainstream sites (domains elided to protect the innocent).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083653">
				<div id="div-comment-1083653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083653">
			October 18, 2013 at 1:14 pm</a>		</div>

		<p>Reading the vfork manpage I am disgusted by what hacks are in place in Linux. Starting a process seems to be a fork+exec call. Fork cloning the process, exec ripping everything out. I am at a complete loss why that would be a good model.</p>
<p>There might be historic reasons for that, but today this is just so awful. Unbearable hacks.</p>
<p>What about a simple CreateProcess call. Seems good to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083663">
				<div id="div-comment-1083663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083663">
			October 18, 2013 at 1:28 pm</a>		</div>

		<p>@xor88: vfork+exec implements CreateProcess easily. See spawn* family of calls. When the model changes again (like say the explicit handle inheritance), it is possible to fix as a library in userspace.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083673">
				<div id="div-comment-1083673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083673">
			October 18, 2013 at 1:40 pm</a>		</div>

		<p>Well, yeah: vfork was a hack to cover up an inability to implement fork sufficiently efficiently (BSD, I think); it is not surprising that vfork is ugly. &nbsp; I&#39;m no expert, but I think fork can be reasonably efficient with copy-on-write pages in your VM subsystem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083693">
				<div id="div-comment-1083693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083693">
			October 18, 2013 at 2:22 pm</a>		</div>

		<p>@xor88: Well, at least with fork+exec you can reasily detect the fact that the program failed to start because some shared libraries were missing (exec will return ENOENT). With CreateProcess? If you pass it the right flags, the error dialog &quot;DLL not found&quot; wasn&#39;t show up, and all you can do is to do Sleep/GetExitStatus.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083703">
				<div id="div-comment-1083703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083703">
			October 18, 2013 at 2:39 pm</a>		</div>

		<p>I&#39;m objecting to the notion that we want child processed to be filled with uncontrolled junk. This is not a basis for a dependable system. State separation is a fundamental tool that we use to make systems reliable.</p>
<p>You have no idea what fork will copy into the child because you do not know what the parent contains. In the presence of libraries and user code (e.g. Apache websites or shell extensions) you have no idea what resources are open, whether they can be used in the context of another process or whether they will leak by being memcpy&#39;d into the child. The child will now keep all memory pages and handle-referenced objects live. It will interfere with the same handles that the parent uses.</p>
<p>It is so bad that I&#39;m feeling the need to write down all these filthy thoughts so I can forget.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1083723">
				<div id="div-comment-1083723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083723">
			October 18, 2013 at 6:25 pm</a>		</div>

		<p>Hi. Normally, I do not stop by just to say &quot;your post was cool&quot; but since I am failing to resist making this comment, I&#39;d like to add something to it: This post is cool and what makes it coolest post today is the fact that it is the only blog post I read today that does not have &quot;Windows 8.1&quot; in its title.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083733">
				<div id="div-comment-1083733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083733">
			October 18, 2013 at 7:18 pm</a>		</div>

		<p>Reduction is time consuming, and that&#39;s exactly the reason for PAYING for support. If a ISV need to do this himself/herself, there&#39;s not very much use of expensive msdn support.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083743">
				<div id="div-comment-1083743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bdell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083743">
			October 18, 2013 at 8:53 pm</a>		</div>

		<p>So&#8230; what do you do if it was the other possibility?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083683">
				<div id="div-comment-1083683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083683">
			October 18, 2013 at 2:17 pm</a>		</div>

		<p>@xor88 CreateProcess takes 10 parameters with other variants taking more. &nbsp;There is a design decision here. &nbsp;A call that takes every parameter that could possibly be useful (plus -Ex versions in the future), or a call that does virtually nothing to setup the child, and in that child you then set whatever parameters matter before executing the intended binary. &nbsp;The former approach isn&#39;t future proof, but is a single call. &nbsp;The latter is very future proof but requires a little more cognitive overhead to code. &nbsp;It does however use the same system calls &#8211; eg setting cwd. &nbsp;The standard C library handles the simple cases anyway (exec*, spawn*).</p>
<p>Ultimately Windows and Unix took the approach that best matched their process semantics. &nbsp;Ultimately I think the Unix approach is better and simpler, but realistically Windows would never be able to do things that way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083753">
				<div id="div-comment-1083753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083753">
			October 18, 2013 at 9:35 pm</a>		</div>

		<p>@xor88: the child isn&#39;t filled with uncontrolled junk (unless your code contains uncontrolled junk). &nbsp;Importantly you can decide what to keep and what to close. &nbsp;You can change user ids and make security checks. &nbsp;You can set resource limits. &nbsp;The amount of things you can do vastly outnumbers the 10 parameters of CreateProcess.</p>
<p>It is true that in the olden days file descriptors could run rampant. &nbsp;However for many years you can open or set a close on exec flag for them so they are automatically not inherited by executed binaries.</p>
<p>The case of fork without exec is far less interesting since it is the same binary running.</p>
<div class="post">[<em>News flash: Your code contains uncontrolled junk. Maybe you use a library that uses a pipe to communicate with another process. You then fork and oops, you didn&#39;t close the pipe in the child process. Now the pipe handle is stuck open. Or maybe the library opens a database and then you fork and oops, you didn&#39;t dbm_close in the child process. Now the database is stuck open. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083773">
				<div id="div-comment-1083773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083773">
			October 19, 2013 at 4:02 am</a>		</div>

		<p>Old versions of the Unix C shell got very confused if you invoked them without all of their standard handles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083783">
				<div id="div-comment-1083783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083783">
			October 19, 2013 at 9:02 am</a>		</div>

		<p>Child configuring itself: So the child already knows all there is to know about what it should do? Is it psychic, or do you recompile it every time before executing?</p>
<p>Child kows whats superfluous: Dangerous thought, and makes optional additional resources quite a dangerous and unreliable idea. Also, you are sure the child is 100% reliable and trustworthy, if you do not trust the parent to get its thing right even if you designed and built it yourself?</p>
<p>CreateProcess is the pinnacle of achievement: Why is there CreateProcessAsUser, CreateProcessWithLogon, CreateProcessWithToken, and such an elaborate scheme for extending some of their parameters? All of this can be done with fork/exec.</p>
<p>Everything added is garbage: Nice that you chuck everything you cannot imagine on the garbage heap. Double points if we take the &quot;&quot;newer&quot;&quot; replacement for fork in Linux, clone, which only has about 10 years.</p>
<p>old Unix C shell: Well, that&#39;s a bit suboptimal, though happens even in windows. GIGO rules still.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083763">
				<div id="div-comment-1083763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083763">
			October 19, 2013 at 2:29 am</a>		</div>

		<p>@Roger any configuration you can make with the fork model you can make with the CreateProcess model as well. Just have the child configure itself. Only the child knows what preconditions it needs to have established to run correctly. If you want to spawn a calc.exe, the parent cannot decide which handles must be present and so on. Only the owner of calc.exe can do that reliably.</p>
<p>Some thing can be reliably configured by the parent such as priority and security. That&#39;s possible with CreateProcess as well. I do not spot a single thing that you cannot do with CreateProcess that you can with fork and *should* be doing with fork. Fork only supports more invalid use cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083793">
				<div id="div-comment-1083793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083793">
			October 19, 2013 at 3:33 pm</a>		</div>

		<p>&quot;reduction&quot;: Isn&#39;t that a normal meaning for informatic? Strength reduction, solving by reduction to a well-understood problem, reducing a problem to its essence?</p>
<div class="post">[<em>Yes, it&#39;s a perfectly normal name. Just remember to use that name instead of a synonym like &quot;simplification&quot; or &quot;minimization&quot;. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083813">
				<div id="div-comment-1083813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083813">
			October 20, 2013 at 11:13 am</a>		</div>

		<p>@Raymond: In the Unix world, if a library has a pipe it doesn&#39;t want duplicated, it should create it with O_CLOEXEC, in which case nobody has to explicitly close it. &nbsp;It&#39;s hardly libc&#39;s fault you&#39;re using a poorly-written library that doesn&#39;t do that.</p>
<div class="post">[<em>I suspect there are a lot of poorly-written libraries. Also, what if you are the library? How do you ensure that the app that is using your library is correctly managing CLOEXEC? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083823">
				<div id="div-comment-1083823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083823">
			October 20, 2013 at 5:28 pm</a>		</div>

		<p>@Kevin:</p>
<p>The problem is, badly written libraries are a fact of life. This also shows that there is a lot of uncontrolled junk in an application. Also, from what I read, Raymond wasn&#39;t bashing libc, he was mentioning that when you write a non trivial application that relies on components you don&#39;t control, then you are open to this kind of problem.</p>
<p>Another thing to remember, from things that I have read, O_CLOEXEC was added somewhere around 2.6.23, that is around the 2008 era. You are also assuming that people would know about this flag and are using it. From some of the communities that I hang around in, you see the whole uptime competitions going on, where people compete/show off their uptimes. These can go into years. There is also the issue that Linux kernel upgrades are non trivial at times. So it is possible that someone is using an outdated version because it works. Kind of like the people using outdated versions of Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083833">
				<div id="div-comment-1083833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vlad</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083833">
			October 20, 2013 at 5:50 pm</a>		</div>

		<p>I got exactly the same problem as that customer. Unfortunately processes in my application started and &quot;random&quot; times and it took me several months to find source of problem. </p>
<p>There are 2 sides of this problem:</p>
<p>1. You start new process and it inherits handles when another thread creates process</p>
<p>2. Another thread creating process and inherits your handles</p>
<p>And as I see PROC_THREAD_ATTRIBUTE_HANDLE_LIST fix only first problem. If you are using some plugins/library which creates process and unaware of PROC_THREAD_ATTRIBUTE_HANDLE_LIST you have exactly the same problem. So it only works when all parts of system uses it. Removing requirement that handle must have inherited attribute when using PROC_THREAD_ATTRIBUTE_HANDLE_LIST will fix all problems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083843">
				<div id="div-comment-1083843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jerome</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083843">
			October 20, 2013 at 11:59 pm</a>		</div>

		<p>@Joshua</p>
<p>I think you are right. I do just this in .Net in my own GUI that wraps ffmpeg for video conversions. (And hide the consoles while reading the redirected output for my dialogs progress bars. I have one dialog for each conversion.) Sometimes the dialogs hang inexplicably, and I had no idea what could be going wrong. This could be related&#8230; </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf odd alt thread-odd thread-alt depth-1" id="comment-1083863">
				<div id="div-comment-1083863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083863">
			October 21, 2013 at 4:59 am</a>		</div>

		<p>Vlad said my thoughts exactly: The function&#39;s requirement that handles still be marked inheritable means the problem stays present unless the whole code (that creates child processes with handle inheritance) uses the fix.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083873">
				<div id="div-comment-1083873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083873">
			October 21, 2013 at 6:14 am</a>		</div>

		<p>@ens</p>
<p>&#8211; If you have uncontrolled junk in your application, you&#39;ve already lost. GIGO applies for spawning too.</p>
<p>&#8211; On UNIX/Linux you have to control handles and priviliges for your child. IMHO that&#39;s easier done directly than with PROC_THREAD_ATTRIBUTE_HANDLE_LIST. You can customize the childs environment even more. Replacing (v)fork with clone gets you more isolation features, if you distrust your new process too.</p>
<p>&#8211; No overcomit neccessary unless you insist on fork and your parent has significantly more modifiable memory than your child needs. In that case use vfork/clone, like good libraries do. You must not stomp all over memory, but you only wanted to start a child anyway, right?</p>
<p>&#8211; BTW, if you distrust your child, you could replace fork/vfork with clone on Linux (no idea about other Unixes) and gain many more isolation features.</p>
<div class="post">[<em>Any application that supports plug-ins has uncontrolled junk. So you&#39;re saying that all those apps have already lost? Sounds like you are making an argument for &quot;No app in their right mind would support plug-ins.&quot; In which case, I&#39;m going to call you on it if you ever ask that a program add a plug-in feature. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1083883">
				<div id="div-comment-1083883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083883">
			October 21, 2013 at 7:13 am</a>		</div>

		<p>fork() is only marginally safe when your process is only running your own single thread. When you run multiple threads scheduled by kernel, which can be in different states (including inside the kernel), you cannot fork them safely.</p>
<p>If you have a global mutex, and one of the process&#39; threads owns that mutex, there is no way to fork it safely. Same for other kernel objects that should not be owned by multiple processes.</p>
<p>fork() IS A HORRIBLE OBSOLETE HACK.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083853">
				<div id="div-comment-1083853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ens</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083853">
			October 21, 2013 at 12:44 am</a>		</div>

		<p>There are some performance reasons for the fork/exec model. &nbsp;There are also cases where some operations have to be performed using information only the caller knows, but which must be provided early in the execution of the new process, and fork provides that.</p>
<p>There are a couple problems that fork has that make me prefer CreateProcess-like semantics the vast majority of the time:</p>
<p>1. &nbsp;The &quot;uncontrolled junk&quot; problem. &nbsp;If I&#39;m not vetting absolutely everything, it&#39;s a problem of unknown magnitude.</p>
<p>2. &nbsp;It makes overcommit almost necessary since you have to double your memory commitment on a fork(), even though copy-on-write means the memory is not actually duplicated most of the time. &nbsp;And overcommit means you need an OOM-killer, and OOM-killers are awful for robustness. &nbsp;There are a few legitimate use-cases for it outside of fork, notably short-lived VMs for web services (which is basically a higher-level &quot;fork&quot; that runs on almost arbitrary base OSes).</p>
<p>This said, with phones and tablets, automatically terminating background processes is becoming common even without overcommit, so the robustness battle might be lost anyway. &nbsp;But it irks the programmer in me that you can do everything right and get all the right promises and *still* crash in a situation that it is not called a bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083923">
				<div id="div-comment-1083923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083923">
			October 21, 2013 at 7:54 am</a>		</div>

		<p>@alegr1: Thanks for the shouting. Doesn&#39;t change anything though.</p>
<p>Fork() is completely safe even if you run multithreaded. It forks the process, duplicating only the executing thread, leaving everything else untouched. If your process was ok without fork, it is still ok with it. Nothing hackish in sight.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083933">
				<div id="div-comment-1083933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083933">
			October 21, 2013 at 8:38 am</a>		</div>

		<p>@Deduplicator: &quot;It forks the process, duplicating only the executing thread, leaving everything else untouched.&quot; That&#39;s only because on Linux threads are simulated with processes. So a 5-threaded process is actually 6 processes, and obviously the thread (which is actually a process) can fork only itself. But there are other Unices.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1083953">
				<div id="div-comment-1083953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083953">
			October 21, 2013 at 9:06 am</a>		</div>

		<p>@Deduplicator:</p>
<p>&gt;Fork() is completely safe even if you run multithreaded. It forks the process, duplicating only the executing thread, leaving everything else untouched. If your process was ok without fork, it is still ok with it. Nothing hackish in sight.</p>
<p>So it drops all other threads in the duplicated process? What if a dropped thread was holding a process-wide lock? What if the remaining thread depends on other threads? For what the duplicated process will be good anyway, other than immediately calling exec()?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083983">
				<div id="div-comment-1083983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1083983">
			October 21, 2013 at 9:19 am</a>		</div>

		<p>@Joker_vD: &quot;That&#39;s only because on Linux threads are simulated with processes.&quot;</p>
<p>Don&#39;t be ridiculous. &nbsp;Linux has had real pthreads for ages.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084003">
				<div id="div-comment-1084003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084003">
			October 21, 2013 at 9:58 am</a>		</div>

		<p>@Kevin: 8 years is not &quot;ages&quot;. Heck, it is just a year older than Vista.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084013">
				<div id="div-comment-1084013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084013">
			October 21, 2013 at 10:37 am</a>		</div>

		<p>@Raymond: Hopefully, the plugins even if crap are at least marginally well-behaved. Otherwise you cannot do anything reliably at all, spawning or forking notwithstanding. GIGO (you yourself advocated killing the process fast if basic program assumptions are violated, as far as i can recall. (DrWatson))</p>
<p>@Joker: Actually, it&#39;s one process (according to one definition) or five processes (according to another definition). That Thread-Ids are system-wide and threads are historically light-weight processes is neither here nor there.</p>
<p>@alegr1: If you fork, you obviously cannot do anything depending on the non-existing other threads making any headway. You are responsible for not depending on them to do so. Just as you are expected not to flush any buffers twice and trusted not to do anything else stupid. Only you can know if you can use the new process directly as is, or have to set up for calling exec.</p>
<p>What could a clone be useful for? Anything you could use threads for, with the added benefit of avoiding most synchronization overhead, conceptual and runtime.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084063">
				<div id="div-comment-1084063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084063">
			October 21, 2013 at 12:47 pm</a>		</div>

		<p>@alegrl1: The consequence is if you are multithreaded anywhere, then you can&#39;t allocate memory in the child process before exec(), which means there is no more a good reason to not use vfork() instead of fork.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084083">
				<div id="div-comment-1084083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084083">
			October 21, 2013 at 1:56 pm</a>		</div>

		<p>@Joshua @alegrl1: Even if the parent is multithreaded and you use fork(), you can allocate memory before exec(), just not with any userland mechanic already in use. So allocating some new pages is ok, and running your own allocator on them is as well. But what the hell are you still doing to set up your child process? All that number-crunching should already be done, to avoid needless complexity. And yes, so you might use vfork() as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084093">
				<div id="div-comment-1084093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084093">
			October 21, 2013 at 2:43 pm</a>		</div>

		<p>@Deduplicator: The general form of the handle reassignment logic requires MAX_HANDLES (historically 1024 on UNIX) short ints of space and must be executed in the child process. Please note nobody uses the constant in usermode anymore as it is changed by recompiling the kernel (server kernel has much bigger MAX_HANDLES). We can prove that substituting the largest handle referenced for MAX_HANDLES always works; however this means the allocation is no longer a constant. Unless coding in C99 or asm, this now means heap (C++ doesn&#39;t have C99&#39;s dynamic array on the stack.)</p>
<p>Before you start to think MAX_HANDLES is too small, remember that it&#39;s per process and only file and socket handles count. Mutex handles are the pointers to the mutexes in userspace heap, so they have unlimited numbers. Despite the fact that mutexes use userspace buffers, they do not crash the kernel if they get overwritten by garbage. Your program; however, might be killed by the kernel if you allow this.</p>
<p>As for leaked database connections, etc. There&#39;s an easy way to clean them up that requires allocating a buffer and calling the syscall version of readdir (the standard library opendir tries to call malloc) so that handles may be enumerated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084153">
				<div id="div-comment-1084153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084153">
			October 22, 2013 at 5:28 am</a>		</div>

		<p>@Joker_vD : Eight years is long enough ago to make the present tense incorrect. &nbsp;For example &quot;George Bush is President of the The United States&quot; is an incorrect statement, even though it was true 8 years ago.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084183">
				<div id="div-comment-1084183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084183">
			October 22, 2013 at 7:53 am</a>		</div>

		<p>@algre1 &#8211; if a dev forks from multithreaded code, I&#39;d hope they&#39;d have half a clue what they&#39;re doing. The threading library, pthreads has library calls to define how fork should be handled &#8211; see pthreads_atfork() for example (although not perfect, it&#39;s a starting point). Writing thread-safe code is always an interesting exercise in anything but simple cases. Handling fork() correctly is just another tax that should not be different from having to handle locks and other cross-thread communication correctly. Of course, I&#39;m sure someone will argue that pthread_atfork() itself is a hack to fix the hack that is fork, but I&#39;ll leave that to other people.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084193">
				<div id="div-comment-1084193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084193">
			October 22, 2013 at 7:54 am</a>		</div>

		<p>GWO: The problem is that saying &quot;Linux has had this feature for ages&quot; is almost like saying &quot;Windows has had this feature for ages&quot; where this feature was introduced in Vista. Whenever Raymond posts some code that uses an API that&#39;s been available since Vista, people complain that it isn&#39;t supported in XP.</p>
<p>Since most of my clients are still using XP (and have no definitive plans to upgrade), a feature that&#39;s been in Windows for ages (nearly 7 years) will be unavailable to me for another year of two. So in 2014 or 2015, when my last client has moved off of XP, they will be on Win7. At that point, I won&#39;t be able to use any APIs newer than 2009 (which will be 5 or 6 years old then).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1084203">
				<div id="div-comment-1084203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084203">
			October 22, 2013 at 9:02 am</a>		</div>

		<p>&gt;GWO: The problem is that saying &quot;Linux has had this feature for ages&quot; is almost like saying &quot;Windows has had this feature for ages&quot;</p>
<p>Then WIndows had real threads since the dynosaurs walked the Earth.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1084273">
				<div id="div-comment-1084273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bdell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084273">
			October 22, 2013 at 11:03 am</a>		</div>

		<p>Medinoc: If a lock is held at fork time, any invariants on the cloned state protected by the lock are probably broken, so it&#39;s dangerous to do anything with it (to you, not your parent). In multithreaded programs, it&#39;s mainly only safe to exec after forking (no printf, malloc, etc). I imagine anything specified to be async-signal-safe could be used safely, but I don&#39;t know for certain.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084283">
				<div id="div-comment-1084283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084283">
			October 22, 2013 at 12:16 pm</a>		</div>

		<p>@Medinoc: Only that calling thread is forked to prevent chaos. Thread Ids are global. The mutexes are jammed if owned by any other thread (consequence: you can release mutexes from the wrong thread&#8211;the system can&#39;t check).</p>
<p>Oh, and don&#39;t take Raymond&#39;s suggestion to call dbm_close() in the child. This will rollback any pending transaction in the parent (same reason you don&#39;t flush buffers).</p>
<p>@Bdell: Indeed, anything async-signal-safe is safe. Anything is safe in single-threaded programs provided you flush buffers first (what do you think fflushall() is for?). This is why library functions that spawn threads are clearly marked.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1084213">
				<div id="div-comment-1084213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084213">
			October 22, 2013 at 9:13 am</a>		</div>

		<p>Wait, *n*x mutexes are process-local objects, right? If so, I don&#39;t see the problem with forking even while a mutex is owned: Duplicate the whole process (ALL of its threads, not just the calling one) and you now have two processes with identical state. Each with its own mutex and the thread owning it.</p>
<p>However, one is to be more cautious for GLOBAL mutually exclusive resources (semaphores?), but I don&#39;t know *n*x enough.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1084353">
				<div id="div-comment-1084353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131018-00/?p=2893#comment-1084353">
			October 23, 2013 at 4:45 am</a>		</div>

		<p>And now after reading this discussion, I am now even more sure than before that threads is not the abstraction I wouls like to use in the daily multitask programming. Locks, mutexes, buffers and flushes, jeez. I don&#39;t even want to know these gory implementation details of task dispatching and message passing.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>