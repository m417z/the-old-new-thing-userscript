<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (73)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1134283">
				<div id="div-comment-1134283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134283">
			June 27, 2014 at 7:05 am</a>		</div>

		<p>&quot;Here be dragons&quot;? What happened to the nasal demons?</p>
<p><a rel="nofollow" target="_new" href="http://catb.org/jargon/html/N/nasal-demons.html">catb.org/&#8230;/nasal-demons.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134293">
				<div id="div-comment-1134293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">VinDuv</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134293">
			June 27, 2014 at 7:08 am</a>		</div>

		<p>[&#8230;] Therefore, the entire else branch can be treated as unreachable.² [&#8230;] Even if you claim that the compiler is not allowed to perform time travel,¹ [&#8230;]</p>
<p>I see what you did there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134313">
				<div id="div-comment-1134313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Liquorice</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134313">
			June 27, 2014 at 7:24 am</a>		</div>

		<p>What do we want? Undefined behavior! When do we want it? It&#39;s irrelevant.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134323">
				<div id="div-comment-1134323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134323">
			June 27, 2014 at 7:25 am</a>		</div>

		<p>Raymond: the C99 standard explicitly states: &quot;83) Thus, &amp;*E is equivalent to E (even if E is a null pointer)&quot; (6.5.3.3, page 89, not sure about C89 though)</p>
<p>I don&#39;t know where you got your knowledge?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134333">
				<div id="div-comment-1134333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134333">
			June 27, 2014 at 7:26 am</a>		</div>

		<p>The omit null check after deref annoys me if there&#39;s no option to turn it off as kerenl mode code might have to handle a null passed from user space to system call.</p>
<p>It&#39;s too late in general to unring that bell. Windows got lucky so few programs depended on it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134343">
				<div id="div-comment-1134343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134343">
			June 27, 2014 at 7:32 am</a>		</div>

		<p>I think I read somewhere though that in C++, &amp;*E is indeed undefined behavior and not equivalent to E. So the bonus chatter may be true for C++. Someone confirm or disprove it please, because I know nothing about C++</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134353">
				<div id="div-comment-1134353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pete</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134353">
			June 27, 2014 at 7:37 am</a>		</div>

		<p>Something something c++ operator overloading something something, I&#39;d imagine. After all, the dereference operator might have side-effects! (Shudders)</p>
<div class="post">[<em>Assume no operator overloading. (I can&#39;t believe I had to say that.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134363">
				<div id="div-comment-1134363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pete</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134363">
			June 27, 2014 at 7:45 am</a>		</div>

		<p>Raymond, I meant that operator overloading could be one of the reasons that &amp;*E is not necessarily equal to E in C++, where it would necessarily be in C.</p>
<div class="post">[<em>I think you&#39;re missing the point of the article. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134373">
				<div id="div-comment-1134373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pete</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134373">
			June 27, 2014 at 8:06 am</a>		</div>

		<p>Sorry Raymond, I wasn&#39;t talking about the article, I was trying to provide an explanation to the comment above mine about the behavior in c++ vs c. &nbsp;I see now that they&#39;re all off topic, including mine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134383">
				<div id="div-comment-1134383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134383">
			June 27, 2014 at 8:12 am</a>		</div>

		<p>The undefined behavior explained in the `value_or_fallback()` example resulted in an actual Linux kernel exploit a while back (the TUN/TAP driver exploit). &nbsp;</p>
<p>See <a rel="nofollow" target="_new" href="http://lwn.net/Articles/342330/">lwn.net/&#8230;/342330</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134393">
				<div id="div-comment-1134393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134393">
			June 27, 2014 at 8:17 am</a>		</div>

		<p>A good example of the undefined behavior is if you do something like </p>
<p>std::vector&lt;int&gt; vect;</p>
<p>int *x = &amp;vect[0];</p>
<p>I got bit by that before vector had a .data() method. &nbsp;My initial expectation was that x would contain NULL. &nbsp;Fortunately no time travel was invoked and the program simply crashed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134413">
				<div id="div-comment-1134413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134413">
			June 27, 2014 at 8:26 am</a>		</div>

		<p>@Pete, No, they are not off topic. Raymond claims that &amp;*nullptr is undefined behavior in both C and C++, but I pointed out it is not undefined behavior in C, but I&#39;m not sure about C++. You pointed out that it is undefined behavior in C++ for the reason you gave.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134423">
				<div id="div-comment-1134423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anders Munch</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134423">
			June 27, 2014 at 8:35 am</a>		</div>

		<p>Nit: In the unwitting function, the optimisation can only be done if the compiler can prove that ring_bell terminates or invokes undefined behaviour.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134433">
				<div id="div-comment-1134433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134433">
			June 27, 2014 at 8:50 am</a>		</div>

		<p>I would simplify the explanation for the first example to: When executing the loop, at some point i will equal 4. This invokes undefined behaviour due to accessing beyond the end of the array, allowing the function to return true. The final iteration of the loop will thus always return true, and so the loop can be optimised to a &quot;return true&quot; statement.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134443">
				<div id="div-comment-1134443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Liquorice</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134443">
			June 27, 2014 at 8:54 am</a>		</div>

		<p>SimonRev: Maybe the undefined behavior invoked a time travel and modified everyone&#39;s memory, as if the program simply crashed? Wait, if a time travel is invoked and no one remembers it, does it make a real time travel?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134463">
				<div id="div-comment-1134463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134463">
			June 27, 2014 at 9:14 am</a>		</div>

		<p>I always question this kind of compiler behaviour especially when you see these kinds of results. Since the likelihood that these invocations of undefined behaviour are unintentional, then wouldn&#39;t it be better finding better ways of telling the user that the code is wrong rather than optimising it away and causing lots of confusion when things break.</p>
<div class="post">[<em>Check out Part 3 of the Related Reading. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134483">
				<div id="div-comment-1134483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">VinDuv</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134483">
			June 27, 2014 at 9:55 am</a>		</div>

		<p>@David: Are you complaining that compilers turn buggy code into buggier code?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134493">
				<div id="div-comment-1134493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kay</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134493">
			June 27, 2014 at 10:29 am</a>		</div>

		<p>Can you please give an example of &quot;A post-modern compiler&quot; that does such crazy optimizations exploiting undefined behaviors? Is this theoretical reasoning? Or, does it can really happen?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134503">
				<div id="div-comment-1134503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134503">
			June 27, 2014 at 10:36 am</a>		</div>

		<p>@VinDuv, compilers certainly turn buggy code hard to de-bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134513">
				<div id="div-comment-1134513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134513">
			June 27, 2014 at 10:42 am</a>		</div>

		<p>The `exists_in_table()` example (the first one) is a variation of a paradox that a professor in one of my university classes presented way back when &#8211; before anyone talked about undefined behavior on computers.</p>
<p>The paradox was presented as:</p>
<p>A teacher of a class on logic announces on a Friday that sometime during the next week a surprise quiz will be given, and that no one will know before the quiz is given when it will be. The students deduce that if the quiz hasn&#39;t been given by Friday, then it would have to be given on Friday. But that couldn&#39;t happen because they would know before Friday&#39;s class that the quiz would be given that day. Since Friday is eliminated as a candidate for quiz day, reduction eliminates all the other days of the week, and the conclusion is that the quiz can&#39;t be given. The students spend the weekend partying instead of studying.</p>
<p>The students show up for class on Monday, and find that they have to take a surprise quiz.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134523">
				<div id="div-comment-1134523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134523">
			June 27, 2014 at 10:45 am</a>		</div>

		<p>@Kay: </p>
<p>Follow the links Raymond gave to John Regehr&#39;s articles on real world undefined behavior. &nbsp;These aren&#39;t just theoretical.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134553">
				<div id="div-comment-1134553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134553">
			June 27, 2014 at 11:33 am</a>		</div>

		<p>@John Doe</p>
<p>s/hard/nigh-unto-impossible/</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134563">
				<div id="div-comment-1134563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shafik Yaghmour</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134563">
			June 27, 2014 at 11:35 am</a>		</div>

		<p>This StackOverflow question where gcc turns a loop with four iterations into a infinite loop due to signed integer overflow is one of the best I have see:</p>
<p> &nbsp;<a rel="nofollow" target="_new" href="http://stackoverflow.com/questions/24296571/why-does-this-code-output-more-than-4-lines">stackoverflow.com/&#8230;/why-does-this-code-output-more-than-4-lines</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134303">
				<div id="div-comment-1134303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Edwin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134303">
			June 27, 2014 at 7:14 am</a>		</div>

		<p>&quot;You might think that the &amp;* cancel out and the result is as if you had written foo(p), but the fact that you performed the dereference at all (even if you never carried through on it) invokes undefined behavior.&quot;</p>
<p>Is this really true? The C99 standard says:</p>
<p>&quot;The unary &amp; operator yields the address of its operand. If the operand has type &lsquo;&lsquo;type&rsquo;&rsquo;,</p>
<p>the result has type &lsquo;&lsquo;pointer to type&rsquo;&rsquo;. If the operand is the result of a unary * operator,</p>
<p>neither that operator nor the &amp; operator is evaluated and the result is as if both were</p>
<p>omitted, except that the constraints on the operators still apply and the result is not an</p>
<p>lvalue.&quot;</p>
<p>(the constraints are basically that the * still has to be used on a pointer, so you can&#39;t write &amp;*1)</p>
<div class="post">[<em>Point taken. I&#39;ve updated the example. This is what happens when I try to condense an example and go too far. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134603">
				<div id="div-comment-1134603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">noMAD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134603">
			June 27, 2014 at 2:53 pm</a>		</div>

		<p>I think you statement: `When i is 4, the code performs undefined behavior. Since undefined behavior lets me do anything I want, I can totally ignore that case and proceed on the assumption that i is never 4.` is paradoxical. If you are going to ignore the case and proceed on the assumption that i is never 4 then you would never have reached the state of undefined behavior in the first place where you would want to not ignore the case. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134453">
				<div id="div-comment-1134453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134453">
			June 27, 2014 at 9:05 am</a>		</div>

		<p>About the whole &amp;*p thing, it is indeed legal in C++: <a rel="nofollow" target="_new" href="http://stackoverflow.com/questions/7346634/dereferencing-an-invalid-pointer-then-taking-the-address-of-the-result" rel="nofollow">stackoverflow.com/&#8230;/dereferencing-an-invalid-pointer-then-taking-the-address-of-the-result</a></p>
<p>It becomes undefined behaviour when there is an lvalue-to-rvalue conversion required for *p.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134473">
				<div id="div-comment-1134473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134473">
			June 27, 2014 at 9:22 am</a>		</div>

		<p>This is great. Post-classical compilers are very good at producing code that very efficiently does the wrong* thing. Progress!</p>
<p>* allowed by the standard but obviously wrong anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134533">
				<div id="div-comment-1134533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134533">
			June 27, 2014 at 10:59 am</a>		</div>

		<p>@Kay: &quot;Can you please give an example of &quot;A post-modern compiler&quot; that does such crazy optimizations exploiting undefined behaviors?&quot;</p>
<p>Yes, there have been several security holes &quot;caused&quot; by compiler optimizations. This can be as simple as a &quot;char* password = malloc(size); &#8230;; memset(password, &#39; &#39;, size); free(password);&quot; where the memset is optimized away to much more complex scenarios. &quot;What Every C Programmer Should Know About Undefined Behavior&quot; Part 2 (and I think somewhere in Reghr&#39;s blogs) shows a simplified example of a real, exploitable security hole caused by the fact that the Linux kernel dereferenced a pointer before checking for null &#8212; the compiler made optimizations based on the dereference that said &quot;since this pointer is dereferenced, it cannot be null*, hence this check for null is redundant and can be removed.&quot; But removing the null check left the function exploitable. (The correct fix was presumably to move the dereference after the check.)</p>
<p>* More precisely, the compiler says &quot;since this pointer is dereferenced, I can do whatever the heck I want when it is NULL, including bypass the null check.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134543">
				<div id="div-comment-1134543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134543">
			June 27, 2014 at 11:18 am</a>		</div>

		<p>@David: &quot;This is great. Post-classical compilers are very good at producing code that very efficiently does the wrong* thing. Progress!&quot;</p>
<p>The problem is, one person&#39;s idea of &quot;incorrect code&quot; is another person&#39;s idea of an optimization.</p>
<p>Take the following program:</p>
<p> &nbsp;void foo() {</p>
<p> &nbsp; &nbsp; &nbsp;int x;</p>
<p> &nbsp; &nbsp; &nbsp;x = 5;</p>
<p> &nbsp;}</p>
<p> &nbsp;void bar() {</p>
<p> &nbsp; &nbsp; &nbsp;int y;</p>
<p> &nbsp; &nbsp; &nbsp;printf(&quot;%dn&quot;, y);</p>
<p> &nbsp;}</p>
<p> &nbsp;int main() {</p>
<p> &nbsp; &nbsp; &nbsp;foo();</p>
<p> &nbsp; &nbsp; &nbsp;bar();</p>
<p> &nbsp; &nbsp; &nbsp;return 0;</p>
<p> &nbsp;}</p>
<p>It&#39;s certainly conceivable that you could find someone (probably from 1975) who would argue that program REALLY should always print 5, because after all, bar&#39;s stack frame will just overlay foo&#39;s, and that something else is obviously incorrect. You can probably find programs that do what I&#39;d call a moral equivalent of that, expecting things to work out, today. But hopefully this example seems pretty ridiculous, because the compiler can do things like register allocation; maybe y doesn&#39;t even *have* a memory address!</p>
<p>Similarly, take the optimization Raymond presented of</p>
<p> &nbsp;int value_or_fallback(int *p)</p>
<p> &nbsp;{</p>
<p> &nbsp; &nbsp;printf(&quot;The value of *p is %dn&quot;, *p);</p>
<p> &nbsp; &nbsp;return p ? *p : 42; // optimized to &#39;return *p&#39;</p>
<p> &nbsp;}</p>
<p>I&#39;m actually very happy with the compiler doing that. It makes perfect sense to me! In this example the benefit is not so clear, but imagine that the different lines are from different functions that were inlined, and the conditional was written because the function was more general than it needs to be for the context in which it is used.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134573">
				<div id="div-comment-1134573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rick C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134573">
			June 27, 2014 at 1:36 pm</a>		</div>

		<p>@Anders Munch: that&#39;s not a nit, that&#39;s the entire point: &nbsp;the compiler *has* determined that undefined behavior occurs on all code paths. &nbsp;Obviously if it cannot do that, none of the rest of the article follows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134583">
				<div id="div-comment-1134583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134583">
			June 27, 2014 at 2:26 pm</a>		</div>

		<p>[Check out Part 3 of the Related Reading. -Raymond]</p>
<p>Yea, well aware of that. But I can always hope that one day, instead of finding optimisation opportunities based off of incorrect code, they spend that time to figure out how to detect and warn about the code itself.</p>
<div class="post">[<em>As noted in Part 3, a big problem is avoid false positives in such reports. Consider:<br />int *GetFroobie() { static int froobie; return &amp;froobie; }<br />int GetValueOrDefault(int *p) { return p ? *p : 42; }<br />char *GetColor(int *p) { return colorTable[GetValueOrDefault(p)]; }<br />char *UpdateFroobieAndGetColor(int v) { int *p = GetFroobie(); *p = v; return GetColor(p); }<br />Do you want the compiler to warn you, &quot;Possible bug in in GetValueOrDefault: testing for &quot;p != nullptr&quot; is redundant because p is dereferenced in UpdateFroobieAndGetColor prior to the test&quot;? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134593">
				<div id="div-comment-1134593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134593">
			June 27, 2014 at 2:28 pm</a>		</div>

		<p>I&#39;m curious what the official stance is on Visual C++&#39;s support for signed integer overflow. &nbsp;By the C/C++ standard, signed integer overflow is undefined, but it may be defined in a given implementation. &nbsp;In C++11, std::numeric_limits&lt;signed T&gt;::is_modulo was reworded to clarify that is_modulo is true if and only if the implementation considers signed integer overflow to be fully defined, and that the definition is to wrap modulo whatever power of 2, as if it were unsigned.</p>
<p>Visual C++ sets is_modulo to true, and experimentally I&#39;ve never been been able to get VC&#39;s optimizer to assume that signed integers can&#39;t overflow. &nbsp;VC acts much as GCC with -fwrapv does, rather than GCC without -fwrapv.</p>
<p>However, I did find a case in which Visual C++&#39;s optimizer handles signed integer overflow incorrectly. &nbsp;When reading about a Visual C++ bug that&#39;s new to 2013&#39;s Update 2 on Microsoft Connect, I noticed that the Update 1 code, from before the bug, doesn&#39;t handle signed integer overflow correctly.</p>
<p>I&#39;ve only tried on x64, but this code on VC 2013 Update 2 breaks spectacularly (Connect bug link at end of post):</p>
<p>void func (int *b, int n)</p>
<p>{</p>
<p> &nbsp;for (int i = 0; i &lt; n; i++)</p>
<p> &nbsp; &nbsp;b[i * (n + 1)] = 1;</p>
<p>}</p>
<p>In Update 1, it works much more properly. &nbsp;However, there&#39;s a very subtle issue: if &quot;n&quot; is exactly 0x7FFFFFFF, VC&#39;s optimizer acts as if the &quot;* (n + 1)&quot; expression means &quot;* 0x0000000080000000LL&quot; rather than the correct &quot;* 0xFFFFFFFF80000000LL&quot;. &nbsp;This obviously is probably not what is desired, and it&#39;s very unlikely that you&#39;d pass such a large array, but it does show that there is some issue with signed integer overflow in the optimizer.</p>
<p>Besides the Update 2 bug, the Update 1 version is also a bug in Visual C++: either the signed integer overflow handling is wrong, or the definition of std::numeric_limits&lt;int&gt;::is_modulo is wrong.</p>
<p><a rel="nofollow" target="_new" href="https://connect.microsoft.com/VisualStudio/feedback/details/905695/wrong-loop-optimization" rel="nofollow">connect.microsoft.com/&#8230;/wrong-loop-optimization</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134613">
				<div id="div-comment-1134613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134613">
			June 27, 2014 at 3:48 pm</a>		</div>

		<p>@noMAD: &quot;If you are going to ignore the case and proceed on the assumption that i is never 4 then you would never have reached the state of undefined behavior in the first place where you would want to not ignore the case.&quot;</p>
<p>That&#39;s where the time travel comes into play. The generated code is a version with a naive implementation of the undefined behavior, except that at runtime it detects the UB, goes back in time, and does something else leading up to it. :-)</p>
<p>(Obviously you should not take that description literally.)</p>
<p>The compiler is not required to leave the undefined behavior in the program. It can do whatever it wants to it, provided that it preserves the observable semantics of runs that would *not* invoke undefined behavior in the abstract machine defined by the appropriate standard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134643">
				<div id="div-comment-1134643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dzmitry</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134643">
			June 27, 2014 at 11:50 pm</a>		</div>

		<p>So why do then C-geeks consider Java inferior? In Java, unreachable code doesn&#39;t compile, and undefined behavior cannot exist.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134663">
				<div id="div-comment-1134663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134663">
			June 28, 2014 at 2:14 am</a>		</div>

		<p>See <a rel="nofollow" target="_new" href="http://stackoverflow.com/questions/23153445/can-branches-with-undefined-behavior-be-assumed-unreachable-and-optimized-as-dea">stackoverflow.com/&#8230;/can-branches-with-undefined-behavior-be-assumed-unreachable-and-optimized-as-dea</a> (&quot;Can branches with undefined behavior be assumed unreachable and optimized as dead code?&quot;). This post answers that question nicely.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134673">
				<div id="div-comment-1134673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134673">
			June 28, 2014 at 2:18 am</a>		</div>

		<p>@VinDuv: Are you complaining that compilers turn buggy code into buggier code?</p>
<p>Yes. Yes I am. See, it turns what should have been a relatively simple problem with straightforward local (if any) consequences, into an impossible to diagnose &quot;infects the whole program&quot; nightmare with observable behaviour that essentially lies about what the problem is. In the name of speed, which is useless because the code is broken anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134633">
				<div id="div-comment-1134633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134633">
			June 27, 2014 at 7:50 pm</a>		</div>

		<p>Through the links you posted, I&#39;m most amazed that *loops can be assumed to terminate* if they have no side-effects in C++11. Even in cases like a function to test something that either halts or loops forever, a C++ compiler can assume it halts. Link (linked to from one of Raymond&#39;s links): <a rel="nofollow" target="_new" href="http://blog.regehr.org/archives/161" rel="nofollow">blog.regehr.org/&#8230;/161</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134683">
				<div id="div-comment-1134683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134683">
			June 28, 2014 at 4:02 am</a>		</div>

		<p>[Do you want the compiler to warn you, &quot;Possible bug in in GetValueOrDefault: testing for &quot;p != nullptr&quot; is redundant because p is dereferenced in UpdateFroobieAndGetColor prior to the test&quot;? -Raymond]</p>
<p>If UpdateFroobieAndGetColor can be shown to be the only caller to GetValueOrDefault, then yes, I want the compiler to warn me. (And the reverse is true if I remove the null-check from GetValueOrDefault and then call it from somewhere that might pass nullptr.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134653">
				<div id="div-comment-1134653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134653">
			June 28, 2014 at 12:54 am</a>		</div>

		<p>Dzmitry: While Java has no UB in the actual language (in stark contrast to C/C++) there are still things undefined. One example I stumbled over, was memory-mapping files where creating a mapping beyond the end of the file is undefined (most likely to differences in how different operating systems handle that case). But there *are* in fact undefined things in the Java standard lib and they are explicitly called out. The definition of undefined behaviour isn&#39;t as hostile as in C as well, granted.</p>
<p>And C geeks consider Java inferior because its *performance* is in most cases worse than C&#39;s. They are willing to live with the plethora of land mines C puts before their feet because they need the features C is able to provide. Well, but then there are those who choose languages not by merits and requirements but more by hype or beliefs and you can&#39;t reason about those. (To me at least there are suitable uses for many different languages and I probably wouldn&#39;t try writing a CRUD web application in C.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134693">
				<div id="div-comment-1134693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">T</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134693">
			June 28, 2014 at 4:42 am</a>		</div>

		<p>Are you sure that dereferencing a pointer without actually looking at the value is undefined behaviour? The following snippet is taken from stddef.h in VS 2012:</p>
<p>#define offsetof(s,m) &nbsp; (size_t)( (ptrdiff_t)&amp;reinterpret_cast&lt;const volatile char&amp;&gt;((((s *)0)-&gt;m)) )</p>
<p>Also, when trying to access an array item out of array size bounds, is that also undefined behaviour if the array is part of the struct? It&#39;s a common technique to have an array of size 1 at the end of a struct and just allocate as much memory as you need its length to be. For example, taken out of WinBase.h:</p>
<p>typedef struct _FILE_NAME_INFO {</p>
<p> &nbsp; &nbsp;DWORD FileNameLength;</p>
<p> &nbsp; &nbsp;WCHAR FileName[1];</p>
<p>} FILE_NAME_INFO, *PFILE_NAME_INFO;</p>
<p>If to follow your post, accessing FileName[5] is undefined, but it totally depends on how much memory is allocated. I would expect the compiler to actually look up the uninitialized memory in this or any other case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134703">
				<div id="div-comment-1134703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134703">
			June 28, 2014 at 6:36 am</a>		</div>

		<p>@Raymond:</p>
<p>I totally agree, but maybe I&#39;m being a bit optimistic in thinking that there should be a way to satisfy both demands now. For example, implementing a compiler option called /imwillingtoputupwiththeextratimeandfalsepositives so that it takes the extra compile time, disk space and memory to do these extra checks so that by the time the optimisations are being done, it has all the information needed.</p>
<p>Well, there are already a lot of great tools to help figure these things out (obligatory product placement time, VCs /analyse option), I also know that the poor compiler devs would be the ones getting all of the complaints for these changes too.</p>
<p>@Neil:</p>
<p>The problem is, quite often the compiler doesn&#39;t have the information needed. The problem is that the compiler strips out a lot of information as it parses the code. The thing which would help is if the compiler could keep/store the extra information for the build, but there be dragons too. Developers always seem to prioritise build times, if you couple that together with the fact that the C++ standard keeps getting more complex then that has a negative impact on compilation times. So as Raymond was pointing out to me, the choice is between false positives or slower build times, and the general consensus is that both suck. (False positives because of options like /Wx and slower build times because that time could be spent doing more work).</p>
<p>@T:</p>
<p>This was covered near the start of the post comments. Originally Raymond had something similar in the bonus chatter section. As the C99 standard states, if &amp; and * appear in the same statement, neither would be evaluated. Now, before the reinterpret_cast there is a &amp;, and the ((s*)0)-&gt;m is essentially (*(s*)0).m, so with the address of operator, and without the casts, you have &amp;*0.m. There is no invocation of undefined behaviour there. For the array, well, unless it is a class type that has an overloaded operator[], the standard defines Array[Elem] as *((Array)+(Elem)) and I don&#39;t think there is any mention of array bounds at all. So for the undefined behaviour, that would arise with the dereferencing of the array element, not with going past the end. This is where the code fragment in the sample and this structure are different. When you allocate it, it could be allocated as</p>
<p>PFILE_NAME_INFO info = (PFILE_NAME_INFO)malloc(sizeof(FILE_NAME_INFO)+ MAX_PATH &#8211; 1);</p>
<p>GetFileInformationByHandleEx(handle, FileNameInfo, info, sizeof(FILE_NAME_INFO) + MAX_PATH &#8211; 1);</p>
<p>So you can see from that, there is enough memory even with the array only being defined as length 1. On the other hand Raymond&#39;s example has</p>
<p>int table[4];</p>
<p>So right from the start you know that it has length 4, so table[4] will be the same as *(table + 4), and that dereferences memory that has not been explicitly allocated, and this is where the undefined behaviour is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134713">
				<div id="div-comment-1134713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134713">
			June 28, 2014 at 3:17 pm</a>		</div>

		<p>@Neil: You may think you do, but in reality no you really don&#39;t. For example Python does reference counting for objects manually using Py_XDECREF/PY_XINCREF macros. Those are some general macros that check if their argument is zero before working on it. Now clearly those will be used in situations where the compiler can deduce that the argument will never be null &#8211; do you really want to generate a warning for each of those situations? You could use another macro version that doesn&#39;t do the null checks, but that&#39;s dangerous &#8211; and worst of all since the compiler can do the deduction for you won&#39;t even give you a performance benefit.</p>
<p>Now warning about missing null checks? That&#39;s probably a good idea, there&#39;s still the chance of false positives, but in general those are going to be way lower than the opposite..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134723">
				<div id="div-comment-1134723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134723">
			June 29, 2014 at 5:38 am</a>		</div>

		<p>&quot;Now clearly those will be used in situations where the compiler can deduce that the argument will never be null &#8211; do you really want to generate a warning for each of those situations?&quot;</p>
<p>Take Raimond&#39;s example with the array: WHEN the compiler is able to see an access to non-allocated memory, THEN it would be much better to produce an compile-time error (because that is clearly a error in the source code) than to generate crazy code. When the compiler cannot prove that then he should of course not generate an error NOR the crazy code.</p>
<p>If you talk about unreachable code in tbe true sense, deduced by compile-time evaluation of expressions, not over undefined behavior, than I&#39;m with you: There should be no warning.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134733">
				<div id="div-comment-1134733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134733">
			June 29, 2014 at 7:58 am</a>		</div>

		<p>Undefined behavior can and does exist in Java. It&#39;s just harder to find how to cause it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134743">
				<div id="div-comment-1134743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hans</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134743">
			June 29, 2014 at 10:28 am</a>		</div>

		<p>@voo: Pretty much sums it up.</p>
<p>But instead of a warning programmers tend to ignore the compiler should actually _replace_ the source code, so that Raimonds example will list as:</p>
<p>bool exists_in_table(int v)</p>
<p>{</p>
<p> &nbsp; &nbsp;return true;</p>
<p>}</p>
<p>Would then be no surprise the generated code matches the source code ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134753">
				<div id="div-comment-1134753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134753">
			June 29, 2014 at 11:15 am</a>		</div>

		<p>@@voo: I think I misunderstood Neil&#39;s example, I agree that these kind of optimizations which rely on undefined behavior to generate optimized code are on first glance annoying &#8211; if the compiler can deduce such a thing why shouldn&#39;t it generate a warning instead? But since working on compilers a bit, I find that generally those kind of optimizations happen deep down the pipeline where it&#39;s no longer apparent that the information was caused by undefined behavior and is a bug and not some valid optimization.</p>
<p>llvm is doing much better than MSVC/gcc in general in this regard but there&#39;s still much to do.</p>
<p>@Joshua: That I doubt, if you exclude JNI and co &#8211; since Java&#39;s sandbox was originally planned to make sure code is securely executed, having undefined behavior would be a gigantic problem. C#/CLR does have some, but I don&#39;t think the Java spec actually does. What examples do you have in mind?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134763">
				<div id="div-comment-1134763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134763">
			June 29, 2014 at 2:13 pm</a>		</div>

		<p>&quot;This new line introduces a bug: It dereferences the pointer p without checking if it is null. This tiny bug actually has wide-ranging consequences. A post-classical compiler will optimize the function to&quot;</p>
<p>This is complete nonsense; the code works fine if p is never null, and the compiler can&#39;t break it when it isn&#39;t. With a claim so blazingly inane and incompetent, I stopped reading at that point.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134773">
				<div id="div-comment-1134773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134773">
			June 29, 2014 at 2:16 pm</a>		</div>

		<p>Argh, I misread &#8230; your optimization does return the right value when p is not null. Ignore my inane and incompetent comment &#8230; carry on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134793">
				<div id="div-comment-1134793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134793">
			June 30, 2014 at 1:10 am</a>		</div>

		<p>I ran this entire article through an optimising English compiler. &nbsp;The output was: </p>
<p>&quot;The behaviour of a program that has undefined behaviour is undefined.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134783">
				<div id="div-comment-1134783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crazy Town</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134783">
			June 29, 2014 at 6:58 pm</a>		</div>

		<p>IF SO-CALLED &quot;PROFESSIONALS&quot; AND &quot;SOFTWARE ENGINEERS&quot; WOULD MAKE SO MANY *SIMPLE* ARITHMATIC COUNTING AND LOGIC ERRORS ETC IN THE FIRST PLACE WE WOULD NOT BE IN THESE SITUATION!!!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134803">
				<div id="div-comment-1134803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134803">
			June 30, 2014 at 4:04 am</a>		</div>

		<p>@Karellen: &quot;here be dragons&quot; sounds cool. &quot;nasal demons&quot; sounds ugly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1134813">
				<div id="div-comment-1134813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">hm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134813">
			June 30, 2014 at 5:27 am</a>		</div>

		<p>&quot;The compiler observed that the call value_or_fallback(nullptr) invokes undefined behavior on all code paths. Propagating this analysis backward, the compiler then observes that if door_is_open is false, then the else branch invokes undefined behavior on all code paths. Therefore, the entire else branch can be treated as unreachable.² &quot;</p>
<p>The code of value_or_fallback() imposes an implicit &nbsp;&lt;ptr != NULL&gt; constraint, which the compiler can act upon in a sensible way by eliminating the ternary operator.</p>
<p>If value_or_fallback() is called with a pointer proven to be NULL, then this constraint is violated and the only sensible behavior of the compiler would be to raise an error.</p>
<p>In this case (and also in the array example), if the compiler is confident about the code error (using an invalid array index, using an invalid pointer) what is the value in trying to optimize broken code? The compiler should refuse to compile it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1134823">
				<div id="div-comment-1134823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Katie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1134823">
			June 30, 2014 at 6:16 am</a>		</div>

		<p>@hm</p>
<p>Things like macros, template definitions and inline functions interact in all sorts of ways in a complicated enough project. There may be situations where an expansion ends up dereferencing a null pointer, but the developer knows that that branch of the expression will never be evaluated. The compiler should compile that code in that case. Although the code could be rewritten to avoid the issue it would make the code more complicated and would possibly duplicate logic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135023">
				<div id="div-comment-1135023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135023">
			June 30, 2014 at 12:06 pm</a>		</div>

		<p>&quot;in all sorts of ways in a complicated enough project. There may be situations where an expansion ends up dereferencing a null pointer, but the developer knows that that branch of the expression will never be evaluated.&quot;</p>
<p>If the code is complicted enough to fit your claim, how would the developer know for sure if the right or the wrong parts of such a complicated construct will be executed?</p>
<p>I think this whole approach has no place in a prograaming tool that is meant to be used be humans.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135033">
				<div id="div-comment-1135033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Katie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135033">
			June 30, 2014 at 1:04 pm</a>		</div>

		<p>Here&#39;s a simple example with a macro from the Linux kernel:</p>
<p>#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL&lt;&lt;(n))-1))</p>
<p>int foo()</p>
<p>{</p>
<p> &nbsp; &nbsp;return DMA_BIT_MASK(64);</p>
<p>}</p>
<p>A 64-bit shift is undefined, but the macro creates one in dead code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135043">
				<div id="div-comment-1135043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">hm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135043">
			June 30, 2014 at 1:21 pm</a>		</div>

		<p>&quot;64-bit shift is undefined&quot;</p>
<p>So what? This statement in itself is non-sensical. This is a completely artifical and counter-intuitive definition. Shift operations should always simply compute the expected result. What compiled code to you expect if you use this macro with a variable instead of a constant?</p>
<div class="post">[<em>It may be an artificial and counter-intuitive definition, but it&#39;s also the law. [expr.shift] &quot;The behavior is undefined if the right operand is negative or greater than or equal to the length in bits of the promoted left operand.&quot; (It&#39;s not artificial if you understand the CPU instruction set. Most architectures limit the number of positions that can be shifted in a single instruction.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135053">
				<div id="div-comment-1135053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135053">
			June 30, 2014 at 1:25 pm</a>		</div>

		<p><a rel="nofollow" target="_new" href="http://lwn.net/Articles/278137/">lwn.net/&#8230;/278137</a></p>
<p>Very telling: &quot;If you use GCC and its C frontend, you want performance, not security.&quot;</p>
<p>So please please don&#39;t use GCC to compile an operating system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135083">
				<div id="div-comment-1135083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135083">
			June 30, 2014 at 11:12 pm</a>		</div>

		<p>@Hm: So, you want Windows, Linux, Java, .Net, (fill in your platform of choice) to use three times the memory and run a tenth as fast, just so there are no undefined behaviors?</p>
<p>There&#39;s a reason non-PoC Operating Systems, Programming platforms and many big projects are written in languages which are not strongly-typed and have undefined behavior: Performance.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135123">
				<div id="div-comment-1135123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135123">
			July 1, 2014 at 4:30 am</a>		</div>

		<p>Remember: doing wrong things fast is more important and better for business than doing correct things slowly. You can always work around wrong behaviour with slight performance hit (provided you can&#39;t stand the wrong behaviour, otherwise just let it be), while you can&#39;t optimize and speed up correct but slow program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135133">
				<div id="div-comment-1135133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ariel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135133">
			July 1, 2014 at 5:17 am</a>		</div>

		<p>The optimisation removing ring_bell is a little weird &#8211; ring_bell probably ends up invoking at least one system call, and the compiler shouldn&#39;t be able to prove they all return &#8211; and if ring_bell fails to return then the code is fine (in C11, ring_bell can be assumed to not diverge, but that&#39;s a different issue &#8211; a system call not returning != diverging, as the former can happen if, say, one of the system calls is _exit, or a futex_wait that is part of a deadlock, or a blocking read from an empty pipe, etc.).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135143">
				<div id="div-comment-1135143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Hm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135143">
			July 1, 2014 at 6:09 am</a>		</div>

		<p>I expect that the compiler will use the target CPU&#39;s shift instruction, where the result of the shift can vary across architectures. It may break it into a few instructions to handle targets that don&#39;t support 63 bit shifts.</p>
<p>However I also understand that it may realize that the variable will never be greater than 64 because of the undefined behavior and wrap it into a clever optimization based on that knowledge. I don&#39;t really care that the optimization may have strange results when it gets a value of 70 because that means my code is doing something wrong anyways. If my driver thinks it needs a 70-bit DMA mask in a 64-bit variable then why should I expect anything after that request to work right anyways?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135153">
				<div id="div-comment-1135153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Katie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135153">
			July 1, 2014 at 6:12 am</a>		</div>

		<p>@Hm</p>
<p>That was me above&#8230; not sure why I put your name like that&#8230;</p>
<p>I also just realized that your question implies that any time a shift operator is used with a variable the compiler must be able to verify that the argument to it will always be within a valid range, otherwise it should refuse to compile it because it would trigger undefined behavior in the language spec.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135173">
				<div id="div-comment-1135173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">hm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135173">
			July 1, 2014 at 7:20 am</a>		</div>

		<p>@Katie: I omitted some text from my answer to your example:</p>
<p>#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL&lt;&lt;(n))-1))</p>
<p>First, as long as &lt;n&gt; is in the range 0 .. 64, there is no undefined behavior whatsoever, because the code path with the shift operation has the constraint that it will not be executed with &lt;n&gt; == 64. &quot;1ULL &nbsp;&lt;&lt; 64&quot; in itself is not undefined behavior until it is proven that this code will be executed.</p>
<p>Second, imaging the following: Some driver module using this macro is changed. After several levels of inlining and macro expansion etc etc (as you said) the compiler can prove that this code fragment will be used with a constant (or variable) outside of the range 0..64, lets say, 128.</p>
<p>What would you like more?</p>
<p>(a) The compiler silently turns this undefined behavior into a random DMA bit mask.</p>
<p>(b) The compiler emits a compile-time error, because it had seen your error.</p>
<div class="post">[<em>But what if the code that passed 128 is itself dead in a way the compiler cannot detect? Now the compiler refuses to compile dead code. In a sense, intentionally executing undefined behavior is how you tell the compiler that code is dead. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135193">
				<div id="div-comment-1135193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Katie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135193">
			July 1, 2014 at 7:33 am</a>		</div>

		<p>(c) The compiler emits a warning letting me know that I have an expression with undefined behavior. This is what GCC does with default configuration.</p>
<p>I selected this example because in some situations it does generate a compiler warning because of the &quot;1ULL&lt;&lt;(64)&quot; when using it with a value of 64. The compiler isn&#39;t always smart enough to recognize that it is dead code and supress the warning. You&#39;re suggesting that in this case it should assume the programmer made a mistake and refuse to compile, even though in that situation there is no error and no matter what code it generates for that expression it will never actually run it.</p>
<p>The warning brings the potential problem to the programmer&#39;s attention and allows them to evaluate the situation, and allows them to fix the bug in the case of it using 128, or ignore it in the case that they can see it is in dead code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135213">
				<div id="div-comment-1135213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135213">
			July 1, 2014 at 8:56 am</a>		</div>

		<p>@Joker: I&#39;m not sure whether you are living up to your name there (too subtle for me then) or are actually serious (Thus demonstrating you didn&#39;t read the material or misunderstood it).</p>
<p>@ariel: You are right, he actually didn&#39;t explicitly say that ring_bell provably returns (Doing system-calls is no valid indication for might never return though).</p>
<p>@hm: The meat of the article is that the compiler uses Undefined Behavior as a hook to understanding what code can be called with which values, so it can properly exploit all those things which are &quot;intuitively obvious&quot; to a human reader, without having to solve the halting problem. Thus, you left out the real options:</p>
<p>A: The compiler warns whenever you might have sinned by invoking UB, swamping you with spurious warnings and errors (Your choice: Allow only provable code or invent an un-consumer which distills the 1000 optimizations the compiler did to a human-readable diagnostic.).</p>
<p>B: The compiler produces mediocre code (half as fast as your competition or even worse =&gt; You are done for) because you define all the corner-cases.</p>
<p>C: The compiler augments its reasoning about your code by supposing you don&#39;t do such evil things and thus gets a much better view.</p>
<p>Seems like you want A, but without false positives (and without missing anything), as well as C. Not gonna happen, the sufficiently smart compiler is still a pipe-dream.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135223">
				<div id="div-comment-1135223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Katie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135223">
			July 1, 2014 at 9:40 am</a>		</div>

		<p>@Deduplicater</p>
<p>And even case B isn&#39;t very reasonable. The compiler would have to define the behavior for every case of undefined behavior, essentially creating a new language. And then bugs would still happen &#8211; if a value of 128 made it into my DMA macro the code would go along and do whatever the compiler says a shift should do in that case, but whatever value it returns still won&#39;t make sense in the context of code written with a maximum of 64 in mind.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135263">
				<div id="div-comment-1135263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135263">
			July 1, 2014 at 11:06 am</a>		</div>

		<p>&quot;Windows, Linux, Java, .Net, (fill in your platform of choice) to use three times the memory and run a tenth as fast, just so there are no undefined behaviors?&quot;</p>
<p>I&#39;m sure you overestimate this factors by a very large scale.</p>
<p>The point is that reliable operation is much more important than 0.1 (or 5%, if you like) performance gains. Remember that we talk here about &quot;general use&quot; software, not about high-performance computing like weather simulation.</p>
<p>The compiler folks deny this responsibility for weak reasons.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135283">
				<div id="div-comment-1135283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ariel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135283">
			July 1, 2014 at 11:50 am</a>		</div>

		<p>@Deduplicator</p>
<p>I&#39;m quite sure that no compiler tries to analyse whether system calls return (gcc, at least, doesn&#39;t: system calls are either within cross-module calls or asm statements, and it has no always_returns attribute) &nbsp;&#8211; that would be way too complicated (in Linux, for example, there could be a seccomp-bpf filter that SIGKILLs your program when it tries to make a specific system call with specific arguments &#8211; and IIRC the filter could be imposed by the process that exec(2)&#39;d you so even WPO won&#39;t help you). </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135373">
				<div id="div-comment-1135373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135373">
			July 2, 2014 at 3:15 am</a>		</div>

		<p>@Katie: I never said it was reasonable or even useful. Specifically, I never suggested it would magically fix a wrong program.</p>
<p>@.: I might be underestimating it there. Though in signal-processing, defined signed overflow alone purportedly makes things last 50% longer. And if your computing system gets even 5% slower, will you really stay loyal and not go to the competition which does not hobble you thus?</p>
<p>@ariel: Didn&#39;t want to imply the compiler analyzing sys-calls. It just generally assumes calls return, unless marked not to or sometimes if it can trivially prove it cannot return. (It has decorations for imposing reordering restrictions)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135403">
				<div id="div-comment-1135403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Katie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135403">
			July 2, 2014 at 5:55 am</a>		</div>

		<p>@Deduplicator</p>
<p>I know, I was agreeing with you that it was a bad solution, just adding my own reason why it still doesn&#39;t solve the kinds of problems we&#39;ve been discussing.</p>
<p>The signed overflow is an interesting example as well. If there is a signed integer overflow somewhere in my signal processing flow then the system will produce incorrect output and the equipment my software controls could destroy a multimillion dollar prototype. So in critical places I prove out that my algorithm will never produce an overflow and put simulations into my test suite that try the typical and extreme cases and verify that it doesn&#39;t overflow and produces the correct output. If I&#39;m confident that the value will never overflow, why not let the compiler assume that it won&#39;t overflow and make some nice optimizations as a result? </p>
<p>If for some reason I do expect it to overflow or am not confident enough in my analysis/testing then I can put my own checks in to handle the situation (probably letting it saturate instead of roll over) and it is still safe for the compiler to assume it won&#39;t overflow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1135563">
				<div id="div-comment-1135563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ariel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135563">
			July 2, 2014 at 10:51 am</a>		</div>

		<p>@Deduplicator</p>
<p>If the compiler assumes that calls return, even if they don&#39;t, then this is a bug in the compiler and should be fixed &#8211; not returning is a perfectly valid action (again, C11-diverging isn&#39;t relevant here), for example, take the following code:</p>
<p>do_security_check(data);</p>
<p>data-&gt;p[data-&gt;i] = data-&gt;v;</p>
<p>Assume that do_security_check can abort via some weird path if the condition was false. Now if the compiler thinks that it always returns, it can move the write ahead of the security check, turning correct (but aborting-on-invalid-data, which is completely fine in application context) code into exploitable code.</p>
<p>Note that some versions of gcc have (had) a bug where</p>
<p>unsigned int f(unsigned int z) {</p>
<p> &nbsp;unsigned int a = 100;</p>
<p> &nbsp;// trigger loop-invariant optimization</p>
<p> &nbsp;for(int i=0;i&lt;100;i++) {</p>
<p> &nbsp; &nbsp; &nbsp;// this isn&#39;t loop-invariant &#8211; but prevents divide-by-zero</p>
<p> &nbsp; &nbsp; &nbsp;if((z+1)*(a+1) == 1) return 0;</p>
<p> &nbsp; &nbsp; &nbsp;// but this is:</p>
<p> &nbsp; &nbsp; &nbsp;a += a*(100/z);</p>
<p> &nbsp;}</p>
<p> &nbsp;return a;</p>
<p>}</p>
<p>could end up failing when z==0. But that was a different problem &#8211; gcc didn&#39;t understand that division could crash.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1135853">
				<div id="div-comment-1135853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1135853">
			July 3, 2014 at 7:30 am</a>		</div>

		<p>@Deduplicator: It was a joke, don&#39;t worry. The main problem of UB in C/C++ is, in my opinion, not that it exists, no, but that it looks nearly indistinguishable from the legal code, and worse, your tools don&#39;t usually have &quot;look for probable subtle errors&quot; mode of work.</p>
<p>As for signed integer overflow, gee, that&#39;s why C# has &quot;unchecked&quot; keyword (I&#39;d assume). It&#39;s like that plastic cover on the &quot;LAUNCH THE MISSILES&quot; buttons — you don&#39;t want to press one by accident, but sometimes you do actually want to launch some missiles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1136063">
				<div id="div-comment-1136063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633#comment-1136063">
			July 3, 2014 at 3:16 pm</a>		</div>

		<p>@ariel: No, the compiler *cannot* move the write ahead of the security check. &nbsp;There&#39;s a sequence point after the function call, and the write has observable side effects, so the compiler is not allowed to reorder those unless it can prove that the two orderings are equivalent, which it won&#39;t be able to do if do_security_check() is an external function to which it doesn&#39;t have the code to at the time.</p>
<p>The loop-invariant code motion example you gave with GCC is, as you said, a bug.(may</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>