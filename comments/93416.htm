<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (23)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1247655">
				<div id="div-comment-1247655" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247655">
			May 6, 2016 at 8:09 am</a>		</div>

		<p>Multithreading 102: RW locks can deadlock if you take them while holding them because a writer attempting to acquire blocks all farther readers.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-alegrigoriev odd alt depth-2 parent" id="comment-1247716">
				<div id="div-comment-1247716" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247716">
			May 6, 2016 at 10:17 am</a>		</div>

		<p>Also Engineering 101: If the documentation tells you &#8220;don&#8217;t do that&#8221;, DON&#8217;T DO THAT!</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-msn even depth-3 parent" id="comment-1247735">
				<div id="div-comment-1247735" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/poizan42' rel='external nofollow' class='url'>poizan42</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247735">
			May 6, 2016 at 10:27 am</a>		</div>

		<p>Reality 101: No one reads the documentation</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4 parent" id="comment-1247755">
				<div id="div-comment-1247755" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nico</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247755">
			May 6, 2016 at 12:30 pm</a>		</div>

		<p>Reality 201: Nobody writes the documentation</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-hankhein even depth-5" id="comment-1247775">
				<div id="div-comment-1247775" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Henri+Hein' rel='external nofollow' class='url'>Henri Hein</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247775">
			May 6, 2016 at 1:02 pm</a>		</div>

		<p>Ha!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1247975">
				<div id="div-comment-1247975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247975">
			May 9, 2016 at 12:31 am</a>		</div>

		<p>Reality 404: Couldn&#8217;t find the documentation. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-4" id="comment-1247805">
				<div id="div-comment-1247805" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">McBucket</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247805">
			May 6, 2016 at 2:03 pm</a>		</div>

		<p>Reality 201: Reality bites (those who don&#8217;t read the documentation).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1247765">
				<div id="div-comment-1247765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247765">
			May 6, 2016 at 12:50 pm</a>		</div>

		<p>&gt; All functions that use the object acquire the SRWLOCK in shared mode, and the function that destroys the object acquires the SRWLOCK in exclusive mode.</p>
<p>This sounds broken already! If the destructor needs to acquire the lock, then that implies that another thread might attempt to use the object while it&#8217;s being destroyed.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-hankhein even depth-2" id="comment-1247796">
				<div id="div-comment-1247796" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Henri+Hein' rel='external nofollow' class='url'>Henri Hein</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247796">
			May 6, 2016 at 1:13 pm</a>		</div>

		<p>Yes, exactly.  I&#8217;ve worked on project code where synchronization objects appeared on the stack.  Unless it&#8217;s some top-level function, it gives me a strong sense the coder don&#8217;t really grok how synchronization works.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1247815">
				<div id="div-comment-1247815" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247815">
			May 6, 2016 at 2:33 pm</a>		</div>

		<p>What makes you think that &#8220;the function that destroys the object&#8221; is &#8220;the destructor&#8221;. I read that as meaning that &#8220;the function that destroys the object&#8221; is the one that calls &#8220;delete&#8221; (or equivalent) on the object.</p>
<p>Given that there is no complement to InitializeSRWLock() it should be safe to grab the lock exclusively, then delete the object. Once you have the lock, no other functions can use the object.</p>
<p>If another function has a reference to the object after you&#8217;ve grabbed the exclusive lock, and tries to get a shared lock, it will block indefinitely because the lock will never be released &#8211; but at that point your ownership semantics have gone screwy anyway. If you&#8217;re deleting an object that other threads still have references to that they think are live, something else has already gone wrong. The type of lock you use won&#8217;t save you.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-hankhein even depth-3 parent" id="comment-1247825">
				<div id="div-comment-1247825" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Henri+Hein' rel='external nofollow' class='url'>Henri Hein</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247825">
			May 6, 2016 at 2:39 pm</a>		</div>

		<p>&gt; but at that point your ownership semantics have gone screwy anyway</p>
<p>That&#8217;s precisely the point.  By &#8220;destroying&#8221; the SRWLOCK, I assume they mean freeing or deleting the memory it points to.  Why would it need to acquire the lock before doing that?  Nothing else should be referencing that lock at that time.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4 parent" id="comment-1247835">
				<div id="div-comment-1247835" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247835">
			May 6, 2016 at 4:10 pm</a>		</div>

		<p>I don&#8217;t see why you&#8217;d acquire it, but if you happen to be already holding it at the time of destroy object, there&#8217;s no reason to release it either.</p>
<p>The operation went:</p>
<p>   Acquire parent<br />
   Acquire object<br />
   Do something so that object could no longer be found from parent<br />
   Release parent<br />
   If we are the last holder of a reference to the object<br />
       Destroy object</p>
<p>Where Acquire and Release kept a visible counter so &#8220;If we are the last&#8221; was trivial.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-hankhein even depth-5" id="comment-1247855">
				<div id="div-comment-1247855" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Henri+Hein' rel='external nofollow' class='url'>Henri Hein</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247855">
			May 6, 2016 at 6:13 pm</a>		</div>

		<p>I&#8217;m honestly not sure what you mean by &#8220;parent&#8221; and &#8220;object.&#8221;  The issue is recursively acquiring a slim lock.  That indicates only one lock was involved.  At least in the issue at hand.</p>
<p>From the description: &#8220;the function that destroys the object acquires the SRWLOCK in exclusive mode.&#8221;  From a purely technical reading of this, maybe acquiring the lock and destroying it are disconnected in time, but the sentence strongly implies the object is acquired just before destroying it, as though that was necessary.  If they need to acquire the lock before they destroy it, some of their other threads are going to be surprised.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1247886">
				<div id="div-comment-1247886" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247886">
			May 7, 2016 at 7:57 am</a>		</div>

		<p>It&#8217;s merely that in this case the path that would destroy a slim lock happens to be already holding the lock, and furthermore there is no need to release the lock prior to destroying it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-5" id="comment-1247896">
				<div id="div-comment-1247896" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247896">
			May 7, 2016 at 10:32 am</a>		</div>

		<p>&gt;I’m honestly not sure what you mean by “parent” and “object.” The issue is recursively acquiring a slim lock.<br />
&gt; That indicates only one lock was involved. At least in the issue at hand.</p>
<p>parent is the class that has the lock on it, object is the one that is being allocated and freed.</p>
<p>&gt;This sounds broken already! If the destructor needs to acquire the lock, then that implies that another thread might attempt to use the object while it’s being destroyed.</p>
<p>I&#8217;m not sure it is the destructor in this case, but a &#8220;function that destroys the object&#8221;. However if you have an object that spawns a thread and then later something calls delete on the object, then you have exactly that situation. Waiting until the object isn&#8217;t being used before it gets free&#8217;d is probably the only reason they added the lock in the first place.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-4" id="comment-1247926">
				<div id="div-comment-1247926" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://harryjohnston.wordpress.com' rel='external nofollow' class='url'>Harry Johnston</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247926">
			May 7, 2016 at 8:13 pm</a>		</div>

		<p>They might mean that they&#8217;re destroying the object protected by the lock, but not necessarily destroying the lock itself.  (For example, the lock might later be reused by a new iteration of the same object.)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1247955">
				<div id="div-comment-1247955" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://owenshepherd.net' rel='external nofollow' class='url'>Owen Shepherd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247955">
			May 8, 2016 at 9:25 am</a>		</div>

		<p>To me it sounds like an example of &#8216;self synchronized destruction&#8217;. Consider an object where the shared lock count is like the ref count on a ref counted object: if somebody posesses a reference, then it must be &gt;0. This means that the point at which you can acquire exclusive access is also the point at which nobody else is holding a handle to the object.</p>
<p>Such use cases are odd, but not unprecedented.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hankhein odd alt thread-even depth-1" id="comment-1247795">
				<div id="div-comment-1247795" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Henri+Hein' rel='external nofollow' class='url'>Henri Hein</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247795">
			May 6, 2016 at 1:09 pm</a>		</div>

		<p>There is a sample here that demonstrates shared locks with the C++ 11 STL synchronization objects: <a href="https://code.msdn.microsoft.com/Multiple-Readers-One-34bb3ac1" rel="nofollow">https://code.msdn.microsoft.com/Multiple-Readers-One-34bb3ac1</a></p>
<p>No doubt SRWLOCK is leaner than the STL ones, but if you need cross-platform, the STL ones are preferred.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1247936">
				<div id="div-comment-1247936" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://harryjohnston.wordpress.com' rel='external nofollow' class='url'>Harry Johnston</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247936">
			May 7, 2016 at 8:16 pm</a>		</div>

		<p>I presume this would have been easy to fix.  Just replace SRWLOCK with your own gizmo that uses SRWLOCK to do the cross-thread locking, but with a per-thread usage counter to handle the recursive case.  Or am I missing something?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1247995">
				<div id="div-comment-1247995" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247995">
			May 9, 2016 at 5:49 am</a>		</div>

		<p>&gt;Am I missing something?</p>
<p>At that point your slim lock has gained a lot of weight, and you might as well use one of the existing locks that support recursive acquisition.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1248106">
				<div id="div-comment-1248106" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1248106">
			May 9, 2016 at 9:29 am</a>		</div>

		<p>Where do you plan on putting the per-thread usage count? TLS? Or are you willing to raise an out-of-memory exception from AcquireShared?</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-sergei_vorobiev odd alt thread-even depth-1" id="comment-1247945">
				<div id="div-comment-1247945" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/sergei_vorobiev' rel='external nofollow' class='url'>sergei_vorobiev</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1247945">
			May 8, 2016 at 12:50 am</a>		</div>

		<p>This design is fundamentally broken.</p>
<p>Proper locking primitive here is akin to rundown references used available for Windows drivers. On a high level, if you have a ptr to object, you use the object as much as you want. If you want to make ptr escape your scope, you acquire a rundown ref &#8212; which can fail, which means the object is getting destroyed. The destroyer alters the state of rundown structure so further acquires fail, and waits for refcount of valid pointer holders to drain to zero.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1248605">
				<div id="div-comment-1248605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20160506-00/?p=93416#comment-1248605">
			May 13, 2016 at 12:35 am</a>		</div>

		<p>I remember using pthread_mutex or something pthread of the sort for the first time and encountering it&#8217;s non-recusive nature. The specific  OS had &#8220;_r&#8221; vetsions that would work the same as windows critical sections, but it was easy to change things to work. (private method with a precondition that the lock is held before calling.)</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>