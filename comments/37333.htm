<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (74)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-224513">
				<div id="div-comment-224513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeproject.com/script/articles/list_articles.asp?userid=152' rel='external nofollow' class='url'>Mike Dunn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224513">
			November 11, 2004 at 10:52 am</a>		</div>

		<p>Another handy tip is that in C++ method calls, &#8216;this&#8217; is stored in the ECX register (at least, MSVC does it that way). If you&#8217;re tracking down a method call that blows up due to a bad &#8216;this&#8217; pointer, look at the assembly and watch how ECX gets set.</p>
<p>Also when you&#8217;re debugging in VC (with source), hit Ctrl+F11 to switch between source and source+assembly views.</p>
<p>Add a watch for &quot;@ERR,hr&quot; to see the value of GetLastError(). Add a watch for &quot;@EAX,hr&quot; to have a permanent place to look for function return values. The &quot;,hr&quot; part means &quot;show as HRESULT&quot;, which also gives you a text description of the number if one is available.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224523">
				<div id="div-comment-224523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224523">
			November 11, 2004 at 11:02 am</a>		</div>

		<p>Pah, source-level debugging! Once the optimizer&#8217;s done with your code source-level debugging is useless.</p>
<p>You youngsters have it so easy&#8230; don&#8217;t even bother learning your HRESULTs, make the debugger decode them for you.. function keys do all the typing for you&#8230; lazy good-for-nothings&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224533">
				<div id="div-comment-224533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene Hamilton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224533">
			November 11, 2004 at 11:04 am</a>		</div>

		<p>I have noticed in debug builds that the compiler will pad the area around the stack with CC&#8217;s  Is that there to help people detect bad code early on, or for some other reason?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224543">
				<div id="div-comment-224543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224543">
			November 11, 2004 at 11:18 am</a>		</div>

		<p>For me, 0xEA is forever NOP.</p>
<p>I first programmed assembly on a 6502, without such luxuries as a disassembler or single-stepping debugger.  You&#8217;ve got it easy.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224563">
				<div id="div-comment-224563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nerd-style</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224563">
			November 11, 2004 at 11:22 am</a>		</div>

		<p>Raymond &#8211; do you have a good recommendation for an x86 programming book?  At the U we did all of our assembly programming on 68K chips (mostly for embedded microprocessor classes), and I&#8217;d love to reaquaint myself with the finer points of x86 machine assembly.</p>
<p>Of course, a book that is more Windows-centric would be preferred.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224553">
				<div id="div-comment-224553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene Hamilton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224553">
			November 11, 2004 at 11:28 am</a>		</div>

		<p>Funny you mention the 6502.</p>
<p>I was just going through all my old 6502 manuals and asm programs about an hour ago.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224573">
				<div id="div-comment-224573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224573">
			November 11, 2004 at 11:43 am</a>		</div>

		<p>@nerd-style:</p>
<p>If you want to learn X86 assembly, a good start is viewing the assembler generated by the compiler for a given construct.  Also, download the IA32 instruction set references (both A-M and N-Z) and the other docs from Intel:</p>
<p><a target="_new" href="http://www.intel.com/design/pentium4/specupdt/252046.htm" rel="nofollow">http://www.intel.com/design/pentium4/specupdt/252046.htm</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224593">
				<div id="div-comment-224593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224593">
			November 11, 2004 at 12:08 pm</a>		</div>

		<p>Or you could install comet cursors on a test box and figure out the myriad ways it breaks things in the shell. I hear that&#8217;s good for hours of fun.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224613">
				<div id="div-comment-224613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224613">
			November 11, 2004 at 12:27 pm</a>		</div>

		<p>No I didn&#8217;t. I haven&#8217;t done source-level debugging since my college days.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224603">
				<div id="div-comment-224603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224603">
			November 11, 2004 at 12:29 pm</a>		</div>

		<p>Raymond, you forgot to say &quot;Back in my day&#8230;&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224623">
				<div id="div-comment-224623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://http:://palmos.combee.net/' rel='external nofollow' class='url'>Ben Combee</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224623">
			November 11, 2004 at 12:37 pm</a>		</div>

		<p>The 0xCC fill done in debug code is to help identify uninitialized variables.  Since 0xCC is an unlikely value, seeing a variable with that byte in the debugger means it&#8217;s likely that it hasn&#8217;t been changed by the program.  Also, the address 0xCCCCCCCC isn&#8217;t likely to be a valid pointer, whereas having an uninitialized stack means it&#8217;s possible your uninitialized pointer might just overlap with a previous pointer value from another call.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224633">
				<div id="div-comment-224633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Allison</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224633">
			November 11, 2004 at 12:42 pm</a>		</div>

		<p>If you read the post, you&#8217;ll notice that 0xCC is the opcode for breaking into the debugger.  Not only are the values easy to notice, but if you ever run into a situation where you execute instructions on the stack, you&#8217;ll automatically kick into the debugger.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224643">
				<div id="div-comment-224643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.brandonfurtwangler.com' rel='external nofollow' class='url'>Brandon Furtwangler</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224643">
			November 11, 2004 at 1:27 pm</a>		</div>

		<p>I&#8217;m sure you have a good reason for <em>only</em> debugging this way, but I simply cant think of one.  Do tell.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224653">
				<div id="div-comment-224653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://PossibleReasons' rel='external nofollow' class='url'>Alexey Kats</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224653">
			November 11, 2004 at 1:41 pm</a>		</div>

		<p>I cannot tell anything for Raymond&#8217;s reasons, but in my experience there are at least two.</p>
<p>1) I do not always trust optimizer in the compiler &#8211; sometimes it does dirty things and throws come calculations off (I had occasional problems with rounding and mixed single-precision and double-precision calculations, for example). And trying to match optimized code to the source code is anything but fun, sometimes you are better by ignoring source code and working with machine code only instead.</p>
<p>2) Sometimes you just HAVE to debug someone else&#8217;s code which you do not have the source code for, but you have to figure out how to change YOUR code to make it work no matter what (that might be your job, and it&#8217;s unfortunately not always an option to stop using the buggy third-party code).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224663">
				<div id="div-comment-224663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224663">
			November 11, 2004 at 1:51 pm</a>		</div>

		<ol>
<li>Once the optimizer has messed with your code source level debugging falls apart.
<p>2. Most debugging is done remotely.  When you have to debug a customer&#8217;s machine 5000 miles away over a 56k modem, you can&#8217;t tell them, &quot;First, I want you to install Visual Studio on your domain controller&#8230;&quot;</p>
<p>3. Installing a GUI debugger on the test machine changes the system configuration and therefore influences the test itself. Imagine if Windows XP had some horrific bug that goes away when you install Visual Studio. If all test machines had Visual Studio installed on them, then this bug would never be found!</p>
<p>4. Just today I had to debug a problem that occurred only immediately after installing the OS. No chance to install VS even if you wanted to.</p>
<p>5. If you&#8217;re debugging the OS itself (say the window manager), then you can&#8217;t use a GUI debugger since it needs the window manager to draw its UI!</p>
<p>Conclusion: Since so much debugging is done in situations where GUI debugging is not possible, you are quickly forced to become an expert at command line debugging. At which point the incremental benefit of a fancy debugger is rather small.</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224673">
				<div id="div-comment-224673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">chadbee</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224673">
			November 11, 2004 at 1:58 pm</a>		</div>

		<p>The Windows debugger includes a command, &quot;a&quot;, which eliminates the need to memorize these opcodes. </p>
<p>Just type &quot;a &lt;address&gt;&quot; where &lt;address&gt; is where you want to insert the new assembly opcode, and you&#8217;ll then get prompted for what you want to put there. </p>
<p>Example, just picking a random jump instruction in Notepad and replacing it with a nop: </p>
<p>0:001&gt; u notepad!Search+0x11<br />
<br />notepad!Search+0x11:<br />
<br />0100595d 895de8 mov [ebp-0x18],ebx<br />
<br />01005960 895dec mov [ebp-0x14],ebx<br />
<br />01005963 7507 jnz notepad!Search+0x20 (0100596c)<br />
<br />01005965 33c0 xor eax,eax<br />
<br />01005967 e9cb010000 jmp notepad!Search+0x1eb (01005b37)<br />
<br />0100596c 56 push esi<br />
<br />0100596d 8b3540120001 mov esi,[notepad!_imp__SendMessageW (01001240)]<br />
<br />01005973 57 push edi </p>
<p>0:001&gt; a 01005963<br />
<br />01005963 nop<br />
<br />nop<br />
<br />01005964 nop<br />
<br />nop<br />
<br />01005965 </p>
<p>0:001&gt; u notepad!Search+0x11<br />
<br />notepad!Search+0x11:<br />
<br />0100595d 895de8 mov [ebp-0x18],ebx<br />
<br />01005960 895dec mov [ebp-0x14],ebx<br />
<br />01005963 90 nop<br />
<br />01005964 90 nop<br />
<br />01005965 33c0 xor eax,eax<br />
<br />01005967 e9cb010000 jmp notepad!Search+0x1eb (01005b37)<br />
<br />0100596c 56 push esi<br />
<br />0100596d 8b3540120001 mov esi,[notepad!_imp__SendMessageW (01001240)]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224683">
				<div id="div-comment-224683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224683">
			November 11, 2004 at 2:52 pm</a>		</div>

		<blockquote><p>
  Most debugging is done remotely. When you<br />
  <br />&gt; have to debug a customer&#8217;s machine 5000<br />
  <br />&gt; miles away over a 56k modem, you can&#8217;t tell<br />
  <br />&gt; them, &quot;First, I want you to install Visual<br />
  <br />&gt; Studio on your domain controller&#8230;&quot; </p>
<p>If you use windbg you can do remote source level debugging without installing anything on the remote machine. All you need to do is copy the files from the debugger directory and start dbgsrv.exe. Then you start windbg on your local machine and connect to the server. Since the actual debugger runs locally, there&#8217;s no need to copy symbols or source files to the remote machine.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224693">
				<div id="div-comment-224693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224693">
			November 11, 2004 at 3:03 pm</a>		</div>

		<p>*this is only stored in CX for one particular calling convention (admittedly the most common for conventional VC C++ code).  What is way more fun is dealing with programs that dynamically load zillions of DLLs, which load other DLLs, have layers of service providers, and are written in C and C++ with liberal amounts of COM and RPC thrown in.  And have many threads, with large numbers of mutexes and other forms of lock.  The optimising compiler then makes it just that little bit more interesting by interpolating the simple instruction stream by register and data dependency so that the CPU can do register renaming and get a higher ILP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224723">
				<div id="div-comment-224723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jeffdav' rel='external nofollow' class='url'>jeffdav</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224723">
			November 11, 2004 at 3:25 pm</a>		</div>

		<p>You can make ntsd show you the source for whatever line your are stepping through&#8230; that doesn&#8217;t count as source level?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224733">
				<div id="div-comment-224733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224733">
			November 11, 2004 at 3:45 pm</a>		</div>

		<p>chadbee: You still need to know the lengths of the instructions if you are patching some existing code, so you might as well just write it in machine code in the first place.</p>
<p>Pavel Lebedinsky: Neat.  Some time ago, I ended up writing a WinDbg extension that (among other things) had some commands to allocate debuggee VM for that sort of stuff.  I suppose it&#8217;s becoming partially obsolete now that .dvalloc is built-in.  Oh well.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224783">
				<div id="div-comment-224783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">n7yap</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224783">
			November 11, 2004 at 4:26 pm</a>		</div>

		<p>A couple of 32-bit x86 assembly language books. These are used for college courses, good for learning assembly language.</p>
<p>&quot;Assembly Language for Intel-Based Computers&quot;<br />
<br />Fourth Edition<br />
<br />Irvine</p>
<p>&quot;80&#215;86 Assembly Language and Computer Architecture&quot;<br />
<br />Detmer</p>
<p>The Intel Pentium Instruction Set manuals are a necessity. </p>
<p>Check out [url]<a target="_new" href="http://www.masm32.com" rel="nofollow">http://www.masm32.com</a>[/url]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224793">
				<div id="div-comment-224793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fa Eb Fe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224793">
			November 11, 2004 at 5:03 pm</a>		</div>

		<p>I was going to make some pithy remark like &quot;if machine code isn&#8217;t the only way you program, it shouldn&#8217;t be the only way you debug&quot; before I realised what a broad and variable meaning &#8216;debugging&#8217; has.</p>
<p>Is debugging by examining output instead of instructions legitimate? I&#8217;d argue it&#8217;s the only legitimate way: 1) code in interrupts this, 2) kernel that, 3) processors with uploadable microcode the other, etc, etc. (This argument is as unuseful as yours.)</p>
<p>I&#8217;m not sure how you reconcile your earlier comment&#8217;s points 4 and 5 (can&#8217;t always install a debugger) with point 2 (debugging is done remotely). Graphical debuggers can be used remotely. I&#8217;m also very wary of point 3, because any debugging can create a Heisenberg effect.</p>
<p>There&#8217;s a place for debugging at source level. This blog has exceptionally high standards, but the occasional mistake as well. No matter how readily you can interpret disassembly or machine code (on a given architecture), you must ultimately map back to the source code in the majority of cases &#8211; why create the extra work.</p>
<p>I bet it took you ages before you could debug on IA64, while all your Visual Studio -using chums were productive sooner. Low level debugging has a place and is an admired skill, but high level debugging and chosing the best tools for a job are also skills.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224803">
				<div id="div-comment-224803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224803">
			November 11, 2004 at 5:38 pm</a>		</div>

		<p>4 vs 5: Debugging is done remotely, which means that you have to convince the guy at the other end to install the remote part of the debugger. This is not always feasible. Better to use something that is already installed (ntsd.exe).</p>
<p>I have never used Visual Studio. I gave up when I hit &quot;next line&quot; in CodeView and the cursor jumped upwards ten lines, and then you ask to look at a local variable and you get garbage. How anybody source-level debugs optimized code I have no idea.</p>
<p>(I was debugging ia64 code in 2000.  When did Visual Studio support for ia64 show up?)</p>
<p>Do you use the Qwerty keyboard? Why don&#8217;t you switch to Dvorak? It&#8217;s much better.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224813">
				<div id="div-comment-224813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://glob.com.au/byron/science/asm.shtml' rel='external nofollow' class='url'>byron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224813">
			November 11, 2004 at 5:39 pm</a>		</div>

		<p>on a similar note, here&#8217;s list of my favourite assembler interrupts:</p>
<p>int 10h service 4<br />
<br />read light pen position</p>
<p>int 13h service 19h<br />
<br />park heads ps/2 only</p>
<p>int 15h<br />
<br />cassette i/o</p>
<p>int 18h<br />
<br />resident basic</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224833">
				<div id="div-comment-224833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224833">
			November 11, 2004 at 7:48 pm</a>		</div>

		<p>Btw, I&#8217;m 100% with Raymond here.  Source level debugging is a crutch.</p>
<p>I do use source level debugging (with windbg), because it&#8217;s convenient, but all of my debugging of my service is done with NTSD (which means assembly language).</p>
<p>The optimizer totally screws up any hope of debugging code, and for my code, the optimizer&#8217;s always on.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224853">
				<div id="div-comment-224853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224853">
			November 11, 2004 at 8:51 pm</a>		</div>

		<p>The thing I would be happiest with is a debugger that could run code backwards (ie it would keep saving state and allow you to unwind to see what happened).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224873">
				<div id="div-comment-224873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.digitalfanatics.org' rel='external nofollow' class='url'>Johan Thelin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224873">
			November 11, 2004 at 10:18 pm</a>		</div>

		<p>Here are two links for thow of you who&#8217;d like to try out win32 from assembler:</p>
<p><a target="_new" href="http://personal5.iddeo.es/ret007ow/articles.html" rel="nofollow">http://personal5.iddeo.es/ret007ow/articles.html</a><br />
<br /><a target="_new" href="http://win32asm.cjb.net/" rel="nofollow">http://win32asm.cjb.net/</a></p>
<p>Beware, these pages are not wonders of layout and style, but kind of fun to read :).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224883">
				<div id="div-comment-224883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/mgrier' rel='external nofollow' class='url'>Michael Grier</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224883">
			November 11, 2004 at 10:55 pm</a>		</div>

		<p>I&#8217;ll go one further.  Debugging with a user mode debugger is a real pain in the ass.  You often can&#8217;t get symbols etc. etc.  It turns out that if you&#8217;re careful you can almost always just do what you want with kd.  Debugging stress problems with kd is tons easier than the equivalent with a source level debugger.</p>
<p>You just have to remember that when a piece of VA is shared across processes, doing tricks like Raymond suggests in the base blog affect all processes.  My team harangued the debugger team enough during XP that there are a lot of options in KD to localize kernel mode set breakpoints to certain processes or threads.</p>
<p>I think that being able to get the source line from the debugger so I can look for it is helpful but I&#8217;m mostly with Raymond.  When I am toying around with an idea I build it without optimizations and use visual studio (having worked on it some years ago&#8230;).  But in the end, when you&#8217;re in a crunch, you&#8217;re going to find a time when you need to debug without symbols so if you&#8217;re hung up on source level debugging and user mode debuggers you&#8217;re just putting hurdles in your own way.</p>
<p>Things are much better than when Raymond first tried though.  The last major PDB format change fixed a bunch of the scoping problems for local variable definitions so examining locals (dv) is an order of magnitude more reliable now.  The windbg UI is enough better that even if you&#8217;re not interested in source level debugging, having windows for the current call stack, registers, memory, etc is nice.</p>
<p>But at the end of the day, if there&#8217;s an important break and all you have is a kernel debugger without symbols, you&#8217;ve got to just roll up your sleeves and figure it out.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224893">
				<div id="div-comment-224893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/mgrier' rel='external nofollow' class='url'>Michael Grier</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224893">
			November 11, 2004 at 10:56 pm</a>		</div>

		<p>Oh and if you need to break in, &quot;ba e1 &lt;addr&gt;&quot; sets a bp that doesn&#8217;t change memory.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224903">
				<div id="div-comment-224903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224903">
			November 11, 2004 at 11:00 pm</a>		</div>

		<p>I use cdb 99% of the time but it&#8217;s not because I don&#8217;t believe in source level debugging. It just so happens that for many types of problems command line UI works just fine. Things like crashes, deadlocks, resource leaks and CPU hogging can in most cases be debugged without having to step through source code.</p>
<p>But there definitely are cases when VS or windbg are really helpful, even if your local variables are all messed up and statements are executed out of order.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224703">
				<div id="div-comment-224703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224703">
			November 11, 2004 at 3:06 pm</a>		</div>

		<p>By the way, in the recent debuggers you can use .dvalloc command to allocate some scratch space in the target address space and copy the code you&#8217;re going to be messing with there. Then if you want to revert your changes, you simply copy it back:</p>
<p>0:000&gt; .dvalloc /b 40000000 1000<br />
<br />Allocated 1000 bytes starting at 40000000</p>
<p>0:000&gt; * copy first 32 bytes of CreateMutexW to 0x40000000<br />
<br />0:000&gt; m kernel32!CreateMutexW L20 40000000</p>
<p>0:000&gt; * Mess with CreateMutexW<br />
<br />&#8230;</p>
<p>0:000&gt; * restore original code<br />
<br />0:000&gt; m 40000000 L20 kernel32!CreateMutexW</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224923">
				<div id="div-comment-224923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224923">
			November 11, 2004 at 11:44 pm</a>		</div>

		<p>Btw, once you get close to shipping, your only opportunity to find most bugs is debugging a crashed machine.  If your front end system crashes every three days, but only after having been running for those three days, the vice president isn&#8217;t going to say &quot;Ok, we&#8217;ll install visual studio and hope and pray it reproduces, never mind that we&#8217;re losing millions of dollars for every minute our mission critical system is down&quot;.  They&#8217;re going to say &quot;I want a fix for this problem TOMORROW&quot;.</p>
<p>User mode debuggers are a crutch, every developer should be able to debug any crashed machine from assembly language.</p>
<p>Btw, for AC (who wanted to go backwards in time), actually that&#8217;s a large part of how you debug in assembly &#8211; you track the flow of data through the stack and registers &#8211; from the state of the various registers and flags, you can infer a huge amount of information about what went wrong.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224913">
				<div id="div-comment-224913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224913">
			November 11, 2004 at 11:49 pm</a>		</div>

		<p>When reverse engineering some code I find it quite usefull myself to take the assembler listing the debugger generates, and annotate it with the equialent c++.</p>
<p>A tool I&#8217;d really like would rebuild a fake pdb from that source file so I could get &quot;source&quot; level debugging going, when I have no source.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224933">
				<div id="div-comment-224933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Serge Wautier</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224933">
			November 12, 2004 at 1:07 am</a>		</div>

		<p>Larry,</p>
<p>I feel and share your pain. I&#8217;m in this exact situation right now. Even more frustrating: I have a copy of VS installed on a test machine where the problem shows up every week or so. Last time it showed up, I started VS and attached it to the process : Bang ! Both crashed ! Go figure&#8230;<br />
<br />And my problem is even worse : not only we never simulated it with debug builds, but the program <em>doesn&#8217;t</em> crash, simply there are operations scheduled internally which as of some random moment are no longer scheduled. I&#8217;d love a good and nice crash so much more !!!</p>
<p>&#8211; Serge, forever fighting&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224943">
				<div id="div-comment-224943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://hallvards.blogspot.com/2004/11/machine-code-hacking.html' rel='external nofollow' class='url'>Hallvard Vassbotn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224943">
			November 12, 2004 at 2:17 am</a>		</div>

		<p>Very nice techniques!</p>
<p>I&#8217;ve used some of them, but must admit I use source-level debugging most of the time, with the occasional low-level machine code debugging when the going gets though.</p>
<p>Added a reference here:<br />
<br />&lt;a href=&quot;<a target="_new" href="http://hallvards.blogspot.com/2004/11/machine-code-hacking.html&quot;&gt;http://hallvards.blogspot.com/2004/11/machine-code-hacking.html&lt;/a&gt;" rel="nofollow"></a><a href="http://hallvards.blogspot.com/2004/11/machine-code-hacking.html&quot;&gt;http://hallvards.blogspot.com/2004/11/machine-code-hacking.html&lt;/a&#038;gt" rel="nofollow">http://hallvards.blogspot.com/2004/11/machine-code-hacking.html&quot;&gt;http://hallvards.blogspot.com/2004/11/machine-code-hacking.html&lt;/a&#038;gt</a>;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-224953">
				<div id="div-comment-224953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224953">
			November 12, 2004 at 2:39 am</a>		</div>

		<p>&quot;The 0xCC fill done in debug code is to help identify uninitialized variables.&quot;</p>
<p>What&#8217;s wrong with good old 0xDEADBEEF ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-224973">
				<div id="div-comment-224973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-224973">
			November 12, 2004 at 4:17 am</a>		</div>

		<p>Multibyte magic values are harder to spot if the structure has unaligned and or byte or word sized  members.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225003">
				<div id="div-comment-225003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.divil.co.uk/net' rel='external nofollow' class='url'>Tim Dawson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225003">
			November 12, 2004 at 5:12 am</a>		</div>

		<p>[i]User mode debuggers are a crutch, every developer should be able to debug any crashed machine from assembly language[/i]</p>
<p>Are you saying every developer should know assembly language? I find that an absurd idea.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225023">
				<div id="div-comment-225023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Raiford</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225023">
			November 12, 2004 at 5:51 am</a>		</div>

		<p>&quot;Are you saying every developer should know assembly language? I find that an absurd idea.&quot;</p>
<p>Not at all absurd. Just like a lot of the examples here, there are many times where you CANNOT debug source-level. This means assembly is a must. </p>
<p>Granted, most of my stuff is user mode, and I can get away with using source mode to check on some of the obvious things, But that&#8217;s more just working out simple, easy to find logic errors. </p>
<p>The tougher one is when a program crashes for some unknown reason on an optimised build (I&#8217;ve had it happen.. Worked fine on the debug build, would fail miserably on the release build&#8230;) Turned out to be some subtlty with VC6&#8217;s optimizer that was fighting with my code. I wound up having to use the intel compiler instead. </p>
<p>Knowing assembly language is very useful. Optimized builds tend to do weird things like store values in registers, which, unless you&#8217;re watching the asm, you won&#8217;t know where to look for the value of a particular variable. Its also invaluable for seeing why a 3rd party library is choking when you&#8217;re sure the input is right. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225013">
				<div id="div-comment-225013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225013">
			November 12, 2004 at 5:53 am</a>		</div>

		<p>Ha. That I&#8217;d agree with. Unless youre obsessed with the word &quot;junior&quot; in your job title, familiarity with your platforms assembler is mandatory.</p>
<p>I disagree with the assertion that kernel mode debugging is a necessity. I&#8217;m quite happy debugging assembler in usermode thanks &#8211; Ive yet to encounter a bug thats exceeded my ability to track down with dev studio :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225033">
				<div id="div-comment-225033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom Seddon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225033">
			November 12, 2004 at 5:58 am</a>		</div>

		<p>Well, at least every C or C++ programmer should know the assembly language for their target platform. It&#8217;s kind of hard to get far without it, particularly when debugging optimized code.</p>
<p>Do all these kernel debugger users who eschew line numbers and information about local variables make use of any symbol information at all? If not, how do you manage to do anything useful like that? Surely you need function names at the very least&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225043">
				<div id="div-comment-225043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.whirlingdervishes.com' rel='external nofollow' class='url'>Henk Devos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225043">
			November 12, 2004 at 6:08 am</a>		</div>

		<p>I really enjoyed reading all these comments.<br />
<br />I have used a few debuffers in my life myself.<br />
<br />At uni, when doing my thesis and working on parallel procesing, all I had was a post-mortem debugger that could tell me the state f all processors. then I could start trying to figure out why they had deadlocked.<br />
<br />I have also used debuggers like CodeView.<br />
<br />At one time, when I had to figure out why an interrupt handler was crashing, the only way of debugging I could think of was putting a CC in the code so that I could see if I got so far, and by moving this CC around I could figure out which instruction was causing the crash. This worked becauzse a CC inside the interrupt handler was giving me a different error than the real crash.<br />
<br />Source level debugging is a great luxury that I want to have when ever possible. But then the debugger still has to be good. For example on Macintosh I have to use CodeWarrior and this is a very poor debugger.<br />
<br />I have to say the Visual Studio debugger is by far the best I have ever used. Not only for source level debugging but also for assembler level debugging.<br />
<br />With Visual Studio I will use source level debugging when ever possible. But of course most of the time it is not possible.<br />
<br />One of the reasons why some people don&#8217;t understand this is that debugging has a different meaning for different people.<br />
<br />For some people debugging just means finding the logical errors that you made yourself. But this is usually a trivial job. Usually what you do is just start up the program and see on which line it crashes, then you realize which variable you forgot to initialize.<br />
<br />For other people it is mostly related to finding out why the software stopped functioning after several people made uncoordinated changes to the source code. The job is basically the same as the previous case.<br />
<br />But the kind of debugging we are talking aout here, that requires assembler level debugging, is a totally different thing.<br />
<br />In the cae of Raymond I assume that many times has has to try figuring out why a certain 3rd party application doesn&#8217;t work on the new Windows version anymore. There is simply no source available in such cases.<br />
<br />Similar when you have to figure out how windows works and why a certain Windows call doesn&#8217;t work and so on. That is the inverse situation of what Raymond has to do, but this is often the case for me. There is also no source code available.<br />
<br />Raymond, I would really advise you to try the Visual Studio debugger for such cases. Once you figure out the tricks you can do amazing things with it.<br />
<br />About the optimizer problem: I think it is very rare that the problems are caused by the optimizer. It used to be the case much more in the past, but such problems have been almost eliminated.<br />
<br />Other things that can be nightmares to debug are everything related to caching: When the code runs in L1 cache it doesn&#8217;t work anymore, that kind of stuff.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225053">
				<div id="div-comment-225053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225053">
			November 12, 2004 at 6:11 am</a>		</div>

		<p>One thing about source level debugging is that it&#8217;s possible to waste time if the debugger is subtly wrong &#8211; e.g. wrong values for locals, or (worse) a bogus stack frame. The advantage of binary+symbols you know that the limited information you have is at least accurate.</p>
<p>And as the wonderful &quot;Undocumented DOS&quot; put it, the advantage about binary+symbols is that &quot;it&#8217;s almost as good as source, the only thing missing is comments which are probably misleading anyway&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225063">
				<div id="div-comment-225063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Raiford</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225063">
			November 12, 2004 at 6:13 am</a>		</div>

		<p>&quot;About the optimizer problem: I think it is very rare that the problems are caused by the optimizer.&quot;</p>
<p>True, I&#8217;ve only run into this once&#8230;</p>
<p>Actually, I think I misstated the problem. It wasn&#8217;t a crash, per s&#233;, but rather missing information in an ActiveX control I created. I turned out that due to a certain sequence of statements, the optimizer &quot;optimized-out&quot; a critical assignment&#8230; </p>
<p>The intel compiler created working code, I imagine because of different heuristics. I probably could have gotten away with compiling that one file with Optimize for size rather than Optimize for speed, but it was drawing code, so faster is better.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225383">
				<div id="div-comment-225383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Drake</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225383">
			November 12, 2004 at 10:26 am</a>		</div>

		<p>Some interesting posts here and some nice tips by Raymond.</p>
<p>However, I get the impression that not everyone moves in the same circles. Although, I sometimes drop down to assembly language while debugging, it is fairly rare.</p>
<p>I have yet to find a bug introduced by the compiler &#8211; mostly because the shops I&#8217;ve worked for disallow using the optimizer.</p>
<p>As an application level developer, all my bugs could be found through use of the source level debugging (although, I sometimes needed to drop into assembly to see the forest instead of the trees).</p>
<p>John</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225543">
				<div id="div-comment-225543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexey Kats</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225543">
			November 12, 2004 at 10:39 pm</a>		</div>

		<p>&quot;About the optimizer problem: I think it is very rare that the problems are caused by the optimizer.&quot;</p>
<p>Rare &#8211; yes, but if you have to suspect it more than twice, and changing a compiler is not an option, you kind of start minding the possiblity of such things, too.</p>
<p>Two real-life examples:</p>
<p>I was writing a function which used a floating-point constant, let&#8217;s say 123.4567. If you store it in single precision format you get one number of bits, double-precision gives you another, which makes an extremely subtle difference. But combined with several hundreds of multiply- add- round- divide- add- multiply- round- divide type of operations (no, I am not kidding) it was finally producing a number 10.5, and right before the final rounding it was 10.4999998 if double-precision was used, and 10.5000003 if single-precision was used. (The numbers are provided for demonstration purpose only, real numbers were different). I had to figure out first why exactly rounding of the final number was different for two builds of our application, and we are talking about subtle difference in one step of like several hundreds of similar iterations. Second, I had to figure out under what circumstances compiler was preferring a single-precision constant to double-precision. Third I had to GUARANTEE than no matter how you compile it the calculations are stable given the same original data (otherwise I&#8217;d be forced to check for this bug forever with each build). Not directly related to any bug in optimizer, but it was the optimization options which essentially forced compiler to chose between different data types, so debugging it was nightmare &#8211; try to match floating-point calculations in optimized and non-optimized code.</p>
<p>On another occasion our application suddenly started to crash. No special user action, no magic keys, no singing and dancing around &#8211; it was simply disappearing as a process once in a while. No logs, no messages&#8230; Turned out it was a stack overflow, which was only caused by a build with full optimization, no debug symbols, and only with specific type of corruption in user data. I ended up writing a tool which was scanning compiled machine-code, finding all places where memory was toucher on stack every 4kb to commit virtual memory for the stack segment, and deducing the amount of stack it was trying to allocate, just to catch all POSSIBLE places where it could fail. Then I have to figure out what functions in source code (it&#8217;s 2/3 of million lines of code project, not counting statically linked libraries) were responsible for these allocations. I simply had to do it, to guarantee that the problem was indeed fixed.</p>
<p>So, in both cases the problem was not CAUSED by optimizer, but SEVERED by it. First one &#8211; because  of subtle difference in the produced code (it was not a bug, but I had to figure out what&#8217;s going on nevertheless), and second one &#8211;  because I had to esentially reverse-engineer our own applications, and for that task I had a pretty much useless source-code.</p>
<p>Sorry for the misprints &#8211; I am tired.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225553">
				<div id="div-comment-225553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexey Kats</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225553">
			November 12, 2004 at 11:02 pm</a>		</div>

		<p>&quot;multiply- add- round- divide- add- multiply- round- divide&quot;</p>
<p>Oops, that was supposed to be</p>
<p>&quot;multiply &#8211; multiply &#8211; round &#8211; divide &#8211; add &#8211; multiply &#8211; round &#8211; divide&quot;</p>
<p>Sorry.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225563">
				<div id="div-comment-225563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gorgosyntheton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225563">
			November 13, 2004 at 12:40 am</a>		</div>

		<p>Source level debugging is not a crutch, it is yet another tool in the toolbox.  I recognize the need for asm level debugging, but there are also situations in which source debugging makes things easier.  If I have a logic error that reproduces in a debug build, why would I traipse through loads of asm when I can easily debug the code I wrote?</p>
<p>I don&#8217;t work on an OS or a server program, maybe that is the difference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225623">
				<div id="div-comment-225623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Pritchard</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225623">
			November 13, 2004 at 6:15 pm</a>		</div>

		<p>Erm, horses for courses, people. Developers are different, requirements are different. Your essential skill is my optional extra, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225633">
				<div id="div-comment-225633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225633">
			November 13, 2004 at 7:40 pm</a>		</div>

		<p>Keith&#8217;s right &#8211; at one point, writing assembly language was a requirement for writing fast code.  These days, the rules for making efficient code are so complicated that the compiler almost always does a better job of it than most people (there are probably a half a dozen people I&#8217;d trust to write efficient assembly language code).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225583">
				<div id="div-comment-225583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/tonyschr' rel='external nofollow' class='url'>Tony Schreiner</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225583">
			November 13, 2004 at 2:36 pm</a>		</div>

		<p>Why this is such an either/or thing? I want strong source-level debugging *and* strong assembly-level debugging. I want the debugger to offload the mundane work wherever possible *and* still allow me to go spelunking with the power of cdb and kd. I dont want to have to install anything on the machine being debugged *and* I want a great GUI on my end that leverages color, multiple windows, data visualization, etc. so that Im not confined by the linear flow of a command line debugger.</p>
<p>For example, compare OllyDbg and cdb below, both are debugging notepad.exe with no symbols or source. Notice how in OllyDbg you always can see the registers and a useful view of the stack. In the assembly window it cracks parameters and window messages, resolves callees, shows the direction of jumps, looks-up constants, etc. wherever possible.</p>
<p><a target="_new" href="http://www.tonyschr.net/images/ollydbg.png" rel="nofollow">http://www.tonyschr.net/images/ollydbg.png</a><br />
<br /><a target="_new" href="http://www.tonyschr.net/images/cdb.png" rel="nofollow">http://www.tonyschr.net/images/cdb.png</a></p>
<p>For now, WinDbg is probably the best balance between power and UI:  <a target="_new" href="http://www.tonyschr.net/images/windbg.png" rel="nofollow">http://www.tonyschr.net/images/windbg.png</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225603">
				<div id="div-comment-225603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Keith Moore [exmsft]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225603">
			November 13, 2004 at 3:13 pm</a>		</div>

		<p>&quot;Are you saying every developer should know assembly language? I find that an absurd idea.&quot;</p>
<p>There are several levels of &quot;knowing assembly language&quot;.</p>
<p>Knowing how to *read* assembly language well enough to debug compiler-generated code is an absolute must. As many people have already pointed out, there are situations in which you have no other choice. When some routine buried in a library spews chunks over your stack and your EIP ends up in the Twilight Zone, you&#8217;ll need to know enough assembly language to &quot;pick up the pieces&quot; and track down the guilty culprit.</p>
<p>Knowing how to *write* assembly language is a much less useful skill, IMHO.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225663">
				<div id="div-comment-225663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bw</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225663">
			November 14, 2004 at 12:14 am</a>		</div>

		<p>ida rocks you damn ms nerds</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225703">
				<div id="div-comment-225703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Silk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225703">
			November 14, 2004 at 3:20 pm</a>		</div>

		<p>for the person that wanted a good assembly windows reference look at the forums here: <a target="_new" href="http://win32asmboard.cjb.net/" rel="nofollow">http://win32asmboard.cjb.net/</a>.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225693">
				<div id="div-comment-225693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Hearn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225693">
			November 14, 2004 at 11:52 am</a>		</div>

		<p>printf debugging is what I normally rely on: I have to assume that checked Windows builds have some kind of logging framework built in. Obviously logging can *also* affect the bug if it&#8217;s timing related, but there are lots of bugs where it&#8217;s not really possible to use assembly level debugging because the effects are quite abstract, and the best way to figure it out is to examine a debug trace.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-225833">
				<div id="div-comment-225833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225833">
			November 15, 2004 at 8:41 am</a>		</div>

		<p>&quot;So, in both cases the problem was not CAUSED by optimizer, but SEVERED by it.&quot;</p>
<p>I have a recent story about one of these myself. I had an application that, only when compiled for release, was periodically failing to update the window during resize.</p>
<p>For context, The normal way the window in my app gets redrawn is as follows:<br />
<br />1) open the back buffer<br />
<br />2) draw into the back buffer<br />
<br />3) copy the back buffer into the window<br />
<br />4) close the back buffer</p>
<p>Basically, step 1 was periodically failing with &quot;buffer already open&quot; errors. Therefore, step 3 was periodically failing to run on subsequent redraws. Step 3 was enclosed in the equivalent of a &quot;finally&quot; block, which, in my little interpreter, is implemented as a pointer from the C stack to a function object that gets called when the stack gets unwound. After some investigative work, it turned out that when step 3 failed to run, this stack pointer pointed to null, rather than to the expected function to close the back buffer. A &quot;break on write&quot; revealed that the function was being nulled out by my garbage collector, which was a suprise since the the GC traversed the stack looking for object pointers, and my buffer close function should therefore have been considered referenced.</p>
<p>The problem stemmed from the way I determined the beginning of the stack.  Basically, in WinMain, I grabbed a pointer to a local variable, and considered that to be a close enough guess to the beginning of the stack and used that during garbage collection to define the range of addresses occupied by the stack. However, in release builds, the compiler took one of my initialization functions (with a couple huge local variables) and inlined it into WinMain, thereby enlarging the local variable space in WinMain. Due to the way local variables were allocated, this changed my guess of the stack base by a couple thousand bytes. During window redraws, the pointer to my buffer close function happened to be in the area of the stack that was not traversed. So, when the GC was invoked and the back buffer was open, the close-the-back-buffer function was considered unreferenced, garbage collected, and thereby failed to run. Subsequent calls to open-the-back-buffer would then fails</p>
<p>The root cause was my mediocre attempt to compute a stack base address, but the optimizer made it a lot worse in an unexpected way.</p>
<p>BTW, anybody have a good way to reliably compute the base address of the runtime stack of the main thread under windows? ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-225853">
				<div id="div-comment-225853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Florian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-225853">
			November 15, 2004 at 8:59 am</a>		</div>

		<p>If only x86 assembly wasn&#8217;t so weird. Not the instructions, but you have only like 8 (?) registers which have funny names. So far I haven&#8217;t got used to that. Good thing my target platform is a PPC. That assembly looks less threatening to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-226013">
				<div id="div-comment-226013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Silk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-226013">
			November 15, 2004 at 1:59 pm</a>		</div>

		<p>8 32-bit ones, I believe there are lots of other ones when you go into the MMX and other acronyms &#8230; (SSE, FPU, &#8230;)</p>
<p>I think the names have reasonable definitions when you find them &#8230; ESI Extended Stack Something ? EAX &#8211; Extended Accumulator ? Hopefully someone can chime in with the real definitions :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-226213">
				<div id="div-comment-226213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Justin Cobb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-226213">
			November 16, 2004 at 5:51 am</a>		</div>

		<p>I have seen a few times MSVC use 0xbadf00d for dodgy pointers. hehe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-226523">
				<div id="div-comment-226523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Johan Johansson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-226523">
			November 16, 2004 at 11:42 am</a>		</div>

		<p>Wow, what a bunch of posers. I&#8217;m sure there are scenarios where the only choice is to debug the machine code and even more where it is preferable, but claiming that the only way to debug something is to look at the disassembly with kd and watch the binary representations of your data types &quot;flow&quot; through the registers? That&#8217;s about as clever as reading a book by examining it&#8217;s molecular structure.</p>
<p>As for debugging optimized code that&#8217;s a moot point since MSVC&#8217;s optimizations can&#8217;t be trusted to begin with. At least that has been the story so far &#8211; vs2005 seems a giant leap in every other respect so I haven&#8217;t given up on it yet. But currently I wouldn&#8217;t go above inlining in a shipping product.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-226543">
				<div id="div-comment-226543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steven C.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-226543">
			November 16, 2004 at 12:06 pm</a>		</div>

		<p>For those seeking backwards-in-time debugging:</p>
<p><a target="_new" href="http://www.ghs.com/products/timemachine.html" rel="nofollow">http://www.ghs.com/products/timemachine.html</a></p>
<p>Sadly, unavailable (at present) for windows debugging. </p>
<p>N.B.: Debugging optimized code is hard, but there&#8217;s no reason a debugger can&#8217;t do it &quot;sufficiently&quot; well, giving the developer the advantage of source code and low level information.  You just have to want that. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-226723">
				<div id="div-comment-226723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-226723">
			November 16, 2004 at 4:47 pm</a>		</div>

		<p>11/16/2004 12:06 PM Steven C.</p>
<p>&gt; For those seeking backwards-in-time<br />
<br />&gt; debugging: </p>
<p>Oh, I thought that was a joke, but it&#8217;s a real product, just with a joke name.  Of course it doesn&#8217;t look all that different from the kind of traceback that ICE can provide, but of course it&#8217;s often[*] advantageous to get it at source level and store a longer history than ICE used to do.</p>
<p>[* often != 0 &amp;&amp; often != 1]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-227363">
				<div id="div-comment-227363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gary Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-227363">
			November 17, 2004 at 3:19 pm</a>		</div>

		<p>I can&#8217;t believe you &#8216;optimizer always on&#8217;, machine-code debugger guys are serious. You can&#8217;t possibly debug any significant size project in this fashion.</p>
<p>And before anybody starts making cracks about me being a source debugging sissy, I&#8217;m maintaining an OS/2 device driver written in 18,000 lines of assembly language. No frickin&#8217; debugger at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-227373">
				<div id="div-comment-227373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-227373">
			November 17, 2004 at 3:32 pm</a>		</div>

		<p>&quot;You can&#8217;t possibly debug any significant size project in this fashion.&quot; </p>
<p>Shhh, don&#8217;t tell the Windows team. Not all debugging is done at asm-level, but a significant chunk is. They&#8217;d be pretty disheartened to learn that what they&#8217;re doing is impossible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-228163">
				<div id="div-comment-228163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/george_v_reilly' rel='external nofollow' class='url'>George V. Reilly</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-228163">
			November 19, 2004 at 2:16 pm</a>		</div>

		<p>Matt Pietrek published two useful articles in MSJ several years ago: Just Enough Assembly Language to Get By, Parts I and II.<br />
<br /><a target="_new" href="http://www.microsoft.com/msj/0298/hood0298.aspx" rel="nofollow">http://www.microsoft.com/msj/0298/hood0298.aspx</a><br />
<br /><a target="_new" href="http://www.microsoft.com/msj/0698/hood0698.aspx" rel="nofollow">http://www.microsoft.com/msj/0698/hood0698.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-228243">
				<div id="div-comment-228243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jason Geffner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-228243">
			November 21, 2004 at 12:18 am</a>		</div>

		<blockquote><p>
  do you have a good recommendation for an x86<br />
  <br />&gt; programming book?</p>
<p>The Art of Assembly Language can be downloaded for free in PDF format: <a target="_new" href="http://webster.cs.ucr.edu/AoA/DOS/pdf/0_AoAPDF.html" rel="nofollow">http://webster.cs.ucr.edu/AoA/DOS/pdf/0_AoAPDF.html</a><br />
  <br />Alternatively, you can look at in HTML format (which I prefer for searching): <a target="_new" href="http://webster.cs.ucr.edu/AoA/DOS/AoADosIndex.html" rel="nofollow">http://webster.cs.ucr.edu/AoA/DOS/AoADosIndex.html</a></p>
<p>&gt; ida rocks you damn ms nerds</p>
<p>Yes, it does, but not for debugging :)<br />
  <br />(at least not yet)
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-228483">
				<div id="div-comment-228483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-228483">
			November 22, 2004 at 6:22 am</a>		</div>

		<p>mschaef: Use something like this:</p>
<p>void * get_stack_base() {<br />
<br />     MEMORY_BASIC_INFORMATION mem_info;<br />
<br />     VirtualQuery(&amp;mem_info, &amp;mem_info, sizeof(mem_info));<br />
<br />     return (char *)mem_info.BaseAddress + mem_info.RegionSize;<br />
<br />}<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-231333">
				<div id="div-comment-231333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://nationalentity2@yahoo.com' rel='external nofollow' class='url'>ade</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-231333">
			November 30, 2004 at 9:16 am</a>		</div>

		<p>PLs, can somebody introduce me into wrtting in machine codes and assembly codes. Thansk</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-233963">
				<div id="div-comment-233963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom Canham</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-233963">
			December 11, 2004 at 1:46 am</a>		</div>

		<p>That&#8217;s what I love about sweeping generalizations &#8212; they&#8217;re all wrong.</p>
<p>*wink*</p>
<p>Does every programmer need to know assembly?  Of course not.  There are plenty of productive programmers out there who don&#8217;t have the faintest clue what assembly language their code creates, and aren&#8217;t interested in learning.  Are they *bad* programmers?  &quot;Bad&quot; is a religious question, and I stay out of religious debates. </p>
<p>Remember when C++ was for wimps, and true coders wrote in C?<br />
<br />Remember when C was for wimps, and true coders wrote in asm?<br />
<br />Remember when asm was for wimps, and true coders wrote in machinecode?<br />
<br />Remember when machine code was for wimps, and true coders &quot;coded&quot; by flipping toggle switches?<br />
<br />Remember when toggle switches were for wimps, and true coders &quot;coded&quot; by swapping out carefully carved gears?</p>
<p>Okay, I&#8217;m getting ridiculous, but the point is that that debate is silly &#8212; it&#8217;s like the definition of a &quot;real man&quot; &#8212; every man wants to be included in that definition, and to exclude as many others as possible.  It&#8217;s just a pissing match.</p>
<p>Now, back to reality.  My *opinion* is that truly clever people use whatever tool is *best suited to the job*.</p>
<p>I have done a *lot* of kernel debugging.  I spent three years in PSS doing top-tier blue screen analysis from WinNT 3.5 through Win2k.  Kernel debugging is the *ultimate* in power &#8212; every value of every variable anywhere in the system can be accessed, somehow, through kd.</p>
<p>It&#8217;s also a *pain* &#8212; in ntsd I can just look at ebp-whatever to see a local.  In kd I have to do that, then map the VM to PM, read the PM, etc.  Does that make it bad?  Of course not.  But it DOES mean that unless you&#8217;ve got a problem that&#8217;s nigh-insoluble in kernel mode, using kd just for some macho factor is, well, stupid.</p>
<p>Source level debugging used to be horrible, horrible, horrible.  When I worked in PSS, we all laughed at Visual Studio and its silly attempts to track locals through optimized code.  Yes, you could source level debug, but 90% of the time (or more), the info you saw was completely wrong.</p>
<p>Guess what?  Times have changed.  With new PDB formats, new debugger support, and compiler tweaks to help the debugger out, source level debugging is pretty damned good.  It&#8217;s not perfect.  True optimization is lossy; and when information is lost, it&#8217;s LOST.  But the good news is that at least now the debuggers have a good idea of the *lifetime* of information&#8217;s validity, so you can at least see &quot;unknown&quot; or something rather than some wrong (and possibly misleading) value.  If you haven&#8217;t source level debugged in a while, I&#8217;d encourage it.</p>
<p>And source level isn&#8217;t just for VS weenies either &#8212; Windbg and (I think) ntsd and (maybe?) kd do it now too.  The functionality is *finally* starting to coagulate into libraries and dll&#8217;s shared across teams at Microsoft.  So *finally* we&#8217;re seeing a coherent debugging picture, and thank god for that!</p>
<p>So in conclusion for this massive post &#8212; I think that coders tend to be a tad insecure.  We all want to think we&#8217;re &quot;l33t&quot; super coders, and everyone else is just a wannabe.  But remember that there are many solutions to most problems, and it&#8217;s not a matter of finding the One True Path, but rather trying to figure out what the most efficient solution to a given problem will be, for you.</p>
<p>Hell, I&#8217;m even using C# more and more these days &#8212; I actually *like* .Net.  Times change!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239693">
				<div id="div-comment-239693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/archive/2005/01/06/347754.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-239693">
			January 6, 2005 at 11:43 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246723">
				<div id="div-comment-246723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://msmvps.com/kernelmustard/archive/2005/01/19/33212.aspx' rel='external nofollow' class='url'>Kernel Mustard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-246723">
			January 19, 2005 at 9:14 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-248313">
				<div id="div-comment-248313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://msmvps.com/kernelmustard/archive/2005/01/22/33603.aspx' rel='external nofollow' class='url'>Kernel Mustard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-248313">
			January 22, 2005 at 8:21 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-248323">
				<div id="div-comment-248323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://msmvps.com/kernelmustard/archive/0001/01/01/33603.aspx' rel='external nofollow' class='url'>Kernel Mustard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-248323">
			January 22, 2005 at 8:22 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-634353">
				<div id="div-comment-634353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.testing.cc/%e6%b5%8b%e8%af%95%e6%8a%80%e6%9c%af/77.htm' rel='external nofollow' class='url'>?????????????????????BUG??????????????????????????? | ?????????????????????</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20041111-00/?p=37333#comment-634353">
			May 30, 2008 at 3:02 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.testing.cc/%e6%b5%8b%e8%af%95%e6%8a%80%e6%9c%af/77.htm" rel="nofollow">http://www.testing.cc/%e6%b5%8b%e8%af%95%e6%8a%80%e6%9c%af/77.htm</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>