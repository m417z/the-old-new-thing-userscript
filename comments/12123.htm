<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (98)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-878663">
				<div id="div-comment-878663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sean Kearney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878663">
			December 3, 2010 at 7:08 am</a>		</div>

		<p>I do have one comment to keep in mind. &nbsp; the application&#39;s processing if it requires Disk I/O in any way shape or form should not eat 100% cpu&#8230; Hey 95% is good but you HAVE to leave SOMETHING for the Kernel to do it&#39;s job :)</p>
<p>Failing that, set the affinity so the app doesn&#39;t steal all the core (Oooooo that was ALMOST a &quot;you know who&quot; joke) ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878653">
				<div id="div-comment-878653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sean Kearney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878653">
			December 3, 2010 at 7:08 am</a>		</div>

		<p>I do have one comment to keep in mind. &nbsp; the application&#39;s processing if it requires Disk I/O in any way shape or form should not eat 100% cpu&#8230; Hey 95% is good but you HAVE to leave SOMETHING for the Kernel to do it&#39;s job :)</p>
<p>Failing that, set the affinity so the app doesn&#39;t steal all the core (Oooooo that was ALMOST a &quot;you know who&quot; joke) ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878673">
				<div id="div-comment-878673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff Zarnett</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878673">
			December 3, 2010 at 7:19 am</a>		</div>

		<p>I think there is another scenario users might have in mind where 100% CPU-usage can be a problem. Suppose you have a process that goes to 100% CPU, for whatever reason. If the user wants to cancel the action or end the program, doing so can be a painful experience. While that application takes 100% CPU, even getting the UI elements to be drawn on the screen (e.g., &quot;are you sure you want to cancel?&quot;-dialog) can take a very long time, and even after the user manages to order the cancellation, it can take a while for that to take effect too.</p>
<p>I have seen situations where if a process goes to 100% CPU it&#39;s faster just to hit the reset-button on the front of the case than to wait for task manager to come up, select the offending process, and order its termination.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878683">
				<div id="div-comment-878683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff Zarnett</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878683">
			December 3, 2010 at 7:20 am</a>		</div>

		<p>I think there is another scenario users might have in mind where 100% CPU-usage can be a problem. Suppose you have a process that goes to 100% CPU, for whatever reason. If the user wants to cancel the action or end the program, doing so can be a painful experience. While that application takes 100% CPU, even getting the UI elements to be drawn on the screen (e.g., &quot;are you sure you want to cancel?&quot;-dialog) can take a very long time, and even after the user manages to order the cancellation, it can take a while for that to take effect too.</p>
<p>I have seen situations where if a process goes to 100% CPU it&#39;s faster just to hit the reset-button on the front of the case than to wait for task manager to come up, select the offending process, and order its termination.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878693">
				<div id="div-comment-878693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878693">
			December 3, 2010 at 7:27 am</a>		</div>

		<p>Jeff, in my experience, most 100% CPU programs only do that when they jack their thread priority up too high before spinning. The more typical case is all physical memory being exhausted and the page file being hammered.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878703">
				<div id="div-comment-878703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Kohne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878703">
			December 3, 2010 at 7:28 am</a>		</div>

		<p>The users who want to never see 100% CPU utilization are the same ones who get freaked out by Win 7 using all their memory to pre-fetch stuff they might need later. What they probably really want is for the UI to remain responsive so that they can do things like cancel when things aren&#39;t working right. But they have no idea what it is they want, they just know there&#39;s a number, and it&#39;s high, and when it&#39;s not high the thing works more like what they want.</p>
<p>A little introspection on the user&#39;s part would go a long way, but that&#39;s a lot to ask of some people.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878713">
				<div id="div-comment-878713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878713">
			December 3, 2010 at 7:32 am</a>		</div>

		<p>I have so much free CPU time that it seems to put in extra effort rendering blog posts, putting them up twice seemingly just to prove that none of the bits are in error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878723">
				<div id="div-comment-878723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Euro Micelli</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878723">
			December 3, 2010 at 7:34 am</a>		</div>

		<p>Sean Kearney: I&#39;m not sure what you are pointing at. If the I/O is synchronous, the kernel will &quot;do its job&quot; during the API call; from your point of view it&#39;s all one flow of execution. Even if the I/O is asynchronous, the program can loop around calculating pi digits to its heart&#39;s content and the scheduler will still allocate processor time to the kernel as needed &#8212; of course you might not get 100% processor associated to your application anymore, but who cares? The CPU is still fully utilized (ignoring context switching overhead, etc).</p>
<p>Either way, there is nothing special you need to do in your code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878733">
				<div id="div-comment-878733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878733">
			December 3, 2010 at 7:40 am</a>		</div>

		<p>In my experience the System Idle Process is the worst offender (<a rel="nofollow" target="_new" href="http://www.pcmag.com/article2/0,2817,1304348,00.asp" rel="nofollow">http://www.pcmag.com/&#8230;/0,2817,1304348,00.asp</a>) /joke</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878743">
				<div id="div-comment-878743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878743">
			December 3, 2010 at 7:42 am</a>		</div>

		<p>@Michael exactly. &nbsp;It seems that people are more worried about memory consumption these days but it&#39;s the same fallacy.</p>
<p>If you manage to keep your memory usage below 50%, you can be proud of it, until you realize you could have just bought a PC with half the physical memory for the same effect AND saved money. &nbsp;If you have the resources you should be using them effectively, not wasting them.</p>
<p>I was checking out a list of Windows apps the other day and looked at two apparently popular maintenance tools. &nbsp;They both included memory cleaning tools&#8230; my knee-jerk reaction was to dismiss the tools as probably not terribly useful (and perhaps harmful) and the authors as unknowledgeable about Windows maintenance. &nbsp;Fortunately the tools didn&#39;t have any features I already had with CCleaner and the Nirsoft and Sysinternals tool suites so I didn&#39;t feel any need to check them out anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878753">
				<div id="div-comment-878753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erik Heemskerk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878753">
			December 3, 2010 at 7:44 am</a>		</div>

		<p>100% CPU usage and not being able to start task manager is usually a case of incorrect thread priorities; explorer.exe is usually running with Normal base priority, so if another process with Normal base priority is burning up all of the CPU cycles, then yes, you&#39;re going to have a hard time terminating it. An application that has a background task with the same priority as the foreground thread, with the foreground thread burning 100% CPU is indeed going to have a hard time updating the UI. The solution would be either giving the UI thread a higher than Normal priority or giving the background thread a lower than Normal priority.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878773">
				<div id="div-comment-878773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878773">
			December 3, 2010 at 7:48 am</a>		</div>

		<p>Oh yeah, now I have a Raymond Chen article to link people to when this sort of thing comes up instead of having to mash words together and hope they form some degree of coherency (like now). &nbsp;Thanks Raymond!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878783">
				<div id="div-comment-878783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878783">
			December 3, 2010 at 7:56 am</a>		</div>

		<p>I have learned this a while ago and am constantly annoyed if an important process (Visual Studio, usually) uses less CPU than I theoretically want to spare, and I am waiting for it to do something (compile C++, usually). I&#39;d like 1 of my 8 cores free, and the other 7 really, really busy. Someone should solve that Halting Problem so we can write a decent scheduler&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878793">
				<div id="div-comment-878793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sinan Unur</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878793">
			December 3, 2010 at 7:57 am</a>		</div>

		<p>There is nothing more painful then having 64 cores and 512GB memory at my disposal and have only three cores utilized a few percent because the input data resides on a network drive. I would do anything to be able to have a few of those cores utilized at 100%.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878803">
				<div id="div-comment-878803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henke37</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878803">
			December 3, 2010 at 7:58 am</a>		</div>

		<p>There is nothing wrong with 100 % CPU usage, even when you want things to be cancelable. The trick is to prioritize the GUI over the big work. And you know, not abandoning the job of manning the message pump.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878813">
				<div id="div-comment-878813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Omar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878813">
			December 3, 2010 at 7:59 am</a>		</div>

		<p>Sad but true. I wish my CPU (a core i7) went to 100% for just one second. I have tried hard (I do heavy dev, but somehow can&#39;t get it to go to 100 for any reasonable amount of time). I have a feeling I need an SSD.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878823">
				<div id="div-comment-878823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878823">
			December 3, 2010 at 8:10 am</a>		</div>

		<p>@Eric: That is usually just a problem on single core processors. &nbsp;Of course, for the best user experience, you should stick sleep(0)s where appropriate in your code so single core machines can still task switch effectively and so the user can continue to use the machine.</p>
<p>I also try to lower the priority of background threads or long working threads so the machine remains usable.</p>
<p>Addendum: Aww, the comment box here is sad when I decide not to post (it shows &quot;Please enter a comment&quot; if you clear the comment box and click off of it).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878833">
				<div id="div-comment-878833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878833">
			December 3, 2010 at 8:22 am</a>		</div>

		<p>Lack of runaway thread detection and of priority demotion for runaway threads in Windows kernel makes the 100% CPU a worse problem than you want to pretend it is. And it&#39;s really easy to detect such threads. If they use up their time slice continuously, they are running away and should be deprioritized.</p>
<p>One notable example is Internet Explorer when it opens this glorious blog. Its terrible scripting performance just kills the puppies. It takes a few seconds of a frozen IE and CPU core pegged at 100%.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878843">
				<div id="div-comment-878843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Ludlow</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878843">
			December 3, 2010 at 8:36 am</a>		</div>

		<p>Is this theoretical application the primary thing the user is working with? &nbsp;Is the user constantly doing stuff with it? &nbsp;If so, then ok, go nuts, use 100% CPU if it helps you do the job quicker. &nbsp;A game can use 100% CPU because it&#39;s unlikely I&#39;ll be doing anything else whilst playing the game.</p>
<p>If I have a reasonable expectation that I can use your app and be able to do other stuff at the same time, then 100%CPU is a bad thing. &nbsp;Outlook using 100% duing Send/Receive is a bad thing, because reading emails in Outlook is just one thing I happen to do at work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-878853">
				<div id="div-comment-878853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878853">
			December 3, 2010 at 8:43 am</a>		</div>

		<p>I never thought of it that way before. &nbsp;Think of all that money I&#39;ve been spending on insurance, and yet I&#39;ve never filed a claim, so it&#39;s all been going to waste!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878863">
				<div id="div-comment-878863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Leo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878863">
			December 3, 2010 at 8:47 am</a>		</div>

		<p>There is value in having reserves. If Napoleon doesn&#39;t deploy two reserve battalions in a battle, it certainly doesn&#39;t mean that Napoleon should have left those battalions at home. If something is using 100% of something normally, what will it do in an emergency?</p>
<p>I will agree that improved task scheduling and deployment of multiple cores are ameliorating the experience of having something use 100% of the CPU. However, historically this tended to lead to major degradation to the multitasking and UI experience.</p>
<p>The perspectives of a user of such a program and the developer of such a program is of course different.</p>
<p>Disclaimer: I know fare less about the subject than Raymond and many other commenters here.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878873">
				<div id="div-comment-878873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MikeCaron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878873">
			December 3, 2010 at 8:57 am</a>		</div>

		<p>&quot;John&quot;: Is that guy kidding? &quot;When I hit Ctrl-Alt-Delete, I see that the System Idle Process is hogging all the resources and chewing up 95 percent of the processor&#39;s cycles. Doing what? Doing nothing?&quot;</p>
<p>Dan: Or, just make sure your UI thread is still pumping and at least as high a priority as your work thread.</p>
<p>Alex Grigoriev: Why is that in any way a good idea? How do you define a run away thread? One that uses all its slice without stopping? What if it&#39;s a thread in PiCalc.exe? It&#39;s not going to stop until its told to otherwise! And, it&#39;s not buggy, it&#39;s doing math! Computers are good at math!</p>
<p>What if you&#39;re playing Dwarf Fortress? No computer that exists today or any time in the next 30 years will be able to run it at anything less than 100% CPU. If, suddenly, its single thread was lowered in priority, just because some uppity kernel is annoyed that I&#39;m using that CPU that I paid hundreds of dollars for, I&#39;d be annoyed.</p>
<p>Leo: What kind of emergency are you thinking of here? Invasion by the British? Extra CPU isn&#39;t going to help :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878883">
				<div id="div-comment-878883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">110%</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878883">
			December 3, 2010 at 9:06 am</a>		</div>

		<p>Bloated .net/java software usually eat cpu cycles for breakfast. Lean and neat apps does not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878893">
				<div id="div-comment-878893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Will</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878893">
			December 3, 2010 at 9:27 am</a>		</div>

		<p>At work we have a 16bit Windows applications that everyone uses. A while back the IT guy was trying to figure out an unrelated issue (network related) and noticed that a lot of the machines were at 100% CPU utilization. He was also confused that a lot of the newer machines were constantly at 50% or so utilization. &nbsp;I did my best to explain how the Windows 16 bit emulation (ntvdm.exe/wowexec.exe) in Windows XP does exactly what Windows 3.x did &#8212; always be pumping messages through the message loop. That uses 100% of the CPU and the new machines were dual core, so they only had ~50% usage.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878923">
				<div id="div-comment-878923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jader3rd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878923">
			December 3, 2010 at 9:45 am</a>		</div>

		<p>I think the reason why people think that %100 CPU utilization is kicking puppies is because that&#39;s the information that&#39;s put right in front of them when they open task manager. If task manager presented outstanding I/O requests, and page faults delta while making it difficult to discover CPU usage, all of a sudden people would focus on those as being the root cause to application slow down (which in my opinion it is).</p>
<p>I&#39;ve seen program use %100 of the CPU, but the computer is still responsive. I&#39;ve also seen programs with infinite loops cause applications to become non responsive.</p>
<p>I think that root of most problems where people see the application being non responsive is because the GUI thread is blocked on another thread doing work. I think the TPL will go a long way towards removing the times when applications will block the GUI thread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878933">
				<div id="div-comment-878933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878933">
			December 3, 2010 at 9:57 am</a>		</div>

		<p>&quot;creaothceann&quot;: I completely agree, it&#39;s the fan. It always annoys when I read a document onscreen, and after 15 minutes or so one of those background system maintainance services discovers I am idle and turns on the fan full-power while doing heavy work on the hard drive. To be fair, the problem is not actually the 100% CPU usage but the fact that those services do something I never requested.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878943">
				<div id="div-comment-878943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878943">
			December 3, 2010 at 10:07 am</a>		</div>

		<p>You must always read between the lines when users complain. &nbsp;When they say, &quot;this application is using 100% CPU!&quot; what they are really saying is, &quot;my computer becomes slow and unresponsive when I run this application!&quot; a legitimate complaint which should not be taken lightly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878963">
				<div id="div-comment-878963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878963">
			December 3, 2010 at 10:44 am</a>		</div>

		<p>A thread at normal priority spending 100% CPU time does not prevent other threads or a user to stop the application, or do other GUI or non-GUI work unless it aggressively utilizes memory (bloating its working set and draining other processes working sets) or issuing I/O requests at high rate. In this case, trying to switch to another, at first glance running at the same priority thread causes the system to increase another process&#39; working set, probably issuing I/O requests to load pages from page file and, shrinking hungry app&#39;s working set, causing it to make a huge band of page faults.</p>
<p>That is really bad and that is experience users are complaining about.</p>
<p>If a developer targets Vista+, he should definitely consider the new kernel improvements (namely, memory and I/O prioritization) when writing CPU, memory and disk-hungry apps. Mark Russinovich has excellent videos about that published in his SysInternals blog recently. A quick example:</p>
<p>A simple utility that just scans the entire HDD volume with 1000000+ files (and storing information about them in memory) completely kills Core i5 750 with 4GB memory, while taking only about 5% CPU. The computer is absolutely unusable despite such a small CPU usage because of its memory and I/O bloating.</p>
<p>Just setting the utility to use lowest priority memory and I/O (and didn&#39;t changing any other bit in code) turns the turtle into the super-high-jet &#8211; a user continues to work on the computer as it were idle, while an app continues to work in the background.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878973">
				<div id="div-comment-878973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rgove</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878973">
			December 3, 2010 at 10:47 am</a>		</div>

		<p>Raymond: I seem to remember you acknowledging that the MSDN blog server upgrade removed the ability to make hyperlinks to individual comments. Why are you still trying to use these links in new posts?</p>
<div class="post">[<i>So that the links will work once they fix the bug. The alternative is, what, removing the anchor and then waiting for them to fix the bug, and then going back and adding the anchors back? Since the effect with and without the anchor is the same, why complain about the anchors that don&#39;t work yet? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878983">
				<div id="div-comment-878983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jschroedl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878983">
			December 3, 2010 at 11:29 am</a>		</div>

		<p>@K: For your C++ builds in VS2010 you can leave one of your eight CPUs available. Go to Tools &gt; Options, Projects and Soltions, Build and Run then change the &quot;maximum number of parallel project builds&quot; setting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878993">
				<div id="div-comment-878993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878993">
			December 3, 2010 at 11:33 am</a>		</div>

		<p>@Gabe: &nbsp;Clock rate is proportional to the instructions per second, but they are not equivalent, even in a single-core, non-SMT cpu. Superscalar architecture has been around on x86 since the original Penitum, and that combined with pipelining allow modern CPUs to execute a dozen or more instructions per-clock-cycle. &nbsp;Different parts of the CPU may also run at different rates. &nbsp;The ALUs on Pentium 4 CPUs run at twice the clock rate of the CPU as a whole, for instance. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879003">
				<div id="div-comment-879003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879003">
			December 3, 2010 at 11:39 am</a>		</div>

		<p>@Leo: &quot;If something is using 100% of something normally, what will it do in an emergency?&quot;</p>
<p>That&#39;s why it&#39;s useful to lower the priority of the thread. &nbsp;It&#39;s not that 100% utilization is bad. &nbsp;It&#39;s that 100% utilization by a thread that doesn&#39;t want to be pre-empted is bad. &nbsp;GUI threads rarely use nearly their entire quantum.</p>
<p>So at the same priority, a hard-working CPU-bound thread regularly delays the GUI thread by roughly 50ms every time the GUI thread thinks it has nothing left to do. &nbsp;Lowering the hard-working thread&#39;s priority allows it to still take the vast majority of CPU time (since it&#39;s the only thread that really wants it that badly), while letting threads that just want short brief moments of the CPU&#39;s time get in right away).</p>
<p>In other words, in an &quot;emergency&quot; (however you define that), you <em>do</em> have headroom. &nbsp;It&#39;s just taken automatically from the hard-working thread.</p>
<p>That said, I think the points about laptops are somewhat valid, in that they are at least worth thinking about. &nbsp;Efficiency is not the sole criteria in terms of computer utilization, and if the computer is really being used for other things while the hard-working thread is busy, it&#39;s not clear that the CPU&#39;s power mode is going to be affected one way or the other much anyway.</p>
<p>The user may indeed prefer to let the computer loaf a bit, so that their lap doesn&#39;t get so hot and the fans aren&#39;t so noisy. &nbsp;As a user, it would be nice to have more direct control over this (and indeed, some laptops do have BIOS-supported controls that limit overall system resource utilization, including CPU, for this very purpose).</p>
<p>In the end, in spite of the laptop scenarios, I still think in the vast majority of cases (well over 90%), the programmer should just lower the thread priority for the hard-working threads and then use as much CPU time as the thread needs. &nbsp;Trying to anticipate other possible user needs just complicates the code (more bugs!) and isn&#39;t guaranteed to do what the user wants anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879023">
				<div id="div-comment-879023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henke37</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879023">
			December 3, 2010 at 2:02 pm</a>		</div>

		<p>The only scenario where one user uses all the tellers that I can think up is illegal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879033">
				<div id="div-comment-879033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RobertWrayUK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879033">
			December 3, 2010 at 2:20 pm</a>		</div>

		<p>@rgove, the answer is in the name of the blog, &quot;The Old New Thing&quot;&#8230; this entry was probably written before the blog software upgrade. =)</p>
<p>That said, if the blog software gets fixed in the future to once again support hyperlinks to individual comments then Raymonds links will once again work as expected!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879043">
				<div id="div-comment-879043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ccutrer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879043">
			December 3, 2010 at 2:25 pm</a>		</div>

		<p>For those using Visual Studio 2010, try setting the &quot;Multi-processor Compilation&quot; flags in C/C++ General Properties (/MP flag to CL, or /maxcpucount to MSBuild). &nbsp;This will allow parallelization of files within a single project, not just parallel builds of multiple projects. &nbsp;This flag alone can cut overall compilation time in four or more. &nbsp;For example, on my Core i7 machine, compiling <a rel="nofollow" target="_new" href="http://github.com/mozy/mordor" rel="nofollow">http://github.com/mozy/mordor</a> takes under two minutes with VS2010, and nearly 10 minutes with VS2008, since VS2008 can&#39;t keep all the cores busy. &nbsp;Definitely an example of more CPU usage being better.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879053">
				<div id="div-comment-879053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">PhilW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879053">
			December 3, 2010 at 3:42 pm</a>		</div>

		<p>Sean: &quot;I do have one comment to keep in mind. &nbsp; the application&#39;s processing if it requires Disk I/O in any way shape or form should not eat 100% cpu&#8230; Hey 95% is good but you HAVE to leave SOMETHING for the Kernel to do it&#39;s job :)&quot;</p>
<p>Why? 1) A well written program that does efficient asynchronous I/O may not ever need to explicitly wait for I/O to finish. 2) I hope you&#39;re not serious. You&#39;re proposing that a program (or the sum of all programs) should not exceed 95% in case the kernel can&#39;t run? Er&#8230; isn&#39;t that what Raymond is mocking?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878763">
				<div id="div-comment-878763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Cleary - Nito Programs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878763">
			December 3, 2010 at 7:46 am</a>		</div>

		<p>@Jeff and @Matt: This is usually due to programmers who have just learned about thread priorities.</p>
<p>I find that most people start out with the *opposite* conception of how thread priorities should be used. They think &quot;hey, I&#39;ve got to do a CPU-intensive thing for a while&quot; and conclude that they should *raise* their computing thread&#39;s priority. Naturally, the correct answer is the opposite &#8211; *reduce* the priority, or just leave it alone and let Windows&#39; dynamic priority boosting take care of everything.</p>
<p>BTW, 100% CPU is good when there&#39;s work being done, but a lot of the time it is also indicative of a bug. With the programs that most &quot;normal&quot; (i.e., non-technical) people use, 100% CPU sustained for minutes on end (or 50% on a dual-core, etc) is more likely a bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878903">
				<div id="div-comment-878903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">creaothceann</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878903">
			December 3, 2010 at 9:28 am</a>		</div>

		<p>Sometimes I want to run a job on my laptop in the background while I do something else (like reading ebooks or websites). I don&#39;t care if the background job takes one hour or two, but I care about the *fan noise*. In this case a program that has 100% CPU utilization is not welcome.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-878913">
				<div id="div-comment-878913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">blah</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878913">
			December 3, 2010 at 9:31 am</a>		</div>

		<p>&quot;110%&quot; beat me to it. That is not efficiency. Neither is Outlook 2007&#39;s e-mail composition context menu that takes 5-10 seconds to update its hover by redlining one core. I guess *some* people on this blog have never used Visual Studio for that matter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-878953">
				<div id="div-comment-878953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-878953">
			December 3, 2010 at 10:30 am</a>		</div>

		<p>A clear distinction must be made. An application I requested to do some work is expected to use 100% of the CPU until it&#39;s done. A program that I did not request do any work should *not* be using 100% CPU for noticeable periods of time.</p>
<p>My CPU runs at 2.5GHz, so it should be able to do 2.5 billion little things per second (neglecting things like TurboBoost, hyperthreading, multicore, and dual-issue). If a program has more than a few billion little things to do, it&#39;s natural to get suspicious. If a program thinks it has 100 billion little things to do (full CPU for 40 seconds), it&#39;s probably a bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879073">
				<div id="div-comment-879073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lazbro</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879073">
			December 3, 2010 at 7:30 pm</a>		</div>

		<p>&#39;If you manage to keep your memory usage below 50%, you can be proud of it, until you realize you could have just bought a PC with half the physical memory for the same effect AND saved money. &nbsp;If you have the resources you should be using them effectively, not wasting them&#39;</p>
<p>If you&#39;re using 100% memory, you&#39;re one notepad file away from having all your stuff swapped out. The point of buying more memory is to delay the point where your system grinds to a stop. I will never use all 8 GB but that&#39;s the whole point. Pegging a core with something useless otoh doesn&#39;t matter because there are plenty more of them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879083">
				<div id="div-comment-879083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879083">
			December 3, 2010 at 8:01 pm</a>		</div>

		<p>@Jim: Fortunately we have schedulers to prevent &quot;one customer using all ten tellers&quot; scenarios. They aren&#39;t perfect &#8212; I&#39;ve seen them go wrong in times of heavy I/O on both Windows and Linux, and if everyone is trying to page it can be a disaster &#8212; but for the most part they are pretty good. Generally speaking if one customer is using all ten tellers it&#39;s because everyone else is milling about talking to each other and filling out their deposit and withdrawl slips.</p>
<p>@Lazbro: You missed the entire point, which is that it&#39;s not just program working sets that are sitting in memory and counting towards the &quot;omg you don&#39;t have free memory&quot; total. The OS maintains a &quot;buffer cache&quot; where it guesses what files you are likely to access in the near future. Potentially this could be gigs. If it&#39;s right, then it sped things up for you! If it&#39;s wrong, then oh well, that data is out on disk anyway, so it just drops a couple pages from the buffer cache. In that situation, you&#39;re no worse off than if the OS didn&#39;t maintain the buffer cache in an effort to keep memory usage down, except that in the latter scenario you&#39;ll never win. It MAKES SENSE for the OS to use basically all available memory for the buffer cache for this reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879013">
				<div id="div-comment-879013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879013">
			December 3, 2010 at 12:38 pm</a>		</div>

		<p>The bank teller analogy would make perfect sense if we were still running CP/M. &nbsp;A better one, on a multi-tasking operating system, is that you have ten tellers, a crowd of customers, and a *single customer* is using all ten tellers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879093">
				<div id="div-comment-879093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879093">
			December 3, 2010 at 11:06 pm</a>		</div>

		<p>Two reasons why 100% might be bad</p>
<p>1) Inefficient software. Just because the previous version used only 10% is no excuse for the current version to use 100% for the same task. That&#39;s a more common complaint than you think.</p>
<p>2) Battery life, especially embedded systems. Power consumption rises with the square of the voltage. If you can step down the CPU to 50%, you can save more energy than running the processor at full speed for half the time, especially if the task is real-time limited (e.g., video or music playback). A media player able to`control its CPU utilization can achieve longer battery life by using the CPU at 50% and allowing the dynamic frequency/voltage scaling (DVFS) to keep the CPU at the slower speed than 100% at full speed and idling at 0% while the rendered buffer plays out, which can force DVFS to keep CPU at full speed always or constantly switching speeds</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879103">
				<div id="div-comment-879103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Troll</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879103">
			December 4, 2010 at 12:57 am</a>		</div>

		<p>Are Explorer and MSE designed to consume 100% CPU?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879063">
				<div id="div-comment-879063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879063">
			December 3, 2010 at 6:23 pm</a>		</div>

		<p>I think the issue isn&#39;t so much &quot;uses 100% of CPU&quot; but &quot;*unnecessarily* uses 100% of CPU&quot;. &nbsp;For example I have some CD-burning software that burns up 100% of one of my power-guzzling heat-producing cores when it&#39;s running, while virtually any other CD-burning software I&#39;ve seen only uses 5-10% at most (for technical reasons I have to use this software in this case, there&#39;s no alternative). &nbsp;This causes the CPU fan to spin up to an annoyingly noisy level, and power consumption to jump dramatically. &nbsp;Another example is IntelliSense in VC++, which burns close to 100% of CPU every time you make a code change in some situations (there are lots of posts on blogs on how to disable IntelliSense by removing the necessary DLL as a means of correcting this).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879143">
				<div id="div-comment-879143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andreas Rejbrand</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879143">
			December 4, 2010 at 5:19 am</a>		</div>

		<p>I do not understand the title (&quot;ZOMG! This program is using 100% CPU!1! Think of the puppies!!11!!1!1!eleven&quot;). Anyone care to explain it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879153">
				<div id="div-comment-879153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Spinal Tap</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879153">
			December 4, 2010 at 5:23 am</a>		</div>

		<p>Windows 8&#39;s Task Manager will go up to 11.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879163">
				<div id="div-comment-879163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">f0dder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879163">
			December 4, 2010 at 5:55 am</a>		</div>

		<p>@ccutrer: older versions of VC++ also have the /MP switch &#8211; it just wasn&#39;t documented/exposed in the GUI. Can&#39;t remember when it was introduced, but I&#39;ve definitely used it with VS2008, and probably VS2005 as well.</p>
<p>It should also be noted that /MP is different from the &quot;projects to build in parallel&quot; setting. /MP, when used on cl.exe with multiple source files as input, spawns a compiler instance for each source file. The other setting only uses one thread per project it&#39;s building.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879173">
				<div id="div-comment-879173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879173">
			December 4, 2010 at 6:31 am</a>		</div>

		<p>This reminds me of the days when I was a student, and a fellow student and I both wrote programs to generate a list of primes up to a million. I still have the printout somewhere. My fellow student wasn&#39;t so fortunate, because he wrote his program to generate all the primes up front and print them out afterwards, and his job got killed for being a CPU hog.</p>
<p>As for not using 100% CPU being a waste, the foreground app is quite entitled to use 100% CPU because we&#39;re presumably waiting for it. It&#39;s all the background stuff that&#39;s making the foreground app unresponsive that we don&#39;t like.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879183">
				<div id="div-comment-879183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul Parks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879183">
			December 4, 2010 at 7:59 am</a>		</div>

		<p>@Andreas Rejbrand: It&#39;s multi-layered, so get ready.</p>
<p>&quot;ZOMG&quot; is a &quot;correction&quot; of &quot;zOMG,&quot; which is an imitation of accidentally hitting the &#39;z&#39; key while trying to press the left shift to capitalize the &#39;O&#39; in &quot;OMG.&quot; Likewise, the &quot;!!11!!&quot; formulation simulates difficulty with the right shift key while trying to type multiple exclamations points (shift-1 on North American keyboards, typically). &quot;Eleven&quot; is more irony, pointing out the tendency to type &quot;11&quot; among several exclamation points. The entire sentence is making fun of people who excitedly post about some new discovery on Usenet or an online forum, in the process discarding good typing practice and using &quot;typical&quot; Internet interjection memes such as &quot;OMG&quot;.</p>
<p>I guess you had to be there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879193">
				<div id="div-comment-879193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879193">
			December 4, 2010 at 10:43 am</a>		</div>

		<p>@Worf: But it&#39;s not a good idea to try and manage CPU power within the application, far better to let the OS take care of that and use DVFS to scale back the total amount of CPU available. It has a much better idea of what is going on in the system overall, compared to just a single application.</p>
<p>It&#39;s amusing to see that, no matter how good an explanation of why utilising system resources to the maximum is a good idea (and Raymond&#39;s explanation is very good) you still see the same old arguments for &#39;keeping some spare&#39; dragged out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879223">
				<div id="div-comment-879223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Barry Kelly</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879223">
			December 4, 2010 at 12:22 pm</a>		</div>

		<p>Heat is a problem with 100% CPU consumption. I have a desktop machine which doesn&#39;t mind 100% spikes of a few seconds, or even a few minutes, but an hour or so (such as when transcoding video) will ultimately cause it to suspend to cool down from overheating. Sure, I could put better cooling in the system, or underclock the CPU (it&#39;s overclocked), but then I&#39;d suffer from either excessive noise during CPU spikes, or from a slower CPU during CPU spikes.</p>
<p>Meanwhile, one of my laptops gets very hot on the keyboard, uncomfortably hot, even with the fans running full whack. Any process which needlessly uses CPU &#8211; such as a web browser without FlashBlock, thus running ads &#8211; I resent, because it burns! Many times I&#39;d trade off waiting longer for something to complete, so long as less heat is output.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879133">
				<div id="div-comment-879133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marquess</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879133">
			December 4, 2010 at 5:11 am</a>		</div>

		<p>That is of course true. What Raymond talks about is intentionally reducing the amount of CPU usage *just for reducing CPU usage* (over time &#8212; it&#39;s of course still taking the same amount of cycles in the end).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879243">
				<div id="div-comment-879243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879243">
			December 4, 2010 at 1:46 pm</a>		</div>

		<p>@Jeff Zarnett: I hope you are joking, right? That is exactly the wrong attitude/reaction. A 100% CPU using program not being able to cancel an action is NOT a Windows problem. It&#39;s an application problem (i.e. a bug). The games I play constantly use around 100% of my CPU, modern ones anyway, as they use both cores. However they are just fine with cancelling something, like say, an inventory screen. I hope you don&#39;t actually use the reset button :)</p>
<p>@Michael Kohne: Why Windows 7? My XP does caching all the time and I am sure it wasn&#39;t the first Windows (just the one I am using right now). 697828 system cache, 1516960 still usable yet I only have 2GB of RAM.</p>
<p>What these &quot;ram freeing&quot; utilities do is actually allocating and filling a lot of memory in order to force unused pages to the page file so you see more &quot;free&quot; RAM in your task manager and brag about it. It doesn&#39;t do any good though. I hope nobody actually pays money for those. Ever.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879253">
				<div id="div-comment-879253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Conerned Citizen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879253">
			December 4, 2010 at 2:17 pm</a>		</div>

		<p>The CPU is a completely different &#39;beast&#39; than RAM, which is where you are transposing this ideology from. You want the RAM filled to 100% utilization (with caches utilizing the space not occupied by running processes) because it is the fastest storage medium your computer has. That is the argument against RAM cleaners. CPU usage, on the other hand, is not AT ALL like this. The less CPU utilization (as an average over a second as represented by the task manager), the faster your code is being executed. Further, since a normal priority CPU bound thread using 100% of the CPU can bring a single CPU system to its knees, it is something to be concerned about.</p>
<p>Using less CPU is ideal because that means your code was written more optimally.</p>
<p>This seems like a transposed argument. Please, don&#39;t be defensive, just listen and think about it..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879263">
				<div id="div-comment-879263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879263">
			December 4, 2010 at 3:55 pm</a>		</div>

		<p>@Concerned Citizen: &quot;The less CPU utilization (as an average over a second as represented by the task manager), the faster your code is being executed.&quot;</p>
<p>You&#39;re going to have to explain that one a bit more.</p>
<p>&quot;Using less CPU is ideal because that means your code was written more optimally.&quot;</p>
<p>How is &quot;I&#39;m going to complete in 2 seconds using 50% of the CPU&quot; more optimal than &quot;I&#39;m going to complete in 1 second using 100% of the CPU&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879273">
				<div id="div-comment-879273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879273">
			December 4, 2010 at 4:59 pm</a>		</div>

		<p>@Evan and &quot;Conerned Citizen&quot;</p>
<p>&quot;Conerned Citizen&quot; is kinda right here too. It&#39;s just the wording I guess.</p>
<p>Situation: You have input X and output Y. You have an algorithm A that transforms X into Y.</p>
<p>Program i uses the CPU for 1 second at 100% to do that</p>
<p>Program j uses the CPU for 1/2 second at 100% to do that, which is shown as an average of 50% over the one second interval.</p>
<p>Which program is better? Clearly program j, as it does the same job by using less CPU resources. Of course things are not that easy to measure and clear cut in real world examples, which is why we end up with the big mess we are making while discussing this whole thing&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879203">
				<div id="div-comment-879203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879203">
			December 4, 2010 at 11:33 am</a>		</div>

		<p>For those who are worried about power consumption and/or fan noise, I would suggest that you are looking in the wrong place for solving that problem. Windows has had *power management* controls available for a long time now; perhaps you should look there first!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879233">
				<div id="div-comment-879233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879233">
			December 4, 2010 at 1:42 pm</a>		</div>

		<p>&gt;For those who are worried about power consumption and/or fan noise, </p>
<p>&gt;I would suggest that you are looking in the wrong place for solving </p>
<p>&gt;that problem. Windows has had *power management* controls available </p>
<p>&gt;for a long time now; perhaps you should look there first!</p>
<p>The only thing you can do with those is permanently cripple your system to never run at more than (say) 50% capacity. &nbsp;I want it to be able to occasionally spike up to 100% for things that require a bit of extra horsepower now and then (after all I paid for that), whether it runs at 100% for 5 seconds or 50% for 10 seconds makes no difference in battery life. What I don&#39;t want is some badly-written piece of junk sucking 100% of CPU for 30 minutes. Even sucking 50% of CPU for 30 minutes (or 100% of a clock-throttled CPU if you want to look at it that way) isn&#39;t going to help, it&#39;s still killing battery life, just not as fast.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879283">
				<div id="div-comment-879283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">f0dder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879283">
			December 4, 2010 at 11:54 pm</a>		</div>

		<p>@Different Alex: while I agree that those memory cleaners are almost always useless, at least *some* of them have moved to calling SetProcessWorkingSetSize() on all processes rather than doing the stupid &quot;let&#39;s allocate until everybody pageouts&quot;. Doing the SPWSS pretty much triggers Windows&#39; default trimming behavior, albeit doing it prematurely.</p>
<p>As for the whole CPU usage thing&#8230; it isn&#39;t as black and white as some of you are painting it to be.</p>
<p>The people claiming that &quot;100% usage is bad, a program using 50% is better optimized&quot; are obviously wrong &#8211; if you do heavy work and utilize less than 100% CPU, it simply shows you have bottlenecks in your code. How optimized the code is is judged by program runtime (and perhaps other statistics such as memory usage and file access patterns), not by looking at the CPU usage graph.</p>
<p>On the other hand, I agree that it isn&#39;t *always* good to run full throttle even if you can. It&#39;s fine for foreground tasks, handling directly user-initiated actions&#8230; but for other scenarios, it can be worthwhile to throttle a bit. Yes, setting a lower thread priority for background tasks can certainly be a good idea, but it doesn&#39;t really help against laptop heat and fan noise :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879293">
				<div id="div-comment-879293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">joalex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879293">
			December 5, 2010 at 12:53 pm</a>		</div>

		<p>Unfortunately, the first thing I thought of when reading this title was how often Task Manager will eat an entire core if it is left open for a while, or sometimes across hibernations; has happened on XP, Vista and 7, single and multi-core. You might imagine the pain that causes on a single core; it can take minutes to try and Win+R -&gt; taskkill.</p>
<p>In that case, it is quite certainly kicking some puppies. Closing and re-opening Task Manager immediately fixes the problem until &#39;the next time.&#39;</p>
<p>I&#39;d always wondered what made Task Manager of all things do that. Afterall, it normally usually takes less than 5% CPU time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879313">
				<div id="div-comment-879313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879313">
			December 5, 2010 at 2:53 pm</a>		</div>

		<p>@Different Alex: Yes, if you can change the code algorithmically to require less CPU in total to complete the same task, that&#39;s a good thing. It&#39;s entirely different from what Raymond is talking about though, where you are trying to artifically reduce the apparent CPU usage by making things take longer. That&#39;s never a good thing, you still have to use the same amount of CPU time in total, you just aren&#39;t doing it as effectively. All the counter-arguments here about battery life, fan noise or heat are incorrectly asuming it&#39;s better to try and do the OS&#39;s job in an application, an optimization which almost always produces a far less desirable result.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879323">
				<div id="div-comment-879323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nils</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879323">
			December 5, 2010 at 4:14 pm</a>		</div>

		<p>People don&#39;t buy expensive/fast computers to run bloated software.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879343">
				<div id="div-comment-879343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879343">
			December 6, 2010 at 1:33 am</a>		</div>

		<p>Aaron: If you can find a useful program that can execute 5 billion instructions on a single thread in one second, I will be very impressed. The average program is lucky to hit 2 IPC, and even getting one instruction per clock isn&#39;t guaranteed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879363">
				<div id="div-comment-879363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Engywuck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879363">
			December 6, 2010 at 2:39 am</a>		</div>

		<p>IIRC these &quot;RAM cleaners&quot; work on two premises:</p>
<p>1) it&#39;s good to have mucho free RAM</p>
<p>2) you need to have all RAM in one large piece</p>
<p>So as described they try to allocate several large blocks of RAM, forcing everything swappable out to swap and after freeing claim something like &quot;1040MB free, largest free block 768MB&quot;.</p>
<p>This being wrong on so many levels&#8230;</p>
<p>For starters doing so just delays every other program that needs to swapin when touched. Then they seem to not know about the difference between &quot;real&quot; and virtual memory addresses etc.</p>
<p>There may(!) have been a time, when you needed large (physical) blocks of contiguous RAM addresses, but these time (if they existed) should be long gone.</p>
<p>OTOH these programs are a nice way to test if your swap works and if some program has a problem with swapping large amounts of RAM back and forth :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879373">
				<div id="div-comment-879373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabor Kulcsar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879373">
			December 6, 2010 at 3:56 am</a>		</div>

		<p>I&#39;ve had a (desktop) computer that I hated soo much &#8211; it had a very badly designed cooling system which was fairly quiet on low CPU usage, but would start to &quot;take off&quot; like a fighter jet if I started doing anything processor intensive (say watch youtube videos&#8230;). So I would have paid a lot of money for lowering my CPU&#39;s clock, or for any other way to stop that bloody ventillator &#8211; and I hated when programs would use 100% processor for say a minute (typical example: antivirus program update).</p>
<p>I also have a laptop for work that suffers from the same problem, if not that much&#8230; so in my book, 100% CPU usage means bad design (these programs are usually have a much less responsive GUI, by the way&#8230;). I don&#39;t mind lower performance, I want a quiet workplace and responsive programs.</p>
<p>The other thing that drives me crazy are programs running in the background and using the hard disk intensively, because even if they are at idle priority they make a real burden on foreground processes&#8230; I&#39;ve yet to see an operating system which does have a responsive GUI all the time and handles background tasks properly.</p>
<p>So while in an ideal world 100% CPU might be the most efficient way to go, in the real world it simply s*cks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879383">
				<div id="div-comment-879383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">matushorvath</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879383">
			December 6, 2010 at 6:49 am</a>		</div>

		<p>Hmm, I can imagine at least one reason why running the processor at 100% should be avoided if possible, even if there is no other process that would use the CPU time. Your reasoning seems to be based on the assumption that you can use 100% CPU time for the same price as 50% CPU time, so why not use it all. But there is a price to pay, if you run a background task with 100% CPU utilization, you will run the processor pretty hot and the fans pretty noisy. If you can do the same work with less CPU usage (e.g. polling less often), it is definitely worth the effort.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879433">
				<div id="div-comment-879433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Engywuck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879433">
			December 6, 2010 at 7:46 am</a>		</div>

		<p>Polling is an I/O problem (primarily), but of course only polling when necessary is good practice. The problem is: how would you slow down a task where the CPU is the bottleneck? Say calculating hashes over large data already in memory, trancsoding movies, whatever. Now you have to add some sleep(100) calls only to slow down to lower-than-100%-CPU levels.</p>
<p>Yes, there are tasks that can be done in far fewer CPU cycles (not recalculating everything 200 times, polling, &#8230;) but iff you are truly CPU bottlenecked that&#39;s quite hard to do. Or said otherwise: when a task uses less than 100% CPU over a long period of time it has some other bottlenecks, mostly I/O, especially network and/or harddisk.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879443">
				<div id="div-comment-879443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879443">
			December 6, 2010 at 7:57 am</a>		</div>

		<blockquote><p>
  IIRC these &quot;RAM cleaners&quot; work on two premises:
</p></blockquote>
<p>I once wrote a &quot;RAM cleaner&quot; for satirical purposes: all it did was purge the working set of all processes. &nbsp;My intent was to expose RAM cleaners as snake-oil salesmen (this was less than one hour&#39;s programming) but a few people seemed to think I had written a useful program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879453">
				<div id="div-comment-879453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rgove</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879453">
			December 6, 2010 at 8:46 am</a>		</div>

		<p>Raymond: Ah, it had been so long that I was assuming that it never would be fixed. I defer to your optimism.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879353">
				<div id="div-comment-879353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879353">
			December 6, 2010 at 1:44 am</a>		</div>

		<p>&quot;I have a desktop machine which doesn&#39;t mind 100% spikes of a few seconds, or even a few minutes, but an hour or so (such as when transcoding video) will ultimately cause it to suspend to cool down from overheating. Sure, I could put better cooling in the system, or underclock the CPU (it&#39;s overclocked), but then I&#39;d suffer from either excessive noise during CPU spikes, or from a slower CPU during CPU spikes.&quot;</p>
<p>Joke? If not, then you have failed to *succesfully* overclock your PC &#8211; you&#39;ve just created an unreliable mess.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879473">
				<div id="div-comment-879473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879473">
			December 6, 2010 at 9:51 am</a>		</div>

		<p>@Barry Kelly, @Gabor Kulcsar:</p>
<p>Surely you can&#39;t expect software developers to specifically code assuming all users have broken hardware? (You&#39;ve both described hardware that&#39;s broken, at least to my definition of &quot;broken&quot;.) Fix your computer, then if you still have the problem, you&#39;re allowed to complain to the developers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879523">
				<div id="div-comment-879523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil (SM)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879523">
			December 6, 2010 at 1:24 pm</a>		</div>

		<p>@Different Alex:</p>
<p>I think that explanation only holds up when the process runs for less than a second. Otherwise it&#39;s back to being inefficient.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dwalker-wk even thread-even depth-1" id="comment-879533">
				<div id="div-comment-879533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879533">
			December 6, 2010 at 1:51 pm</a>		</div>

		<p>Slightly off-topic, but since others brought this up&#8230;</p>
<p>A lot of people seem to have fan noise issues. &nbsp;All of my desktop systems are built to run quietly. &nbsp;Some of them have a fan resistor to slow down the CPU fan, and another fan resistor to slow down the large, rear-facing exhaust fan (80 or 120mm). &nbsp;With correct use of good-quality silver-based thermal paste (and not too much of it), the CPU stays comfortably cool. &nbsp;A couple of my systems have larger, slower-moving (and quieter) CPU fans, with 80-to-70 or 80-to-60 mm fan reducer adapters (basically, plastic shrouds). &nbsp;I have not resorted to heatpipes or huge, heavy CPU heatsinks or liquid cooling, although I sometimes replace the stock heatsink with a slightly better heatsink. &nbsp; :-)</p>
<p>And speaking of SSDs, they are terrific. &nbsp;I hope they come down in price a little. &nbsp;I just bought one, and it&#39;s great. &nbsp;I accidentally bought the &quot;value&quot; model when I meant to buy the &quot;mainstream&quot; model, but it still made a huge difference. &nbsp;The next one I buy will be the M model.</p>
<p>And don&#39;t be afraid to leave the paging file on the SSD. &nbsp;Supposedly the paging file is 90% reads and 10% writes, more or less, so it&#39;s a terrific candidate to place on an SSD. &nbsp;Music and videos, on the other hand, can go on the spinning disk drive. &nbsp;And, you can put a laptop disk drive into a desktop CPU for more quiet goodness, to store all those videos!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879543">
				<div id="div-comment-879543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">f0dder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879543">
			December 6, 2010 at 2:49 pm</a>		</div>

		<p>@DWalker59: silver thermal paste? one of the reputable (iirc it was Toms or Anand) did a test a while ago, the temperature differences between different paste was something in the range of 2C &#8211; not worth the premium. Had the extra added benefit of frying a few of the non-shroud AMD CPUs as well, when applied incorrectly :)</p>
<p>Fan noise is mostly a problem in laptops anyway, where it&#39;s a bit hard adding proper 120mm fans. For long-running tasks, I&#39;d personally rather have the task throttle a bit rather than listening to the periodic-but-definitely-annoying jet exhaust spinning up&#8230; and to other commenters: no, the OS power options don&#39;t help diddly squat against that.</p>
<p>As for pagefile on an SSD&#8230; if you can afford an SSD, you should be able to afford throwing enough RAM in your system that you can disable it entirely :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879553">
				<div id="div-comment-879553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DaveWill</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879553">
			December 6, 2010 at 3:13 pm</a>		</div>

		<p>Users are fixated on the CPU because it is the only way for them to see that &quot;something&quot; is going on. &nbsp;When they are not doing something then they expect the CPU to not do something. &nbsp;Until transparency into what the CPU is doing is conveyable to the end user this conflict of concern will continue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879573">
				<div id="div-comment-879573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879573">
			December 6, 2010 at 5:28 pm</a>		</div>

		<p>Yes, definitely broken hardware, if fan noise is a problem. In a desktop it is simply inexcusable. My CPU fan isn&#39;t even throttling (replace that one, as the constant off/slow/fast cycles actually made the most noise) any more. I have a simple, low noise Pabst fan that I screwed on the heat sink that came with the throttling fan I had bought earlier.</p>
<p>As for laptops: yes, you can&#39;t put that 120mm fan in there (and actually the desktop&#39;s fan is only 80mm &#8230;) but you can still make low noise laptops. My Samsung R70 is really great. Under normal circumstances, no noise at all, when the CPU gets use for longer periods of time, I am usually doing something that makes noise anyway, say play a video or a game and when I am done and the fan needs to push out some residual heat, the Samsung guys apparently did some great sound engineering in that the noise (which is noticeable) doesn&#39;t have a bad pitch or anything like that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879583">
				<div id="div-comment-879583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Slapout</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879583">
			December 6, 2010 at 6:13 pm</a>		</div>

		<p>The programs that seem to slow down my computer aren&#39;t the ones with high CPU usage, they are the ones with high disk access.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879593">
				<div id="div-comment-879593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879593">
			December 6, 2010 at 9:17 pm</a>		</div>

		<p>Obviously 100% utilisation can be bad in certain situations; specifically anything with a generally real-time function. The example in the article is relevant to this, if my media player is using 100% CPU it is an indication that it can&#39;t keep up and frames and whatnot are being dropped. Worse is the system which idles along at something acceptable (like 70%), but can be perturbed by a transient condition into using 100% CPU, thereby failing timeliness constraints on the real time base load. In such a situation it <em>is</em> better to slow down the processing of the transient process to ensure it does not choke the system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879603">
				<div id="div-comment-879603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879603">
			December 6, 2010 at 9:26 pm</a>		</div>

		<p>What would be cool, is if on your server you could assign a maximum process % to your various server processes thereby allowing divvying up of the CPU pie. This way one service getting overloaded would not kill the performance of others. I suppose this is already done with virtualisation and blade servers and whatnot. Is there already a way to do this under windows?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879613">
				<div id="div-comment-879613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879613">
			December 6, 2010 at 11:38 pm</a>		</div>

		<p>@Andy C: DVFS works at a lower level than applications. All DVFS cam do is see what current load is, what historical load is, and guess what future load is going to be and prepare for it.</p>
<p>Applications know their load profile &#8211; they know they&#39;re going to process an MP3 for the length of that MP3, so it&#39;s either decode and idle, or slow down the decode by idling smartly so the DVFS doesn&#39;t have to handle a spike. Spiking CPU loads can cause the DVFS to artificially keep processor power up (it costs power to switch, so minimizing switching is a good thing), wasting power when the CPU is idle.</p>
<p>If the app is going to crunch data for a few seconds then go idle for a while (e.g., web page display), then the browser knows it should render it at once, then pre render the scroll regions in anticipation of the use (while the CPU is at peak speed), the slow down and try to minimize utilization to keep the load low so DVFS won&#39;t switch.</p>
<p>Trying to keep utilization sane while under various loads drove me nuts &#8211; if we filtered for spikes during audio playback, we got skipping video because the CPU didn&#39;t ramp up fast enough. And at the CPU utilization level, you can&#39;t determine the application in use in order to choose the right profile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879623">
				<div id="div-comment-879623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Magnum</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879623">
			December 7, 2010 at 2:54 am</a>		</div>

		<p>Had this very issue come up the other day. &nbsp;I&#39;m working on improving response times on an old system by multi-threading it, and I said in a process meeting I was making good progress because my threads were using close to 100% CPU.</p>
<p>Not one, but two managers piped up to say &quot;No we can&#39;t have that&quot; and despite my repeated explanations of why yes we do they insisted CPUs shouldn&#39;t run at full capacity for some reason.</p>
<p>I had to pick my bottom jaw up off the floor.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879693">
				<div id="div-comment-879693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879693">
			December 7, 2010 at 1:04 pm</a>		</div>

		<p>@f0dder: &quot;no, the OS power options don&#39;t help diddly squat against that.&quot;</p>
<p>What setting are you changing, because it helps for me.</p>
<p>@Different Alex: &quot;(and actually the desktop&#39;s fan is only 80mm &#8230;)&quot;</p>
<p>Maybe yours are, but I have four fans in my desktop (I think) and all four are 120mm.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879743">
				<div id="div-comment-879743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin Provance</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879743">
			December 7, 2010 at 5:43 pm</a>		</div>

		<p>Task Manager? &nbsp;LOL! &nbsp;WTF is that? &nbsp;Most evolved Windows users (programmers) use Process Explorer. &nbsp;Anything else is useless.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879763">
				<div id="div-comment-879763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879763">
			December 7, 2010 at 6:47 pm</a>		</div>

		<p>@Evan: The 80mm reference was supposed to show that even with just 80mm vs 120mm, you can get a noise free desktop. And just so you know, the big case fan in the back is 120mm :)</p>
<p>@Ben No it is not a good idea to artificially slow down your transient process by programming it that way. That, as the article states, is what priorities are for. Which of course you can use from your program, just set your priority to something lower. However, if nothing else on the system wants the CPU, this means that your process can still take 100% of the CPU power (if it can saturate that, as we have already shown at length in the comments, that most desktop processes are somehow I/O bound anyway. I do that with video encoding jobs on my server under Linux using the nice utility. The encoding runs at 100% CPU usage when nothing else wants the CPU, but as it&#39;s priority is very low, nothing else on the system suffers if it wants to have the CPU (like say video playback) if it wants the CPU. But if nothing else is using the CPU, I don&#39;t waste half the CPU. Same goes for disk I/O (ionice).</p>
<p>Assigning a maximum CPU usage percentage is just the same BS and not cool. Just set priorities.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879773">
				<div id="div-comment-879773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879773">
			December 7, 2010 at 7:46 pm</a>		</div>

		<p>@Diff Alex</p>
<p>I&#39;m not sure you understand my point. First of all, I am not referring to &quot;desktop processes&quot;, but rather server processes. More specifically server processes who have a real-time component and thus &quot;fail&quot; if timeliness constraints are not met. These are not, I suppose, the most common problems to be concerned with, but they are issues that I must contend with, and are relevant to the topic. With those assumptions in mind:</p>
<p>One of the issue I face in coding components for my companies application that must contend with large (enormous) I/O loads that are CPU bound, is how to deal with peak loads in avalanche conditions. In the environment this software is used, base loads and peak loads are predictable and model-able and it useful for the customer to be able to tune the priorities based on the type of data. This allows continued timeliness of the base load, at the sacrifice of slower processing of data that does not have the same constraints (or less stringent constraints). In this case thread priorities is insufficient, as the control goes to the O/S and the user can not predict the behaviour. So in this context I think you can see why &quot;artificially&quot; slowing down the processing of transient data can be a good idea.</p>
<p>To my second point; one of the issues I must contend with is that there is a strong incentive to run multiple server processes on an individual box. This is due to the fact that it significantly reduces overall cost (due to licenses). In this scenario it is important that one process that is being overwhelmed, does not affect the performance of another. This is currently achieved by binding these processes to individual cores to ensure that their CPU usage is capped. Again, giving control back to the O/S removes the users control in this context, and makes it impossible to provide performance guarantees on time-critical data. So I thought it would be nice to be able to divide up the CPU in a more fine-grained way than by core.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879793">
				<div id="div-comment-879793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker59</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879793">
			December 7, 2010 at 8:43 pm</a>		</div>

		<p>f0dder: No, I didn&#39;t see that price comparison that said that cheap thermal paste vs. silver thermal paste would only result in 2 degrees C of difference. &nbsp;For me, it has resulted in 5-10 degrees C of difference, even when I did not replace the heatsink. &nbsp;YMMV.</p>
<p>And I don&#39;t know about your price comparisons, but you could be right. &nbsp;A large SSD costs a lot of money, and so does more than 4GB of DDR3 memory. &nbsp;I have more than one machine that can only accept 4 GB of memory, so the 60GB value SSD was cheaper than a new motherboard, CPU, and new DDR3 memory!</p>
<p>What bothers me, and I&#39;ll bet many other people, is when the CPU fan speeds up, and slows down, and speeds up, and slows down, etc. &nbsp;I turned off the automatic CPU fan speed control in several motherboards, and simply reduced the fan speed (after using silver thermal paste). &nbsp;That changing speed noise is much more noticeable than a constant fan speed (I think).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879803">
				<div id="div-comment-879803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879803">
			December 7, 2010 at 8:47 pm</a>		</div>

		<p>That does explain some things, thanks :) May I ask which operating system this would be on?</p>
<p>If loads are predictable and model-able, maybe you should use an O/S where you can actually specify these things to the O/S, so that scheduling algorithms can take them into account. Redoing an O/S&#39;s work in every application is however not something I think should be done. If you need guarantees, use a real time O/S &#8230; Also it feels like &quot;This allows continued timeliness of the base load, at the sacrifice of slower processing of data that does not have the same constraints&quot; is kinda what I was describing with the background video conversion vs. foreground video playing. The video conversion has less stringent constraints. It should finish reasonably fast but it certainly shouldn&#39;t keep the video playback starving. So, you give video playback a high priority (higher than normal tasks, except for kernel tasks) and encoding is niced, so that it yields to any other process. That pretty much describes it I think.</p>
<p>Can you elaborate on what &quot;CPU bound I/O load&quot; is? Is it I/O bound or CPU bound? I don&#39;t get it.</p>
<p>OK, so you care about one process not starving another process. That, to me, sounds like what scheduling algorithms are all about and that is precisely what the job of an O/S is and what a lot of operating system research has gone into over the last 50 years. Why would you make every single application programmer responsible for this, when there are very bright people writing operating systems to tackle exactly this problem for you? If you need guarantees, use an operating system that can give you a guarantee, but don&#39;t be surprised if those guarantees mean that you have to sacrifice some raw performance (see soft vs. hard real time O/S).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879823">
				<div id="div-comment-879823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879823">
			December 7, 2010 at 9:34 pm</a>		</div>

		<p>@Diff Alex</p>
<p>In answer to your questions. We use Windows operating systems. Yes in essence this is a hard real time system (or firm if you prefer), attempting to use a non real-time O/S (Performance requirements are confirmed by simulation during commissioning, or by having hardware that greatly exceeds the base load requirements). You may be surprised at how frequently this occurs. The why&#39;s and wherefores of this would take many paragraphs to explain, but suffice to say that no competitor in our industry actually uses a real-time O/S to my knowledge. Over 90% of installations are on Windows servers. Having got that out of the way, the load is a large I/O load that is CPU bound long before hitting I/O limitations (due to the amount of work that must be performed on each data piece). I agree that tweaking the scheduling is precisely what an application should not do in a normal situation. In this instance though, I am referring to an application balancing it&#39;s own load (for which it does indeed have an internal scheduler that provides hard-real time allocation of CPU within the context of the process). This is about trying to get the nice predictable behaviour of a real-time system. And yes, you are correct in saying that some performance may be sacrificed in pursuit of this goal (we spend a great deal of time trying to optimise this however).</p>
<p>So assuming that a 20 year legacy code base cannot be adapted to a real-time OS in any sane business case, pragmatic solutions are required. From this point of view, I would love to be able to tell the O/S, &quot;balance the CPU load as you see fit, but honour these conditions&quot;. However, the current system is fine, cores are cheap and getting cheaper; and if the CPU is mostly idle in one or two of them, our customers could not care a whit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879833">
				<div id="div-comment-879833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879833">
			December 7, 2010 at 9:49 pm</a>		</div>

		<p>More generally, I&#39;m not a network admin, but I imagine they face similar issues. Can you run a web server and an exchange server on the same box? What happens when the web server comes under too heavy a load, do you lose access to email as well? I imagine network admins work around this with multiple boxes or virtualisation, but I maintain that it would be great to be able to achieve the same effect by being able to put caps on resource usage. Primarily as this would save a good deal of licensing outlay.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-879863">
				<div id="div-comment-879863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879863">
			December 8, 2010 at 12:07 am</a>		</div>

		<p>Different Alex: There are plenty of good reasons to want to throttle CPU usage instead of using priorities. For one thing, process priorities only tell the OS that one class of processes should not run if another class (those with higher priorities) wants to run.</p>
<p>Let&#39;s say I want to run SETI@home and Folding@home, but I think curing cancer is more important than finding aliens, so I want SAH to use just 20% of the CPU and have FAH use the rest. I can&#39;t just set SAH to a lower priority because FAH will never (well, rarely) give it a chance to execute.</p>
<p>Another example is web pages. I want to leave a web page open all the time, but the ads on the page consume vast quantities of CPU. Lowering the priority of the process will make it impossible to read my webmail while I&#39;m compiling, yet it will still make my fan run and drain my laptop&#39;s battery. If I could set the web browser to use only, 10% of the CPU, I could still use it as I want to without it noticeably slowing down anything else and without it draining my battery.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-879923">
				<div id="div-comment-879923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-879923">
			December 8, 2010 at 7:02 am</a>		</div>

		<p>@Ben Thanks for those explanations! If all you are doing is scheduling your own application, well yeah. But don&#39;t run anything other than your software on that system or everything goes out the window (see other stories by Raymond, like &quot;What if more than one program does that&quot; :)</p>
<p>As for admins. I was one for a smaller company and worked closely with them in a larger one and yes, that&#39;s what they did. Smaller company, it didn&#39;t matter, load wasn&#39;t that high anyway, large company, dedicated CPU resources etc. If you are large enough that you need the resources, you need the resources. Sharing them only makes sense, if you are just idling anyway. Oh and man LPAR (i.e. admins have done this for forever), and man ulimit (at least on real UNIXes) :)</p>
<p>@Gabe: As for SETI, well, bad example in my book :) Web pages, get noscript and ads don&#39;t bother you any longer. If you web browser is only allowed to use 10% of the CPU your webmail would still be slow, as the ads would suck up all of those 10% &#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880033">
				<div id="div-comment-880033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-880033">
			December 8, 2010 at 8:31 am</a>		</div>

		<p>I&#39;m sure Task manager is making calculated guesses most of the time, mathematically, 100% CPU means nothing left to calculate the CPU load. Hence the best form of measurement is the temperature!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880133">
				<div id="div-comment-880133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-880133">
			December 8, 2010 at 10:55 am</a>		</div>

		<p>Different Alex: Are you aware of what ulimit does? It kills your process once it&#39;s used so many seconds of CPU time! That&#39;s completely unrelated to what Ben is asking for.</p>
<p>All you&#39;re doing is coming up with hack after hack to make up for the fact that there&#39;s no simple way to just tell the OS not to let a process use too many resources at once. Using LPARs has all the administrative overhead of having separate computers; not running Folding@home means I don&#39;t get to help cure cancer; turning off scripts in my webmail means my webmail doesn&#39;t work either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880243">
				<div id="div-comment-880243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-880243">
			December 8, 2010 at 1:30 pm</a>		</div>

		<p>@Gabe: LPAR and ulimit were meant for Ben, LPAR especially in regards to his virtualization etc. comments yes. Also, how is an RTOS a hack if your job requires an RTOS to be executed correctly? If you don&#39;t want to do that and want to use Windows. Stop complaining.</p>
<p>As for you, I am aware of the problem with you two *@homes, but I didn&#39;t like the examples. However, the browser thing: not true. I never told you to turn of scripts, but to use noscript! That&#39;s a Firefox plugin, where you can selectively disable and enable certain domain&#39;s scripts. Works like a charm. I almost never see any ads, as most ads are just loaded/displayed using javascript from easily blockable domains. E.g., who would want to execute ANY script from doubleclick.net? So you just disable doubleclick.net from executing scripts. However, hotmail.com is not disabled and you get to use your webmail&#8230; As said, it only works with almost every ad, but I can live with that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-880253">
				<div id="div-comment-880253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Different Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-880253">
			December 8, 2010 at 1:32 pm</a>		</div>

		<p>Oh and I forgot, use the RequestPolicy plugin together with that, so you can selectively allow/disallow cross domain script execution/calling.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-880423">
				<div id="div-comment-880423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101203-00/?p=12123#comment-880423">
			December 9, 2010 at 1:07 am</a>		</div>

		<p>Different Alex: Switching to a different OS is a hack because the scheduling feature he wants is only *one* of the features that his service needs. Who&#39;s to say that there exists an OS with all the features he needs? If Windows has every feature he needs except one, what&#39;s wrong with asking for that one feature?</p>
<p>And I don&#39;t understand the ulimit comment. Ben was talking about putting a web server and a mail server on the same box. Where does ulimit come in? It&#39;s not like you would want to kill the web server after it&#39;s taken up too much CPU! All he wants to do is make sure a heavily-loaded web server doesn&#39;t bog down the mail server and vice-versa. It seems like this sort of thing ought to be trivial to do without the overhead of virtualization.</p>
<p>What don&#39;t you like about my *@home examples? Millions of people run such software and lots of them wish they could do so without using lots of energy. Face it, CPU cycles aren&#39;t free anymore. When you use the CPU, you are using power and generating heat. In laptops this shortens battery life, causes fan noise, and can make computers too uncomfortable to hold. In data centers it drives up electricity and cooling costs.</p>
<p>As for the webmail example, noscript is not a general solution. What if the ads are served from the same domain as the mail scripts? What if it detects that ads are blocked and refuses to give me mail until I unblock them? What if I&#39;m required to use IE6? What if the slowdown is in the webmail scripts themselves rather than the ads?</p>
<p>Another (real-life) example is this Flash game I like to play. It uses 100% of a CPU no matter whether it&#39;s idle (paused) or in the middle of a level, no matter how fast my CPU is. Why? I don&#39;t know. All I know is that I can only play it when my laptop is plugged in or it drains the battery in an hour or two. If I could tell the OS to give it fewer or shorter timeslices, the game should still be playable (it works just fine on slow netbooks), just without using up nearly so much power.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>