<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (39)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-168823">
				<div id="div-comment-168823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168823">
			April 28, 2004 at 8:33 am</a>		</div>

		<p>Another instance where C++ does the Right Thing and other languages (C#, Java, et al.) do not.</p>
<p>It&#8217;s funny.  C++ is clunky in so many areas (the syntax has so many horrors due to declaration mimics use, some pointless restrictions on what you can do with templates, the stupid inclusion model and use of the C preprocessor, = 0 for pure virtual functions, etc. etc.), yet time and time again manages to do the right thing where its &quot;superior&quot; derivatives do not.</p>
<p>If only the C++ Working Group would realize that breaking changes are not the end of the world, they could fix these problems, and make a much more approachable, even more expressive language.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-168843">
				<div id="div-comment-168843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168843">
			April 28, 2004 at 8:57 am</a>		</div>

		<p>Yeah, I didn&#8217;t know C# behaved that way.  Between that and its lack of const, I&#8217;m starting to dislike the language more and more.  Maybe I should read up on it to dislike it more :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-168863">
				<div id="div-comment-168863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://chuacw.hn.org/chuac' rel='external nofollow' class='url'>Delphi Developers' Singapore and Asia Fortress of</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168863">
			April 28, 2004 at 9:22 am</a>		</div>

		<p>Mr Pizza, well, IMO, Delphi did the right thing, ie, you cannot instantiate a class with at least one abstract method.</p>
<p>You guys should really look at Delphi.</p>
<p>Jack, you should try Delphi anyway&#8230; C# is derived from Delphi.</p>
<p>Also, take a look at the comparison between C# and Delphi, here <a target="_new" href="http://chuacw.hn.org/chuacw/archive/2004/04/28/460.aspx" rel="nofollow">http://chuacw.hn.org/chuacw/archive/2004/04/28/460.aspx</a> and here <a target="_new" href="http://chuacw.hn.org/chuacw/category/47.aspx" rel="nofollow">http://chuacw.hn.org/chuacw/category/47.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-168873">
				<div id="div-comment-168873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168873">
			April 28, 2004 at 9:30 am</a>		</div>

		<p>You&#8217;re not allowed to do that in C# or C++ either.  You have to instantiate the base class.  The question is, what is the object&#8217;s identity when the base class constructor is running?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-168883">
				<div id="div-comment-168883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.wallace.net/marc/resume/' rel='external nofollow' class='url'>Marc Wallace</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168883">
			April 28, 2004 at 9:38 am</a>		</div>

		<p>I could see it being useful knowing your eventual type in the constructor.</p>
<p>It doesn&#8217;t feel intuitive to me, though.  Even though I hadn&#8217;t known how C++ handled it (never really tried it before), it makes sense to me that the object would start out a Base and become a Derived.  This also matches how the compiler invokes super() as a precondition before Derived&#8217;s constructor executes.</p>
<p>On the other hand, consider cases where you explicitly call super(), perhaps near the end of Derived&#8217;s constructor.  By that point, the object must already be a Derived.  So maybe the C# way makes sense, and maybe my intuition is just wrong?</p>
<p>C# is also a bit messy because of all the intra-language concerns (as was mentioned in the const links from yesterday).  Besides, the name is silly.  I keep wanting to call it &quot;D flat&quot;. ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-168903">
				<div id="div-comment-168903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168903">
			April 28, 2004 at 9:50 am</a>		</div>

		<p>And here is a bit of trivia for all the Morts: C++ lets you define the pure virtual function.</p>
<p>struct Foo {<br />
<br /> virtual void foo() = 0;<br />
<br />};</p>
<p>inline void Foo::foo() { }</p>
<p>struct Boo : Foo {<br />
<br /> void foo() { }<br />
<br />};</p>
<p>Boo b;<br />
<br />b.Foo::foo();<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-168943">
				<div id="div-comment-168943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168943">
			April 28, 2004 at 11:07 am</a>		</div>

		<blockquote><p>
  C++ lets you define the pure virtual function. </p>
<p>Lemme guess: you found out about this while tracking some bizarre bug?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-168813">
				<div id="div-comment-168813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://msmvps.com/gbvb/posts/5598.aspx' rel='external nofollow' class='url'>Girish Bharadwaj</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168813">
			April 28, 2004 at 11:14 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-168953">
				<div id="div-comment-168953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168953">
			April 28, 2004 at 11:19 am</a>		</div>

		<p>Making a virtual function call in the constructor rarely makes sense anyway.  I have to vote that C++ got this better (though not right) &#8211; if the Derived class constructor hasn&#8217;t run, it doesn&#8217;t make sense for a virtual function to resolve to one defined in that class.  That call is going to rely on class invariants that haven&#8217;t been established.<br />
<br />IMHO, the right way is with post-constructors, functions that runs at construction time, but only after the object is fully formed.  ATL COM objects support these, I think.  I forget what they call them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-168963">
				<div id="div-comment-168963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aarrgghh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168963">
			April 28, 2004 at 11:33 am</a>		</div>

		<p>brian: FinalConstruct() and FinalRelease().</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-168993">
				<div id="div-comment-168993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-168993">
			April 28, 2004 at 12:33 pm</a>		</div>

		<blockquote><p>
  &gt; You have to instantiate the base class. The question is, what is the object&#8217;s identity when the base class constructor is running? &lt;&lt;</p>
<p>The identity in the ctor or dtor should be the class the ctor/dtor is in (not in the &quot;actual&quot; derived class that the class will become).  Why?  In a ctor, the other parts do not exist yet.  They have not been constructed, so they are random bits.  In a dtor, the data has been destroyed, so that part of the object is gone.  Why would you want to call methods in an object that does not exist yet?</p>
<p>In C++, what you get in a virtual call is a function knowing about the data for the parts of the class that have been made or a pure virtual (which I believe is a warning in lots of compilers now, unless the virtual call is a function call away).  In C#, you get it acting on data that doesn&#8217;t exist yet.  While you can obvious write code in either to STILL break, C# is a lot more crash prone in this regard.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169003">
				<div id="div-comment-169003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169003">
			April 28, 2004 at 12:34 pm</a>		</div>

		<p>&#8230; and while the pure virtual in C++ <em>will</em> crash, it will not be a random thing depending on the bits in memory, like the C# crashes/errors would be.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169013">
				<div id="div-comment-169013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169013">
			April 28, 2004 at 12:52 pm</a>		</div>

		<p>Well C# doesn&#8217;t permit uninitialized memory so the result won&#8217;t be random. It&#8217;ll get its default value (for integers, zero).</p>
<p>abstract class Base {<br />
<br />public Base() { x(); }<br />
<br />public abstract void x();<br />
<br />}<br />
<br />class Derived : Base {<br />
<br />public int j;<br />
<br />public override void x() { System.Console.WriteLine(&quot;j = {0}&quot;, j); }<br />
<br />}</p>
<p>class Program {<br />
<br />public static void Main()<br />
<br />{<br />
<br /> Derived d = new Derived();<br />
<br /> d.j = 9;<br />
<br /> d.x();<br />
<br />}<br />
<br />}</p>
<p>this prints</p>
<p>j = 0<br />
<br />j = 9</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169023">
				<div id="div-comment-169023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Tejada</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169023">
			April 28, 2004 at 1:58 pm</a>		</div>

		<p>&quot;And here is a bit of trivia for all the Morts: C++ lets you define the pure virtual function.&quot;</p>
<p>Yes, you can define the body for any pure virtual function and in fact it&#8217;s required for pure desctructors (even if it&#8217;s just an empty body).</p>
<p>Actually, contrary to what Raymond seems to suggest with &quot;which does not exist since it is a pure virtual function&quot;, a &quot;pure&quot; function doesn&#8217;t mean that there&#8217;s no implementation of the function in the base class.<br />
<br />It rather means that descendants are obliged to extend the implementation (the base class is abstract and cannot be instanciated directly) but, as mentioned, the base class can provide a helper or default implementation for the pure function.</p>
<p>Which reminds me of a VC6 bug where destructors of global variables (think singletons) couldn&#8217;t be private because the program finalization routine added by the compiler had to be able to call them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169043">
				<div id="div-comment-169043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169043">
			April 28, 2004 at 3:19 pm</a>		</div>

		<p>Raymond:<br />
<br />So in C#, all types have a default constructor?  Your own classes have to support default construction?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169053">
				<div id="div-comment-169053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169053">
			April 28, 2004 at 3:27 pm</a>		</div>

		<p>Jack: Sorry, I don&#8217;t see how that relates to this subject. Section 10.10.4 of the C# Language Specification is titled &quot;Default Constructors&quot; and discusses what C# default constructors are like. But I don&#8217;t see how that is relevant here.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169073">
				<div id="div-comment-169073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169073">
			April 28, 2004 at 4:30 pm</a>		</div>

		<p>&quot;Making a virtual function call in the constructor rarely makes sense anyway.&quot;<br />
<br />It crops up naturally from time to time, and that C++ does things the right way is useful.  That C# (and Java, for that matter) do not do things the right way is similarly unhelpful.</p>
<p>&quot;IMHO, the right way is with post-constructors, functions that runs at construction time, but only after the object is fully formed.&quot;<br />
<br />It&#8217;s not clear what this would do or what problem it would solve.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169093">
				<div id="div-comment-169093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169093">
			April 28, 2004 at 4:58 pm</a>		</div>

		<blockquote><p>
  It&#8217;s not clear what this would do or what problem it would solve.</p>
<p>You can eat your cake and not choke on it.  The object is fully-formed by the time the code in the post-constructor runs, and virtual functions resolve to the most-derived implementation.  Compare this to the C++ approach where you can call undefined functions (the topic of this blog entry) or the C#/Java approach where the function can manipulate members that haven&#8217;t been initialized (because the function call is defined in a more-derived class which hasn&#8217;t been constructed yet).
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169113">
				<div id="div-comment-169113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169113">
			April 28, 2004 at 6:31 pm</a>		</div>

		<p>Raymond:</p>
<p>If you have a private default constructor, then how is the memory &quot;default constructed&quot; ?  By what you&#8217;re saying, before a class with virtuals is instantiated, it would have to be pre-default constructed because its first ctor is ever called.</p>
<p>It&#8217;s more likely the memory is just guaranteed to be zeroed, which is very much different than the objects all having default construction.</p>
<p>And if the memory is just zeroed, then it&#8217;s very much invalid data, though at least it&#8217;s not random.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169123">
				<div id="div-comment-169123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169123">
			April 28, 2004 at 6:47 pm</a>		</div>

		<p>&quot;You can eat your cake and not choke on it.&quot;<br />
<br />I don&#8217;t choke on it in C++.</p>
<p>&quot;The object is fully-formed by the time the code in the post-constructor runs, and virtual functions resolve to the most-derived implementation.&quot;<br />
<br />If I wanted the most derived version to be called I wouldn&#8217;t have called the virtual function from the flipping base class constructor!</p>
<p>&quot;Compare this to the C++ approach where you can call undefined functions (the topic of this blog entry)&quot;<br />
<br />Er&#8230; so?  That&#8217;s not the wrong thing to do.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169153">
				<div id="div-comment-169153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169153">
			April 28, 2004 at 7:26 pm</a>		</div>

		<p>&quot;The object is fully-formed by the time the code in the post-constructor runs, and virtual functions resolve to the most-derived implementation.&quot;</p>
<p>Wait, so if you have two classes where Foo is derived from Bar, then Bat&#8217;s variables get constructed, then Foo&#8217;s, THEN Bar&#8217;s ctor function then Foo&#8217;s?  If so, that&#8217;s completely asinine.  How do you go about showhorning code between the two without making some proxy object that calls back into Bar?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169163">
				<div id="div-comment-169163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://chuacw.hn.org/chuac' rel='external nofollow' class='url'>Delphi Developers' Singapore and Asia Fortress of</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169163">
			April 28, 2004 at 10:34 pm</a>		</div>

		<blockquote><p>
  Raymond,<br />
  <br />You said &quot;The question is, what is the object&#8217;s identity when the base class constructor is running? &quot;</p>
<p>Why is knowing the object&#8217;s identity during construction important?</p>
<p>For me, at least, this question never came up at all. I suspect this might be the case for some other Delphi developers.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169183">
				<div id="div-comment-169183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169183">
			April 28, 2004 at 11:05 pm</a>		</div>

		<p>Jack: All variables get an initial value; I don&#8217;t know what the rules are but presumably rules exist. </p>
<p>And &quot;How do you go about shoehorning&#8230;&quot;? Presumably the CLR somehow manages to know how to construct the objects.</p>
<p>Delphi: So if you invoke a virtual method from the base class&#8217;s constructor, which function gets called? The one defined by the base class or the one defined by the derived class? Or is this merely something that Delphi people don&#8217;t do in the first place?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169213">
				<div id="div-comment-169213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog@hronk.com' rel='external nofollow' class='url'>Jason McCullough</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169213">
			April 29, 2004 at 12:06 am</a>		</div>

		<p>Yeagh, that&#8217;s horrible.  So the problem is that the garbage collector has to violate the &quot;external objects cannot access an object before it is fully constructed&quot; kinda-rule?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169223">
				<div id="div-comment-169223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Petr Kadlec</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169223">
			April 29, 2004 at 12:32 am</a>		</div>

		<p>Interesting, I have probably never give much thought to that (just like I don&#8217;t need to call virtual functions in constructor), so the answer is maybe that Delphi people don&#8217;t do that.<br />
<br />So I&#8217;ve made a little test. Results: Delphi calls the virtual function &quot;correctly virtually&quot;, i.e. it calls the implementation of the derived class, even if called in constructor.<br />
<br />But it may be because of another difference &#8212; in Delphi, the inherited constructors are <em>not</em> called automatically, you have to explicitly call them using &quot;inherited&quot;. (And, like C#, Delphi objects have their memory initialized to zeros at the time the constructor gets called.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169283">
				<div id="div-comment-169283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.whirlingdervishes.com' rel='external nofollow' class='url'>Henk Devos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169283">
			April 29, 2004 at 7:24 am</a>		</div>

		<p>True, Delphi will create an object of the derived type before calling any constructors, but set all memory to 0. Delphi programmers tell me that they like this behavior, that they think it&#8217;s superior to the C++ behavior.<br />
<br />In reality it means Delphi does not have real constructors.</p>
<p>But to go back to the original subject:<br />
<br />If the problem is just that the GC needs to determine the size, what would be wrong with just putting the size somewhere? Isn&#8217;t this how all allocators/deallocators are supposed to work?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169293">
				<div id="div-comment-169293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169293">
			April 29, 2004 at 8:32 am</a>		</div>

		<p>Putting the size with the object would increase the size of each object by 4 bytes just to cover a case that most people consider to be bad programming form anyway.</p>
<p>Since when are allocators &quot;supposed&quot; to work by putting the size with the allocation? There are many systems which do not do this. (The &quot;buddy system&quot; for example infers the size from the address.  Most GCs infer the size from other metadata.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169363">
				<div id="div-comment-169363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Centaur</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169363">
			April 29, 2004 at 9:44 am</a>		</div>

		<p>In Delphi, constructors are a very peculiar thing.</p>
<p>First, they serve as initializers. After a new object is created, one of its constructors is used to give it initial value. Only the most derived constructor is called, which means the developer is responsible for calling a superclass constructor, either directly or by calling another  constructor of the same class.</p>
<p>Second, a constructor is used as a class-scope factory method. The usual syntax is:</p>
<p>myObject := TMyClass.Create(…);</p>
<p>Another syntax is to call a constructor on an instance, in which case it (re)initializes the instance. This is commonly used in derived constructors to call the inherited constructor on the same object. However, it might be possible (I didn’t check) to take a pointer to raw memory, cast it into a reference to an object, and invoke a constructor on that reference, thus constructing an object in arbitrary memory space, not just the default heap.</p>
<p>Third, Delphi has a concept of class references. A class reference is a variable that is assigned a class as a whole. Class-scope methods of the class become instance-scope methods of the class reference. Since a constructor is a class-scope method behaving as a factory, it becomes an instance-scope factory method of a class reference. This, and the fact that constructors can be virtual (in terms of the class reference), allows to create objects whose type is only known at runtime.</p>
<p>var<br />
<br />  MyClass: class of TControl;<br />
<br />  MyObject: TControl;<br />
<br />…<br />
<br />if someCondition then<br />
<br />  MyClass := TButton<br />
<br />else<br />
<br />  MyClass := TCheckBox;<br />
<br />…<br />
<br />MyObject := MyClass.Create(MyForm); // creates a button or a checkbox</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169653">
				<div id="div-comment-169653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169653">
			April 29, 2004 at 10:05 pm</a>		</div>

		<p>Why does C++ have to swap vtables?  I would assume that, since the type is known in the constructor, calls to virtual functions could be made directly, without involving the vtable at all&#8230;  Then attempting to call a pure virtual method could be a compile time error, or at least link time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169673">
				<div id="div-comment-169673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169673">
			April 29, 2004 at 10:49 pm</a>		</div>

		<p>True if it&#8217;s coming from the constructor, but what about this: </p>
<p>class Base {<br />
<br />public:<br />
<br />Base() { g(); }<br />
<br />virtual void f() { cout &lt;&lt; 1; }<br />
<br />void g() { f(); }<br />
<br />}; </p>
<p>class Derived : public Base {<br />
<br />public:<br />
<br />virtual void f() { cout &lt;&lt; 2; }<br />
<br />}; </p>
<p>Derived d;<br />
<br />d.g(); </p>
<p>What code should be generated for the function Base::g()? If it is called from the constructor, then you must call Base::f(), but if it is called from a fully-constructed Derived object, then you must call Derived::f(). </p>
<p>That&#8217;s why you need to swap the vtable. For all the g()&#8217;s out there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169783">
				<div id="div-comment-169783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.whirlingdervishes.com' rel='external nofollow' class='url'>Henk Devos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169783">
			April 30, 2004 at 6:13 am</a>		</div>

		<p>Raymond:<br />
<br />Putting the size with the object would increase the size of each object by 4 bytes just to cover a case that most people consider to be bad programming form anyway.<br />
<br />Since when are allocators &quot;supposed&quot; to work by putting the size with the allocation? There are many systems which do not do this. (The &quot;buddy system&quot; for example infers the size from the address. Most GCs infer the size from other metadata.) </p>
<p>First of all, i think the 4 bytes for the size would be a small overhead cmpared to the type information. But even if it&#8217;s small you would still have some point (every bit helps).<br />
<br />But you give a better formulation of what i said yourself: A memory manager will always have some way of knowing the size. It has to. Wether using the buddy system as you say, using blocks that contain the size, using pools of blocks for a given size, or any other method, you can always know the size, and this is essential to a memory manager. I just don&#8217;t see the use of relying on the type information for this.<br />
<br />And how is this implemented? I suppose there is just a size field in the type description that&#8217;s not used for anything else?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-169813">
				<div id="div-comment-169813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169813">
			April 30, 2004 at 6:42 am</a>		</div>

		<p>I don&#8217;t know precisely how it&#8217;s implemented, but I do know that the size is not kept with the object.  The CLR folks have gone to extraordinary lengths to get the per-object overhead as low as possible. There are ways of doing this without increasing the overhead (e.g., &quot;dummy types&quot; which exist only during construction) but as I noted, it seems an excessive amount of effort for something that most people recommend against anyway. Why penalize people who don&#8217;t use it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-169943">
				<div id="div-comment-169943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">M Knight</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-169943">
			April 30, 2004 at 9:10 am</a>		</div>

		<p>The Delphi translation would either be &#8216;2&#8217; or &#8217;22&#8217; depending if you added the constructor chaining. Since constructor chaining is purely voluntary.</p>
<p>In Delphi, every class has a &#8216;class type&#8217; metadata imbedded into the exe/dll. This &#8216;class type&#8217; data contain the v-table + misc metdata as well as a number of &#8216;special&#8217; virtual functions, which implement some neat fucntionality.</p>
<p>To create an object, you obtain a class-reference and call an object constructor in that class reference(constructors can be named). The size of the object, is determined by the class reference which knows how much memory to allocate as well as special actions to take for reference counted fields(Strings &amp; interfaces are reference counted under Delphi for Win32). The object itself probably doesnt know it size, but the class-definition does.</p>
<p>Once you have a valid class reference, you have everything you need to create a new object from that class reference. Constructors are really initializers, as thats all they do under the Delphi Object model(Memory allocation &amp; deallocation are handled by 2 virtual class reference methods).</p>
<p>Saddly, non of the internals of the class are publicly documented. As with some fleshing out, you could easily build a native win32 version of .NET Reflection. </p>
<p>I&#8217;ve derived some methods which actually allow you to create new class definitions, but it was incredibly crude due to the lacking metadata.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-170183">
				<div id="div-comment-170183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Petr Kadlec</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-170183">
			April 30, 2004 at 2:28 pm</a>		</div>

		<p>I don&#8217;t agree that none of the internals are documented. If you take a look at the TObject&#8217;s methods, you&#8217;ll see quite many useful things. (Like ClassParent, FieldAddress, MethodName, MethodAddress, InstanceSize, and of course the often-used ClassName.) And, if that is not enough, just take a look at System.pas, where you will find much fun. :-)</p>
<p>But, I am afraid that we are getting off-topic &#8212; these are &quot;actually not a .NET comments&quot;. ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-170213">
				<div id="div-comment-170213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-170213">
			April 30, 2004 at 3:41 pm</a>		</div>

		<p>&lt;i&gt;That&#8217;s why you need to swap the vtable. For all the g()&#8217;s out there.&lt;/i&gt;</p>
<p>Ah, those pesky g()&#8217;s.  Thanks for the explanation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-170223">
				<div id="div-comment-170223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-170223">
			April 30, 2004 at 3:41 pm</a>		</div>

		<p>&lt;hmpf/&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-170303">
				<div id="div-comment-170303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://chuacw.hn.org/chuac' rel='external nofollow' class='url'>Delphi Developers' Singapore and Asia Fortress of</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-170303">
			May 1, 2004 at 5:20 am</a>		</div>

		<p>Raymond, assuming declarations</p>
<p>type<br />
<br />TBase = class<br />
<br />public<br />
<br />  constructor Create;<br />
<br />  procedure SomeProc; virtual;<br />
<br />end;</p>
<p>TDerived = class(TBase)<br />
<br />public<br />
<br />  procedure SomeProc; override;<br />
<br />end;</p>
<p>constructor TBase.Create;<br />
<br />begin<br />
<br />  SomeProc;<br />
<br />end;</p>
<p>procedure TBase.SomeProc;<br />
<br />begin<br />
<br />  WriteLn(&#8216;Hello&#8217;);<br />
<br />end;</p>
<p>procedure TDerived.SomeProc;<br />
<br />begin<br />
<br />  WriteLn(&#8216;World&#8217;);<br />
<br />end;</p>
<p>var<br />
<br />  Base: TBase;<br />
<br />begin<br />
<br />  Base := TDerived.Create;<br />
<br />end.</p>
<p>then, &quot;World&quot; is displayed, therefore, like Petr pointed out, the &quot;correct&quot; virtual function is called.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-170333">
				<div id="div-comment-170333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-170333">
			May 1, 2004 at 7:45 am</a>		</div>

		<p>On the other hand, in the first comment, DrPizza claims that the C++ behavior is the &quot;correct&quot; behavior. Different people have different ideas as to what &quot;should&quot; be done here, and it is reflected in how each language is designed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-170313">
				<div id="div-comment-170313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://chuacw.hn.org/chuacw/archive/2004/05/01/471.asp' rel='external nofollow' class='url'>Delphi Developers' Singapore and Asia Fortress of</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040428-00/?p=39613#comment-170313">
			May 1, 2004 at 8:21 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>