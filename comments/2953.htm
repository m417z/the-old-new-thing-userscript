<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1082353">
				<div id="div-comment-1082353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082353">
			October 11, 2013 at 7:08 am</a>		</div>

		<p>Raymond&#39;s not kidding about the undefined behavior. The platforms that leave this undefined are also likely to have no memory protection. You might call a NULL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082383">
				<div id="div-comment-1082383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082383">
			October 11, 2013 at 8:12 am</a>		</div>

		<p>@Joshua, Calling a null and getting SEGV and dumping core, IS memory protection. Putting a null in the vtable is a good choice.</p>
<p>Some platforms instead use a wrapper function that produces a sensible diagnostic and calls abort. Also a reasonable choice.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082393">
				<div id="div-comment-1082393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082393">
			October 11, 2013 at 8:24 am</a>		</div>

		<p>@Ben: I believe I said the ones that end up with calling a NULL or some other hideously undefined result such as uninitialized memory in the vptr are often the ones that don&#39;t have any memory protection so calling a NULL does something but not what you want.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf odd alt thread-odd thread-alt depth-1" id="comment-1082403">
				<div id="div-comment-1082403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082403">
			October 11, 2013 at 8:29 am</a>		</div>

		<p>In short, the reason we get a linker error in the first case (instead of a runtime error), is that the constructor calls f() directly (or at least, tries to) instead of going through the vtable (and getting __purecall instead) ?</p>
<p>On the other hand, call_f() is not a constructor, so it goes through the vtable&#8230;</p>
<div class="post">[<em>Thanks for filling in that gap. I realized just now that I forgot to answer that question. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082463">
				<div id="div-comment-1082463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Misha</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082463">
			October 11, 2013 at 10:48 am</a>		</div>

		<p>&gt; &nbsp;What happens when the test function constructs a Derived? </p>
<p>You mean the main function, right?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082483">
				<div id="div-comment-1082483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082483">
			October 11, 2013 at 10:52 am</a>		</div>

		<p>@Ben:</p>
<p>Unless your C++ is in kernel mode, and you&#39;re running on Windows7.</p>
<p>In which case an attacker might have put some shellcode at NULL. And you just called it over a security boundary from Ring-0, giving it control of your machine, and letting it take your credit card numbers and install drivers all over your system.</p>
<p>Every Single Windows Patch Marked As Critical is caused by undefined behavior in the language. Don&#39;t fall into the trap of thinking that undefined behavior will fail safe. It typically won&#39;t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082503">
				<div id="div-comment-1082503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082503">
			October 11, 2013 at 10:55 am</a>		</div>

		<p>Batman will always regret the day he had to implement a pure virtual function in its base class.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082513">
				<div id="div-comment-1082513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tyler Reddun</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082513">
			October 11, 2013 at 11:00 am</a>		</div>

		<p>This is a corner case, but there is just enough rare places where it can be useful (@Chris had a great example of that) that maybe it should be codified in some future version of the spec. That way you&#39;ll no longer run the risk of corrupting memory, summing Candle Jack or having your hard drive</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082523">
				<div id="div-comment-1082523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082523">
			October 11, 2013 at 11:46 am</a>		</div>

		<p>&#39;&#8230;the base class constructor has engaged in a conspiracy&#8230; with the function call_f&#8230;&#39;</p>
<p>This sounds like it should be in an advertisement for one of Russinovich&#39;s Zero Day novels.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082533">
				<div id="div-comment-1082533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082533">
			October 11, 2013 at 12:02 pm</a>		</div>

		<p>@Matt: an attacker who can put code at location 0 is already on the other side of the proverbial airtight hatch. It is also not true that every critical security vulnerability is caused by undefined behavior &#8212; if only it were that clear-cut. And finally, you seem to be accusing Ben of holding opinions he never stated. In short, if your post had been an editorial in a magazine, I would be asking for my money back.</p>
<p>It is very true that undefined behavior is bad, though, and programs should not contain it. I think we can reach consensus on that.</p>
<div class="post">[<em>Actually, it&#39;s not true that they are on the wrong side of the airtight hatch. User-mode code could map memory at offset 0, and then kernel code can be tricked into accessing it. You now have elevation from user mode to kernel mode. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082553">
				<div id="div-comment-1082553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082553">
			October 11, 2013 at 1:03 pm</a>		</div>

		<p>@JM: On some Microchip processors, 0 (I forget if their compiler maps NULL to 0 or not) when interpreted as a code segment pointer (Harvard architecture) is the address of the IVT, which consists of jump instructions. You just raised interrupt 0, whatever it may be.</p>
<p>On x86 in 16 bit mode, this executes the IVT offsets as instructions, which is pretty badly undefined. If DOS is loaded, there&#39;s a JMP instruction a few dozen bytes down which will get executed if IP is still aligned correctly. This results in entering the DOS syscall gateway with trashed registers (registers are syscall arguments), then continue from your code (C calling convention = caller cleans up the stack).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082373">
				<div id="div-comment-1082373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082373">
			October 11, 2013 at 7:50 am</a>		</div>

		<p>This is mainly useful for pure virtual destructors. If you need to make your class pure virtual, but don&#39;t have any method in particular that you need overridden, a pure virtual destructor will do that. However, the destructor still needs a definition, and it *is* called implicitly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082433">
				<div id="div-comment-1082433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082433">
			October 11, 2013 at 9:05 am</a>		</div>

		<p>@Joshua: it would be nice to get a machine where this is treated as calling location 0, and location 0 contains wonderful instructions that corrupt your program state (or some *other* program&#39;s state, even better) but don&#39;t terminate it, so you end up with an undebuggable mess. Unfortunately that&#39;s unlikely &#8212; if you have a tinkertoy with no memory protection, calling random instructions is far, far more likely to outright crash or hang the machine than to do something interesting instead. Ah, so much for joy and wonder.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082573">
				<div id="div-comment-1082573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xyz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082573">
			October 11, 2013 at 5:58 pm</a>		</div>

		<p>In regard to the linked article:</p>
<p>Did we ever finish determining if init-methods or constructors are the only right thing?</p>
<p>And there are easy methods around adding size to every allocation to get it for gc, which can be easily optimised to no_vtable for common cases where no virtual is called during construction.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082583">
				<div id="div-comment-1082583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082583">
			October 11, 2013 at 7:52 pm</a>		</div>

		<p>@JM: Windows 7 and earlier allow unprivileged user-mode applications to allocate memory at address 0 within their own process space by calling VirtualAlloc or MapViewOfFile with an nonzero address that gets aligned down to zero; the traditional way is to use (void*) 1. &nbsp;This feature is intentionally used by NTVDM to allocate the interrupt table for V86 mode. &nbsp;Because the Windows NT kernel runs with userspace directly accessible to the kernel, null pointers are dangerous, because that memory is then user-controlled. &nbsp;Windows 8 blocks this by limiting address 0 allocation to NTVDM, which secondarily limits it to 32-bit x86 Windows only.</p>
<p>@Raymond: Why does C++ allow pure virtual functions to have an implementation? &nbsp;This seems silly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082603">
				<div id="div-comment-1082603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082603">
			October 12, 2013 at 2:19 am</a>		</div>

		<p>@Myria: You realise this was the subject of the article, right? Anyway, to repeat it, it&#39;s to allow explicit calls from derived classes, or (as Chris says) to allow destructors (which certainly need an implementation) to be pure virtual.</p>
<p>The only case I&#39;ve seen of this is to allow pure virtual destructors. It was a bit of an idiom in the code that I saw it; it was used fairly regularly to mean &quot;abstract class (but with no naturally abstract methods)&quot;. It feels very suspect to me. If there are no other virtual methods in this class, surely nobody should be manipulating objects (including destroying them) through a pointer of this type anyway? Perhaps you could change inheritance to composition, which is usually an improvement where reasonable possible. Alternatively, if there are some implemented virtual methods but they all &quot;need a bit more&quot; implementation from derived classes, that seems like a rather fragile design.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082633">
				<div id="div-comment-1082633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082633">
			October 12, 2013 at 2:42 am</a>		</div>

		<p>Oh, and slightly off-topic for this article (but not much), since no one mentioned it in the previous one:</p>
<p>The most common cause of &quot;pure virtual method called&quot; bugs, in my experience, is not something happening deep in the constructor&#39;s call stack. Instead it is a symptom of calling a virtual method on an object that&#39;s been destroyed. As the destructor is run the vtable is updated in the opposite way to construction: it moves up the inheritance chain until finally it&#39;s left at the root class. This is left in place when the object is destroyed (there&#39;s no point in setting it to something else, because the memory should never be read again) so if you access it after that, and by chance the memory hasn&#39;t been reused, you&#39;ll use the base class virtual methods.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082653">
				<div id="div-comment-1082653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082653">
			October 12, 2013 at 3:57 am</a>		</div>

		<p>OK, I&#39;d better ask the question in reverse:</p>
<p>Why does a virtual function with an implementation need to be pure? (The example given is to make a class abstract, although I&#39;m not sure why making all the constructors protected doesn&#39;t suffice.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082593">
				<div id="div-comment-1082593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082593">
			October 12, 2013 at 12:18 am</a>		</div>

		<p>@Raymond: Well don&#39;t I feel like pond scum now. But Raymond, isn&#39;t it wrong that user code is allowed to do that if it can cause problems like that? And is it fair to say the kernel is &quot;tricked&quot; when what we mean is that the kernel contains bugs that cause it to access location 0 at times where it shouldn&#39;t?</p>
<p>@Myra: OK, that answers my question. I&#39;m glad Windows 8 fixes this hole. That the kernel can access the memory isn&#39;t worrisome, IMO &#8212; it will inevitably need to, somehow. Even disallowing code access and copying all data to safe buffers first doesn&#39;t mean you can&#39;t stuff data in those buffers that exploits a bug (though it helps, obviously).</p>
<p>@Joshua: I&#39;m happy to learn that there&#39;s actually a far better chance of continuing the program in a corrupted state than I thought! Thanks, I learned something new. (I was thinking of *really* dinky setups like an 8-bit 6502; it is far more likely to encounter an instruction that will hang the processor or invoke an NMI which resets things rather than a jump instruction, let alone one that takes you back to where you came from.)</p>
<div class="post">[<em>In the original design, it was legal for user mode code to whatever it wanted, and people who wrote code that ran in kernel mode need to be understand that 0 was a potentially valid address. In practice, this means that if you find a null pointer bug in kernel, you can use the null mapping trick to turn it into EoP. So yes, what&#39;s really happening is that you are exploiting a null pointer bug in kernel. &quot;Trickery&quot; was an interpretive statement on my part as to your motivation. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082663">
				<div id="div-comment-1082663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082663">
			October 12, 2013 at 7:46 am</a>		</div>

		<p>@Neil: Indeed. That&#39;s how I do it.</p>
<p>Some people go farther and protect the class from trying to instantiate itself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082673">
				<div id="div-comment-1082673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082673">
			October 12, 2013 at 8:10 am</a>		</div>

		<p>Imagine that the pure virtual method is declared in a published header, but the implementation is defined in a private source code file.</p>
<p>There, the actual implementation has an actual virtual method for itself that the audience thinks it does not. It may be a useful technique in a handful of cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082693">
				<div id="div-comment-1082693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082693">
			October 12, 2013 at 1:33 pm</a>		</div>

		<p>Herb Sutter: Does it ever make sense to make a function pure virtual, but still provide a body?</p>
<p><a rel="nofollow" target="_new" href="http://www.gotw.ca/gotw/031.htm">http://www.gotw.ca/&#8230;/031.htm</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082703">
				<div id="div-comment-1082703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082703">
			October 12, 2013 at 2:57 pm</a>		</div>

		<p>@John Doe:</p>
<p>What do you think hiding the implementation of your pure virtual function buys you? People can extend your class anyway, unless its the dtor.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082713">
				<div id="div-comment-1082713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082713">
			October 13, 2013 at 12:19 pm</a>		</div>

		<p>@Deduplicator, but they can&#39;t instance it directly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082733">
				<div id="div-comment-1082733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082733">
			October 13, 2013 at 2:13 pm</a>		</div>

		<p>@John Doe:</p>
<p>Nobody can instantiate an abstract class. So what? And what exatly do you think hiding the implementation in an obscure location buys you?</p>
<p>BTW: Having the implementation in a (bunch of) private source file is standard practice. If its published, you name it opensource, otherwise closedsource.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082743">
				<div id="div-comment-1082743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082743">
			October 13, 2013 at 7:10 pm</a>		</div>

		<p>&gt; In that article, I wrote that a pure virtual function is &quot;a method which is declared by the base class,</p>
<p>&gt; but for which no implementation is provided.&quot; That statement is false.</p>
<p>&gt; You can provide an implementation for a pure virtual method in C++.</p>
<p>Yes the statement is false. The pure virtual function tells the compiler that you&#39;re not going to be providing an implementation, so the class is abstract and an instance cannot be created. You have to derive a class that implements all the pure virtual functions before you can create one.</p>
<p>The linker you use doesn&#39;t appear to care that you told the compiler you wouldn&#39;t be providing an implementation but then you did. If the spec doesn&#39;t say that you can do this (I haven&#39;t checked) then another compiler might take the = 0 as an implementation and then it&#39;s linker might complain that you&#39;ve provided two conflicting implementations. Microsofts linker does allow multiple conflicting implementations but MINGW tools do not allow them (I was recently tripped up by this, although not in relation to pure virtual calls).</p>
<div class="post">[<em>Implementing pure virtual methods is allowed by the standard [class.abstract and basic.def.odr] and every compiler must support it. Declaring a virtual method pure does not mean &quot;I will not provide an implementation.&quot; It means &quot;I require derived classes to override this method.&quot; In practice, you rarely want one without the other. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn even thread-even depth-1" id="comment-1082723">
				<div id="div-comment-1082723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082723">
			October 13, 2013 at 12:21 pm</a>		</div>

		<p>Note that making constructors &quot;protected&quot; does not protect your class: C++ does not enforce this protection, it is only marked as such in the header files that the user can easily manipulate, or even write</p>
<p>#define protected public</p>
<p>#include &lt;whatever&gt;</p>
<div class="post">[<em>If you&#39;re looking for protection against malicious object usage, then C++ is the wrong language. Even without editing the header file, you can get around the enforcement. <code>*(int *)((char *)this + magicOffset) = 3; // hahahah I modified a private member!</code> -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082753">
				<div id="div-comment-1082753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082753">
			October 13, 2013 at 7:27 pm</a>		</div>

		<p>While being aware of this stuff is obviously important to the developer (because they may need to debug problems caused by it) from a language design perspective I think this can all be filed under &quot;reasons why allowing subclasses is a bad idea&quot;. &nbsp;</p>
<p>(Of course, this presumes that interfaces and unnamed member objects can effectively serve the same purposes as subclasses, given properly-designed code. &nbsp;I haven&#39;t yet seen a counterexample, but OTOH I haven&#39;t looked very hard.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082763">
				<div id="div-comment-1082763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082763">
			October 14, 2013 at 12:46 am</a>		</div>

		<p>@AlexCohn &quot;#define private public&quot; may well work, but violates the one-definition-rule, so you&#39;ve got undiagnosed undefined the moment you hit main()</p>
<p>Compilers are allowed to change the relative ordering of members with different access, so there&#39;s no guarantee that</p>
<p>class foo</p>
<p>{</p>
<p> private:</p>
<p> &nbsp; int x;</p>
<p> public:</p>
<p> &nbsp; int y;</p>
<p>}</p>
<p>and </p>
<p>class foo2</p>
<p>{</p>
<p> public:</p>
<p> &nbsp; int x;</p>
<p> &nbsp; int y;</p>
<p>}</p>
<p>have the same layout.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082783">
				<div id="div-comment-1082783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082783">
			October 14, 2013 at 4:41 am</a>		</div>

		<p>@Harry Johnston, but by redirecting to member objects as to replicate &quot;base class behavior inheritance&quot;, you have to worry about object identity. Sometimes that means simple redirecting methods, but other times it means wrapping everything and a trip to Mars.</p>
<p>This reminds me a lot of COM aggregation. But for it to be useful, it should be encouraged. And higher-level languages should make it easier, e.g. stating the coclass used to instantiate the object that will &quot;implement&quot; an interface by default, i.e. for which an interface&#39;s methods redirect to if not explicitly overridden.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082823">
				<div id="div-comment-1082823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082823">
			October 14, 2013 at 8:59 am</a>		</div>

		<p>@smf</p>
<p>In my copy of the C++ Standard 2003, section 10.4 Abstract classes, paragraph 2 says &quot;A pure virtual function need be defined only if explicitly called with the qualified-id syntax (5.1)&quot;. This in turns means that you can define a pure virtual function, but that it will only be used if you explicitly call it with a qualified call (of the form A::b(), instead of just plain b()).</p>
<p>You are also permitted to make a function into a pure virtual as you derive from a class, so:</p>
<p>class A</p>
<p>{</p>
<p>public:</p>
<p> &nbsp; &nbsp;void foo();</p>
<p>};</p>
<p>class B</p>
<p>{</p>
<p>public:</p>
<p> &nbsp; &nbsp;void foo() = 0;</p>
<p>}</p>
<p>is legit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1082773">
				<div id="div-comment-1082773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082773">
			October 14, 2013 at 4:05 am</a>		</div>

		<p>@Deduplicator, the answer to &quot;So what?&quot; is exactly that you want to keep the class abstract to not allow direct instantiation. Most probably, because the class was designed with that specific behavior ruled out. It forces the &quot;user&quot; (a developer here) to override the pure virtual methods, whether they are actually implemented or not, whether they call the base method even knowing it was declared pure virtual.</p>
<p>Commenter Simon gave a very good link explaining this kind of stuff. In other languages, you simply mark the class as abstract without these&#8230; &quot;tricks&quot;.</p>
<p>For the other part, I wasn&#39;t even implying that &quot;private&quot; source files (e.g. *.c/*.cpp) were either open or closed source, much less &quot;obscure places&quot;. It&#39;s usual for headers files to serve as public definition files or public interfaces. Notwithstanding proper documentation, Of Course™. If it&#39;s there but it&#39;s not documented, it might not be there the next version, or it might be different.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082913">
				<div id="div-comment-1082913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082913">
			October 14, 2013 at 3:25 pm</a>		</div>

		<p>&quot;We&#39;ll see in a future article how undefined behavior can lead to time travel. How&#39;s that for a teaser!&quot;</p>
<p>I&#39;m so excited I&#39;m going to go invoke some undefined behavior in the hopes it will make that time arrive sooner!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1082953">
				<div id="div-comment-1082953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082953">
			October 14, 2013 at 5:21 pm</a>		</div>

		<p>A member function access may be (at least it was) part of the decorated name. If you mangle the class declaration and call a library function that otherwise would not be acessible, the linker may not actually find it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1082883">
				<div id="div-comment-1082883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1082883">
			October 14, 2013 at 12:47 pm</a>		</div>

		<p>@John Doe: I&#39;m sorry, I don&#39;t understand what you mean. &nbsp;The way I see it, eliminating subclassing means precisely that you *don&#39;t* have to worry about object identify. &nbsp;If you&#39;ve got a pointer to a Foo, you know that the object is indeed a Foo, and you know exactly what code will be called when you invoke a member function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1083033">
				<div id="div-comment-1083033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1083033">
			October 15, 2013 at 7:51 am</a>		</div>

		<p>@Harry Johnston, when you say &quot;eliminating subclassing&quot;, do you mean eliminating type hierarchy or implementation inheritance? The first means you can&#39;t tell the interfaces an object implements by looking at its type (but maybe like Go, by looking at its methods). The second means interfaces can inherit from interfaces and classes may implement interfaces (ok, pure abstract classes), but (non-pure abstract) classes may not inheric other (non-pure abstract) classes.</p>
<p>I was referring to the second.</p>
<p>So, to immitate implementation inheritance, you must wrap an existing class&#39;s instance, i.e. an object of the type you&#39;re &quot;subclassing&quot;. The identity problem happens when you have referential usage of objects provided as arguments to methods. For instance, if you&#39;re wrapping an existing object which has events, either that object participates in your object&#39;s identity, or you have to wrap the events getters and setters, and you have to set the inner object&#39;s events to these wrappers. The wrappers then call the actual event handlers with our object as &quot;this&quot;, not the inner object.</p>
<p>In COM, aggregation works because the only interface pointer that dictates identity is the one for IUnknown. However, it only works for aggregatable objects, so for the rest (majority?), you have to go through hoops (if you really need to).</p>
<p>In C++, you usually don&#39;t twist at this level so much and you usually just assume that any same-class pointer comparison is enough for identity. The inner object is never the outer object. If your event handler code or tests assert for identity (I&#39;m being invoked by the object on which I registered), you have a problem unless you somehow wrap.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083303">
				<div id="div-comment-1083303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1083303">
			October 16, 2013 at 1:07 pm</a>		</div>

		<p>@John Doe:</p>
<p>Type hierarchy is what I primarily want to eliminate: that is, given a class object I want the class definition to unambiguously determine the methods and interfaces the object implements, and exactly which code gets used when you call them. &nbsp;If you have an interface, of course, all that you know is that the object is of some class which implements the interface in question. &nbsp;(Except that, if the language supports class references, it would be sensible to be able to take an interface and get a class reference for the underlying object.)</p>
<p>As for implementation inheritance, this divides into several different cases (probably including one or more I&#39;ve not thought about).</p>
<p>One case is where the inner object is not designed to be nested, and where it is natural for the outer object to contain the inner one. &nbsp;This typically means you are extending or using the inner functionality rather than modifying it. &nbsp;In this case implementation inheritance amounts to syntactic sugar so that the compiler can automatically convert Alice-&gt;x to Alice-&gt;Bob.x if the programmer so desires. &nbsp;I&#39;m happy with this.</p>
<p>For event-driven code, syntactic sugar should be all you need provided that Alice does not need to modify the events that Bob is sending or receiving. &nbsp;Alice&#39;s getFooSender function can return the FooSender interface for the member instance of Bob, or perhaps some more syntactic sugar can take care of it. &nbsp;Carol, receiving the events, only ever knows about Bob. &nbsp;(And vice versa if Bob is the receiver and Carol the sender.)</p>
<p>The second case is where the inner object is designed to be nested, and changes its behavior depending on the object it is nested within. &nbsp;I think this is best managed via some sort of plug-in approach; the outer object installs one or more plug-ins that the inner object calls out to. &nbsp;I don&#39;t see why this can&#39;t be done with interfaces just as well as with virtual functions, although you might want some more syntactic sugar to eliminate the boilerplate that would otherwise be required during construction.</p>
<p>For event-driven code, Bob might call methods such as preSendFoo and/or postSendFoo contained in the plug-in interface provided by the outer object, allowing the outer object to veto, modify, or respond to the event.</p>
<p>Yet another case is where the inner object is not designed to be modified but the outer object wants to modify it anyway; for example, if Alice wants to modify the way Bob processes events without actually standing between Bob and Carol. &nbsp;I&#39;m not sure if that&#39;s the scenario you&#39;re talking about or not. &nbsp;I&#39;m not convinced that this is sound programming practice. &nbsp;If my hypothetical idealized language were to support it at all, it would probably be via some sort of templating, i.e., telling the compiler &quot;create a class called Alice which has all of the same source code as Bob except for the bits I explicitly change&quot;. &nbsp;From Carol&#39;s point of view, and in terms of the binary, Alice and Bob would be entirely unrelated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1083413">
				<div id="div-comment-1083413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1083413">
			October 17, 2013 at 8:47 am</a>		</div>

		<p>Harry, it sounds like you want &quot;final&quot;</p>
<p><a rel="nofollow" target="_new" href="http://en.cppreference.com/w/cpp/language/final">en.cppreference.com/&#8230;/final</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1083493">
				<div id="div-comment-1083493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1083493">
			October 17, 2013 at 12:53 pm</a>		</div>

		<p>@GregM: not really; &quot;final&quot; doesn&#39;t address type hierarchy, and besides, it&#39;s optional. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1083533">
				<div id="div-comment-1083533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953#comment-1083533">
			October 17, 2013 at 8:47 pm</a>		</div>

		<p>Well, of course it&#39;s optional. &nbsp;How could it possibly be any other way? &nbsp;How does it not address type hierarchy? &nbsp;It makes it so you can&#39;t derive from the classes, exactly as you described. &nbsp;Mark every one of your classes with final, and you get exactly what you asked for, &quot;that is, given a class object I want the class definition to unambiguously determine the methods and interfaces the object implements, and exactly which code gets used when you call them.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>