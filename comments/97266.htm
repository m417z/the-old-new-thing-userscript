<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (14)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1313465">
				<div id="div-comment-1313465" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nathan_works</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313465">
			October 23, 2017 at 9:18 am</a>		</div>

		<p>I remember cs304/algorithms (from a long time ago) saying something like 80% of all CPU time is spent sorting.  A  <a href="http://www.cs.cmu.edu/~clo/www/CMU/DataStructures/Lessons/lesson8_1.htm" rel="nofollow">CMU slide</a> says 25%. I wonder how true that still is today.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-bboorman odd alt depth-2 parent" id="comment-1313475">
				<div id="div-comment-1313475" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313475">
			October 23, 2017 at 11:49 am</a>		</div>

		<p>With multiple cores, and most PCs (at least in work/industrial environments) being on 24/7, I would suggest that 80% of all CPU time is spent in the idle loop.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1313485">
				<div id="div-comment-1313485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aged .Net Guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313485">
			October 23, 2017 at 12:55 pm</a>		</div>

		<p>And 80% of the rest is spent processing or filtering spam or displaying inane or inflammatory videos.</p>
<p>What have we collectively wrought?  Von Neumann would be simultaneously awed with our progress and appalled by our uses of it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-3" id="comment-1313495">
				<div id="div-comment-1313495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313495">
			October 23, 2017 at 4:12 pm</a>		</div>

		<p>Some time ago I read a joke. A 1950s-era man in a suit in front of a teletype was talking by (wired) phone: &#8220;Will we have inside our pockets machines capable of billions of operations per second? And will we use them to do &#8220;likes&#8221; and &#8220;faves&#8221;, and share pictures of our breakfast with our friends? Really?&#8221;. There&#8217;s nothing more to add.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1313505">
				<div id="div-comment-1313505" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fabian Giesen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313505">
			October 23, 2017 at 5:06 pm</a>		</div>

		<p>These figures are from way back in the punchcards-and-tapes era of mainframe computing.</p>
<p>There&#8217;s still a lot of sorting and searching going on (e.g. inside database engines, especially if you also count things like B-tree index maintenance as &#8220;sorting&#8221; in a sense), but computer workloads are a lot more heterogenous now than when the primary commercial usage of computers was accounting or payroll :).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1313497">
				<div id="div-comment-1313497" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryce Wagner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313497">
			October 23, 2017 at 4:45 pm</a>		</div>

		<p>A binary search makes sense here, but the the choice of bounds does not.  The search space is size k, so a binary search on it should be O(log2(k)), both the best case and worst case.  We&#8217;re searching for how many of k elements should come from each array.  At one extreme we have k elements coming from array 1.  At the other extreme,  we have k elements coming from array 2.  So we can represent 0 as one extreme, and k as the other extreme.  Your binary search ends up looking something like this pseudocode:</p>
<p>binarysearch(0, k, i =&gt; arrax1[k -i].CompareTo(array2[i])).</p>
<p>And then you can shrink your bounds further so it can&#8217;t go past the end of either array.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1313506">
				<div id="div-comment-1313506" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313506">
			October 23, 2017 at 6:27 pm</a>		</div>

		<p>Excellent!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1313515">
				<div id="div-comment-1313515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.tripleboot.org' rel='external nofollow' class='url'>Henry Skoglund</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313515">
			October 23, 2017 at 7:29 pm</a>		</div>

		<p>Hi, in those cases where k is bigger than half of the total size of array 1 and array 2, it should be faster to instead binary search downwards for (total size) &#8211; k as the new k.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-3" id="comment-1313585">
				<div id="div-comment-1313585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313585">
			October 24, 2017 at 7:29 am</a>		</div>

		<p>That&#8217;s what Bryce&#8217;s &#8220;shrink your bounds further so it can’t go past the end of either array&#8221; step does. Magic.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1313536">
				<div id="div-comment-1313536" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Clarkstone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313536">
			October 24, 2017 at 3:51 am</a>		</div>

		<p>I was thinking in similar ways; I imagine it as an ascending line and a descending line plotted on the same axes and trying to find where they cross.</p>
<p>Since we want to know which specific element is the answer and hence which array to get it from, we might want to consider the bottom k elements of array1 to be in some sense &#8220;interleaved&#8221; with the reversed bottom k elements of array2, so the index not only specifies at a specific bottom slice of both arrays, but also indicates which of those two slices has the answer at the top.  I haven&#8217;t thought about exactly how this search would work.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1313637">
				<div id="div-comment-1313637" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313637">
			October 24, 2017 at 9:12 am</a>		</div>

		<p>@Simon: Yours is a simple binary search (for zero) on the array representing (the signed difference between the two signals).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1313796">
				<div id="div-comment-1313796" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Markus Falk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1313796">
			October 25, 2017 at 4:54 am</a>		</div>

		<p>As both lists are already sorted, only k steps are needed to get the result.<br />
1) Start with the first elements of A and B.<br />
2) Choose the smaller one and put it on the new list. If it was from A take the next element from A, otherwise from B.<br />
3) repeat 2) until you have k elements.</p>
<p>This is always O(k)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1314106">
				<div id="div-comment-1314106" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1314106">
			October 26, 2017 at 5:39 pm</a>		</div>

		<p>But O(log k) is better than O(k).</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1314145">
				<div id="div-comment-1314145" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Richard Wells</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171023-00/?p=97266#comment-1314145">
			October 27, 2017 at 9:33 am</a>		</div>

		<p>It&#8217;s not just better; it&#8217;s exponentially better.  I&#8217;m ashamed to say it took one of my students pointing this out for me to realize it; I had never thought of it that way.<br />
Perhaps a better challenge is to find the kth smallest item in two unsorted arrays in O(n) time.  I know it can be done with a single array, and I&#8217;m pretty sure that solution can be extended to two arrays in a manner similar to this problem, but I have to admit I  haven&#8217;t bothered working out the details.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>