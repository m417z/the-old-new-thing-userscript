<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (28)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-183713">
				<div id="div-comment-183713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeproject.com/script/articles/list_articles.asp?userid=152' rel='external nofollow' class='url'>Mike Dunn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183713">
			June 15, 2004 at 8:52 am</a>		</div>

		<p>I didn&#8217;t get into Windows programming until 1995 so I missed the whole Win16 era. The more I read about it, the more amazed I am that anything worked. ;)  (That&#8217;s not a flame, just an observation of how every program on the machine had to play nice together to make the system work.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183733">
				<div id="div-comment-183733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Montgomery</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183733">
			June 15, 2004 at 10:12 am</a>		</div>

		<p>The sort of contortions MS went through back in the day is also the reason why we have DLL Hell today. Back in the 16 bit days, memory and harddisk space were expensive enough that re-use of code via DLLs made sense. The idea was that you only stored a single copy of the DLL on the disk, and a single copy in memory at runtime. </p>
<p>Sadly, we are stuck with this outdated thinking today, even though memory and disk space are so cheap it&#8217;s completely silly to worry anymore. If every Windows app simply stored all the DLLs it needs (aside from true Windows DLLs) in a directory that either contains the executable or is a sub-direcotry of the directory with the EXE, then all the DLL Hell would go away. </p>
<p>Think about it &#8211; you wouldn&#8217;t worry if another app installed a new version of the DLL since your code would always load the version you installed with it. Also, if you wanted to move an application, simply moving the whole directory tree it lives in would move everything needed to run it at the same time. </p>
<p>Instead, programmers still act like it&#8217;s 1984 and we need to save precious disk and memory space by re-using an existing copy of a DLL. </p>
<p>Oh well&#8230;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183753">
				<div id="div-comment-183753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183753">
			June 15, 2004 at 10:20 am</a>		</div>

		<p>Peter is right on. Starting even in Windows 98 additional OS capabilities were available to encourage side-by-side installation, but it still today hasn&#8217;t caught on. </p>
<p><a href="http://msdn.microsoft.com/ms811700.aspx" rel="nofollow">http://msdn.microsoft.com/ms811700.aspx</a> </p>
<p>There are other good articles in that same part of MSDN</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183773">
				<div id="div-comment-183773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ATZ Man</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183773">
			June 15, 2004 at 10:27 am</a>		</div>

		<p>How did the hPrevInstance parameter work in real mode? Did all the DS&#8217;s live in low memory or were they pageable to high memory the way code was?</p>
<p>The first time I used Windows was Windows 3.0 in a machine with 1 MB of RAM. Later that week I got the boss to spend $$$ to add 4 MB to it and I tried enhanced mode.</p>
<p>They made fun of me for learning about Windows in 1989. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183783">
				<div id="div-comment-183783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183783">
			June 15, 2004 at 10:30 am</a>		</div>

		<p>As they say, premature optimisation is the root of all evil.  Several of the things done now are due to premature space or time optimisations done in the very first versions of Windows.</p>
<p>IMHO the first versions of Windows were an absolutely excellent fit with the constraints of the machines at the time (no hard drives, two floppy drives, low res graphics, 512Kb memory).</p>
<p>But the optimisations done were only good for a generation or two at which point they became liabilities.</p>
<p>And Mike, you don&#8217;t realise just how hard it was doing non-trivial programs back then.  You had to work with 64kb segments, worry about the stack, data and code segments pointing in different places, had to thunk all your callbacks (which ensured the correct segments where setup before calling the actual code) and you usually had all sorts of DOS level crud running as well (which later became vxds).</p>
<p>And some trivia I read was that by changing to the &quot;pascal&quot; calling convention, Windows 1.0 was 9% smaller than the C calling convention. Of course that meant you had to worry about which calling convention was used all over the place.  Details at <a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2004/01/02/47184.aspx" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2004/01/02/47184.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183803">
				<div id="div-comment-183803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183803">
			June 15, 2004 at 10:33 am</a>		</div>

		<p>I have to admit I never had a machine with expanded memory so I never learned how Windows used it&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183813">
				<div id="div-comment-183813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">njkayaker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183813">
			June 15, 2004 at 10:41 am</a>		</div>

		<p>I like DLL&#8217;s. I think they are one of the coolest things in Windows.</p>
<p>&quot;DLL Hell&quot; came about because people (including Microsoft) were not disciplined enough.</p>
<p>You can avoid DLL Hell by creating a new name for a DLL whenever the interface or behavior (that breaks things) changes.</p>
<p>And never install an older version of a DLL than already exists on the system.</p>
<p>Note that you can keep the name the same when you add new functions.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183843">
				<div id="div-comment-183843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183843">
			June 15, 2004 at 12:32 pm</a>		</div>

		<p>Anonymous Coward wrote:<br />
<br />&gt; As they say, premature optimisation is the</p>
<p>&gt; root of all evil. Several of the things done<br />
<br />&gt; now are due to premature space or time<br />
<br />&gt; optimisations done in the very first<br />
<br />&gt; versions of Windows. </p>
<p>Er&#8230; no. Optimization that is essential to get something to work on the hardware of the time is NOT premature optimization.</p>
<p>Optimization before you measure performance, however, IS premature optimization.</p>
<p>Please learn the difference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183853">
				<div id="div-comment-183853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183853">
			June 15, 2004 at 1:19 pm</a>		</div>

		<p>Raymond: Regarding DLL Hell, it&#8217;s not even close to solved.  While you have the trivial case of side by side DLL&#8217;s solved, the entire OLE situation is still just like the old days.  Let&#8217;s say I want to run IE 5.01&#8217;s web browser control because I know that works.  I can&#8217;t guarantee that as an ISV.  Let&#8217;s say, well, I want to guarantee <em>any</em> older version of an ActiveX control.  No can do.</p>
<p>Now while I don&#8217;t know if .NET fixes anything like this with components, I know that right now it&#8217;s just as bad as it ever was with COM components.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183863">
				<div id="div-comment-183863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183863">
			June 15, 2004 at 1:24 pm</a>		</div>

		<p>This is not my area of expertise so I will leave it to others.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183873">
				<div id="div-comment-183873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aarrgghh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183873">
			June 15, 2004 at 1:37 pm</a>		</div>

		<p>Peter Montgomery: It&#8217;s tough to have more than one COM object with the same CLSID on the same system, so your cure for DLL Hell runs into a problem there. </p>
<p>njkayaker: Access violations also happen because people aren&#8217;t disciplined enough &#8212; not to mention resource leaks, ferry accidents in the Pacific, traffic accidents, and people getting the HWND and HDC arguments to ReleaseDC() transposed when they don&#8217;t have STRICT defined, etc. etc. etc. </p>
<p>Sure, if people were more disciplined, these things wouldn&#8217;t happen. If Grandma had wheels, she&#8217;d be a train. That&#8217;s not a terribly profound or useful observation.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183893">
				<div id="div-comment-183893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Barry Tannenbaum</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183893">
			June 15, 2004 at 3:24 pm</a>		</div>

		<p>Aarrgghh: Sure, if people were more disciplined, these things wouldn&#8217;t happen. If Grandma had wheels, she&#8217;d be a train. That&#8217;s not a terribly profound or useful observation. </p>
<p>I worked on software at DEC for 15 years.  You can take an application written on a VAX for VAX/VMS 1.0 (released in 1977) and run it unchanged on the latest version of the operating system (assuming that it&#8217;s running on the same architecture hardware).  It&#8217;s always amazed me that Microsoft has never been able to duplicate that feat.</p>
<p>It&#8217;s all a matter of what the priority is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183903">
				<div id="div-comment-183903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183903">
			June 15, 2004 at 3:38 pm</a>		</div>

		<blockquote><p>
  &gt; It&#8217;s all a matter of what the priority is.</p>
<p>If the priorities are keeping enough cruft in to run 27 year old applications, then those are terrible priorities.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183923">
				<div id="div-comment-183923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183923">
			June 15, 2004 at 5:08 pm</a>		</div>

		<p>&quot;If the priorities are keeping enough cruft in to run 27 year old applications, then those are terrible priorities.&quot;</p>
<p>Well, I don&#8217;t think it&#8217;s 27 year-old, but it&#8217;s certainly some pretty old apps. And I think there are a very large number of enterprise customers who would disagree with your priority assessment. Raymond has covered this in a previous blog entry (sorry, I&#8217;m too lazy to dig out the link), but there are a huge number of custom apps inside enterprise customers that were originally written for DOS or early Windows versions, which they still rely on for line-of-business. We have a tough time selling them a new version of Windows if it breaks their business critical applications.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183953">
				<div id="div-comment-183953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183953">
			June 15, 2004 at 7:08 pm</a>		</div>

		<p>I should clarify what I meant in that there is nothing wrong with optimisations per se, unless they show through in your API design or other areas that affect future source or binary compatibility.  It is the latter I was referring to.</p>
<p>I don&#8217;t think Microsoft has historically done a particular good job of API design.  However they did pick backwards compatibility as an important priority, hence the win16 api ending up in win32 rather than a cleaner design for NT.</p>
<p>And as for claims about running old binaries, try Visicalc from <a target="_new" href="http://www.bricklin.com/history/vcexecutable.htm" rel="nofollow">http://www.bricklin.com/history/vcexecutable.htm</a><br />
<br />It works fine for me on my XP Pro machine.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183963">
				<div id="div-comment-183963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matthew Lock</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183963">
			June 15, 2004 at 7:43 pm</a>		</div>

		<blockquote><p>
  You can take an application written on a VAX<br />
  <br />&gt; for VAX/VMS 1.0 (released in 1977) and run<br />
  <br />&gt; it unchanged on the latest version of the<br />
  <br />&gt; operating system (assuming that it&#8217;s running<br />
  <br />&gt; on the same architecture hardware). It&#8217;s<br />
  <br />&gt; always amazed me that Microsoft has never<br />
  <br />&gt; been able to duplicate that feat. </p>
<p>Sure you can. Here is the original version of Visicalc for DOS that still runs on Windows XP 23 years later: <a target="_new" href="http://www.bricklin.com/history/vcexecutable_m.htm" rel="nofollow">http://www.bricklin.com/history/vcexecutable_m.htm</a>
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-183973">
				<div id="div-comment-183973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frederik Slijkerman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183973">
			June 16, 2004 at 1:13 am</a>		</div>

		<p>&quot;I don&#8217;t think Microsoft has historically done a particular good job of API design.&quot;</p>
<p>Well, it&#8217;s certainly much better than the old Mac API&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-183993">
				<div id="div-comment-183993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-183993">
			June 16, 2004 at 5:57 am</a>		</div>

		<p>&quot;If the priorities are keeping enough cruft in to run 27 year old applications, then those are terrible priorities. &quot;</p>
<p>That&#8217;s odd, since one of Microsoft&#8217;s defining characteristics (to me) has been an obsessive focus on certain kinds of backwards compatibility. Just witness VisiCalc, posted above, as an example.</p>
<p>FWIW, I think that this is a mark of high qualitity systems software provider, and signifies that they understand the economic realities of their customers. IBM has done a lot of work on backwards compatibliity with their mainframe line. Part of the design work for the original System/360 machines included work on emulating older hardware.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-184043">
				<div id="div-comment-184043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Barry Tannenbaum</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184043">
			June 16, 2004 at 8:29 am</a>		</div>

		<p>One of the things that helped VMS&#8217;s upward compatibility work was that the loader helped enforce it.  Each image had in it the version for each shared image (another name for a DLL) it was linked against and it&#8217;s version matching criteria.  Linker options allowed you to specify whether any version was acceptable, only an exact version match was acceptable, or any version which was greater than or equal to the version you linked against was acceptable.  The default was to accept the version you linked against or newer.</p>
<p>So if you linked an application against V1.2.3 of a shared image and tried to run it against V1.2.1, the loader would abort and display a message explaining why.</p>
<p>Given Dave Cutler&#8217;s involvement in both operarating systems, I&#8217;ve never understood why this wasn&#8217;t part of NT.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-184073">
				<div id="div-comment-184073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184073">
			June 16, 2004 at 9:02 am</a>		</div>

		<p>Barry Tannenbaum wrote:<br />
<br />&gt; So if you linked an application against V1.2.3<br />
<br />&gt; of a shared image and tried to run it against<br />
<br />&gt; V1.2.1, the loader would abort and display a<br />
<br />&gt; message explaining why.<br />
<br />&gt;<br />
<br />&gt; Given Dave Cutler&#8217;s involvement in both<br />
<br />&gt; operarating systems, I&#8217;ve never understood why<br />
<br />&gt; this wasn&#8217;t part of NT. </p>
<p>I&#8217;d assume that it&#8217;s because apps which update system DLLs were supposed to replace those DLLs with same-version-or-higher. So theoretically, you&#8217;d never get v1.2.1 on the system if you were expecting v1.2.3</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-184183">
				<div id="div-comment-184183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jekke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184183">
			June 16, 2004 at 1:01 pm</a>		</div>

		<p>Being able to add functionality to a DLL without invoking DLL hell is only really true in non-COM DLLs. A COM consumer maintains function entry-point references based on memory offsets. If a COM DLL is recompiled with new functions added, the offsets will often change and cause older consumers to stop working.</p>
<p>This is one of the reasons (according to Don Box) for ubiquitous metadata in .net. Metadata-based discovery allows for more flexible referencing by assembly consumers, which in turn allows the developer to run old consumers with new assemblies that, traditionally, would have broken binary compatability.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-184273">
				<div id="div-comment-184273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">HeavyZapper</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184273">
			June 16, 2004 at 4:53 pm</a>		</div>

		<p>We use COM dlls, which are used only by our applications. When we register them, we simply don&#8217;t register the full path, only the relative file name.  Actually, we put an environment variable in place of the path, in the InProcServer32 registry key value. Windows automatically expands at environment variable at runtime with the environment of the executable, which we&#8217;ve setup in WinMain.</p>
<p>This allows the user to install multiple versions of our application in different directories without conflict.  The only rule is that a COM object cannot ever change DLL name without changing CLSID, because it would &#8216;break&#8217; the previous registration and break older version of hte app. CoCreateInstance will create our COM objects in the DLL in the same directory as the executable.  It&#8217;s my understanding there is versionning for COM dll nowdays.. but we&#8217;ve been doing this for years.</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-184553">
				<div id="div-comment-184553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184553">
			June 17, 2004 at 7:25 am</a>		</div>

		<p>{quote}<br />
<br />&quot;I don&#8217;t think Microsoft has historically done a particular good job of API design.&quot; </p>
<p>Well, it&#8217;s certainly much better than the old Mac API&#8230;<br />
<br />{/quote}</p>
<p> And nowhere near as nice as the new Mac API :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-184753">
				<div id="div-comment-184753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.voidnish.com' rel='external nofollow' class='url'>Nish</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184753">
			June 17, 2004 at 10:52 am</a>		</div>

		<p>I always put my WinMain as follows :&#8211;</p>
<p>&lt;pre&gt;int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE, LPTSTR lpCmdLine, int nCmdShow)&lt;/pre&gt;</p>
<p>Notice how the 2nd parameter is not named :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-184763">
				<div id="div-comment-184763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.voidnish.com' rel='external nofollow' class='url'>Nish</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184763">
			June 17, 2004 at 10:53 am</a>		</div>

		<p>Holy crap! I didn&#8217;t know that weblogs.asp.net didn&#8217;t support the &lt;pre&gt; tag :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-184853">
				<div id="div-comment-184853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pinochet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184853">
			June 17, 2004 at 2:54 pm</a>		</div>

		<p>Lots of people used hPrevInstance as kind of a boolean flag, as if it were &quot;bPrevInstanceExists.&quot;  Sure, in Win32 you don&#8217;t need instance-to-instance copying via GetInstanceData any more, but there are still times when you want your app to be the only one running.  IIRC, the API docs recommend that you jump through a hoop involving a shared, memory-mapped file &#8212; if the share exists, then another instance must be running.  Not nearly as easy as the old way&#8230;.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-184863">
				<div id="div-comment-184863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pinochet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-184863">
			June 17, 2004 at 2:56 pm</a>		</div>

		<p>&#8230;whoops&#8230; make that &quot;there are still times when you want your app to be the only <em>instance</em> running.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-185043">
				<div id="div-comment-185043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smnaha</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040615-00/?p=38873#comment-185043">
			June 18, 2004 at 4:48 am</a>		</div>

		<p>One way to ensure that you want only one instance of your app to be running is to use mutexes. Create the mutex at startup and release it at the end. If the mutex exists, then bring the existing app to the foreground (assuming its a desktop app).</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>