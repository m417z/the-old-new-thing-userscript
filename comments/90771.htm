<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (22)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1222242">
				<div id="div-comment-1222242" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1222242">
			July 31, 2015 at 7:07 am</a>		</div>

		<p>I&#39;m surprised the Windows team didn&#39;t reuse the old rule in C that allows sizeof (void (*)()) &gt; sizeof (void *).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234306">
				<div id="div-comment-1234306" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234306">
			July 31, 2015 at 7:25 am</a>		</div>

		<p>How you don&#39;t totally hate Itanium?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1222232">
				<div id="div-comment-1222232" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xv8</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1222232">
			July 31, 2015 at 7:29 am</a>		</div>

		<p>@Joshua</p>
<p>Because you would break so much existing code. (POSIX defines sizeof(void(*)() &lt;= sizeof(void *), and it&#39;s been an assumption on win16 and existing win32 code since forever).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234296">
				<div id="div-comment-1234296" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234296">
			July 31, 2015 at 9:45 am</a>		</div>

		<p>The lack of a reg+imm addressing mode is a strong contender for the single worst design decision in this architecture. &nbsp;And the existence of the postincrement mode (together with the rotating register feature) tells you something about the kind of code the designers thought was worth caring about &#8212; namely, the same kind of code a DSP is good at.</p>
<p>In fact, there&#39;s a case to be made that the Itanium isn&#39;t a general purpose CPU at all, but rather a ridiculously feature-rich DSP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234286">
				<div id="div-comment-1234286" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234286">
			July 31, 2015 at 10:38 am</a>		</div>

		<p>1, 2, 3, 3b, 5?</p>
<div class="post">[<em>Actually, 1, 2, 3, 4, 3b, 5. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zlynx odd alt thread-odd thread-alt depth-1" id="comment-1234276">
				<div id="div-comment-1234276" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zan+Lynx%27' rel='external nofollow' class='url'>Zan Lynx'</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234276">
			July 31, 2015 at 10:48 am</a>		</div>

		<p>Zack, how many bits would a reg+imm instruction take up? Now compare that to doing a register load, add a value to the register, and load indirect from that register.</p>
<p>Remember that it is a bit like RISC. Instructions have to fit into slots. They cannot be just whatever length is convenient.</p>
<p>So just believe in your mind that the three instructions make a single reg+imm address mode.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234266">
				<div id="div-comment-1234266" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234266">
			July 31, 2015 at 11:01 am</a>		</div>

		<p>@zack A load of the Itanium designers were poached by AMD in 2006, so hopefully they learnt their lesson about what kind of code a CPU needs to be good at. They may not have done, AMD had already made their 64 bit chips and Intel were nowhere close to matching them but since then Intel have really excelled and AMD are essentially back where they started trying to make money on cheap hardware.</p>
<p>In the mean time Itanium has been like the Terminator, it absolutely will not stop, ever. Anyone who tries to stop supporting it gets sued. However Kittson is supposed to be out soon/now and there is no sign. Maybe Intel has figured that not enough people care anymore.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234256">
				<div id="div-comment-1234256" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234256">
			July 31, 2015 at 11:30 am</a>		</div>

		<p>&gt; Zack, how many bits would a reg+imm instruction take up? &#8230; Remember that it is a bit like RISC.</p>
<p>Somehow reg+imm addressing modes are very common even on RISC architectures, even on those with 32-bit instructions. The Itanium needs two more bits to address each register and a typical RISC ISA has ld/str instructions with two register operands, which would take up only 4 of the 9 extra bits per instruction. ARM, for example, supports predicating all (or at least almost all) instructions and yet supports reg+imm.</p>
<p>Now, you may well be right that Intel decided that they needed more than even five extra bits/instruction on other things, but that&#39;s not necessarily contradictory to believing that&#39;s a bad decision. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234246">
				<div id="div-comment-1234246" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234246">
			July 31, 2015 at 12:16 pm</a>		</div>

		<p>Normally I love all the arcane details you give us, but this is the most boring series of blog posts EVER. &nbsp;I remember looking at disassembly for this processor, and decided my days as an asm coder were over. &nbsp;Then the x64 arrived, and I got a contract to port old x86 code over &#8211; and I was back in business! &nbsp;Still, x64 asm is hard to read, too bad they couldn&#39;t think up slightly more meaningful mnemonics than &quot;r#&quot;. &nbsp;</p>
<p> &nbsp;&quot;Anyone who tries to stop supporting it gets sued.&quot;</p>
<p>Well, then, my prescience was fortuitous, because I can&#39;t get sued for stopping, because I never started!</p>
<p> &nbsp;&quot;In fact, there&#39;s a case to be made that the Itanium isn&#39;t a general purpose CPU at all, but rather a ridiculously feature-rich DSP&quot;</p>
<p>That is the best explanation I ever heard for it! &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234236">
				<div id="div-comment-1234236" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234236">
			July 31, 2015 at 1:06 pm</a>		</div>

		<p>@boogaloo: Who is included in &quot;anyone&quot; other than Oracle?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1222222">
				<div id="div-comment-1222222" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zack</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1222222">
			July 31, 2015 at 1:41 pm</a>		</div>

		<p>As Evan points out, reg+imm is ubiquitous or nearly so on classic RISC, and for damn good reason: it&#39;s good for something like 33% code size reduction on SPECint-like code. &nbsp;Yes, 33%. &nbsp;That is how often it gets used. &nbsp;Itanium doesn&#39;t need it for spilling registers to the stack, which account for a fair chunk of that 33%, but it does need it for globals, structure members, vtable slots, unrolled loops (which Itanium otherwise *loves*), aggregates on the stack, etc.</p>
<p>I don&#39;t *know*, but I suspect it was left out not because of any lack of instruction encoding space, but because they didn&#39;t want complex address-generation circuitry and/or could send memory accesses out to the cache a pipeline stage earlier without it.</p>
<p>Many of the Itanium design decisions I don&#39;t like, have in common that they make code less dense, particularly when there isn&#39;t much ILP to be had. &nbsp;Code density translates directly to better I-cache utilization and thus to better performance across the board. &nbsp;I *think* it was obvious even at the time that efficient cache utilization was becoming *the* dominant factor in overall performance, but I could be misremembering.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234226">
				<div id="div-comment-1234226" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234226">
			July 31, 2015 at 4:36 pm</a>		</div>

		<p>Itanium doesn&#39;t have any addressing mode because it is supposed to be explicit parallel with absolutely no form of reordering inside the processor, making the load pipeline longer by adding address modes would either reduce clock or increase load latency to 2 cycles, in other words, the same latency as addl/ld8 sequence, Intel avoided multi-cycle latency instructions at all costs, even integer multiplication suffered as a result.</p>
<p>About code density, at 128 bits per 3 instructions is outrageous, x86 lives with an average of 3 bytes per much more complex instruction and ARM is a mix of 16 and 32 bits instructions, lack of addressing modes is the least of code density problems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1234216">
				<div id="div-comment-1234216" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234216">
			July 31, 2015 at 5:02 pm</a>		</div>

		<p>@ZZZzzz&#8230; snarf I disagree with your first sentence.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234196">
				<div id="div-comment-1234196" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1234196">
			July 31, 2015 at 5:27 pm</a>		</div>

		<p>@Raymond, sorry for the content-free comment, but I also disagree with &quot;ZZZzzz&#8230; snarf&quot;: this has been one of your most interesting blog series so far. It&#39;s one thing to read dry descriptions about that esoteric beast of an architecture, it&#39;s another thing to read about it from somebody who worked with it before it was known to be a dead end.</p>
<p>And for those who need some &quot;brain bleach&quot; after reading about IA-64, here&#39;s the ISA documentation for a very clean modern RISC variant: <a rel="nofollow" target="_new" href="http://riscv.org/spec/riscv-spec-v2.0.pdf">riscv.org/&#8230;/riscv-spec-v2.0.pdf</a> (from the makers of the original RISC).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1197051">
				<div id="div-comment-1197051" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bill P. Godfrey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1197051">
			August 3, 2015 at 2:30 am</a>		</div>

		<p>I&#39;m enjoying this and I&#39;d be very interested in a similar series on the ARM processor.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1197041">
				<div id="div-comment-1197041" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Christian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1197041">
			August 3, 2015 at 2:41 am</a>		</div>

		<p>You must have waited for this question: What happens if a module wants to have 524289 global objects?</p>
<div class="post">[<em>That issue never came up. I assume you got a linker error. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1197031">
				<div id="div-comment-1197031" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bulletmagnet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1197031">
			August 3, 2015 at 3:03 am</a>		</div>

		<p>The &quot;Programming for 64-bit Windows&quot; link doesn&#39;t work for me: it redirects to &quot;MSDN Magazine Issues and Downloads&quot; (<a rel="nofollow" target="_new" href="https://msdn.microsoft.com/en-us/magazine/ee310108.aspx">msdn.microsoft.com/&#8230;/ee310108.aspx</a>) &nbsp;:(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1197021">
				<div id="div-comment-1197021" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1197021">
			August 3, 2015 at 6:18 am</a>		</div>

		<p>Anybody knows when approximately the article &quot;Programming for 64-bit Windows&quot; appeared, it&#39;s hard finding it otherwise? Unfortunately old issues of MSDN mag are CHM files between 2003 and 2008 and online only from 2009 on, so even search doesn&#39;t work. Archive.org seems not to have it too under the given ee310108.aspx link.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1197011">
				<div id="div-comment-1197011" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1197011">
			August 3, 2015 at 6:23 am</a>		</div>

		<p>Bulletmagnet: <a rel="nofollow" target="_new" href="https://web.archive.org/web/20120418084630/http://msdn.microsoft.com/en-us/magazine/bb985017.aspx">web.archive.org/&#8230;/bb985017.aspx</a></p>
<p>(That was hard.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1197001">
				<div id="div-comment-1197001" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1197001">
			August 3, 2015 at 6:25 am</a>		</div>

		<p>acq: ee310108 is the one that MSDN redirects to now that the pre-2003 issues have been removed. You need to use the one Raymond linked (or my previous link).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196991">
				<div id="div-comment-1196991" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1196991">
			August 3, 2015 at 6:25 am</a>		</div>

		<p>Oh, and I&#39;ve also enjoyed reading these articles, I don&#39;t care that I&#39;ve never worked with the computer with such a CPU and that they are probably never going to be used more.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196921">
				<div id="div-comment-1196921" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrei Warkentin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150731-00/?p=90771#comment-1196921">
			August 3, 2015 at 11:40 am</a>		</div>

		<p>While perhaps the NT LE calling convention was different, at least for the PowerPC64 ABI the TOC is per-module, so each function in a module is entered with the same TOC value. It would be strange to have a per-function TOC, given that the TOC describes a module&#39;s globals, and maintaining multiple TOC tables would be a strange burden. Now, every function has their own calculation for computing the TOC when called as global function, because the TOC = function address + offset.</p>
<p>Btw, it would be great to see a line of articles about NT on the PPC PreP machines&#8230;</p>
<p>A</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>