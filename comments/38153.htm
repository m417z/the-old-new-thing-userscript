<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (58)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-203563">
				<div id="div-comment-203563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Payne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203563">
			August 17, 2004 at 7:24 am</a>		</div>

		<p>Why is the split between user mode and the kernel at 8 TB rather than half way through the 64 bit address space?  I realize that Intel and AMD processors have 44 and 40 address lines respectively so the architecture currently wouldn&#8217;t allow more than 1 TB or 16 TB in total but I don&#8217;t understand why the software shouldn&#8217;t be ready.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203573">
				<div id="div-comment-203573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://typicus.org' rel='external nofollow' class='url'>St&#233;phane Lajoie</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203573">
			August 17, 2004 at 7:29 am</a>		</div>

		<p>Besides, this whole series of articles have been telling us that physical limits like the number of address lines have nothing to do with the size of the virtual address space.</p>
<p>I&#8217;d also like to know why the limit is so low. I&#8217;m sure there&#8217;s already applications where terabytes of memory are required. What we call a supercomputing application today is somebody&#8217;s screen saver tomorrow&#8230;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203583">
				<div id="div-comment-203583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203583">
			August 17, 2004 at 7:36 am</a>		</div>

		<p>I&#8217;ll cover the technical reasons later. Hint: ABA.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203593">
				<div id="div-comment-203593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ToddM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203593">
			August 17, 2004 at 7:39 am</a>		</div>

		<p>I&#8217;d like to hear about any gotchas in the 64-bit model, such as the off-limits 64KB block just below 2GB in the 32-bit model.  And what about system DLLs?  Have they been rebased in 64-bit Windows to insanely high addresses?</p>
<p>In other words, w.r.t. virtual address space, what&#8217;s the largest contiguous block one can practically allocate under 64-bit Windows?  (Even with some gotchas, I bet it&#8217;s still pretty big&#8230;&gt;7TB, perhaps?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203653">
				<div id="div-comment-203653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203653">
			August 17, 2004 at 9:28 am</a>		</div>

		<p>&quot;I&#8217;ll cover the technical reasons later&quot;</p>
<p>I, for one, am looking forward to that article.  ABA is one tough word to google for.  Maybe the ABA race-condition?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203663">
				<div id="div-comment-203663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203663">
			August 17, 2004 at 9:29 am</a>		</div>

		<p>&quot;and, in the SIS world &quot;</p>
<p>Er, SSI, rather.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203683">
				<div id="div-comment-203683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203683">
			August 17, 2004 at 9:34 am</a>		</div>

		<p>&quot;I, for one, am looking forward to that article. ABA is one tough word to google for. Maybe the ABA race-condition? &quot;<br />
<br />That&#8217;s the only thing I can think of, though I can&#8217;t immediately see how it applies here.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203693">
				<div id="div-comment-203693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/carmencr' rel='external nofollow' class='url'>Carmen Crincoli</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203693">
			August 17, 2004 at 9:50 am</a>		</div>

		<p>One thing to keep in mind is that on the 64bit platform, those limits are not hard-set.  In future OS revisions, we can change the layout of VA space as needed, and in fact, they probably will&#8230;but only when 8TB of physical memory becomes a reality.</p>
<p>Until then, it doesn&#8217;t MATTER if it&#8217;s part of your data set, because all you&#8217;re going to be doing is pulling it off one disk to put it onto another (the paging file)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203713">
				<div id="div-comment-203713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203713">
			August 17, 2004 at 10:16 am</a>		</div>

		<p>Setting /LARGEADDRESSAWARE:NO on 64-bit programs would be done for essentially the same reason that you don&#8217;t set /LARGEADDRESSAWARE:YES on 32-bit progrmas to take advantage of /3GB.</p>
<p>Bascially, if you&#8217;ve &#8216;ported&#8217; your 32-bit code to compile with a 64-bit compiler, but you have decided not to fix the bugs that assume that pointers are 32-bit entities that can be passed around in an int.</p>
<p>There are a lot of programs which don&#8217;t really need the huge address space. I wouldn&#8217;t be surprised if a 64-bit version of some MS Office applications used this option, if and when Office is made available in a 64-bit edition.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203733">
				<div id="div-comment-203733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203733">
			August 17, 2004 at 10:41 am</a>		</div>

		<p>&quot;(Notice however that you can set /LARGEADDRESSAWARE:NO on your 64-bit program to tell the operating system to force the program to live below the 2GB boundary. It&#8217;s unclear why you would ever want to do this, though, since you&#8217;re missing out on the 64-bit address space while still paying for it in pointer size. It&#8217;s like paying extra for cable television and then not watching.)&quot;<br />
<br />I imagine it means you don&#8217;t have to run under WOW64 (so no thunking) but can still safely truncate pointers (so no tedious porting), which for an application such as WinWord would presumably be quite a useful thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203743">
				<div id="div-comment-203743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/carmencr' rel='external nofollow' class='url'>Carmen Crincoli</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203743">
			August 17, 2004 at 10:42 am</a>		</div>

		<p>DrPizza: Being a regular reader of Raymond&#8217;s blog, you should know the theme of tradeoffs pretty well by now.  Since it looks like Raymond will cover it, I&#8217;ll let him do it.  Don&#8217;t assume decisions like that are made trivially though.  There was a lot of deliberation behind it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203753">
				<div id="div-comment-203753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203753">
			August 17, 2004 at 10:42 am</a>		</div>

		<p>Could you comment on the choice of having 32 bits &quot;int&quot; even in 64 bits? Most codes I know use &quot;int&quot; to access components of an array. So basically this limits a usable array size of 2^31. Isn&#8217;t that going to be a problem some day when we will be able to allocate arrays that can&#8217;t be accessed entirely? </p>
<p>Why hasn&#8217;t the &quot;int&quot; been promoted to 64 bits like pointers? Backward compatibility issues? Is it a good decision in the long term?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203763">
				<div id="div-comment-203763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203763">
			August 17, 2004 at 10:49 am</a>		</div>

		<p>&quot;DrPizza: Being a regular reader of Raymond&#8217;s blog, you should know the theme of tradeoffs pretty well by now.&quot;<br />
<br />Indeed.  Given the choice between doing the right thing and not doing the right thing, the decision will almost invariably be &quot;not doing the right thing&quot;.</p>
<p>&quot;Since it looks like Raymond will cover it, I&#8217;ll let him do it. Don&#8217;t assume decisions like that are made trivially though. There was a lot of deliberation behind it.&quot;<br />
<br />And lots of deliberation in applications that have got to work around it too.  Glorious.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203773">
				<div id="div-comment-203773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203773">
			August 17, 2004 at 11:01 am</a>		</div>

		<p>The choice is often between &quot;doing right thing X and doing right thing Y &#8211; you can&#8217;t do both&quot;. Those are the hard choices.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203853">
				<div id="div-comment-203853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203853">
			August 17, 2004 at 11:50 am</a>		</div>

		<p>&quot;So, my guess is that the kernel folks realized that to map exabytes of data it&#8217;ll take terabytes of virtual address space, and optimized in that direction.&quot;<br />
<br />They can still have their terabytes of virtual address space, though.  That&#8217;s the thing about a 64-bit address space; it&#8217;s bloody big, and you can dedicate thousands of terabytes to both user- and kernel-mode.</p>
<p>Except that Win64 doesn&#8217;t do this.  User-mode is left without a simple and effective way of dealing with the vast datasets that exist /today/.  Let alone future, even vaster, datasets.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203873">
				<div id="div-comment-203873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203873">
			August 17, 2004 at 12:01 pm</a>		</div>

		<p>&quot;Why hasn&#8217;t the &quot;int&quot; been promoted to 64 bits like pointers? Backward compatibility issues? Is it a good decision in the long term? &quot;<br />
<br />int probably should be 32-bit.<br />
<br />long probably shouldn&#8217;t.</p>
<p>Most unixes are LP64 (so it&#8217;d ease porting between unix and Win32&#8211;which for the kind of scientific applications that benefit from 64-bit even today would be a bonus), and LP64 is simpler to deal with in C89 and C++98, as it doesn&#8217;t require the use of non-standard integral types.  You leave char as 8, short as 16, and int as 32, and make long 64. Then all is well in the world.</p>
<p>If people insist on truncating their pointers to ints (a) they&#8217;re idiots (b) the compiler can issue pretty good diagnostics (c) there&#8217;s always the image option to force all pointers to have the top 32 bits zeroed out.  This makes such broken programs generally safe, and unlike the decision to go &quot;LLP64&quot; can be doing without hurting properly-written programs.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203883">
				<div id="div-comment-203883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203883">
			August 17, 2004 at 12:13 pm</a>		</div>

		<p>carl: the only guarantee you have is that ints are at least 16 bits. If you want other guarantees, either create your own typedefs or use stdint.h/inttypes.h. I mostly use size_t for accessing an array but if you want to use a signed type, the correct way to do it is ptrdiff_t because that&#8217;s what the compiler implicitly casts it to when you add/subtract arithmetic types from pointers (and do array access).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203893">
				<div id="div-comment-203893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203893">
			August 17, 2004 at 2:51 pm</a>		</div>

		<p>Mapping a huge file in one go wastes page table entries, which obviously take up physical memory if they&#8217;re swapped in, and swap space if swapped out. Map enough of the file to work with at the moment, then switch the mappings to work with another part of the file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203613">
				<div id="div-comment-203613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203613">
			August 17, 2004 at 8:37 am</a>		</div>

		<p>&quot;In 64-bit Windows, the 2GB limit is gone; the user-mode virtual address space is now a stunning 8 terabytes. &quot;<br />
<br />Which is a remarkably short-sighted decision.</p>
<p>Even today, people have to deal with data sets of *around* that kind of size.  Big databases, for example (consider the largest TPC-H data set&#8211;10 TB).</p>
<p>It would afford a certain convenience if these large datasets could be dealt with without having to implement some kind of application-level paging.</p>
<p>After all, the entire reason we don&#8217;t want to use AWE is because it requires us to implement application-level paging (we have to move our window about to pick and choose the chunk of our big block of memory that we can actually address).</p>
<p>Current 64-bit processors do support a 63- or 64-bit virtual address space (they don&#8217;t have enough address lines, of course, because the physical RAM to realize such a space would be vast).  This wasn&#8217;t always the case (you&#8217;d instead have 64-bit pointers with a 4x- or 5x-bit virtual address space), so why not make it bigger?</p>
<p>A 50:50 (or perhaps 75:25 kernel:user) split would put off these concerns more or less indefinitely; we&#8217;d be already at the effective limit of 64-bit addressing, and the only way forward would be 128-bit.  The current 8TB split, on the other hand, means that applications with large data sets are already pushing that limit.</p>
<p>It&#8217;s particularly surprising given that MS has stated an interest in moving more into the HPC business, where vast data sets are relatively common, and, in the SIS world (which Windows can&#8217;t operate in today, but who knows what the future holds) large address spaces also.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203673">
				<div id="div-comment-203673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203673">
			August 17, 2004 at 9:33 am</a>		</div>

		<p>I&#8217;m pretty sure you can access more than 4GB with selectors, it just gets *really* ugly: mark entire selectors as &quot;not present&quot; and do huge amounts of paging when someone starts using a different one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203913">
				<div id="div-comment-203913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203913">
			August 17, 2004 at 4:33 pm</a>		</div>

		<p>&quot;One of our boot.ini files has a /7GB switch.&quot;</p>
<p>Well i&#8217;d say that he&#8217;s lying. He is mistaken if he thinks he sees a /7GB switch in his boot.ini file. </p>
<p>Since there is an 8TB user mode address space, Microsoft didn&#8217;t invent a /7GB switch.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203703">
				<div id="div-comment-203703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203703">
			August 17, 2004 at 10:01 am</a>		</div>

		<p>&quot;they probably will&#8230;but only when 8TB of physical memory becomes a reality. &quot;<br />
<br />Why on earth should virtual address space be constrained in this way by physical address space?  One can experience benefits from expanding the address space long before one has the physical memory to realize that address space.  The whole Exchange /3GB w/1 GiB RAM issue should have made that one amply clear&#8230;.</p>
<p>&quot;Until then, it doesn&#8217;t MATTER if it&#8217;s part of your data set, because all you&#8217;re going to be doing is pulling it off one disk to put it onto another (the paging file) &quot;<br />
<br />Yes, it does matter.  It matters a lot.  Some smart OS guy has already written a complex system for pulling things in from disk and flushing things back out to disk.  If I can just map a huge file, I can make use of this guy&#8217;s hard work, which leaves me free to deal with the problem at hand (which may be lots of things, but writing a paging mechanism ain&#8217;t it).</p>
<p>If I don&#8217;t have enough address space to map that huge file, I have to *waste my time* implementing a mechanism that *already exists* within the OS.</p>
<p>So, yes, it does matter.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203923">
				<div id="div-comment-203923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.carlrobitaille.org' rel='external nofollow' class='url'>Carl</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203923">
			August 17, 2004 at 5:43 pm</a>		</div>

		<p>asdf: On the project I&#8217;m currently working on, we are using &quot;long int&quot; hidden behind a typedef, so we are covered. </p>
<p>But my argument was more a general about the majority of codes/libraries using int and what it implies for the future. I guess that only the applications needing huge arrays (e.g. Finite Elements Method programs for storing large sparse matrices) will have to be modified. I don&#8217;t see my buddy list going over 2^32 entries any time soon ;-)</p>
<p>The funny thing is that not many libraries I know manipulating those huge arrays (e.g. PETSc) didn&#8217;t see the need to use a typedef to access more that 2^31 entries. I guess the community didn&#8217;t expect the &quot;int&quot; staying at 32 bits. At least, that&#8217;s my take on it.</p>
<p>DrPizza: Of course, I wasn&#8217;t advocating to have 64 bits &quot;int&quot; to store pointers ;-)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203933">
				<div id="div-comment-203933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203933">
			August 17, 2004 at 5:55 pm</a>		</div>

		<p>Ian, I know the email thread Raymond&#8217;s talking about.  The customer HAD a /7GB switch in their boot.ini file.</p>
<p>The question was how do you respond to that customer :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203823">
				<div id="div-comment-203823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.positivenetworks.net' rel='external nofollow' class='url'>Steve Dispensa</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203823">
			August 17, 2004 at 11:29 am</a>		</div>

		<p>Remember that one thing we&#8217;re optimizing for is the manipulation of huge amounts of storage space.  There are arrays out there with many many terabytes of information on-line.  In order for the virtual block cache that NT uses to be effective, it has to have enough virtual memory handy to adequately address the files it&#8217;s trying to cache.  This is not a physical memory thing, but rather has to do with the way the virtual block cache works: virtual memory is mapped to views of files, and as the physical memory available fluctuates, the memory manager pages data in and out as necessary.  The cache competes with the rest of the processes in the system for access to page frames, and the natural working set balancing algorithms in mm make it all work perfectly.</p>
<p>Virtual memory is already very tight when you think about using 512MB of *virtual* cache to map to large disks today.  The memory manager has to start kicking pages out to disk even though it has physical memory to spare, because it is out of virtual memory to map the views.  </p>
<p>So, my guess is that the kernel folks realized that to map exabytes of data it&#8217;ll take terabytes of virtual address space, and optimized in that direction.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203943">
				<div id="div-comment-203943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203943">
			August 17, 2004 at 6:47 pm</a>		</div>

		<p>Regarding limitations on virtual address spaces:  Remember that Windows 9x had trouble with page tables when physical memory exceeded sizes like 64MB or 512MB.  One potential way to avoid trouble could have included limiting virtual address spaces to 512MB (not a complete solution, but better than no solution).  This doesn&#8217;t mean that a fixed 8TB limit is a good choice though, it just means that an option should be available to set a limit.</p>
<p>Regarding the size of int:  In the spirit of old C, int would be 64 bits on 64-bit machines.  In the spirit of new C, int is the same size as everyone else&#8217;s int.  You might be allowed to notice that some of those everyone elses have different sizes of int from the rest of the everyone elses, but only for a moment and then you have to ignore them.</p>
<p>Regarding the customer who was told by a consultant to have a /7GB switch:  When talking to the customer, inform them that consultants are not exceptions to Sturgeon&#8217;s law.  If that doesn&#8217;t settle it, then there&#8217;s only one thing to do.  Despite my personality, I do remember that the customer is the customer.  The old saw &quot;The customer is always right&quot; is somewhat exaggerated, but if the customer knows what they want then the customer is right about what they want.  Either offer to sell them a working /7GB switch (if they want to pay the development expenses) or let them just keep it as is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203953">
				<div id="div-comment-203953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203953">
			August 17, 2004 at 6:59 pm</a>		</div>

		<p>&quot;how do you respond to that customer&quot;</p>
<p>MS Knowledge Base Article &#8211; 1048576</p>
<p>Boot loader fails to validate boot.ini switches</p>
<p>CAUSE</p>
<p>The use of college sophomores as consultants.</p>
<p>RESOLUTION</p>
<p>A Hotfix is now available which will issue bug check 0x1337 when invalid switches are applied.  We recommend that you wait for the next service pack that contains this hotfix.</p>
<p>BACKGROUND</p>
<p>The /7GB switch was depricated as of Windows 3.11.  We recomend using the /InfiniteGB switch.  Or for X-treme performance requirments use the /OnlyForBillAndNSA switch.</p>
<p>Note: Those two switches will be disabled by this hotfix due to the fact that our agreement with the US government reserves those hidden resources for use by Carnavore.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203963">
				<div id="div-comment-203963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Day</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203963">
			August 17, 2004 at 7:12 pm</a>		</div>

		<p>How nice does Microsoft want to be to consultants who may be product champions?:) I suppose we all end up with completely wrong-headed ideas sometimes, though that consultant was pretty far gone.</p>
<p>If viable I might try contacting the consultant, so the consultant can correct their own error once they understand it. That may still result in a former consultant for that company but it may at least stop the future misinformation spread from that source.</p>
<p>THe simplest solution is to tell the customer and make the consultant a former consultant with a chip on their shoulder.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203973">
				<div id="div-comment-203973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203973">
			August 17, 2004 at 7:18 pm</a>		</div>

		<p>4 gigs of his physical memory will never be used (I&#8217;m not sure how the kernel does things but I think there is no way for the page lookup mechanism to map to physical address larger than 4gigs [I&#8217;d love to see an article about PAE here]). By allocating more than 2 gigs I assume he means a being able to allocate at least a 2 gig continuous block of virtual memory which you cannot do because there are holes in your address space (system dlls, those 64kb blocks, and the kernel address space).</p>
<p>Also, isn&#8217;t it less than 7TB? 0x6FC00000000 = 7152 gigs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203983">
				<div id="div-comment-203983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">timchen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203983">
			August 17, 2004 at 8:07 pm</a>		</div>

		<p>On AMD64 it&#8217;s 0x80000000000. Why is it 0x6FC00000000 on IA64?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203993">
				<div id="div-comment-203993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-203993">
			August 18, 2004 at 12:58 am</a>		</div>

		<p>&quot;Mapping a huge file in one go wastes page table entries, which obviously take up physical memory if they&#8217;re swapped in, and swap space if swapped out. Map enough of the file to work with at the moment, then switch the mappings to work with another part of the file. &quot;<br />
<br />Wasn&#8217;t the whole file mapping thing reworked in WinXP so that fewer resources were needed?</p>
<p>In any case, the size of the page tables is going to be much less than the amount of RAM in a system dealing with such files, so it&#8217;s no big deal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204013">
				<div id="div-comment-204013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mahdi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204013">
			August 18, 2004 at 7:17 am</a>		</div>

		<p>@carl: int is compiler dependent, but via one of the C(++) standards defined to be 32 bits on 32bit machines and 16 bits on 16 bit machines. On 64 bit machines, only the long value is pumped up to 64 bits, on 128 bit machines long long would be 128 bits, etc. But this is <em>not</em> a general standard and e.g. holds not true for certain embedded platforms.<br />
<br />In the Windows world 32 bits is a &quot;longword&quot;, and a &quot;word&quot; is 16 bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204053">
				<div id="div-comment-204053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204053">
			August 18, 2004 at 7:51 am</a>		</div>

		<p>OK, you need one PTE per 4KB page (per 2MB if you use large mappings with the MEM_LARGE_PAGE switch on Windows Server 2003) on x64. x64 uses PAE-style 64-bit PTEs in long (64-bit) mode &#8211; it&#8217;s a four-level hierarchy. Mapping an 8TB file using 4KB pages would need 2Gpages and hence 2G PTEs. Each PTE is 8 bytes so you can get 512 of them onto a page and we need 4Mpages for the lowest level (level 3) page tables, or 16GB of address space. Add 32MB for level 2 and 64KB for level 1.</p>
<p>x86 not running in PAE mode only uses three levels and has 1024 PTEs per page (32-bit PTE), so the relative cost is lower.</p>
<p>Having said that, mapped files don&#8217;t use valid PTEs directly, PTEs for shared sections are prototype PTEs which point to real PTEs, so there&#8217;s at least one extra level of mapping there. I&#8217;ve never quite squared away what Windows does when you actually reference a prototype PTE &#8211; I think it explicitly loads the mapping into the TLB, leaving the prototype PTE in the actual page table.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204063">
				<div id="div-comment-204063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204063">
			August 18, 2004 at 7:53 am</a>		</div>

		<p>DrPizza wrote: &quot;Current 64-bit processors do support a 63- or 64-bit virtual address space&#8230;&quot;</p>
<p>Maybe some of them do, but AMD64 doesn&#8217;t; currently it&#8217;s limited to 48-bit virtual addresses using 4 levels of page tables (as opposed to 2 on x86). Supporting 64-bit virtual addresses would presumably require 5 or 6 levels, which is bordering on the ridiculous. Every extra level adds complexity to the MMU and the OS&#8217;s memory manager.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204073">
				<div id="div-comment-204073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204073">
			August 18, 2004 at 8:00 am</a>		</div>

		<p>mahdi wrote: &quot;int is compiler dependent, but via one of the C(++) standards defined to be 32 bits on 32bit machines and 16 bits on 16 bit machines. &#8230;  But this is <em>not</em> a general standard and e.g. holds not true for certain embedded platforms.&quot;</p>
<p>Yes, exactly, it&#8217;s not a standard at all. All the standard says is int has at least 16 significant bits and long has at least 32 (and at least as many as int).</p>
<p>mahdi wrote: &quot;In the Windows world 32 bits is a &quot;longword&quot;, and a &quot;word&quot; is 16 bits.&quot;</p>
<p>I believe those are DWORD (double word) and WORD and they are a holdover from the original implementation of Windows in 16-bit assembly where these terms were actually meaningful. They ought to have been deprecated in the transition to Win32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204133">
				<div id="div-comment-204133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">timchen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204133">
			August 18, 2004 at 8:51 am</a>		</div>

		<p>&quot;Wasn&#8217;t the whole file mapping thing reworked in WinXP so that fewer resources were needed?&quot;</p>
<p>I remember this was done at win2000 sp2. Prior to that doing buffered i/o on a file (mapped by cc) would build up the entire section at the very beginning, and every 4k requires 4 bytes in paged pool. Therefore the biggest file you can normally use on such system is around 180GB on NT4 (paged pool maximum at 192MB). Copying big file also fails because CopyFile uses buffered i/o.</p>
<p>This was changed in sp2 that the allocation will occur only when actually being used.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204163">
				<div id="div-comment-204163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204163">
			August 18, 2004 at 10:29 am</a>		</div>

		<p>&quot;Maybe some of them do, but AMD64 doesn&#8217;t; currently it&#8217;s limited to 48-bit virtual addresses using 4 levels of page tables (as opposed to 2 on x86). Supporting 64-bit virtual addresses would presumably require 5 or 6 levels, which is bordering on the ridiculous. Every extra level adds complexity to the MMU and the OS&#8217;s memory manager.&quot;<br />
<br />I don&#8217;t pay much attention to that abomination.  x86 is crufty enough.  We don&#8217;t need yet more hacks applied to it.</p>
<p>Itanium2 is 64-bit virtual and 50-bit physical (and can do weird segmentation things on top of that).  I think new POWER family processors are 64-bit virtual and 42-bit physical (and can do weird bank-switching segmentation things to take that up to about 80-bit).  Alpha went up to, what, 53-bit?  Fujitsu&#8217;s SPARC64 V line are 64-bit virtual, 43-bit physical.</p>
<p>These families have fancier page tables (hashed PTEs in the case of Itanium and POWER for example) than x86 does, though, particularly Itanium, so perhaps x86&#8217;s crapness is prohibitive in its case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204203">
				<div id="div-comment-204203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204203">
			August 18, 2004 at 11:24 am</a>		</div>

		<p>0000000000000000 User-Mode User Space<br />
<br />000006FC00000000 Kernel-Mode User Space<br />
<br />1FFFFF0000000000 User Page Tables<br />
<br />2000000000000000 Session Space<br />
<br />3FFFFF0000000000 Session Space Page Tables<br />
<br />E000000000000000-<br />
<br />E000060000000000 System Space<br />
<br />FFFFFF0000000000 Session Space Page Tables</p>
<p>That&#8217;s where the 0x6FC00000000 comes from (lets hope it formats correctly when I submit this).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204453">
				<div id="div-comment-204453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/gpage' rel='external nofollow' class='url'>Greg Page</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204453">
			August 19, 2004 at 12:18 pm</a>		</div>

		<p>you may have seen this raymond&#8230;.the 7 GB switch is either a typo or the work of an insane person. I suspect someone was munging the 3GB switch with PAE and had once heard a passing reference to the userva switch, popped them all in a blender and out popped the 7 GB switch. </p>
<p>That, or it was a typo.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204583">
				<div id="div-comment-204583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">darwou</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204583">
			August 20, 2004 at 12:42 am</a>		</div>

		<p>On 32-bit x86, you have 8 byte atomic compare and swap (CAS) instructions, or &quot;cmpxchg&quot;. </p>
<p>The ABA problem occurs when you have an lock-free algorithm that tests a value to make sure it is A and then uses cmpxchg to change the value to something else&#8230; but in the interval between the test and the cmpxchg, someone else changes A to B and then back to A again, hence &quot;ABA&quot;.</p>
<p>Interlocked SList is the Windows implementation of a lock-free singly linked-list. These lists are really fast because they do not have to take out a lock when things are added or removed from them. Hence they&#8217;re used in a lot of places in the OS.</p>
<p>Interlocked SList solves the ABA problem by (basically) keeping a counter and bumping it up whenever an operation happens. This ensures that the second A in ABA is different from the first.</p>
<p>On 32-bit x86, since you can cmpxchg 8-bytes at a time, everything is easy. You keep the pointer in the first 32-bits, and the other information in the other 32-bits, and life is grand.</p>
<p>But on both AMD64 and Itanium, you run into a little problem: There is nothing bigger than a 8-byte atomic cmpxchg. No 16-byte atomic cmpxchg instruction exist in either Itanium or AMD64.</p>
<p>Since pointers on those platforms are also 8-bytes, you have no room to store your extra information. </p>
<p>The solution is to sacrifice some of the 8-bytes of address. </p>
<p>Hence the limitation of the address space on AMD64 to 40 bits. The rest of the bits are used to store other information.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204593">
				<div id="div-comment-204593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204593">
			August 20, 2004 at 5:46 am</a>		</div>

		<p>&quot;The ABA problem occurs when you have an lock-free algorithm that tests a value to make sure it is A and then uses cmpxchg to change the value to something else&#8230; but in the interval between the test and the cmpxchg, someone else changes A to B and then back to A again, hence &quot;ABA&quot;. &quot;<br />
<br />But most of the time you don&#8217;t actually need lock-free; &quot;nearly&quot; lock-free is &quot;good enough&quot;.  By saying that your locked pointers must be aligned on an 8-byte boundary (which is not unreasonable on a 64-bit platform; Itanium for example requires it anyway for its CAS instructions) you can use the bottom 3 bits as your count and a mechanism such as the one described here: <a target="_new" href="http://www.hpl.hp.com/techreports/2004/HPL-2004-105.pdf" rel="nofollow">http://www.hpl.hp.com/techreports/2004/HPL-2004-105.pdf</a>  .  That algorithm backs off to spin locks if there&#8217;s more than N concurrent accesses, but since N is normally low that&#8217;s OK.  The particularly troublesome situation (signals/interrupts) needs only to cope with 2.  For greater contention spinlocks can be as good (or even better) than CAS.</p>
<p>I believe that Intel&#8217;s x86-64 has a 16-byte CAS anyway, and Itanium&#8217;s cmp8xchg16 is probably good enough too.</p>
<p>In any case, as long as one has pointer-width CAS one can fabricate arbitrarily large CAS.</p>
<p>As such, removing such a huge chunk of address space seems really rather gratuitous and unnecessary.  It&#8217;s a solution&#8211;of sorts&#8211;but it&#8217;s hardly a <em>good</em> solution.  The ABA rationale seems rather weak.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204613">
				<div id="div-comment-204613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204613">
			August 20, 2004 at 7:36 am</a>		</div>

		<p>Okay, so explain how the existing SList functions can be implemented using the technique in the paper. Remember, you can&#8217;t change the existing interface.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204703">
				<div id="div-comment-204703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204703">
			August 20, 2004 at 9:10 am</a>		</div>

		<p>Am I allowed to force alignment of slist pointers to 4 bytes on 32-bit platforms and 8 bytes on 64-bit platforms?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204713">
				<div id="div-comment-204713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204713">
			August 20, 2004 at 9:13 am</a>		</div>

		<p>And what do I win?</p>
<p>Am I allowed to use techniques described elsewhere, or must I use the ones from that article?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204733">
				<div id="div-comment-204733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204733">
			August 20, 2004 at 10:07 am</a>		</div>

		<p>You can use whatever techniques you want. (And you are allowed to impose aligment restrictions.) Don&#8217;t forget to implement QueryDepthSList.  My point is that the technique in that paper isn&#8217;t the slam dunk you portray it as.</p>
<p>Oh, and &quot;nearly lock-free&quot; isn&#8217;t good enough.  Suppose you can handle up to N concurrent operations and the (N+1)th has to block. Say you have a single-processor machine.  The first N operations get under way and a hardware interrupt comes in and needs to perform a (N+1)th operation. if you make the hardware interrupt wait for one of the other N to complete, your machine will hang. The other N are waiting for the hardware interrupt to complete, but the hardware interrupt is waiting for the other N.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204763">
				<div id="div-comment-204763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204763">
			August 20, 2004 at 10:30 am</a>		</div>

		<p>What do the routines use the spinlock for if not to lock?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204783">
				<div id="div-comment-204783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204783">
			August 20, 2004 at 10:35 am</a>		</div>

		<p>What spinlock? The SList functions are lock-free. That&#8217;s the whole point.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204793">
				<div id="div-comment-204793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204793">
			August 20, 2004 at 10:38 am</a>		</div>

		<p>The spinlock in the APIs.  e.g. ExInterlockedPopEntrySList, ExInterlockedPushEntrySList</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204803">
				<div id="div-comment-204803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204803">
			August 20, 2004 at 10:39 am</a>		</div>

		<p>Of course, I&#8217;m assuming the new kernel32 exports use those behind the scenes.  I don&#8217;t have XP or 2K3 immediately available to hand, so perhaps they don&#8217;t.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204813">
				<div id="div-comment-204813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204813">
			August 20, 2004 at 10:42 am</a>		</div>

		<p>Sorry, I was talking about the non-Ex versions. (Those Ex functions aren&#8217;t Win32.) The non-Ex functions don&#8217;t have a spinlock parameter.</p>
<p>And no, the kernel32 exports don&#8217;t use the spinlocks.   (They can&#8217;t anyway since spinlocks are kernel objects not user-mode objects.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204943">
				<div id="div-comment-204943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204943">
			August 20, 2004 at 12:24 pm</a>		</div>

		<p>I wasn&#8217;t aware that kernel mode had a special version that took a spinlock. Strikes me as very odd.</p>
<p>If the user-mode version secretly took a spinlock, then you would end up with all the slists in the process sharing the same spinlock, which would create lock contention &#8211; exactly the opposite goal of the slist functions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204893">
				<div id="div-comment-204893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.savagenomads.net/archives/000203.html' rel='external nofollow' class='url'>Savage Nomads</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204893">
			August 20, 2004 at 1:45 pm</a>		</div>

		<p>&amp;nbsp; As Evan&amp;nbsp;already mentioned on his blog, Raymond Chen has a great series on /3GB switch on his blog. What is really cool is that Raymond takes on some myths about the /3GB switch and&amp;nbsp; the fact that he&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-205003">
				<div id="div-comment-205003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">darwou</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-205003">
			August 20, 2004 at 2:17 pm</a>		</div>

		<p>The spinlock parameter is for compatibility with older versions of Windows. The later ones ignore the spinlock parameter because they switched to a lock-free SList implementation.</p>
<p>If you want a single driver binary that runs on 2K/XP/2K3, you should define _WIN2K_COMPAT_SLIST_USAGE. This will revert to the older version of the API.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204933">
				<div id="div-comment-204933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-204933">
			August 20, 2004 at 11:58 am</a>		</div>

		<p>&quot;Sorry, I was talking about the non-Ex versions. (Those Ex functions aren&#8217;t Win32.) The non-Ex functions don&#8217;t have a spinlock parameter. &quot;<br />
<br />But equally, they&#8217;re allowed to let other threads run, because they&#8217;re user-mode, in which case nearly-no-lock is &quot;good enough&quot;.</p>
<p>If you&#8217;re talking about *Win32* you&#8217;re talking about *user-mode* in which case you can *always* be pre-empted, so your hardware interrupt situation *doesn&#8217;t matter*.  One of the other threads will *eventually* get a cycle and unblock, allowing the N+1th to continue.</p>
<p>If you&#8217;re talking about *kernel* functions, you can&#8217;t always be pre-empted, so your hardware interrupt situation *does* matter&#8211;but those functions take a spinlock (and so presumably *can* lock and wait) *anyway*.</p>
<p>&quot;And no, the kernel32 exports don&#8217;t use the spinlocks. (They can&#8217;t anyway since spinlocks are kernel objects not user-mode objects.) &quot;<br />
<br />No, but they could use a critical section behind the scenes, for much the same effect (as critical sections are just spinlocks which can escalate to events if they grow tired of spinning).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-205023">
				<div id="div-comment-205023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-205023">
			August 21, 2004 at 1:38 am</a>		</div>

		<p>When did the SList go lock-free?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-444343">
				<div id="div-comment-444343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/11/22/1122581.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-444343">
			November 22, 2006 at 10:00 am</a>		</div>

		<p>The fantasy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-444353">
				<div id="div-comment-444353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/11/22/1122581.aspx' rel='external nofollow' class='url'>The Old New Thing : The quiet dream of placebo settings</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-444353">
			November 22, 2006 at 10:00 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/11/22/1122581.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/11/22/1122581.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-613273">
				<div id="div-comment-613273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.fragmasters.co.uk/forum/f23/help-me-find-a-new-comp-22670/#post340502' rel='external nofollow' class='url'>help me find a new comp - Fragmasters Talkingforums</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040817-00/?p=38153#comment-613273">
			March 26, 2008 at 8:42 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.fragmasters.co.uk/forum/f23/help-me-find-a-new-comp-22670/#post340502" rel="nofollow">http://www.fragmasters.co.uk/forum/f23/help-me-find-a-new-comp-22670/#post340502</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>