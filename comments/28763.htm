<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (27)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-452123">
				<div id="div-comment-452123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452123">
			December 11, 2006 at 10:40 am</a>		</div>

		<p>I&#8217;ve never heard of the Application Verifier before. &nbsp;Thanks for the tip! &nbsp;Has anybody had any real-world experience using it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452133">
				<div id="div-comment-452133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452133">
			December 11, 2006 at 11:30 am</a>		</div>

		<p>Yeah, my real-world experience with it consisted of this:</p>
<p>Me: &nbsp;Hey, our app crashes under Microsoft&#8217;s Application Verifier. &nbsp;You need to figure out why and fix the problem.</p>
<p>Other developer: &nbsp;Come on, you can&#8217;t expect our application to work flawlessly under every possible situation. &nbsp;We only need to fix things our internal testers can find.</p>
<p>Me: &nbsp;Oh how I hate you.</p>
<p>(and I debugged and fixed the problem when I was moved full time to the project)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452223">
				<div id="div-comment-452223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452223">
			December 11, 2006 at 9:17 pm</a>		</div>

		<p>So, just out of interest, why is it possible to destroy a critical section while it is in use?</p>
<p>Is there ever a valid reason to do it, because, to me, it seems like something that you would never do, like closing a file while another thread is reading/writing it, is that possible?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452233">
				<div id="div-comment-452233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452233">
			December 11, 2006 at 9:22 pm</a>		</div>

		<p>&gt; This can also happen if some other piece of</p>
<p>&gt; code has a double-close bug, and the handle</p>
<p>&gt; (now closed) just happened to be reused as</p>
<p>&gt; the critical section&#8217;s event handle.</p>
<p>Ouch. &nbsp;In some programs I declared a boolean together with each file, and if error processing closed a file then I set the boolean to FALSE in order to know later not to close the same file again. &nbsp;But in some programs I was lazy and if error processing closed a file then other processing might just observe and discard an error return from closing the same file again. &nbsp;So in fact it&#8217;s a serious problem if later processing doesn&#8217;t get an error return because it closed some innocent victim instead, and the innocent victim is something that the program didn&#8217;t even know about.</p>
<p>The double close bug needs a lot more emphasis. &nbsp;It differs vastly from most other operating systems where a double close of a file has no effects beyond the file.</p>
<div class=post>[<i>*ix has the same double-close problem. It too recycles file handles. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452323">
				<div id="div-comment-452323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roman Belenov</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452323">
			December 12, 2006 at 3:13 am</a>		</div>

		<p>&#8220;One possibility is that the critical section has been corrupted, and the memory that normally holds the event handle has been overwritten with some other value that happens not to be a valid handle.&#8221;</p>
<p>IMHO it&#8217;s worth mentiioning that this corruption can be done by perfectly legal call to EnterCriticalSection in some rare circumstances.</p>
<p><a href="http://www.bluebytesoftware.com/blog/PermaLink,guid,db9f8f5b-8d1d-44b0-afbd-3eadde24b678.aspx" target="_new" rel="nofollow">http://www.bluebytesoftware.com/blog/PermaLink,guid,db9f8f5b-8d1d-44b0-afbd-3eadde24b678.aspx</a></p>
<div class="post">[<i>But only if you tried to catch the exception. Win32 exceptions are, as a general rule, not safely catchable since the code in between is rarely exception-safe. This is just another example. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452253">
				<div id="div-comment-452253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arlie Davis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452253">
			December 11, 2006 at 10:04 pm</a>		</div>

		<p>The double-close problem is actually *worse* on UNIX because the UNIX handle table will re-use the lowest unused fd index, which means that fds will be reused very, very quickly. &nbsp;NT does not recycle object handles nearly as quickly, so the problem is less likely to occur on NT.</p>
<p>It&#8217;s still a serious, serious flaw in any application, of course, and should always be fixed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452263">
				<div id="div-comment-452263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452263">
			December 11, 2006 at 10:55 pm</a>		</div>

		<p>&gt; *ix has the same double-close problem. It too</p>
<p>&gt; recycles file handles.</p>
<p>But only if the program opens another file between the two closes.</p>
<p>Monday, December 11, 2006 10:04 PM by Arlie Davis </p>
<p>&gt; The double-close problem is actually *worse*</p>
<p>&gt; on UNIX because the UNIX handle table will</p>
<p>&gt; re-use the lowest unused fd index, which means</p>
<p>&gt; that fds will be reused very, very quickly.</p>
<p>But fds won&#8217;t be reused for critical sections or tons of other stuff, they&#8217;ll only be reused for files (and pipes and stuff that get accessed as files).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452363">
				<div id="div-comment-452363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452363">
			December 12, 2006 at 6:59 am</a>		</div>

		<p>I&#8217;ve used Application Verifier just a little bit. Gflags.exe was more expressive.</p>
<p>In any case you will need a debugger attached to see the results, and probably do more analysis, (so learn how to use WinDbg&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-larryosterman even thread-even depth-1" id="comment-452273">
				<div id="div-comment-452273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Larry+Osterman+%5BMSFT%5D' rel='external nofollow' class='url'>Larry Osterman [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452273">
			December 11, 2006 at 11:31 pm</a>		</div>

		<p>Norman, the double close problem on Windows is exactly the same as the double close problem on *nix, and has exactly the same pre and post conditions.</p>
<p>What I don&#8217;t know is if *nix has a global handle manager or if each of the handles to objects is managed by a separate subsystem &#8211; if the handles are managed by unrelated subsystems, then that causes a whole other set of problems (if handle number 17 is used for both a critical section and for a file, hilarity can ensue when handle 17 is handed to the wrong close API).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452423">
				<div id="div-comment-452423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arlie Davis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452423">
			December 12, 2006 at 11:08 am</a>		</div>

		<p>James: UNIX &quot;file&quot; handles have not just been &quot;file&quot; handles for a long, long time. &nbsp;They are, conceptually and in real-life use, exactly the same as object handles on NT. &nbsp;You&#8217;re quibbling about details of the behavior of a class of bugs (double-close) on different platforms. &nbsp;But it&#8217;s all the same bug, with all the same effects!</p>
<p>Your &quot;liquid dispenser&quot; analogy is idiotic and wrong. &nbsp;If you look at the Windows API functions that take objects as parameters, they DO take the type of the object into account. &nbsp;Every function validates the type of object that it is acting on; if you call ReadFile on a semaphore, the call will fail with a &quot;wrong object type&quot; error.</p>
<p>There are only a handful of functions that can work on more than one object type. &nbsp;The WaitFor* functions, and CloseHandle. &nbsp;This is hardly &quot;reactor coolant&quot; and &quot;baby food&quot;. &nbsp;You are intentionally skewing this discussion to make your pet OS look better, when in reality, it isn&#8217;t. &nbsp;If there were 15 types of CloseHandle functions (CloseFileHandle, CloseXxxHandle), you would probably be complaining that Windows makes you remember too much.</p>
<p>BryanK: All object handles that user-mode processes can access are bound to that process. &nbsp;If this was not the case, it would be impossible to create a secure system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452313">
				<div id="div-comment-452313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452313">
			December 12, 2006 at 3:09 am</a>		</div>

		<p>Monday, December 11, 2006 11:31 PM by LarryOsterman </p>
<p>&gt; Norman, the double close problem on Windows</p>
<p>&gt; is exactly the same as the double close</p>
<p>&gt; problem on *nix, and has exactly the same pre</p>
<p>&gt; and post conditions.</p>
<p>I still don&#8217;t believe it. &nbsp;In Windows the innocent victim can be an event handle that the program didn&#8217;t even know about, or surely other kinds of handles that the program didn&#8217;t even know about. &nbsp;In Unix the innocent victim can only be a file identifier, and the only way for it to be a valid file identifier is if the program has opened another file in between the two closes.</p>
<p>&gt; What I don&#8217;t know is if *nix has a global</p>
<p>&gt; handle manager</p>
<p>It doesn&#8217;t matter. &nbsp;It could vary by kernel (System V, NetBSD, Linux 2.4.9, Linux 2.4.10, etc., all completely different). &nbsp;It doesn&#8217;t matter what they do internally because the API presented to programs uses small integer file identifiers. &nbsp;0 is stdin, 1 is stdout, 2 is stderr, 3 is whatever the program opens next, etc. &nbsp;(I guess 3 doesn&#8217;t have to be next but it still doesn&#8217;t matter, 3 isn&#8217;t going to be a critical section&#8217;s event handle.)</p>
<div class="post">[<i>I don&#8217;t get it. You say it&#8217;s not the same problem, and then describe the same problem: If you close something twice and somebody reuses the handle in between, then you closed the wrong thing. The details may be different but the problem is the same: Handle reuse. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452433">
				<div id="div-comment-452433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sergio</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452433">
			December 12, 2006 at 11:28 am</a>		</div>

		<blockquote><p>
  The Windows approach is like a generic &#8216;liquid dispenser&#8217;
</p></blockquote>
<p>That was exactly the initial goal of Unix authors too &#8212; to treat as much as possible as file handle. And it is actually a good concept. For just a simplest example, although not historically first, to read random bits, you just open a file named &quot;/dev/random&quot; and read from it. Only when unix started to be expanded, the &quot;non file&quot; calls were added in quantities (that&#8217;s why you can&#8217;t read sockets like files). Windows designers somewhere tried to follow the initial Unix idea (e.g. COM port is really opened by CreateFile, although reading from it properly is not so easy) but more often they didn&#8217;t.</p>
<p>I would personally be happier when there were more things visible &quot;as files&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452453">
				<div id="div-comment-452453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452453">
			December 12, 2006 at 12:26 pm</a>		</div>

		<p>&quot;Only when unix started to be expanded, the &quot;non file&quot; calls were added in quantities (that&#8217;s why you can&#8217;t read sockets like files).&quot;</p>
<p>You can (and often do) call read(2) on the handle for a connected socket. You only need something else if your socket isn&#8217;t connected or you want extra information on top of the actual transmitted data, such as the return address, out of band messages, error statistics etc.</p>
<p>If a connected socket is passed as e.g. standard input to an ordinary Unix process, messages that arrive at that socket will be read by the process as its input.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452353">
				<div id="div-comment-452353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sandman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452353">
			December 12, 2006 at 6:56 am</a>		</div>

		<p>I&#8217;ve never been hit by the double close thing on *ix, but I cant<br />
recall getting hit by this on windows either &#8211; or at least enough to<br />
have difficultly finding the issue.</p>
<p>I agree wiht the MS team hgere that the bug is the same between Os&#8217;s<br />
, if wnayhting should be worse undix *ix because of the mroe frequent<br />
re-use but I;ve done a lot of progamming under *ix without hitting hit<br />
seriously by it.</p>
<p>However I think it could be real bad in the case Raymonds describing<br />
here as the actual handle is obscure behind an ptr to an opaque (and<br />
rightly so) data strucuture. The fact that a crtical section handle<br />
contains an event handle handle and hidden one can be invalid is a<br />
problem. Particlaur if the error message returned directs the users to<br />
think the outer (critical section) handle is the invalid one.</p>
<p>Does windows return the same error for and invalid cs handle as for an invalil cs-&gt;event handle ?</p>
<div class="post">[<i>Critical sections are not handles. They&#8217;re just a<br />
chunk of memory (CRITICAL_SECTION). If you pass a pointer to a bogus<br />
chunk of memory then undefined things happen. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452533">
				<div id="div-comment-452533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asampson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452533">
			December 12, 2006 at 3:21 pm</a>		</div>

		<p>Windows 2003? Did I miss a release?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452553">
				<div id="div-comment-452553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452553">
			December 12, 2006 at 3:41 pm</a>		</div>

		<p>Modern versions of Unix use &quot;files&quot; for all kinds of things that aren&#8217;t even close to files, such as initializing memory (/dev/zero), generating random numbers (/dev/random), and getting process statistics (/proc).</p>
<p>It&#8217;s entirely possible that a double-close bug in your process statistics code (reading /proc) could cause a failure in your random number generator.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452393">
				<div id="div-comment-452393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452393">
			December 12, 2006 at 8:08 am</a>		</div>

		<p>&gt; If you close something twice and somebody reuses the handle in between, then you closed the wrong thing.</p>
<p>But it depends on who &#8220;somebody&#8221; is.</p>
<p>In Windows, if another process was the one that had the double-close<br />
bug, is it possible for your critical section&#8217;s event to have been<br />
closed? &nbsp;I&#8217;d hope not (since that would violate just about every<br />
principle of keeping processes separate), but I don&#8217;t know for sure.</p>
<p>I know that on *nix, file handles are per-process, so if some other<br />
process gets 5 back from an open() call, and you&#8217;ve done a close(5)<br />
twice, you won&#8217;t corrupt that other process.</p>
<p>(Of course, even if handles in Windows are per process, you can<br />
still screw up your own process from another thread. &nbsp;Same on<br />
*nix, I believe &#8212; AFAIK file handles are shared between threads.<br />
&nbsp;OTOH, it seems that vastly fewer *nix programs are<br />
multithreaded&#8230;)</p>
<div class="post">[<i>I&#8217;m assuming everybody knows whether handles are global or per-process. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452403">
				<div id="div-comment-452403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://deadnode.org/sw/' rel='external nofollow' class='url'>James</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452403">
			December 12, 2006 at 8:45 am</a>		</div>

		<p>Raymond: The difference is that Unix file handles are not &#8220;handles&#8221;,<br />
they are &#8220;*file* handles&#8221;, completely distinct from, say, semaphores.<br />
For a Unix library to close your semaphore when it meant to close its<br />
own file, it would have to be calling completely the wrong function,<br />
not just calling the right function too many times.</p>
<p>The Windows approach is like a generic &#8216;liquid dispenser&#8217;, with<br />
numbered nozzles for everything from baby food to reactor coolant, as<br />
opposed to Unix having a completely separate set of fuel nozzles: you<br />
might still end up putting diesel in a petrol car by mistake, but you<br />
won&#8217;t be left drinking a pint of Draino instead of the<br />
similarly-numbered beer you expected.</p>
<p>It&#8217;s funny; I&#8217;d expect freeing and allocating blocks of memory to go<br />
through a single API (malloc/free or equivalent) while files and<br />
critical sections would be separate (since they have nothing in<br />
common)&#8230;</p>
<p>Bryan: You&#8217;re right; between processes being much &#8220;cheaper&#8221; and<br />
greater use of non-blocking I/O, there&#8217;s much less need for threads.</p>
<div class="post">[<i>Yes, I know that they operate only on file<br />
descriptors, but the core problem is the same &#8211; handle reuse. (Files<br />
and critical sections *are* separate. You can&#8217;t CloseHandle a critical section.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452563">
				<div id="div-comment-452563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://deadnode.org/sw/' rel='external nofollow' class='url'>James</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452563">
			December 12, 2006 at 3:42 pm</a>		</div>

		<p>Arlie: you have a point that double-closing remains possible, but a file descriptor remains precisely that: a file, not an &quot;object&quot; wrapped around one of a variety of possible things.</p>
<p>You haven&#8217;t identified anything &quot;wrong&quot; about it, nor am I &quot;skewing&quot; anything: yes, attempting the impossible fails, as one would expect (did you seriously expect trying to read data from something which doesn&#8217;t contain any to do anything else?!) &#8211; but why doesn&#8217;t closing something mirror opening it? You don&#8217;t call CreateHandle to get an event, you call CreateEvent: why break the symmetry like that? I very much doubt people would complain about having simple and obvious symmetry &#8211; CreateEvent/CloseEvent and CreateFile/CloseFile &#8211; rather than the present, more complex setup, where operating on an event might involve an Event function or a Handle one depending on the weather.</p>
<p>By calling both files and events &quot;HANDLE&quot;, you lose type checking. Yes, the *OS* knows what&#8217;s inside &#8211; but now, the compiler doesn&#8217;t. I&#8217;m no fan of languages like ML, but I still value some type checking.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452753">
				<div id="div-comment-452753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452753">
			December 13, 2006 at 4:09 am</a>		</div>

		<p>asampson:</p>
<blockquote><p>
  Windows 2003? Did I miss a release?
</p></blockquote>
<p>I don&#8217;t know, did you?</p>
<p><a rel="nofollow" target="_new" href="http://www.microsoft.com/windowsserver2003/" rel="nofollow">http://www.microsoft.com/windowsserver2003/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452723">
				<div id="div-comment-452723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452723">
			December 12, 2006 at 9:52 pm</a>		</div>

		<p>&gt; I don&#8217;t get it. You say it&#8217;s not the same</p>
<p>&gt; problem, and then describe the same problem:</p>
<p>&gt; If you close something twice and somebody</p>
<p>&gt; reuses the handle in between, then you closed</p>
<p>&gt; the wrong thing. The details may be different</p>
<p>&gt; but the problem is the same: Handle reuse.</p>
<p>Well, if I think really hard then I can imagine some cases where Unix would open a file and assign the fd number to a process without the process expecting it or knowing about it. &nbsp;But if I think harder then I forget what I was thinking of. &nbsp;It still doesn&#8217;t seem to be as easy to do as unknowingly having handles opened by Windows APIs.</p>
<p>By the way notice that I didn&#8217;t complain about the design philosophy. &nbsp;I only asked that the warning about double close bugs be emphasized more widely. &nbsp;Programs get in real trouble when a duplicate call to CloseHandle *doesn&#8217;t* return an error. &nbsp;For example the MSDN page for CloseHandle should emphasize that programmers must take care never to do a double close.</p>
<div class="post">[<i>What about double-DestroyWindow? Double-LocalFree? Double-delete? Should they all say &#8220;don&#8217;t destroy something more than once&#8221;? At what point do you stop restating the ground rules for programming? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452973">
				<div id="div-comment-452973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-452973">
			December 13, 2006 at 7:26 pm</a>		</div>

		<p>Interesting and frustrating problem I had with Application Verifier. &nbsp;I read about it on your blog, downloaded it, installed it, and (to try it out) picked notepad.exe for the application.</p>
<p>At that point it told me of the need for a debugger, which I didn&#8217;t have installed on this computer, and quit. &nbsp;I uninstalled the software and forgot about it.</p>
<p>Today rolls around. I&#8217;m on a web site browsing a catalog without a wishlist and I find a bunch of new items I want. &nbsp;I fire up notepad, go page by page through the items &#8211; recording description, cost, etc. until I&#8217;m done. &nbsp;When I go to save the list on my desktop a dialog pops up telling me I&#8217;ve hit some sort of breakpoint. &nbsp;Crap, I think, as I press &lt;Ok&gt;. &nbsp;Gone is notepad, my list, and my time.</p>
<p>Works ok now, but boy am I glad I didn&#8217;t try App Verifier out on Word (or worse). &nbsp;I might have lost a day&#8217;s worth of work (or a years worth of Quicken data).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453003">
				<div id="div-comment-453003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-453003">
			December 13, 2006 at 8:38 pm</a>		</div>

		<p>&gt; What about double-DestroyWindow?</p>
<p>&gt; Double-LocalFree? Double-delete?</p>
<p>OK, I see your point.</p>
<p>&gt; At what point do you stop restating the</p>
<p>&gt; ground rules for programming?</p>
<p>I see your point there too, but it leads to another odd observation. &nbsp;Some MSDN pages about APIs restate ground rules about C (often correctly) where I think it would be better to restate ground rules about Windows. &nbsp;In view of a lot of garbage programs that you and I both have to contend with, a lot of programmers need a lot of ground rules to be restated. &nbsp;On the other hand a lot of those programmers would never understand the purpose or usage of MSDN pages. &nbsp;So here you go. &nbsp;You ask an impossible question, you get a rambling answer.</p>
<p>Wednesday, December 13, 2006 7:26 PM by Mike</p>
<p>&gt; Interesting and frustrating problem I had</p>
<p>&gt; with Application Verifier.</p>
<p>I wonder. &nbsp;I thought release builds of applications (Notepad or other) were supposed to have no breakpoints. &nbsp;I wish that release builds didn&#8217;t have most of their debugging information stripped out but that&#8217;s a bit different from imposing breakpoints on retail customers.</p>
<p>&gt; Gone is notepad, my list, and my time.</p>
<p>If you were using Internet Explorer 7 you wouldn&#8217;t even need Notepad, Application Verifier, or anything else in order to reach that state. &nbsp;IE 7 crashed several times per day, closing three or four windows at a time, and only half the time it offered to send crash dumps to Microsoft. &nbsp;Yesterday I uninstalled it. &nbsp;The uninstallation deleted several Windows Update security patches in addition to uninstallting IE 7. &nbsp;Running Windows Update under the restored IE 6 did not offer to reinstall the deleted security patches. &nbsp;One machine now is running with known vulnerabilities and I&#8217;m considering reinstalling XP.</p>
<div class=post>[<i>The breakpoint came from the verifier; it&#8217;s not from Notepad proper. That&#8217;s why the verifier documentation says you need a debugger. I&#8217;m not sure why you&#8217;re ranting about IE7 here. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-453053">
				<div id="div-comment-453053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-453053">
			December 14, 2006 at 3:41 am</a>		</div>

		<blockquote><p>
  The breakpoint came from the verifier; it&#8217;s</p>
<p>  not from Notepad proper.
</p></blockquote>
<p>OK, glad to hear it.</p>
<blockquote><p>
  I&#8217;m not sure why you&#8217;re ranting about IE7</p>
<p>  here.
</p></blockquote>
<p>Well, if I were using IE7 I wouldn&#8217;t be able to post a rant about it ^_^ &nbsp;But you&#8217;re right, my frustration and Mike&#8217;s frustration had unrelated roots. &nbsp;Sorry.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453153">
				<div id="div-comment-453153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-453153">
			December 14, 2006 at 12:13 pm</a>		</div>

		<p>&gt;&gt;The breakpoint came from the verifier; </p>
<p>Oops, I meant to comment on this when I posted and forgot. &nbsp;What I found interesting was that I hit the breakpoint two days later, after I had shut down and uninstalled Application Verifier and the computer had been rebooted a couple times.</p>
<p>Not only was I not expecting a breakpoint, I&#8217;d always assumed that, when setting one, the executable was patched up in memory (INT3 or some such, it&#8217;s been a while for me) to cause one. &nbsp;The mechanism that allowed the breakpoint to hit days later threw me.</p>
<div class=post>[<i>The verifier also turns on debugging code in the core OS that is off by default. That&#8217;s why you hit it even after you uninstalled the verifier. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-453343">
				<div id="div-comment-453343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-453343">
			December 15, 2006 at 12:46 pm</a>		</div>

		<p>&gt;The verifier also turns on debugging code in the core OS that is off by default. </p>
<p>&gt;That&#8217;s why you hit it even after you uninstalled the verifier.</p>
<p>This behaviour is really, *really* annoying. For reasons too complicated to go into, I had to run App.Verifier on a server that was running some custom app that was causing problems. Unfortunately uninstalling it afterwards didn&#8217;t completely get rid of it (as you mention above), and in the end the only way to get the server running properly was a complete reinstall, which was what running App.Verifier on the thing was supposed to avoid in the first place (the custom stuff on there is extremely painful to configure). Why can&#8217;t the uninstall restore the original state, instead of leaving performance-affecting fundamental system changes in effect? Perhaps the App.Verified install should warn users that it&#8217;ll make changes to your system that can&#8217;t be undone, and it should only be used on sacrificial test machines.</p>
<div class=post>[<i>You can undo them, you just have to remember to undo them before you uninstall Application Verifier. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453623">
				<div id="div-comment-453623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061211-00/?p=28763#comment-453623">
			December 17, 2006 at 6:16 am</a>		</div>

		<blockquote><p>
  You can undo them, you just have to remember to undo them before you uninstall Application Verifier.
</p></blockquote>
<p>The problem with this is that (a) you need to know the changes have been made (which I didn&#8217;t until I read your comment above) and (b) you need to know what is is that A.V. changed. I have no idea what it&#8217;s done to the system, and consequently what needs to be undone.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>