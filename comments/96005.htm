<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (31)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-jeremytais even thread-even depth-1" id="comment-1293245">
				<div id="div-comment-1293245" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/SimonRev' rel='external nofollow' class='url'>SimonRev</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293245">
			April 20, 2017 at 7:13 am</a>		</div>

		<p>You are lobbing us an easy one today Raymond.  15 years ago that would have been a tricky exercise, but today hopefully anyone who does programming that involves pointers is cognizant of LARGEADDRESSAWARE and the distinct possibility that a 32 bit user mode app may have valid memory above the 2gb barrier.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1293255">
				<div id="div-comment-1293255" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293255">
			April 20, 2017 at 7:44 am</a>		</div>

		<p>&#8220;generat3ed &#8221; : typo</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-bboorman even depth-2" id="comment-1293265">
				<div id="div-comment-1293265" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293265">
			April 20, 2017 at 8:06 am</a>		</div>

		<p>No, Raymond was smuggling the sentinel value 3 inside a string. If you don&#8217;t know what the 3 means, I&#8217;m afraid there&#8217;s no hope for you.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1293395">
				<div id="div-comment-1293395" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293395">
			April 20, 2017 at 2:59 pm</a>		</div>

		<p>Not a typo. The &#8220;3&#8221; was silent you see.</p>
<p>Homage to Tom Lehrer, <i>We Will All Go Together When We Go</i>: &#8220;I am reminded at this point of a fellow I used to know who&#8217;s name was Henry, only to give you an idea of what an individualist he was he spelt it HEN3RY. The 3 was silent, you see.&#8221;</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1293275">
				<div id="div-comment-1293275" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293275">
			April 20, 2017 at 8:41 am</a>		</div>

		<p>Raymond mentioned the bottom of the address space, but what about the top?</p>
<p>If your widget object has at least x bytes, the last x-1 bytes of the address space can be used as sentinel values. In particular, unless your widget object it a single byte, -1 (the last byte of the address space) is a good sentinel value.</p>
<p>(The Linux kernel does something similar: if the return value of a system call is a negative value above -4096, it&#8217;s an error value. This works even for system calls like mmap which returns a pointer, since its successful return value points to a 4096-byte (or greater) page.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1293295">
				<div id="div-comment-1293295" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Irek Zielinski</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293295">
			April 20, 2017 at 8:58 am</a>		</div>

		<p>Values above 0x80000000 are typically not used in 32 bit applications, unless one is marked as &#8220;Large Address Aware&#8221; and running on 64 bit windows.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1293335">
				<div id="div-comment-1293335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eric Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293335">
			April 20, 2017 at 10:46 am</a>		</div>

		<p>I think you mean &#8220;OR running on win64&#8221;.  If you are large address aware on win32, you have to be prepared for addresses larger than 0x80000000.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-yuhong-bao odd alt depth-3" id="comment-1293346">
				<div id="div-comment-1293346" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293346">
			April 20, 2017 at 11:51 am</a>		</div>

		<p>I think they mean &#8220;running on 64-bit Windows or booted with the /3GB switch&#8221;</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-even depth-1" id="comment-1293305">
				<div id="div-comment-1293305" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293305">
			April 20, 2017 at 9:11 am</a>		</div>

		<p>This reminds me of what LLVM does with bitpacking values into pointers Chandler Carruth goes into detail <a href="https://youtu.be/vElZc6zSIXM?t=22m" rel="nofollow">https://youtu.be/vElZc6zSIXM?t=22m</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1293306">
				<div id="div-comment-1293306" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293306">
			April 20, 2017 at 9:19 am</a>		</div>

		<p>As well as not being largeaddressaware, 0x80000000 is, after suitable casting, going to compile perfectly happily in the 64-bit port of your software that will be done several years after everyone has forgotten how cleverly the sentinel values were done.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1293316">
				<div id="div-comment-1293316" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodr√≠guez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293316">
			April 20, 2017 at 9:55 am</a>		</div>

		<p>Even in 32-bit software without LARGEADDRESSAWARE, most of the addresses above 0x80000000 aren&#8217;t usable as sentinel values. IIRC, Win32 reserves two sentinel areas, 64 KB in size, just above and bellow the border, but any address above the upper sentinel area is kernel space and, thus, can be returned by a function which references kernel memory. So, of the values above 0x80000000, just a fraction of them can be safely used as sentinel values, and just under some conditions. Too variable to be useful.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1293345">
				<div id="div-comment-1293345" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eric Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293345">
			April 20, 2017 at 10:49 am</a>		</div>

		<p>Why would a user mode function return a pointer to an address in kernel space?  You can&#8217;t read or write to it from user space, so that doesn&#8217;t sound especially useful.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-msn even depth-3" id="comment-1293375">
				<div id="div-comment-1293375" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/poizan42' rel='external nofollow' class='url'>poizan42</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293375">
			April 20, 2017 at 12:40 pm</a>		</div>

		<p>Why are there kernel mode pointers in the TEB? &#8211; Well actually I&#8217;m not sure I want to know the answer to that&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-3" id="comment-1293386">
				<div id="div-comment-1293386" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodr√≠guez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293386">
			April 20, 2017 at 2:39 pm</a>		</div>

		<p>It&#8217;s not that an user function could return a kernel space pointer. It&#8217;s that, AFAIK, a kernel space pointer can, under some circumstances, be valid in user mode. And this opens the possibility that the pointer gets mistaken for a sentinel value.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-odd thread-alt depth-1 parent" id="comment-1293326">
				<div id="div-comment-1293326" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293326">
			April 20, 2017 at 10:46 am</a>		</div>

		<p>&#8220;Prior to Windows 8, applications could unreserve the bottom 64KB of address space and allocate actual memory there, which created the opportunity for mass confusion.&#8221;<br />
And security problems. Of course, you can still enable NTVDM and get the support back.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1293385">
				<div id="div-comment-1293385" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293385">
			April 20, 2017 at 1:53 pm</a>		</div>

		<p>Oh man. Something I discussed once to make .NET code untraceable was to allocate that bottom 64k and fill it with zeros. Deferencing nulls in C# yielded zeroed objects. Usually this would try to follow a virtual function call and crash, but if it wasn&#8217;t a virtual call it would actually call the object code with null this, which might succeed on doing something interesting if the code is just so.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1293355">
				<div id="div-comment-1293355" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293355">
			April 20, 2017 at 12:25 pm</a>		</div>

		<p>There is also the easiest of all solutions although it may waste some space depending on how large your widgets are:</p>
<p>Widget *my_great_sentinal = new Widget;</p>
<p>If your widget is only a few bytes large that&#8217;s a nice, easy to understand, hard to get wrong solution. Although it&#8217;s a pity that you can&#8217;t demonstrate how clever you are by using it.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1293365">
				<div id="div-comment-1293365" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293365">
			April 20, 2017 at 12:32 pm</a>		</div>

		<p>Raymond does even suggest that in the article: &#8220;If you need a small number of sentinel values, you could just allocate a few objects for the sole purpose of providing an address.&#8221;</p>
<p>If one wanted to be fancy, one can be all object oriented, with a CouldBeAWidget base class/interface, and SentinelWidget and RealWidget implementations. I&#8217;m sure that that&#8217;s all I&#8217;d ever need to do on the systems I generally deal with, but Raymond (and presumably others) sometimes deal with the lower levels of things where I can imagine it&#8217;d be useful to overload pointer values in these various ways.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1293415">
				<div id="div-comment-1293415" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">kme</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293415">
			April 20, 2017 at 6:46 pm</a>		</div>

		<p>You can also do things like:</p>
<p>static const char sentinels[3];</p>
<p>const Widget * const widget_default = (const Widget *)&amp;sentinels[0];<br />
const Widget * const widget_all = (const Widget *)&amp;sentinels[1];<br />
const Widget * const widget_inherit = (const Widget *)&amp;sentinels[2];</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1293465">
				<div id="div-comment-1293465" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Haim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293465">
			April 21, 2017 at 5:59 am</a>		</div>

		<p>I&#8217;m not sure how valid it is. It definitely breaks the strict aliasing rule , and I&#8217;m not sure about the alignment ..</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1293475">
				<div id="div-comment-1293475" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Haim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293475">
			April 21, 2017 at 6:04 am</a>		</div>

		<p>Although now that I think about it it could work with array of unions where each Union contains T and char c. This will fix both the strict aliasing and the alignment issues . Just don&#8217;t dereference that pointer..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-4 parent" id="comment-1293505">
				<div id="div-comment-1293505" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293505">
			April 21, 2017 at 7:27 am</a>		</div>

		<p>The strict aliasing rule only affects dereferenced pointers. If you never dereference the sentinel pointers (and you shouldn&#8217;t if you&#8217;re using most of the other ideas in this post/comments) then you&#8217;re OK. Ditto on the alignment. It doesn&#8217;t matter. The pointers are only sentinels to indicate special cases; like NULL, they&#8217;re not *meant* to be pointers to valid objects, or to be dereferenced. They&#8217;re just values that can be identified, and won&#8217;t ever be used as pointers to valid objects.</p>
<p>The GP&#8217;s solution has the advantage of only using 1 byte per sentinel (plus the sentinel value itself), whereas your other suggestion uses sizeof(Widget) per sentinel. At that point, I don&#8217;t see the advantage in using an array of unions over a plain array of Widgets.</p>
<p>Although I think the GPs suggestion falls under Raymond&#8217;s &#8220;you could just allocate a few objects for the sole purpose of providing an address.&#8221; (with the caveat that the objects you&#8217;ve allocated (chars) aren&#8217;t of the expected type, but not in any way that matters) &#8211; because that&#8217;s the reason I didn&#8217;t post the exact same comment myself a few hours before!</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1293725">
				<div id="div-comment-1293725" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt (Visual Studio and Development Technologies MVP with C++ focus)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293725">
			April 24, 2017 at 1:12 pm</a>		</div>

		<p>Alignment absolutely does still matter.  The only rule that guarantees that widget_all != widget_inherit is the one that makes them round-trip when converted back to the original pointer type (char*), and that rule doesn&#8217;t apply unless alignment is respected.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1293435">
				<div id="div-comment-1293435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Martin Bonner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293435">
			April 21, 2017 at 12:25 am</a>		</div>

		<p>Critique:  Presumably the idea is that 32-bit Windows uses the top half of the address space for the kernel so user objects won&#8217;t go there.  Problems:<br />
64-bit totally messes this up<br />
Large-address-space free everything below 3G for the user.<br />
Shared memory goes above the limit anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1293485">
				<div id="div-comment-1293485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MV</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293485">
			April 21, 2017 at 6:39 am</a>		</div>

		<p>I once wrote an application that kept important data in the low-order 2 bits of 4-byte-aligned pointers.  Essentially the pointer could point to any of 4 different kinds of things, without requiring the pointed-to things to inherit from a common base.  I still can&#8217;t decide if it was an elegant solution, or a horrible hack.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1293486">
				<div id="div-comment-1293486" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Electron Shepherd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293486">
			April 21, 2017 at 7:03 am</a>		</div>

		<p>Well, elegant or hack, the kernel people were thinking along the same lines.</p>
<p>see <a href="https://blogs.msdn.microsoft.com/oldnewthing/20050121-00/?p=36633" rel="nofollow">https://blogs.msdn.microsoft.com/oldnewthing/20050121-00/?p=36633</a></p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1293496">
				<div id="div-comment-1293496" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293496">
			April 21, 2017 at 7:11 am</a>		</div>

		<p>Does using misaligned pointers as sentinels not violate some C (and C++) rule about pointers?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1293515">
				<div id="div-comment-1293515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293515">
			April 21, 2017 at 7:42 am</a>		</div>

		<p>Some processors have used pointer registers that validate a pointer when they are loaded, so a bad pointer will immediately fault.  Thus it is undefined behaviour in C/C++ to even form an invalid pointer.  (At least it used to be.  I don&#8217;t keep up with this kind of thing any more.)</p>
<p>Of course, you are free to use generally undefined behaviour that actually is defined on your target platform.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1293516">
				<div id="div-comment-1293516" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293516">
			April 21, 2017 at 8:30 am</a>		</div>

		<p>Though it might still trip you up.  A clever compiler could easily decide that a test like &#8220;if (1 &amp; (int)pointer) DoSentinelStuff();&#8221; could never succeed and throw it away.  Though if msvc did this I suspect Windows would break long before I was troubled by it.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1293685">
				<div id="div-comment-1293685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1293685">
			April 24, 2017 at 2:23 am</a>		</div>

		<p>Yes, &#8220;your target platform&#8221; here has to include all of CPU, OS, compiler and C library. Even if your CPU does a well-defined thing the other parts may still assume your C program is free of undefined behavior.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1294936">
				<div id="div-comment-1294936" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Guteniev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170420-00/?p=96005#comment-1294936">
			May 2, 2017 at 6:52 am</a>		</div>

		<p>I would prefer top or bottom 64 K rather than intentionally misaligned pointers. Those would be easier to interpret, also they would cause immediate access violation on access to indirected data.</p>
<p>Yet I&#8217;m aware of an example when there&#8217;s a need for intentionally misaligned pointers. One of low bits of aligned heap pointer is used by GlobalAlloc() to mark GMEM_MOVEABLE. So that GlobalLock can &#8216;fix&#8217; moveable pointer (marked with low bit) and do nothing with fixed pointer (not marked with low bit, direct result of RtlAllocateHeap).</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>