<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (110)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-250623">
				<div id="div-comment-250623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250623">
			January 31, 2005 at 7:23 am</a>		</div>

		<blockquote><p>
  Nobody in their right mind would transfer a pointer across processes</p>
<p>So, about a year after win64 ships, you&#8217;ll be writing a log entry about how the app-compat team had to write a patch for some app that did just that.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250633">
				<div id="div-comment-250633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250633">
			January 31, 2005 at 7:25 am</a>		</div>

		<p>I personally know many programmers who aren&#8217;t in their right mind.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250663">
				<div id="div-comment-250663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek Park</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250663">
			January 31, 2005 at 7:44 am</a>		</div>

		<p>Looks to me like this is a good example of the flaw with Microsoft&#8217;s typedefs.  If the typedefs had been defined as INT16, INT32, and INT64, there wouldn&#8217;t be a problem (well, not this problem) with porting to 64 bit.  The typedefs would need to be updated, but they would still be logically correct (i.e. INT32 is still 32 bits, and LONG just doesn&#8217;t exist).  In fact, such a port is still possible, but more difficult.</p>
<p>It&#8217;s hard to blame this entirely on Microsoft, though.  Their typedefs were still far better than the poorly defined C/C++ built-in types.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250673">
				<div id="div-comment-250673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250673">
			January 31, 2005 at 7:59 am</a>		</div>

		<p>I never liked most of Pascal, but declaring an integer variable&#8217;s range like 1..20 was a good idea. In many (most?) cases you&#8217;re using integers for counting and know you don&#8217;t need the full range. Then you let the compiler choose the best size. Yes, there need to be pragmas to nail down actual sizes, just like there are pragmas for struct alignment. But as it stands the compiler has no easy way to tell how big a number you might put in that variable.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250683">
				<div id="div-comment-250683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250683">
			January 31, 2005 at 8:03 am</a>		</div>

		<p>&quot;Parsing&quot; data files by overlaying a C struct is a bad idea anyway. What about other issues like endianness and alignment? I think it&#8217;s a far better idea to read the file in chunks (well, read large parts of it and parse it in chunks, really) and copy the data of interest into an in-memory structure, doing conversions as necessary. Sure, it might be a bit slower, but it&#8217;ll be far more portable.</p>
<p>Do all of the architectures that Win32 runs on have the same endianness? I guess they must, or overlaying that bitmap structure over a bitmap file would fail on some platforms but not others. I can&#8217;t actually remember off the top of my head which platforms Windows NT is or has been available for, though.</p>
<p>With all that said, I do think it was a good idea to leave the data sizes the same. Knowing the kinds of nasty tricks and stupid mistakes application developers make, it would have been a portability nightmare. The days when the release of a new system meant rewriting or heavily modifying your application are (in most cases) behind us, and I like it much better this way. (Not to say that good programmers shouldn&#8217;t use practices that make their programs generally storage-size-independent, though.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250693">
				<div id="div-comment-250693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">G. Man</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250693">
			January 31, 2005 at 8:03 am</a>		</div>

		<p>I would generally ignore anything Beer28 says, he is a Linux troll and a poor one at that.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250703">
				<div id="div-comment-250703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.apptranslator.com' rel='external nofollow' class='url'>Serge Wautier</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250703">
			January 31, 2005 at 8:12 am</a>		</div>

		<blockquote><p>
  any change to the integer sizes would result in a mismatch.</p>
<p>I may be nitpicking here but I think it&#8217;s worth pointing out that it had been possible to change the size of int when switch from Win16 to Win32 because long was preferred to int in Windows header files. The trick consisted in keeping long&#8217;s size unchanged while changing int&#8217;s size.</p>
<p>Now long can&#8217;t stay 32 bits if int becomes 64 bits because the C/C++ standard says that long&#8217;s size must be greater than or equal to int&#8217;s size.</p>
<p>The question is, since LONG seems to be preferred to long in Windows headers, what about typedef&#8217;ing LONG to a 32 bit integer (short?) while int and long become 64 bits ? From semantics point of view, it&#8217;s not elegant (LONG is no longer that long&#8230; And I agree this is not negligeable !). But is there any major technical problem besides this semantics problem ?<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250713">
				<div id="div-comment-250713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250713">
			January 31, 2005 at 8:14 am</a>		</div>

		<p>&quot;The Win64 team selected the LLP64 data model, in which all integral types remain 32-bit values and only pointers expand to 64-bit values. Why? &quot;</p>
<p>To create gratuitous incompatibility with Unix.</p>
<p>&quot;If a LONG expanded from a 32-bit value to a 64-bit value, it would not be possible for a 64-bit program to use this structure to parse a bitmap file. &quot;<br />
<br />So fix the header to not say &quot;LONG&quot; but instead &quot;DWORD&quot; or whatever it should be.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250733">
				<div id="div-comment-250733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250733">
			January 31, 2005 at 8:17 am</a>		</div>

		<p>DrPizza: One structure down, 20 billion to go. And most of the 20 billion belong to you &#8211; the application progammer &#8211; not to Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250753">
				<div id="div-comment-250753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BlackTigerX</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250753">
			January 31, 2005 at 8:20 am</a>		</div>

		<p>and fix the other 3 million structures with the same thing, oh, plus any user made structures&#8230;</p>
<p>I don&#8217;t know about that</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250763">
				<div id="div-comment-250763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lowercase josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250763">
			January 31, 2005 at 8:36 am</a>		</div>

		<p>Hey, if you don&#8217;t like it, you can always #define long __int64 #define int __int32 or something.</p>
<p>Of course then you&#8217;ll have trouble using other people&#8217;s header files and linking with the C++RT&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250773">
				<div id="div-comment-250773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250773">
			January 31, 2005 at 8:39 am</a>		</div>

		<p>To take an analogy of perhaps what effect changing the type widths would have, think about the impact of migrating your code from old 8-bit characters to 16-bit Unicode.</p>
<p>If you think that nearly all existing code is going to run in 32-bit emulation anyway, then all code that wants or needs to be 64-bit should take the trouble to make sure it is properly 64-bit, in which case a &#8216;better&#8217; choice of type width could have been made. </p>
<p>IMHO, the current choice seems to be about short-term ease (unless its just a conspiracy to make source compatibility with 64-bit Linux more difficult :) )<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250783">
				<div id="div-comment-250783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vince</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250783">
			January 31, 2005 at 8:51 am</a>		</div>

		<p>Well if MS had realized this was a problem years ago when doing 64-bit Alpha port, or even with the ia64 port then most of the important structures could have been fixed long ago, and warnings could have been displayed so people could fix their own code.</p>
<p>It&#8217;s not really a compatibility issue, as it only makes a difference when re-compiling code, not when using an existing binary.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250823">
				<div id="div-comment-250823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250823">
			January 31, 2005 at 9:10 am</a>		</div>

		<p>&quot;most of the important structures could have been fixed&quot;.  If you don&#8217;t fix them all then the cure becomes worse than the disease.</p>
<p>&quot;short-term ease&quot;: Yup, this is a topic I intend to come back to in a few months.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250843">
				<div id="div-comment-250843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.eightypercent.net' rel='external nofollow' class='url'>Joe Beda</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250843">
			January 31, 2005 at 9:26 am</a>		</div>

		<p>Hey Raymond,</p>
<p>&quot;Nobody in their right mind would transfer a pointer across processes: Separate address spaces mean that the pointer value is useless in any process other than the one that generated it, so why share it?&quot;</p>
<p>The only case I can think of to pass pointer values across processes is for abstract cookies.  I know that I&#8217;ve designed APIs in the past where you register something and get a handle/cookie back.  That handle cookie is either a poitner directly or the pointer XORd with some private value.  While this is most common in proc, I can imagine someone doing it cross proc.  Implementing one of these legacy interfaces in 64-bit land means that you have to create a 64-&gt;32 bit map where you didn&#8217;t need to map before.  Not insurmountable but not straightforward either.</p>
<p>Joe</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250853">
				<div id="div-comment-250853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">A Cautious Observer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250853">
			January 31, 2005 at 9:36 am</a>		</div>

		<p>What Raymond is basically saying is that because on-disk and on-wire formats weren&#8217;t specified with explicit widths like INT32 instead of LONG then they were broken. User programs copied this brokenness and hence the LLP64 had to be chosen because of bad design choices made &gt; 15 years ago.<br />
<br />Is that a fair assessment?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250863">
				<div id="div-comment-250863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250863">
			January 31, 2005 at 9:36 am</a>		</div>

		<p>Cooney, no they won&#8217;t.  My trackback got lost, but:<br />
<br /><a target="_new" href="http://weblogs.asp.net/larryosterman/archive/2005/01/31/363881.aspx" rel="nofollow">http://weblogs.asp.net/larryosterman/archive/2005/01/31/363881.aspx</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250873">
				<div id="div-comment-250873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.csc.calpoly.edu/~bfriesen/' rel='external nofollow' class='url'>Brian Friesen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250873">
			January 31, 2005 at 10:14 am</a>		</div>

		<p>I agree with Derek Park, I wish Microsoft would drop the typedefs altogether and explicitly use __int8, __int16, __int32, and __int64; remove the ambiguity.</p>
<p>While we&#8217;re on the subjuct of typedefs, who at Microsoft was the genius behind &quot;DWORD64&quot; in BaseTsd.h?  This is a contradiction in terms, I guess they never heard of QWORD.  Also, why do the new 64-bit types end in &quot;PTR?&quot; (e.g. DWORD_PTR)  This is a misnomer since these aren&#8217;t pointers.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250883">
				<div id="div-comment-250883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spacebunny.xepher.net/' rel='external nofollow' class='url'>KJK::Hyperion</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250883">
			January 31, 2005 at 10:17 am</a>		</div>

		<p>Derek: Win32 does have explicit typedefs. There&#8217;s UINT8 to UINT64, INT8 to INT64, ULONG32/LONG32 (actually defined as non-long ints, probably by mistake) and ULONG64/LONG64. They just are relatively new and rarely used.</p>
<p>Ben: yes, Windows only ever ran on little-endian architectures. There&#8217;s very little places concerned with endianness in Win32, and they&#8217;re all #ifdef _MAC (i.e. the Win32 port to MacOS for Office and Internet Explorer)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250903">
				<div id="div-comment-250903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Swamp Justice</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250903">
			January 31, 2005 at 10:33 am</a>		</div>

		<p>If you are going to use explicitly sized ints, you should use the typedef defined by the C99 standard:</p>
<p>int8_t<br />
<br />int16_t<br />
<br />int32_t<br />
<br />uint8_t<br />
<br />uint16_t<br />
<br />uint32_t<br />
<br />&#8230;</p>
<p>Brian: I don&#8217;t think DWORD_PTR is not supposed to be used as an int. It is defines the int type that is large enough to hold a pointer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250913">
				<div id="div-comment-250913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/ericlippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250913">
			January 31, 2005 at 10:36 am</a>		</div>

		<p>Joe: </p>
<p>&gt; Not insurmountable but not straightforward either. </p>
<p>Indeed &#8212; in fact, an interview question I often ask &quot;industry&quot; candidates is to critique such a system, and then describe to me how they would implement such a system in 64 bit land without changing the requirement that the unique cookies be 32 bit integers.</p>
<p>It most definately is not straightforward &#8212; you can run into problems of security, efficiency, portability, all kinds of stuff.  I quite like &quot;open ended&quot; interview questions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250933">
				<div id="div-comment-250933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250933">
			January 31, 2005 at 11:14 am</a>		</div>

		<p>Larry,<br />
<br />Your link is about transferring handles, not pointers. You can transfer handles, but you will need OS support to do it. Pointers are still useless as pointers outside of their process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250943">
				<div id="div-comment-250943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250943">
			January 31, 2005 at 11:19 am</a>		</div>

		<p>Cooney, absolutely &#8211; but handles are logically pointers (the HANDLE type is a PVOID).</p>
<p>Swamp Justice: Revisionist history.  The C99 types you&#8217;re describing weren&#8217;t available in 1985, when many of these structures were finalized.  We&#8217;re not prescient.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250953">
				<div id="div-comment-250953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">long vs Long</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250953">
			January 31, 2005 at 11:21 am</a>		</div>

		<p>Long in (c++).net is 64-bit<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250963">
				<div id="div-comment-250963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250963">
			January 31, 2005 at 11:36 am</a>		</div>

		<p>Asking me, it is fix the header files, don&#8217;t &quot;fix&quot; the compiler. Many headers now DO use the new DWORD_PTR stuff, why not simply fix those? Gosh, a simple search/replace would do, is that hard?</p>
<p>BTW what will be the size of DWORD_PTR in 64 edition? 8 bytes I guess&#8230; so I&#8217;ll look at DWORD part and will think &quot;4 bytes&quot; and then will have to remember the PTR part and say &quot;oh, 8 bytes&quot;&#8230; Also, this means UINT and UINT_PTR could have sizes&#8230; well, asking me, this is at least confusing&#8230; And by the way, WORD wasn&#8217;t supposed to be fixed 2 bytes, but thanks to Intel it is&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250973">
				<div id="div-comment-250973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.philweber.com' rel='external nofollow' class='url'>Phil Weber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250973">
			January 31, 2005 at 11:39 am</a>		</div>

		<p>Raymond: Care to comment on why the VB.NET team made the opposite decision (redefining &quot;Integer&quot; to 32 bits), breaking VB6 persistence formats, not to mention Win32 API calls? Thanks! :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-250983">
				<div id="div-comment-250983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250983">
			January 31, 2005 at 11:51 am</a>		</div>

		<p>Waleri: The reason for DWORD_PTR is so that on 32-bit systems it stays DWORD. Does C99 have a &quot;pointer that is the same size as an integer&quot; type? </p>
<p>Phil: I am not qualified to comment on VB.NET design principles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250993">
				<div id="div-comment-250993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250993">
			January 31, 2005 at 12:10 pm</a>		</div>

		<p>Long time reader, first time poster.  love the show.</p>
<p>I don&#8217;t really buy Raymond&#8217;s inital argument that the definition of a bmp file (or any file format) should in some way define the size of data types in an OS.  Why not create a new data type for 64 bit quantities, higher precision reals, etc. (there are plenty of Windows specials, anyway &#8211; DWORD, for example).</p>
<p>As to RPC and DCOM, why isn&#8217;t data transmitted btween these in some network (architecture-independent) format?</p>
<p>Well, reading through the above post before sending, I can see that you&#8217;ve got to work with what you&#8217;ve got.</p>
<p>Were there any other possibilities?  A couple i can think of right now are a) new 64-bit data types, to keep RPC, file etc. formats valid, b) versioning in RPC and file formats to allow on the fly conversion (e.g. bmps translated in app layer [maybe with help from a library] plus new &#8217;64-bit bmp format&#8217;, RPC, etc. translated in OS subsystem). c) ?</p>
<p>Any thoughts on these?  Would they have been considered?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251003">
				<div id="div-comment-251003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mpz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251003">
			January 31, 2005 at 12:11 pm</a>		</div>

		<p>&quot;What about other issues like endianness and alignment?&quot;</p>
<p>Not to mention input validation. An attacker can inject unexpected values into a data file and crash the program / gain priviledges that way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251023">
				<div id="div-comment-251023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brent Dax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251023">
			January 31, 2005 at 12:48 pm</a>		</div>

		<p>I can understand why you wouldn&#8217;t want to use INT32-type things everywhere&#8211;that would mean a crapload of search-and-replace when you were porting to 64-bit.  But why not say that you should use INT{8,16,32,64} in serializable structures, and {SHORT,INT,LONG} otherwise?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251033">
				<div id="div-comment-251033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251033">
			January 31, 2005 at 12:57 pm</a>		</div>

		<p>Brent: Are you saying that existing structures should be retrofitted to use the INT&lt;n&gt; types? But that would violate the &quot;don&#8217;t break existing 32-bit code&quot; rule.  Consider:</p>
<p>struct something {<br />
<br /> INT a;<br />
<br /> LONG b;<br />
<br />};</p>
<p>becomes</p>
<p>struct something {<br />
<br /> INT32 a;<br />
<br /> INT32 b;<br />
<br />};</p>
<p>Great, the underlying type of &quot;b&quot; changed from &quot;signed long&quot; to &quot;signed int&quot; -&gt; build breaks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251063">
				<div id="div-comment-251063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.highprogrammer.com/alan/' rel='external nofollow' class='url'>Alan De Smet</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251063">
			January 31, 2005 at 1:36 pm</a>		</div>

		<p>For better or worse, I worked on a product that passed a HANDLE across processes.  Specifically, we wanted to seperate a web browser plugin implementation into its own process for stability reasons.  (Said plugin used OpenGL.  At the time hardware acceleration could be a bit sketchy, driver problems were all too common.)  So we (from memory) sprintfed the HANDLE for the plugin&#8217;s window into a &quot;%d&quot; and passed it into the child process on the command line.  Said plugin was cross platform, a similar trick was done on Linux/X-Windows.  I&#8217;m fuzzy on how the MacOS9 version did it.  The entire thing seemed overly clever to me, but it worked like a charm.</p>
<p>This got me thinking.  My understanding is that a HANDLE is (handwave) a void pointer.  So quietly turning into a 64-bit pointer could cause problems; I suppose it depends on our code&#8217;s ability to write a 64-bit integer and read it back.</p>
<p>Of course, in this particular case it&#8217;s moot; the company went under and the code is basically dead.  It will almost certainly never be compiled into a 64-bit binary, so things should keep Just Working. (crosses fingers)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251073">
				<div id="div-comment-251073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251073">
			January 31, 2005 at 1:44 pm</a>		</div>

		<blockquote><p>
  &gt;&gt; The reason for DWORD_PTR is so that on 32-bit systems it stays DWORD. Does C99 have a &quot;pointer that is the same size as an integer&quot; type? </p>
<p>Yes, but on 64-bit systems DWORD_PTR would be misleading. Why do I need &quot;pointer that is same in size as integer&quot; type in a first place?</p>
<p>&gt;&gt;&gt; I guess I don&#8217;t understand what your proposed &quot;DDWORD&quot; type would be used for, different from the existing UINT64 type. </p>
<p>No difference, DDWORD/QWORD/UINT64 that&#8217;s all the same, but the point is which one should be used &#8211; INT/LONG or WORD/DWORD/QWORD/WHATEVER128 in structures like bitmap headers, etc.</p>
<p>As for the DCOM issues, why not simply create a 32bit stub for 64-bit platforms and a &quot;native&quot; 64-bit implementation?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251083">
				<div id="div-comment-251083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251083">
			January 31, 2005 at 1:47 pm</a>		</div>

		<p>&quot;Why do I need &#8216;pointer that is same in size as integer&#8217; type in the first place?&quot; -&gt; Look through your Platform SDK header files and you&#8217;ll see plenty of reasons.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251093">
				<div id="div-comment-251093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251093">
			January 31, 2005 at 2:26 pm</a>		</div>

		<p>Frankly, not breaking existing source code seems like a pretty pathetic goal, seeing as how it&#8217;s pretty much doomed to failure anyway. Having to go in and cut/paste some types or even just typedef for compatibility wouldn&#8217;t take anyone very much time. It&#8217;s not like any sane person would expect they could reduce their testing requirements because &quot;it just compiled&quot; anyway, right? </p>
<p>The most egregious example of this I can think of is the system32 directory. </p>
<p>While it won&#8217;t break existing code (mostly), we&#8217;re going to end up being saddled with 64-bit DLLs being in System32, and 32-bit DLLs being in WOW64 for a very, very long time (there&#8217;s only one more doubling of bit-size needed before we can individually label every subatomic particle in the universe)&#8230;</p>
<p>Ok, some bad programmers would have had to have changed 1 constant somewhere in their code to fix this. Was it worth it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251123">
				<div id="div-comment-251123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251123">
			January 31, 2005 at 3:04 pm</a>		</div>

		<p>Ray,<br />
<br />  I love this.  Up until today, all the arguments on Raymond&#8217;s blog were all about how it was stupid for Microsoft to jump through hoops to make existing binary applications to work.</p>
<p>The argument usually went &quot;Why don&#8217;t we just force the developers to recompile their stupid broken applications and ship a new one?&quot;.</p>
<p>Now that the issue is not revising source definitions in the header files, the claim is that we should stop those apps that used these types from compiling.</p>
<p>Ah, the irony.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251143">
				<div id="div-comment-251143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251143">
			January 31, 2005 at 3:30 pm</a>		</div>

		<p>Suppose you installed the latest header files and nothing compiled any more. Even code that was previously perfectly legal. (In other words, you&#8217;re innocent!) But now you have to go and upgrade to Win64 every window procedure, every call to SetTimer, every WM_NOTIFY handler, every owner-drawn listbox and menu&#8230; even though your program has no intention of being a 64-bit program.</p>
<p>How would you react? Would you say, &quot;Thanks, Microsoft! After four days of effort, I&#8217;m finally back to where I was with preceptible benefit to me! Too bad I can&#8217;t use MFC&#8217;s class builder any more &#8211; it spits out code that doesn&#8217;t compile any more. And the code samples in all the magazines I own and web pages I visit don&#8217;t work any more, including this function I just copied from a magazine without really understanding how it works but it sure does the job&#8230;&quot;</p>
<p>Or would you say, &quot;Heck, for all this effort I could&#8217;ve ported it to OS/2.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251173">
				<div id="div-comment-251173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://reduction.blogspot.com' rel='external nofollow' class='url'>pete diemert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251173">
			January 31, 2005 at 4:12 pm</a>		</div>

		<p>Here, here!  Hat&#8217;s off to Ray and Larry for weathering the storm!  Just wanted to toss in some quick kudos to the MS folks who have worked VERY hard over several Windows releases to keep our favorite apps up and going.  In an earlier comment a disgruntled developer asked why would MS make this decision about LLP64 by answering:</p>
<p>&quot;To create gratuitous incompatibility with Unix&quot;</p>
<p>I will gratuitously suggest that if by this comment he means preserving combatibility with legacy apps between Window&#8217;s releases then I give a resounding three cheers to people like Ray who help keep the wheels in motion with this little &quot;incompatibility&quot;.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251193">
				<div id="div-comment-251193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251193">
			January 31, 2005 at 4:36 pm</a>		</div>

		<p>Well, what about this:</p>
<p>SomeStringFn(LPTSTR) turns to<br />
<br />SomeStringFnA(LPSTR) and<br />
<br />SomeStringFnW(LPWSTR)</p>
<p>So why not<br />
<br />SomeIntegerFn(UINT) to become<br />
<br />SomeIntegerFn32(UINT32) and<br />
<br />SomeIntegerFn64(UINT64)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251203">
				<div id="div-comment-251203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251203">
			January 31, 2005 at 4:37 pm</a>		</div>

		<p>P.S. &#8211; same to be applied to structures, etc</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251233">
				<div id="div-comment-251233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251233">
			January 31, 2005 at 4:52 pm</a>		</div>

		<p>Raymond: C99 specifies intptr_t and uintptr_t as optional type aliases for signed and unsigned integer types large enough to hold a pointer. (They are optional because there may not be large enough integer types.) Even VC++ has definitions for them now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251243">
				<div id="div-comment-251243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.foxyshadis.com' rel='external nofollow' class='url'>foxyshadis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251243">
			January 31, 2005 at 4:55 pm</a>		</div>

		<p>API/header bloat, probably. A few entries back Raymond mentioned a similar scenario, and the test matrix nightmare that would ensue. (That was for adding a flag, but same diff.) Not to mention the age-old documentation question &#8211; when do you use 32, when do you use 64, when do you use generic &quot;I don&#8217;t care&quot; for best portability?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251273">
				<div id="div-comment-251273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.tringali.org' rel='external nofollow' class='url'>Scott Tringali</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251273">
			January 31, 2005 at 5:31 pm</a>		</div>

		<p>I can believe the application problems.  How come, then doesn&#8217;t Windows make LONG a typedef to int, and allow the (naked) long be 64 bit? </p>
<p>Is it because changing both LONG and long to 64 bits would break tons of stuff; while changing LONG to 32 bits (say typedef to int) and then making long 64 bits while break somewhat less, but still plenty, of stuff?</p>
<p>Unix programmers can&#8217;t can&#8217;t assume sizeof(long) == size(int) for a very uh, long, time now.  Otherwise nothing will compile on many interesting platforms.  With Linux these days, and other Unixes quickly dying out, that might not be the case for long, though&#8230;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251283">
				<div id="div-comment-251283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251283">
			January 31, 2005 at 5:40 pm</a>		</div>

		<p>Hi, I was the baligerant poster who originally made the comment about type widths staying the same.</p>
<p>Since I&#8217;m porting alot of the MFC defs to a new linux lib I&#8217;m spearheading from windef.h, I&#8217;m pretty familiar with the various millions of types declared in that lovely document.</p>
<p>&lt;quote&gt;Notice that in these inter-process communication scenarios, we don&#8217;t have to worry as much about the effect of a changed pointer size. Nobody in their right mind would transfer a pointer across processes: Separate address spaces mean that the pointer value is useless in any process other than the one that generated it, so why share it?&lt;/quote&gt;</p>
<p>GlobalAlloc(), Mapped Files, ATOM&#8217;s across instances, Named Pipes, ect&#8230; </p>
<p>IPC with memory handles wasn&#8217;t uncommon in my now defunct windows programming style. Of course I would pass handles for API, and not the actual paged addresses, because of protected mode annoyances like page protection ect&#8230;.</p>
<p>Also I don&#8217;t even know if a paged address from one process would even be the same address for another process because of the context switching in the kernel ect&#8230;, and the restoring of the registers from the different process&#8217;s ldt in GDT. I&#8217;m pretty sure the addresses are absolute as 32 bit in the virtual paged addy table, but who really knows, maybe there was some effect from process&#8217;s registers when they are restored to execute the slice.</p>
<p>Who the heck knows, and nobody will ever know because windows is closed source. I am happy because now I can flip open the kernel source and voyeuristically peer in to my hearts content. I even have handbook guides to help me along. Thanks Linus, you da man.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251293">
				<div id="div-comment-251293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251293">
			January 31, 2005 at 5:49 pm</a>		</div>

		<p>&quot;I don&#8217;t even know if a paged address from one process would even be the same address for another process because of the context switching in the kernel etc&quot; -&gt; ?? Processes have separate address spaces. An address in one process is meaningless in any other process. So asking whether it&#8217;s the &quot;same&quot; is like asking if my phone has the same telephone number in a different area code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251303">
				<div id="div-comment-251303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251303">
			January 31, 2005 at 5:50 pm</a>		</div>

		<p>Raymond, it seems we&#8217;re talking about different things. Yes, so called LLP64 will perfectly preserve the structures, but my point is that structures should be updated in a manner that they won&#8217;t depend on INT/LONG size, such preservation will not be an issue anymore. Anyhow, this is plain theory, since due to backward compatibility reasons we&#8217;ll stuck in 32-bit world forever, due to mixing fixed with nonfixed datatypes, like HIWORD(lParam). </p>
<p>Presumably, WinFX will be free from these issues, but all the problems you mentioned in your first post will remain &#8211; how application written in WIN32 and WINFX will share memory, etc&#8230;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251333">
				<div id="div-comment-251333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251333">
			January 31, 2005 at 6:03 pm</a>		</div>

		<p>&quot;structures should be updated in a manner that they won&#8217;t depend on INT/LONG size&quot; -&gt; The cost here is that by changing every structure in the system from &quot;LONG&quot; to &quot;int32_t&quot;, you break existing perfectly legal code. Do this too much and people say, &quot;Obviously Microsoft has an ulterior motive in making widespread breaking changes to Win32 and forcing people to rewrite their Win32 code &#8211; they are intentionally making Win32 programming so difficult that people will give up and switch to WinFX.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-250893">
				<div id="div-comment-250893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-250893">
			January 31, 2005 at 10:23 am</a>		</div>

		<p>I wouldn&#8217;t call them &quot;bad&quot; design choices. Who could have predicted that in the next 15 years that the system you were designing would have to *remain source code compatible* with a processor with four times the register size? (OS/2 was the operating system &quot;for the ages&quot;; Windows was just a toy.)</p>
<p>Brian Friesen: The _PTR suffix means that the integer has the same size as a native pointer. I.e., sizeof(X_PTR) == sizeof(void*). It&#8217;s explained in MSDN. <a target="_new" href="http://msdn.microsoft.com/library/en-us/win64/win64/the_new_data_types.asp" rel="nofollow">http://msdn.microsoft.com/library/en-us/win64/win64/the_new_data_types.asp</a></p>
<p>(The SDK can&#8217;t define new types beginning with __; those are reserved by the C and C++ language standards.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251343">
				<div id="div-comment-251343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251343">
			January 31, 2005 at 6:38 pm</a>		</div>

		<p>The cost here is that by changing every structure in the system from &quot;LONG&quot; to &quot;int32_t&quot;, you break existing perfectly legal code.</p>
<p>Legal in which context, LONG doesn&#8217;t exist in C++ or C, none of the typedefs in windef.h exist in the standards. So really when you use these types in the first place, which is accepted as the norm in windows programming, you are asking for it not to be portable.</p>
<p>If you really wanted to match windows types for portability, could you just doctor windef.h and that would be the end of it?</p>
<p>All those types are a bunch of fooey anyway. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251353">
				<div id="div-comment-251353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251353">
			January 31, 2005 at 6:42 pm</a>		</div>

		<p>By &quot;perfectly legal code&quot; I meant of course &quot;perfectly legal Win32 code.&quot;</p>
<p>Look at the &quot;struct something&quot; example from earlier today. No matter how you define &quot;int32_t&quot;, you will break either &quot;a&quot; or &quot;b&quot;, because one of them is derived from &quot;int&quot; and the other is derived from &quot;long&quot;. Whichever one you pick for &quot;int32_t&quot; you will break the other.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251363">
				<div id="div-comment-251363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251363">
			January 31, 2005 at 7:13 pm</a>		</div>

		<p>&lt;quote&gt;Look at the &quot;struct something&quot; example from earlier today. No matter how you define &quot;int32_t&quot;, you will break either &quot;a&quot; or &quot;b&quot;, because one of them is derived from &quot;int&quot; and the other is derived from &quot;long&quot;. Whichever one you pick for &quot;int32_t&quot; you will break the other.&lt;/quote&gt;</p>
<p>But how could picking one ever break the other for legacy code?</p>
<p>legacy Win32 code will always have LONG as typedef&#8217;d from long in winnt.h, so in the 32 bit VC compiler context, that&#8217;s always a 32 bit value.</p>
<p>Having LONG be 32 bits in a 64 bit compiler context where the &quot;long&quot; compiler type is possibly 64 bits wide, is certainly a little confusing, but at least it wouldn&#8217;t break anything. I think that&#8217;s what you guys ended up doing from reading the first post on this blog here. Just keeping the original windef.h and winnt.h widths.</p>
<p>so<br />
<br />typedef int INT<br />
<br />typedef INT LONG</p>
<p>Another thing you could do from the compiler perspective is make 32 bit and 64 bit pragma blocks where the actual &quot;long&quot; C type is 32 bits in the 32bit pragma block, and 64 bit in the 64 bit pragma block, like it is in java, with 32 bit ints and 64 bit longs.</p>
<p>#pragma <strong>win32</strong></p>
<p>// BLOCK</p>
<p>#pragma <strong>win64</strong></p>
<p>like that. I&#8217;m guessing you guys already built that into the preprocessor and compiler.</p>
<p>You could actually just have the preprocessor go through and just macro change &quot;long&quot; to &quot;int&quot; in the <strong>win32</strong> code blocks within that pragma directive, so it wouldn&#8217;t even require a compiler change persay.</p>
<p>At any rate, with the GNU tools you&#8217;re responsible for making your own abstract types of any kind, so ultimately you, yourself have to change them. This is my situation now, so I&#8217;m focusing on that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251373">
				<div id="div-comment-251373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251373">
			January 31, 2005 at 7:16 pm</a>		</div>

		<p>&lt;quote&gt;legacy Win32 code will always have LONG as typedef&#8217;d from long in winnt.h, so in the 32 bit VC compiler context, that&#8217;s always a 32 bit value. &lt;/quote&gt;</p>
<p>I mean that for a 32 bit C++ compiler. It could be different for a 64 bit compiler, in which case you could do pp replacements before you start lexing/parsing/compiling the code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251383">
				<div id="div-comment-251383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251383">
			January 31, 2005 at 7:24 pm</a>		</div>

		<p>actually, if the pp went through and macro replaced all the LONG, ULONG, to INT, UINT and long to int, all the 32 bit code blocks would work fine, </p>
<p>then when you would call a function from a 64 bit block with a LONG return type, it would be a type mismatch.</p>
<p>So ultimately the compiler would have to be involved, smart converting types between 32 and 64 bit blocks.</p>
<p>That&#8217;s why they pay you guys the big bucks though right!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251393">
				<div id="div-comment-251393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251393">
			January 31, 2005 at 7:36 pm</a>		</div>

		<p>from 64 bit block functions with 64 bit wide return types to 32 bit pragma blocks calling, have the compiler issue data loss warnings for 32 bit cut offs.</p>
<p>If people ignore them at least you tried. Other than that I think it would be ok.</p>
<p>If they really want the whole 64 bits, they move the func out of the 32 bit block into the 64 bit.</p>
<p>For those that don&#8217;t need the extra width, they can keep coding as usual with the <strong>win32</strong> block pragma&#8217;s and pretend AMD64 was never released.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251213">
				<div id="div-comment-251213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://dotnetjunkies.com/WebLog/paul/archive/2005/01/31/49485.aspx' rel='external nofollow' class='url'>Paul Mooney</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251213">
			January 31, 2005 at 7:46 pm</a>		</div>

		<p>A blog reaction</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251403">
				<div id="div-comment-251403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251403">
			January 31, 2005 at 7:59 pm</a>		</div>

		<p>If you want LONG to be a 64-bit integer when compiler on a 64-bit machine, then you have to figure out how to change the definition of &quot;struct something&quot; so that the following legal Win32 code compiles cleanly and operates identically both as 32-bit and as 64-bit:</p>
<p>something s;<br />
<br />fread(fp, &amp;s, sizeof(s));<br />
<br />int i = s.a;<br />
<br />long l = s.b;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251413">
				<div id="div-comment-251413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251413">
			January 31, 2005 at 8:26 pm</a>		</div>

		<p>I see, I was thinking 32 and 64 bit versions of the API as well in which ever block. 32bit pragma block retains the 32 bit versions of stdlib.h or cstdlib and the rest of the API outside the standard libraries.</p>
<p>I realize that would be next to impossible for you to accomplish though.</p>
<p>If you&#8217;re going to use the same system dll API for both the 32 and 64 bit blocks it wouldn&#8217;t work.</p>
<p>I&#8217;m going to see how GNU handled this. I don&#8217;t have a 64 bit chip so I haven&#8217;t been interested but I bet they came up with a crafty solution.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251423">
				<div id="div-comment-251423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beer29</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251423">
			January 31, 2005 at 8:39 pm</a>		</div>

		<p><a target="_new" href="http://64.233.161.104/search?q=cache:X6vyrlUbMJkJ:gcc.fyxm.net/summit/2003/Porting%2520to%252064%2520bit.pdf+x86_64+gcc+64+bit+long+types&amp;hl=en" rel="nofollow">http://64.233.161.104/search?q=cache:X6vyrlUbMJkJ:gcc.fyxm.net/summit/2003/Porting%2520to%252064%2520bit.pdf+x86_64+gcc+64+bit+long+types&#038;hl=en</a></p>
<p>&lt;quote&gt;4.2.1 int vs. long<br />
<br />Since the sizes of int and long are the same on a 32-bit platforms, programmers have of-ten been lazy and used int and long inter-changeably. But this will not work anymore with 64-bit systems where long has a larger size than int.</p>
<p>Due to its size a pointer does not fit into a variable of type int. It fits on Unix into a long variable but the intptr_t type from ISO C99 is the better choice.&lt;/quote&gt;</p>
<p>Well, I guess this will kind of suck at first, but amd64 does have 32 bit compatibility mode, and it&#8217;s better to stick to standards. I think they did the right thing.</p>
<p>Not having all those typedefs to same width types in winnt.h and windef.h probably are going to help gcc/g++&#8217;s case along when it comes to this switch.</p>
<p>It&#8217;s been this way with java since the jdk1.1, so it&#8217;s not a new concept.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251013">
				<div id="div-comment-251013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251013">
			January 31, 2005 at 12:44 pm</a>		</div>

		<p>RPC/DCOM do use an architecture-independent format.</p>
<p>One of the goals of the Win64 design is *not to break existing 32-bit code*. If structures changed from, say, LONG to int32_t, you would have build breaks like</p>
<p>error: assigning signed long to signed int.</p>
<p>on compilers that are strict about int/long separation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251313">
				<div id="div-comment-251313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.cdpa.nsysu.edu.tw/zmx/archives/001074.html' rel='external nofollow' class='url'>zmx's Weblog/鍾明勳的部落格</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251313">
			January 31, 2005 at 8:52 pm</a>		</div>

		<p>LP64 v.s. LLP64 (aka Unix64 v.s. Win64) <a href="http://www.unix.org/version2/whatsnew/lp64_wp.html" rel="nofollow">http://www.unix.org/version2/whatsnew/lp64_wp.html</a> Getting Ready for 64-bit Windows Why did the Win64 team choose the LLP64 model?&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251043">
				<div id="div-comment-251043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251043">
			January 31, 2005 at 1:02 pm</a>		</div>

		<p>&quot;RPC/DCOM do use an architecture-independent format.&quot;</p>
<p>So why would changing the sizes of the data types in the OS affect these protocols?  i.e. i don&#8217;t think this is a valid argument.</p>
<p>&quot;One of the goals of the Win64 design is *not to break existing 32-bit code*.&quot;</p>
<p>Given this, i can certainly see why they made the decision they did, then.  Can someone clear something up for me &#8211; are talking about the 64bit version of XP, or are we talking about Longhorn?  (RTFA, or find one, is a valid answer!)</p>
<p>If Longhorn, then I was under the impression that apps had to be recompiled for this new OS anyway.  Please correct me if I&#8217;m wrong.</p>
<p>Finally, one last q.  Given Raymond&#8217;s answers, why couldn&#8217;t they have gone the route of a new set of data types.  You went from WORD to DWORD.  Why not DDWORD, etc.?  Adding new types would not break any existing code at all.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251053">
				<div id="div-comment-251053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251053">
			January 31, 2005 at 1:10 pm</a>		</div>

		<p>I&#8217;m not talking about wire formats. I&#8217;m talking about structures in header files.</p>
<p>And I&#8217;m talking about 64-bit Windows in general, not tied to a specific release &#8211; Windows XP 64-bit, Windows Server 2003 64-bit, etc.</p>
<p>I don&#8217;t see how inventing a new data type helps you fix existing structures. You can&#8217;t touch them carelessly without breaking source code compatibility.</p>
<p>Besides, there *are* new types, like the INT{8,16,32,64} mentioned above. So I&#8217;m not sure why you&#8217;re saying the Win64 designers should have invented something that they already invented.</p>
<p>I guess I don&#8217;t understand what your proposed &quot;DDWORD&quot; type would be used for, different from the existing UINT64 type.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251103">
				<div id="div-comment-251103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251103">
			January 31, 2005 at 2:31 pm</a>		</div>

		<p>Now that I think of it, why didn&#8217;t MS just add a &quot;WIN32_COMPATIBLE&quot; flag to the compiler that kept all the sizes the same while by default letting the types sizes float to ones that make more sense in the processor architecture?</p>
<p>Surely the effort of typing 24 characters wouldn&#8217;t be too much to ask *even* of people too lazy to have programmed their code correctly in the first place&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251113">
				<div id="div-comment-251113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251113">
			January 31, 2005 at 2:54 pm</a>		</div>

		<p>Okay, consider: You download the latest Platform SDK, recompile your program, and you get all these errors. Is your reaction: </p>
<p>(a) Gosh, I&#8217;d better go through and modify my 50,000-line program to work with these new 64-bit compatible structures. </p>
<p>(b) !@#$!! Microsoft, why do they go around breaking perfectly good code? I&#8217;m not going to port to 64-bit Windows any time soon, why do I have to go through and modify my 50,000-line program to be compatible with something I don&#8217;t care about? </p>
<p>&quot;Why not a WIN32_COMPATIBLE compiler flag?&quot; -&gt; You might have a different opinion of this approach after you spend four days tracking down a problem caused by somebody #define&#8217;ing this flag in one header file (but not another), causing two structure definitions to mismatch.</p>
<p>The Win64 team went through multiple proposals before settling on the one they chose. I experienced the pain of previous attempts that tried some of the things people have been suggesting. It was not fun. &quot;Hey, I&#8217;m making a checkin to winbase.h that *prevents all of Windows from compiling*.&quot; You don&#8217;t make friends that way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251133">
				<div id="div-comment-251133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251133">
			January 31, 2005 at 3:19 pm</a>		</div>

		<p>Ummm, actually, that argument always was BS. The reason not to break binaries is that you&#8217;re hurting the wrong people. You&#8217;re hurting end users that weren&#8217;t to blame for the poorly written code in the first place. Not only does this win you no customers, it punishes the innocent. </p>
<p>Breaking the compile punishes the guilty. Hopefully enough that they get out of the business. Darwin is way too dead in the modern world as it is. </p>
<p>I wonder, though, about this decision regarding System32&#8230; who exactly was that supposed to protect, and from what? It&#8217;s *more* likely to break binaries (of apps that made some path assumptions that are now broken), but *less* likely to break recompiles&#8230; </p>
<p>Does this have anything to do with Steve tromping around yelling &quot;DEVELOPERS!&quot;? :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251153">
				<div id="div-comment-251153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Blekhman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251153">
			January 31, 2005 at 3:38 pm</a>		</div>

		<p>&quot;Ah, the irony.&quot;</p>
<p>Actually, the whole irony is that DWORD was broken from the beginning for 32-bit architecture. It&#8217;s that since DWORD macro is just leftover of 16-bit world where DWORD had (just for once) its true meaning: doubled processor word, i.e. 32 bits. Processor&#8217;s word under IA32 has 32 bits, so DWORD should be 64 bits. Sad story about WPARAM and LPARAM is the first thing that beginner learns from Petzold&#8217;s book and PSDK documentation.</p>
<p>As a matter of fact, I have great admiration for MS developers, which succeeded to maintain backward compatibility for code that can be 15 years old. And still, if written carefully, it will compile and *work* flawlessly today. It suggests highest rank of professionalism among these developers. I just take my hat off to you, guys.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251433">
				<div id="div-comment-251433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251433">
			January 31, 2005 at 11:54 pm</a>		</div>

		<p>&quot;Ben: yes, Windows only ever ran on little-endian architectures. There&#8217;s very little places concerned with endianness in Win32, and they&#8217;re all #ifdef _MAC (i.e. the Win32 port to MacOS for Office and Internet Explorer)&quot;</p>
<p>Wasn&#8217;t IE-Mac a completely different codebase/engine than IE/Win32 ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251443">
				<div id="div-comment-251443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bobsmith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251443">
			February 1, 2005 at 12:27 am</a>		</div>

		<p>What about creating new header files that fix the mistakes made when the current ones were made? A winbase_new.h would allow for new projects to use fixed headers while older projects can use winbase.h until someone decides to update them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251223">
				<div id="div-comment-251223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251223">
			January 31, 2005 at 4:46 pm</a>		</div>

		<p>Creating two versions of the structure completely misses the point.  The whole point of the exercise is to ensure that structures *stay the same* between 32-bit and 64-bit. Otherwise 64-bit code wouldn&#8217;t be able to read BMP files created by a 32-bit program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251253">
				<div id="div-comment-251253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brent Dax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251253">
			January 31, 2005 at 5:02 pm</a>		</div>

		<p>&quot;Are you saying that existing structures should be retrofitted to use the INT&lt;n&gt; types?&quot;</p>
<p>No, I&#8217;m saying that the designers of Win32 should have anticipated that one day there might be 64-bit architectures that people would want to run Windows on, and designed the type system with room to expand without massive code breakage.  Especially since they were in the middle of a 16-to-32-bit change!</p>
<p>If WinFX is a complete replacement for Win32 (I&#8217;m a little fuzzy on this), I hope it *is* being designed this way, with separate &quot;{small,medium,large} integer&quot; and &quot;{16,32,64}-bit integer&quot; types.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251263">
				<div id="div-comment-251263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251263">
			January 31, 2005 at 5:06 pm</a>		</div>

		<p>Alex Blekhman wrote:<br />
<br />&quot;Actually, the whole irony is that DWORD was broken from the beginning for 32-bit architecture. It&#8217;s that since DWORD macro is just leftover of 16-bit world where DWORD had (just for once) its true meaning: doubled processor word, i.e. 32 bits. Processor&#8217;s word under IA32 has 32 bits, so DWORD should be 64 bits. Sad story about WPARAM and LPARAM is the first thing that beginner learns from Petzold&#8217;s book and PSDK documentation&quot;</p>
<p>Hmmm&#8230; are you sure about this?</p>
<p>I always heard it like this:</p>
<p>4 bits = nybble<br />
<br />8 bits = 1 byte<br />
<br />2 nybbles = 1 byte<br />
<br />2 bytes = 1 word</p>
<p>&#8230; and the logical extension from there is 2 words = 1 dword, 4 words = 1 qword.</p>
<p>*shrugs* I don&#8217;t recall ever hearing that the length of a word was CPU specific.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251323">
				<div id="div-comment-251323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251323">
			January 31, 2005 at 5:58 pm</a>		</div>

		<p>&gt;&gt;&gt; *shrugs* I don&#8217;t recall ever hearing that the length of a word was CPU specific. </p>
<p>BYTE is always 8 bits<br />
<br />WORD is largest amount of BYTEs CPU can process at once. When first Intel CPUs became popular, WORD was equal to two BYTEs and when CPUs WORD began to grow, WORD remain 2 bytes, for the same reasons we&#8217;re discussing here now &#8211; everybody *knew* that WORD is two BYTEs and changing that would broke too many things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251483">
				<div id="div-comment-251483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251483">
			February 1, 2005 at 6:32 am</a>		</div>

		<p>KJK::Hyperion wrote: Windows only ever ran on little-endian architectures. There&#8217;s very little places concerned with endianness in Win32, and they&#8217;re all #ifdef _MAC</p>
<p>Did I hear wrong about the X-Box Next running on a PowerPC in big-endian mode, then?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251633">
				<div id="div-comment-251633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251633">
			February 1, 2005 at 8:48 am</a>		</div>

		<p>So what&#8217;s the type of size_t and ptrdiff_t when compiling 64-bit?  These have to be (at least) 64-bit quantities.  If long and unsigned long&#8211;the largest integral types defined by the C standard&#8211;aren&#8217;t big enough for these quantities, how can they be defined in a standard and useful manner?  What will happen when you use sizeof (which is a size_t by definition)?</p>
<p>Raymond wrote:  &quot;Note however that converting a program from Win16 to Win32 typically resulted in two unrelated codebases (or a single file with a LOT of #ifdef&#8217;s) because the Win16-&gt;Win32 shift was so huge.&quot;</p>
<p>I disagree.  Win16-&gt;Win32 was painful only if you had sloppy Win16 code.  Message packer/cracker macros handled the different packing schemes for the parameters.  Quicken had simultaneous 16- and 32-bit versions from the same source with minimal #ifdefs (and no Win32s).  In fact, for a while we built 16-bit with Borland and 32-bit with Microsoft compilers.</p>
<p>How big are HANDLEs (kernel and GDI) and WPARAMs in Win64?  When compiling with STRICT, GDI HANDLEs are defined as pointers to different types so that the compiler can do stricter type checking.  To do that in Win64, then HANDLEs would have to be 64-bits, like a pointer.  Both WPARAM and LPARAM have to hold HANDLEs from time to time as do LRESULTs, so are they all 64-bit?</p>
<p>I never understood why the SDK came up with VOID, CHAR, LONG, etc.  Why not use the standard keywords if the underlying types could never be changed?  I agree with the early commentor.  Size-specified types should be used for persistent formats and &quot;on the wire&quot;, but everything else should use the size-neutral types.</p>
<p>A byte is not 8 bits.  A byte is the size of the smallest directly-addressable unit of memory.  On most modern processors, it happens to be 8 bits.  That&#8217;s why RFCs use the term octet to be unambiguous and TeX can be compiled on machines that have bytes as small as 6 bits.</p>
<p>A word is not 16 bits.  A word is the natural size of the processor&#8217;s arithmetic unit.  If you&#8217;re a C programmer, this is an int.  Typically this was also the size of an address, but that seems to be changing as we move to 64-bit machines.  On current processors, a word is typically 32-bits, but the term has been abused to the point that it&#8217;s now ambiguous.</p>
<p>DWORD, as far as I can tell, was coined by Microsoft to mean a double word.  But it stuck at 32 bits, since words were 16 bits when the term was introduced.</p>
<p>A quadword is four words.  On a 32-bit machine, this should mean 128 bits, not 64.  If my memory is correct, VAX/VMS got this right.  I wonder what it was on Alpha/VMS.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251653">
				<div id="div-comment-251653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251653">
			February 1, 2005 at 9:00 am</a>		</div>

		<p>I don&#8217;t know who invented DWORD, but Windows got it from Intel assembly language.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251453">
				<div id="div-comment-251453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://Words,words..' rel='external nofollow' class='url'>Alex Blekhman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251453">
			February 1, 2005 at 1:25 am</a>		</div>

		<p>Simon Cooke [exMSFT] wrote:<br />
<br />&quot;*shrugs* I don&#8217;t recall ever hearing that the length of a word was CPU specific.&quot;</p>
<p>Yes, it&#8217;s very common to think that word related rather to number of bytes than to architecture. It comes as surprise to a lot of people. Actually, the more correct term is &quot;machine word&quot;, since the size of word determined both by CPU and data bus. Strict definition is: size of machine word is equal to amount of bits that machine can operate on as unit. Usually hardware designers tend to make well balanced systems, so they make data bus wide enough to operate on CPU register at once. Therefore, most of the time machine word is equal to CPU register. Here&#8217;s additional info: &quot;Understanding Intel Instruction Sizes&quot; (<a target="_new" href="http://www.swansontec.com/sintel.htm" rel="nofollow">http://www.swansontec.com/sintel.htm</a>). </p>
<p>As Waleri already explained it (<a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#364195" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#364195</a>), success of PC (which was 16-bit then) was so tremendous that terms of that era became engraved in people&#8217;s memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251493">
				<div id="div-comment-251493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/larryosterman/archive/0001/01/01/363881.aspx' rel='external nofollow' class='url'>Larry Osterman's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251493">
			February 1, 2005 at 9:42 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251463">
				<div id="div-comment-251463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251463">
			February 1, 2005 at 1:47 am</a>		</div>

		<p>&lt;Quote&gt;<br />
<br />structures should be updated in a manner that they won&#8217;t depend on INT/LONG size&quot; -&gt; The cost here is that by changing every structure in the system from &quot;LONG&quot; to &quot;int32_t&quot;, you break existing perfectly legal code.<br />
<br />&lt;/Quote&gt;</p>
<p>Yes, but that will occure *only* when one recompile with WIN64 as a target. If the compiler have a switch for both WIN32/WIN64 as a target, it would be up to the developer to decide whether to compile with new settings and face the consequences or not.</p>
<p>&lt;Quote&gt;<br />
<br />something s;<br />
<br />fread(fp, &amp;s, sizeof(s));<br />
<br />int i = s.a;<br />
<br />long l = s.b;<br />
<br />&lt;/Quote&gt;</p>
<p>Good example of a bad code. Aside of sizeof(s) vs. 4 problem, there are also problems with little endian/big endian of the variables. </p>
<p>Many years ago, part of the Microsoft C 6.0 or was it 7.0 documentation was a little book how to write application in a WIN32 ready manner. I think all these issues were covered there. I think it is time to reprint this manual for WIN64&#8230; well, maybe it is a little too late :) Even today, compiler have a switch to warn about W64 portability problems &#8211; I just wonder how many ppl here use it (I don&#8217;t :)</p>
<p>My point is, that years ago, when the dilemma was whether INT should be 16 or 32, the decision was to made it 32, so why choice now?</p>
<p>It seems that ppl never learn from their mistakes. We had 16 vs 32 now we had 32 vs 64.. soon we&#8217;ll run to 64 vs 128.. or I guess it will be 32 vs 128&#8230; We had Y2K problem, in couple decades we&#8217;ll run into time_t problem (somewhere around the yeaar 2038). I understand nobody&#8217;s perfect. No one can predict everything, but now we talk about problems we already encountered before and instead solve them, we didn&#8217;t solve them even now. Instead we try to find a workaround and postpone the problem</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251473">
				<div id="div-comment-251473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251473">
			February 1, 2005 at 6:32 am</a>		</div>

		<p>Wow, so many misconceptions I hardly know where to begin.</p>
<p>Raymond wrote: The SDK can&#8217;t define new types beginning with __; those are reserved by the C and C++ language standards.</p>
<p>They&#8217;re reserved to the implementation, which MS dictates at least part of (for instance, the sizes of fundamental types).  Don&#8217;t tell me the Platform SDK people have suddenly developed a concern for namespace pollution after years of wantonly defining macros with no prefixes.</p>
<p>Raymond wrote:<br />
<br />If structures changed from, say, LONG to int32_t, you would have build breaks like<br />
<br />error: assigning signed long to signed int.<br />
<br />on compilers that are strict about int/long separation.</p>
<p>Such compilers are, so far as I&#8217;m aware, a figment of your imagination.  Such conversions are entirely legal.  Conversion of pointer types (long * to int *) is a different matter, admittedly.</p>
<p>Simon Cooke wrote: *shrugs* I don&#8217;t recall ever hearing that the length of a word was CPU specific. </p>
<p>I think I&#8217;m going to add this to my random signature collection.</p>
<p>Waleri: BYTE is always 8 bits.</p>
<p>A byte was originally the unit of storage used for character codes.  As such it has varied between about 6 and 12 bits on different systems; in fact the PDP-10 allowed software to determine the size of a byte.  C and C++ require at least 8-bit bytes, however, and 8 bits has become the de facto standard &#8211; yet, with the increasing use of Unicode, it is normal to use 16 or 32 bits for a character code.  For precision one should use &quot;octet&quot; to mean a group of 8 bits.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251553">
				<div id="div-comment-251553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251553">
			February 1, 2005 at 7:48 am</a>		</div>

		<p>Note however that converting a program from Win16 to Win32 typically resulted in two unrelated codebases (or a single file with a LOT of #ifdef&#8217;s) because the Win16-&gt;Win32 shift was so huge. </p>
<p>One of the goals of the Win32-&gt;Win64 transition is that you can write a program once, *without any ifdef&#8217;s* (well okay maybe one or two), and have it compile and run as both a Win32 program and a Win64 program. </p>
<p>Another goal was that existing Win32 code should remain valid. (Even if it wasn&#8217;t Win64-compliant, it should still be valid Win32 code.) </p>
<p>How well do these alternate proposals hold up in the face of these two constraints? Just saying, &quot;That&#8217;s bad code&quot; is a cop-out. Whether you like it or not, there&#8217;s a lot of bad code out there. </p>
<p>(I don&#8217;t know what to make of the suggestion that sizeof(LONG) &lt; sizeof(long) on Win64. Surely if the Win64 team came up with such a model you would point to it as proof that Microsoft developers are morons.)</p>
<p>bobsmith: Two versions of the header file with different definitions for types, structures, and functions creates the &quot;incompatible libraries&quot; problem. Suppose you have two code libraries, an older one that uses the old definitions, and a newer one that uses the new definitions. Your program needs to use both libraries. What do you do? Whichever one you pick, you&#8217;ll be incompatible with the other one.</p>
<p>(Ben: __ is reserved for the implementation, and the Platform SDK is not the implementation. It&#8217;s just a header file in the application namespace.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251863">
				<div id="div-comment-251863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">T</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251863">
			February 1, 2005 at 5:33 pm</a>		</div>

		<p>From this<br />
<br /><a target="_new" href="http://www.unix.org/version2/whatsnew/lp64_wp.html" rel="nofollow">http://www.unix.org/version2/whatsnew/lp64_wp.html</a></p>
<p>I get the impression LP64 might be as rational a choice for Unix as LLP64 is for Windows.</p>
<p>I guess it&#8217;s because Unix apis tend to work on the assumption that sizeof(long) &gt;= sizeof(void *). Unix code has to worry about endianess issues, multiple compilers and so on, and is less likely to write C structures to disk with a single fwrite call.</p>
<p>On the other hand in 64 bit Windows with the LLP64  model, code that tries to fit a pointer into an int will break at compile time, which is easy to fix. But there is lots of application code that makes implicit assumptions about types when it writes structures to disk, and if you changed sizeof(int) you&#8217;d break it silently at run time.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251873">
				<div id="div-comment-251873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251873">
			February 1, 2005 at 5:40 pm</a>		</div>

		<p>ok, my last post didn&#8217;t get through.</p>
<p>But thanks for your answers and time Raymond, and everyone else too.  Definitely one of the more interesting posts.  All those for more of the same technical stuff say aye.  Passed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251953">
				<div id="div-comment-251953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251953">
			February 2, 2005 at 12:54 am</a>		</div>

		<p>I guess to avoid similar problems in the future, it would be nice to have a warning in the compiler about assigning nonfixed data type to a fixed one. Warning should be generated even if sizeof(UINT) &gt;= sizeof(UINT32)</p>
<p>UINT src;<br />
<br />UINT32 dst;<br />
<br />dst = src; // Produce a warning</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-251963">
				<div id="div-comment-251963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Martin Liversage</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251963">
			February 2, 2005 at 1:43 am</a>		</div>

		<p>While you are busy porting from Win32 to Win64 please prepare for Win128 to avoid the hazzle next time. ;^)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-251983">
				<div id="div-comment-251983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-251983">
			February 2, 2005 at 3:09 am</a>		</div>

		<p>&quot;DrPizza: One structure down, 20 billion to go. And most of the 20 billion belong to you &#8211; the application progammer &#8211; not to Windows. &quot;<br />
<br />But I only have to care if I recompile in 64-bit.  If I don&#8217;t, the old 32-bit compiled-in sizes are maintained.</p>
<p>And if I&#8217;ve written a program that assumes that longs in structs are a particular size then I&#8217;ve probably also written a program that has other 64-bit portability issues anyway.  Which I&#8217;ve got to fix anyway.</p>
<p>So what&#8217;s the &quot;win&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252003">
				<div id="div-comment-252003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">T</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252003">
			February 2, 2005 at 4:35 am</a>		</div>

		<p>@Adrian</p>
<p> How big are HANDLEs (kernel and GDI) and<br />
<br /> WPARAMs in Win64? </p>
<p>64 bit. Obviously ;-)<br />
<br />I gues on Win128 they&#8217;d be 128bit.</p>
<p> I never understood why the SDK came up with<br />
<br /> VOID, CHAR, LONG, etc. Why not use the<br />
<br /> standard keywords if the underlying types<br />
<br /> could never be changed? </p>
<p>Because the underlying types may change I guess, the typedefs could be altered to remain the same size as the platform and compilers changed.</p>
<p> DWORD, as far as I can tell, was coined by<br />
<br /> Microsoft to mean a double word. </p>
<p>I think DWORD meant a 32 bit integer in Win16, and now it Win64 it still means the same thing. If a API function needs to use DWORD parameters to store pointers, the parameter type changes to DWORD_PTR which will be pointer sized. So rather than criticising them for not breaking third party code, why not praise them for fixing their own APIs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252173">
				<div id="div-comment-252173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252173">
			February 2, 2005 at 8:47 am</a>		</div>

		<p>DrPizza:  Paranoia is a good thing when it comes to changing something that hasn&#8217;t changed in over 20 years. There are millions of lines of code that use, for example, the BITMAPINFOHEADER structure. Can you prove that none of them will break if the &quot;LONG biWidth&quot; changes to &quot;INT32 biWidth&quot;?</p>
<p>I remember seeing a compiler that raised a warning if you did</p>
<p>long l;<br />
<br />int i = l; // warning: nonportable &#8211; potential truncation</p>
<p>If you change LONG to INT32 then code that went</p>
<p>long l;<br />
<br />bmih.biWidth = l; // warning raised here</p>
<p>will not get a warning when they didn&#8217;t before.</p>
<p>I guess we could have invented &quot;LONG32&quot;, which then would create the strange situation that on 64-bit machines, &quot;LONG32&quot; isn&#8217;t a &quot;long&quot;.</p>
<p>Like I said, many possibilities were considered. Perhaps in your opinion we should have taken the greater risk and chosen a model that would have required more work to convert a program to Win64, hoping that people would perceive the extra work as worth the hassle.</p>
<p>Note that it wasn&#8217;t under Windows 95 that people finally perceived the extra work as worth the hassle to port from Win16 to Win32! 64-bit Windows has been available since Windows XP 64-bit Edition &#8211; do you see many people porting to Win64? Shouldn&#8217;t the goal be to make it easier to port to Win64, not harder?</p>
<p>&quot;And if I&#8217;ve written a program that assumes that longs in structs are a particular size then I&#8217;ve probably also written a program that has other 64-bit portability issues anyway. Which I&#8217;ve got to fix anyway.&quot;</p>
<p>But you don&#8217;t have to fix them if you have no intention of porting to Win64. See above.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252323">
				<div id="div-comment-252323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252323">
			February 2, 2005 at 10:40 am</a>		</div>

		<p>&quot;DrPizza: Paranoia is a good thing when it comes to changing something that hasn&#8217;t changed in over 20 years. There are millions of lines of code that use, for example, the BITMAPINFOHEADER structure. Can you prove that none of them will break if the &quot;LONG biWidth&quot; changes to &quot;INT32 biWidth&quot;? &quot;<br />
<br />Er&#8230;  if you&#8217;re not recompiling it doesn&#8217;t matter what the structure changes to, because you&#8217;re not recompiling.  If you are recompiling, then at the absolute worst you&#8217;ll get a compile-time error (because the compiler doesn&#8217;t know what an INT32 is), which you can fix.</p>
<p>&quot;Like I said, many possibilities were considered. Perhaps in your opinion we should have taken the greater risk and chosen a model that would have required more work to convert a program to Win64, hoping that people would perceive the extra work as worth the hassle. &quot;<br />
<br />What greater risk?  The only things that&#8217;ll change are programs rebuilt as 64-bit binaries, and they fall into two categories already:<br />
<br />programs that need fixing to become 64-bit clean (in which case fixing the structure makes their job no harder)<br />
<br />programs that are already 64-bit clean (in which case fixing the structure makes their job no harder)</p>
<p>Except thanks to this decision, there are vanishingly few programs in the latter category.  If LP64 were picked, at least all the cross-platform scientific/maths/etc. programs would be 64-bit clean (or very nearly so).</p>
<p>&quot;64-bit Windows has been available since Windows XP 64-bit Edition &#8211; do you see many people porting to Win64? Shouldn&#8217;t the goal be to make it easier to port to Win64, not harder? &quot;<br />
<br />Maybe if XP 64 were (a) available on something other than Itanium (the x86-64 version still isn&#8217;t out&#8230;) (b) not crippled (as the Itanium version omits lots of features the 32-bit version has (c) useful (as there&#8217;s next to no software that benefits from Itanium or 64-bit that you&#8217;d want to run on WinXP) we&#8217;d see more Win64 uptake.</p>
<p>&quot;But you don&#8217;t have to fix them if you have no intention of porting to Win64. See above. &quot;<br />
<br />But if I&#8217;ve no intention of porting, it doesn&#8217;t matter ANYWAY because the definitions I&#8217;m using will be the same as they always were, because they&#8217;re compiled into the program, which will be running under WoW64.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252333">
				<div id="div-comment-252333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252333">
			February 2, 2005 at 11:00 am</a>		</div>

		<p>&quot;But if I&#8217;ve no intention of porting, it doesn&#8217;t matter ANYWAY because the definitions I&#8217;m using will be the same as they always were&quot;</p>
<p>No, because your proposal changes LONG to INT32. The type changed. You install the latest Platform SDK, recompile your program, and it doesn&#8217;t build any more. Does this make you happy or sad?</p>
<p>&quot;because they&#8217;re compiled into the program&quot; &#8211; and then what happens when you recompile?</p>
<p>Most people expect that installing the latest Platform SDK will not introduce build breaks.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252013">
				<div id="div-comment-252013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ebbe Kristensen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252013">
			February 2, 2005 at 6:00 am</a>		</div>

		<p>Raymond Chen: &quot;If a LONG expanded from a 32-bit value to a 64-bit value, it would not be possible for a 64-bit program to use this structure to parse a bitmap file.&quot;</p>
<p>The *real* problem is that the most commonly used languages for Windows development do not specify the size of numeric types other than a, say, the size of a &#8216;long int&#8217; must be bigger or equal to the size of an &#8216;int&#8217; etc. And that was of course the reason for inventing DWORD etc..</p>
<p>Also, I don&#8217;t understand why it is a problem to define a DWORD to be 32 bits in a 64 bit system?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252503">
				<div id="div-comment-252503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252503">
			February 2, 2005 at 5:55 pm</a>		</div>

		<p>&quot;No, because your proposal changes LONG to INT32.&quot;<br />
<br />No, it changes structure definitions that previously erroneously said &quot;long&quot; to say something else (presumably &quot;int&quot;).</p>
<p>My 32-bit program is unaltered anyway (because it treats long and int equivalently, save for truncation warnings).</p>
<p>My 64-bit program needs careful checking anyway (because I need to make sure I&#8217;m not assuming that integral types are big enough to hold pointer types).</p>
<p>&quot;The type changed. You install the latest Platform SDK, recompile your program, and it doesn&#8217;t build any more. Does this make you happy or sad? &quot;<br />
<br />Huh?  Why would it stop building?</p>
<p>&quot;and then what happens when you recompile? &quot;<br />
<br />As 32-bit?  Nothing.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252513">
				<div id="div-comment-252513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252513">
			February 2, 2005 at 6:02 pm</a>		</div>

		<p>&quot;Why would it stop building?&quot;</p>
<p>Because you changed &quot;long&quot; to &quot;int&quot;. You yourself noted that doing this will raise truncation warnings. And if you compile with &quot;treat warnings as errors&quot; your build is broken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252293">
				<div id="div-comment-252293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kuwanger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252293">
			February 2, 2005 at 10:23 am</a>		</div>

		<p>As far as the whole Win32 and Win64 compatibility goes, what happens if a programmer does this:</p>
<p>int temp_buffer[4];<br />
<br />int *some_int = NULL;</p>
<p>temp_buffer[0] = (int) some_int;</p>
<p>And before you say that&#8217;s crazy, realize that automatic garbage collector libraries that work in C actually do checks on pointers *and* ints because they realize it is a real issue that programmers will put pointers into ints and extract them back out as pointers later.  As someone else was pointing out, they used %d to print out a handle to another program, yet they should have been using %p.  And there&#8217;s also the issue of programs that have hardcoded structure sizes which container pointers.  It&#8217;d seem that all the issues with pointers would motivate someone to realize that it&#8217;s not possible to keep longs the same size and assume that&#8217;d fix all problems.  Though I will agree it might motivate people to switch to Win64..until their badly written code starts corrupting/crashing because of assumptions on pointer size as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252533">
				<div id="div-comment-252533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Patrick Bergeron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252533">
			February 2, 2005 at 11:05 pm</a>		</div>

		<p>I am in the process of porting a 32-bit app to Win64. The app is over 15 million lines of code. I&#8217;ve been at this for 6+ months.</p>
<p>Raymond, THANK YOU for LLP64.</p>
<p>While I&#8217;m on the subject, DrPizza, Raymond is absolutely correct when saying that changing &quot;long&quot; to &quot;int&quot; in code introduces build breaks. I&#8217;ve experienced it over thousands of lines of broken code, which I would have had to fix. </p>
<p>Unfortunately for me, I have to port this application to Linux-64 as well, under Mainwin. Since under linux &quot;long&quot; is 64 bits, the mainwin headers had no choice to define LONG as &quot;typedef int&quot;. You can&#8217;t imagine how broken the linux builds are right now.</p>
<p>God, how I wish Windows and Unix had chosen the same model. </p>
<p>It looks like we will have no choice but to ban the use of the word &quot;long&quot; in our code and enforce it by writing checkin scripts that parse the code and make sure no programmer has used this type.</p>
<p>I found this site by trying to find a way to tell gcc (linux) to make &quot;long&quot; 32 bits. I found a switch, &quot;-mlong32&quot;, but I am not sure how this will break other things, especially when compiling/linking external libraries we use (like STL etc). Any comments?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252583">
				<div id="div-comment-252583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252583">
			February 3, 2005 at 3:40 am</a>		</div>

		<p>&quot;God, how I wish Windows and Unix had chosen the same model. &quot;<br />
<br />Given that unix chose first&#8230;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252593">
				<div id="div-comment-252593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252593">
			February 3, 2005 at 3:41 am</a>		</div>

		<p>&quot;Because you changed &quot;long&quot; to &quot;int&quot;. You yourself noted that doing this will raise truncation warnings. And if you compile with &quot;treat warnings as errors&quot; your build is broken. &quot;<br />
<br />It ought to only raise truncation warnings when conversion from long to int is a truncation.  Which only ought to be the case when compiling for 64-bit.  Which needs truncation fixes anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252803">
				<div id="div-comment-252803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252803">
			February 3, 2005 at 10:34 am</a>		</div>

		<p>Just because things are bad doesn&#8217;t mean that we should intentionally make things worse.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252643">
				<div id="div-comment-252643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252643">
			February 3, 2005 at 7:25 am</a>		</div>

		<p>I already explained the truncation warning here<br />
<br /><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#364024" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#364024</a><br />
<br />and here<br />
<br /><a target="_new" href="<a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523</a>&#8220;><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523</a><br />
<br />and alluded to it here<br />
<br /><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#364255" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#364255</a><br />
<br />(assuming the reader would pick up on the long-to-int assignment). </p>
<p>&quot;It ought to only raise truncation warnings when conversion from long to int is a truncation.&quot; </p>
<p>On your compiler perhaps. There is at least one compiler that raises warnings for *potential* behavior, not just actual behavior &#8211; as I already mentioned here<br />
<br /><a target="_new" href="<a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523</a>&#8220;><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2005/01/31/363790.aspx#365523</a></p>
<p>I find it frustrating that in my comments I keep having to repeat myself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252793">
				<div id="div-comment-252793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252793">
			February 3, 2005 at 10:21 am</a>		</div>

		<p>Raymond wrote: __ is reserved for the implementation, and the Platform SDK is not the implementation. It&#8217;s just a header file in the application namespace.</p>
<p>$ pwd<br />
<br />/cygdrive/c/Program Files/Microsoft Visual Studio .NET 2003/Vc7/PlatformSDK/Include<br />
<br />$ grep &#8216;(# *define|struct)  *__&#8217; *.h | wc -l<br />
<br />   8844</p>
<p>The same goes for _ followed by a capital letter, by the way.</p>
<p>$ grep &#8216;(# *define|struct)  *_[A-Z]&#8217; *.h | wc -l<br />
<br />   5380<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252903">
				<div id="div-comment-252903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/hippietim' rel='external nofollow' class='url'>hippietim</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252903">
			February 3, 2005 at 8:28 pm</a>		</div>

		<p>pete diemart &#8211; I wish it was only 15 years :)</p>
<p>As part of my last job on the Windows team I was the Dev Mgr for NTVDM.  We still run Visicalc.  Wasn&#8217;t that released back in &#8217;81?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252913">
				<div id="div-comment-252913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252913">
			February 3, 2005 at 8:40 pm</a>		</div>

		<p>I understand why you chose LLP64, but I still have a big reservation about it.</p>
<p>The C standard guarantees that<br />
<br />    sizeof(short) &lt;= sizeof(int) &lt;=sizeof(long)<br />
<br />and<br />
<br />    long is the biggest int.</p>
<p>People who have followed the standard may now have their code broken, as long is no longer the biggest.</p>
<p>Alternatively, we are supporting people who ignored the standard by assuming that sizeof(long) would not change.</p>
<p>Effectively we are rewarding bad programmers.</p>
<p>Now I know that you have to live in the real world, and you probably made the right choice, but it still grates on me a bit.  :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-252983">
				<div id="div-comment-252983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antoine</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252983">
			February 4, 2005 at 9:03 am</a>		</div>

		<p>This discussion is fascinating.</p>
<p>Of course MS did not have any other options: there are far too much code out there which assume LONG &lt;B&gt;and&lt;/B&gt; long are 32 bit that anything else would be a rebuttal; and the coders are &lt;B&gt;customers&lt;/B&gt;.</p>
<p>OTOH, about the choice made by Unices: there, idioms such as:<br />
<br />    printf(&quot;foo: %lun&quot;, (unsigned long)sizeof(foo));<br />
<br />which furthermore is code that went to precautions to be maximally portable (among Unices), led them to the only possible solution: ensuring that the assertion size_t&lt;=ulong still holds with 64-bit. Even if it meant breaking a lot of code (written in the &#8217;80s, usually on Vaxen) which incorrectly assumed that int==long (or, more often, long==int32_t). Less code, older, and less vociferous coders: less hassle.</p>
<p>As someone that writes code intended to be portable (without #ifdef) between Windows (Win32 and Win64) and Unices, I certainly know this is a minefield. However, I am really much more annoyed by the lack of long long in CL until 2003: this means that for yet a pair of years I will have to &quot;support&quot; the __int64 hack.</p>
<p>And this leads to Michael&#8217;s point: as a consensuated end to the long long debate, it was agreed to add in the C99 standard the following subclause:</p>
<p>&lt;BLOCKQUOTE&gt;<br />
<br />7.17 Common definitions &lt;stddef.h&gt;</p>
<p>Recommended practice<br />
<br />[#4] The types used for size_t and ptrdiff_t should not have an integer conversion rank<br />
<br />greater than that of signed long unless the implementation supports objects large<br />
<br />enough to make this necessary.<br />
<br />&lt;/BLOCKQUOTE&gt;</p>
<p>Having closely followed the whole thread that ended here, I do not feel this is actually a reward toward bad programmers. I do not believe bad programmers will receive any reward in any case. I rather believe it is just that &quot;not bad&quot; programmers that cared about portability, and which had part of their code brocken, were penalized; and this above point was in order to soften this.</p>
<p>Since Unix compilers generally enhance this recommendation, while MS did not, it only turns out that Unix &quot;not bad&quot; programmers voiced their concerns louder than MS &quot;not bad&quot; ones. Nothing more.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-252993">
				<div id="div-comment-252993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-252993">
			February 4, 2005 at 9:05 am</a>		</div>

		<p>Michael Smith: This is not guaranteed in C99. However, the MS C/C++ compiler implements only a fraction of the changes made in C99, so when compiling for 64-bit targets it&#8217;s compliant with neither C90 nor C99, which is a shame.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-253093">
				<div id="div-comment-253093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antoine</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-253093">
			February 4, 2005 at 12:02 pm</a>		</div>

		<p>Michael: what do you mean by &quot;guaranteed&quot;?<br />
<br />Of course a &quot;Recommended practice&quot; is no guarantee! It is rather the contrary, at least to the coder reading the Standard; it should mean that while he may be customary for him to see this behaviour, this text reminds him he can encounter different situations (yes, Standardese is a strange dialect.)</p>
<p>In 2005, compilers&#8217; conformance to C99 is not 100% even for the most advanced one.<br />
<br />Of course VC does not claim to be among them either. I am reading they are after C++:98, which is another piece of cake entirely.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-253753">
				<div id="div-comment-253753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-253753">
			February 8, 2005 at 8:31 am</a>		</div>

		<p>I dont know. I&#8217;d have thought theres far too much code out there written by coders who expect </p>
<p>int len = pszEnd &#8211; pszStart;</p>
<p>or, more generically, for an int to be big enough to hold the result of a (char* &#8211; char*)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256273">
				<div id="div-comment-256273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-256273">
			February 16, 2005 at 8:03 pm</a>		</div>

		<p>The question should be who came up with these standards? Peter?</p>
<p>What should have been done was the same thing that was done going from 16 to 32 bits.</p>
<p>pointer sizes= 16, 32, 64<br />
<br />int = 16, 32, 64<br />
<br />long = 32<br />
<br />longlong = 64<br />
<br />short = 16</p>
<p>then of course the int16, int32, int64 variations.</p>
<p>I support 16 and 32 bit in one code base and would have been automatic for 64bit but now it&#8217;s going to be a hassle of coming up with my own typedef data types.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-566473">
				<div id="div-comment-566473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.roughlydrafted.com/2007/11/10/ten-myths-of-leopard-10-leopard-is-a-vista-knockoff/' rel='external nofollow' class='url'>Ten Myths of Leopard: 10 Leopard is a Vista Knockoff! &#8212; RoughlyDrafted Magazine</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-566473">
			November 10, 2007 at 2:49 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.roughlydrafted.com/2007/11/10/ten-myths-of-leopard-10-leopard-is-a-vista-knockoff/" rel="nofollow">http://www.roughlydrafted.com/2007/11/10/ten-myths-of-leopard-10-leopard-is-a-vista-knockoff/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611483">
				<div id="div-comment-611483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://editline.ru/2008/03/20/zabytye-problemy-razrabotki-64-bitnyx-programm/' rel='external nofollow' class='url'>editline.ru &raquo; Blog Archive &raquo; ?????????????? ???????????????? ???????????????????? 64-???????????? ????????????????</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-611483">
			March 23, 2008 at 5:35 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://editline.ru/2008/03/20/zabytye-problemy-razrabotki-64-bitnyx-programm/" rel="nofollow">http://editline.ru/2008/03/20/zabytye-problemy-razrabotki-64-bitnyx-programm/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-639143">
				<div id="div-comment-639143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.roughlydrafted.com/2008/06/17/myths-of-snow-leopard-2-32-bit-support/' rel='external nofollow' class='url'>Myths of Snow Leopard 2: 32-bit Support &#8212; RoughlyDrafted Magazine</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-639143">
			June 17, 2008 at 1:40 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.roughlydrafted.com/2008/06/17/myths-of-snow-leopard-2-32-bit-support/" rel="nofollow">http://www.roughlydrafted.com/2008/06/17/myths-of-snow-leopard-2-32-bit-support/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-710763">
				<div id="div-comment-710763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://auranix.info/2009/02/109' rel='external nofollow' class='url'>???????????? ???????????? ?? C++ | Roman's knowledgebase</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563#comment-710763">
			February 22, 2009 at 12:13 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://auranix.info/2009/02/109" rel="nofollow">http://auranix.info/2009/02/109</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>