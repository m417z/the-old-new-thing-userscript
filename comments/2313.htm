<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (17)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1095703">
				<div id="div-comment-1095703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095703">
			December 20, 2013 at 7:10 am</a>		</div>

		<p>Indeed implementing shell objects or altering their behavior requires infrastructure that is most of COM. But merely calling them could have been much simpler with a little ingenuity.</p>
<p>COM without CINTERFACE has this weird artifact of depending on the C++ memory layout (which is not normally a platform constant).</p>
<div class="post">[<em>I also showed how calling them could be done with a flat API. But it&#39;s just a difference in how you type the words. Either <code>pObject-&gt;Verb(Args)</code> or <code>VerbObject(p, Args)</code>. Or did you have something more radical in mind? Why not share your idea with us? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095713">
				<div id="div-comment-1095713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095713">
			December 20, 2013 at 7:45 am</a>		</div>

		<p>&quot;Show me the implementation&quot;</p>
<p>When a non-dev presents an alternative, they can be excused when they don&#39;t show the code.</p>
<p>When a dev presents an alternative, they need to have code to show.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095723">
				<div id="div-comment-1095723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cracky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095723">
			December 20, 2013 at 8:04 am</a>		</div>

		<p>For myself, working out how IAdvise (proper) coped with network failure, etc was vexing and then head banging in its simplicity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1095733">
				<div id="div-comment-1095733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095733">
			December 20, 2013 at 8:06 am</a>		</div>

		<p>&quot;How about we make the drivers OO, but because we want to save memory, we put the methods into a single per-driver table&quot;. And this is why Windows drivers have to have the same dispatch routines for all device objects they create, which is so inconvenient for some types of drivers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095743">
				<div id="div-comment-1095743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095743">
			December 20, 2013 at 8:26 am</a>		</div>

		<p>@Joshua: which only means that there is only One True memory layout for C++ on Windows. Using something different in your compiler is asking for troubles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-odd thread-alt depth-1" id="comment-1095753">
				<div id="div-comment-1095753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095753">
			December 20, 2013 at 8:48 am</a>		</div>

		<p>@Joshua actually COM was deliberately designed to follow the windows implementation of the C++ memory layout, I believe Raymond actually mentioned this a post awhile back talking about why the shell class headers were exposed directly (because the internals are C due to when the shell was written, and they manually build the vTables).</p>
<div class="post">[<em><a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/10/05/238050.aspx">I already covered this</a>. That&#39;s why we have macros like <code>BEGIN_INTERFACE</code>. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-wndsks even thread-even depth-1" id="comment-1095773">
				<div id="div-comment-1095773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/skSdnW' rel='external nofollow' class='url'>skSdnW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095773">
			December 20, 2013 at 12:01 pm</a>		</div>

		<p>And guess what, the shell already uses the message based extension model in some places.</p>
<p>When implementing/extending the default IShellView (DefView) you even get to choose if you want a callback function (LPFNVIEWCALLBACK) or a COM object with a single method (IShellFolderViewCB). You also have IShellMenuCallback for menu bands? and IContextMenuCB when you need to provide a IContextMenu.</p>
<p>In typical Microsoft fashion if you actually try to use this stuff you often hit a wall of poor documentation and lots of undocumented messages&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095783">
				<div id="div-comment-1095783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095783">
			December 20, 2013 at 2:04 pm</a>		</div>

		<p>[Not sure how you intend to do this in a flat C-like API while still supporting extensibility. This isn&#39;t C# where you can reflect on objects. -Raymond]</p>
<p>The shell folder tree has an apparently small number of objects (really interfaces). The trick involved is to reduce the number of interfaces to 1. The only reflection still required would be the single bit &quot;is this a kind of entity that could have children&quot; which should by handled by the enumerate operation, and the custom menu verbs which aren&#39;t specific interfaces right now.</p>
<div class="post">[<em>Now you&#39;re answering a question different from the one that was asked. The original question was &quot;Wouldn&#39;t a flat C API be simpler?&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095763">
				<div id="div-comment-1095763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095763">
			December 20, 2013 at 10:22 am</a>		</div>

		<p>[I also showed how calling them could be done with a flat API. But it&#39;s just a difference in how you type the words. Either pObject-&gt;Verb(Args) or VerbObject(p, Args). Or did you have something more radical in mind? Why not share your idea with us? -Raymond]</p>
<p>You would have had to change the fundamental design so that almost all verbs are universal and objects (not just directories) can be accessed by descending a path through the shell namespace and single-op verbs do not require taking references on their own object.</p>
<p>Potential verb list (this is really hard to make exhaustive one one pass):</p>
<p>* New (descends like 95-XP &#8212; folder, shortcut, file from template)</p>
<p>* GetBackingPath **</p>
<p>* GetHandle</p>
<p>* ReleaseHandle</p>
<p>* Copy</p>
<p>* Move</p>
<p>* Delete</p>
<p>* Rename</p>
<p>* Enum-Menu-Verbs</p>
<p>* Menu-Verb (calls whetever verbs returned by Enum-Menu-Verbs)</p>
<p>* GetIconFromForm (works on invalid paths such as *.doc)</p>
<p>* GetIcon</p>
<p>* GetIconOverlay</p>
<p>* OpenWith</p>
<p>* Get-Properties</p>
<p>* Set-Properties</p>
<p>* Get-Extended-Properties (details in the UI)</p>
<p>* Set-Extended-Properties (when they can be edited)</p>
<p>** GetBackingPath for a file is the full path. GetBackingPath for things like documents is SHGetSpecialFolder. GetBackingPath for Desktop returns the current user&#39;s desktop for the obvious reason.</p>
<p>Most verbs would need a flag that says whether or not a UI is acceptable to show.</p>
<p>For this design to be coherent, SHGetSpecialFolder must be moved to kernel32 where it should have been in the first place.</p>
<div class="post">[<em>Not sure how you intend to do this in a flat C-like API while still supporting extensibility. This isn&#39;t C# where you can reflect on objects. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095793">
				<div id="div-comment-1095793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095793">
			December 21, 2013 at 12:09 am</a>		</div>

		<p>I&#39;m not sure about Extensibility either.</p>
<p>Adding new verbs either means you need to ask the &quot;object&quot; about the verbs it supports and call through a pointer (like COM) or you&#39;re just jamming extra calls into whatever will pass as the vtable &amp; then hopefully versioning it so you don&#39;t ever try to call something past the end of the vtable ( which is how AmigaOS worked circa 1985).</p>
<p>I&#39;d be more interested in how you&#39;d implement something like COM in BCPL or Objective C :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095803">
				<div id="div-comment-1095803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095803">
			December 21, 2013 at 7:51 am</a>		</div>

		<p>[Now you&#39;re answering a question different from the one that was asked. The original question was &quot;Wouldn&#39;t a flat C API be simpler?&quot; -Raymond]</p>
<p>I think I&#39;m answering the question in the spirit of what was asked.</p>
<div class="post">[<em>Okay, fine, then be specific. You haven&#39;t really made a concrete proposal so much as presented a list of goals. How exactly do you have universal verbs in a flat C API? Are you saying that it should be<br /> <code>VARIANT args[2];<br /> args[0].vt = VT_BYREF;<br /> args[0].byref = pszNewName;<br /> args[1].vt = VT_I4;<br /> args[1].lVal = flags;<br /> InvokeUniversalVerbOnObjectWithArguments(hObject, ShellVerb_Rename, args, 2);</code><br /> ? This is basically the same as <code>AwesomeShellFolderInvoke</code>. And if the verb doesn&#39;t take a reference to the object, then there is no <code>hObject</code> parameter, so how does it know which object to operate on? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095873">
				<div id="div-comment-1095873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095873">
			December 23, 2013 at 10:32 am</a>		</div>

		<p>[The issues you have with COM are not actually issues with COM]</p>
<p>Issue #1 with COM is X-apartment model resulting in incompatibility. E.g. OpenFileDialog doesn&#39;t work very will with multi-thread apartment. This results in certain sets of COM components being completely incompatible with each other.</p>
<p>Issue #2 with COM is it&#39;s got this habit of loading DLLs at stupid times. Plug-in in this context means not implemented in shell32.dll.</p>
<p>Issue #3 with COM is memory corruption due to buggy third-party shell extension.</p>
<div class="post">[<em>What is the threading model for your alternative? Are all objects free-threaded, or do they have thread affinity? (Remember, whatever decision you make affects all implementations.) Also, defining a plug-in by what DLL implements them is very fragile. Components move around between DLLs a lot. (Control panel items in particular.) What would prevent your alternative from loading DLLs at stupid times? And buggy third party shell extensions don&#39;t go away when you switch from COM to a custom plug-in model, so it&#39;s not clear why you are blaming COM. And what is your extensibility model? What if a plug-in wants to add a new verb? (&quot;Add to Playlist&quot; or something.) Do they have to ask Microsoft to add an API for that new verb and then hope everybody upgrades to the next version of Windows? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095883">
				<div id="div-comment-1095883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095883">
			December 23, 2013 at 11:34 am</a>		</div>

		<p>[What is the threading model for your alternative? Are all objects free-threaded, or do they have thread affinity?]</p>
<p>This should be defined independently per interface rather than per memory space.</p>
<p>[(Control panel items in particular.)]</p>
<p>No case where I have to care needs to load control panel items or anything else that isn&#39;t a directory, drive, network share, computer, desktop, start menu, or special folder that behaves like desktop (think quick launch or send to). I don&#39;t have to care about recycle bin either but it is likely somebody else would.</p>
<p>[What would prevent your alternative from loading DLLs at stupid times?]</p>
<p>Either flag or sensible error handling when LoadLibrary returns EGOAWAY (i.e. don&#39;t stop enumeration if this object can&#39;t be started. Either pretend it&#39;s a file object or skip it).</p>
<p>[And buggy third party shell extensions don&#39;t go away when you switch from COM to a custom plug-in model, so it&#39;s not clear why you are blaming COM]</p>
<p>Because COM is defined in a way that COM interfaces can be hijacked by overriding registration. This should be flat-out impossible.</p>
<p>[And what is your extensibility model?]</p>
<p>I actually did think of the idea of making new shell folders via plugins. As I said before the actual implementation on the extender&#39;s side looks like COM with a few more variables floating.</p>
<p>[(&quot;Add to Playlist&quot; or something.)]</p>
<p>Same way I did in Windows 95. Add a new verb in the file types dialog that spawns a program with specific options. This is what I call Menu-Verb above.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1095893">
				<div id="div-comment-1095893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095893">
			December 23, 2013 at 2:29 pm</a>		</div>

		<p>&gt;Because COM is defined in a way that COM interfaces can be hijacked by overriding registration.</p>
<p>ANY plug-in model can be hijacked by overriding registration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095903">
				<div id="div-comment-1095903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095903">
			December 23, 2013 at 2:42 pm</a>		</div>

		<p>&gt; ANY plug-in model can be hijacked by overriding registration.</p>
<p>But a built-in component shouldn&#39;t be overridable that way. This limits plugins to overriding other plugins.</p>
<div class="post">[<em>Whether a registration can be overridden doesn&#39;t have anything to do with whether the Recycle Bin sample program would have been simpler with a flat API model. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095853">
				<div id="div-comment-1095853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095853">
			December 23, 2013 at 9:56 am</a>		</div>

		<p>What I call root here is more like current directory but we can have arbitrary N of them.</p>
<p>NT Native API has the same concept.</p>
<p>Operations that display pre-defined dialogs may accept a list of strings to populate the dialog.</p>
<p>The most prominent of these is new shortcut. Menu-verb has the same artifact.</p>
<p>The idea of XSTR is it&#39;s a string that&#39;s only reference counted if you return it. If passed one,</p>
<p>don&#39;t assume you can keep it after returning. I&#39;m assuming that auto_ptr hasn&#39;t been discovered yet.</p>
<p>Since we now have exactly 1 interface, we may almost completely depend on strong typing (no need for VT_&#8230;) and declare C functions for them as so:</p>
<p>/* declarations */</p>
<p>#define SHFLAG_NOUI 1</p>
<p>#define SHFLAG_DONTLOADPLUGINS 2 /* for processes that must function with special memory-model constraints */</p>
<p>#define SHEFLAG_CANDESCEND 1</p>
<p>#define SHEFLAG_NOBACKINGFILE 2</p>
<p>#define SHEFLAG_NOSTATE 4 /* requires SHEFLAG_NOBACKINGFILE */</p>
<p>/* these are the only entities that exist at the root of the shell namespace */</p>
<p>/* All valid file paths are also valid SHNAME paths */</p>
<p>/* These teplates exist at root level to keep people from deleting them */</p>
<p>#define SHNAME_DESKTOP &quot;\\!\desktop&quot;;</p>
<p>#define SHNAME_TEMPLATE_EMPTY &quot;NUL&quot;;</p>
<p>#define SHNAME_TEMPLATE_FOLDER &quot;\\!\{::newfolder}&quot;;</p>
<p>#define SHNAME_TEMPLATE_SHORTCUT &quot;\\!\{::newshortcut}&quot;;</p>
<p>#define SHNAME_TEMPLATE_TEMPLATEDIR &quot;\\!\{::templates};&quot;</p>
<p>#define SHNAME_MY_COMPUTER &quot;\!desktopcomputer&quot;;</p>
<p>/* Most of these exist ONLY to identify shell special folders independent of name */</p>
<p>#define PROVIDER_FILESYSTEM MKGUID(&#8230;)</p>
<p>#define PROVIDER_TEMPLATE MKGUID(&#8230;)</p>
<p>#define PROVIDER_DESKTOP MKGUID(&#8230;)</p>
<p>#define PROVIDER_RECYCLE_BIN MKGUID(&#8230;)</p>
<p>typedef struct _xstr { ssize_t owner_refcnt; size_t sz, wchar_t *data; } XSTR;</p>
<p>typedef struct _verb { DWORD flags, GUID providerid, DWORD nmargs /* most stock have 0 here */, XSTR verb; } SHVERB;</p>
<p>typedef struct _entity { DWORD flags, GUID providerid, DWORD attributes, FILETIME moddatetime, QWORD inum, XSTR name); } SHENTITY</p>
<p>inline XSTR StringToXSTR(wchar_t str) { XSTR x { -1 /* cannot be freed */, _wstrlen(str), str}; return x; }</p>
<p>HRESULT SHGetBackingPath(HANDLE root, XSTR path, OUT *XSTR backing);</p>
<p>HRESULT SHGetHandle(HANDLE root, XSTR path, OUT *HANDLE child);</p>
<p>HRESULT SHReleaseHandle(HANDLE root);</p>
<p>HRESULT SHNew(HANDLE root, DWORD flags, HWND owner, XSTR template, XSTR newname, size_t nargs, IN XSTR *args);</p>
<p>HRESULT SHCopy(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname);</p>
<p>HRESULT SHMove(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname);</p>
<p>HRESULT SHRename(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname_nameonly);</p>
<p>HRESULT SHDelete(HANDLE root, DWORD flags, HWND owner, XSTR name);</p>
<p>HRESULT SHGetMenuVerbs(HANDLE root, XSTR path, OUT DWORD *verbs, OUT SHVERB *verbs);</p>
<p>HRESULT SHFindOpen(HANLDE root, XSTR path, OUT *enumhandle);</p>
<p>HRESULT SHFindNext(HANLDE enumerator, OUT SHENTITY *entity);</p>
<p>HRESULT SHFindClose(HANLDE enumerator);</p>
<p>/* &#8230; */</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095863">
				<div id="div-comment-1095863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095863">
			December 23, 2013 at 9:57 am</a>		</div>

		<p>[please shorten your comment to 3072 bytes or less] ok breaking</p>
<p>So the rename recycle bin would look like:</p>
<p>int main(int argc, char **argv)</p>
<p>{</p>
<p>wchar_t *newname = /* gimmie first arg as whar_t */</p>
<p>HRESULT hr;</p>
<p>SHENTITY e;</p>
<p>HANDLE h;</p>
<p>hr = SHFindOpen(NULL, SHNAME_DESKTOP, h);</p>
<p>if (SUCCEEDED(hr)) {</p>
<p>while (1) {</p>
<p>SHFindNext(h, entity);</p>
<p>if (e.name.sz == 0) break; /* EOL */</p>
<p>if (e.providierid == PROVIDERID_RECYCLE_BIN) {</p>
<p>XSTR rc = JoinXstrs(3, SHNAME_DESKTOP, &quot;\&quot;, e.name);</p>
<p>SHRename(rc, SHFLAG_NOUI, NULL, rc, StringToXSTR(newname));</p>
<p>ReleaseXSTR(rc);</p>
<p>}</p>
<p>}</p>
<p>SHFindClose(h);</p>
<p>}</p>
<p>}</p>
<p>For an example of implementation disptach (this is a library function that would already be provided): SHRename</p>
<p>HRESULT SHRename(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname_nameonly)</p>
<p>{</p>
<p>XSTR folder;</p>
<p>XSTR file;</p>
<p>HANDLE h;</p>
<p>HRESULT hr;</p>
<p>if (!XSTRGetFolderAndFile(oldname, &amp;folder, &amp;file)) /* if no folder component, returns &quot;.&quot; */</p>
<p>return EBADPATH;</p>
<p>hr = SHGetHandle(root, folder, &amp;hr);</p>
<p>if (!SUCCEEDED(hr)) return hr;</p>
<p>hr = ((struct internalentity *)h)-&gt;vtbl-&gt;rename(flags, owner, file, newname_nameonly);</p>
<p>SHReleasehandle(h);</p>
<p>return hr;</p>
<p>}</p>
<p>Key differences between this and COM such that no wrapper could ever be written:</p>
<p>1. Does not impose any memory model or message pumping requirements if the _NOUI flag is passed.</p>
<p>2. The SHFLAG_DONTLOADPLUGINS exists, which permits access to core shell functions without imposing any more memory model constraints than WIN32. This would allow things like SQL server to use this directly.</p>
<div class="post">[<em>The issues you have with COM are not actually issues with COM. They are issues with the shell interface itself. For example, there is COM-imposed reason why there can&#39;t be a &quot;DONTLOADPLUGINS&quot; flag. That&#39;s a shell limitation. Internally, <span style="text-decoration:underline;">everything</span> is a plug-in. Control Panel? That&#39;s a plug-in. Files on disk? That&#39;s a plug-in. It happens to be a plug-in provided with Windows, but from the shell namespace&#39;s standpoint, it&#39;s still a plug-in. So as far as I can tell, your complaints have nothing to do with COM. You merely wish the shell interfaces were designed some other way. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>