<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (41)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-852933">
				<div id="div-comment-852933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marquess</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-852933">
			August 11, 2010 at 7:10 am</a>		</div>

		<p>Then there&#39;s the Homer Simpson garbage collector, which spends all it&#39;s money at program initialization and then takes the garbage from other processes to make up for it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-nathan_works odd alt thread-odd thread-alt depth-1" id="comment-852943">
				<div id="div-comment-852943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/nathan_works' rel='external nofollow' class='url'>nathan_works</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-852943">
			August 11, 2010 at 7:12 am</a>		</div>

		<p>The death certificate link has a spurious quote in it. </p>
<p>But like my comment yesterday about if you&#39;re trying to walk the stack in C#, you&#39;re doing it wrong.. </p>
<p>If you don&#39;t want your object &quot;deleted&quot;, don&#39;t drop your references to it. There are a zillion ways to prevent this.. If you need to check if it&#39;s been deleted, you&#39;re doing it wrong.</p>
<div class="post">[<i>Link fixed, thanks. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-852953">
				<div id="div-comment-852953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-852953">
			August 11, 2010 at 7:16 am</a>		</div>

		<p>Funny thing, but I read this and think, &quot;Wow &#8212; yet another example of why many of those who read this blog prefer deterministic resource reclamation.&quot; &nbsp;It is obvious that this customer is thinking in those terms.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-852963">
				<div id="div-comment-852963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Christoph</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-852963">
			August 11, 2010 at 7:17 am</a>		</div>

		<p>This may have been a long discussion, but it was highly interesting. To me, at least. As were all posts from CLR week. Please don&#39;t try to keep posts shorter than necessary. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-nathan_works even thread-even depth-1" id="comment-852983">
				<div id="div-comment-852983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/nathan_works' rel='external nofollow' class='url'>nathan_works</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-852983">
			August 11, 2010 at 7:54 am</a>		</div>

		<p>SimonRev &#8212; I will agree, it feels &quot;wrong&quot; to not explicitly say &quot;delete this object&quot; when writing lots of C# code.. That you&#39;ve got all these &quot;new&quot; operations, with out the corresponding delete.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-852993">
				<div id="div-comment-852993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-852993">
			August 11, 2010 at 8:08 am</a>		</div>

		<p>I can think of a scenario where you would want to do what the customer asks for. You may want to verify (in debug builds) that some resource has been freed (unreferenced) properly. Imagine in a game when you go from one level to the next. If any code (like the collision system) still refers to any of the objects in the old level, that&#39;s a bug and should be caught and fixed. Otherwise the game might not crash, but may misbehave in subtle ways (like bumping into some invisible wall left over from the last level). Of course I would do that between levels, when calling the GC and paying the price (particularly in debug builds) is acceptable.</p>
<p>The problem with this test is that it doesn&#39;t tell you who has the extra reference, just that there is one (or more). But still, it is a starting point for locating the bug.</p>
<div class="post">[<i>That&#39;s not quite what the customer asked for. You want to know whether the reference count is zero or nonzero. For that, use WeakReference. The customer wants to know whether it is one or greater than one. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853003">
				<div id="div-comment-853003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853003">
			August 11, 2010 at 8:18 am</a>		</div>

		<p>Ivo&#8230; sure, but the best way of doing something like that would be checking with an external debugging tool that can find references to objects on the heap (I&#39;m assuming such a tool is available for .net; I&#39;ve never needed to use one there, but have used one in java). I don&#39;t really see much need to automate such a test.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853013">
				<div id="div-comment-853013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853013">
			August 11, 2010 at 8:18 am</a>		</div>

		<p>Does garbage collector track number of hard page faults per second? Because if it only runs as late as possible, it might have to go through objects already paged out. This is the biggest problem I see with GC &#8211; it inflates the process working set.</p>
<div class="post">[<i>That&#39;s why CLR GC is generational. See Maoni&#39;s blog which I listed as bonus reading. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853023">
				<div id="div-comment-853023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JS Bangs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853023">
			August 11, 2010 at 8:23 am</a>		</div>

		<p>Nathan_works, it only looks &quot;wrong&quot; if you&#39;ve been brain-damaged by too much C++. Yes, I consider C++ a form of brain damage. This despite the fact that I have to write code in C++ every day.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853033">
				<div id="div-comment-853033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853033">
			August 11, 2010 at 8:29 am</a>		</div>

		<p>@JS Bangs:</p>
<p>In fact, I&#39;d say only if you&#39;re writing too much C, because if you&#39;re writing what I&#39;d consider good C++, most of your deletes will be done automatically by auto_ptr/shared_ptr.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853043">
				<div id="div-comment-853043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">djeidot</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853043">
			August 11, 2010 at 8:43 am</a>		</div>

		<p>&quot;I like how he immediately weakened his request from &quot;I want the exact reference count&quot; to &quot;I want to know if it is greater than one.&quot; Because as we all know, the best way to solve a problem is to reduce it to an even harder problem.&quot;</p>
<p>I have some issues with this comment. People will often ask for a general solution in order to solve a particular problem. This is because they assume that there won&#39;t be a specific function for their case. For instance, I don&#39;t go to a forum and ask for a function that determines if the size of an array is bigger than 123, because there is no way that particular function exists and people will just call me stupid. I will ask for a function that gets me the size of the array.</p>
<p>In this case, the customer was wrong, there was indeed a specific solution for his specific case. But that is the exception, not the rule.</p>
<div class="post">[<i>A better question would be to ask for a function to determine if the size of an array is bigger than N for some fixed N. Because it may be easier to determine that an array is &quot;big enough&quot; than to determine exactly how big it is. It&#39;s easier to answer &quot;Can this library hold at least 5000 books?&quot; than &quot;Exactly how many books can this library hold?&quot;-Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853053">
				<div id="div-comment-853053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">blah</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853053">
			August 11, 2010 at 9:28 am</a>		</div>

		<p>&quot;performance benefits of garbage collected systems&quot;</p>
<p>I nominate this as oxy of the month.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853063">
				<div id="div-comment-853063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853063">
			August 11, 2010 at 9:46 am</a>		</div>

		<p>@blah: &quot;I nominate this as oxy of the month.&quot;</p>
<p>Why&#39;s that necessarily an oxymoron? Think carefully before you answer. (Hint: it is sometimes the case that a GC&#39;d system will perform better than manual memory management.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853073">
				<div id="div-comment-853073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul M. Parks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853073">
			August 11, 2010 at 9:49 am</a>		</div>

		<p>@blah: Your dismissive comment leads me to believe you might not have read this:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms973838.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/ms973838.aspx</a></p>
<p>For several usage scenarios, garbage collection does indeed out-perform manually managed memory heaps. Don&#39;t dismiss it until you&#39;ve measured it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853103">
				<div id="div-comment-853103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.owenpellegrin.com' rel='external nofollow' class='url'>Owen Pellegrin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853103">
			August 11, 2010 at 10:26 am</a>		</div>

		<p>@BarfieldMV:</p>
<p>There are facilities to handle the situation where your type references large portions of memory the GC might otherwise be unaware of. &nbsp;See GC.AddMemoryPressure(). &nbsp;I&#39;m pretty sure Bitmap does it, but if your type maintains several Bitmap instances you might have to do it as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853123">
				<div id="div-comment-853123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853123">
			August 11, 2010 at 11:08 am</a>		</div>

		<p>@Nathan &amp; JS</p>
<p>Anymore, I tend to consider a manual call to delete in C++ a &quot;code smell.&quot; &nbsp;Good chance there is an error there. &nbsp;In any case it probably means you didn&#39;t use RAII. &nbsp;The first thing you should do with just about memory resource you get is stick it in shared_ptr, scoped_ptr or unique_ptr. (Note: &nbsp;shared_ptr at least probably reduces performance to be roughly equal or less than GCed memory, but does preserve deterministic destruction semantics).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853133">
				<div id="div-comment-853133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ooh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853133">
			August 11, 2010 at 11:15 am</a>		</div>

		<p>@blah: Interestingly enough, it&#39;s especially in long-running server scenarios where a GC really shines. The reason is that the .NET GC is a compacting GC, i.e. it does not only reclaim memory but &quot;defragments&quot; the memory, which results in better locality of objects. Therefore a compacting GC actively avoids heap fragmentation, which is essential for scalable Web apps.</p>
<p>That&#39;s not to say that you can&#39;t write scalable web apps using explicit memory management (as with all the other benefits of managed environments). It&#39;s just a lot harder to do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853143">
				<div id="div-comment-853143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853143">
			August 11, 2010 at 11:43 am</a>		</div>

		<p>@mikeb: If an object&#39;s finalizer resurrects it, it&#39;s common practice to call GC.ReRegisterForFinalize so the finalizer will have another go when the time is right.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853163">
				<div id="div-comment-853163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bdodson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853163">
			August 11, 2010 at 1:25 pm</a>		</div>

		<p>Any chance you can tell us what the customer was actually trying to do? I&#39;m still trying to come up with a scenario where you&#39;d want to know this (and for which you&#39;d go to the great lengths of asking questions to figure out how to do it rather than just finding some other way to do what you want).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-852973">
				<div id="div-comment-852973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.coryfoy.com' rel='external nofollow' class='url'>Cory Foy</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-852973">
			August 11, 2010 at 7:42 am</a>		</div>

		<p>One of the things I saw on a lot of customer sites was people saying, &quot;But we know X about our system, and so we call GC.Collect&quot;.</p>
<p>The thing is, there are cases when you *do* know more than the Garbage Collector you are using. But unless you&#39;ve actually run profilers against your code and determined where the bottlenecks are (and the time and memory saved by calling GC.Collect right there) then you may not know as much as you think you do.</p>
<p>In addition, the GC isn&#39;t static in that if there are better ways to do things (or better GCs tailored to your situation) you can use those. If you&#39;ve decided to preempt that process, then you need to be ensuring that you have tests in place to make sure that it is still the right choice.</p>
<p>GC.Collect is always guilty until proven innocent. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853183">
				<div id="div-comment-853183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853183">
			August 11, 2010 at 3:05 pm</a>		</div>

		<p>I am not a managed developer, but judging by your description of weak references, it seemed like naive use of them would be a race with the garbage collector. &nbsp;The fact that IsAlive was false doesn&#39;t mean that in the time between that moment and when you decide to dereference, the GC won&#39;t reclaim it. &nbsp;Looking at the documentation it seems like the dereference will throw InvalidOperationException in this circumstance, so I would almost be inclined to never check IsAlive, and always grab a reference in a try block.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853213">
				<div id="div-comment-853213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853213">
			August 11, 2010 at 3:43 pm</a>		</div>

		<p>@Anonymous: You don&#39;t need to worry about exceptions. If you grab the reference from the Target property, you&#39;ll get null if it&#39;s already been collected. InvalidOp only throws when trying to set an invalid reference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853083">
				<div id="div-comment-853083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marquess</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853083">
			August 11, 2010 at 9:54 am</a>		</div>

		<p>Indeed, with enough memory at hand, a null garbage collector will outperform *any* other memory management strategy :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853093">
				<div id="div-comment-853093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BarfieldMV</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853093">
			August 11, 2010 at 10:05 am</a>		</div>

		<p>I just wanted to add a note that if you keep huge objects around (10+ MB of bitmaps) forcing a garbage collect can really speed up your machine. The GC won&#39;t see the huge amount of memory space used by those bitmaps and won&#39;t force a lvl 3 collec even through it should. (.net only keeps a reference to those bitmaps alive and probably thinks, i&#39;m only using 80 bitmap reference ~ couple Kb of mem so it wont even start a lvl 3 collect)</p>
<p>Spending the dollar when you&#39;re sure the application can miss it is always* a smart move.</p>
<p>*always for a given value of always that might not be your value of always.</p>
<p>ps. any comment about a garbage collector not backed up with generation memory snapshots and performance counter information is worthless (ya&#39;ll did know you can just read them no?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853113">
				<div id="div-comment-853113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853113">
			August 11, 2010 at 10:58 am</a>		</div>

		<p>I haven&#39;t done much serious .NEt work in a while, but I still really like .NET week&#8230;</p>
<p>Anyway, prompted by this article, I looked into the difference between the 2 types of WeakReference where it discussed &#39;resurrection&#39;, which sounded interesting. I ended up in the docs for Object.Finalize():</p>
<p>&gt;&gt; Finalize can take any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection. However, the object can only be resurrected once; Finalize cannot be called on resurrected objects during garbage collection. &lt;&lt;</p>
<p>Now *that* seems like a curious scenario rife with possibilities for screwing things up. I&#39;d be interested in pointers (or references) to where resurrection is a useful technique (maybe Raymond already has something in the .NET Week queue&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853233">
				<div id="div-comment-853233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henning Makholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853233">
			August 11, 2010 at 6:16 pm</a>		</div>

		<p>@mikeb: It&#39;s not so much that resurrection is a Good Idea than the fact that it would be very hard to prevent the programmer from doing it without also disallowing things that do make sense. (Consider, for example the case of cyclic structures of finalizable objects, where one object is finalized first, and another object&#39;s finalizer resurrects it afterwards). Given that the language cannot prevent perverse programmers from trying, it should at least do something well-defined and documented when it happens. And the &quot;don&#39;t finalize twice&quot; rules is one of the simplest rules that are easy to explain AND reasonably easy to implement without an efficiency penalty.</p>
<p>That being said, controlled resurrection can sometimes be useful. Imagine, for example, that releasing a resource needs something to happen in a particular thread. The finalizer cannot count on running in any specific thread, so what it&#39;ll need to do is to place enter the object on a worklist that the thread walks through from time to time. But as soon as the object is reachable from the worklist, it has technically been resurrected.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853243">
				<div id="div-comment-853243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Smart Aleck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853243">
			August 11, 2010 at 7:02 pm</a>		</div>

		<p>[A better question would be to ask for a function to determine if the size of an array is bigger than N for some fixed N. Because it may be easier to determine that an array is &quot;big enough&quot; than to determine exactly how big it is. It&#39;s easier to answer &quot;Can this library hold at least 5000 books?&quot; than &quot;Exactly how many books can this library hold?&quot;-Raymond]</p>
<p>Use IsBadReadPtr to determine if the library book pointed-to is a Bad Read.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853253">
				<div id="div-comment-853253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853253">
			August 11, 2010 at 8:43 pm</a>		</div>

		<p>Is there a way to find out if an object has any &quot;strong references&quot; to it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853263">
				<div id="div-comment-853263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TwelveBaud</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853263">
			August 11, 2010 at 8:47 pm</a>		</div>

		<p>@SmartAleck &quot;Use IsBadReadPtr to determine if the library book pointed-to is a Bad Read.&quot;</p>
<p>Ha! But the problem with that is what&#39;s to stop you from wandering out the library&#39;s back door, down the road a few blocks, and into my bedroom picking up my mystery novel. Sure, it&#39;s not a Bad Read, but what the heck are you doing in my bedroom? ;)</p>
<p>@IanBoyd &quot;Is there a way to find out if an object has any &quot;strong references&quot; to it?&quot;</p>
<p>Sure. The answer is yes: the one you&#39;re using to ask the question. Of course, now that you&#39;ve finished asking, the answer might have changed&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853193">
				<div id="div-comment-853193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ficedula</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853193">
			August 11, 2010 at 3:25 pm</a>		</div>

		<p>@Anonymous: The documentation suggests to me that Target returns null if the object has been garbage collected so no Try/Catch is required &#8211; InvalidOperation is only thrown when *setting* it &#8211; &#8230; but otherwise, yes, I&#39;d say that you should just try and retrieve the object, not check IsAlive first. I guess IsAlive is basically just a convenience method which makes it slightly easier to do something like MyCache.RemoveAll(item =&gt; !item.IsAlive)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853203">
				<div id="div-comment-853203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ficedula</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853203">
			August 11, 2010 at 3:37 pm</a>		</div>

		<p>@bdodson: Well, I can construct a situation where you might want to know &#8230; say you have a cache of some expensive-to-construct items, using WeakReferences (so far so good), and each item takes up a fair amount of memory and requires disposing (to free a native resource). You *might* want to remove items from the cache for various reasons; perhaps they expire after a certain period of time. However because each cached item (ideally) requires disposing, the removal procedure could be:</p>
<p>-Check the WeakReference is still alive (if not, it&#39;s been GC&#39;d and you can&#39;t do anything with it anyway!)</p>
<p>-If it&#39;s still alive, get a reference to the item into a local variable, remove the cache entry, and Dispose it to free up the native resource. But you can only Dispose it if no other thread currently has an outstanding reference to the object; Disposing something while it&#39;s in use elsewhere would be bad. So you want a way to ask the GC &quot;is there only one outstanding reference to this object, i.e. just my local variable&quot;.</p>
<p>Of course, this is just a guess, but it *is* possible the customer had a &quot;legitimate&quot; reason for asking. Which isn&#39;t to say that another solution wouldn&#39;t have been better.</p>
<p>As it happens, this sort of problem &#8211; WeakReferences to objects that need to clean up non-managed resources &#8211; is a tricky situation to deal with. It&#39;s one situation in which a finalizer is actually a really good idea as part of your normal operation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853273">
				<div id="div-comment-853273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853273">
			August 11, 2010 at 11:06 pm</a>		</div>

		<p>@Nathan_works : agreed. I would imagine if we could get the full explanation of the issue, we&#39;d find something more easily resolved farther up the chain than needing to find a reference count for a particular object.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853223">
				<div id="div-comment-853223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853223">
			August 11, 2010 at 5:30 pm</a>		</div>

		<p>@Anonymous: &gt;&gt; judging by your description of weak references, it seemed like naive use of them would be a race with the garbage collector. &lt;&lt;</p>
<p>Raymond&#39;s discussion of the IsAlive property discusses exactly this incorrect, naive use of WeakReference. &nbsp;If you want to use WeakReference, in almost all cases you should *not* deal with the IsAlive property at all. &nbsp;Just use the Target property to get the strong reference back (this operation is synchronized with the GC). &nbsp;If you get a non-null reference, you&#39;re good to go. &nbsp;If you get null back, the object is gone, and you&#39;ll need to recreate it (or whatever the appropriate handling for this situation is).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853283">
				<div id="div-comment-853283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeffrey Bosboom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853283">
			August 12, 2010 at 1:07 am</a>		</div>

		<p>@Henning Makholm: Java has &quot;reference queues&quot; a Reference object can be registered with: blocking queues that a Reference object is placed on when it becomes eligible for collection but before it&#39;s actually collected (and it&#39;s guaranteed not to be collected while it&#39;s in the queue). &nbsp;What you describe is pretty much what they&#39;re for &#8212; any time your finalizer does something more than a last-ditch attempt to free a native resource, you should use a reference queue. &nbsp;Does .NET have anything analogous?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853293">
				<div id="div-comment-853293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853293">
			August 12, 2010 at 3:38 am</a>		</div>

		<p>Did you ever find out what the customer actually wanted?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853303">
				<div id="div-comment-853303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vulcan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853303">
			August 12, 2010 at 4:08 am</a>		</div>

		<p>I read an old (old new?) post of yours ending with: &quot;We&#39;ll look at that next time.&quot; Here is the URL: <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2005/07/26/443384.aspx" rel="nofollow">blogs.msdn.com/&#8230;/443384.aspx</a></p>
<p>I have not yet been able to find the &quot;next&quot; article/post. Please help. I am trying to determine the very first message a window receives in each of the following cases: top-level windows, child windows and any others.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853313">
				<div id="div-comment-853313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853313">
			August 12, 2010 at 7:12 am</a>		</div>

		<p>@Vulcan: <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2005/07/27/443824.aspx" rel="nofollow">blogs.msdn.com/&#8230;/443824.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853353">
				<div id="div-comment-853353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853353">
			August 12, 2010 at 7:30 am</a>		</div>

		<p>@TwelveBaud No; i have a &quot;weak reference&quot; (i.e. WeakReference). This is implicit in the question, otherwise one might short-circuit the question and skip to a non-answer.</p>
<p>The question can be re-formulated, to avoid your non-answer: &quot;Is there a way to find out if an object has any &quot;strong references&quot; to it, besides the [strong] one i&#39;m using to ask the question?&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853383">
				<div id="div-comment-853383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853383">
			August 12, 2010 at 8:07 am</a>		</div>

		<p>Ian Boyd wrote &quot;Is there a way to find out if an object has any &quot;strong references&quot; to it, besides the [strong] one i&#39;m using to ask the question?&quot;</p>
<p>In other words, does the object have more than one reference? &nbsp;Which is exactly the question that Raymond&#39;s post answers.</p>
<p>If you start with a weak reference the question is partially decidable. &nbsp;If the weak reference is dead there were no strong references; if it&#39;s alive that tells you nothing about strong references.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-853443">
				<div id="div-comment-853443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bdodson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853443">
			August 12, 2010 at 8:55 am</a>		</div>

		<p>@ficedula &#8211; thanks for the example you gave. I can now see why a customer might look for this capability. Of course, the way you usually have to end up implementing such a cache/object pool is to have clients of the cache &quot;check out&quot; (i.e. add a reference) to an object and then check it back in again with the cache later. That way the cache keeps it&#39;s own reference count so it knows if it&#39;s free to Dispose something.</p>
<p>I&#39;ve seen this done with pools of expensive objects, although usually checking the object out removes it from the pool so you don&#39;t have to worry about the number of references (it&#39;s always effectively 1 or 0).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-853933">
				<div id="div-comment-853933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100811-00/?p=13173#comment-853933">
			August 14, 2010 at 2:54 pm</a>		</div>

		<p>I think that the customer must have had a background in Objective-C programming (Mac/iPhone).</p>
<p>They have this concept of a reference count on every object. You increase the count by calling [object retain] and decrease it with [object release]. There is also a method, whose name I forgot, to get the reference count of an object. How it works is pretty simple: when you call [object release] and the reference count hits zero, the object is immediately deallocated.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>