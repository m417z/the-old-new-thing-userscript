<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (41)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-206073">
				<div id="div-comment-206073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.zero-one-zero.com/vs' rel='external nofollow' class='url'>Jonathan Payne</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206073">
			August 26, 2004 at 7:40 am</a>		</div>

		<p>How would you allocate one of these structures in C++?  My understanding was that new/delete and malloc/free had to be done in matching pairs so ideally you would want to use new so you don&#8217;t need to remember to call free rather than delete.  But you can&#8217;t allocate it using &#8216;new TOKEN_GROUPS&#8217; as you will get an incorrectly sized structure.  And you can&#8217;t allocate it using &#8216;new BYTE[sizeof(TOKEN_GROUPS) + sizeof(SID_AND_ATTRIBUTES)]&#8217; as you may get a badly aligned structure.</p>
<p>What am I missing?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206093">
				<div id="div-comment-206093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Serge Wautier</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206093">
			August 26, 2004 at 7:51 am</a>		</div>

		<blockquote><p>
  you can&#8217;t allocate it using &#8216;new BYTE[&lt;snip&gt;]&#8217;<br />
  <br />&gt;as you may get a badly aligned structure.</p>
<p>Is there basically a difference between C++&#8217;s new BYTE[x] and C&#8217;s malloc(x) regarding the way the allocation is performed ?</p>
<p>&gt; What am I missing?</p>
<p>An alternative version of TOKEN_GROUPS::operator new() that would take NumberOfGRoups as an extra argument ?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206113">
				<div id="div-comment-206113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.zero-one-zero.com/vs' rel='external nofollow' class='url'>Jonathan Payne</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206113">
			August 26, 2004 at 8:14 am</a>		</div>

		<p>Sorry &#8211; I see my mistake (for some strange reason I thought malloc was doing something different as the structure contained a pointer but obviously that doesn&#8217;t make sense and alignment was coming from the fact that items were both in a structure).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206123">
				<div id="div-comment-206123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206123">
			August 26, 2004 at 8:16 am</a>		</div>

		<p>Use &#8216;new BYTE[FIELD_OFFSET(TOKEN_GROUPS, Groups[NumberOfGroups])];&#8217;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206133">
				<div id="div-comment-206133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.differentpla.net' rel='external nofollow' class='url'>Roger Lipscombe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206133">
			August 26, 2004 at 8:19 am</a>		</div>

		<blockquote><p>
  difference between C++&#8217;s new BYTE[x] and C&#8217;s malloc(x)</p>
<p>In theory, new allocates objects from the &quot;free store&quot;. malloc allocates memory from the heap.</p>
<p>In practice, there&#8217;s no real difference, so there&#8217;s nothing wrong with using new BYTE[x].</p>
<p>&gt; TOKEN_GROUPS::operator new()</p>
<p>That&#8217;d be really useful but, as I&#8217;m sure you know, C++ class declarations are closed. You can&#8217;t add things to them after the fact (unlike Ruby, e.g.)</p>
<p>FWIW, I&#8217;d never seen the malloc(FIELD_OFFSET) trick anywhere before. It&#8217;s kinda cool, but could it have made sense for the header file to declare a TOKEN_GROUPS_BytesRequired macro? Too late now, I know.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206153">
				<div id="div-comment-206153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206153">
			August 26, 2004 at 8:44 am</a>		</div>

		<p>I couldn&#8217;t find anything in The C++ Programming Language that said one way or another about alignment guarantees for operator new, so you have to work around it a bit.</p>
<p>#define MAKE_ALIGNED(align, val) (((val) &amp; ((align)-1)) ? (((val) &amp; ~((align)-1)) + (align)) : (val))</p>
<p>    PTOKEN_GROUPS TokenGroups = (PTOKEN_GROUPS)new unsigned char[sizeof(TOKEN_GROUPS) + (NumberOfSidAndAttributes &#8211; 1) * sizeof(SID_AND_ATTRIBUTES) + __alignof(TOKEN_GROUPS)];</p>
<p>    if((ULONG_PTR)TokenGroups &amp; (__alignof(TOKEN_GROUPS) &#8211; 1))<br />
<br />        TokenGroups = (PTOKEN_GROUPS)(MAKE_ALIGNED(__alignof(TOKEN_GROUPS), (ULONG_PTR)TokenGroups));</p>
<p>Actually though, on Win32, heap allocations are all at least 16-byte aligned (IIRC), so you should never &quot;really&quot; have to do this on VC for heap allocations.  If you have a weird operator new that does return pointers that aren&#8217;t 16-byte aligned, though, then you may have cause to worry.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206163">
				<div id="div-comment-206163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206163">
			August 26, 2004 at 9:03 am</a>		</div>

		<p>I already gave one example where you can get not-16-aligned data back.</p>
<p><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2004/02/03/66660.aspx" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2004/02/03/66660.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206183">
				<div id="div-comment-206183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206183">
			August 26, 2004 at 9:16 am</a>		</div>

		<p>In that case, you might be justified in being paranoid with VC&#8217;s operator new.</p>
<p>Perhaps the simplest solution would be to wrap operator new with a version that always returns an alignment suitable for the allocation request, up to say 16-byte alignment (like the Win32 heap manager seems to do).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206193">
				<div id="div-comment-206193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Luc Rooijakkers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206193">
			August 26, 2004 at 9:16 am</a>		</div>

		<p>But note that (at least under Visual C++ 6) the &quot;new BYTE[cb]&quot; variant will return 16-byte aligned memory, so the example above is safe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206203">
				<div id="div-comment-206203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206203">
			August 26, 2004 at 9:32 am</a>		</div>

		<p>Don&#8217;t rely on heap alignments. In case you think this can&#8217;t bite on 32-bit systems, see <a target="_new" href="http://support.microsoft.com/default.aspx?kbid=317898" rel="nofollow">http://support.microsoft.com/default.aspx?kbid=317898</a>. The WebClass runtime contained an alignment bug which caused peculiar non-reproducible inexplicable crashes &#8211; invariably when we were showing the website to management or the customer.</p>
<p>I managed to reproduce the error by turning on the page heap flag for dllhost.exe, which made it crash every time. Armed with this, we asked for the hotfix and got it (very promptly!)</p>
<p>I&#8217;m not sure the zero-length array is legal in C++ yet, so I wouldn&#8217;t try to use it. It might work as an MS extension in Visual C++ &#8211; I&#8217;m not sure what VC&#8217;s position on supporting the C99 standard is.</p>
<p>Some of these security structures have to be marshalled over RPC or LPC; it&#8217;s a lot easier if it&#8217;s a single block of data (not to mention cache coherency). I&#8217;ve recently been experimenting with LsaLogonUser which requires that the username, password and domain name directly follow the MSV1_0_INTERACTIVE_LOGON structure despite being pointed to from that structure &#8211; this isn&#8217;t documented!</p>
<p>Raymond, are you going to cover &#8216;Why are many structures in the Windows API size-prefixed?&#8217;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206213">
				<div id="div-comment-206213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206213">
			August 26, 2004 at 9:48 am</a>		</div>

		<p>Raymond wrote: &quot;Zero-length arrays did not become legal Standard C until 1999. Since Windows was around long before then, it could not take advantage of that functionality in the C language.&quot;</p>
<p>This is absolute nonsense. The Platform SDK has always required non-standard functionality &#8211; once it was &quot;near&quot; and &quot;far&quot;; now it&#8217;s things like &quot;__declspec&quot; and &quot;__stdcall&quot;. So far as I can see, the Platform SDK is designed to work with the Microsoft C/C++ compiler and other compiler vendors need to replicate MS extensions. Correct me if I&#8217;m wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206223">
				<div id="div-comment-206223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206223">
			August 26, 2004 at 9:49 am</a>		</div>

		<p>Jonathan Payne wrote: &quot;And you can&#8217;t allocate it using &#8216;new BYTE[sizeof(TOKEN_GROUPS) + sizeof(SID_AND_ATTRIBUTES)]&#8217; as you may get a badly aligned structure.&quot;</p>
<p>Actually you can. The standard says (section 18.4.1.1, paragraph 1) that operator new returns a block of memory that&#8217;s suitably aligned for any object of the given size.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206233">
				<div id="div-comment-206233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206233">
			August 26, 2004 at 9:58 am</a>		</div>

		<p>Mike Dimmick: Raymond already wrote something about this in <a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2003/12/12/56061.aspx" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2003/12/12/56061.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206273">
				<div id="div-comment-206273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ryan Myers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206273">
			August 26, 2004 at 1:48 pm</a>		</div>

		<p>RC: &quot;malloc(FIELD_OFFSET(TOKEN_GROUPS, Groups[NumberOfGroups]))&quot;</p>
<p>The first thing I thought was, doesn&#8217;t that point to Groups&#8217; base?  Then I noticed that it would actually return the address of the N+1th member, which is the overall size of the N-element struct&#8230; it works and it&#8217;s concise, but takes a bit of thinking.  There&#8217;s a dedicated macro for this, RTL_SIZEOF_THROUGH_FIELD(), but it would require using NumberOfGroups &#8211; 1.</p>
<p>It&#8217;s probably just best to throw hands up as nonintuitive either way.  ;p</p>
<p>BH: &quot;Actually you can. The standard says (section 18.4.1.1, paragraph 1) that operator new returns a block of memory that&#8217;s suitably aligned for any object of the given size.&quot;</p>
<p>I&#8217;m going to assume that you&#8217;re referring to the second TOKEN_GROUPS which has only the DWORD in it.  If this is wrong, disregard.</p>
<p>Indeed &#8212; new will return a suitably aligned memory block for a TOKEN_GROUPS (a DWORD) plus SID_AND_ATTRIBUTES.  This entire article is devoted to the observation that the struct in question is larger than just those two members added together because of alignment padding.</p>
<p>SID_AND_ATTRIBUTES has a pointer in it.  As such, in order to USE that pointer, the pointer member has to be aligned on a boundary.  For that reason, allocing using FIELD_OFFSET() will guarantee this, by putting padding bytes between the DWORD in TOKEN_GROUPS and the start of the SID array.  You don&#8217;t get that guarantee by just adding sizes together.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206143">
				<div id="div-comment-206143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://msmvps.com/kernelmustard' rel='external nofollow' class='url'>Steve Dispensa</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206143">
			August 26, 2004 at 8:36 am</a>		</div>

		<p>There&#8217;s another caveat with structures declared that way.  One alternative might have been:</p>
<p>typedef struct _TOKEN_GROUPS {<br />
<br />    DWORD GroupCount;<br />
<br />    SID_AND_ATTRIBUTES *Groups;<br />
<br />} TOKEN_GROUPS, *PTOKEN_GROUPS;</p>
<p>This would still force Groups to be pointer-aligned, but it&#8217;s much less convenient when you think of argument marshalling.  </p>
<p>In driver development, developers are sometimes faced with sending arguments from user-mode to kernel-mode via a METHOD_BUFFERED IOCTL.  Structures with embedded pointers like this one represent anything from a security flaw waiting to happen to simply a PITA.  </p>
<p>A common structure that is complained about along these lines is:</p>
<p>typedef struct _UNICODE_STRING {<br />
<br />    USHORT Length;<br />
<br />    USHORT MaximumLength;<br />
<br />    PWSTR  Buffer;<br />
<br />} UNICODE_STRING;</p>
<p>Even if you allocate your character buffer immediately after this structure:</p>
<p>UNICODE_STRING s = malloc(sizeof(UNICODE_STRING) + numChars * sizeof(WCHAR));</p>
<p>you still have to initialize it with a pointer:</p>
<p>s-&gt;Buffer = s + 1;</p>
<p>which, once embedded into your structure, will cause havoc when your structure is double-buffered into its kernel-mode argument buffer, where all of the addresses of things are numerically different values.</p>
<p>And, even after all of that, it still might crash for alignment reasons &#8211; UNICODE_STRING happens to end with a pointer, but imagine something that ended with a CHAR &#8211; if you did the above trick with a single allocation, your WSTR buffer would start on an odd boundary.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206303">
				<div id="div-comment-206303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ryan Myers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206303">
			August 26, 2004 at 5:09 pm</a>		</div>

		<p>Oh, one other bit &#8212; if you&#8217;re using C++, the new operator knows the type you&#8217;re allocating FOR, so it can guarantee alignment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206313">
				<div id="div-comment-206313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ryan Myers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206313">
			August 26, 2004 at 5:16 pm</a>		</div>

		<p>I guess I should be more careful about checking the Standards before commenting; it turns out that under C99, at least, malloc() also guarantees a base address that uses universal alignment (read: the largest alignment-requirement of any intrinsic type), so malloc() should be safe in Ken&#8217;s case above.</p>
<p>_aligned_alloc() should be used when you want to align on a smaller alignment requirement, i.e. for when you&#8217;re hand-tuning.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206323">
				<div id="div-comment-206323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206323">
			August 26, 2004 at 5:16 pm</a>		</div>

		<p>Ken: yes and no. For all the standard types, this is the correct way to do it. If you use any types that have __declspec(align) like if you&#8217;re doing any SSE programming, you need to use _aligned_malloc instead.</p>
<p>On a side note, be careful when using __declspec(align) because all fundamental assumptions behind C go out the window when using __declspec(align):</p>
<p>struct foo {<br />
<br /> __declspec(align(16)) char ch;<br />
<br />};</p>
<p>sizeof(foo) == 16 on MS, == 1 on Intel.<br />
<br />sizeof(foo[2]) == 32 on MS, == 2 on Intel.</p>
<p>struct foo2 {<br />
<br /> __declspec(align(16)) char ch;<br />
<br /> __declspec(align(16)) char ch2;<br />
<br />};</p>
<p>sizeof(foo2) == 17 on both<br />
<br />sizeof(foo2[2]) == 64 on both</p>
<p>It&#8217;s awesome to see rand() with constant seeds being used in sizeof() calculations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206253">
				<div id="div-comment-206253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206253">
			August 26, 2004 at 11:03 am</a>		</div>

		<p>While it&#8217;s true that the SDK has always required some nonstandard stuff, it tries to avoid *gratuitous* nonstandard stuff. Especially stuff that might conflict with a future version of the language (like zero-length arrays would have).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206333">
				<div id="div-comment-206333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.winehq.com' rel='external nofollow' class='url'>Steven Edwards</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206333">
			August 26, 2004 at 6:40 pm</a>		</div>

		<p>Thanks Raymond I think I understand the issue a little better now. We&#8217;ve hit bugs that I guess are related to this in Wine when generating code to be compiled for both MS_VC and Mingw-gcc. To quote Francois:</p>
<p>&quot;Running the generated tests on Windows I found a couple of alignment<br />
<br />issues.</p>
<p>Apparently gcc thinks that 64bit integers only need to be aligned on 4<br />
<br />byte boundaries while MSVC aligns them on 8 byte boundaries. What I<br />
<br />don&#8217;t understand is that we have already told gcc to align ULONGLONG and<br />
<br />DWORDLONG types on 8 byte boundaries but this seems to have no effect on<br />
<br />structure fields, or the structures themselves.</p>
<p>So I had to add some packing and DECLSPEC_ALIGN directives to get the<br />
<br />right effect but I must admit this is still a bit mysterious to me&#8230;.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206263">
				<div id="div-comment-206263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206263">
			August 26, 2004 at 12:53 pm</a>		</div>

		<p>5.3.4/10 &quot;For arrays of char and unsigned char, the difference between the result of the new-expression and the address returned by the allocation function shall be an integral multiple of the most stringent alignment requirement (3.9) of any object type whose size is no greater than the size of the array being created.&quot;</p>
<p>The complex wording it there to allow an implementation to stick padding for its own information or align it on a WORD boundary if you allocate BYTE[2]. So it&#8217;s safe as long as you can guarantee Microsoft will never change BYTE to be typedeffed to anything other than unsigned char (say they change it to unsigned __int8 where this is a different type than unsigned char on Intel&#8217;s compiler).</p>
<p>I personally would just use void *mem = ::operator new(size/*, std::nothrow*/) or just plain old malloc and be done with it.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206363">
				<div id="div-comment-206363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206363">
			August 26, 2004 at 7:57 pm</a>		</div>

		<p>8/26/2004 5:16 PM asdf<br />
<br />describes things that look like bugs in Intel&#8217;s compiler.</p>
<p>Technically the described behavior doesn&#8217;t render Intel&#8217;s compiler non-conforming, because __declspec is in the category of identifiers reserved to the implementation and the implementation can do whatever it pleases (e.g. compile Fortran and complain if your program isn&#8217;t Fortran).</p>
<p>Practically speaking, since it seems that Intel&#8217;s compiler understands Microsoft&#8217;s meaning of __declspec(align()), it does look like an Intel bug.  A struct&#8217;s size has to be adjusted so that an array of those structs will have total size matching the number of elements times the struct&#8217;s size.  Although examples are not normative, example 2 on page 80 explains it pretty well, and normative parts of the standard are not very far from there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206283">
				<div id="div-comment-206283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Showman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206283">
			August 26, 2004 at 3:37 pm</a>		</div>

		<p>Is it always safe to create a standalone array of structures via malloc(N*sizeof(foo)), even if sizeof(foo) is not a factor of 8?</p>
<p>For example:<br />
<br />struct foo<br />
<br />{<br />
<br />    int x;<br />
<br />};</p>
<p>foo* pFoo = (foo*)malloc(10*sizeof(foo));<br />
<br />foo* pFoo1 = &amp;pFoo[1];<br />
<br />pFoo1-&gt;x = 4;  // Is this safe?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206293">
				<div id="div-comment-206293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ryan Myers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206293">
			August 26, 2004 at 4:53 pm</a>		</div>

		<p>It&#8217;s safe under x86 and x64 (AMD64/EM64T) because Windows or the processor will invisibly do an alignment fixup before the userspace app ever learns about what happened.  (Yes, alignment is a concern on Win32 when performance is critical.  Also, see the disclaimer below.)  Fixups are not free, but not amazingly horribly expensive either.</p>
<p>It may not be safe under IA64.  The fixup process is so expensive on Itanium that Windows disables it by default, and only enables it on a per-app basis.  (The app has to request it explicitly using SetErrorMode().)</p>
<p>Think of every type as having a number associated with it, called the alignment-requirement.  The CPU will raise an alignment fault if you attempt to access something whose offset is not a clean multiple of the alignment-requirement.  For intrinsic data types like int, float, etc. the alignment requirement is usually the same as the data type&#8217;s size; for structs/classes the alignment is the same as the largest alignment its members, and it adds padding between members to make sure that each member has its own alignment needs met, as well as padding after the last member to make sure the struct&#8217;s own alignment needs are met during array accesses.</p>
<p>So, the answer to your question is the same as the answer to this question: Does malloc() return aligned addresses?  And the answer to that is &quot;maybe.&quot;  There are two solutions for VC++:</p>
<p>* When declaring your array pFoo, use the __unaligned qualifier.  The compiler will insert code to handle unaligned accesses.  This is MUCH faster than using SetErrorMode() to do fixups, but not free.</p>
<p>* When grabbing memory for pFoo, use _aligned_alloc( 10 * sizeof(foo), __align_of(foo) ); to ensure that the base is aligned.</p>
<p>Disclaimer: FYI, there are some ways to confuse an x86 in such a way that it will generate an unfixable fault, using the SSE types.  But in general, if you&#8217;re using SSE, either the compiler is automatically generating it and it&#8217;ll hopefully do the right thing, or you&#8217;re handcoding it and you brought it on yourself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206373">
				<div id="div-comment-206373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://shire.symonds.net/~shivanan' rel='external nofollow' class='url'>HS</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206373">
			August 27, 2004 at 2:13 am</a>		</div>

		<p>I believe Ken Thompson called this behaviour &quot;Unwarranted chumminess with the compiler&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206613">
				<div id="div-comment-206613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jbn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206613">
			August 30, 2004 at 9:24 am</a>		</div>

		<p>note that in C++ you can do the same by overriding the placement new operator :</p>
<p>void *TOKEN_GROUPS::operator new(size_t sz, int NumberOfGroups) {<br />
<br /> return ::operator new(FIELD_OFFSET(TOKEN_GROUPS, Groups[NumberOfGroups])));<br />
<br />}</p>
<p>basically it&#8217;s just returning a block bigger than a TOKEN_GROUPS instance.<br />
<br />Then just invoke it as follows:</p>
<p>int n = 123; // whatever the NumberOfGroups must be<br />
<br />PTOKEN_GROUPS *p = new (n) PTOKEN_GROUPS();</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206753">
				<div id="div-comment-206753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206753">
			August 30, 2004 at 6:17 pm</a>		</div>

		<p>Oh, sorry I forgot that this is C++, and my citation of Example 2 on page 80 is in the 1999 C standard.  In the 2003 C++ standard, sizeof is on page 79 and there is no example, but there is normative wording &quot;When applied to a class, the result is the number of bytes in an object of that class INCLUDING ANY PADDING REQUIRED FOR PLACING THAT TYPE IN AN ARRAY&quot;.  Practically speaking it still looks like Intel&#8217;s compiler has a bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-206663">
				<div id="div-comment-206663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tardis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206663">
			August 30, 2004 at 11:47 am</a>		</div>

		<p>jbn: Just for the record, that&#8217;s not what&#8217;s usually meant by &quot;placement new&quot; (see <a target="_new" href="http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10" rel="nofollow">http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10</a>);  moreover, Roger Lipscombe mentioned earlier that it&#8217;s impossible to define new class members (like that operator new) after the fact.</p>
<p>Finally (assuming I remember correctly), easier would be to just define a<br />
<br />void* TOKEN_GROUPS::operator new[](size_t s) {&#8230;}<br />
<br />and do<br />
<br />PTOKEN_GROUPS *p=new TOKEN_GROUPS[n];<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206793">
				<div id="div-comment-206793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jbn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-206793">
			August 31, 2004 at 8:38 am</a>		</div>

		<p>Tardis: i think you are mistaken, the name &quot;placement new&quot; is used because the additionnal argument being passed typically is a memory location, but it may very well be anything you want.</p>
<p>I agree that it&#8217;s a problem that you can&#8217;t define new members after the fact, though.<br />
<br />It would however be possible to make the placement of the byte array customizable by passing around a placement manager object to the placement new &amp; to the constructor of that object.</p>
<p>Additionnally, using operator new[] is quite different, it&#8217;s used to allocate an array of PTOKEN_GROUPS in your example, which is not the same as allocating a single object but with a variable size&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-209613">
				<div id="div-comment-209613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209613">
			September 13, 2004 at 4:32 am</a>		</div>

		<p>&quot;Zero-length arrays did not become legal Standard C until 1999. Since Windows was around long before then, it could not take advantage of that functionality in the C language. &quot;<br />
<br />WTF are you talking about?</p>
<p>EVENTSFORLOGFILE? PACKEDEVENTINFO? CLUSPROP_BINARY? PROPERTYINSTEX? WNODE_ALL_DATA? WNODE_SINGLE_INSTANCE? WNODE_SINGLE_ITEM?<br />
<br />WNODE_METHOD_ITEM? WNODE_EVENT_REFERENCE? WMIREGINFOW? </p>
<p>It might be non-standard.  But it&#8217;s useful, and makes it easier to get things correct (the size of buffer to allocate is just sizeof(structure) + sizeof(buffer)).  Win32 does it in a number of places.  It should do it across the board.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-209643">
				<div id="div-comment-209643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209643">
			September 13, 2004 at 7:42 am</a>		</div>

		<p>You&#8217;ve never had to deal with backwards compatibility have you. The answer to this is obvious:</p>
<p>If a structure was originally defined with a size of [1] then it must keep the original definition.</p>
<p>// Since TOKEN_GROUPS already contains 1<br />
<br />// SID_AND_ATTRIBUTES, we need<br />
<br />// NumberOfGroups-1 more.<br />
<br />PTOKEN_GROUPS TokenGroups = malloc(sizeof(TOKEN_GROUPS) + (NumberOfGroups &#8211; 1) * sizeof(SID_AND_ATTRIBUTES));</p>
<p>If TOKEN_GROUPS were redefined to have [], then this code would have a buffer overrun.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-209703">
				<div id="div-comment-209703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209703">
			September 13, 2004 at 10:17 am</a>		</div>

		<p>&quot;You&#8217;ve never had to deal with backwards compatibility have you.&quot;<br />
<br />On the contrary.  I suffer with backwards compatibility every time I have to write raw Win32 programs.  The refusal to ever fix anything just makes writing new code much harder.</p>
<p>&quot;The answer to this is obvious: &quot;<br />
<br />and wrong, as obvious answers so frequently are.</p>
<p>&quot;If a structure was originally defined with a size of [1] then it must keep the original definition. &quot;<br />
<br />Rubbish.  Change the definition when someone #defines the OS version to be (say) 0x0501 or similar.  You already change other structure definitions depending on the defined OS version.  Why not change these ones too?  Or, hell, you could even do something really helpful (god forbid) and have a unsizedarraymembers #define to toggle the behaviour.  This would let old code work whilst still permitting new code to be clean.</p>
<p>And why does old code need to be built against the latest and greatest Platform SDK in the first place?  I mean, the whole argument for this backwards compatibility crap is that old code can&#8217;t be fixed/rewritten because it&#8217;s no longer maintained.  If something&#8217;s being rebuilt anyway, it can be changed anyway.</p>
<p>I believe there are some structures where one couldn&#8217;t switch (because the OS expects the &quot;size&quot; member of the structure to exclude the first array member), but may be mistaken.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-209713">
				<div id="div-comment-209713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209713">
			September 13, 2004 at 10:22 am</a>		</div>

		<p>In any case, you miss the bigger point&#8211;that you&#8217;re wrong.  Windows uses unsized last array members, did so prior to C99, and requires support for them even when compiling as C++.  As such their inconsistent use is even more annoying.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-209733">
				<div id="div-comment-209733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209733">
			September 13, 2004 at 10:30 am</a>		</div>

		<p>&quot;On the contrary. I suffer with backwards compatibility every time I have to write raw Win32 programs.&quot;</p>
<p>I was referring to producing backwards compatiblity, not consuming it. Rewrite a header file so that code compiled with the old header file interoperates with code compiled with the new header file, and so that somebody can take code written for the old header file, recompile with the new header file, and still work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-209853">
				<div id="div-comment-209853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209853">
			September 13, 2004 at 4:29 pm</a>		</div>

		<p>&quot;what on earth makes you think I should care&quot;</p>
<p>Um because that was the issue you were responding to? I was explaining why the OS can&#8217;t change the system header files.</p>
<p>FLEXIBLE_ARRAYS would work. Then the hard part of coordinating all the dozens of groups that produce header files to get them to follow it. (And if a single group misses a spot, I&#8217;m sure you&#8217;ll be all over it.)</p>
<p>The Hungarian-or-not is a separate issue which I will add to the topics list.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-209723">
				<div id="div-comment-209723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209723">
			September 13, 2004 at 10:25 am</a>		</div>

		<p>&quot;Change the definition when someone #defines the OS version to be (say) 0x0501 or similar.&quot; </p>
<p>It&#8217;s one thing to change a definition to expose new functionality. Developers would turn on the #define and the new stuff becomes available. (Sometimes at the cost of no longer running on downlevel systems.) </p>
<p>But it&#8217;s another thing to change a definition so that *previously correct code compiles without a compiler warning even though it is now incorrect*. </p>
<p>Yes it&#8217;s inconsistent. That&#8217;s what happens when there are dozens of independent groups writing header files.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-209843">
				<div id="div-comment-209843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-209843">
			September 13, 2004 at 4:19 pm</a>		</div>

		<p>&quot;I was referring to producing backwards compatiblity, not consuming it.&quot;<br />
<br />Of course you were.  But what on earth makes you think I should care?</p>
<p>&quot;Rewrite a header file so that code compiled with the old header file interoperates with code compiled with the new header file, and so that somebody can take code written for the old header file, recompile with the new header file, and still work.&quot;<br />
<br />I&#8217;ve already suggested how you might do that.  Have a #define (say &quot;FLEXIBLE_ARRAYS&quot;) that if off uses the TypeName[1] crap that we hate; if on uses the TypeName[] stuff that&#8217;s so much more convenient.</p>
<p>There are other #defines that don&#8217;t actually influence the headers but just make them easier to deal with (STRICT), so I don&#8217;t think adding a new one would be the end of the world.</p>
<p>&quot;Yes it&#8217;s inconsistent. That&#8217;s what happens when there are dozens of independent groups writing header files. &quot;</p>
<p>I know coding standards are a pain an&#8217; all, but come on.  You really can&#8217;t enforce *any* rules?</p>
<p>It might be nice if you could be consistent about whether to use hungarian or not for struct members.  Fixing that wouldn&#8217;t even be a silently breaking change, so updating code would be mechanical and reliable process.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210013">
				<div id="div-comment-210013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-210013">
			September 14, 2004 at 7:06 am</a>		</div>

		<p>&quot;Um because that was the issue you were responding to? I was explaining why the OS can&#8217;t change the system header files. &quot;<br />
<br />The issue I&#8217;m responding to is, why as a developer do I have to suffer this kind of crap?</p>
<p>&quot;FLEXIBLE_ARRAYS would work. Then the hard part of coordinating all the dozens of groups that produce header files to get them to follow it. (And if a single group misses a spot, I&#8217;m sure you&#8217;ll be all over it.) &quot;<br />
<br />Well shit, if it&#8217;s that hard, hire me and I&#8217;ll do the job for you.</p>
<p>&quot;The Hungarian-or-not is a separate issue which I will add to the topics list. &quot;<br />
<br />I don&#8217;t think it&#8217;s a separate issue, really, is it?  It seems to be the same issue&#8211;there is a great lack of conformity amongst the Win32 headers, as different headers do the same thing in different ways.</p>
<p>This might make sense from the OS developer&#8217;s point of view, because you have different groups of developers working on different areas.  But it&#8217;s immensely frustrating as an application developer, because we don&#8217;t have the luxury of just sticking to a particular subset of the API.  We&#8217;ve gotta use a cross-section of it, which means we have to put up with the inconsistency.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-211773">
				<div id="div-comment-211773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Thompson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-211773">
			September 17, 2004 at 2:50 pm</a>		</div>

		<p>&quot;The issue I&#8217;m responding to is, why as a developer do I have to suffer this kind of crap?&quot;</p>
<p>No one is making you. Go write for something that makes your boat float.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-428333">
				<div id="div-comment-428333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/10/06/796395.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-428333">
			October 6, 2006 at 10:00 am</a>		</div>

		<p>Belated answers to exercises and other questions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-710963">
				<div id="div-comment-710963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://aonprog.wordpress.com/2009/02/23/file-minifilter-part4-sending-huge-data-from-kernel-to-user-mode-efficiently-using-variable-sized-structures/' rel='external nofollow' class='url'>File Minifilter Part4: Sending huge data from kernel to user mode efficiently using variable-sized structures &laquo; On Programming Software</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040826-00/?p=38043#comment-710963">
			February 23, 2009 at 12:33 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://aonprog.wordpress.com/2009/02/23/file-minifilter-part4-sending-huge-data-from-kernel-to-user-mode-efficiently-using-variable-sized-structures/" rel="nofollow">http://aonprog.wordpress.com/2009/02/23/file-minifilter-part4-sending-huge-data-from-kernel-to-user-mode-efficiently-using-variable-sized-structures/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>