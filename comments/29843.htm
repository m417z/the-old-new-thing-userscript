<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (30)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-416933">
				<div id="div-comment-416933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-416933">
			September 6, 2006 at 10:11 am</a>		</div>

		<p>A disassembler would need to know this.</p>
<p>Vorn</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-416943">
				<div id="div-comment-416943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-416943">
			September 6, 2006 at 10:22 am</a>		</div>

		<p>A disassembler could probably guess. Just look for lots of AMD64-specific opcodes in the code segment. As I understand it, they&#8217;re gibberish constants to an x86.</p>
<div CLASS=post>[<i>If a disassembler doesn&#8217;t even know what instruction set to decode it&#8217;s already in a major world of hurt. I could give you an ia64 byte stream &#8211; good luck with that. Presumably the disassembler has an external cue &#8211; you may have told it explicitly, it may have inferred it from the module header, it may have a live process to extract context from. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-416953">
				<div id="div-comment-416953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-416953">
			September 6, 2006 at 10:27 am</a>		</div>

		<p>Couldn&#8217;t a disassembler just look at whether it&#8217;s a PE32 or PE64 executable or DLL file? &nbsp;I.e., look at the PE header to see what processor it&#8217;s intended to run on.</p>
<p>I know ELF binaries have this, so I&#8217;d be really surprised if PE didn&#8217;t&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-416963">
				<div id="div-comment-416963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-416963">
			September 6, 2006 at 11:14 am</a>		</div>

		<p>If you distribute the source code, you are no longer the person compiling it. Not everybody agrees with Microsoft&#8217;s vision of the &quot;One True Software Corporation&quot;.</p>
<p>But it&#8217;s still a silly question. Every compiler defines similar symbols for this. If you don&#8217;t want to be tied to a specific compiler, then compilers also define symbols indentifying themselves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-416973">
				<div id="div-comment-416973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-416973">
			September 6, 2006 at 11:16 am</a>		</div>

		<blockquote><p>
  &gt; As I understand it, they&#8217;re gibberish constants to an x86.</p>
<p>Most AMD64 instructions are not gibberish if interpreted as x86 code because it was mostly a reuse of legacy opcodes (for example one-byte versions of INC and DEC, or the BCD arithmetic opcodes). Of course this does not include in-code constants, but I doubt it&#8217;s an easy task to tell between x86 and AMD64 instruction sets only by reading the stream. Reading the PE header is certainly easier.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-416983">
				<div id="div-comment-416983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-416983">
			September 6, 2006 at 11:21 am</a>		</div>

		<p>If that&#8217;s the case &#8211; is there an API for reading the PE header and telling what architecture the program runs on? &nbsp;If so, then the answer to the original query is actually yes.</p>
<p>Vorn</p>
<div CLASS=post>[<i>Even if there were such a function, it would be overkill. You already know the answer. You don&#8217;t need to ask somebody to tell you something you already know. It&#8217;s like having a function that tells you what language your program was written in. You already know what language your program was written in since <u>you wrote it in that language</u>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-416993">
				<div id="div-comment-416993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-416993">
			September 6, 2006 at 11:26 am</a>		</div>

		<p>I think this is just another side-effect of the &quot;Visual Studio Makes You Stupid&quot; phenomenon. Even Larry Osterman agrees:<br />
<br /><a rel="nofollow" target="_new" href="http://blogs.msdn.com/larryosterman/archive/2005/10/26/485415.aspx" rel="nofollow">http://blogs.msdn.com/larryosterman/archive/2005/10/26/485415.aspx</a></p>
<p>Developers raised on Project Properties often don&#8217;t understand the build process, it&#8217;s handled automagically by VS. Those command line options and defines that they see in Properties are just gobbledegook. It&#8217;s not clear to them whether something happens at VS autocomplete, compile, link, or run time, they just know it happens. </p>
<p>By hiding a lot of the details, VS makes it possible for these people to overcome their defective/incomplete models of the programming environment and write C++ that kinda sorta works. Rejoice, for this provides much blog material for The Old New Thing.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417023">
				<div id="div-comment-417023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417023">
			September 6, 2006 at 11:53 am</a>		</div>

		<p>What if you didn&#8217;t build all of the app?<br />
<br />What if you want to know at runtime what architecture a dll was compiled against?</p>
<p>Obviously the compiler target is inherently compiler specific. But some people may find it useful to know what instructions may be contained in a dll.</p>
<p>This may be especially true for people who wish to load some plugin dlls but don&#8217;t want any non 64bit ones in the mix to trigger WOW64 (this is therefore less a runtime query and more of a file based one but the principle of determining the ISA, pointer length, endian (whatever) assumptions, of some code you did not compile.<br />
<br />Obviously the answer will, in many cases, be unless you know how it was built you can&#8217;t without trying it!.</p>
<div CLASS=post>[<i>Are you saying somebody took your x86 library and linked it into an x64 binary? How does that work? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417033">
				<div id="div-comment-417033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arlie Davis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417033">
			September 6, 2006 at 11:55 am</a>		</div>

		<p>Most of you are completely missing the point. &nbsp;This isn&#8217;t about analyzing some other module to see what language it is written in, or what architecture it targets. &nbsp;This is about when you know the target architecture of the code you are currently writing.</p>
<p>Look at the examples &#8212; it&#8217;s so obvious. &nbsp;The target architecture is decided when you compile something. &nbsp;The compiler defines preprocessor macros (<em>X86</em>, <em>AMD64</em>, whatever) precisely so your code can choose different behaviors for different targets. &nbsp;Your code ALREADY knows (or rather, you, as a competent developer, should realize that these macros are available to you) the target architecture!</p>
<p>This is like sizeof(INT_PTR). &nbsp;It&#8217;s decided when the compiler runs, and the build of the compiler decides the value. &nbsp;sizeof(INT_PTR), no matter what its value, will not change while your program is running. &nbsp;That&#8217;s why sizeof is an intrinsic language keyword, not a C runtime function like GetSizeOfIntPtr().</p>
<p>This has NOTHING to do with whether you are using VC++, Notepad, or even whether you&#8217;re developing on Windows or a completely different platform!</p>
<p>The post was not about disassemblers, or any other software where one module analyzes a different module. &nbsp;The post was about a module choosing its own behavior, based on the target architecture.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417053">
				<div id="div-comment-417053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417053">
			September 6, 2006 at 12:27 pm</a>		</div>

		<p>&quot;If you distribute the source code, you are no longer the person compiling it.&quot;</p>
<p>Umm, who cares? </p>
<p>#if defined(<em>X86</em>)<br />
<br /> &nbsp;printf(&quot;I was compiled for the x86!&quot;);<br />
<br />#endif</p>
<p>Problem solved.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417113">
				<div id="div-comment-417113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417113">
			September 6, 2006 at 1:58 pm</a>		</div>

		<p>I&#8217;d like to take the opportunity to discourage using the ifdefs in Raymond&#8217;s article more than once in an app. If you use then to enable capability style defines, then adding new architectures and capabilities will be a lot easier, and there will be less and more localized platform specific code.</p>
<p>My guess for the original question is that this is some sort of optimization question &#8211; you need different codepaths for an mp4 encoder on x86-64 vs. intel if you want the best speed. The alternative, behavioral changes, makes no sense at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417123">
				<div id="div-comment-417123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BarryTannenbaum</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417123">
			September 6, 2006 at 2:38 pm</a>		</div>

		<p>A number of people asked whether you can tell what architecture a module was built for by looking at the header. &nbsp;The answer is &quot;Of course you can&quot;. &nbsp;It&#8217;s specified in the &quot;Machine&quot; field of the IMAGE_FILE_HEADER structure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417153">
				<div id="div-comment-417153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417153">
			September 6, 2006 at 4:31 pm</a>		</div>

		<p>Some people, like id software, check endian-ness at run-time, too. It&#8217;s kind of pointless, and they then have to use indirect calls for no good reason. I don&#8217;t think Visual Studio made them that stupid, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417163">
				<div id="div-comment-417163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mihai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417163">
			September 6, 2006 at 4:42 pm</a>		</div>

		<p>&lt;&lt;Rejoice, for this provides much blog material for The Old New Thing. &gt;&gt;<br />
<br />Or for &quot;The Daily WTF&quot; (<a rel="nofollow" target="_new" href="http://thedailywtf.com" rel="nofollow">http://thedailywtf.com</a> :-)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417173">
				<div id="div-comment-417173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.ookii.org' rel='external nofollow' class='url'>Sven Groot</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417173">
			September 6, 2006 at 5:14 pm</a>		</div>

		<p>While it&#8217;s true that for unmanaged code you don&#8217;t need this, in the managed world you might. A .Net 2.0 assembly which has the &quot;MSIL&quot; target architecture (the &quot;Any CPU&quot; setting in Visual Studio 2005) it&#8217;ll run as x86 on an x86 OS, as native x64 on an x64 OS, and as native ia64 on an Itanium OS.</p>
<p>So here the question of how to determine the architecture at runtime is a valid one. If all you care about is 32 vs 64 bit it&#8217;s easy: just check the value of System.IntPtr.Size. But if you want to tell the difference between x64 and ia64, you&#8217;re out of luck with the .Net BCL. As far as I know the only way to do it would be to use PInvoke to call GetSystemInfo or GetNativeSystemInfo.</p>
<p>The same technique would apply to native code as well, a combination of sizeof(void*) and Get(Native)SystemInfo would do the trick. But as Raymond pointed out, there&#8217;s no reason to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417223">
				<div id="div-comment-417223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thras</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417223">
			September 6, 2006 at 6:40 pm</a>		</div>

		<p>I guess that some people have never written cross-platform C++ libraries.</p>
<p>Take a look at &lt;a href=&quot;<a rel="nofollow" target="_new" href="http://www.boost.org&quot;&gt;Boost&lt;/a&gt;" rel="nofollow"></a><a href="http://www.boost.org&quot;&gt;Boost&lt;/a&#038;gt" rel="nofollow">http://www.boost.org&quot;&gt;Boost&lt;/a&#038;gt</a>; for a good example. Their libraries are absolutely littered with these sorts of #ifdefs &#8212; that&#8217;s the only way to write cross-platform code. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417233">
				<div id="div-comment-417233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417233">
			September 6, 2006 at 6:45 pm</a>		</div>

		<p>&quot;I wish to LoadLibrary() on all of these except if I can know before hand that the library is 32 or 64 bit capable in advance. &quot;</p>
<p><a rel="nofollow" target="_new" href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx" rel="nofollow">http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417073">
				<div id="div-comment-417073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417073">
			September 6, 2006 at 12:59 pm</a>		</div>

		<p>[Are you saying somebody took your x86 library and linked it into an x64 binary? How does that work? -Raymond] </p>
<p>I meant something along the lines of: </p>
<p>I have an app which is 64bit. it has a directory where plugin dlls can be dumped. I wish to LoadLibrary() on all of these except if I can know before hand that the library is 32 or 64 bit capable in advance. <br />I do not wish to simply call load library and have it fail (since I am not sure I will be able to determine if the fail was due to the dll being fundamentally unsound or if it is simply the wrong bitness) <br />say I want to dump some dll&#8217;s in but load only IA64 compiled ones instead of AMD64&#8230; </p>
<p>I know this is a contrived example which would be easily solved by separate directories or naming convention but the concept is rational. To want to know before invoking LoadLibrary on a dll what ISA it targets (and in the case of AMD64 and IA64 it is not even a question if bitness) </p>
<p>I wholly agree the the question as framed by Raymond (since he certainly knows how to be exact) is *not* asking this since it explicitly says &#8216;my program&#8217; hence reasonable assumption that source and/or linkage entirely known at compilation and under your control. </p>
<p>What I am talking about is &#8216;can you know, from a dll, whether it *definitely cannot* be loaded via LoadLibrary via a system call or simple parsing of the header. </p>
<p>The answer &#8216;no&#8217; is perfectly acceptable &#8211; I just thought it was a reasonable question. </p>
<p>Coming more from a managed, high level of introspection background I find the question an interesting one.</p>
<div CLASS=post>[<i>Well, okay, but that&#8217;s a different problem from the one posed in this article. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417253">
				<div id="div-comment-417253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">db48x</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417253">
			September 6, 2006 at 8:10 pm</a>		</div>

		<p>Yea, it&#8217;s pretty common for a video player to have different decoding routines for different instruction sets (even if they&#8217;re not actually written in assembly). That way you can distribute a binary with all of them, and choose the the most appropriate one at run time, rather than having to distribute several different versions of the application, one for each processor type.</p>
<p>This is a good example of why you need to state your goal when asking the question though, because the easy answer (compile time preprocessor checks) won&#8217;t work for you.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417283">
				<div id="div-comment-417283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417283">
			September 6, 2006 at 11:16 pm</a>		</div>

		<p>ID Software probobly check for endianness so their code is portable to other platforms.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417313">
				<div id="div-comment-417313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417313">
			September 7, 2006 at 12:03 am</a>		</div>

		<blockquote><p>
  You already know what your target<br />
  <br />&gt; architecture is because you compiled it<br />
  <br />&gt; yourself!</p>
<p>I have almost nothing to add after others&#8217; comments. &nbsp;Almost.</p>
<p>&gt; Sometimes the questions I see make me shake<br />
  <br />&gt; my head in wonderment.</p>
<p>Yeah, that needed adding. &nbsp;It&#8217;s not just for questions.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417333">
				<div id="div-comment-417333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mike.filespanker.com/' rel='external nofollow' class='url'>Mike Owens</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417333">
			September 7, 2006 at 1:56 am</a>		</div>

		<blockquote><p>
  It so happens that the Microsoft Visual C++ compiler<br />
  <br />&gt; defines several symbols for you automatically<br />
  <br />&gt; (assuming you&#8217;re not running the compiler in<br />
  <br />&gt; &quot;strict ANSI compliance mode&quot;). If you&#8217;re willing<br />
  <br />&gt; to tie yourself to the Microsoft Visual C++<br />
  <br />&gt; compiler, you can use those symbols.</p>
<p>ISO C++ 17.4.3.1.2: &quot;Each name that contains a double underscore (&quot;__&quot;) or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.&quot;</p>
<p>Visual C++ would be fully justified in defining these symbols in even the strictest of ISO/ANSI compliant modes. &nbsp;GCC and Intel C++ have similar macros defined in their strict modes.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417343">
				<div id="div-comment-417343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417343">
			September 7, 2006 at 3:20 am</a>		</div>

		<p>Thanks for the PECOFF link &#8211; very interesting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417433">
				<div id="div-comment-417433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://denisbider.blogspot.com' rel='external nofollow' class='url'>denis bider</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417433">
			September 7, 2006 at 6:56 am</a>		</div>

		<p>&quot;Visual C++ would be fully justified in defining these symbols in even the strictest of ISO/ANSI compliant modes. &nbsp;GCC and Intel C++ have similar macros defined in their strict modes.&quot;</p>
<p>It would be justified, but if the purpose of the ISO/ANSI strict mode is to make sure the code would compile anywhere, leaving no room for doubt, then letting these macros be defined would violate the purpose of that mode.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417903">
				<div id="div-comment-417903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417903">
			September 7, 2006 at 9:00 pm</a>		</div>

		<p>Thursday, September 07, 2006 6:56 AM by denis bider<br />
<br />&gt;&gt; Visual C++ would be fully justified in<br />
<br />&gt;&gt; defining these symbols in even the strictest<br />
<br />&gt;&gt; of ISO/ANSI compliant modes. &nbsp;GCC and Intel<br />
<br />&gt;&gt; C++ have similar macros defined in their<br />
<br />&gt;&gt; strict modes.<br />
<br />&gt;<br />
<br />&gt; It would be justified, but if the purpose of<br />
<br />&gt; the ISO/ANSI strict mode is to make sure the<br />
<br />&gt; code would compile anywhere, leaving no room<br />
<br />&gt; for doubt, then letting these macros be<br />
<br />&gt; defined would violate the purpose of that<br />
<br />&gt; mode.</p>
<p>Would not. &nbsp;The entire meaning of the ISO/ANSI statement that that the implementation gets to use those kinds of identifiers is that the implementation gets to use those kinds of identifiers.</p>
<p>A program that inspects those identifiers will almost surely be a non-strictly-conforming program, but that&#8217;s a nearly irrelevant statement about the program not about the implementation. &nbsp;Strictly conforming programs are useless for practical purposes even if they&#8217;re longer than 5 lines.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-417923">
				<div id="div-comment-417923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-417923">
			September 7, 2006 at 10:12 pm</a>		</div>

		<blockquote><p>
  ID Software probobly check for endianness so their code is portable to other platforms</p>
<p>At compile time each call would trivially inline to a handful of instructions or nothing. The way they did it at runtime required more effort to write, and gets them nothing for it.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-418043">
				<div id="div-comment-418043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Boof</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-418043">
			September 8, 2006 at 6:06 am</a>		</div>

		<p>Re-reading the entry of the blog the question Mr. Chen quotes and the problem Mr. Chen says is being solved don&#8217;t properly add up.</p>
<p>The quote asks what architecture it was compiled for. It does not say what it was compiled on. I have a 32 bit processor but can compile 64 code because the compiler allows me to. I can&#8217;t test it myself.</p>
<p>Mr. Chen says &#8220;This person wants the program to detect whether it was compiled with an x86 compiler, an ia64 compiler, an amd64 compiler, or whatever.&#8221; &#8211; notice the compiled with.</p>
<p>.Net 2.0 appears to support a ProcessorArchitecture enumation.</p>
<div CLASS=post>[<i>By &#8220;compiled with an XYZ compiler&#8221; I mean &#8220;compiled with a compiler that generates code intended to run on an XYZ system&#8221;. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-418073">
				<div id="div-comment-418073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-418073">
			September 8, 2006 at 6:57 am</a>		</div>

		<p>Boof:<br />
<br />&gt; Mr. Chen says &quot;This person wants the program to<br />
<br />&gt; detect whether it was compiled with an x86<br />
<br />&gt; compiler, an ia64 compiler, an amd64 compiler, &gt; or whatever.&quot; &#8211; notice the compiled with. </p>
<p>This sounds an awful lot like arguing over semantics &#8211; I read the quote to mean a compiler that targets x64, a compiler that targets ia64, a compiler that targets amd64 or whatever; in which case the argument stands.</p>
<p>If you are compiling for a target platform you know the target platform you are compiling for &#8211; if you don&#8217;t then your problems are far worse than any simple API call can solve.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-418383">
				<div id="div-comment-418383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pagetable.com/' rel='external nofollow' class='url'>Myria</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-418383">
			September 9, 2006 at 12:24 am</a>		</div>

		<p>Matt&#8217;s question about DLLs reminded me of something.</p>
<p>The kernel actually prohibits you from calling NtMapViewOfSection on a 32 bit image section into a 64 bit process. &nbsp;This restriction is completely arbitrary and pointless, especially since 64 bit code in a 32 bit process is allowed to map image sections of either type.</p>
<p>It should be user mode&#8217;s problem whether something &quot;makes sense&quot;; the kernel should let user mode do whatever it wants that doesn&#8217;t violate system integrity.</p>
<p>Melissa</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-419383">
				<div id="div-comment-419383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mobile</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060906-07/?p=29843#comment-419383">
			September 12, 2006 at 4:15 pm</a>		</div>

		<p>On Windows Mobile 5.0 a process can&#8217;t read it&#8217;s own exe file. Thus a process cannot use the image to determine it&#8217;s architecture.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>