<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (47)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-384253">
				<div id="div-comment-384253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Ritchie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384253">
			May 24, 2006 at 10:31 am</a>		</div>

		<p>I believe explicit should be on every constructor (with parameters) when is written. &nbsp;Sort of like TDD (write your code to only do what it needs to do until it passes the current test), pull it off when you need to use that c&#8217;tor as a conversion constructor.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384263">
				<div id="div-comment-384263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Moi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384263">
			May 24, 2006 at 10:44 am</a>		</div>

		<p>Thanks, you just ruined my favourite interview question :-)</p>
<p>Peter &#8211; it is only necessary on constructors taking exactly one parameter (as Raymond said in his article, to be fair), so putting it on &quot;every constructor (with parameters)&quot; is going a bit far.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384273">
				<div id="div-comment-384273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384273">
			May 24, 2006 at 10:52 am</a>		</div>

		<p>Been a while since I&#8217;ve done any C++, but is the &quot;explicit&quot; keyword (and the compiler behavior that makes it necessary) part of the C++ standard? &nbsp;It sounds like it is, but I&#8217;ve never heard of it before. &nbsp;(Though since it&#8217;s been a while, that doesn&#8217;t mean much.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384343">
				<div id="div-comment-384343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.parkscomputing.com/' rel='external nofollow' class='url'>Paul M. Parks</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384343">
			May 24, 2006 at 11:55 am</a>		</div>

		<p>Yes, the &quot;explicit&quot; specifier is standard. Section 12.3.1.</p>
<p>PMP<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384353">
				<div id="div-comment-384353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alyosha`</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384353">
			May 24, 2006 at 12:42 pm</a>		</div>

		<p>For me, the red flag is not the lack of &quot;explicit&quot;. &nbsp;It&#8217;s the large buffer inside a class. &nbsp;Most classes with large, fixed-sized buffers don&#8217;t need them &#8230; they probably would benefit from string or vector instead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384373">
				<div id="div-comment-384373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://gammawave.wordpress.com' rel='external nofollow' class='url'>Patrick Broman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384373">
			May 24, 2006 at 1:42 pm</a>		</div>

		<p>Alyosha, you kind of missed the point. </p>
<p>Raymond&#8217;s BigBuffer class is clearly as contrived as the oops() function, only there to serve as an example of &quot;a class that has a fair ammount of statically allocated memory&quot;. A representation of the situations where large, fixed-size buffers are actually useful. </p>
<p>You might as well have pointed out that the oops() function is suspicous, since all it does is to call another function with a hardcoded parameter ;)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384423">
				<div id="div-comment-384423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://java.sun.com' rel='external nofollow' class='url'>Duke</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384423">
			May 24, 2006 at 4:09 pm</a>		</div>

		<p>Damn, I love Java.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384433">
				<div id="div-comment-384433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Soren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384433">
			May 24, 2006 at 4:17 pm</a>		</div>

		<p>Stuff like this is a major reason I don&#8217;t like C++. To use even the simplest features like construtors, you need to know and understand all minds of crap, like automatic conversions. I&#8217;ll take plain old C with a good utility library any day.</p>
<p>There are very few useful C++ features that don&#8217;t drag in lots of weird stuff, so the argument that &#8216;you can just use the parts of C++ that you understand&#8217; is bunk.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384483">
				<div id="div-comment-384483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">boxmonkey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384483">
			May 24, 2006 at 4:52 pm</a>		</div>

		<p>I don&#8217;t know about you Soren, but I will never understand minds of crap. ;)</p>
<p>I appreciate this post from Raymond, I didn&#8217;t know C++ behaved this way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384493">
				<div id="div-comment-384493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Some guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384493">
			May 24, 2006 at 5:01 pm</a>		</div>

		<p>The funny thing is that with &quot;plain old C with a good utility library&quot;, you still actually need to understand all of C and all of the utility library.</p>
<p>Hell, even with Java or C# you can write code that will work but run like a dead snail if you don&#8217;t understand what the memory manager is doing behind your back. (Java code written by people who fell for the lie that you don&#8217;t need to understand memory management is not pretty. C# code written by the same people isn&#8217;t any better.)</p>
<p>The only language where you can do high quality development work without understanding the intricate details of the compiler is &quot;english&quot;, as used by a manager when telling the coders what to do. (Well, perhaps&#8230;)</p>
<p>However, people who know C++ intimately assume that it&#8217;s perfect, while C experts assume that C is naturally &quot;easier&quot; when actually it&#8217;s just what they know. A good X programmer will beat a poor Y programmer for virtually any pair of languages you care to name. And that even includes your personal least favorite version of Basic.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384503">
				<div id="div-comment-384503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384503">
			May 24, 2006 at 5:03 pm</a>		</div>

		<p>Does anybody know why C++ has this feature in the first place?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384513">
				<div id="div-comment-384513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rsclient</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384513">
			May 24, 2006 at 5:03 pm</a>		</div>

		<p>Not only are the odd bits of C++ pretty wierd, but they often aren&#8217;t documented very well.</p>
<p>The Microsoft C++ documentation for &#8216;explicit&#8217; has some fairly useless verbiage, plus an example of how having an &#8216;explicit&#8217; in a constructor will case a compiler error. &nbsp;It then says: &quot;To resolve the error, remove the &#8216;explicit&#8217; keywords&#8230;&quot;.</p>
<p>It would be better, of course, to fix the code to use the class correctly.</p>
<p>(And of my four C++ books, only Stroustrup mentions explicit at all)</p>
<p>Thank you, Raymond, for adding to my C++ knowledge!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-384523">
				<div id="div-comment-384523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384523">
			May 24, 2006 at 5:35 pm</a>		</div>

		<p>rsclient: Which feature are you asking about? The &quot;using a constructor as a converter&quot; feature or the &quot;explicit&quot; feature?</p>
<p>I&#8217;m surprise nobody has yet commented, &quot;If Microsoft hadn&#8217;t made X stupid decision back in 19XX, we wouldn&#8217;t have this problem today,&quot; since that&#8217;s the typical reaction to most of my &quot;compatibility pitfalls&quot; articles&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384533">
				<div id="div-comment-384533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Some guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384533">
			May 24, 2006 at 5:45 pm</a>		</div>

		<p>Even the idiots amongst us know that Microsoft didn&#8217;t invent C++? Well, I bet that wasn&#8217;t your prediction. &nbsp;;)</p>
<p>Still, I am kinda surprised that so many people allegedly didn&#8217;t know this detail &#8211; I must have gotten lucky with my C++ reading because I&#8217;ve known it for years. It&#8217;s odd the things that occasionally turn out to be an obscure corner of a language. It&#8217;s good to know that C++ is the only language where that applies, though. Or something.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384543">
				<div id="div-comment-384543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arlie Davis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384543">
			May 24, 2006 at 5:56 pm</a>		</div>

		<p>If Microsoft hadn&#8217;t made the stupid decision to support C and C++ in the 1980s, we wouldn&#8217;t have this problem today&#8230;</p>
<p>&#8230;and we probably wouldn&#8217;t have anything, at all&#8230;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384553">
				<div id="div-comment-384553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384553">
			May 24, 2006 at 5:56 pm</a>		</div>

		<p>Found this out very early on while learning c++.<br />
<br />This little &#8216;feature&#8217; can cause all sorts of basicly broken code to compile if you&#8217;re not aware of it.<br />
<br />Altough i can see the reason for including it, it allows the same syntax to be used for implicit conversion in the way that its supported for native types.<br />
<br />That a constructor becomes a conversion operator without some kind of keyword however is not something i like, and i hope new languages will invert the use of something like &#8216;explicit&#8217;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384563">
				<div id="div-comment-384563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kzinti</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384563">
			May 24, 2006 at 6:07 pm</a>		</div>

		<p>It would be nice if the default was &quot;explicit&quot; and you had to write &quot;implicit&quot; to get the current behavior. A bit late to fix this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384583">
				<div id="div-comment-384583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arlie Davis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384583">
			May 24, 2006 at 7:15 pm</a>		</div>

		<p>Bart, Kzinti: You&#8217;ll be happy to know that C# does things the way you want. &nbsp;You can provide conversions, but they must be marked &quot;explicit&quot; or &quot;implicit&quot;, and constructors are not default conversions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-384593">
				<div id="div-comment-384593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384593">
			May 24, 2006 at 7:17 pm</a>		</div>

		<p>&quot;Obviously, the C++ committee must fix this bug in the next version of the language specification. Programs that relied on the bug will have to be rewritten. That&#8217;s the price of progress. Backwards compatbility is a drain on resources.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384603">
				<div id="div-comment-384603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rsclient</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384603">
			May 24, 2006 at 8:23 pm</a>		</div>

		<p>Raymond: That was &#8216;Gabe&#8217; who was asking about the feature. &nbsp;I was just commenting that it wasn&#8217;t documented very well &#8212; many books don&#8217;t mention it, and at least one major manufacturer has, for its documentation, the implicit notion that it should just be removed from code if it causes problems.</p>
<p>Gabe: My guess is: because it&#8217;s darn useful. &nbsp;Strousstrup gives the example</p>
<p> &nbsp; &nbsp;string s = &#8216;a&#8217;; // make s a string with int(&#8216;a&#8217;) elements</p>
<p>which is clearly useless and non-intuitive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384613">
				<div id="div-comment-384613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384613">
			May 24, 2006 at 8:42 pm</a>		</div>

		<blockquote><p>
  My guess is that the code is generating lots<br />
  <br />&gt; of large C++ temporaries.</p>
<p>That&#8217;s what killed memory performance, but in fact you could delete the word &quot;large&quot; and describe a lot more performance killers. &nbsp;Think of how much code creates and deletes temporaries that need heap allocations, even just 4 bytes at a time, but invoke the memory manager twice for each one.</p>
<p>Wednesday, May 24, 2006 5:56 PM by Arlie Davis<br />
  <br />&gt; If Microsoft hadn&#8217;t made the stupid decision<br />
  <br />&gt; to support C and C++ in the 1980s, we<br />
  <br />&gt; wouldn&#8217;t have this problem today&#8230;<br />
  <br />&gt; &#8230;and we probably wouldn&#8217;t have anything,<br />
  <br />&gt; at all&#8230; </p>
<p>Sure we would. &nbsp;We wouldn&#8217;t have a language which started out as a replacement for assembly language, and we wouldn&#8217;t have a language which started out as a replacement for object oriented assembly language, but we&#8217;d have others. &nbsp;Maybe Microsoft might not have made a decision to drop support for Fortran? &nbsp;Microsoft still would have bought VB, then killed it off and started selling VB#. &nbsp;Same for something starting with a J ^_^</p>
<p>Once upon a time Fortran benefited from the addition of a statement &quot;IMPLICIT NONE&quot; which careful programmers started using. &nbsp;Later VB got its Option Explicit and some VC++ headers started allowing programmers to use Strict to catch some of their own bugs in VC++ programs. &nbsp;It really isn&#8217;t too late for the C++ standard to be augmented with a similar optional kind of declaration, or maybe a #pragma. &nbsp;Political problems yes, timing problems no.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-384623">
				<div id="div-comment-384623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384623">
			May 24, 2006 at 9:00 pm</a>		</div>

		<p>Norman: I&#8217;m not sure why you&#8217;re bringing performance into the picture. The original problem wasn&#8217;t a performance issue, it was a crashing bug! Lots of small temporaries wouldn&#8217;t have caused a stack overflow crash.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384633">
				<div id="div-comment-384633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Ritchie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384633">
			May 24, 2006 at 10:00 pm</a>		</div>

		<p>Moi, true, it&#8217;s not &quot;needed&quot; on anything other than a constructor with a single parameter; but, I&#8217;ve run into many situations where a constructor with multiple parameters was refactored to a constructor with a single parameter and introduced the problem outlined here.</p>
<p>Add it to all c&#8217;tors does not add any code and therefore does not add any performance implications; it merely makes the code safer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384643">
				<div id="div-comment-384643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Ritchie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384643">
			May 24, 2006 at 10:06 pm</a>		</div>

		<p>In the original C++ specifications there was no explicit keyword; the default behaviour was that c&#8217;tors with a single parameter were always potentially implicitly used as conversion constructors. &nbsp;This, obviously, wasn&#8217;t realized until after much code had been written that already used this default behaviour and adding an &quot;implicit&quot; keyword would have potentially broken much code. &nbsp;Thus, the &quot;explicit&quot; keyword was added.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384663">
				<div id="div-comment-384663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384663">
			May 24, 2006 at 11:31 pm</a>		</div>

		<blockquote><p>
  I&#8217;m not sure why you&#8217;re bringing performance<br />
  <br />&gt; into the picture. The original problem<br />
  <br />&gt; wasn&#8217;t a performance issue, it was a<br />
  <br />&gt; crashing bug!</p>
<p>I misinterpreted the original complaint, sorry. &nbsp;I thought the original complaint was that the program was using too much memory. &nbsp;In fact the original complaint was a more specific version of this, which you stated but I overlooked. &nbsp;Sorry.</p>
<p>By the way it&#8217;s interesting that one of your colleagues blogged about essentially the same topic on the same day. &nbsp;A different design decision in the C programming language was involved but it also leads to bugs. &nbsp;The programmer made a mistake which was unintended, received no error message because the program had a valid meaning, and the program behaved in an undesired manner.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384703">
				<div id="div-comment-384703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384703">
			May 25, 2006 at 5:17 am</a>		</div>

		<p>Don&#8217;t forget that this particular conversion only happens for const parameters. If you have extern void Foo(BigBuffer&amp; o); then a call to Foo(3) won&#8217;t compile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384713">
				<div id="div-comment-384713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Phylyp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384713">
			May 25, 2006 at 6:15 am</a>		</div>

		<p>Raymond,<br />
<br />Wow, this was a really interesting (and concise) example!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384723">
				<div id="div-comment-384723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384723">
			May 25, 2006 at 6:42 am</a>		</div>

		<p>While we&#8217;re at it, I wish C++ didn&#8217;t automatically produce (usually wrong) copy constructors and assignment operators. Like the conversion constructors they are useful features that should be left in, but they should also not do things by default (because they&#8217;re usually wrong!), invisibly, without the programmer asking for them explicitly (no pun intended).</p>
<p>There&#8217;s clearly a willingness to change C++ as the hundreds of warnings I got when moving to VS2005 are testament to. Okay, this was mainly Secure CRT stuff rather than the language itself, but small parts of the language have also been changing. I think it&#8217;s good that things are not set in stone and the language is progressing.</p>
<p>I hope implicit conversion/copy/assignment constructors/operators are next against the wall! The effort required to update old code which relies on them is trivial compared to the effort that can be spent tracing the problems they cause (not to mention the fact that I&#8217;m sick of declaring private constructors/assignment operators, just in case, for classes that nobody in their right mind would apply those semantics to), and there can always be a compiler switch or pragma to get the old behaviour, just like there is/was for the (stupid) for loop variable scoping.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384733">
				<div id="div-comment-384733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anders Dalvander</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384733">
			May 25, 2006 at 7:02 am</a>		</div>

		<p>Gabe: The implicit conversion is rather handy when creating objects on the stack.</p>
<p>std::string s = &quot;Hello World!&quot;;</p>
<p>may be a bit easier to read than either of:</p>
<p>std::string s(&quot;Hello World!&quot;);<br />
<br />std::string s = std::string(&quot;Hello World!&quot;);</p>
<p>Using the heap is another thing as you&#8217;ll always use new and the name of the class you want to instantiate:</p>
<p>std::string* p = new std::string(&quot;Hello World!&quot;);</p>
<p>Another interesting C++ &quot;feature&quot; is the following:</p>
<p>std::string s();</p>
<p>What does that line do? Anyone? ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384753">
				<div id="div-comment-384753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">meh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384753">
			May 25, 2006 at 8:03 am</a>		</div>

		<p>Nothing really. :P It&#8217;s a function declaration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384773">
				<div id="div-comment-384773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.gimpel.com' rel='external nofollow' class='url'>Me</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384773">
			May 25, 2006 at 9:07 am</a>		</div>

		<p>There&#8217;s a reason why Lint issues a warning &quot;constructor &#8230; can be used for implicit conversions&quot; !</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384793">
				<div id="div-comment-384793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384793">
			May 25, 2006 at 10:04 am</a>		</div>

		<p>My favourite example of this bug is like:<br />
<br /> &nbsp; &nbsp;CPoint p = (5, 10);</p>
<p>which looks reasonable but doesn&#8217;t do what a naive user would expect. It&#8217;s equivalent to:<br />
<br /> &nbsp; &nbsp;CPoint p = CPoint(10);</p>
<p>Microsoft in its wisdom having given MFC CPoint a constructor that takes a single int.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384803">
				<div id="div-comment-384803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Randolpho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384803">
			May 25, 2006 at 10:23 am</a>		</div>

		<p>Dave Harris:</p>
<p>You used the words &quot;wisdom&quot; and &quot;MFC&quot; in the same sentence. SHAME!!! :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384863">
				<div id="div-comment-384863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Blekhman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384863">
			May 25, 2006 at 12:29 pm</a>		</div>

		<p>&lt;flame intensity=100%&gt;<br />
<br />I’m sick of all those people who lament about C++ complexity. If you’re not smart enough to code in C++, then just leave this niche and learn a language you can cope with. One doesn’t pursue tenure of nuclear physics professor and don’t attend world chess championships if he/she isn’t qualified/smart (or both) enough to do these thing. So, why people claim they program in C++ just to cry a moment later about how difficult C++ is.</p>
<p>No one proposes to remove half of pieces in chess with excuse that there are too many freaking combinations. That’s the game and that’s the rules. You don’t like it, you don’t play it. That simple.<br />
<br />&lt;/flame&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384953">
				<div id="div-comment-384953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jay B</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384953">
			May 25, 2006 at 1:48 pm</a>		</div>

		<blockquote><p>
  &gt;&gt;I hope implicit conversion/copy/assignment constructors/operators are next against the wall! The effort required to update old code which relies on them is trivial compared to the effort that can be spent tracing the problems they cause &lt;clip&gt; &lt;&lt;&lt;</p>
<p>Now, imagine you have multiple million lines of code spread out through many hundred different compiled modules as part of your &quot;product&quot;. &nbsp;Still think it&#8217;s trivial? &nbsp;I can tell you without a doubt, it is not.</p>
<p>Sure, you can say in hindsight, fixing a large problem would have resulted in less investment than finding and fixing a bunch of little ones, but what if you&#8217;ve already invested the time in finding and fixing those little ones? &nbsp;Now you&#8217;re talking about fixing the large one after the fact, meaning not only was there the original investment but now there is a new investment. &nbsp;And what&#8217;s the benefit? &nbsp;You&#8217;re likely going to introduce more bugs, cost development dollars and gain nothing in the marketplace. &nbsp;Clients and customers don&#8217;t ultimately care how proper your code is. &nbsp;You can&#8217;t sell new versions of your product if nothing of substance changed.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-384973">
				<div id="div-comment-384973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.j-dotonline.com' rel='external nofollow' class='url'>J.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384973">
			May 25, 2006 at 2:49 pm</a>		</div>

		<p>Moi, I may be mistaken, but my understanding is that the &quot;explicit&quot; keyword does have meaning outside of the single-argument constructor scenario described here. &nbsp;For instance:</p>
<p>class Money {<br />
<br /> &nbsp;public:<br />
<br /> &nbsp; &nbsp;Money(int dollars, int cents) { &#8230; }<br />
<br />}</p>
<p>Money roundsForYou() { return Money(10.5, 50); }</p>
<p>Here, an implicit conversion will take place from the double, 10.5, to an int. &nbsp;If the constructor was declared with the explicit keyword, I don&#8217;t think this would be allowed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-384993">
				<div id="div-comment-384993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Blekhman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-384993">
			May 25, 2006 at 3:56 pm</a>		</div>

		<p>J, you are mistaken. `explicit&#8217; constructor prevents implicit creation of an object. For instance:</p>
<p>struct X<br />
<br />{<br />
<br /> &nbsp; &nbsp;explicit X(int) {}<br />
<br />};</p>
<p>X foo() { return 3; }</p>
<p>In this example foo() won&#8217;t compile. You need explicitly state that you want to create an<br />
<br />object:</p>
<p>X foo() { return X(3); }</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-385063">
				<div id="div-comment-385063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-385063">
			May 25, 2006 at 8:27 pm</a>		</div>

		<p>Over the years of dealing with the compiler generated methods, I have run into more issues where people created such things as assignment operators and copy constructors when the compiler generated methods would have worked just fine.</p>
<p>Removing the compiler generated methods might remove one source of bugs, but you end up just trading those bugs for another type of bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-385073">
				<div id="div-comment-385073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-385073">
			May 25, 2006 at 8:43 pm</a>		</div>

		<p>Thursday, May 25, 2006 12:29 PM by Alex Blekhman<br />
<br />&gt; &lt;flame intensity=100%&gt;<br />
<br />&gt; If you&#8217;re not smart enough to code in C++,<br />
<br />&gt; then just leave this niche and learn a<br />
<br />&gt; language you can cope with.</p>
<p>Oh I agree. &nbsp;If you&#8217;re smart enough to code in C++ for 5 minutes per day while really maximizing your concentration and avoiding making any coding errors, then you should code in C++ for 5 minutes per day and code in Eiffel for the rest of the day. &nbsp;If you have a cold that day then you should do 0 minutes in C++ and stick to Eiffel.</p>
<p>This is almost exactly parallel to the use of other dangerous powers. &nbsp;If you&#8217;re smart enough to run as root (or Administrator) for 5 minutes per day while really maximizing your concentration and avoiding making any typing or mousing errors, then you should run as Administrator for 5 minutes per day and run as a limited user for the rest of the day. &nbsp;If you have a cold that day then you shouldn&#8217;t use an account that is capable of having administrative privileges enabled that day.</p>
<p>Now what happens if you want to hibernate a PC instead of pulling the plug, or if you need to fix some C++ code that was written by someone less skilled than you, but it&#8217;s going to take more than 5 minutes?</p>
<p>If you&#8217;re a mere mortal who is aware that sometimes you make mistakes, and you want to make a bit of effort to protect yourself and your customers from mistakes (e.g. by getting informed of them as quickly as possible), then you might wish for better tools. &nbsp;Let me know when a C++ to Eiffel converter is available, and let me know when it works.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-385123">
				<div id="div-comment-385123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Luther Baker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-385123">
			May 25, 2006 at 11:18 pm</a>		</div>

		<p>&lt;slightly-ot&gt;<br />
<br />How does one look at the size of the stack in something like and MSVC 2005 environment? Do you insert a breakpoint and somehow look at the stack trace or debug output?<br />
<br />&lt;/slightly-ot&gt;</p>
<p>Thanks,</p>
<p>-Luther</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-385133">
				<div id="div-comment-385133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-385133">
			May 25, 2006 at 11:42 pm</a>		</div>

		<p>Ooooops. &nbsp;This one&#8217;s too explicit for me:</p>
<p><a rel="nofollow" target="_new" href="http://thedailywtf.com/forums/permalink/74461/74486/ShowThread.aspx#74486" rel="nofollow">http://thedailywtf.com/forums/permalink/74461/74486/ShowThread.aspx#74486</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-385313">
				<div id="div-comment-385313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Conrad</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-385313">
			May 26, 2006 at 11:19 am</a>		</div>

		<p>&quot;If you’re not smart enough to code in C++, then just leave this niche and learn a language you can cope with.&quot;</p>
<p>Absolutely! In fact, I hope that future changes will greatly increase the complexity of C++ to weed out more people who think they can program. Thin the herd! We shouldn&#8217;t design programming languages for the people who are going to use them; instead, make the people adapt to the programming language. With a little work we can turn C++ into a language where almost any construction is a subtle, hard-to-find, difficult-to-understand error.</p>
<p>&quot;Now, imagine you have multiple million lines of code spread out through many hundred different compiled modules as part of your &quot;product&quot;. &nbsp;Still think it&#8217;s trivial?&quot;</p>
<p>Yup. Just turn on the backwards-compatibility compiler switch. Then add the copy ctors and assignment ctors to the classes one by one, over time, occasionally turning off the compiler switch to see what classes still need them. (This could be a long range refactoring project over a period of months, while other development continues unimpeded.)</p>
<p>Eventually, when you turn off the compiler switch you get no errors, and you know you are done. You may have millions of SLOC, but you don&#8217;t have millions of classes in your product, do you?</p>
<p>Worst case, you just turn on the backwards-compatibility compiler switch and leave it that way, but new projects can take advantage of the change. Now, whether this is a good idea, I am undecided on, but I think it would definitely be doable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-385213">
				<div id="div-comment-385213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Oliver</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-385213">
			May 26, 2006 at 6:46 am</a>		</div>

		<p>&gt;&gt;&gt;Don&#8217;t forget that this particular conversion only happens for const parameters. If you have extern void Foo(BigBuffer&amp; o); then a call to Foo(3) won&#8217;t compile.&lt;&lt;&lt;</p>
<p>And consider this (actually somewhat made-up) example with build-in types (which will generate a warning, but compile):</p>
<p>class CTest<br />
<br />{<br />
<br />public:<br />
<br />	/*explicit*/ CTest(int i) : m_i(i) { }<br />
<br />	int GetInt() const { return m_i; }<br />
<br />private:<br />
<br />	int m_i;<br />
<br />};</p>
<p>CTest foo()<br />
<br />{<br />
<br />	return 7.9;<br />
<br />}</p>
<p>;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-385493">
				<div id="div-comment-385493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasondoucette.com/' rel='external nofollow' class='url'>Jason Doucette</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-385493">
			May 26, 2006 at 3:37 pm</a>		</div>

		<p>Leo Davidson:</p>
<p>I agree that copy constructors and assignment operators should not be implicitly created, especially when they are almost always wrong. &nbsp;When you don&#8217;t want them, it forces you to override them yourself, introducing all kinds of problems &#8212; duplicate code, error handling, dependency problems. &nbsp;I ran into this recently on a large project, and it&#8217;s just a complete mess. &nbsp;Luckily I can make them private (which doesn&#8217;t solve everything), but why am I forced to do even this? &nbsp;Why does the language create them when they are useless for anything but the most basic classes?</p>
<p>I also agree that a compiler switch / pragma can solve the problem, to allow the old code of yesteryear to compile without the expense of upgrading, but also allow newer code to be written with less bugs. &nbsp;Both worlds can co-exist.</p>
<p>Jay B:</p>
<p>Yes, it is costly to fix millions of lines of code, even if the fixes are trivial. &nbsp;But, doesn&#8217;t a backward compatibility switch allow both worlds to co-exist with no additional effort from either? &nbsp;And is this too much to ask?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-386243">
				<div id="div-comment-386243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Per Vognsen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-386243">
			May 30, 2006 at 10:33 am</a>		</div>

		<p>Jason Doucette,</p>
<p>&quot;I agree that copy constructors and assignment operators should not be implicitly created, especially when they are almost always wrong.&quot;</p>
<p>The synthesized copy constructor and assignment operator often do exactly you want in a well-designed system where (1) most classes have proper value semantics; and (2) manual memory management is confined to as few classes as possible.</p>
<p>&quot;Luckily I can make them private (which doesn&#8217;t solve everything)&quot;</p>
<p>What problem are you trying to solve?</p>
<p>If you don&#8217;t want to allow copying or assignment, the usual idiom is to make the copy constructor and assignment operator private and&#8211;this is important&#8211;leave them unimplemented. If you do this correctly, attempts at copying or assignment (even by member or friend functions) will result in a compile-time error.</p>
<p>Even better would be to use boost::noncopyable or the like.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-386803">
				<div id="div-comment-386803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/jdanielsmith/' rel='external nofollow' class='url'>J. Daniel Smith</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-386803">
			May 31, 2006 at 1:09 pm</a>		</div>

		<p>I&#8217;d like to see the C++ defaults changed too: an &quot;implicit&quot; keyword that can be used everywhere &quot;explicit&quot; is, and then slowly make &quot;explicit&quot; the default.</p>
<p>Same goes for &quot;mutable&quot; and &quot;const&quot;, I want to explicitly write &quot;mutable&quot; functions or arguments just like I do for &quot;const&quot; now. &nbsp;And eventually, make &quot;const&quot; the default instead of an implicit &quot;mutable&quot; (or get rid of an implicit default altogether).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-386813">
				<div id="div-comment-386813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.j-dotonline.com' rel='external nofollow' class='url'>J.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060524-12/?p=31083#comment-386813">
			May 31, 2006 at 1:38 pm</a>		</div>

		<p>Thanks Alex, I&#8217;ll shut up now :/</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>