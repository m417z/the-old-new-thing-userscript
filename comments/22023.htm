<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (4)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-637203">
				<div id="div-comment-637203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://lambert.geek.nz/' rel='external nofollow' class='url'>Miral</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080609-00/?p=22023#comment-637203">
			June 9, 2008 at 9:12 pm</a>		</div>

		<p>I&#8217;m still not quite sure why the dependency tracking you dismissed in your earlier post wouldn&#8217;t actually work.</p>
<p>Surely if A.DLL loads MIDDLE.DLL (implicitly or explicitly) and MIDDLE.DLL loads B.DLL (implicitly or explicitly) then the dependency chain can be set such that MIDDLE.DLL won&#8217;t unload until after A.DLL does, and B.DLL won&#8217;t unload until after MIDDLE.DLL does, which preserves the expected behaviour that B.DLL will still be loaded when A.DLL unloads.</p>
<p>There are still cases where you can trip it up, of course (such as setting up a circular or reverse dependency, as you mentioned), but doing this seems safer than not doing it.</p>
<p>And yes, you can&#8217;t trust the return address, but I doubt modifying DLL dependency relationships is much of an attack vector. &nbsp;So I don&#8217;t see any harm in trusting it in this case.</p>
<p>Maybe I&#8217;m missing some vital point&#8230;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-637213">
				<div id="div-comment-637213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080609-00/?p=22023#comment-637213">
			June 9, 2008 at 9:53 pm</a>		</div>

		<p>&quot;And yes, you can&#8217;t trust the return address, but I doubt modifying DLL dependency relationships is much of an attack vector.&quot;</p>
<p>I don&#8217;t think it&#8217;s a matter of security as such. There are plenty of non-security related cases where you can&#8217;t trust the return address (for example, what about on-the-fly generated code?)</p>
<p>Besides, all of this is moot if developers just stick to the &quot;don&#8217;t call methods in other DLLs (except kernel32.dll, maybe) from your DllMain&quot; rule.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-637223">
				<div id="div-comment-637223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080609-00/?p=22023#comment-637223">
			June 9, 2008 at 11:11 pm</a>		</div>

		<p>Besides, all of this is moot if developers just stick to the &quot;don&#8217;t call methods in other DLLs (except kernel32.dll, maybe) from your DllMain&quot; rule.</p>
<p>I agree with you completely, however those who aren&#8217;t ignorant to its existance in the first place seem to find that abiding to this particular rule to be unbearably difficult. So any discussion about it surely can&#8217;t be a bad thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-637263">
				<div id="div-comment-637263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tepsif&#252;les</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080609-00/?p=22023#comment-637263">
			June 10, 2008 at 5:07 am</a>		</div>

		<p>Miral said:</p>
<p>Surely if A.DLL loads MIDDLE.DLL (implicitly or explicitly) and MIDDLE.DLL loads B.DLL (implicitly or explicitly) then the dependency chain can be set such that MIDDLE.DLL won&#8217;t unload until after A.DLL does, and B.DLL won&#8217;t unload until after MIDDLE.DLL does, which preserves the expected behaviour that B.DLL will still be loaded when A.DLL unloads.</p>
<p>The indicated context was that MIDDLE is a common wrapper, likely to be unloaded only when the lights go out. So adding a dependency on B would just stick B in the memory forever, which is not the desired outcome.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>