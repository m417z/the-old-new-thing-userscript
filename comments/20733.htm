<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (17)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-671193">
				<div id="div-comment-671193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">car insurance &raquo; Anybody can make up a generic mapping</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671193">
			September 29, 2008 at 10:02 am</a>		</div>

		<p>PingBack from <a href="http://hoursfunnywallpaper.cn/?p=8287" rel="nofollow">http://hoursfunnywallpaper.cn/?p=8287</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-671233">
				<div id="div-comment-671233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671233">
			September 29, 2008 at 10:49 am</a>		</div>

		<p>This is like Alfred Hitchcock&#8217;s &quot;The Birds&quot;, only instead of birds it&#8217;s pingback spam.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-671243">
				<div id="div-comment-671243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Will</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671243">
			September 29, 2008 at 11:10 am</a>		</div>

		<p>@John:</p>
<p>I prefer to think of it as being like William F. Claxton&#8217;s &quot;Night of the Lepus&quot;, only instead of giant mutant rabbits it&#8217;s pingback spam.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-671253">
				<div id="div-comment-671253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671253">
			September 29, 2008 at 11:51 am</a>		</div>

		<p>So actually, anything can have a security descriptor, and that&#8217;s why the AccessCheck() uses it rather than a kernel handle to the object ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-671263">
				<div id="div-comment-671263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671263">
			September 29, 2008 at 12:07 pm</a>		</div>

		<p>Medinoc,</p>
<p>The point is that if you have your own set of permissions in your application (for example, your app is a source/versioning control system), you can use Win32 security API for access check. In this case you keep the ACLs in your application files. When you give your own meanings to the permission bits, you can also create your own set of generic mappings.</p>
<p>For example, in a versioning control system, generic read permissions will include get the source, enumerate files, get labels, read security lists, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-671273">
				<div id="div-comment-671273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671273">
			September 29, 2008 at 3:18 pm</a>		</div>

		<blockquote><p>
  One of my colleagues points out that the mandatory integrity mechanism does have implications for generic mappings.
</p></blockquote>
<p>I think their suggestion is that integrity levels provide a snapshot of generic mappings. &nbsp;If a user has a low trust token, it&#8217;s likely that&#8217;s GENERIC_READ, while high trust will usually be GENERIC_ALL_ACCESS. &nbsp;But again, each component implements it as it wants.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-671283">
				<div id="div-comment-671283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671283">
			September 29, 2008 at 3:24 pm</a>		</div>

		<p>&#8230; and although it would be nice to have a mechanism to expose what the generic mappings are, I&#8217;m afraid there&#8217;s no point forcing things to have such a mapping.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-671303">
				<div id="div-comment-671303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671303">
			September 29, 2008 at 4:08 pm</a>		</div>

		<blockquote><p>
  mandatory integrity mechanism does have implications for generic mappings
</p></blockquote>
<p>One example of this is the fact that PROCESS_QUERY_LIMITED_INFORMATION is part of PROCESS_EXECUTE_ACCESS rather than PROCESS_READ_ACCESS (if it was part of read access, MIC wouldn&#8217;t allow a lower integrity process to query information about a higher integrity process).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-671323">
				<div id="div-comment-671323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671323">
			September 29, 2008 at 7:20 pm</a>		</div>

		<p>I can answer the cryptic part about generic accesses and mandatory integrity &#8211; not to brag, but my BS thesis was the first ever implementation of a Bell-LaPadula policy for Windows (ReactOS actually, because my school didn&#8217;t have a WRK license, but close enough).</p>
<p>The Biba integrity policy (the one implemented by Vista) is based on the concept of an integrity level. Every object (in Windows, a security descriptor) and subject (token object) is marked (&quot;labeled&quot; is the technical term) with a specific integrity level. The more critical a process, file, registry key, etc. the higher the integrity level. Conversely, the more untrusted a program, the lower the integrity level it will need to be run at. Levels as assigned to objects and subjects are immutable, for really complicated reasons (the short of it: Windows doesn&#8217;t support revoking access to objects). Obviously, you don&#8217;t want low-integrity processes to be able to alter high-integrity code and data; in MAC-speak, this is known as &quot;no write up&quot;, and it&#8217;s one of the two security properties that make up the Biba policy.</p>
<p>To detect whether an access control operation (CreateFile, OpenProcess, RegCreateKey, etc.) is going &quot;up&quot;, you just compare the subject&#8217;s level with the object&#8217;s: if the object&#8217;s is larger, the direction is &quot;up&quot;. To detect whether the operation is a &quot;write&quot;, you have to take the intersection between the requested access and the GenericWrite mask for the object type: if the intersection isn&#8217;t empty, the operation is &quot;write&quot;. An operation that is both &quot;write&quot; and &quot;up&quot; fails before the ACL is even checked.</p>
<p>For an object type to properly support mandatory policy, it&#8217;s <em>imperative</em> that either its GenericWrite includes DELETE | WRITE_DAC | WRITE_OWNER (I believe the system handles ACCESS_SYSTEM_SECURITY automatically), <em>or</em> that the object type doesn&#8217;t support the delete/set owner/write DAC operations. Failure to do this results in a security hole (a write operation that isn&#8217;t detected as a &quot;write&quot;).</p>
<p>The full Biba policy has a second property, &quot;no read down&quot;, that prevents high-integrity processes from writing low-integrity data into themselves by themselves, but Windows doesn&#8217;t implement it (I can see why, it&#8217;d be an usability and compatibility nightmare). On the other hand, and if I remember correctly, Windows implements &quot;no execute up&quot; and &quot;no read up&quot; too. This is where things get interesting. Detecting writes alone is easy; detecting reads as well is complicated by dubious design choices made a long time ago. The very short of it (this was of the longest parts of my thesis): the Windows kernel object model is leaky, unorthogonal and can&#8217;t support mandatory security policies completely. The theory of the object model is that data managed by the kernel on behalf of user-mode is split up into discrete subsets, that is objects, and each object maps to a security model object, that is a security descriptor.</p>
<p>The reality is very different. A lot of data isn&#8217;t even in an object, for example (the process list, to name one). Some non-trivial object types result in several data subsets with different semantics sharing the same object, and by extension the same security descriptor (which therefore has to contain a mishmash of access bits, some covering one subset, some covering another, some covering all of them…). For example, file mapping objects, where the same security descriptor covers the object itself and the data it points to &#8211; by looking at the GENERIC_MAPPING alone, a security policy would think file mapping objects supported write-only access (they don&#8217;t, mapped memory is always at least readable. Well they do with COW, but this isn&#8217;t expressed in any way the security subsystem can understand). Or file objects, actually made up of two objects (the file object itself and the FCB it points to) sharing a single security descriptor, where SYNCHRONIZE access covers the file object itself (a volatile, in-memory structure) and the rest of accesses cover the FCB… but all bits end up serialized on disk in the FCB&#8217;s security descriptor (you can deny synchronous I/O access to a file… what&#8217;s the use of that?). In fact, almost any all operations on file objects would be detected as &quot;read&quot;/&quot;write&quot;/&quot;execute&quot; at the same time by looking at the GENERIC_MAPPING alone, since all generic accesses include SYNCHRONIZE… An extreme case are disk volumes, where a single security descriptor (the volume&#8217;s) bypasses hundreds or thousands others (the files&#8217;), an unique issue that MAC policies don&#8217;t address because UNIX doesn&#8217;t give any raw access to mounted volumes.</p>
<p>And objects are hard enough, let&#8217;s not even get into the mess that <em>subjects</em> are: where TrustedBSD (my reference implementation) has a single label covering a process, its credentials and all its threads, Windows has a security descriptor for the process, a security descriptor for each thread in it, a process token, a security descriptor for the token itself, multiplied by the number of active impersonation tokens… I don&#8217;t know how Windows handles it yet, but I remember coming up with really byzantine formulas.</p>
<p>A small PS: the definition of MAC policies uses the term &quot;label&quot; instead of the more specific &quot;level&quot;, because labels are required to be composed of a non-hierarchical component (a set of horizontal &quot;compartments&quot; &#8211; the original Bell-LaPadula paper used &quot;Crypto&quot;, &quot;NATO&quot; and &quot;Nuclear&quot;) as well as the hierarchical component (the vertical &quot;level&quot; &#8211; e.g. &quot;unclassified&quot;, &quot;secret&quot;, &quot;top secret&quot;, because Bell-LaPadula is specular to Biba and designed to prevent unauthorized leaks of information, rather than violations of integrity), but that&#8217;s another story for another day (basically, Windows implements a single compartment)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-671333">
				<div id="div-comment-671333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671333">
			September 29, 2008 at 7:21 pm</a>		</div>

		<p>I can answer the cryptic part about generic accesses and mandatory integrity &#8211; not to brag, but my BS thesis was the first ever implementation of a Bell-LaPadula policy for Windows (ReactOS actually, because my school didn&#8217;t have a WRK license, but close enough).</p>
<p>The Biba integrity policy (the one implemented by Vista) is based on the concept of an integrity level. Every object (in Windows, a security descriptor) and subject (token object) is marked (&quot;labeled&quot; is the technical term) with a specific integrity level. The more critical a process, file, registry key, etc. the higher the integrity level. Conversely, the more untrusted a program, the lower the integrity level it will need to be run at. Levels as assigned to objects and subjects are immutable, for really complicated reasons (the short of it: Windows doesn&#8217;t support revoking access to objects). Obviously, you don&#8217;t want low-integrity processes to be able to alter high-integrity code and data; in MAC-speak, this is known as &quot;no write up&quot;, and it&#8217;s one of the two security properties that make up the Biba policy.</p>
<p>To detect whether an access control operation (CreateFile, OpenProcess, RegCreateKey, etc.) is going &quot;up&quot;, you just compare the subject&#8217;s level with the object&#8217;s: if the object&#8217;s is larger, the direction is &quot;up&quot;. To detect whether the operation is a &quot;write&quot;, you have to take the intersection between the requested access and the GenericWrite mask for the object type: if the intersection isn&#8217;t empty, the operation is &quot;write&quot;. An operation that is both &quot;write&quot; and &quot;up&quot; fails before the ACL is even checked.</p>
<p>For an object type to properly support mandatory policy, it&#8217;s <em>imperative</em> that either its GenericWrite includes DELETE | WRITE_DAC | WRITE_OWNER (I believe the system handles ACCESS_SYSTEM_SECURITY automatically), <em>or</em> that the object type doesn&#8217;t support the delete/set owner/write DAC operations. Failure to do this results in a security hole (a write operation that isn&#8217;t detected as a &quot;write&quot;).</p>
<p>The full Biba policy has a second property, &quot;no read down&quot;, that prevents high-integrity processes from writing low-integrity data into themselves by themselves, but Windows doesn&#8217;t implement it (I can see why, it&#8217;d be an usability and compatibility nightmare). On the other hand, and if I remember correctly, Windows implements &quot;no execute up&quot; and &quot;no read up&quot; too. This is where things get interesting. Detecting writes alone is easy; detecting reads as well is complicated by dubious design choices made a long time ago. The very short of it (this was of the longest parts of my thesis): the Windows kernel object model is leaky, unorthogonal and can&#8217;t support mandatory security policies completely. The theory of the object model is that data managed by the kernel on behalf of user-mode is split up into discrete subsets, that is objects, and each object maps to a security model object, that is a security descriptor.</p>
<p>The reality is very different. A lot of data isn&#8217;t even in an object, for example (the process list, to name one). Some non-trivial object types result in several data subsets with different semantics sharing the same object, and by extension the same security descriptor (which therefore has to contain a mishmash of access bits, some covering one subset, some covering another, some covering all of them…). For example, file mapping objects, where the same security descriptor covers the object itself and the data it points to &#8211; by looking at the GENERIC_MAPPING alone, a security policy would think file mapping objects supported write-only access (they don&#8217;t, mapped memory is always at least readable. Well they do with COW, but this isn&#8217;t expressed in any way the security subsystem can understand). Or file objects, actually made up of two objects (the file object itself and the FCB it points to) sharing a single security descriptor, where SYNCHRONIZE access covers the file object itself (a volatile, in-memory structure) and the rest of accesses cover the FCB… but all bits end up serialized on disk in the FCB&#8217;s security descriptor (you can deny synchronous I/O access to a file… what&#8217;s the use of that?). In fact, almost any all operations on file objects would be detected as &quot;read&quot;/&quot;write&quot;/&quot;execute&quot; at the same time by looking at the GENERIC_MAPPING alone, since all generic accesses include SYNCHRONIZE… An extreme case are disk volumes, where a single security descriptor (the volume&#8217;s) bypasses hundreds or thousands others (the files&#8217;), an unique issue that MAC policies don&#8217;t address because UNIX doesn&#8217;t give any raw access to mounted volumes.</p>
<p>And objects are hard enough, let&#8217;s not even get into the mess that <em>subjects</em> are: where TrustedBSD (my reference implementation) has a single label covering a process, its credentials and all its threads, Windows has a security descriptor for the process, a security descriptor for each thread in it, a process token, a security descriptor for the token itself, multiplied by the number of active impersonation tokens… I don&#8217;t know how Windows handles it yet, but I remember coming up with really byzantine formulas.</p>
<p>A small PS: the definition of MAC policies uses the term &quot;label&quot; instead of the more specific &quot;level&quot;, because labels are required to be composed of a non-hierarchical component (a set of horizontal &quot;compartments&quot; &#8211; the original Bell-LaPadula paper used &quot;Crypto&quot;, &quot;NATO&quot; and &quot;Nuclear&quot;) as well as the hierarchical component (the vertical &quot;level&quot; &#8211; e.g. &quot;unclassified&quot;, &quot;secret&quot;, &quot;top secret&quot;, because Bell-LaPadula is specular to Biba and designed to prevent unauthorized leaks of information, rather than violations of integrity), but that&#8217;s another story for another day (basically, Windows implements a single compartment)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-671363">
				<div id="div-comment-671363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Seth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671363">
			September 30, 2008 at 3:35 am</a>		</div>

		<p>Oh man, I had to read that last comment twice to get it&#8230; ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-671373">
				<div id="div-comment-671373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Name required</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671373">
			September 30, 2008 at 6:01 am</a>		</div>

		<p>He lost me at &quot;BS thesis&quot;. Mainly because I thought that if the thesis was BS, I probably shouldn&#8217;t read what he said.</p>
<p>(colon dash right-bracket)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-671463">
				<div id="div-comment-671463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Poochner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671463">
			September 30, 2008 at 1:49 pm</a>		</div>

		<p>This is one of the reasons I read this blog.</p>
<p>That [long post] reminds me of some mainframe systems, with access &quot;rings.&quot; &nbsp;Also, the &quot;no read down&quot; sounds like what perl aims for with data tainting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aaron-margosis odd alt thread-odd thread-alt depth-1" id="comment-671573">
				<div id="div-comment-671573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Aaron+Margosis' rel='external nofollow' class='url'>Aaron Margosis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671573">
			September 30, 2008 at 11:44 pm</a>		</div>

		<p>That comment was thesis-length. :) &nbsp;Let me see whether I can condense it:</p>
<p>MIC = Vista&#8217;s Mandatory Integrity Control.</p>
<p>Every process (and every thread that is impersonating) has an access token. &nbsp;The access token has a MIC level (typically Low, Medium, High or System). &nbsp;Every object has an explicit or implicit MIC label, which consists of a level (e.g., Low, Medium, etc.) and a policy (no-write-up, no-read-up, no-execute-up). &nbsp;If a process(thread) requests access to an object, and the token&#8217;s level is lower than that of the object label, then the policies come into play. &nbsp;If the actor is requesting &quot;write&quot; permissions on the object, access is denied if the object&#8217;s policy includes &quot;no-write-up&quot;. &nbsp;If the actor is requesting &quot;read&quot; permissions, access is denied if the policy includes &quot;no-read-up&quot;. &nbsp;(And likewise with &quot;execute&quot; and &quot;no-execute-up&quot;.) &nbsp;So what constitutes &quot;write&quot; permissions? &nbsp;That&#8217;s where the generic mappings, provided by the relevant resource manager (e.g., NTFS) come into play. &nbsp;Each permission that GENERIC_WRITE maps to is a &quot;write&quot; permission; each permission that GENERIC_READ maps to is a &quot;read&quot; permission; etc. &nbsp;(Or if the process/thread requests GENERIC_WRITE explicitly.)</p>
<p>In Vista, most objects have explicit or implicit &quot;no-write-up&quot; policies only. &nbsp;Processes and threads have both &quot;no-write-up&quot; and &quot;no-read-up&quot;, so a lower integrity process cannot open the process and read its memory space.</p>
<p>Hope this helps.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aaron-margosis even thread-even depth-1" id="comment-671583">
				<div id="div-comment-671583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Aaron+Margosis' rel='external nofollow' class='url'>Aaron Margosis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-671583">
			September 30, 2008 at 11:48 pm</a>		</div>

		<p>For further reading on Vista&#8217;s Mandatory Integrity Control, here&#8217;s the whitepaper:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/bb625964.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/bb625964.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-672413">
				<div id="div-comment-672413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-672413">
			October 1, 2008 at 11:03 pm</a>		</div>

		<p>Sorry for the rambling comment, but Raymond&#8217;s post gave me a Vietnam flashback</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-672423">
				<div id="div-comment-672423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080929-00/?p=20733#comment-672423">
			October 1, 2008 at 11:07 pm</a>		</div>

		<p>Poochner: data tainting schemes are, in fact, MAC policies. I wish more environments/languages supported them natively. The state of Internet security would be quite little different</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>