<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (29)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1018143">
				<div id="div-comment-1018143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018143">
			October 29, 2012 at 7:16 am</a>		</div>

		<p>Ah, the old Python adage &quot;practicality beats purity&quot;. &nbsp;If you build the tallest ivory tower of utmost purity, nobody will want to live in it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com odd alt thread-odd thread-alt depth-1" id="comment-1018153">
				<div id="div-comment-1018153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018153">
			October 29, 2012 at 8:02 am</a>		</div>

		<p>Thank God the x86 to x64 porting of Windows happened while Jim Allchin was still there at the company! The current team would have made all sorts of compromises like they did for ARM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018163">
				<div id="div-comment-1018163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018163">
			October 29, 2012 at 8:06 am</a>		</div>

		<p>My compiler generates a pretty strong warning when I try that setup (hides virtual base member).</p>
<p>Of course on that particular case, meh it&#39;s just not worth it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018183">
				<div id="div-comment-1018183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018183">
			October 29, 2012 at 9:41 am</a>		</div>

		<p>@xpclient: &nbsp;You liar, Windows 8 provides a no-compromise computing experience. &nbsp;I read it in a marketing release so it must be true.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018193">
				<div id="div-comment-1018193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018193">
			October 29, 2012 at 10:05 am</a>		</div>

		<p>I agree but it&#39;s a slippery slope guys. Look at PHP ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018203">
				<div id="div-comment-1018203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018203">
			October 29, 2012 at 10:16 am</a>		</div>

		<p>This looks like a C++ specific problem. &nbsp;I didn&#39;t actually know that there was a not-yet-standardized &quot;override&quot; pseudo-keyword, but I know where the idea comes from: that&#39;s one of the many little details that makes Delphi a better language.</p>
<p>In Delphi, when a derived class declares a method with the same name as a virtual method in a base class, it has to match the signature and mark it as &quot;override&quot; to make it an override. &nbsp;Otherwise you get a compiler warning. &nbsp;If you do mark a method as override and it doesn&#39;t match the signature, as in the example here, it&#39;s a compiler error. And there&#39;s another directive, &quot;reintroduce,&quot; that makes it explicit that you don&#39;t mean to override the virtual method and gets rid of the compiler warning. &nbsp;Between &quot;override&quot; and &quot;reintroduce&quot;, it&#39;s impossible to accidentally make this kind of mistake unnoticed. &nbsp;(Especially if you also treat warnings as errors.)</p>
<div class="post">[<i>There are non-C++ examples, too. For example, changing the function signature silently breaks every p/invoke. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1018213">
				<div id="div-comment-1018213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018213">
			October 29, 2012 at 10:25 am</a>		</div>

		<p>One notable old PHD from CMU, an expert in Windows kernel and user mode, has bitterly complained that Win64 didn&#39;t expand ReadFile/WriteFile length to 64 bits. Seriously.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1018223">
				<div id="div-comment-1018223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018223">
			October 29, 2012 at 11:05 am</a>		</div>

		<p>Mason, Visual C++ has similar warnings about differing virtual functions, but I believe that they are disabled by default unless you use the highest level of warnings (which I highly recommend).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018233">
				<div id="div-comment-1018233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018233">
			October 29, 2012 at 11:37 am</a>		</div>

		<p>Why did you use DWORD_PTR here instead of SIZE_T? I thought that type was used for when you wanted to non-lossy cast between pointers and integers in the DWORD range?</p>
<div class="post">[<i>To avoid introducing a breaking change to the 32-bit side. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018243">
				<div id="div-comment-1018243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018243">
			October 29, 2012 at 12:04 pm</a>		</div>

		<p>@xpclient:</p>
<p>I take it you missed this:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx" rel="nofollow">blogs.msdn.com/&#8230;/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018253">
				<div id="div-comment-1018253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018253">
			October 29, 2012 at 12:12 pm</a>		</div>

		<blockquote><p>
  One notable old PHD from CMU, an expert in Windows kernel and user mode, has bitterly complained that Win64 didn&#39;t expand ReadFile/WriteFile length to 64 bits. Seriously.
</p></blockquote>
<p>Wow. Do you really want a &gt;2GB single IO request?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-1018263">
				<div id="div-comment-1018263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018263">
			October 29, 2012 at 12:57 pm</a>		</div>

		<p>Reminds me of this:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/psssql/archive/2011/10/03/yes-we-made-a-mistake-and-are-finally-going-to-fix-it.aspx" rel="nofollow">blogs.msdn.com/&#8230;/yes-we-made-a-mistake-and-are-finally-going-to-fix-it.aspx</a></p>
<p><a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/983246" rel="nofollow">support.microsoft.com/&#8230;/983246</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018273">
				<div id="div-comment-1018273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018273">
			October 29, 2012 at 3:44 pm</a>		</div>

		<p>wrt &gt;2GB I/O requests..</p>
<p>I would like them, yes. The entire point of going 64-bit is to address more memory. When you are designing standards for 64-bit computing, the last thing that you want to do is use 32-bit thinking to limit it. Not to mention the fact that modern consumer grade SSD&#39;s push half a gigabyte per second these days, that high end SSD&#39;s use proprietary interfaces to push several gigabytes per second over PCIe, that new computers are often now sold with 8= GB of memory&#8230;</p>
<p>What desirable purpose does it serve to require specialized code to read and write a dataset whose size happens to breach an artificial barrier imposed by a 20 year old paradigm? There is no justification for a 31-bit size restriction on a 64-bit architecture, only fallacious rationalizations such as &quot;do you really want a &gt;2GB single IO request?&quot; .. YES, I WOULD LIKE TO INFORM THE OS OF EXACTLY WHAT I AM DOING.</p>
<div class="post">[<i>It doesn&#39;t matter whether you extend the parameter to 64 bits or not, because the maximum size of a single write is 32MB. (Remember that I/O buffers must be locked, and locking 4GB of memory is not very friendly to the memory manager.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018283">
				<div id="div-comment-1018283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018283">
			October 29, 2012 at 4:35 pm</a>		</div>

		<p>@Mason Wheeler</p>
<p>Unfortunately, and it breaks my heart to say so, Delphi is not better in this perspective then any other language and that is because Delphi had/forced to recognize the existence of C/C++ languages (hence we got those nice register;cdecl; reserved words) while C/C++ acted just like Windows (Linux? who is Linux? I am the only OS and the given God gift to PC&#39;s). So, from this perspective, the entire Delphi implementation of COM / Win32s / interfaces etc was made purely as a port to match binary compilation like a C/C++ compiler would do. And that&#39;s why Delphi tastes so bad when you start to need those .h files to have a Delphi implementation of an already C/C++ library.</p>
<p>Now, back to our example, do this in Delphi, port Ray&#39;s example one on one to a Delphi equivalent and then see that Delphi will suffer from the same &quot;kick&quot; like Ray said in the end regarding CSecureNamedObject.</p>
<p>Perhaps I should feel better because when you deal with interfaces at least you already know what to expect if you decide to switch from C/C++ to Delphi as your main language for living, only to discover later that Delphi is a breeze when it comes to &quot;my boss wants this app done in 2 weeks while I know form my experience it will took at least 2 months&quot;. Sorry Ray, but it is the truth, Delphi is so much better then C/C++. If Microsoft would decide to make W9 in Delphi, it will find out that it need only half the time, so maybe sticking with C/C++ to create it is better from economics perspective &#8211; you feed more people. Decisions decisions&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018293">
				<div id="div-comment-1018293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/axel_4000_crytek.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>axel@crytek.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018293">
			October 29, 2012 at 5:21 pm</a>		</div>

		<p>Danny, you realize that C# was designed by the creator of Delphi and was influenced a lot of its design, especially in the libraries?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1018303">
				<div id="div-comment-1018303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018303">
			October 29, 2012 at 9:55 pm</a>		</div>

		<p>[because the maximum size of a single write is 32MB]</p>
<p>Strictly speaking, it&#39;s not true anymore in Vista+ (2GB-4K) and Win7+ (4GB-4K). Length argument in IoAllocateMdl is still ULONG.</p>
<p>But this is a game of diminishing returns. Most storage controllers have a limit for a single IO size (usually around 1MB, more or less). A single I/O larger than that has to be chopped to multiple requests anyway. It doesn&#39;t make sense to push a whole giant buffer at once.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1018313">
				<div id="div-comment-1018313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018313">
			October 29, 2012 at 9:57 pm</a>		</div>

		<p>[A single I/O larger than that has to be chopped to multiple requests anyway.]</p>
<p>Although this is done by classpnp.sys, transparently for the application.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018353">
				<div id="div-comment-1018353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018353">
			October 30, 2012 at 7:26 am</a>		</div>

		<p>[&#8230; (Remember that I/O buffers must be locked,&#8230;.) -Raymond]</p>
<p>I would assume that only the lowest-level device driver needs to lock and unlock pages, and only for the duration of the onging respective I/O requests.</p>
<p>Is Windows really locking all the pages of a ReadFile() call at once, even if (for example) a USB 1.1 memory stick needs seconds to minutes to read 10 Mbyte of data request by the ReadFile call?</p>
<div class="post">[<i>If you&#39;re going to issue a single I/O to the device, then it had all better be locked! It&#39;s hard to DMA into the pagefile. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018403">
				<div id="div-comment-1018403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018403">
			October 30, 2012 at 9:37 am</a>		</div>

		<p>@Axel: Exactly. &nbsp;Things have diverged a fair amount since then, but if you look at C# and .NET 1.0, it&#39;s essentially &quot;Delphi rewritten to look like Java.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018323">
				<div id="div-comment-1018323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018323">
			October 30, 2012 at 3:10 am</a>		</div>

		<p>Look, a 2 TB IO request may not make sense now, but in just a few years we&#39;ll all be pointing and laughing at the people who never said 640K ought to be enough for anybody, so we&#39;d better start rewriting things right now.</p>
<p>@Joseph: a non-fallacious rationalization is the simple observation that we&#39;re not &quot;designing standards for 64-bit computing&quot;. In itself, that&#39;s not such a good market to be in anyway (ask Intel about Itanium some time). What we *are* doing is getting 64-bit out there in a way that makes the most pragmatic sense. Sometimes that may err on the side of too much conservatism, but that tends to be less harmful than erring on the other side. Of course, everybody has their favorite examples of some doofus getting it obviously wrong.</p>
<p>The blanket statement &quot;there is no justification for a 31-bit size restriction on a 64-bit architecture&quot; is faintly ridiculous as a comment on a post where *just that* is demonstrated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018483">
				<div id="div-comment-1018483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018483">
			October 30, 2012 at 2:19 pm</a>		</div>

		<p>What&#39;s going to happen to Raymond&#39;s blog? &nbsp;It&#39;s clear from Windows 8 that Microsoft considers desktop applications deprecated, so why bother to have backward compatibility in the long run?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018533">
				<div id="div-comment-1018533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gerry</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018533">
			October 30, 2012 at 5:29 pm</a>		</div>

		<p>@JamesJohnston &#8211; To be fair, Delphi has provided overloaded versions of the conversion functions for many versions (not sure which one was first, before Delphi 2006. Yes it should have been earlier, preferably Delphi 2 when Win32 support was added). The original versions were written before multithreading was common &#8211; Delphi 1 was for Windows 3.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-1018453">
				<div id="div-comment-1018453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018453">
			October 30, 2012 at 11:58 am</a>		</div>

		<p>@xpclient: Windows RT has a full enough implementation of Win32 and the classic GDI model that the majority of Office 2013 Home &amp; Student can be ported, and that all the same desktop control panels are present. It&#39;s just that ordinary developers are not being permitted to even sideload apps, which is a very different thing. I would be *astonished* if Windows RT were not simply a recompile of the common source code, with just a few pieces written in assembly.</p>
<p>Macros are missing from Office RT because &#8211; assuming things are the same as they were when MacBU were trying to migrate from Carbon to Cocoa, see <a rel="nofollow" target="_new" href="http://www.schwieb.com/blog/2006/08/08/saying-goodbye-to-visual-basic/" rel="nofollow">http://www.schwieb.com/&#8230;/saying-goodbye-to-visual-basic</a> &#8211; the VBA bytecode interpreter is written in tens of thousands of lines of x86 assembly.</p>
<p>My suspicion is that the only reason that the desktop remains in Windows RT is because the Office team did not want to take a dependency on WinRT while it was still in its formative stages, and similarly that the control panels deemed less important were not prioritised for porting to WinRT. New core features like Storage Spaces probably didn&#39;t want to take a dependency on WinRT at this stage either. The Windows division have learned from the Longhorn debacle. Shipping is a feature.</p>
<p>Certainly Windows RT is intended to only ever be used on tablets &#8211; allowing any arbitrary code to be recompiled for it would not meet the design goals of very low power consumption and low heat output.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018463">
				<div id="div-comment-1018463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018463">
			October 30, 2012 at 1:06 pm</a>		</div>

		<p>@Mason Wheeler: &nbsp;&quot;if you look at C# and .NET 1.0, it&#39;s essentially &#39;Delphi rewritten to look like Java.&#39;&quot;</p>
<p>I&#39;d clarify that by saying it&#39;s essentially Delphi rewritten to look like Java, but with loads of improvements to the runtime libraries. &nbsp;Having worked with both .NET Framework and the VCL, I&#39;ve lost count of the number of times in the VCL I&#39;ve thought &quot;wow, this is like .NET, but worse.&quot;</p>
<p>For example: if you want to convert a string to a date/time from different formats, you have to modify *global variables* that control date/time formatting. &nbsp;(You wanted to multi-thread your program and use VCL date/time functions? &nbsp;Ha!!) &nbsp;The TDateTime constructor that accepts a string parameter won&#39;t accept any parameter that specifies formatting information. &nbsp;The only way I&#39;ve found is to modify global variables&#8230;</p>
<p>Comedy ensues when you have programs storing dates as strings in files that are shared across international borders and the programmer&#39;s didn&#39;t think to fuss with global variables to make it culture-neutral. &nbsp;At least .NET has an overload to make you think about it, and makes it brain-dead easy to use a culture-neutral format.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018583">
				<div id="div-comment-1018583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018583">
			October 30, 2012 at 8:24 pm</a>		</div>

		<p>[It doesn&#39;t matter whether you extend the parameter to 64 bits or not, because the maximum size of a single write is 32MB. (Remember that I/O buffers must be locked, and locking 4GB of memory is not very friendly to the memory manager.) -Raymond]</p>
<p>Then why support sizes larger than 32MB, like 2GB? This is just another rationalization.</p>
<p>We are talking about a legacy 32-bit API that supported 2GB I/O requests at a time when only 12MB to 16MB of system memory (NT 3.1) was expected. You simply do not get to talk about some irrelevant 32MB restriction as if it has any teeth&#8230; because it didnt then, so why would it now?</p>
<p>The reasoning is &quot;We don&#39;t have to change anything this way&quot; .. the rationalization is all this other stuff that makes excuses for it.</p>
<div class="post">[<i>I don&#39;t know where you got the idea that 32-bit Windows supported 2GB I/O requests. Like I said, the maximum was 32MB. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1018593">
				<div id="div-comment-1018593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018593">
			October 30, 2012 at 8:50 pm</a>		</div>

		<blockquote><p>
  Is Windows really locking all the pages of a ReadFile() call at once
</p></blockquote>
<p>Yes, this is about the first thing (along with the handle dereference) done by the I/O manager, for non-buffered requests. Because most of the further processing is done outside of the original process context.</p>
<blockquote><p>
  Then why support sizes larger than 32MB, like 2GB?
</p></blockquote>
<p>This is more likely for special applications, such as RDMA.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-davebacher even thread-even depth-1" id="comment-1018673">
				<div id="div-comment-1018673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018673">
			October 31, 2012 at 6:34 am</a>		</div>

		<p>There is also an additional cost on all basic type changes. If a type changes bits, then you have to repack it from the other subsystem. &nbsp;If you change a type like SIZE_T, you also break cross task marshalling. &nbsp;In Delphi and other Pascal derivatives, there is more formalization, but having a structure different sizes still will complicate any IPC, and so these sorts of definition changes are bad there as well.</p>
<p>From an app architecture point of view, your better off ignoring the CPU, and sizing types based off of intended usage. &nbsp;Used to be I&#39;d advocate using 32bit values for most everything, but 64 is just too wide. &nbsp;You waste way too much space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1018683">
				<div id="div-comment-1018683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018683">
			October 31, 2012 at 6:39 am</a>		</div>

		<p>[I doubt that this lock-the-whole-range-at-once approach is the best way of doing I/O]</p>
<p>This would be an unnecessary optimization for obscenely large I/O requests, causing unnecessary complication of the storage stack. Otherwise if you lock pages as you go, you can&#39;t do asynchronous I/O. Welcome to early single-threaded UNIX.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018613">
				<div id="div-comment-1018613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018613">
			October 31, 2012 at 2:26 am</a>		</div>

		<p>[If you&#39;re going to issue a single I/O to the device, then it had all better be locked! It&#39;s hard to DMA into the pagefile. -Raymond]</p>
<p>Ok, thats how it is implemented today: The low-level drivers will not request the pages as needed to be present in memory to lock them. But I doubt that this lock-the-whole-range-at-once approach is the best way of doing I/O. The discussed examples of starting very large* I/O operations demonstrate that this strategy will needlessly lock pages for absurd long durations.</p>
<p>* &nbsp;&quot;Large&quot; in terms of time it will take to complete, which will be many hours for a 2 TB read operation even on a harddisk, let alone slower devices like CD-ROM/Blu-Ray, USB-Sticks or network access.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>