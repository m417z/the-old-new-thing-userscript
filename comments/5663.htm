<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (58)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1029703">
				<div id="div-comment-1029703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anyfoo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029703">
			January 2, 2013 at 7:49 am</a>		</div>

		<p>This makes me curious what the arguments against MOV EDI, EDI are (no matter how correct they turn out to be)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029733">
				<div id="div-comment-1029733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029733">
			January 2, 2013 at 8:00 am</a>		</div>

		<p>@anyfoo: Mostly idiocy. I&#39;d have used MOV EAX, EAX which is basically the same thing.</p>
<p>Filler text to avoid the spam filter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029753">
				<div id="div-comment-1029753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029753">
			January 2, 2013 at 8:08 am</a>		</div>

		<p>Intel&#39;s documentation recommends &nbsp;0x66 0x90 &nbsp; as a 2 byte NOP, &nbsp; not mov edi edi.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029783">
				<div id="div-comment-1029783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029783">
			January 2, 2013 at 9:44 am</a>		</div>

		<p>@Jon: Apart from on some architectures that&#39;s an invalid instruction, so you&#39;ll get an enormous fault up to the kernel and lose 10000 cycles every time you hit one of those on an old CPU.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029793">
				<div id="div-comment-1029793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">a random passerby</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029793">
			January 2, 2013 at 9:59 am</a>		</div>

		<p>Bother, my previous comment must&#39;ve been filtered for being too long. But Matt makes a better point than I did, anyways.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1029803">
				<div id="div-comment-1029803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029803">
			January 2, 2013 at 10:25 am</a>		</div>

		<p>@Matt:</p>
<p>Live pathing is only supported on the OS versions that don&#39;t run on ancient CPUs.</p>
<div class="post">[<em>You&#39;re looking at the problem at the wrong level. What happens if somebody sets the /hotpatch flag for a non-OS app that intends to run downlevel? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029813">
				<div id="div-comment-1029813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029813">
			January 2, 2013 at 10:46 am</a>		</div>

		<p>alegrl: Live pathing is only supported on the OS versions that don&#39;t run on ancient CPUs.</p>
<p>A curious statement. I can find no evidence that /hotpatch is supported for x64. A Google search only turns up somebody complaining on the forums that it doesn&#39;t work (compiler complains). If there is no /hotpatch for x64 than we will soon be saying /hotpatch is only supported for ancient CPUs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1029833">
				<div id="div-comment-1029833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029833">
			January 2, 2013 at 10:47 am</a>		</div>

		<p>[You&#39;re looking at the problem at the wrong level. What happens if somebody sets the /hotpatch flag for a non-OS app that intends to run downlevel? -Raymond]</p>
<p>OK, 66 90 actually should not cause an exception on any 32+ bit architecture because it&#39;s XCHG AX,AX or XCHG RAX,RAX.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029863">
				<div id="div-comment-1029863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">a random passerby</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029863">
			January 2, 2013 at 11:18 am</a>		</div>

		<p>[66 90 actually should not cause an exception on any 32+ bit architecture because it&#39;s XCHG AX,AX or XCHG RAX,RAX.]</p>
<p>@alegr1: Really. From the documentation I found 0x66 is an SSE2 extension introduced by the Pentium 4. XCHG is 0x86. And all 2-byte opcodes prefixed with 0x66 were introduced in P4 or later (and many were only introduced in Core 2). I&#39;m not sure how 0x66 0x90 would ever be a valid byte patter prior to SSE2, and there are a lot of 32 bit processors that predate it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029873">
				<div id="div-comment-1029873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Csaboka</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029873">
			January 2, 2013 at 11:28 am</a>		</div>

		<p>@a random passerby:</p>
<p>You should really search more thoroughly next time. 0x66 is the operand size prefix &#8211; it makes instructions 32-bit wide in 16-bit mode and 16-bit wide in 32-bit mode. See details here: <a rel="nofollow" target="_new" href="http://wiki.osdev.org/X86-64_Instruction_Encoding#Operand-size_and_address-size_override_prefix" rel="nofollow">wiki.osdev.org/X86-64_Instruction_Encoding</a></p>
<p>Intel may have given it special meaning for more modern instructions, but for the basic instructions that are present in up to and including the 386, it affects the operand size.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029883">
				<div id="div-comment-1029883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029883">
			January 2, 2013 at 11:32 am</a>		</div>

		<p>0x66 is the operand size prefix and was present on the 386 &#8211; &nbsp;ie. &nbsp;on processors older than those that Windows NT runs on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029913">
				<div id="div-comment-1029913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029913">
			January 2, 2013 at 12:08 pm</a>		</div>

		<p>I&#39;ve found a neat little code to insert hooks into hot patched compatible binaries (x86)</p>
<p><a rel="nofollow" target="_new" href="http://www.secnews.pl/en/2012/12/07/hot-patching/" rel="nofollow">http://www.secnews.pl/&#8230;/hot-patching</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1029933">
				<div id="div-comment-1029933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029933">
			January 2, 2013 at 12:27 pm</a>		</div>

		<p>@alegr1:</p>
<p>From the Intel processor manual:</p>
<p>The one-byte NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.</p>
<p>The multi-byte NOP instruction performs no operation on supported processors and generates undefined opcode exception on processors that do not support the multibyte NOP instruction.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1029943">
				<div id="div-comment-1029943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029943">
			January 2, 2013 at 12:29 pm</a>		</div>

		<p>Stop posting link-spam to your own website. There are plenty of free and better solutions for hooking APIs (see Detours, EasyHook etc).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030013">
				<div id="div-comment-1030013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030013">
			January 2, 2013 at 2:04 pm</a>		</div>

		<p>Do these administrators know if all different versions of patches is backwards and forward compatible? No, because most patches can&#39;t be trusted to be compatible with hot-patching. How did this feature gain even -100 points?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1030033">
				<div id="div-comment-1030033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030033">
			January 2, 2013 at 2:34 pm</a>		</div>

		<p>@Matt:</p>
<p>How about actually reading what&#39;s written there in the said Intel manual, and paying attention to the opcodes of the multi-byte NOP commands there?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030043">
				<div id="div-comment-1030043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Richard Russell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030043">
			January 2, 2013 at 2:59 pm</a>		</div>

		<p>Having written my own x86 assembler, I can confirm that 66 90 is indeed the opcode for &#39;xchg ax,ax&#39; (in 32-bit mode).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030083">
				<div id="div-comment-1030083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030083">
			January 2, 2013 at 6:27 pm</a>		</div>

		<p>@640k: Because the Linux guys can indeed patch almost everything without rebooting. Really only kernel &amp; X need to reboot, and sometimes not even X. For i386 if you&#39;re lucky someone will have a ksplice module for you so you don&#39;t have to reboot. MS just had to implement the same thing for security patches.</p>
<div class="post">[<em>I like how it&#39;s &quot;except the kernel, the window manager, and IPC.&quot; That&#39;s all the interesting parts! That&#39;s like saying &quot;no part of the car is affected except the engine and the electronics.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1029953">
				<div id="div-comment-1029953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1029953">
			January 2, 2013 at 12:41 pm</a>		</div>

		<p>I find the soft hyphen to be more useful when many of the following are true:</p>
<p>* Horizontal width of the column is low</p>
<p>* Text is justified (both right- and left-aligned)</p>
<p>* Words are broken far from their beginning or ending</p>
<p>* (That is to say, only long words are broken, and then only in the middle)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030103">
				<div id="div-comment-1030103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030103">
			January 3, 2013 at 1:40 am</a>		</div>

		<p>@alegr, richard: I work at Intel. You are both wrong (and in richard&#39;s case, your x86 assembler is also wrong).</p>
<p>There is no mneumonic for XCHG EAX, EAX, or XCHG AX, AX. This instruction does not exist.</p>
<p>Opcode 90 is (and has always been) implemented in silicon as a NOP (pipeline ignore) not an XCHG. This is important because otherwise a NOP could cause pipeline stalls waiting for EAX (or AX)es value to be resolved by older processors who would then need EAX to be fully resolved (i.e. leave the register renaming unit for XCHG resolution) before EAX could be used.</p>
<p>That is why 66 90 can cause an invalid opcode instruction on some older models. A memory-size prefix followed by a pipeline ignore is invalid; it is not, and never was an MEMPREFIX:XCHG a,a</p>
<p>Later models (up to about PI) would ignore the error and continue, but it would still take longer to complete than a MOV.</p>
<p>That is why our advice was not to use a 66 90, but to use a 2 byte mov. The reason we chose EDI was because EDI is the least likely register to still be in the pipeline at the start of a function (based on running about half a million programs through our simulator). Consequently using MOV EDI, EDI is less likely to cause a pipeline stall waiting for the register&#39;s result to be finalized from a previous &quot;in-flow&quot; instruction.</p>
<p>I don&#39;t see why this is so hard. Raymond told you guys that the reason MOV EDI, EDI was chosen was because it was faster according to the processor team at Intel (and presumably AMD). Don&#39;t argue with them. If you disagree with the Intel processor team about what the fastest 2-byte NOP is, it&#39;s probably because you&#39;re wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030133">
				<div id="div-comment-1030133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030133">
			January 3, 2013 at 2:33 am</a>		</div>

		<p>Spoke too soon. There is a mnemonic for XCHG EAX, EAX in long mode, (just not in legacy mode): 87 C0.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030143">
				<div id="div-comment-1030143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anyfoo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030143">
			January 3, 2013 at 2:49 am</a>		</div>

		<p>Matt, thanks for the insight, makes perfect sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030163">
				<div id="div-comment-1030163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny Moules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030163">
			January 3, 2013 at 4:15 am</a>		</div>

		<p>&quot;Don&#39;t argue with them. If you disagree with the Intel processor team about what the fastest 2-byte NOP is, it&#39;s probably because you&#39;re wrong.&quot;</p>
<p><a rel="nofollow" target="_new" href="http://yourlogicalfallacyis.com/appeal-to-authority" rel="nofollow">yourlogicalfallacyis.com/appeal-to-authority</a></p>
<p>Ah, the amount of times I&#39;ve heard that argument from teams, vehemently certain they can&#39;t be at fault because they surely know their own application better than anyone, who then have major egg on their face when their application is shown to have a major security fault. The funny thing is they even have all the evidence up front but, because of their hubris, don&#39;t bother checking before they outright reject the assertion. They fail to realise that other people can choose, as their area of research, a third-party product &#8211; unladen with the bias of it being their own. The best authorities on Adobe security, for example, exist well outside Adobe.</p>
<p>Note that I don&#39;t argue that they&#39;re not often more likely to be correct. Rather, I vehemently disagree with the assertion that nobody should bother trying to correct it. People who think that their authority means they should reasonably be beyond scrutiny are the sort of people who don&#39;t get their work properly reviewed &#8211; and are therefore rather more likely to have it shot down.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030173">
				<div id="div-comment-1030173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030173">
			January 3, 2013 at 4:55 am</a>		</div>

		<p>@Danny Moules: You, as an armchair critic with no actual understanding of processors, with no benchmarks and with no relevant experience do not understand Intel&#39;s processors better than the Intel processor team. You might know more than some people at Intel (e.g. people in finance) and some people outside Intel might know more than everyone at Intel (e.g. an ex-employee of Intel&#39;s or an expert at a competitor company). But Raymond didn&#39;t ask a random person at Intel, he asked the IAX processor team. And you are almost certainly not one of the tiny number of people qualified to assess, never mind the even smaller number of people qualified to contradict Intel&#39;s assertion about what the fastest effective nop on their processors is.</p>
<p>In summary: If you disagree with the Intel processor team about what the fastest 2-byte NOP is, it&#39;s probably because you&#39;re wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030183">
				<div id="div-comment-1030183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny Moules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030183">
			January 3, 2013 at 5:44 am</a>		</div>

		<p>You&#39;re still falling foul of the fallacy. My hobby (security research) is entirely based upon the premise that intelligent people can, and do, regularly disprove engineer&#39;s assumptions about their own products. Their &#39;authority&#39; is irrelevant. Sony assert that nobody could possibly break their keys and then somebody does because they got sick of hearing it said. Social networks say they know their systems don&#39;t have holes and then it&#39;s shown they do (<a rel="nofollow" target="_new" href="http://www.theregister.co.uk/2012/09/05/menshn_password_reset_vuln/" rel="nofollow">http://www.theregister.co.uk/&#8230;/menshn_password_reset_vuln</a>).</p>
<p>The fallacy is not assuming that people with authority are liable to be correct. It&#39;s assuming that because the team understand their product that everybody else is ill-suited to refute those assumptions. In fact, they are the most likely people to be blinkered because they will invariably look at things through &#39;Intel-coloured glasses&#39;, to paraphrase Raymond. In research peer review is not only desirable, it&#39;s considered necessary. The people who build a system are assumed to be the worst at assessing it (this assumption is patently not true but it&#39;s ultimately so useful as to be a mantra).</p>
<p>Incidentally I assume you meant &#39;you&#39; in the global term. Unless you think I&#39;m trying to represent myself as somebody who could prove the the team&#39;s assertion wrong. That&#39;s certainly not the case, I&#39;m talking about a principle. e.g. Bruce Schneier does not build his own crypto systems in a vacuum. He openly asks everyone to challenge his assertions. Although <em>the</em> leading expert on his algorithms or his lectures, he gets plenty of valid criticism which ultimately makes his work even better. This is true of the entire cryptographic profession. Nobody with any sense &#39;rolls their own&#39;, even if they <em>are</em> the best in the world. It&#39;s just too damn complicated for a crack team of the best to do by themselves with any reliability. I know from my own experience with writing kernels and poking around GPUs that this level of complexity is shared in processor-land.</p>
<p>Being the best does not make you infallible. Therefore it&#39;s unreasonable to suggest (as you did initially) &quot;Don&#39;t argue with them&quot;. People can, and do, argue with leading authorities all the time and win. That&#39;s pretty much what research is about. I have no problem with your summary, that people who challenge them are likely to get their asses handed to them (because they are) but that&#39;s no justification for nobody to try. That assertion is fundamentally based on a logical fallacy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030193">
				<div id="div-comment-1030193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030193">
			January 3, 2013 at 6:22 am</a>		</div>

		<p>@Danny Moules</p>
<p>The &quot;probably&quot; is in his statement because there is a slight chance there is a better solution. Yes, the argument is an appeal to authority, but it certainly is a good one. Microsoft decided to put a 2-byte NOP in every function call, so they definitely wanted to be certain that it was as efficient as possible. They went out to the appropriate experts in the field (such as the IAS processer team), which also certainly understood the importance of giving the best possible answer. After all this research they used the NOP given in the article, because a team of experts agreed that it is the best solution. There is a chance that someone can find a better NOP, but there is no reason for anyone here to assume that the ideas they throw out off the top of their heads are going to work better than what Intel, Microsoft and presumably other manufacturers determined &#8211; I suspect that pretty much any idea given in this thread or the previous one was already considered and ultimately rejected. If someone would bother to explain why they think their NOP is better with a well-reasoned argument (it could be safely assumed that Intel had a well-reasoned argument even before Matt&#39;s post), then I&#39;m sure you could get some civil discussion about the solution.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030203">
				<div id="div-comment-1030203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Another Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030203">
			January 3, 2013 at 6:49 am</a>		</div>

		<p>My argument isn&#39;t about which NOP is the best, &nbsp;it&#39;s about the documentation.</p>
<p>If Intel think mov edi,edi &nbsp;is the best 2-byte NOP, &nbsp;then why does the documentation say to use 66 90 ?</p>
<div class="post">[<em>66 90 is probably the best 2-byte nop <span style="text-decoration:underline;">if you know that your CPU supports it</span>. But Windows needs to run on processors which may not support 66 90. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030213">
				<div id="div-comment-1030213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random User 68973290</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030213">
			January 3, 2013 at 7:22 am</a>		</div>

		<p>@Another Jon</p>
<p>Probably because, while &quot;mov edi,edi&quot; is <em>usually</em> in effect a NOP at the start of most functions, is is not in fact a true NOP. As Matt points out, the MOV can cause a pipeline stall waiting on registers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030223">
				<div id="div-comment-1030223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030223">
			January 3, 2013 at 8:10 am</a>		</div>

		<p>@Another Jon: Which documentation are you looking at? Features and best practices have changed throughout the IAx86 series of processors, so it&#39;s quite possible that what you have is correct for a certain class of processor but not necessarily all classes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030233">
				<div id="div-comment-1030233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random User 68973290</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030233">
			January 3, 2013 at 8:13 am</a>		</div>

		<p>&quot;if you know that your CPU supports it&quot;</p>
<p>Oh, right. Probably more that than what I said.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1030253">
				<div id="div-comment-1030253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030253">
			January 3, 2013 at 8:18 am</a>		</div>

		<p>[66 90 is probably the best 2-byte nop if you know that your CPU supports it. But Windows needs to run on processors which may not support 66 90. -Raymond]</p>
<p>Um, 66 90 is even supported by 80386. The only issue was that old Pentiums might not optimize this opcode as NOP.</p>
<div class="post">[<em>According to <a href="http://www.asmpedia.org/index.php?title=NOP" rel="nofollow">this web page</a>, it raises #UD on CPUs prior to family 6 (Pentium Pro). Note also that there are CPU manufacturers other than Intel. Do you know for sure that the Cyrix 6&#215;86 can handle 66 90? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030263">
				<div id="div-comment-1030263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030263">
			January 3, 2013 at 8:20 am</a>		</div>

		<p>@Danny: &quot;Being the best does not make you infallible&quot;</p>
<p>No, but it means that in a random crowd of people, several of whom know nothing about your product, but off the top of their head claim that &quot;X&quot; to be true about a thing you spend 9-5 researching and benchmarking for thirty years, it is so infintessimally small that they are right entirely by accident that it&#39;s almost not worth the argument.</p>
<p>If you&#39;ve studied it, be my guest and announce your findings. But don&#39;t claim that an expert panel are wrong off the top of your head without actually having the first bit of knowledge about the subject area at all or performing any real tests to check.</p>
<p>Suggesting that an Intel processors team with their combined years of expertise and massive benchmarks will have mistakenly said &quot;mov edi, edi&quot; to the question &quot;what is the fastest 2-byte nop &#8211; I need to know because that OS that runs on your processor that most of your customers use and will use to benchmark you against your main competitor is about to have this two byte sequence liberally sprinkled all over it, and if you give me the wrong answer it will be bad for your business&quot;, but would have entirely forgotten to check the performance versus the &quot;2-byte nop&quot; opcode says more about your understanding than about the experts&#39;.</p>
<p>Regards the security stuff, I think you have a very strange view of &quot;expert&quot;. Here is a hint: Intel knows a LOT about benchmarking their processors. Louise Mench &#8211; famed for being an MP who writes adult books and who quit in the middle of her job after admitting to taking class-A drugs, knows very, very little about securing websites.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1030273">
				<div id="div-comment-1030273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030273">
			January 3, 2013 at 8:38 am</a>		</div>

		<p>OK, Dr. Matt,</p>
<p>The Big Disagreement here has been whether 66 90 could be used at all. You claimed 66 90 will cause #UD on some processors that can run Windows NT. Because shaking hands with Intel experts makes you also an expert.</p>
<p>The reality is that 66 90 is not a multy-byte NOP (which may not be supported on older processors). It&#39;s a single byte NOP (equivalent to XCHG EAX, EAX) which may or may not be optimized into NOP by a particular pipeline design, with an operand size prefix, and is supported since 80386.</p>
<p>This is the end of story.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030293">
				<div id="div-comment-1030293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JDP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030293">
			January 3, 2013 at 8:55 am</a>		</div>

		<p>It&#39;s like Composition 101 all up in here. A fallacious appeal to authority is relying on an expert in field A for information or advice in field B. Ex: &quot;I trust Danny Moules to explain argumentation because he knows his stuff when it comes to computer security.&quot;</p>
<p>In the kind of example Danny gave above, there&#39;s a strong inductive argument in listening to an expert in his field. Yes, that expert may be proven wrong, but it&#39;s not per-se example of a fallacy to believe him or take his advice in his field of expertise.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030313">
				<div id="div-comment-1030313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030313">
			January 3, 2013 at 9:32 am</a>		</div>

		<p>@alegr1: What the hell are you talking about? 66 90 isn&#39;t a single byte, it isn&#39;t an XCHG EAX, EAX (nor is it equivilent to one &#8211; try it in long mode if you don&#39;t believe me) and on a substantial number of machines at the time when the question was asked 66 90 would either #UD or run orders of magnitude slower than MOV EDI, EDI.</p>
<p>THAT is the end of the story.</p>
<p>In fact, it was obviously the end of the story because Raymond said &quot;We asked Intel and they told us the answer&quot;.</p>
<p>Much as you and Danny might like to believe otherwise, magically summoning the answer out of your gut feelings and trying to claim that you now know better than the world&#39;s biggest collection of processor experts who were asked a business-critical question about a field they collectively have hundreds of years studying and who actually did the tests which clearly prove you wrong is more an indication of your egomania than an indication of your massive intellect.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1030343">
				<div id="div-comment-1030343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030343">
			January 3, 2013 at 10:06 am</a>		</div>

		<p>Matt,</p>
<p>On which CPU 66 90 would #UD and in which mode? Have you actually ever tried it (or had an architecture expert confirm that)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1030353">
				<div id="div-comment-1030353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030353">
			January 3, 2013 at 10:07 am</a>		</div>

		<p>We seem to be moving from &quot;appeal to authority&quot; to &quot;ad hominem&quot;&#8230;</p>
<p>The point Danny raises is valid (or not valid) regardless of Danny&#39;s personal expertise.</p>
<p>&quot;Because the processor vendors said so&quot; is an excellent business answer to &quot;why do we use this particular NOP?&quot; but an unsatisfying engineering answer, because it just raises the follow-up question &quot;OK, but why did the processor vendors favor that NOP?&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030373">
				<div id="div-comment-1030373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul Parks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030373">
			January 3, 2013 at 10:13 am</a>		</div>

		<p>@Maurits: I believe Matt answered the question about why MOV EDI,EDI was used in the comment at 2013/1/3 4:40 AM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030383">
				<div id="div-comment-1030383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030383">
			January 3, 2013 at 10:40 am</a>		</div>

		<p>@alegr: Matt also answered that one</p>
<p>&quot;From the Intel processor manual:</p>
<p>The one-byte NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.</p>
<p>The multi-byte NOP instruction performs no operation on supported processors and generates undefined opcode exception on processors that do not support the multibyte NOP instruction.&quot;</p>
<p>The fact that Intel say that multibyte NOPs (of which they explicitly mention 66 90 as a multibyte nop) can generate undefined opcode operations proves his point. They didn&#39;t say &quot;one and two byte nops won&#39;t generate a #UD&quot;. They just said that one byte ones won&#39;t.</p>
<p>Stop being a d*. You&#39;re clearly wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030393">
				<div id="div-comment-1030393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030393">
			January 3, 2013 at 10:51 am</a>		</div>

		<p>&quot;On which CPU 66 90 would #UD and in which mode?&quot;</p>
<p>The documentation is clear. &nbsp;Raymond quoted it earlier</p>
<p>The multi-byte form of NOP is available on processors with model encoding:</p>
<p>• CPUID.01H.EAX[Bytes 11:8] = 0110B or 1111B</p>
<p>This means multi-byte NOP is supported on families 6 and 15. &nbsp; Which is Pentium Pro and newer. &nbsp;Check the AMD documentation for the other half of the market.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1030423">
				<div id="div-comment-1030423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030423">
			January 3, 2013 at 11:09 am</a>		</div>

		<p>@Adrian, Dave:</p>
<p>Multi-byte NOP has two-byte opcode 0F 1F. One can have longer NOP command by using different addressing modes of these opcodes. and adding prefixes to them. In the Intel Architecture document, only 0F 1F is ever called multi-byte NOP. Only this opcode support is indicated by the said CPUID bit.</p>
<p>0x90 is a single-byte NOP, equivalent to XCHG EAX. A 0x66 prefix (operand size) doesn&#39;t magically make it an invalid opcode, because it&#39;s still a valid instruction on all IA32 CPUs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1030433">
				<div id="div-comment-1030433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030433">
			January 3, 2013 at 11:19 am</a>		</div>

		<blockquote><p>
  A 0x66 prefix (operand size) doesn&#39;t magically make it an invalid opcode, because it&#39;s still a valid instruction on all IA32 CPUs.
</p></blockquote>
<p>More on that. Opcodes from 0x90 to 0x97 are single-byte XCHG to a register, it&#39;s been this way since 8086, and it still means the same in the extended mode. Starting with 80386, an operand length prefix (0x66) could be applied to this command. There was no special case for 0x90 to make it an invalid to use with 0x66. 80486, Pentiums, etc kept it the same, because a) why bother, b) it would break existing software.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030443">
				<div id="div-comment-1030443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030443">
			January 3, 2013 at 11:23 am</a>		</div>

		<p>66 90 is a multibyte nop. You can tell this not only by the fact that it has multiple bytes and is a nop, but because it appears in &quot;Table 4-9. &nbsp;Recommended Multi-Byte Sequence of NOP Instruction&quot; of the Intel IA32 manual as entry &quot;2 bytes: 66 90&quot;.</p>
<p>90 is not an XCHG EAX, EAX in IA32 (90 was a XCHG AX, AX before the 8086, but since the 8086 it&#39;s been a NOP).</p>
<p>This discussion is getting boring. Proof that NOP isn&#39;t an XCHG:</p>
<p>&nbsp;MOV RBX, 1122334455667788h</p>
<p>&nbsp;XCHG EBX, EBX</p>
<p>result: RBX = 0000000055667788h</p>
<p>&nbsp;MOV RAX, 1122334455667788</p>
<p>&nbsp;db 90 ; // what you think is an XCHG EAX, EAX</p>
<p>result: RAX = 1122334455667788h.</p>
<p>This discussion is getting boring alegr. The reason why Mov EDI, EDI is the best 2 byte nop at the point where Microsoft asked is because that is the 2 byte sequence that Intel told them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1030463">
				<div id="div-comment-1030463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030463">
			January 3, 2013 at 11:36 am</a>		</div>

		<p>Matt:</p>
<p>So what you&#39;re saying 66 90 has suddenly become an invalid opcode on some processor architecture? You&#39;re mistaken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030473">
				<div id="div-comment-1030473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030473">
			January 3, 2013 at 11:46 am</a>		</div>

		<p>Matt: When you say &quot;90 was a XCHG AX, AX before the 8086&quot;, what came before the 8086? The 8008 and 8080 preceded it, but 90 was a subtraction opcode on those chips.</p>
<p>alegr1: Matt isn&#39;t saying that the opcode has &quot;suddenly&quot; become invalid; he said it was invalid on some older architectures. The 90 opcode has to be implemented as a NOP to prevent pipeline stalls. Since 66 is not a valid prefix for a NOP, 66 90 is not a valid opcode. While that combination may be ignored by current architectures, it does not mean that it always was.</p>
<p>Regardless, if 90 is implemented as XCHG AX, AX then it will be slow because it will cause a pipeline stall, making it ineligible for use in hot patching.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030483">
				<div id="div-comment-1030483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jas71_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jas71@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030483">
			January 3, 2013 at 11:53 am</a>		</div>

		<p>From Raymond&#39;s link, support is only conditional for the 3+ byte form &#8211; the 0x0f1f variants; the 1 and 2 bytes are documented there as NOT raising #UD. It seems quite likely it&#39;s Matt and Raymond who are right about 0x6690 failing on earlier CPUs, and the documentation Raymond linked to could well be mistaken, but Raymond does seem to have missed the &quot;&gt;= 3 bytes&quot; stipulation from his own link.</p>
<p>Dave: the documentation Raymond cited stipulates &#39;multi-byte NOP&#39; applies to the THREE (and more) byte forms only.</p>
<p>I get the impression &#8211; and would certainly expect &#8211; that Microsoft consulted more than just Intel. As Matt notes, &#39;MOV EAX,EAX&#39; sounds like an obvious candidate but actually has a nasty drawback (it will wait for the value of EAX to be current, even though it doesn&#39;t really matter); on the previous thread someone suggested &#39;lea esi, [esi]&#39;, which would have a worse version of that flaw on some cores (address generation interlock).</p>
<p>On ARM the recommended NOP after a CPU mode transition used to be &#39;MOVNV R0,R0&#39; (the NV &#8211; Never &#8211; conditional prefix negating the instruction&#39;s entire meaning anyway); irritatingly, ARM later deprecated the NV condition code then redefined it as &quot;special purpose&quot;, recommending a plain &quot;MOV R0,R0&quot; as NOP instead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030513">
				<div id="div-comment-1030513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@jas88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030513">
			January 3, 2013 at 12:11 pm</a>		</div>

		<p>&quot;From Raymond&#39;s link, support is only conditional for the 3+ byte form &#8211; the 0x0f1f variants&quot;</p>
<p><a rel="nofollow" target="_new" href="http://download.intel.com/design/processor/manuals/253667.pdf" rel="nofollow">download.intel.com/&#8230;/253667.pdf</a></p>
<p>&quot;The multi-byte NOP instruction performs no operation on supported processors and generates undefined opcode exception on processors that do not support the multibyte NOP instruction.&quot; suggests that the two byte form might raise a #UD. 66 90 is clearly included in the &quot;multibyte nops&quot; group as shown from the table that immediately follows it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1030523">
				<div id="div-comment-1030523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030523">
			January 3, 2013 at 12:14 pm</a>		</div>

		<p>[According to this web page, it raises #UD on CPUs prior to family 6 (Pentium Pro). Note also that there are CPU manufacturers other than Intel. Do you know for sure that the Cyrix 6&#215;86 can handle 66 90? -Raymond]</p>
<p>This page says that UD is only thrown for 0f 1f opcode.</p>
<div class="post">[<em>You&#39;re right, I misread the table. But I wouldn&#39;t be surprised if it was suboptimal on older processors. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030543">
				<div id="div-comment-1030543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JDP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030543">
			January 3, 2013 at 12:32 pm</a>		</div>

		<p>I like that the conversation&#39;s gone from &quot;Well, what about THIS OPCODE?&quot; to &quot;Let&#39;s look at what intel&#39;s documentation says.&quot; Eventually people will check with AMD and get tenuously close to &quot;after consulting with CPU manufacturers for their recommendations&quot; as Raymond first wrote.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1030673">
				<div id="div-comment-1030673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030673">
			January 3, 2013 at 5:23 pm</a>		</div>

		<p>[According to this web page, it raises #UD on CPUs prior to family 6 (Pentium Pro). Note also that there are CPU manufacturers other than Intel. Do you know for sure that the Cyrix 6&#215;86 can handle 66 90? -Raymond]</p>
<p>Indeed. According to this [ <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Cyrix_coma_bug" rel="nofollow">en.wikipedia.org/&#8230;/Cyrix_coma_bug</a> ] Wiki page, XCHG instruction can leave Cyrix 6&#215;86 processors in uninterruptable state forever. The fix is to insert NOP if you need to use XCHG at all.</p>
<p>Therefore if you know your code will run on Cyrix processors, you&#39;ll want to avoid using it as NOP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030333">
				<div id="div-comment-1030333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030333">
			January 3, 2013 at 10:01 am</a>		</div>

		<p>66 90 is the best instruction *Intel* can recommend *currently*. It has nothing to do with any hardware or any truth.</p>
<p>1. Intel is not the only x86 cpu manufacturer in town.</p>
<p>2. What Intel recommends today is not the same as they recommended yesterday and tomorrow.</p>
<p>3. With Intel&#39;s compiler tricks in recent memory, actually the ONLY important metric Intel should optimize every answer for are stockholder value. Let&#39;s say the recommended instruction performs lousy on competitors hardware and mediocre on current Intel hardware, recommending that instruction gives the best value for Intel&#39;s stockholder, even if it performs worse than any other instruction.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1030703">
				<div id="div-comment-1030703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030703">
			January 3, 2013 at 7:05 pm</a>		</div>

		<p>@cheong00:</p>
<p>The cyrix problem is related to XCHG with memory operand (and possibly unaligned). It goes through absolutely different uops than a register XCHG, and also involves an implicit LOCK.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com even thread-even depth-1" id="comment-1030713">
				<div id="div-comment-1030713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030713">
			January 3, 2013 at 10:24 pm</a>		</div>

		<p>MS should make it more prominent which KBs support hotpatching. It is an under-used feature.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030663">
				<div id="div-comment-1030663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ShakeASpear</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030663">
			January 3, 2013 at 4:56 pm</a>		</div>

		<p>Much Ado About Nopping</p>
<p>*funny, no? &nbsp;punny? &nbsp;yes*</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1030773">
				<div id="div-comment-1030773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030773">
			January 4, 2013 at 1:26 am</a>		</div>

		<p>&quot;It goes through absolutely different uops than a register XCHG&quot;</p>
<p>Like 66 90 then.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1030783">
				<div id="div-comment-1030783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Oldcorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1030783">
			January 4, 2013 at 1:47 am</a>		</div>

		<p>One interesting aspect is that you could potentially split nop into two different things: &quot;some code that does nothing&quot; and &quot;an instruction to the processor to do nothing&quot;. The former implies using as few resources as possible, and the latter implies using a fixed amount of resource.</p>
<p>Microsoft&#39;s desire in this case is explicitly for the former, and it&#39;s certain that NOP itself has (at least at some points in the past, and maybe on some architectures now) had the semantics of the latter.</p>
<p>MOV EDI,EDI makes sense for this in that on a renaming CPU it uses only decode resources and rename resources (the rename potentially inducing a stall to wait for a previous EDI computation to complete). It&#39;s probable that no execution resources will be required at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-asklar even thread-even depth-1" id="comment-1031283">
				<div id="div-comment-1031283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alexander+Sklar' rel='external nofollow' class='url'>Alexander Sklar</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1031283">
			January 5, 2013 at 10:00 pm</a>		</div>

		<p>re:&quot;MS should make it more prominent which KBs support hotpatching. It is an under-used feature.&quot;</p>
<p>It&#39;s not under-used, we don&#39;t use it (well, haven&#39;t really). Not all fixes are hot-patchable, and it takes only one hotfix/GDR to force a reboot for the whole batch in a patch Tuesday. The likelihood of being able to avoid a reboot due to hot-patching is close to zero.</p>
<p>[Due disclosure] I work in the team that issues hotfixes/security updates/service packs, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1031263">
				<div id="div-comment-1031263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeroen Mostert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130102-00/?p=5663#comment-1031263">
			January 5, 2013 at 2:04 pm</a>		</div>

		<p>Well, I&#39;m glad I checked back on this discussion, even though the popcorn is stale by now. What a performance.</p>
<p>@Dave: if you want to get technical, there isn&#39;t really any difference between those two. Since the processor doesn&#39;t stop, a NOP does *something*, regardless of how its implemented &#8212; at the bare minimum, it increments the instruction pointer. Selecting a &quot;good&quot; NOP is harder than expected because 1. it must do nothing observable to a program, 2. it must work on all processor models we want to support, 3. if it slows down the program, it should do so to the least extent possible. As the discussion here shows, doing nothing well can be surprisingly hard. Perhaps the Tao Te Ching should be consulted, in addition to any processor manuals.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>