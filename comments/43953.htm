<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1153223">
				<div id="div-comment-1153223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vitor Canova</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153223">
			September 30, 2014 at 8:44 am</a>		</div>

		<p>To complex to my understand but good to see that there is a good explanation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-robrobpaveza-net odd alt thread-odd thread-alt depth-1" id="comment-1153233">
				<div id="div-comment-1153233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Rob+Paveza+%5Bmsft%5D' rel='external nofollow' class='url'>Rob Paveza [msft]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153233">
			September 30, 2014 at 9:01 am</a>		</div>

		<p>Joel on Software&#39;s excellent treatment of character encodings and Unicode would probably help understand as well &#8211; <a rel="nofollow" target="_new" href="http://www.joelonsoftware.com/articles/Unicode.html">http://www.joelonsoftware.com/&#8230;/Unicode.html</a></p>
<p>Separately: I was under the impression that Windows &quot;Unicode&quot; was UCS-2, because UTF encoding didn&#39;t exist when NT was minted. &nbsp;Is that inaccurate?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zlynx even thread-even depth-1" id="comment-1153243">
				<div id="div-comment-1153243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zan+Lynx%27' rel='external nofollow' class='url'>Zan Lynx'</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153243">
			September 30, 2014 at 9:21 am</a>		</div>

		<p>It used to be UCS-2 back when Microsoft thought 16,384 characters was enough for everyone. It wasn&#39;t though, so they had to change over to UTF-16LE. Which, in my opinion, was a horrible result. Now they have the worst of both worlds and none of the benefits.</p>
<p>Well maybe one benefit: programmers generally know right away if they forgot to convert ASCII to UTF-16, when with UTF-8 the program will go along just fine until it hits a land mine.</p>
<p>UTF-16 still has programmers thinking that they can jump ahead 5 characters or trim a string at 80 characters just with array indexes though.</p>
<p>And I only know one person (it isn&#39;t me!) who understands how to figure out how long a Unicode string is in display characters as opposed to code points (if I have those terms right) because there are weird things like combining diacriticals and non-displayed hyphens.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153253">
				<div id="div-comment-1153253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Crowell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153253">
			September 30, 2014 at 9:54 am</a>		</div>

		<p>Zan,</p>
<p>Even the .NET framework doesn&#39;t properly handle indexing a string with anything other than 16-bit characters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153263">
				<div id="div-comment-1153263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153263">
			September 30, 2014 at 10:12 am</a>		</div>

		<p>&gt;when Microsoft thought 16,384 characters was enough for everyone.</p>
<p>&quot;Microsoft&quot; thought that because the Unicode consortium told them it was so. &nbsp;For a short time in the early 90s, we lived in a world of bliss (as opposed to when I worked at DEC and lived in a world of BLISS) where there was one character encoding and all characters had the same size.</p>
<p>I used to hold the opinion that 16-bit characters was appropriate, but UTF16 has convinced me that I am misguided. UTF8 is a better encoding. &nbsp;But this author expresses it better than I can: <a rel="nofollow" target="_new" href="http://www.theregister.co.uk/2013/10/04/verity_stob_unicode/">http://www.theregister.co.uk/&#8230;/verity_stob_unicode</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153283">
				<div id="div-comment-1153283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153283">
			September 30, 2014 at 10:57 am</a>		</div>

		<p>I was not expecting Raymond to summon this one again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153293">
				<div id="div-comment-1153293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nico</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153293">
			September 30, 2014 at 12:14 pm</a>		</div>

		<p>@dave</p>
<p>That Register article is fantastic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153303">
				<div id="div-comment-1153303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153303">
			September 30, 2014 at 12:24 pm</a>		</div>

		<p>To make things worse, while on Windows &quot;Unicode&quot; is UTF16-LE (sizeof(wchar_t) == 2), on Unix it often is UTF32 (sizeof(wchar_t) == 4). It gets better with C11 and its separate char16_t and char32_t types, but given how long it took for Microsoft to adopt C99, I&#39;m not hopeful.</p>
<p>With UTF32, mojibake would be hard to happen, since modern Unicode is (IIRC) 21-bit, and most misdetected text won&#39;t have NUL bytes. On the other hand, it&#39;s quite wasteful in its space use (while being simpler for not having to use surrogates for codepoints outside the BMP); it&#39;s no wonder Unix programmers tend to use UTF-8 instead (or, when using some portable frameworks like Qt, UTF-16).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153313">
				<div id="div-comment-1153313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Raphael</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153313">
			September 30, 2014 at 12:50 pm</a>		</div>

		<p>Screw it, I&#39;m just gonna use UTF-32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153333">
				<div id="div-comment-1153333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153333">
			September 30, 2014 at 1:10 pm</a>		</div>

		<p>I hold the opinion that the real issue with UTF16 is one of education more than anything else. Even before UTF8, even before they added surrogates and created UTF16, Unicode was not a fixed length encoding. The combining accents starting at U+0300 were in Unicode version 1. So from the start you should have seen even UCS2 and UCS4 as a variable length encoding.</p>
<p>The real thing that changed between UCS2 and UTF16 was that instead of just being variable size in how many code points there were per display character, it also became variable in how many code units were used per code point. What was more problematic was that due to compatibility, they couldn&#39;t just throw the UCS2 encoding away but instead extend it somehow. This was why surrogates leaked in rather than a new encoding for 16 bit code units happened.</p>
<p>The reason why I say, and always believe that this is more a matter of education than the UTF16 encoding is that people somehow don&#39;t get properly taught the semantic changes between ANSI and Unicode, probably somehow believing that even Unicode has a one character per code point mapping. Rather than this, new programmers get to Unicode because of a compiler error and get told &quot;change char to TCHAR&quot; and things like that. If they don&#39;t get taught that Unicode is different, then how are they to know that it is. If they did get taught that Unicode is variable length then they wouldn&#39;t get caught off guard with surrogates or with the concept of more than once code point per character.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153343">
				<div id="div-comment-1153343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DispatcherLock</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153343">
			September 30, 2014 at 1:16 pm</a>		</div>

		<p>@dave</p>
<p>Which did you like better, Pillar or BLISS?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153353">
				<div id="div-comment-1153353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark S</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153353">
			September 30, 2014 at 2:36 pm</a>		</div>

		<p>Wow. &nbsp;After today I have a clear picture of Unicode vs. UTF-8, UTF-16, and what&#39;s going on under the hood in Windows and .NET. &nbsp;It isn&#39;t a pretty picture, but all those little fuzzy pieces have been resolved. &nbsp;Lack of a time machine really bites MS again, doesn&#39;t it. &nbsp;You&#39;d think MS Research would have given it a higher priority</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153363">
				<div id="div-comment-1153363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153363">
			September 30, 2014 at 3:39 pm</a>		</div>

		<p>Treating UTF-16 as UCS-2 works well most of the time. Not to mention that most users don&#39;t really need ancient Egyptian hieroglyphs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153383">
				<div id="div-comment-1153383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153383">
			September 30, 2014 at 4:20 pm</a>		</div>

		<p>@Azarien:</p>
<p>Well, it isn&#39;t really that much of a choice unless you properly check for illegal UCS2 sequences, like the surrogate pairs, and show them as bad characters. But you are then suddenly not treating UTF16 as UCS2. But while most users don&#39;t need Hieroglyphs, East Asian users could want to use plane 2 for the extra CJK characters that could appear in names. There are also other scripts from minor languages there, so it is very short sighted to just ignore anything above the BMP if you plan to deal with international clients. There is also the fact that more and more symbols are creeping into plane 1, like the musical notation and I am sure that even more dingbats will be going there. Also let&#39;s face it, who wouldn&#39;t want to be able to properly handle the pile of poo character (U+1F4A9).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153393">
				<div id="div-comment-1153393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153393">
			September 30, 2014 at 4:47 pm</a>		</div>

		<p>@Cesar where does Unix use UTF-32? I have to say I&#39;ve not come across it. Everything I&#39;ve seen uses UTF-8 with a handful of programs in the same position as Windows, using UTF-16 for historical reasons (and usually failing at it &#8211; try to type a pile of poo in Konsole for example&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153403">
				<div id="div-comment-1153403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153403">
			September 30, 2014 at 5:54 pm</a>		</div>

		<p>@Muzer: All the wcs* functions (standard wide char functions) in C and consequently std::wstring and friends in C++ use a 4-byte wchar_t, thus UTF-32. But yeah, as I mentioned Unix people tend to not use wide chars, they use UTF-8 most often, with Qt and Java programs (and a few others) mixing it with UTF-16 (as you said, for historical reasons; the consensus seems to be that UTF-8 makes more sense for new frameworks).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153413">
				<div id="div-comment-1153413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Count Zero</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153413">
			October 1, 2014 at 12:58 am</a>		</div>

		<p>I think the &quot;best&quot; encoding for non-Asian users is UTF-8. (And it even works for Asian languages.) In case of basically Latin characters UTF-16 is a waste of resources &#8211; not to mention UTF-32. Every one of us have seen those files in hexdump with those 0x00 bytes. That thing almost make my eyes bleed every time. </p>
<p>Their only benefit would be their indexability, but since separate accent modifier characters (like U+005E &#8211; or &quot;add a circumflex character to the following character&quot;), and code points above 0xFFFF renders this property invalid. So you still can&#39;t get the 5ᵗʰ glyph of a string by getting its szSample[4] character. Those days are poorly over now. And our only solace is the increasing processing capacity that makes the more complex string operations affordable.</p>
<p>In contrary UTF-8 is more space efficient which makes parsing faster too. The only sad thing is UTF-8 came too late. NT kernel is built with UTF-16 in mind, and lots of our developer tools too. I can hope that some time in the near future Windows will have a chance to correct this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153423">
				<div id="div-comment-1153423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153423">
			October 1, 2014 at 2:11 am</a>		</div>

		<p>@Count Zero:</p>
<p>I&#39;m not going to say much about your opinion on what the best encoding is, since that is obviously subjective. The only thing I will mention is I feel you are wrong with one statement.</p>
<p>&quot;In contrary UTF-8 is more space efficient which makes parsing faster too.&quot;</p>
<p>This would only really be true for code points in the ASCII range. Code points U+0080 and above would need extra work, while UTF-16 means that you don&#39;t have to worry about this until code points U+10000 or above. So while it is less space efficient in the ASCII range, for code points outside of the ASCII range UTF-16 has less work to do per 16 bit code unit. Since it is then going to be scanning two bytes at a time linearly through memory, besides the higher probability of a cache miss, the processor will read the two bytes just as fast as it reads one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153433">
				<div id="div-comment-1153433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Count Zero</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153433">
			October 1, 2014 at 2:23 am</a>		</div>

		<p>@Crescens2k &#8211; I would happily agree if there weren&#39;t those pesky separate modifier characters that could (and will) extend the character width unpredictably. Since they are there and valid even in UTF-32 there is no guarantee that you can read an entire glyph with one operation. This makes code reading UTF-16 characters glyph-by-glyph (which IMHO is actually the way you need them) as complicated as code reading UTF-8 characters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153443">
				<div id="div-comment-1153443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153443">
			October 1, 2014 at 6:33 am</a>		</div>

		<p>@Crescens2k</p>
<p>It depends. &nbsp;UTF-8 can represent ASCII in one byte, while UTF-16 uses two. &nbsp;OTOH, UTF-16 can represent all BMP characters in two bytes where UTF-8 uses three for U+0800 and up. &nbsp;For non-BMP stuff, they&#39;re equivalent in terms of space usage. &nbsp;So UTF-16 is only better in the U+0800 to U+FFFF range. &nbsp;As it happens, this range appears to contain all of the CJK blocks as well as a number of other scripts. &nbsp;Most European scripts are below U+0800, though.</p>
<p>If you&#39;re doing HTML or anything else built out of ASCII markup characters, UTF-8 is usually more space efficient in practice.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-even depth-1" id="comment-1153463">
				<div id="div-comment-1153463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153463">
			October 1, 2014 at 7:18 am</a>		</div>

		<p>AFAIK, Windows use of UTF-16 as a primary character encoding is purely historical. Were it not for the fact that when the original NT was coded unicode specified the UCS(a 16 bit encoding) as the only serialization, then MS would likely be using UTF-8. But NT predates UTF-8 by a few years and switching now would break the golden rule of compatibility (although personally I would be in favor of having a set of U8 apis I don&#39;t think it will ever happen, that and missing [non-existent and not planned to be implemented ever] CRT support for UTF-8).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153593">
				<div id="div-comment-1153593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153593">
			October 1, 2014 at 10:15 am</a>		</div>

		<p>The whole argument about how many bytes the different encodings use for different types of scripts is pointless, because if you care at all about storage size, just compress it using your favorite compression method and be done with it. &nbsp;Both UTF-8 and UTF-16 compress about equally well [1].</p>
<p>[1]: <a rel="nofollow" target="_new" href="http://utf8everywhere.org/#faq.asians">utf8everywhere.org</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153623">
				<div id="div-comment-1153623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153623">
			October 1, 2014 at 11:00 am</a>		</div>

		<p>@Count Zero:</p>
<p>The whole issue is that you are more likely to have to reconstruct the modifiers with UTF-8. For example, if you come across say a À. In both ways of encoding this UTF-8 will have to take more time. With the code point itself it is higher that 0x7f, so it would be two bytes, for the combining form, the combining grave is above 0x7f and so it would be two bytes. This means that UTF-8 parsers would have to do more work.</p>
<p>@Kevin:</p>
<p>I&#39;m not debating whether UTF-8 is more space efficient. I&#39;m saying that everything outside of the ASCII range is more efficient to process in UTF-16 until you have to do something outside of the BMP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153643">
				<div id="div-comment-1153643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153643">
			October 1, 2014 at 12:01 pm</a>		</div>

		<p>@Adam Rosenfield: That&#39;s a strange argument. Pretty obvious if you&#39;re handling strings in your application you want to do something with them, from simple things like displaying to searching or indexing them. All of those operations can&#39;t be done on your compressed text which makes it bloody useless for anything but long term storage &#8211; which is generally uninteresting for the vast majority of applications.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153663">
				<div id="div-comment-1153663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153663">
			October 1, 2014 at 12:26 pm</a>		</div>

		<p>@voo: I&#39;d wager that in the vast majority of applications, the difference in memory footprint between storing uncompressed text as UTF-8 vs. UTF-16 is rarely more than +/- a few MBs (or maybe a few tens of MBs) [citation needed], which shouldn&#39;t be a concern on modern hardware. &nbsp;Text-heavy applications running on low-memory embedded or mobile devices might care, and certainly specialized applications like word processors and databases care, but business apps running on modern PCs really shouldn&#39;t care about those few MBs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153703">
				<div id="div-comment-1153703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153703">
			October 1, 2014 at 4:39 pm</a>		</div>

		<p>The space argument is really not one that is sane to use nowadays except in specialist uses, either for or against UTF-8. The main argument for UTF-8 is the ability to use the fact that it can be used with exactly the same string functions that people have been using for years without having to mess about with multi-byte chars, and can also be used with any old API call that expects a string of indeterminate encoding as long as it doesn&#39;t do too much more difficult text processing on it (like a &quot;delete one character&quot; type thing). UTF-8 really can be treated simply the same as an ordinary null-terminated-string-of-bytes in a very large proportion of use cases, which is its main strength.</p>
<p>Maybe this is less important for Windows users because of the long history of UTF-16 support, I don&#39;t know &#8211; I&#39;m not a Windows programmer. But it&#39;s certainly a very good argument for its use on networks, the web, etc. &#8211; existing stuff won&#39;t break horribly when they see UTF-8.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153733">
				<div id="div-comment-1153733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Count Zero</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153733">
			October 2, 2014 at 12:58 am</a>		</div>

		<p>@Adam Rosenfeld &#8211; You say &quot;the difference in memory footprint between storing uncompressed text as UTF-8 vs. UTF-16 is rarely more than +/- a few MBs (or maybe a few tens of MBs) [citation needed], which shouldn&#39;t be a concern on modern hardware.&quot;, I say we are not really thinking in terms memory or storage footprint nowadays. We are thinking in terms of bandwidth. And if you have ever tried to debug a server application and download a 4Gb log file &#8211; using a 3G mobile connection while you are on vacation (wasting your entire roaming data plan) &#8211; which would easily fit in 2Gb if it hasn&#39;t been encoded with a space-waster encoding, you would know the struggle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153753">
				<div id="div-comment-1153753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153753">
			October 2, 2014 at 6:41 am</a>		</div>

		<p>@Adam Rosenfield: What about cache misses? &nbsp;Even saving a few MB may be worth it when we&#39;re talking about an actively running program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153833">
				<div id="div-comment-1153833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153833">
			October 2, 2014 at 7:26 am</a>		</div>

		<p>@Count Zero: Yes, bandwidth is an important consideration. &nbsp;If you&#39;re transmitting a 4 GB log file, then you should absolutely be using compression in any case, either at the application level (compress before encoding) or at the protocol level (e.g. use a compressed Transfer-Encoding with HTTP such as by passing &#8211;compressed to curl, or use -C with scp, etc.).</p>
<p>@Kevin: That&#39;s a good point. &nbsp;You all have convinced the encoded size argument is not totally moot. &nbsp;I&#39;m a strong proponent of UTF-8 everywhere (in case that wasn&#39;t clear from the link I posted earlier), which in most cases wins the size comparison with UTF-16. &nbsp;Only in the rarer case of dense Asian text could I be convinced that UTF-16 is a superior encoding.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1153863">
				<div id="div-comment-1153863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153863">
			October 2, 2014 at 8:44 am</a>		</div>

		<p>From the day that Unicode broke the 16 bit barrier and their promise, it was inevitable that an encoding of Unicode in char * would predominate. Indeed UTF-8 had not yet arisen when MS wrote NT; however UTF-1 was already published. Don&#39;t get me wrong, UTF-1 was a poor encoding; nevertheless it showed what should have been. Once having seen UTF-1, the existence (although not the form) of a correct design was obvious.</p>
<p>All who use UTF-16 as the primary format are in the state of being legacy code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1153873">
				<div id="div-comment-1153873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1153873">
			October 2, 2014 at 9:11 am</a>		</div>

		<p>@Adam Rosenfield:</p>
<p>The thing is, as one smart person said, the actual performance of a program isn&#39;t truly known until you run it. I wrote a little program which created arrays of one and two bytes and then did something per array element to test how long the program would take.</p>
<p>The times below the following array sizes were returning 0ms.</p>
<p>Test completeArray of size 134217728 of element size 1</p>
<p>Access took 15 milliseconds</p>
<p>Test completeArray of size 268435456 of element size 1</p>
<p>Access took 31 milliseconds</p>
<p>Test completeArray of size 536870912 of element size 1</p>
<p>Access took 47 milliseconds</p>
<p>Test completeArray of size 1073741824 of element size 1</p>
<p>Access took 94 milliseconds</p>
<p>Test completeArray of size 67108864 of element size 2</p>
<p>Access took 15 milliseconds</p>
<p>Test completeArray of size 134217728 of element size 2</p>
<p>Access took 16 milliseconds</p>
<p>Test completeArray of size 268435456 of element size 2</p>
<p>Access took 47 milliseconds</p>
<p>Test completeArray of size 536870912 of element size 2</p>
<p>Access took 109 milliseconds</p>
<p>Test completeArray of size 1073741824 of element size 2</p>
<p>Access took 172 milliseconds</p>
<p>Running multiple times didn&#39;t change things too much. So the access time is bounded by the size of the data you are processing, not cache misses. What&#39;s more it doesn&#39;t really become noticeable until you get above a certain threshold.</p>
<p>So the question is, how often do you have to process documents that have more than 67 million code points. Also, while in this case the only thing I did was to touch the memory, how fast or slow is the processing in comparison with the memory access.</p>
<p>With the linear time nature of the access, the encoded size argument is not, IMO, that strong either. It would take a lot to convince me that the extra ~90ms at the largest test size is really such a bank breaker.</p>
<p>The more I read on the issue, the more I am convinced that the entire UTF-8 vs. UTF-16 debate is actually moot in most cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1154073">
				<div id="div-comment-1154073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">remis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1154073">
			October 3, 2014 at 8:32 am</a>		</div>

		<p>Guys,</p>
<p>you can&#39;t imagine how &quot;creative people&quot; can use this &quot;feature&quot;.</p>
<p>3 years ago I found a suspicious index.html on some web site. It was like valid HTML but right after &lt;/html&gt; there were many strange Chinese characters. Even if they were valid Chinese chars, text was totally meaningful.</p>
<p>Then I noticed if I change encoding to some 1 byte encoding that HTML turns into Chinese chars but these Chinese chars below become &lt;script&gt;a popular js virus at that time &lt;/script&gt;.</p>
<p>Antivirus program did not detect the virus in index.html.</p>
<p>I submitted this to: <a rel="nofollow" target="_new" href="https://www.microsoft.com/security/portal/submission/submissionhistory.aspx?SubmissionId=a516c592-9cb3-4828-bc0c-d347b1b05e66">http://www.microsoft.com/&#8230;/submissionhistory.aspx</a></p>
<p>and they said &quot;no infection detected&quot;.</p>
<p>But imagine possibilities considering there is a complex logic in browser to choose encoding for html page when HTML is not strictly formed: current locale, BOM header&#8230;</p>
<p>On other side antivirus also has some logic detecting locale when scanning that html file before browser can access it.</p>
<p>There is a chance that antivirus and browser logic differs and wow! Here is a way to bypass antivirus and execute malicious script inside the browser.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1154133">
				<div id="div-comment-1154133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">remis (again)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1154133">
			October 3, 2014 at 11:20 am</a>		</div>

		<p>I didn&#39;t want to make a Day 0. I just wanted to make it Day -7.</p>
<p>Dear Moderator, did you check it&#39;s safe with Malware Protection Center?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1154143">
				<div id="div-comment-1154143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">remis (still alive)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140930-00/?p=43953#comment-1154143">
			October 3, 2014 at 11:34 am</a>		</div>

		<p>=Correction:</p>
<p>On other side antivirus also has some logic detecting locale when scanning that html file before browser can access it.</p>
<p>=Should be changed to:</p>
<p>On other side antivirus also has some logic detecting encoding when scanning that html file before browser can access it.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>