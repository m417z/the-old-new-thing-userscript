<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1144313">
				<div id="div-comment-1144313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144313">
			August 14, 2014 at 8:07 am</a>		</div>

		<p>And let me guess, nobody is going to fix the evaluation order of &quot;x += f()&quot; to first evaluate the right hand side, then capture the variable, because it&#39;d be a &quot;breaking change&quot;. Even though everyone affected is probably broken to begin with.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144323">
				<div id="div-comment-1144323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144323">
			August 14, 2014 at 8:12 am</a>		</div>

		<p>@ Zarat</p>
<p>To say &quot;fix&quot;, one must assume that the evaluation order is somehow broken. &nbsp;It isn&#39;t. &nbsp;It is 100% in keeping with the public spec for C#. &nbsp;Just because developers fai to read the docs, doesn&#39;t mean that something is broken and needs to be fixed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144333">
				<div id="div-comment-1144333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144333">
			August 14, 2014 at 8:35 am</a>		</div>

		<p>Maybe they should fix the spec so that they can then fix the evaluation order ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144343">
				<div id="div-comment-1144343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144343">
			August 14, 2014 at 8:35 am</a>		</div>

		<p>@ Zarat &amp; 12BitSlab:</p>
<p>As 12BitSlab says, it is not broken. It just looks like a broken concept because we&#39;re &#39;zoomed in&#39; on this particular case of C# expressions.</p>
<p>Suddenly saying &#39;this case is special and should have right-to-left evaluation&#39; would make even less sense. To begin with, would that only apply to stuff in the shorthand &#39;+=&#39; format? Or would it somehow need to be sniffed out that the first argument of the expression is the same as what comes before the assignment operator? Sure sure, you might say, you can just avoid all that mess by instead changing &#39;x += 5&#39; behaviour into &#39;x = 5 + x&#39;&#8230; but then you could probably get into nasty territory involving operator overloading and implicit conversions which would lead to even harder to figure out problems.</p>
<p>Making this case &#39;sensible&#39; will make a lot of other cases confusing and hard to understand warts of the language specification. It simply isn&#39;t worth it, even assuming that this change would not break anything.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144353">
				<div id="div-comment-1144353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144353">
			August 14, 2014 at 8:46 am</a>		</div>

		<p>Just tested and the same thing applies to VB.NET . &nbsp; Eye opening for sure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144363">
				<div id="div-comment-1144363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144363">
			August 14, 2014 at 9:12 am</a>		</div>

		<p>For instance, changing x += 5 to mean x = 5 + x would be disastrous for operations for which addition is not associative, like o.Name += &quot;, Jr.&quot;;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144373">
				<div id="div-comment-1144373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144373">
			August 14, 2014 at 9:38 am</a>		</div>

		<p>And for associative of course read commutative&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ipoverscsi odd alt thread-odd thread-alt depth-1" id="comment-1144393">
				<div id="div-comment-1144393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ipoverscsi' rel='external nofollow' class='url'>ipoverscsi</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144393">
			August 14, 2014 at 10:27 am</a>		</div>

		<p>@Zarat: As you pointed out, the &#39;+=&#39; operator is typically syntactic sugar that gets translated at compile-time; &nbsp;thus, x += 5 is translated into x = x + 5. </p>
<p>While the assignment operator &#39;=&#39; is processed in right-to-left order, most binary operators are processed in left-to-right order, including the &#39;+&#39; operator.In order for your suggestion to work, you would need a new operator called &#39;special-plus&#39; that is performs the same action as the &#39;+&#39; operator but it evaluates in right-to-left order. In this case, x += 5 would be translated into x = x &#39;special-plus&#39; 5. Note that we can&#39;t reverse the argument order (as you mentioned) otherwise &#39;string x += &quot;suffix&quot;&#39; won&#39;t work. </p>
<p>For each possible compound operation (&#39;-=&#39;, &#39;*=&#39;, &#8230;) you would need a special opcode that does the same thing as the regular opcode but with right-to-left evaluation.</p>
<p>This is actually a lot of work that will lead to compiler complexity and errors. This from a guy who&#39;s actually written a few compilers in his time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144403">
				<div id="div-comment-1144403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144403">
			August 14, 2014 at 10:28 am</a>		</div>

		<p>@Zarat, it&#39;s not a question of when the left hand side gets evaluated. &nbsp;x += f() gets rewritten as x = x + f(). &nbsp;The &quot;x + f()&quot; part gets evaluated left to right.</p>
<p> &nbsp;KC</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144413">
				<div id="div-comment-1144413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144413">
			August 14, 2014 at 12:09 pm</a>		</div>

		<p>@Zarat: I commiserate with you, there are too many literalists who seem to have one-track minds.</p>
<p>To reformulate your question:</p>
<p>Is there any reason (beside it having been done so), that &quot;x += y;&quot;</p>
<p>is evaluated as &quot;x = x + y;&quot;</p>
<p>instead of &quot;{var temp = y; x = x + temp;}&quot;,</p>
<p>with in any case x only being evaluated once?</p>
<p>And if there is none, is there good enough reason not to correct the spec and the language itself?</p>
<p>Is there credible reason to think any non-broken code will change its meaning?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144423">
				<div id="div-comment-1144423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144423">
			August 14, 2014 at 12:10 pm</a>		</div>

		<p>I don&#39;t know what you are trying to explain/defend, you kinda claim that its impossible to fix this issue, but that&#39;s simply not true.</p>
<p>Compilers can do more than just expression rewriting, there is nothing (besides the spec, which can also be fixed) that would prevent a compiler to push the result of &quot;f()&quot; (or whatever the right hand side of &quot;x += &#8230;&quot; is) on the stack (in case of .NET IL a local slot may be better than the stack), call the getter for x, call &quot;operator +&quot; with the right argument order, then call the assignment operator. No special opcodes needed, just redefined when exactly the getter for x is called (after evaluating the right hand side instead of before).</p>
<p>And before someone complains that would make IL larger by a byte or two, I&#39;m aware of that and still think it&#39;d be worth to fix &#8211; mostly due to the async/await use case &#8211; your opinion may of course differ.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144433">
				<div id="div-comment-1144433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144433">
			August 14, 2014 at 12:12 pm</a>		</div>

		<p>@Deduplicator: Thanks for clarifying, that&#39;s exactly what I meant (didn&#39;t think about formulating it as a rewritten expression though, nice one)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144453">
				<div id="div-comment-1144453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frank</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144453">
			August 14, 2014 at 12:41 pm</a>		</div>

		<p>Interesting enough, I tried the code in C++. I got &quot;11&quot; as the result. Looking at the compiled (assembly) code, C++ evaluates the function first before capturing &quot;X&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144483">
				<div id="div-comment-1144483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144483">
			August 14, 2014 at 1:14 pm</a>		</div>

		<p>&gt;C++ evaluates the function first before capturing &quot;X&quot;.</p>
<p>Or more exactly, a particular implementation of C++ on this particular source code on this particular day of the week happened to evaluate the function first.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cs-rakowski even thread-even depth-1" id="comment-1144503">
				<div id="div-comment-1144503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Christiaan+Rakowski' rel='external nofollow' class='url'>Christiaan Rakowski</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144503">
			August 14, 2014 at 1:35 pm</a>		</div>

		<p>Interesting stuff. Will definitely check some places in our codebase for this!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144523">
				<div id="div-comment-1144523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144523">
			August 14, 2014 at 3:51 pm</a>		</div>

		<p>@SimonRev: What&#39;s your definition of &quot;the language is broken&quot;?</p>
<p>Imho, C# acts counter-intuitivels there, due to how the compund-assignment-operators are defined. If that&#39;s not a defect in the language, what would be? I concede that C++ has no strong left-to right ordering for expression evaluation (citing another language which in another situation has weaker guarantees is at best a strawman anyway, especially as that&#39;s somewhat expected), but at least it does not ever explode a compound-assignment operator behind your back.</p>
<p>@ChrisB: You are missing the point, which is that the compound-assignment-operators have a bad (aka counter-intuitive) definition. It has nothing at all to do with strict left-to-right ordering.</p>
<p>@Matt: Putting up a big warning is better than nothing, hope that will be implemented at minimum.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zlynx even thread-even depth-1" id="comment-1144533">
				<div id="div-comment-1144533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zan+Lynx%27' rel='external nofollow' class='url'>Zan Lynx'</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144533">
			August 14, 2014 at 3:56 pm</a>		</div>

		<p>@dave: Check out the C++11 sequencing rules. They&#39;ve changed since C++03 and become better defined. C++ will guarantee that the functions have been run and results returned before using those results in another operation. And it also promises that the right-hand side of an assignment operation is complete before performing the assignment. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144543">
				<div id="div-comment-1144543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">meh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144543">
			August 14, 2014 at 3:57 pm</a>		</div>

		<p>If C# wants to play with the big boys and include the += etc operators shouldn&#39;t it have matched what C does? Otherwise you get code that would just do the x += y assignment on one line, but then has to split it apart like a two year-old on the next line (for the await reason). They&#39;ve changed the spec before for odd things (<a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx">blogs.msdn.com/&#8230;/closing-over-the-loop-variable-considered-harmful.aspx</a>). What does the introduction of the await-type thing-o in the new Visual C++ do? If it matches what the CLR spec does then maybe that might be ok; but if not then wtf?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144383">
				<div id="div-comment-1144383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144383">
			August 14, 2014 at 9:54 am</a>		</div>

		<p>I wasn&#39;t suggesting to change x += 5 to mean x = 5 + x &#8230; I was saying to change the *evaluation* order (of the expression) not the *argument* order (of the operator).</p>
<p>For an assignment expression of the style &quot;x += f()&quot; it makes perfect sense to evaluate the right hand side before the left hand side, in fact I think it makes *more* sense than the presented behavior. It probably just ended up with the bugged way we have because it is specced (and probably implemented) via expression rewriting.</p>
<p>IMHO I think it&#39;s worth fixing, but I doubt they will.</p>
<p>@12BitSlab (and others &quot;defending&quot; the current behavior): Just because it has been specced this way, that doesn&#39;t mean it has to be the right way. Can anyone actually give an example where this evaluation order makes sense or is useful? ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144553">
				<div id="div-comment-1144553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Fisher</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144553">
			August 14, 2014 at 4:55 pm</a>		</div>

		<p>The &quot;fixed&quot; code still has the exact same problem as before. The race condition is still there. It is just that the race condition is much less likely to be hit now because there is only a short delay between reading and writing the TotalWidgets property since the expensive BuyMoreAsync call was moved to before reading the property instead of after.</p>
<p>The real solution is to modify the TotalWidgets property in an atomic way. You could add a method called AddWidgets that internally uses Interlocked.Add (<a href="http://msdn.microsoft.com/en-us/library/33821kfh.aspx" rel="nofollow" target="_new">msdn.microsoft.com/&#8230;/33821kfh.aspx</a>) on the field. Alternatively, the += operation could be done inside a lock.</p>
<p>It is good to remember that += is not atomic. If it is going to be called on multiple threads in parallel, you have to use Inetrlocked or some sort of synchronization (lock).</p>
<p>In a way it is good that your code was written in a way that exposed the race condition. If you use the &quot;fixed&quot; code, it still has the problem but it would be harder to track down due to occurring only rarely.</p>
<div class="post">[<em>We are assuming single-threaded operation throughout, so nothing can run between reading and writing the TotalWidgets property. (This was implied because this is UI code, and UI objects can be accessed only from the thread that created them. Therefore, all the code in all the examples run on the same thread.) The point is that the async keyword suspends execution of the task and allows another task to run on that thread. And that other task may interfere with your computation. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144573">
				<div id="div-comment-1144573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">glugglug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144573">
			August 14, 2014 at 5:11 pm</a>		</div>

		<p>In other languages like C++ and Java, the = and related operators (like +=) are explicitly right associative, not left, so this evaluates as you would expect.</p>
<p>Also the = or += operator returns a reference to the left hand result, so, in C++</p>
<p>x += y += z; is the same as</p>
<p>x += (y += z); or</p>
<p>y = y + z; x = x + y;</p>
<p>Given C# is also a C-oid language, this pure left to right evaluation seems really broken.</p>
<div class="post">[<em>You&#39;ve confused associativity with order of evaluation. <a href="http://msdn.microsoft.com/en-us/library/aa691323(v=vs.71).aspx">The C# assignment operators are right-associative</a> but evaluate left-to-right. The C assignment operators are also right-associative, but evaluation order is unspecified. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144583">
				<div id="div-comment-1144583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Crabtree</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144583">
			August 14, 2014 at 6:16 pm</a>		</div>

		<p>@Deduplicator/@Zarat</p>
<p>I agree thoroughly. There&#39;s no good reason for C# to behave this way for the compound operators, and when combined with await, this results in some seriously unexpected behavior.</p>
<p>Any code of the form x += y; where the get for x needs to be evaluated for the value of y to be correctly evaluated is very probably already broken, and at best is working by sheer luck.</p>
<p>At the very least, a compilation-time warning is called for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-1144593">
				<div id="div-comment-1144593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144593">
			August 14, 2014 at 6:39 pm</a>		</div>

		<p>Somehow I have the thought that today&#39;s article is inspired by G&#39;s wallet. My sister was charged triple times for buying single article.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144443">
				<div id="div-comment-1144443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144443">
			August 14, 2014 at 12:39 pm</a>		</div>

		<p>@Dedup:</p>
<p>I don&#39;t see a reason to change the language. &nbsp;As several have pointed out, the language itself isn&#39;t broken, rather doesn&#39;t behave as intuitive as you might like for this *specific* example. &nbsp;Keep in mind that when evaluating an expression in the form x+=y, that *y* can just as easily have side effects as evaluating x! &nbsp;We can easily rewrite the example so that y is a property which modifies the static variable in which case right to left evaluation seems wrong.</p>
<p>Just be glad we aren&#39;t in C++ land where not only is evaluation order not specified, but it is entirely possible and reasonably for a compiler for the expression a=b+c to evaluate part of c, then part of b then the rest of c then the rest of b before performing the addition &#8212; talk about a headache there. &nbsp;In fact, I think that C++ could choose to evaluate &#39;a&#39; right in the middle there if it felt like.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144463">
				<div id="div-comment-1144463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris B</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144463">
			August 14, 2014 at 12:45 pm</a>		</div>

		<p>@Deduplicator/@Zarat</p>
<p>I imagine strict left to right ordering was chosen (at least in part) so that all compilers execute code in the same order. For a statement like</p>
<p>int x = y() / z();</p>
<p>C/C++ compilers are permitted to call y() and z() in the order of their choosing. &nbsp;This becomes important when one of the functions depends on a side effect of the other.</p>
<p>In C#, this is important because x could be a property, which as Raymond mentioned, is just short hand for a method called get_x(); If the get_x() pseudo-method has a side effect, it is reasonable for a developer to expect that it be observed only once (since x only appears once), and that it occur *before* y is evaluated (since x comes before y).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144473">
				<div id="div-comment-1144473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144473">
			August 14, 2014 at 1:10 pm</a>		</div>

		<p>Might be worth VS team adding a warning for the following rule:</p>
<p>For every sub-expression in the AST:</p>
<p>* If the expr is a compound assignment (i.e. %=, /=, *=, +=, -=, ^=, |=, &amp;=)</p>
<p>* AND the right-hand side of the operation CONTAINS an AWAIT-expression (that definitely terminates)</p>
<p>* AND the left-hand side of the operation is Not</p>
<p> &nbsp;* A local-variable or a parameter to the function</p>
<p> &nbsp;* And also a value type</p>
<p>* Then:</p>
<p>Raise a warning in the compiler for the developer, i.e: &quot;The read and write parts of a compound-assignment expression are potentially delayed by an &quot;await&quot; statement, which could lead to a race-condition&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144603">
				<div id="div-comment-1144603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144603">
			August 14, 2014 at 9:13 pm</a>		</div>

		<p>&gt;Interesting enough, I tried the code in C++.</p>
<p>Frank, you&#39;re going to have to be a lot more specific than that: what compiler, what platform, what version, etc&#8230; since the spec doesn&#39;t say what order the expression must be evaluated in, each compiler could do it differently. &nbsp;Or the same compiler could do it differently based on what the target architecture is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144613">
				<div id="div-comment-1144613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144613">
			August 15, 2014 at 5:07 am</a>		</div>

		<p>@Deduplicator and co: So you&#39;re saying that interpreting &quot;x += y&quot; as &quot;x = x + y&quot; is counter intuitive? I disagree! </p>
<p>This comes down to simple preferences though: On one hand we have purists that prefer a simple, easy to understand system which means they have to learn a few rules and can then reason out the rest. On the other hand we have people who prefer to introduce special rules for things to make them more &quot;intuitive&quot; or easier (except in rare situations where all those extra, special rules start to interact in weird and confusing ways).</p>
<p>This is basically Lisp vs. Basic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144623">
				<div id="div-comment-1144623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144623">
			August 15, 2014 at 5:09 am</a>		</div>

		<p>&gt;since the spec doesn&#39;t say what order the expression must be evaluated in,</p>
<p>The spec goes further: it says the order is undefined. That is, the order is explicitly not specified, rather than merely unspecified due to omission.</p>
<p>(A minor wording quibble, perhaps, but it indicates the spirit better: even if you can find out what your compiler does today, you&#39;d be a fool to rely on it)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144633">
				<div id="div-comment-1144633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris B</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144633">
			August 15, 2014 at 6:03 am</a>		</div>

		<p>@Deduplicator:</p>
<p>&quot;Is there any reason (beside it having been done so), that &#39;x += y;&#39;</p>
<p>is evaluated as &#39;x = x + y;&#39;</p>
<p>instead of &#39;{var temp = y; x = x + temp;}&#39;,</p>
<p>with in any case x only being evaluated once?&quot;</p>
<p>And my response is that x is evaluated first because it precedes y in the statement, which is strict left-to-right ordering. Your example is right to left ordering. What point am I missing?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144693">
				<div id="div-comment-1144693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144693">
			August 15, 2014 at 8:31 am</a>		</div>

		<p>@voo: Sorry, but you are completely off your rocker.</p>
<p>That has nothing to do with adhering to strict left-to-right evaluation-order, but with how op= is defined to make proper sense.</p>
<p>And if you go the route that whatever way it is, that&#39;s natural and good and glorious, why don&#39;t you loudly decry the fix to range-based loops and closure?</p>
<p>@ChrisB: The point you are missing is that (as Raymond acknowledges), the definition for op= in C# is at best unfortunate, and arguably and error. What exactly that definition is or should be has exactly nothing at all to do with evaluation-order.</p>
<p>Anyway, up to now nobody at all made the case for there being any non-broken code which would change its meaning due to fixing that trap. Though there were plenty who defended the strawman that the definition of op= is somehow unavoidable and sacrosanct due to evaluation-order.</p>
<div class="post">[<em>I have a case for non-broken code relying on order of evaluation, but the discussion is too big to fit into a comment, so you&#39;ll have to wait until it reaches the head of the queue. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144713">
				<div id="div-comment-1144713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ls</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144713">
			August 15, 2014 at 9:59 am</a>		</div>

		<p>@Deduplicator:</p>
<p>&gt; Is there any reason (beside it having been done so), that &quot;x += y;&quot;</p>
<p>&gt; is evaluated as &quot;x = x + y;&quot;</p>
<p>Because it&#39;s straightforward and makes the code easy to reason about? Saying &quot;x += y is a shorthand for x = x + y, except that x only gets evaluated once&quot; is a sane thing to do. It&#39;s the way almost every undergrad programming course explains those operators. If you fiddle around with the evaluation order, your simple rule is gone. Mayhem results.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144723">
				<div id="div-comment-1144723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MBR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144723">
			August 15, 2014 at 11:37 am</a>		</div>

		<p>This behavior seems completely unsurprising and reasonable.</p>
<p>Even if it were not, I don&#39;t think the compiler should be trying to &quot;fix up&quot; code that tries to mix the global side-effects f() and the value returned by f() &#8211; this is just rotten code &#8211; it&#39;s basically like doing:</p>
<p> &nbsp; x = f(ref x);</p>
<p>&#8211; I&#39;d expect the assignment to clobber any changes to x made inside of f() &#8211; but I never count on it either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144733">
				<div id="div-comment-1144733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144733">
			August 15, 2014 at 12:22 pm</a>		</div>

		<p>[I have a case for non-broken code relying on order of evaluation, but the discussion is too big to fit into a comment, so you&#39;ll have to wait until it reaches the head of the queue. -Raymond]</p>
<p>I will patiently await the article on this subject in summer 2016 or so.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144773">
				<div id="div-comment-1144773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KallDrexx</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144773">
			August 15, 2014 at 3:13 pm</a>		</div>

		<p>@Dedup</p>
<p>&quot;Anyway, up to now nobody at all made the case for there being any non-broken code which would change its meaning due to fixing that trap. Though there were plenty who defended the strawman that the definition of op= is somehow unavoidable and sacrosanct due to evaluation-order.&quot;</p>
<p>You missed the argument about o.Name += &quot;, Jr&quot; above. &nbsp;That will be completely broken in changing the order of evaluation, and either requires users to do &quot;, JR&quot; += o.Name (which is completely unintuitive for an append operation).</p>
<p>It also means that when you create a custom class that overrides the += you have to know that it has to be defined as:</p>
<p>public static MyClass operator += (MyClass right, MyClass left). &nbsp;Changing this operation not only risks breaking almost all overloaded operators on += it makes it far less intuitive when you need to overload those operations and the only reason anyone is thining that this isn&#39;t intuitive is because of this one edge case, but once you reverse the evaluation logic you have edge cases that will cause you to go &quot;this is retarded, it should be re-reversed&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd odd alt thread-odd thread-alt depth-1" id="comment-1144703">
				<div id="div-comment-1144703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144703">
			August 15, 2014 at 8:39 am</a>		</div>

		<p>I imagine *a* reason for existing: is the ability to opt into an optimization. </p>
<p>The value of the variable is pushed onto the stack as `value1`. The value to add is computed and pushed onto the stack as `value2`. </p>
<p>Then you can call the IL `add` instruction:</p>
<p> &nbsp; &nbsp;add – add numeric values </p>
<p> &nbsp; &nbsp;58 &nbsp; add </p>
<p> &nbsp; &nbsp;Add two values, returning a new value.</p>
<p> &nbsp; &nbsp;Stack Transition:</p>
<p> &nbsp; &nbsp;…, value1, value2  …, result</p>
<p> &nbsp; &nbsp;The add instruction adds value2 to value1 and pushes the result on the stack</p>
<p>If you didn&#39;t want the value of x pushed onto the CLI stack at the start of the instruction and left there, you should have used:</p>
<p> &nbsp; &nbsp;x = x + 1</p>
<p>instead.</p>
<p>(and before hit post, i recognize a 10% chance that my formatting will look readable in the rendered form)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144783">
				<div id="div-comment-1144783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144783">
			August 15, 2014 at 4:05 pm</a>		</div>

		<p>@Raymond: Eagerly awaiting it. Even though there is then at least one example for code which would actually break if the semantics were fixed. Still, in the case of closures and the ranged-for loop, there probably were some too, so it&#39;s not categorically the death-knell to any chance of a fix.</p>
<p>@KallDrexx: Seems you didn&#39;t read anything of what I wrote. Because your post does not in the least reflect what I said. Makes me sad that so few seem to take the time to read, before they jump to the defense of orthodoxy like well-trained attack-dogs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144793">
				<div id="div-comment-1144793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KallDrexx</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144793">
			August 15, 2014 at 6:25 pm</a>		</div>

		<p>@Deduplicator </p>
<p>I guess I was getting your arguments mixed up with Zatar&#39;s, my bad.</p>
<p>However, re-reading your argument it seems like you are questioning why it&#39;s always done that way instead of another way, such as with a temp variable behind the scenes. I&#39;d argue that your idea of using temp tables isn&#39;t a good idea either. &nbsp;This means you are now taking something that&#39;s a minimum of 2 operations and now forcing it to be a minimum of 3. &nbsp;While it may not seem that huge, it can be compounded in loops and cause slightly worse performance in a hard to predict way (since most people are expecting it to be straight forward x = x + y).</p>
<p>Furthermore, if you are dealing with reference types instead of value types you are now adding extra garbage that has to be cleaned up. &nbsp;That will significantly impact any games or high performance applications.</p>
<p>Other than those two I&#39;m not sure of how you are going to do it without adding even more complexity in an area that really shouldn&#39;t be that complex for no reason other than to hopefully try and save coders from themselves, and I&#39;d argue that the edge case in this article that makes op= not function as predicted is more of a an argument for reducing side effects of functions instead of trying to save the coder from it themselves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1144803">
				<div id="div-comment-1144803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nico</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144803">
			August 15, 2014 at 6:58 pm</a>		</div>

		<p>I was just browsing Stack Overflow&#39;s &quot;Hot Questions&quot; when I came across this: <a href="http://stackoverflow.com/questions/25323202/c-and-php-vs-c-sharp-and-java-unequal-results" rel="nofollow" target="_new">stackoverflow.com/&#8230;/c-and-php-vs-c-sharp-and-java-unequal-results</a></p>
<p>I&#39;m not sure why the guy decided to effectively copy and paste your post (and without any kind of credit to you) and then ask a question which you directly answered, but there it is. &nbsp;Maybe a lame attempt at some easy internet points.</p>
<p>Regardless, an interesting topic and another enjoyable CLR week. Thanks, Raymond.</p>
<div class="post">[<em>&quot;I&#39;ve made the big time. <a href="http://steeleinlove.com/steele_at_any.html">I&#39;VE BEEN STOLEN</a>!&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1144933">
				<div id="div-comment-1144933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144933">
			August 18, 2014 at 7:30 am</a>		</div>

		<p>&gt; There is some discussion of what &quot;evaluated only once&quot; means, but that&#39;s not important here.</p>
<p>(It would have been easier to copy-paste the spec following this statement, it&#39;s actually simpler, but&#8230;)</p>
<p>Actually, there are two important aspects here:</p>
<p>&#8211; x is any expression, which is stated nowhere</p>
<p>&#8211; what is evaluated only once are the sub-expressions that lead to the variable reference (lvalue) expression</p>
<p> &nbsp;&#8211; e.g. a very simple example, in Object.Property.Method(argument).Field += &lt;whatever&gt;</p>
<p> &nbsp;&#8211; Object, Property, argument and Method() are evaluated only once</p>
<p> &nbsp;&#8211; then Field is evaluated for its value, then &lt;whatever&gt; is evaluated, then the operation (+) is evaluated, then Field is set with the resulting value.</p>
<p>So,</p>
<p>Object.Property.Method(argument).Field += &lt;whatever&gt;;</p>
<p>is roughly equivalent to</p>
<p>var __temp = Object.Property.Method(argument);</p>
<p>__temp.Field = __temp.Field + &lt;whatever&gt;;</p>
<p>where temporary variables are used as needed due to a method call, a property access or array-like indexing. &nbsp;If x is already a variable or field reference, there&#39;s no need for the temp.</p>
<p>You need as many temporary variables as the necessary sub-expressions of the l-value expression, e.g. Object.Property.Method(argument).Field[&lt;expr&gt;] would need an extra temporary for the evaluation of &lt;expr&gt;.</p>
<p>About C/C++, there&#39;s a strange case where it guarantees order of evaluation, comma expressions, probably because of the first three parts of the for statement. &nbsp;An afterthought.</p>
<p>This is very easily confused with argument list expressions, which don&#39;t have a specific order of evaluation.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>