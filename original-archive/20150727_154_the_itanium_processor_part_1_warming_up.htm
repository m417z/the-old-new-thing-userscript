<html>
<head>
<title>The Itanium processor, part 1: Warming up</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The Itanium processor, part 1: Warming up</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 27, 2015 / year-entry #155</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>62</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">All those registers.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
The Itanium may not have been much of a commercial success,
but it is interesting as a processor architecture because it
is different from anything else commonly seen today.
It's like learning a foreign language:
It gives you an insight into how others view the world.
</p>
<p>
The next two weeks will be devoted
to an introduction to the Itanium processor architecture,
as employed by Win32.
(Depending on the reaction to this series, I might also do a series
on the Alpha AXP.)
</p>
<p>
I originally learned this information in order to be able to debug
user-mode code as part of the
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2012/12/18/10378851.aspx">
massive port of several million lines of code from 32-bit to 64-bit Windows</a>,
so the focus will be on being able to read, understand,
and debug user-mode code.
I won't cover kernel-mode features since I never had to learn them.
</p>
<p>
<b>Introduction</b>
</p>
<p>
The Itanium is a 64-bit EPIC architecture.
EPIC stands for Explicitly Parallel Instruction Computing,
a design in
which work is offloaded from the processor
to the compiler.
For example,
the compiler decides which operations can be safely performed in parallel
and
which memory fetches can be productively speculated.
This relieves the processor from having to make these decisions on the fly,
thereby allowing it to focus on the real work of processing.
</p>
<p>
<b>Registers overview</b>
</p>
<p>
There are a lot of registers.
</p>
<ul>
<li>128 general-purpose integer registers <var>r0</var> through <var>r127</var>,
    each carrying 64 value bits and a trap bit.
    We'll learn more about the trap bit later.
</li>
<li>128 floating point registers <var>f0</var> through <var>f127</var>.
</li>
<li>64 predicate registers <var>p0</var> through <var>p63</var>.
</li>
<li>8 branch registers <var>b0</var> through <var>b7</var>.
</li>
<li>An instruction pointer, which the
    <a HREF="http://msdn.microsoft.com/en-us/windows/hardware/gg463009.aspx">
    Windows debugging engine</a>
    for some reason calls <var>iip</var>.
    (The extra "i" is for "insane"?)
</li>
<li>128 special-purpose registers, not all of which have been given meanings.
    These are called "application registers" (<var>ar</var>) for some reason.
    I will cover selected register as they arise during the discussion.
</li>
<li>Other miscellaneous registers we will not cover in this series.
</li>
</ul>
<p>
Some of these registers are further subdivided into categories like
<i>static</i>,
<i>stacked</i>, and
<i>rotating</i>.
</p>
<p>
Note that if you want to retrieve the value of a register with the
Windows debugging engine, you need to prefix it with an at-sign.
For example <code>? @r32</code> will print the contents of the
<var>r32</var> register.
If you omit the at-sign, then the debugger will look for a variable
called <var>r32</var>.
</p>
<p>
A notational note: I am using the register names assigned by the Windows
debugging engine.
The formal names for the registers are
<var>gr#</var> for integer registers,
<var>fr#</var> for floating point registers,
<var>pr#</var> for predicate registers,
and
<var>br#</var> for branch registers.
</p>
<p>
<b>Static, stacked, and rotating registers</b>
</p>
<p>
These terms describe how the registers participate in register renumbering.
</p>
<p>
<i>Static</i> registers are never renumbered.
</p>
<p>
<i>Stacked</i> registers are pushed onto a register stack
when control transfers into a function,
and they pop off the register stack when control transfers out.
We'll see more about this when we study the calling convention.
</p>
<p>
<i>Rotating</i> registers can be cyclically
renumbered during the execution of
a function.
They revert to being stacked when the function ends
(and are then popped off the register stack).
We'll see more about this when we study register rotation.
</p>
<p>
<b>Integer registers</b>
</p>
<p>
Of the 128 integer registers, registers
<var>r0</var> through <var>r31</var> are static,
and
<var>r32</var> through <var>r127</var> are stacked
(but they can be converted to rotating).
</p>
<p>
Of the static registers,
Win32 assigns them the following mnemonics which correspond
to their use in the Win32 calling convention.
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border: solid 1px black; border-collapse: collapse">
<tr>
<th>Register</th>
<th>Mnemonic</th>
<th>Meaning</th>
</tr>
<tr>
<td><var>r0</var></td>
<td></td>
<td>Reads as zero (writes will fault)</td>
</tr>
<tr>
<td><var>r1</var></td>
<td><var>gp</var></td>
<td>Global pointer</td>
</tr>
<tr>
<td><var>r8</var>&hellip;<var>r11</var></td>
<td><var>ret0</var>&hellip;<var>ret3</var></td>
<td>Return values</td>
</tr>
<tr>
<td><var>r12</var></td>
<td><var>sp</var></td>
<td>Stack pointer</td>
</tr>
<tr>
<td><var>r13</var></td>
<td></td>
<td>TEB</td>
</tr>
</table>
<p>
Registers <var>r4</var> through <var>r7</var>
are preserved across function calls.
Well, okay, you should also preserve the stack pointer and
the TEB if you know what's good for you,
and there are special rules for <var>gp</var>
which we will discuss later.
The other static variables are scratch
(may be modified by the function).
</p>
<p>
Register <var>r0</var> is a register that always contains the value zero.
Writes to <var>r0</var> trigger a processor exception.
</p>
<p>
The
<var>gp</var> register points to the current function's
global variables.
The Itanium has
no absolute addressing mode.
In order to access a global variable, you need to load it
indirectly through a register,
and the <var>gp</var> register points to the global variables
associated with the current function.
The <var>gp</var> register is kept up to date when code transfers
between DLLs
by means we'll discuss later.
(This is sort of a throwback to
<!-- backref: MAKEPROCINSTANCE -->
the old days of
<code>MAKEPROCINSTANCE</code></a>.)
</p>
<p>
Every integer register contains 64 value bits and one trap bit,
known as not-a-thing, or <i>NaT</i>.
The NaT bit
is used by speculative execution to indicate that the register
values are not valid.
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/19/60162.aspx">
We learned a little about NaT some time ago</a>;
we'll discuss it further when we reach the topic of control speculation.
The important thing to know about NaT right now is that
if you take a
register which is tagged as NaT and try to do arithmetic with it,
then the NaT bit is set on the output register.
Most other operations on registers tagged as NaT will raise an exception.
</p>
<p>
The NaT bit means that
accessing an uninitialized variable can <i>crash</i>.
</p>
<pre>
void bad_idea(int *p)
{
 int uninitialized;
 *p = uninitialized; // can crash here!
}
</pre>
<p>
Since the variable <var>uninitialized</var> is uninitialized,
the register assigned to it might happen to have the NaT bit set,
left over from previous execution,
at which point trying to save it into memory raises an exception.
</p>
<p>
You may have noticed that there are four return value registers,
which means that you can return up to 32 bytes of data in registers.
</p>
<p>
<b>Floating point registers</b>
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border: solid 1px black; border-collapse: collapse">
<tr>
<th>Register</th>
<th>Meaning</th>
</tr>
<tr>
<td><var>f0</var></td>
<td>Reads as 0.0 (writes will fault)</td>
</tr>
<tr>
<td><var>f1</var></td>
<td>Reads as 1.0 (writes will fault)</td>
</tr>
</table>
<p>
Registers
<var>f0</var> through <var>f31</var> are static,
and
<var>f32</var> through <var>f127</var> are rotating.
</p>
<p>
By convention,
registers
<var>f0</var> through <var>f5</var>
and <var>f16</var> through <var>f31</var> are preserved across calls.
The others are scratch.
</p>
<p>
That's about all I'm going to say about floating point registers,
since they aren't really where the Itanium architecture is exciting.
</p>
<p>
<b>Predicate registers</b>
</p>
<p>
Instead of a flags register,
the Itanium records the state of previous comparison operations
in dedicated registers known as <i>predicates</i>.
Each comparison operation indicates which predicates should hold
the comparison result, and future instructions can test the predicate.
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border: solid 1px black; border-collapse: collapse">
<tr>
<th>Register</th>
<th>Meaning</th>
</tr>
<tr>
<td><var>p0</var></td>
<td>Reads as <var>true</var> (writes are ignored)</td>
</tr>
</table>
<p>
Predicate registers
<var>p0</var> through <var>p15</var> are static,
and
<var>p16</var> through <var>p63</var> are rotating.
</p>
<p>
You can predicate almost any instruction,
and the instruction will execute only if the predicate register
is <var>true</var>.
For example:
</p>
<pre>
(p1) add ret0 = r32, r33
</pre>
<p>
means,
"If predicate <var>p1</var>
is <var>true</var>,
then
set register <var>ret0</var> equal to the sum of
<var>r32</var> and <var>r33</var>.
If not, then do nothing."
The thing inside the parentheses is called the
<i>qualifying predicate</i> (abbreviated <i>qp</i>).
</p>
<p>
Instructions which execute unconditionally are internally
represented as being conditional upon
predicate register <var>p0</var>,
since that register is always <var>true</var>.
</p>
<p>
Actually, I lied when I said that the instruction will execute
only if the qualifying predicate is <var>true</var>.
There is one class of instructions which execute regardless of
the state of the qualifying predicate;
more on that later.
</p>
<p>
The Win32 calling convention specifies that predicate registers
<var>p0</var> through <var>p5</var> are preserved across calls,
and
<var>p6</var> through <var>p63</var> are scratch.
</p>
<p>
There is a special pseudo-register called
<var>preds</var> by the Windows debugging engine
which consists of the 64 predicate registers combined
into a single 64-bit value.
This pseudo-register is used when code needs to save and
restore the state of the predicate registers.
</p>
<p>
<b>Branch registers</b>
</p>
<p>
The branch registers are used for indirect jump instructions.
The only things you can do with branch registers are load them from
an integer register,
copy them to an integer register,
and jump to them.
In particular, you cannot load them directly from memory
or do arithmetic on them.
If you want to do any of those things, you need to do it with
an integer register,
then transfer it to a branch register.
</p>
<p>
The Win32 calling convention assigns the following meanings
to the branch registers:
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border: solid 1px black; border-collapse: collapse">
<tr>
<th>Register</th>
<th>Mnemonic</th>
<th>Meaning</th>
</tr>
<tr>
<td><var>b0</var></td>
<td><var>rp</var></td>
<td>Return address</td>
</tr>
</table>
<p>
The return address register is sometimes called <var>br</var>,
but the disassembler calls it <var>rp</var>, so that's what we'll
call it.
</p>
<p>
The return address register is set automatically by the processor
when a <code>br.call</code> instruction is executed.
</p>
<p>
By convention, registers <var>b1</var> through <var>b5</var>
are preserved across calls,
while <var>b6</var> and <var>b7</var> are scratch.
(Exercise: Is <var>b0</var> preserved across calls?)
</p>
<p>
<b>Application registers</b>
</p>
<p>
There are a large number of application registers,
most of which are not useful to user-mode code.
We'll introduce the interesting ones as they arise.
I've already mentioned one of them already:
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2005/04/21/410397.aspx">
<code>bsp</code> is the ia64's second stack pointer</a>.
</p>
<p>
<b>Break</b>
</p>
<p>
Okay, this was a whirlwind tour of the Itanium register set.
I bet your head hurts already,
and we haven't even started coding yet!
</p>
<p>
In fact, we're not going to be coding for quite some time.
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20150728-00/?p=90811">
Next time</a>,
we'll look at the instruction format.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (62)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235486">
				<div id="div-comment-1235486" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235486">
			July 27, 2015 at 7:05 am</a>		</div>

		<p>Thanks for all of the effort that obviously went into writing all of this up. &nbsp;I hope you don&#39;t get too many comments along the lines of &quot;we don&#39;t care about the Itanium&quot;. Processor architecture is fascinating to many of us!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235476">
				<div id="div-comment-1235476" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235476">
			July 27, 2015 at 7:07 am</a>		</div>

		<p>Is b0 preserved across calls?</p>
<p>Only recursive calls :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235466">
				<div id="div-comment-1235466" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235466">
			July 27, 2015 at 7:11 am</a>		</div>

		<p>So you think that is a lot of registers? I&#39;m working on a project involving a CPU w/ 512 32bit registers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235456">
				<div id="div-comment-1235456" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235456">
			July 27, 2015 at 7:11 am</a>		</div>

		<p>So you think that is a lot of registers? I&#39;m working on a project involving a CPU w/ 512 32bit registers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235446">
				<div id="div-comment-1235446" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235446">
			July 27, 2015 at 7:16 am</a>		</div>

		<p>This series is also of interest to me as would a series on the AXP (particularly if there is information about the unfinished 64-bit port.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-odd thread-alt depth-1" id="comment-1235436">
				<div id="div-comment-1235436" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235436">
			July 27, 2015 at 7:36 am</a>		</div>

		<p>I also vote for the AXP follow on. Alpha was a very interesting architecture killed by sales people that couldn&#39;t sell and price point</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1235426">
				<div id="div-comment-1235426" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Charles H. Stevens</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235426">
			July 27, 2015 at 8:08 am</a>		</div>

		<p>Thanks for writing this up. I think it will be interesting.</p>
<p>I will also vote for the AXP series for the same reason.</p>
<p>Also I am going to guess that the extra i in iip is for Intel :) &nbsp;[and yes I remember that this processor is related to the HP PA-RISC]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235416">
				<div id="div-comment-1235416" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235416">
			July 27, 2015 at 8:12 am</a>		</div>

		<p>And this is your processor on drugs&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mngoldeneagle even thread-even depth-1" id="comment-1235406">
				<div id="div-comment-1235406" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235406">
			July 27, 2015 at 8:18 am</a>		</div>

		<p>I love it! &nbsp;I&#39;ve always been curious about the Itanium architecture. &nbsp;I heard/read that it had plenty of registers, but didn&#39;t realize exactly how many until you listed them (in excellent detail, might I add) above. &nbsp;No wonder those processors were so expensive; it&#39;s surprising they didn&#39;t release a scaled back version with half the number of registers. &nbsp;That still would have been an improvement over x86.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235396">
				<div id="div-comment-1235396" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235396">
			July 27, 2015 at 8:38 am</a>		</div>

		<p>Yes, my head does hurt already. This will be interesting though, looking forward to the rest of it.</p>
<p>I almost expected there to be a &quot;register p1 always reads as false&quot;. But maybe that would be useless??</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235386">
				<div id="div-comment-1235386" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235386">
			July 27, 2015 at 8:39 am</a>		</div>

		<p>I wouldn&#39;t be so rude as to suggest that nobody cares about a topic so Raymond shouldn&#39;t spend a lot of time on it. &nbsp;Different strokes for different folks. &nbsp;But as I used to say to my Wife, &quot;Just wake me when it&#39;s over.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235376">
				<div id="div-comment-1235376" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235376">
			July 27, 2015 at 8:47 am</a>		</div>

		<p>The first &quot;i&quot; in &quot;iip&quot; is for &quot;Insanium&quot;, never to be confused with the instruction pointer of other architectures, emulated or not.</p>
<p>Oops, I meant &quot;Itanium&quot;!</p>
<p>Actually, it stands for something else, I think&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235366">
				<div id="div-comment-1235366" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235366">
			July 27, 2015 at 8:54 am</a>		</div>

		<p>Looking forward to this series, and hoping for the AXP one as well. &nbsp;It&#39;s always interesting to take a look at what might have been. &nbsp;Not that IA64 and AXP didn&#39;t happen, but if things had turned out differently I might be developing for them today instead of x86 or x86_64.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235356">
				<div id="div-comment-1235356" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235356">
			July 27, 2015 at 8:59 am</a>		</div>

		<p>The irony of course being that as transistors shrunk, it wound up being to do all that stuff they wanted to offload onto the compiler in the chip itself. ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1222181">
				<div id="div-comment-1222181" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1222181">
			July 27, 2015 at 9:07 am</a>		</div>

		<p>I&#39;m also looking forward to this series (and hoping you do one one the Alpha). There was some discussion of Itanium features in a grad compiler class I took several years ago, and a lot of it is pretty neat. I think it was the first time I learned about the idea of generic instruction predicates, for instance, which seem like a neat and useful idea. (OTOH, ARM 32-bit supports predicates but ARM64 doesn&#39;t, so maybe they *aren&#39;t* actually that useful. Or at least are less useful than having those instruction bits for other stuff.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235346">
				<div id="div-comment-1235346" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235346">
			July 27, 2015 at 9:20 am</a>		</div>

		<p>You say writing to r0, f0, f1 and p0 is &ldquo;not allowed&rdquo;. How and on which level is this enforced? Does the processor ignore writes to them, or does it raise an exception, or is it just a Windows convention &ldquo;thou shalt not write to r0 lest thou changest the value of integer zero&rdquo;?</p>
<p>Re exercise: There is not enough information in this post in order to give an answer.</p>
<p>The contract as stated (&ldquo;rp contains the return address&rdquo;) consists of two clauses: 1. Whenever the Callee is invoked, rp shall initially contain the return address, and the Callee may return by jumping to that address. 2. Before invoking any function, the Caller shall set rp to the address it wishes control returned to (including, but not limited to, the address immediately following the instruction that transfers control to the callee &mdash; see tail call optimization).</p>
<p>The callee may want to copy its initial rp value to a different register, then modify rp (perhaps to call its sub-callees), then restore the return address into a scratch register and jump via that. In this case, rp will be trashed.</p>
<p>I can see one case where the caller cares for rp to be preserved: When it calls a single function in a tight loop. In this case, relying on rp keeping its value across the call allows its initial assignment to be hoisted out of the loop.</p>
<p>Preserving the return address also simplifies compiler and debugger implementation.</p>
<div class="post">[<em>Good points. I&#39;ll clarify in the article. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235336">
				<div id="div-comment-1235336" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235336">
			July 27, 2015 at 9:25 am</a>		</div>

		<p>This looks like a very interesting series, looking forward to the next parts!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235326">
				<div id="div-comment-1235326" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235326">
			July 27, 2015 at 9:26 am</a>		</div>

		<p>I can&#39;t wait till Microsoft engineers develop unreliable, insecure software for this platform too! How about, instead of securing it, you can just darken the screen and give the user a threatening warning box that if they want to USE their Itanium server, they risk destroying it. </p>
<p>How about forcing them to reboot every 2-3 days because &quot;updates&quot; ?</p>
<p>How about leaving the system vulnerable to privilege-escalation bugs so that someone can write a few lines of malformed javascript, root the system, encrypt all your data, and hold it ransom ? That&#39;s a great idea, isn&#39;t it? </p>
<p>How about creating all these problems, letting the system get polluted and trashed, like you always do, but then offer them a NEW VERSION with a higher version number (and fewer features and less functionality), to sell them a solution to those problems that you created in the first place ?</p>
<p>Is that how you become a billion dollar corporation ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235306">
				<div id="div-comment-1235306" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235306">
			July 27, 2015 at 9:39 am</a>		</div>

		<p>@Mike I&#39;m curious, do trolls read articles and formulate their nonsense based on that, or do you just have a few different ones in a shared document somewhere? If the latter, I&#39;d like to take a look!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235296">
				<div id="div-comment-1235296" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235296">
			July 27, 2015 at 9:48 am</a>		</div>

		<p>There was a famous (at the time) virus for Windows on Itanium. &nbsp;I can&#39;t even understand its code anymore. &nbsp;Slots and allocs and sptk.few&#8230; and that predicate abuse. &nbsp;Who puts 11 predicated lines in a row?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235286">
				<div id="div-comment-1235286" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235286">
			July 27, 2015 at 9:48 am</a>		</div>

		<p>Nice that you&#39;re covering the underdog. I suggest you mention the features that make up for its drawbacks: the security features. It has stack protection, memory key technology like IBM mainframes, and per-page read/write/execute permissions. Secure64&#39;s SourceT OS built on these ground up to receive quite a review by Matasano. Other appliance vendors could use it for a combo of security &amp; reliability. Details on Itanium security below:</p>
<p><a rel="nofollow" target="_new" href="http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/intel-itanium-secure-white-paper.pdf">http://www.intel.com/&#8230;/intel-itanium-secure-white-paper.pdf</a></p>
<p>I also second a look at the Alpha. Unlike the rest, I encourage you to explore its coolest feature: PALcode. It was like having abilities of microcode with regular assembler. It was used for performance enhancements, firmware mods, security techniques, and so on. Very applicable to modern stuff is the fact that a PAL instruction block executed atomically. Modern concurrency handling relies on tricks such as compare-and-swap. Alpha could do a whole transaction in the CPU. Further, it was simple enough that the DARPA-funded crash-safe.org converted a simple implementation into a highly secure processor for HLL languages. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1222171">
				<div id="div-comment-1222171" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1222171">
			July 27, 2015 at 10:00 am</a>		</div>

		<p>Great article. I briefly worked on Itanium back when MS was porting Windows to it, but I had forgotten almost all of this stuff. </p>
<p>This article also reminds me that I wish vendors could come up with a universal, *documented* set of aliases for registers (even if registers might have a couple different names). Occasionally I&#39;ll read some MIPS assembly, and there seems to be a few different conventions for naming special registers on that chip (similar to how certain registers on the Itanium might have different names depending on the tool being used). &nbsp;Usually these register aliases are poorly documented &#8211; you just have to &quot;know the lore&quot;.</p>
<p>Also, I&#39;d like to point out that the help file for the Debugging Tools for Windows package has (or maybe &quot;had&quot;) really, really good Itanium information in the Debugging Techniques/Processor Architecture section.</p>
<p>Also: a vote for the AXP series. &nbsp;Hell, I&#39;m pretty sure you&#39;d write a really good ARM series if you put your mind to it (even if you haven&#39;t worked on that target yet).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235276">
				<div id="div-comment-1235276" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235276">
			July 27, 2015 at 10:05 am</a>		</div>

		<p>&gt;&gt; but then offer them a NEW VERSION with a higher version number</p>
<p>Clearly, this is the crux of the problem. &nbsp;New versioning scheme: Decrement!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235266">
				<div id="div-comment-1235266" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235266">
			July 27, 2015 at 10:10 am</a>		</div>

		<p>Also, I&#39;d guess that the instruction pointer is named `iip` in the debugger because of this (from the Itanium Architecture Developer&#39;s Manual):</p>
<p>&quot;The processor maintains two instruction pointers for IA-32 instruction set references, EIP (32-bit effective address) and IP (a 64-bit virtual address equivalent to the Itanium instruction set IP)&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235256">
				<div id="div-comment-1235256" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235256">
			July 27, 2015 at 10:18 am</a>		</div>

		<p>Liked the article. Looking forward to part 2. Also another vote the the AXP series.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235246">
				<div id="div-comment-1235246" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235246">
			July 27, 2015 at 10:23 am</a>		</div>

		<p>&gt; [Good points. I&#39;ll clarify in the article. -Raymond]</p>
<p>Thanks.</p>
<p>After the clarification, it is still unclear how using br0 for the return address is a Windows (as opposed to Itanium) convention, without delving further into Itanium-specific br.call and br.ret semantic. [I looked in a book and now I understand.] But the fact that the return address is automatically stored into the register removes loop hoisting as a valid reason for the callee to preserve this register.</p>
<p>Also, from the callerâ€™s point of view, the mere act of calling a subroutine trashes the return address register by setting it to a known value. The caller is therefore responsible for saving the original value if it will eventually return to its grand-caller. The caller is also likely to have a better way of knowing addresses in its own code than by analyzing the contents of the return address register after calling a different function.</p>
<p>Thus, I see no reason to require that the callee preserve rp.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235236">
				<div id="div-comment-1235236" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235236">
			July 27, 2015 at 10:34 am</a>		</div>

		<p>Related reading: <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/13/58199.aspx">blogs.msdn.com/&#8230;/58199.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235226">
				<div id="div-comment-1235226" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235226">
			July 27, 2015 at 10:54 am</a>		</div>

		<p>&quot;r0 		Reads as zero (writes will fault)&quot;</p>
<p>An interesting design decision. When I went to school we learned in such an architecture that has a zero register, writing to it is usually how you throw away the result. So &quot;test r1, r2&quot; would be expressed as &quot;and r0, r1, r2&quot;. Not in this case though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235216">
				<div id="div-comment-1235216" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235216">
			July 27, 2015 at 11:00 am</a>		</div>

		<p>The fact that Windows NT&#39;s first 64-bit architecture was Itanium and not x86-64 has left its mark on the code. &nbsp;WOW64, the engine behind running x86-32 programs on 64-bit Windows NT, was originally written for Itanium. &nbsp;WOW64 was thus originally written to run x86-32 programs on Itanium.</p>
<p>Older Itanium chips had a built-in x86 emulator assisting feature, but later ones did not, when it was found that simple software emulation could be faster. &nbsp;WOW64 for Itanium works by having a software emulation layer to run x86-32 programs. &nbsp;Unlike other operating systems, however, the thunking from 32-bit system calls to 64-bit in Windows NT is done almost entirely in user mode. &nbsp;Linux and Darwin (Mac OS X) do it in kernel mode, for example.</p>
<p>As a result of this, WOW64 is written to have a CPU emulation layer. &nbsp;WOW64 consists of three DLLs: wow64.dll, wow64win.dll, and wow64cpu.dll. &nbsp;wow64.dll is the portion of WOW64 that is primarily responsible for translating 32-bit system calls into 64-bit system calls. &nbsp;wow64win.dll is the portion that does the same for windowing and GDI (the NtUser* system calls). &nbsp;wow64cpu.dll is the CPU emulator, which is tasked with actually running the 32-bit applications.</p>
<p>Due to the history, wow64cpu.dll still exists in x86-64. &nbsp;It is still responsible for emulating the x86-32 software, like it was on Itanium. &nbsp;Obviously, on x86-64, it has quite a hardware assist with running x86-32 code: it runs directly. &nbsp;So x86-64 wow64cpu.dll&#39;s calls to do the x86-32 emulation directly jump to the x86-32 code. &nbsp;To exit emulation upon a system call, the x86-32 ntdll.dll jumps directly to x86-64 code inside wow64cpu.dll that suspends the &quot;emulator&quot; and returns to wow64.dll for system call dispatch.</p>
<p>Just wanted to give some WOW64 context. =^-^=</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1222161">
				<div id="div-comment-1222161" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1222161">
			July 27, 2015 at 11:02 am</a>		</div>

		<p>The story of Itanium is a sad one. I can only imagine the terrible disappointment on the part of the engineers who designed it when their 2.0 processor, with a neat, clean architecture free of all the mistakes of the past, was overtaken by a boring, predictable 64-bit extension to the original instruction set &#8212; designed by the *competitor*, no less. &quot;Good enough&quot; wins again.</p>
<p>With the benefit of hindsight, it&#39;s easy to say the Itanium was the victim of its own ambition. A completely new architecture that leaves it up to compiler writers to fully exploit it which doesn&#39;t come with a great story for leveraging your existing software (since the architecture itself was incompatible and emulation was hopelessly slow). It had to hit it out of the park on the first go, and it didn&#39;t. Still, as far as failures go, Itanium was a courageous one. I look forward to learning more about it. Also, another vote for a similar series on the Alpha; Alpha machines have only ever been mythical creatures for me. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235206">
				<div id="div-comment-1235206" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235206">
			July 27, 2015 at 11:08 am</a>		</div>

		<p>I used to work at intel, and specifically on Itanium validation. I swear I used to know what iip meant.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235196">
				<div id="div-comment-1235196" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235196">
			July 27, 2015 at 11:13 am</a>		</div>

		<p>mikeb: IIP stands for Interruption Instruction Pointer. It points to a 16-byte-aligned bundle of 3 intstructions. The value of the IP gets copied to IIP whenever execution is being interrupted by something like an exception, break point, etc.</p>
<p>I think the debugger wanted to reserve IP as a pseudo-register for the actual instruction being executed, so it uses the IIP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235186">
				<div id="div-comment-1235186" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235186">
			July 27, 2015 at 11:55 am</a>		</div>

		<p>Thank you for this article. I&#39;ve done very little asm in the past, and this is quite over my head, but all that means is that I&#39;ll have to read it a couple times before it starts to make sense, which I don&#39;t see as a problem. I also vote for the AXP series.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235176">
				<div id="div-comment-1235176" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235176">
			July 27, 2015 at 12:13 pm</a>		</div>

		<p>I had a small hand in the Itanium back end for GCC, lo these many years ago, working under contract for HP.</p>
<p>The lesson I took away from it, as a compiler guy, was that for general-purpose integer work, ahead-of-time scheduling &lt;i&gt;cannot&lt;/i&gt; hope to compete with out-of-order execution in the CPU, because memory access latencies and branch destinations are just too unpredictable. &nbsp;All of that lovely explicit parallelism was being blown on NOPs and load stalls.</p>
<p>(Version 1 of the silicon was also ridiculously power-hungry for the performance. &nbsp;My little contracting shop had to move all its computers to a beefier data center because the HVAC at the place we started couldn&#39;t handle the Itaniums.)</p>
<p>It&#39;s my understanding that modern GPU architectures look suspiciously similar to the Itanium &#8212; which works for them, because the programmer understands they have to think about what can execute efficiently on something like that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235166">
				<div id="div-comment-1235166" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235166">
			July 27, 2015 at 12:42 pm</a>		</div>

		<p>Can&#39;t wait for your overview of the Alpha.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235156">
				<div id="div-comment-1235156" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235156">
			July 27, 2015 at 12:44 pm</a>		</div>

		<p>Just reading this post&#39;s title got me excited. Looking forward to more!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mquinlan even thread-even depth-1" id="comment-1235146">
				<div id="div-comment-1235146" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MichaelQuinlan' rel='external nofollow' class='url'>MichaelQuinlan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235146">
			July 27, 2015 at 12:49 pm</a>		</div>

		<p><a rel="nofollow" target="_new" href="http://www.intel.com/content/dam/doc/manual/itanium-architecture-vol-1-2-3-4-reference-set-manual.pdf">http://www.intel.com/&#8230;/itanium-architecture-vol-1-2-3-4-reference-set-manual.pdf</a> section 3.3.5.3 says that iip stands for Interruption Instruction Bundle Pointer. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235126">
				<div id="div-comment-1235126" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235126">
			July 27, 2015 at 1:14 pm</a>		</div>

		<p>@JM: Doubtless there were some iAPX-432 engineers left on whose shoulders the Itanium engineers could shed their tears. <a rel="nofollow" target="_new" href="https://en.wikipedia.org/wiki/Intel_iAPX_432">en.wikipedia.org/&#8230;/Intel_iAPX_432</a></p>
<p>@Raymond: Thank you for this series.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235116">
				<div id="div-comment-1235116" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235116">
			July 27, 2015 at 2:20 pm</a>		</div>

		<p>@McBucket: but, frankly, the 432 sounds terrible even on paper &#8212; bit-aligned variable length instructions? Ada as your primary programming language, complete with your own OS? There&#39;s ambition and then there&#39;s going overboard. There&#39;s definitely parallels in that the 432 too relied on the compiler to work magic. In the case of the 432 the compiler was perversely inefficient. In the case of Itanium, it just proved too hard to make the compiler do all the optimization. But the Itanium at least sounds like something you could get to work in theory, while the 432 sounds like a lead balloon. </p>
<p>Thanks for reminding me about this shambling horror, though. I know I read about it once, but I&#39;d completely forgotten about it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235106">
				<div id="div-comment-1235106" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235106">
			July 27, 2015 at 2:50 pm</a>		</div>

		<p>I&#39;m excited for this series! Keep em coming!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd even thread-even depth-1" id="comment-1235096">
				<div id="div-comment-1235096" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235096">
			July 27, 2015 at 3:53 pm</a>		</div>

		<p>I remember seeing the (hindsight) complaint that the Itanium was difficult to create compilers for. It wasn&#39;t until now that i understood why that would be. </p>
<p>Only after watching Eric Brumer&#39;s excellent talks on compilers and modern processors, as well as Herb Sutter&#39;s atomic&lt;&gt; weapon&#39;s talk, did i appreciate how much magic the x86/x64 CPU does.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235086">
				<div id="div-comment-1235086" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235086">
			July 27, 2015 at 5:05 pm</a>		</div>

		<p>+1 on excited for this and excited for a series on the Alpha!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-1235076">
				<div id="div-comment-1235076" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235076">
			July 27, 2015 at 7:01 pm</a>		</div>

		<p>I&#39;m interested to hear whether Windows has built special code to handle what is executed with IA32-EL differently, or is that also transparent to the operating system. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235066">
				<div id="div-comment-1235066" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235066">
			July 27, 2015 at 7:13 pm</a>		</div>

		<p>IA64 was a big deal for NT&#8230;there was just no software, not even Microsoft. &nbsp;About the same time, NT4 sp3 NT was dropped for Alpha. With enough RAM, it would smoke a P4. IMHO, looking forward to rest of article. Ty</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235056">
				<div id="div-comment-1235056" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235056">
			July 27, 2015 at 7:21 pm</a>		</div>

		<p>@ Mr Bucket, JM</p>
<p>i432 did go overboard but System/38 (later AS/400) did survive aiming for similar capabilities. They should&#39;ve made it compatible with popular stuff, though, instead of Ada among other things. I think they did a good job with their i960 that trimmed i432:</p>
<p><a rel="nofollow" target="_new" href="https://en.wikipedia.org/wiki/Intel_i960">en.wikipedia.org/&#8230;/Intel_i960</a></p>
<p>Take out the weird BiiN stuff, make it C/UNIX compatible, and what you have left is a sophisticated, RISC chip. It&#39;s error handling, high availability, and object protection would be useful today. Matter of fact, there were designs then (eg NonStop) and now (eg HISC, CHERI) with some but not all properties. Had they marketed it right, the i960 might have made it and would today be 8-16 cores with blah blah acceleration. I&#39;d be coding on it. :) </p>
<p>It&#39;s still in production minus my favorite features far as I can see. I suggested they open source and license it for a tiny fraction on MIPS or ARM. Independents or academics might do something with it. No action on that. I&#39;d like the MX model, myself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235046">
				<div id="div-comment-1235046" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235046">
			July 27, 2015 at 7:26 pm</a>		</div>

		<p>Thank you for the article &#8211; I look forward to the follow-ons!</p>
<p>You mentioned you don&#39;t intend to cover the floating point side of things as they aren&#39;t exciting, but that&#39;s an area I would find very interesting. &nbsp;At the time, I remember reading that the Itanium opcodes could shove three parallel instructions into 128 bits with a tag bit of some sort to indicate following sets of 3 instructions could also be executed in parallel. &nbsp;I think the idea was that as they could afford to stuff more ALUs onto the chip, parallel code could scale transparently (without recompilation on a newer compiler). &nbsp;For numerical (floating point) work, this seems brilliant. &nbsp;SSE and AVX can mostly fill that niche now, but you mostly have to do the exact same operations across the vector, and in order to scale, Intel has to create bigger SIMD registers (AVX-512).</p>
<p>I always thought it was a shame Itanium died in the market, largely from (what I believed was) trash-talking articles drawing attention to how poorly it emulated legacy x86. &nbsp;Regardless, the public glommed on to that and rejected it like sheep (people still call it the Itanic without even knowing much about it).</p>
<p>I wonder if Intel marketing had not tried to keep it backwards compatible if they could&#39;ve dodged all the complaints about running it in that mode. &nbsp;My guess is that aren&#39;t enough people doing scientific programming to justify the architecture. &nbsp;Integer ops and 3D vectors rule the day in web-serving and gaming markets&#8230;</p>
<p>I also look forward to your Alpha articles. &nbsp;I used plenty of those in the day, and when everything switched to x86, a lot of our (naive) software ran slower until we tailored it for x86 (simple code ran fast enough on the Alphas). &nbsp;Price per performance ended up winning in the end, and now we use a desktop architecture for numerical algorithms.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235036">
				<div id="div-comment-1235036" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235036">
			July 27, 2015 at 7:59 pm</a>		</div>

		<p>This is fascinating. &nbsp;And with 20/20 hindsight, I can see why they thought this was a good way forward, and also why x86 beat it. &nbsp;Keep it coming!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235026">
				<div id="div-comment-1235026" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235026">
			July 27, 2015 at 8:20 pm</a>		</div>

		<p>@Zack wrote:</p>
<p>&gt; I had a small hand in the Itanium back end for GCC</p>
<p>&gt; The lesson I took away from it, as a compiler guy, </p>
<p>&gt; was that for general-purpose integer work, ahead-of-time</p>
<p>&gt; scheduling &lt;i&gt;cannot&lt;/i&gt; hope to compete with out-of-order</p>
<p>&gt; execution in the CPU, because memory access latencies and</p>
<p>&gt; branch destinations are just too unpredictable. &nbsp;All of</p>
<p>&gt; that lovely explicit parallelism was being blown on NOPs</p>
<p>&gt; and load stalls.</p>
<p>As I&#39;m sure you know, around the same time, several GCC forks were consolidated into EGCS to try and get good performance out of regular old x86 &#8211; eventually replacing the old GCC. &nbsp;It is easy for me to believe that GCC&#39;s original design wasn&#39;t very accommodating to anything other than traditional RISC processors, and that EPIC might have required a similar effort from GCC developers to be viable.</p>
<p>Besides, who&#39;s to say that Itanium couldn&#39;t have evolved to do speculative/out-of-order execution (and register renaming, etc&#8230;) as well? &nbsp;Just because the compiler has more freedom to be explicit doesn&#39;t mean the CPU can&#39;t infer additional optimizations. &nbsp;In some imaginary world (one we don&#39;t live in), those no-ops would&#39;ve been discarded upon translation to the icache. &nbsp;It&#39;s hard for me to see how an instruction set with more registers and the ability to indicate more information to the CPU &quot;&lt;i&gt;cannot&lt;/i&gt; hope to compete&quot; with a CPU which has neither.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1235016">
				<div id="div-comment-1235016" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235016">
			July 27, 2015 at 9:27 pm</a>		</div>

		<p>Wow&#8230;. THAT many registers?</p>
<p>How in the world do you handle context switches for that many registers? I thought the original i860 was eventually rejected for NT (&quot;N-Ten&quot;) because it just couldn&#39;t switch its many registers fast enough. But this thing has a lot more than the 860 did! How does an Itanium context switch even work?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1235006">
				<div id="div-comment-1235006" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1235006">
			July 28, 2015 at 1:11 am</a>		</div>

		<p>@Mark: the reason people took Itanium to task for not doing x86 well was also because Intel itself envisioned Itanium as the replacement for x86 everywhere. When it became clear the global domination wasn&#39;t happening any time soon Intel backpedaled quickly, positioning the Itanium as purely a server architecture instead with no designs on the desktop market. Even then it could have worked, but Intel failed to make Itanium compelling quickly enough. x86 performance aside, even native Itanium code wasn&#39;t outperforming the competition. Intel did improve it, but they just couldn&#39;t catch up. When AMD64 came out and gave people what they wanted, rather than what Intel thought they needed, it was basically game over. Itanium had some interesting ideas, but it dramatically failed to capitalize on them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234996">
				<div id="div-comment-1234996" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234996">
			July 28, 2015 at 2:42 am</a>		</div>

		<p>Please keep going with this series. I vote +1 for the Alpa AXP, too!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1234986">
				<div id="div-comment-1234986" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234986">
			July 28, 2015 at 3:48 am</a>		</div>

		<p>This is insane&#8230;</p>
<p>And I&#39;ll be boring, but I&#39;m more interested in ARM than AXP&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234976">
				<div id="div-comment-1234976" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234976">
			July 28, 2015 at 4:40 am</a>		</div>

		<p>@Andre</p>
<p>Relative to the predicate registers, my first thought upon seeing &quot;p0 Reads as true&quot; was to ask why wasn&#39;t p0 set up to always read as false and p1 always read as true. Further reflection revealed this wouldn&#39;t make any sense if there isn&#39;t a direct way to &quot;test false and do/branch&quot;. But as I know virtually nothing about the Itanium instruction set, this is just guessing on my part.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234956">
				<div id="div-comment-1234956" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234956">
			July 28, 2015 at 7:13 am</a>		</div>

		<p>I&#39;m going to greatly enjoy this series. I often wish I had a job that requires knowing information like this.</p>
<p>Another +1 for AXP too</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234876">
				<div id="div-comment-1234876" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234876">
			July 28, 2015 at 10:49 am</a>		</div>

		<p>@Mark:</p>
<p>I don&#39;t remember which version of GCC first shipped an ia64 back end. I worked on it a few years after the branches were reunified &#8212; circa 2002, so that would&#39;ve been 3.1 or 3.2. Someone else had already done most of the heavy lifting, I just did fine-tuning and debugging. (For clarity, also, I haven&#39;t been involved with GCC development since about 2006.)</p>
<p>It is true that the architecture GCC had at the time was a handicap; in particular, the ia64 back end disabled the machine-independent scheduler and reimplemented it from scratch, because the MI scheduler (at the time) was not capable of bundle-packing correctly. However, that was not the biggest hindrance to performance. Rather, it was that there just isn&#39;t enough _statically visible_ ILP in &quot;general purpose integer code&quot; to fill up the bundles efficiently. (Think SPECint rather than SPECfp; alternatively, think &quot;gigantic white-elephant C++ application, in which a supermajority of all instructions executed are virtual method calls&quot;.) Out-of-order hardware will always be able to squeeze more ILP out of this kind of code &#8230; I think probably 75% because of dynamic branch prediction and 25% because it doesn&#39;t have to conservatively estimate memory access latencies. Both involve information that isn&#39;t available to an ahead-of-time compiler, no matter how clever it is.</p>
<p>I can imagine an architecture not unlike what Transmeta (remember Transmeta?) was going for, in which out-of-order execution is implemented in software. I suspect that couldn&#39;t beat dedicated OOO hardware on speed or power efficiency, but it might make the hardware simpler enough to be worth the hit. (Disclaimer: I know bupkis about hardware design.) I can also imagine an evolved Itanium with out-of-order execution that&#39;s competitive on generic integer code, but I think you could get there easier if you started from something like Alpha or MMIX. Which HP had the opportunity to do, come to think of it, didn&#39;t they buy the Alpha design IP when they bought Compaq? Perhaps that is what AArch64 will become &#8212; I haven&#39;t looked at it in detail.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234866">
				<div id="div-comment-1234866" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234866">
			July 28, 2015 at 10:56 am</a>		</div>

		<p>@JM:</p>
<p>Absolutely agree: the inclusion of an x86 compatibility mode in Itanium was 100% a mistake, as was attempting to position it from day one as The One Architecture To Rule Them All. &nbsp;Better to have introduced it as a high-end server CPU with no backward compatibility goop, and moved downmarket after it had demonstrated enough momentum to warrant ongoing R&amp;D resources.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234726">
				<div id="div-comment-1234726" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234726">
			July 29, 2015 at 12:11 am</a>		</div>

		<p>@IanBoyd Not only in hindsight. I remember being at an Itanium session at JavaOne in 1998 and thinking it very ironic that a processor so actively hostile to JIT compilation was being presented at a Java conference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234706">
				<div id="div-comment-1234706" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234706">
			July 29, 2015 at 6:10 am</a>		</div>

		<p>Very interesting article and please do a series on the Alpha too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234686">
				<div id="div-comment-1234686" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234686">
			July 29, 2015 at 7:31 am</a>		</div>

		<p>JeroenFrijters: My first thought upon seeing the architecture was also how painful it must be to JIT. All that analysis the compiler must do would surely make any JIT horribly slow to start up.</p>
<p>But then as I read more about the features of IA64, I thought many of them seem impossible for a compiler to use because they require runtime analysis. And then I realized &#8212; those features are custom-made for a JIT compiler!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234566">
				<div id="div-comment-1234566" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234566">
			July 29, 2015 at 11:51 am</a>		</div>

		<p>@JD: (regarding i860)</p>
<p>Word of mouth is that the problem was interrupt processing. &nbsp;Interrupt processing on the i860 required significant, complex code to save the state that was interrupted and then resume it when the interrupt was completed.</p>
<p>It&#39;s possible that the memory bandwidth wasn&#39;t adequate for context switching but I don&#39;t remember ever hearing about that.</p>
<p>Interestingly in very high performance workloads, interrupt processing is again too slow so many techniques are applied to mitigate high interrupt rates which probably would have made the ghastly amount of decode required for i860 interrupts tolerable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234516">
				<div id="div-comment-1234516" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234516">
			July 29, 2015 at 2:51 pm</a>		</div>

		<p>I love this sort of stuff. &nbsp;Also interested in the Alpha AXP if you decide to do it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234426">
				<div id="div-comment-1234426" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150727-00/?p=90821#comment-1234426">
			July 30, 2015 at 9:30 am</a>		</div>

		<p>I would like to see a PA-RISC overview.Commodore were going to put PA-RISC&#39;s into the next gen Amiga&#39;s bitd. the one&#39;s that never came out and were going to be Windows NT based :/</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

