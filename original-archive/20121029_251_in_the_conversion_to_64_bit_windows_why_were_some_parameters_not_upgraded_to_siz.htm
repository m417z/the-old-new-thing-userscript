<html>
<head>
<title>In the conversion to 64-bit Windows, why were some parameters not upgraded to SIZE_T?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>In the conversion to 64-bit Windows, why were some parameters not upgraded to SIZE_T?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 29, 2012 / year-entry #252</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>29</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">James wonders why many functions kept DWORD for parameter lengths instead of upgrading to SIZE_T or DWORD_PTR. When updating the interfaces for 64-bit Windows, there were a few guiding principles. Here are two of them. Don't change an interface unless you really need to. Do you really need to? Changing an interface causes all sorts...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
James wonders
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2010/07/20/10040074.aspx#10042836">
why many functions kept <code>DWORD</code> for parameter
lengths instead of upgrading to <code>SIZE_T</code> or
<code>DWORD_PTR</code></a>.
</p>
<p>
When updating the interfaces for 64-bit Windows,
there were a few guiding principles.
Here are two of them.
</p>
<ul>
<li>Don't change an interface unless you really need to.
<li>Do you really need to?
</ul>
<p>
Changing an interface causes all sorts of problems when porting.
For example, if you change the parameters to a COM interface,
then you introduce a breaking change in everybody who implements it.
Consider this hypothetical interface:
</p>
<pre>
// namedobject.idl
interface INamedObject : IUnknown
{
    HRESULT GetName([out, string, sizeof(cchBuf)] LPWSTR pszBuf,
                    [in] DWORD cchBuf);
};
</pre>
<p>
And here's a hypothetical implementation:
</p>
<pre>
// contoso.cpp
class CContosoBasicNamedObject : public INamedObject
{
    ...
    HRESULT GetName(LPWSTR pszBuf, DWORD cchBuf)
    {
        return StringCchPrintfW(pszBuf, cchBuf, L"Contoso");
    }
    ...
};
</pre>
<p>
Okay, now it's time to 64-bit-ize this puppy.
So you do the natural thing: Grow the
<code>DWORD</code> parameter
to <code>DWORD_<wbr>PTR</code>.
Since
<code>DWORD_<wbr>PTR</code> maps to <code>DWORD</code>
on 32-bit systems, this is a backward-compatible change.
</p>
<pre>
// namedobject.idl
interface INamedObject : IUnknown
{
    HRESULT GetName([out, string, sizeof(cchBuf)] LPWSTR pszBuf,
                    [in] DWORD<font COLOR=red>_PTR</font> cchBuf);
};
</pre>
<p>
Then you recompile the entire operating system and find that
the compiler complains,
"Cannot instantiate abstract class: CContosoBasicNamedObject."
Oh, right, that's because the
<code>INamed&shy;Object::<wbr>Get&shy;Name</code> method
in the implementation no longer matches the method in the
base class,
so the method in the base class is not overridden.
Fortunately, you have access to the source code for
<code>contoso.cpp</code>, and you can apply the appropriate fix:
</p>
<pre>
// contoso.cpp
class CBasicNamedObject : public INamedObject
{
    ...
    HRESULT GetName(LPWSTR pszBuf, DWORD_<font COLOR=red>PTR</font> cchBuf)
    {
        return StringCchPrintfW(pszBuf, cchBuf, L"Basic");
    }
    ...
};
</pre>
<p>
Yay, everything works again.
A breaking change led to a compiler error, which led you
to the fix.
The only consequence (so far) is that the number of
"things in code being ported from 32-bit Windows to 64-bit Windows
needs to watch out for"
has been incremented by one.
Of course,
too much of this incrementing, and the list of things becomes
so long that developers are going to throw up their hands and say
"Porting is too much work, screw it."
Don't forget,
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2012/09/13/10348876.aspx">
the number of breaking API changes in the
conversion from 16-bit to 32-bit Windows was only 117</a>.
</p>
<p>
You think you fixed the problem, but you didn't.
Because there's another class elsewhere in the Contoso project.
</p>
<pre>
class CSecureNamedObject : public CBasicNamedObject
{
    ...
    HRESULT GetName(LPWSTR pszBuf, DWORD cchBuf)
    {
        if (IsAccessAllowed())
        {
            return CBasicNamedObject::GetName(pszBuf, cchBuf);
        }
        else
        {
            return E_ACCESSDENIED:
        }
    }
}
</pre>
<p>
The compiler did not raise an error on
<code>CSecure&shy;Named&shy;Object</code> because that
class is not abstract.
The
<code>INamed&shy;Object::<wbr>Get&shy;Name</code> method
from the <code>INamed&shy;Object</code> interface
is implemented by <code>CBasic&shy;Named&shy;Object</code>.
All abstract methods have been implemented,
so no "instantiating abstract class" error.
</p>
<p>
On the other hand, the <code>CSecure&shy;Named&shy;Object</code>
method <i>wanted</i> to override the base method,
but since its parameter list didn't match,
it ended up creating a separate method rather than an override.
(The <code>override</code> pseudo-keyword not yet having been standardized.)
As a result, when somebody calls the
<code>INamed&shy;Object::<wbr>Get&shy;Name</code> method
on your
<code>CSecure&shy;Named&shy;Object</code>,
they don't get the one with the security check,
but rather the one from
<code>CBasic&shy;Named&shy;Object</code>.
Result: Security check bypassed.
</p>
<p>
These are the worst types of breaking changes:
The ones where the compiler doesn't tell you that something is wrong.
Your code compiles,
it even basically runs,
but it doesn't run <i>correctly</i>.
Now, sure, the example I gave would have been uncovered
in security testing,
but I chose that just for drama.
Go ahead and substitute something much more subtle.
Like say,
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2006/10/24/868544.aspx">
invalidating the entire desktop when you pass
<code>NULL</code> to
<code>Invalidate&shy;Rect</code></a>.
</p>
<p>
Okay, so let's look back at those principles.
Do we really need to change this interface?
The only case where expanding to
<code>SIZE_T</code> would make a difference is if
an object had a name longer than 2 billion characters.
Is that a realistic end-user scenario?
Not really.
Therefore, don't change it.
</p>
<p>
Remember,
you want to make it <i>easier</i> for people to port
their program to 64-bit Windows, not harder.
The goal is <i>make customers happy</i>, not
<i>create the world's most architecturally
pure operating system</i>.
And customers aren't happy when the operating system
can't run their programs
(because every time the vendor try to port it, they keep stumbling
over random subtle behavior changes that break their program).</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (29)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1018143">
				<div id="div-comment-1018143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018143">
			October 29, 2012 at 7:16 am</a>		</div>

		<p>Ah, the old Python adage &quot;practicality beats purity&quot;. &nbsp;If you build the tallest ivory tower of utmost purity, nobody will want to live in it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-xpclientgmail-com odd alt thread-odd thread-alt depth-1" id="comment-1018153">
				<div id="div-comment-1018153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/xpclient' rel='external nofollow' class='url'>xpclient</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018153">
			October 29, 2012 at 8:02 am</a>		</div>

		<p>Thank God the x86 to x64 porting of Windows happened while Jim Allchin was still there at the company! The current team would have made all sorts of compromises like they did for ARM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018163">
				<div id="div-comment-1018163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018163">
			October 29, 2012 at 8:06 am</a>		</div>

		<p>My compiler generates a pretty strong warning when I try that setup (hides virtual base member).</p>
<p>Of course on that particular case, meh it&#39;s just not worth it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018183">
				<div id="div-comment-1018183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018183">
			October 29, 2012 at 9:41 am</a>		</div>

		<p>@xpclient: &nbsp;You liar, Windows 8 provides a no-compromise computing experience. &nbsp;I read it in a marketing release so it must be true.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018193">
				<div id="div-comment-1018193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018193">
			October 29, 2012 at 10:05 am</a>		</div>

		<p>I agree but it&#39;s a slippery slope guys. Look at PHP ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018203">
				<div id="div-comment-1018203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018203">
			October 29, 2012 at 10:16 am</a>		</div>

		<p>This looks like a C++ specific problem. &nbsp;I didn&#39;t actually know that there was a not-yet-standardized &quot;override&quot; pseudo-keyword, but I know where the idea comes from: that&#39;s one of the many little details that makes Delphi a better language.</p>
<p>In Delphi, when a derived class declares a method with the same name as a virtual method in a base class, it has to match the signature and mark it as &quot;override&quot; to make it an override. &nbsp;Otherwise you get a compiler warning. &nbsp;If you do mark a method as override and it doesn&#39;t match the signature, as in the example here, it&#39;s a compiler error. And there&#39;s another directive, &quot;reintroduce,&quot; that makes it explicit that you don&#39;t mean to override the virtual method and gets rid of the compiler warning. &nbsp;Between &quot;override&quot; and &quot;reintroduce&quot;, it&#39;s impossible to accidentally make this kind of mistake unnoticed. &nbsp;(Especially if you also treat warnings as errors.)</p>
<div class="post">[<i>There are non-C++ examples, too. For example, changing the function signature silently breaks every p/invoke. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1018213">
				<div id="div-comment-1018213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018213">
			October 29, 2012 at 10:25 am</a>		</div>

		<p>One notable old PHD from CMU, an expert in Windows kernel and user mode, has bitterly complained that Win64 didn&#39;t expand ReadFile/WriteFile length to 64 bits. Seriously.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-1018223">
				<div id="div-comment-1018223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018223">
			October 29, 2012 at 11:05 am</a>		</div>

		<p>Mason, Visual C++ has similar warnings about differing virtual functions, but I believe that they are disabled by default unless you use the highest level of warnings (which I highly recommend).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018233">
				<div id="div-comment-1018233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018233">
			October 29, 2012 at 11:37 am</a>		</div>

		<p>Why did you use DWORD_PTR here instead of SIZE_T? I thought that type was used for when you wanted to non-lossy cast between pointers and integers in the DWORD range?</p>
<div class="post">[<i>To avoid introducing a breaking change to the 32-bit side. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018243">
				<div id="div-comment-1018243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018243">
			October 29, 2012 at 12:04 pm</a>		</div>

		<p>@xpclient:</p>
<p>I take it you missed this:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx" rel="nofollow">blogs.msdn.com/&#8230;/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018253">
				<div id="div-comment-1018253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018253">
			October 29, 2012 at 12:12 pm</a>		</div>

		<blockquote><p>
  One notable old PHD from CMU, an expert in Windows kernel and user mode, has bitterly complained that Win64 didn&#39;t expand ReadFile/WriteFile length to 64 bits. Seriously.
</p></blockquote>
<p>Wow. Do you really want a &gt;2GB single IO request?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-1018263">
				<div id="div-comment-1018263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018263">
			October 29, 2012 at 12:57 pm</a>		</div>

		<p>Reminds me of this:</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/psssql/archive/2011/10/03/yes-we-made-a-mistake-and-are-finally-going-to-fix-it.aspx" rel="nofollow">blogs.msdn.com/&#8230;/yes-we-made-a-mistake-and-are-finally-going-to-fix-it.aspx</a></p>
<p><a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/983246" rel="nofollow">support.microsoft.com/&#8230;/983246</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018273">
				<div id="div-comment-1018273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018273">
			October 29, 2012 at 3:44 pm</a>		</div>

		<p>wrt &gt;2GB I/O requests..</p>
<p>I would like them, yes. The entire point of going 64-bit is to address more memory. When you are designing standards for 64-bit computing, the last thing that you want to do is use 32-bit thinking to limit it. Not to mention the fact that modern consumer grade SSD&#39;s push half a gigabyte per second these days, that high end SSD&#39;s use proprietary interfaces to push several gigabytes per second over PCIe, that new computers are often now sold with 8= GB of memory&#8230;</p>
<p>What desirable purpose does it serve to require specialized code to read and write a dataset whose size happens to breach an artificial barrier imposed by a 20 year old paradigm? There is no justification for a 31-bit size restriction on a 64-bit architecture, only fallacious rationalizations such as &quot;do you really want a &gt;2GB single IO request?&quot; .. YES, I WOULD LIKE TO INFORM THE OS OF EXACTLY WHAT I AM DOING.</p>
<div class="post">[<i>It doesn&#39;t matter whether you extend the parameter to 64 bits or not, because the maximum size of a single write is 32MB. (Remember that I/O buffers must be locked, and locking 4GB of memory is not very friendly to the memory manager.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018283">
				<div id="div-comment-1018283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018283">
			October 29, 2012 at 4:35 pm</a>		</div>

		<p>@Mason Wheeler</p>
<p>Unfortunately, and it breaks my heart to say so, Delphi is not better in this perspective then any other language and that is because Delphi had/forced to recognize the existence of C/C++ languages (hence we got those nice register;cdecl; reserved words) while C/C++ acted just like Windows (Linux? who is Linux? I am the only OS and the given God gift to PC&#39;s). So, from this perspective, the entire Delphi implementation of COM / Win32s / interfaces etc was made purely as a port to match binary compilation like a C/C++ compiler would do. And that&#39;s why Delphi tastes so bad when you start to need those .h files to have a Delphi implementation of an already C/C++ library.</p>
<p>Now, back to our example, do this in Delphi, port Ray&#39;s example one on one to a Delphi equivalent and then see that Delphi will suffer from the same &quot;kick&quot; like Ray said in the end regarding CSecureNamedObject.</p>
<p>Perhaps I should feel better because when you deal with interfaces at least you already know what to expect if you decide to switch from C/C++ to Delphi as your main language for living, only to discover later that Delphi is a breeze when it comes to &quot;my boss wants this app done in 2 weeks while I know form my experience it will took at least 2 months&quot;. Sorry Ray, but it is the truth, Delphi is so much better then C/C++. If Microsoft would decide to make W9 in Delphi, it will find out that it need only half the time, so maybe sticking with C/C++ to create it is better from economics perspective &#8211; you feed more people. Decisions decisions&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018293">
				<div id="div-comment-1018293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/axel_4000_crytek.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>axel@crytek.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018293">
			October 29, 2012 at 5:21 pm</a>		</div>

		<p>Danny, you realize that C# was designed by the creator of Delphi and was influenced a lot of its design, especially in the libraries?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1018303">
				<div id="div-comment-1018303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018303">
			October 29, 2012 at 9:55 pm</a>		</div>

		<p>[because the maximum size of a single write is 32MB]</p>
<p>Strictly speaking, it&#39;s not true anymore in Vista+ (2GB-4K) and Win7+ (4GB-4K). Length argument in IoAllocateMdl is still ULONG.</p>
<p>But this is a game of diminishing returns. Most storage controllers have a limit for a single IO size (usually around 1MB, more or less). A single I/O larger than that has to be chopped to multiple requests anyway. It doesn&#39;t make sense to push a whole giant buffer at once.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1018313">
				<div id="div-comment-1018313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018313">
			October 29, 2012 at 9:57 pm</a>		</div>

		<p>[A single I/O larger than that has to be chopped to multiple requests anyway.]</p>
<p>Although this is done by classpnp.sys, transparently for the application.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018353">
				<div id="div-comment-1018353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018353">
			October 30, 2012 at 7:26 am</a>		</div>

		<p>[&#8230; (Remember that I/O buffers must be locked,&#8230;.) -Raymond]</p>
<p>I would assume that only the lowest-level device driver needs to lock and unlock pages, and only for the duration of the onging respective I/O requests.</p>
<p>Is Windows really locking all the pages of a ReadFile() call at once, even if (for example) a USB 1.1 memory stick needs seconds to minutes to read 10 Mbyte of data request by the ReadFile call?</p>
<div class="post">[<i>If you&#39;re going to issue a single I/O to the device, then it had all better be locked! It&#39;s hard to DMA into the pagefile. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018403">
				<div id="div-comment-1018403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018403">
			October 30, 2012 at 9:37 am</a>		</div>

		<p>@Axel: Exactly. &nbsp;Things have diverged a fair amount since then, but if you look at C# and .NET 1.0, it&#39;s essentially &quot;Delphi rewritten to look like Java.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018323">
				<div id="div-comment-1018323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018323">
			October 30, 2012 at 3:10 am</a>		</div>

		<p>Look, a 2 TB IO request may not make sense now, but in just a few years we&#39;ll all be pointing and laughing at the people who never said 640K ought to be enough for anybody, so we&#39;d better start rewriting things right now.</p>
<p>@Joseph: a non-fallacious rationalization is the simple observation that we&#39;re not &quot;designing standards for 64-bit computing&quot;. In itself, that&#39;s not such a good market to be in anyway (ask Intel about Itanium some time). What we *are* doing is getting 64-bit out there in a way that makes the most pragmatic sense. Sometimes that may err on the side of too much conservatism, but that tends to be less harmful than erring on the other side. Of course, everybody has their favorite examples of some doofus getting it obviously wrong.</p>
<p>The blanket statement &quot;there is no justification for a 31-bit size restriction on a 64-bit architecture&quot; is faintly ridiculous as a comment on a post where *just that* is demonstrated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018483">
				<div id="div-comment-1018483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018483">
			October 30, 2012 at 2:19 pm</a>		</div>

		<p>What&#39;s going to happen to Raymond&#39;s blog? &nbsp;It&#39;s clear from Windows 8 that Microsoft considers desktop applications deprecated, so why bother to have backward compatibility in the long run?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018533">
				<div id="div-comment-1018533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gerry</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018533">
			October 30, 2012 at 5:29 pm</a>		</div>

		<p>@JamesJohnston &#8211; To be fair, Delphi has provided overloaded versions of the conversion functions for many versions (not sure which one was first, before Delphi 2006. Yes it should have been earlier, preferably Delphi 2 when Win32 support was added). The original versions were written before multithreading was common &#8211; Delphi 1 was for Windows 3.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-1018453">
				<div id="div-comment-1018453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018453">
			October 30, 2012 at 11:58 am</a>		</div>

		<p>@xpclient: Windows RT has a full enough implementation of Win32 and the classic GDI model that the majority of Office 2013 Home &amp; Student can be ported, and that all the same desktop control panels are present. It&#39;s just that ordinary developers are not being permitted to even sideload apps, which is a very different thing. I would be *astonished* if Windows RT were not simply a recompile of the common source code, with just a few pieces written in assembly.</p>
<p>Macros are missing from Office RT because &#8211; assuming things are the same as they were when MacBU were trying to migrate from Carbon to Cocoa, see <a rel="nofollow" target="_new" href="http://www.schwieb.com/blog/2006/08/08/saying-goodbye-to-visual-basic/" rel="nofollow">http://www.schwieb.com/&#8230;/saying-goodbye-to-visual-basic</a> &#8211; the VBA bytecode interpreter is written in tens of thousands of lines of x86 assembly.</p>
<p>My suspicion is that the only reason that the desktop remains in Windows RT is because the Office team did not want to take a dependency on WinRT while it was still in its formative stages, and similarly that the control panels deemed less important were not prioritised for porting to WinRT. New core features like Storage Spaces probably didn&#39;t want to take a dependency on WinRT at this stage either. The Windows division have learned from the Longhorn debacle. Shipping is a feature.</p>
<p>Certainly Windows RT is intended to only ever be used on tablets &#8211; allowing any arbitrary code to be recompiled for it would not meet the design goals of very low power consumption and low heat output.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1018463">
				<div id="div-comment-1018463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018463">
			October 30, 2012 at 1:06 pm</a>		</div>

		<p>@Mason Wheeler: &nbsp;&quot;if you look at C# and .NET 1.0, it&#39;s essentially &#39;Delphi rewritten to look like Java.&#39;&quot;</p>
<p>I&#39;d clarify that by saying it&#39;s essentially Delphi rewritten to look like Java, but with loads of improvements to the runtime libraries. &nbsp;Having worked with both .NET Framework and the VCL, I&#39;ve lost count of the number of times in the VCL I&#39;ve thought &quot;wow, this is like .NET, but worse.&quot;</p>
<p>For example: if you want to convert a string to a date/time from different formats, you have to modify *global variables* that control date/time formatting. &nbsp;(You wanted to multi-thread your program and use VCL date/time functions? &nbsp;Ha!!) &nbsp;The TDateTime constructor that accepts a string parameter won&#39;t accept any parameter that specifies formatting information. &nbsp;The only way I&#39;ve found is to modify global variables&#8230;</p>
<p>Comedy ensues when you have programs storing dates as strings in files that are shared across international borders and the programmer&#39;s didn&#39;t think to fuss with global variables to make it culture-neutral. &nbsp;At least .NET has an overload to make you think about it, and makes it brain-dead easy to use a culture-neutral format.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018583">
				<div id="div-comment-1018583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018583">
			October 30, 2012 at 8:24 pm</a>		</div>

		<p>[It doesn&#39;t matter whether you extend the parameter to 64 bits or not, because the maximum size of a single write is 32MB. (Remember that I/O buffers must be locked, and locking 4GB of memory is not very friendly to the memory manager.) -Raymond]</p>
<p>Then why support sizes larger than 32MB, like 2GB? This is just another rationalization.</p>
<p>We are talking about a legacy 32-bit API that supported 2GB I/O requests at a time when only 12MB to 16MB of system memory (NT 3.1) was expected. You simply do not get to talk about some irrelevant 32MB restriction as if it has any teeth&#8230; because it didnt then, so why would it now?</p>
<p>The reasoning is &quot;We don&#39;t have to change anything this way&quot; .. the rationalization is all this other stuff that makes excuses for it.</p>
<div class="post">[<i>I don&#39;t know where you got the idea that 32-bit Windows supported 2GB I/O requests. Like I said, the maximum was 32MB. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1018593">
				<div id="div-comment-1018593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018593">
			October 30, 2012 at 8:50 pm</a>		</div>

		<blockquote><p>
  Is Windows really locking all the pages of a ReadFile() call at once
</p></blockquote>
<p>Yes, this is about the first thing (along with the handle dereference) done by the I/O manager, for non-buffered requests. Because most of the further processing is done outside of the original process context.</p>
<blockquote><p>
  Then why support sizes larger than 32MB, like 2GB?
</p></blockquote>
<p>This is more likely for special applications, such as RDMA.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-davebacher even thread-even depth-1" id="comment-1018673">
				<div id="div-comment-1018673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018673">
			October 31, 2012 at 6:34 am</a>		</div>

		<p>There is also an additional cost on all basic type changes. If a type changes bits, then you have to repack it from the other subsystem. &nbsp;If you change a type like SIZE_T, you also break cross task marshalling. &nbsp;In Delphi and other Pascal derivatives, there is more formalization, but having a structure different sizes still will complicate any IPC, and so these sorts of definition changes are bad there as well.</p>
<p>From an app architecture point of view, your better off ignoring the CPU, and sizing types based off of intended usage. &nbsp;Used to be I&#39;d advocate using 32bit values for most everything, but 64 is just too wide. &nbsp;You waste way too much space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1018683">
				<div id="div-comment-1018683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018683">
			October 31, 2012 at 6:39 am</a>		</div>

		<p>[I doubt that this lock-the-whole-range-at-once approach is the best way of doing I/O]</p>
<p>This would be an unnecessary optimization for obscenely large I/O requests, causing unnecessary complication of the storage stack. Otherwise if you lock pages as you go, you can&#39;t do asynchronous I/O. Welcome to early single-threaded UNIX.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1018613">
				<div id="div-comment-1018613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20121029-00/?p=6233#comment-1018613">
			October 31, 2012 at 2:26 am</a>		</div>

		<p>[If you&#39;re going to issue a single I/O to the device, then it had all better be locked! It&#39;s hard to DMA into the pagefile. -Raymond]</p>
<p>Ok, thats how it is implemented today: The low-level drivers will not request the pages as needed to be present in memory to lock them. But I doubt that this lock-the-whole-range-at-once approach is the best way of doing I/O. The discussed examples of starting very large* I/O operations demonstrate that this strategy will needlessly lock pages for absurd long durations.</p>
<p>* &nbsp;&quot;Large&quot; in terms of time it will take to complete, which will be many hours for a 2 TB read operation even on a harddisk, let alone slower devices like CD-ROM/Blu-Ray, USB-Sticks or network access.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

