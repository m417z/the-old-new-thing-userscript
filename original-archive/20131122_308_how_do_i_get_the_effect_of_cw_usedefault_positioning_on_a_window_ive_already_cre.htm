<html>
<head>
<title>How do I get the effect of CW_USEDEFAULT positioning on a window I've already created?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How do I get the effect of CW_USEDEFAULT positioning on a window I&#8217;ve already created?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 22, 2013 / year-entry #309</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>37</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer wanted to know how to get the effect of CW_USE­DEFAULT positioning on a window that already exists. In particular, they wanted to be able to reposition a dialog box to get the CW_USE­DEFAULT cascade effect, but since you can't actually pass CW_USE­DEFAULT in a dialog template, the repositioning has to be done after...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p> A customer wanted to know how to <a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/11/26/10371440.aspx"> get the effect of <code>CW_USE&shy;DEFAULT</code> positioning</a> on a window that already exists. In particular, they wanted to be able to reposition a dialog box to get the <code>CW_USE&shy;DEFAULT</code> cascade effect, but since you can't actually pass <code>CW_USE&shy;DEFAULT</code> in a dialog template, the repositioning has to be done after the fact. (Presumably in the <code>WM_<wbr>INIT&shy;DIALOG</wbr></code> handler, which runs before the dialog is visible, so that there is no visible flicker.) </p>
<p> The solution here is simple: Create a temporary invisible window with <code>CW_USE&shy;DEFAULT</code> as its position and the same height and width as your dialog box. See where the window manager puts that temporary window and move your dialog box to match that position. Then destroy the temporary window. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1090833">
				<div id="div-comment-1090833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090833">
			November 22, 2013 at 10:03 am</a>		</div>

		<p>I dare say the customer thought of that, but just wanted to know if there&#39;s a way that isn&#39;t a blood-ugly hack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1090853">
				<div id="div-comment-1090853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090853">
			November 22, 2013 at 11:10 am</a>		</div>

		<p>IF the custoomer, as A C suggests, thinks this is a blodd-ugly hack, he has my full support.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1090863">
				<div id="div-comment-1090863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Another AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090863">
			November 22, 2013 at 11:16 am</a>		</div>

		<p>If that&#39;s the solution, I&#39;d rather do without the feature.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1090873">
				<div id="div-comment-1090873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090873">
			November 22, 2013 at 12:25 pm</a>		</div>

		<p>As hacks go, it&#39;s not that bad at all: it only relies on putting a string of documented features together (CreateWindow -&gt; GetWindowRect -&gt; DestroyWindow). They&#39;re even being used for their intended purposes! If I recall, this is sometimes also known as &quot;programming.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1090913">
				<div id="div-comment-1090913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">hmm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090913">
			November 22, 2013 at 1:00 pm</a>		</div>

		<p>Interesting. &nbsp;I guess since usually dialog boxes have an associated owner window and aren&#39;t usually used like normal overlapped windows, it looks like there simply aren&#39;t any parameters in any of the dialog creation functions to control/direct dialog-box positioning; it looks like you are basically expected to explicitly reposition the dialog yourself in your own code.</p>
<p>The temporary window solution may be a little hacky, but then again, Windows already use hidden windows for all manner of things like receiving cross-apartment STA COM calls, so how bad is a temporary window really?</p>
<p>@Another AC: my guess is the customer wants to use a dialog as their application&#39;s main window, in which case it makes perfect sense that they&#39;d want to support as much of the &quot;normal&quot; window-positioning behaviors as feasible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1090923">
				<div id="div-comment-1090923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Curran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090923">
			November 22, 2013 at 1:47 pm</a>		</div>

		<p>@ErikF &#8212; I don&#39;t see how creating &amp; destroying a window without ever displaying it qualifies as &quot;being used for their intended purposes&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1090933">
				<div id="div-comment-1090933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090933">
			November 22, 2013 at 2:40 pm</a>		</div>

		<p>As hmm mentioned there are numerous reasons to create a window without displaying it. &nbsp;Windows to receive broadcast messages. &nbsp;Windows for STA COM calls. &nbsp;Windows for other types of simple IPC.</p>
<p>While creating a window just to see where it is positioned is a bit hokey, it is hardly the worst thing in the world, and as Erik pointed out &#8212; totally documented.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1090953">
				<div id="div-comment-1090953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090953">
			November 22, 2013 at 3:33 pm</a>		</div>

		<p>Hey guys &#8211; welcome to programming. Putting some blocks together, in this case a hidden window and a bunch of documented APIs. It is certainly not a hack. It would take about 5 minutes to write a wrapper function that does all of this, i.e. CreateDefaultWindowPosition(&#8230;), and now whatever might have the potential to look ugly is tucked away elegantly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1090963">
				<div id="div-comment-1090963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090963">
			November 22, 2013 at 4:07 pm</a>		</div>

		<p>Clever. For some reason, I am cursing myself for not realizing it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1090983">
				<div id="div-comment-1090983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio &#039;Grijan&#039;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090983">
			November 22, 2013 at 4:58 pm</a>		</div>

		<p>I hope the customer has great reasons for doing this. But IMHO, with big displays and multimonitor setups, the only window that should be left at WM_DEFAULT position is the application&#39;s main window, and only if the user hasn&#39;t resized or moved it in a previous session (in which case, we should infer the user wants it to be *there*). Dialog boxes should be placed over their owner, maybe centered on it, but I have come to prefer them just bellow the title bar&#39;s center. Palettes and other secondary windows should be placed relative to the main window, too, in coherent places (for example, next to the left or right border). I know this is not exactly what Windows UI guidelines say, but these rules aren&#39;t incoherent with them, and I think they can greatly help the user.</p>
<p>All of this is my own opinion, grown over the years out of watching my customers using my applications, and watered with a bit of common sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1090993">
				<div id="div-comment-1090993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1090993">
			November 22, 2013 at 6:28 pm</a>		</div>

		<p>It *is* a hack, because it&#39;s doing a very large amount of work in order to get information that is trivially exposed for use by the Window Manager in kernel-mode, but hidden from view for user-mode programs.</p>
<p>Create window class -&gt; syscall -&gt; add an entry to the atom table -&gt; create Window -&gt; syscall -&gt; create window handle -&gt; create preemptive caches of everything a window might want -&gt; ask the window manager to come up with a CW_USEDEFAULT position -&gt; inform users over RDP that a new window has been made -&gt; register window with window station -&gt; begin window pump -&gt; attach to thread -&gt; return to user some time later -&gt; syscall to get window position -&gt; Destroy Window -&gt; tear everything down -&gt; window pump a WM_DESTROY and WM_NCDESTROY -&gt; destroy window handle -&gt; destroy window class -&gt; tell RDP that the window has been destroyed.</p>
<p>It&#39;s maybe a hundred transitions from user to kernel if we include the windows pump, huge amounts of state being constructed and then immediately destroyed &#8211; when all you wanted was to ask the window manager to come up with a CW_USEDEFAULT position for your window.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091013">
				<div id="div-comment-1091013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091013">
			November 23, 2013 at 2:42 am</a>		</div>

		<p>I once wanted to create an application which consisted entirely of a modal dialog but in such a way that it would appear in Windows 95&#39;s task list.</p>
<p>I ended up creating a visible minimised window which owned an invisible window which was the owner of the dialog. This meant that the dialog was associated with the minimised window in the task list, but opened at the &quot;default&quot; position.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091043">
				<div id="div-comment-1091043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091043">
			November 23, 2013 at 10:41 pm</a>		</div>

		<p>Right, because that REALLY slows down the application, compared to the other 30 windows the application is going to create anyway. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091073">
				<div id="div-comment-1091073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091073">
			November 24, 2013 at 3:03 am</a>		</div>

		<p>I do think this is an ugly hack.</p>
<p>It should be possible to pass CW_USEDEFAULT to MoveWindow (or call it MW_USEDEFAULT for that matter).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091083">
				<div id="div-comment-1091083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091083">
			November 24, 2013 at 6:25 am</a>		</div>

		<p>@Matt (and others): If calling an additional function to get a value is considered hacky, then you must absolutely hate the &quot;allocate until the buffer is large enough&quot; approach used by functions like RegQueryValueEx! :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091053">
				<div id="div-comment-1091053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Iain Clarke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091053">
			November 24, 2013 at 12:32 am</a>		</div>

		<p>@James Curran</p>
<p>&gt; @ErikF &#8212; I don&#39;t see how creating &amp; destroying a window without ever displaying it qualifies as &quot;being used for their intended purposes&quot;.</p>
<p>Invisible windows are used for all sorts of purposes. I think you&#39;re focussing too much on one use of a window &#8211; something having a shape to restrict a device context, when it&#39;s also very useful as something to associate a message queue with on a finer scale than a process.</p>
<p>*Cough* COM, *cough* Marshalling&#8230;</p>
<p>I&#39;m sure whoever wrote some of that code found it non-trivial too, but I&#39;m sure they didn&#39;t call it an ugly hack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091093">
				<div id="div-comment-1091093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091093">
			November 24, 2013 at 9:24 am</a>		</div>

		<p>@ErikF: You don&#39;t? There&#39;s something inherently hacky about dual-purpose functions and the Win32 API has some of the worst offenders in that regard (to name MultiByteToWideChar as just one example that immediately comes to mind). </p>
<p>On the other hand I don&#39;t see anything inherently wrong about the proposed approach here &#8211; that&#39;s not really something people need every day is it and the work around is well documented and hardly that much additional work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091103">
				<div id="div-comment-1091103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091103">
			November 24, 2013 at 9:29 am</a>		</div>

		<p>Using GUI objects for IPC is a hack. Although many do it because there&#39;s no better (convenient, performant, simpel) way to do it. Still a hack though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091113">
				<div id="div-comment-1091113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sven2</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091113">
			November 24, 2013 at 11:14 am</a>		</div>

		<p>Doesn&#39;t this solution have concurrency issues when other processes create dialogs?</p>
<p>E.g.: Your process creates its dummy window and it goes to e.g. position (100,100). But before you can create the real window, the task scheduler switches to a second process which creates a dialog the normal way, which is cascaded down to e.g. position 130,130. After that, your process gets CPU time and creates its window at 100,100.</p>
<p>In the end, the window at 100,100 is on top of the window at 130,130. Although it was supposed to be the other way around.</p>
<div class="post">[<em>This race condition existed even if you had a direct method. Your application spends too much time in its <code>WM_INIT&shy;DIALOG</code> handler and another thread creates a dialog at 130,130. You then show your initialized dialog, and it appears at 100,100. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091123">
				<div id="div-comment-1091123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091123">
			November 24, 2013 at 1:02 pm</a>		</div>

		<p>@ErikF The problem with those &quot;Provide us buffer large enough&quot; functions is that they introduce races. While it&#39;s okay for MultiByteToWideChar â€” you pass your own string in, so don&#39;t be your own enemy and don&#39;t change it between two calls, â€” it&#39;s not okay for, say, GetTcpTable: the number of connections can easily grow up before the second call to it. Really, can&#39;t the system allocate some internal buffer on its own?</p>
<p>And do you how netstat circumvents that problem with GetTcpTable? Oh, it calls some un-documented API function that basically calls GetTcpTable three more times on ERROR_INSUFFICIENT_BUFFER until it gives up. Yeaaaaaaah, totally not a hack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091143">
				<div id="div-comment-1091143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091143">
			November 24, 2013 at 2:45 pm</a>		</div>

		<p>I&#39;m not saying that the &quot;provide your own buffer and hope it&#39;s big enough&quot; method isn&#39;t wonderful (it&#39;s not, and I&#39;d rather have the system create the buffer for me.) I was just trying to argue that compared with something like my example, having to create a hidden window to get dimensions for a dialogue box is not nearly as bad!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091153">
				<div id="div-comment-1091153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091153">
			November 24, 2013 at 4:35 pm</a>		</div>

		<p>@Joker_vD: There&#39;s no race condition or bug in any of those &quot;first ask for input size then call it again with that buffer&quot; functions. Assuming that you don&#39;t want to let the Kernel/library allocate memory for you (for a low-level API such as Win32 that makes sense to some degree although it complicates the interface naturally) there&#39;s not many ways around a loop to solve the problem (at least not if the kernel&#39;s involved, you can&#39;t it a function pointer and expect it to execute the code there after all). Low level but not ugly given the constraints. </p>
<p>Higher level libraries abstract all those details away anyhow and at least there are good reasons to do so. But using the same function to ask for the necessary buffer size and populating it? Ugly and unnecessary.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1091163">
				<div id="div-comment-1091163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091163">
			November 24, 2013 at 6:11 pm</a>		</div>

		<p>&quot;Doesn&#39;t this solution have concurrency issues when other processes create dialogs?&quot;</p>
<p>Yes, and this happens right now with different processes, so it&#39;s not really a big deal. &nbsp;It&#39;s no different than the process being swapped out after the window is created but before it is shown.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091173">
				<div id="div-comment-1091173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091173">
			November 24, 2013 at 8:45 pm</a>		</div>

		<p>@voo: The kernel knows the exact amount of memory it needs when a function is called. It can allocate the buffer and copy the needed data right there, in one pass. Instead we do two passes, and it does open a window to DoS attacks.</p>
<p>&quot;But using the same function to ask for the necessary buffer size and populating it? Ugly and unnecessary.&quot; â€” do you really propose doubling the amount of functions in public API? What would be the benefit? Okay, assume I have both DWORD GetTcpTableSize() and BOOL GetTcpTableData(PMIB_TCPTABLE pTcpTable, _In_ DWORD pdwSize, _In_ BOOL bOrder). So, if the GetTcpData fails, I would have to call GetTcpTableSize() again, because GetTcpTableData must not convey the needed size (that&#39;s the whole point of separation, otherwise GetXxxCount() is redundant), so I still do two function calls in normal scenario, but twice as many for a re-try. Where is the gain?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091303">
				<div id="div-comment-1091303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091303">
			November 25, 2013 at 11:09 am</a>		</div>

		<p>@Eric Brown: Who is going to free it? Either a) the kernel itself, for example the next time your the thread calls this function again; b) you when you&#39;re done with it. As for the &quot;from where&quot; question &mdash; oh, there are TONS of function just to allocate memory: GlobalAlloc, LocalAlloc, HeapAlloc, SysAllocSomething, pick yours.</p>
<p>Really, the question &quot;but who&#39;s gonna call CloseHandle on the returned handle?&quot; has pretty much the same nature yet somehow people manage to solve it.</p>
<div class="post">[<em>Heaps are in user mode. Kernel mode cannot allocate memory from user-mode heaps. Preallocation is the only possible way. <code>Close&shy;Handle</code> has exactly the same problem, and you solve it by making <code>HANDLE</code> a fixed size so that everybody knows exactly how much space to preallocate. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091333">
				<div id="div-comment-1091333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091333">
			November 25, 2013 at 11:13 am</a>		</div>

		<p>Maurits: The problem is that somebody could change the registry value between the two calls to RegQueryValueEx, causing even the second call to fail.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091393">
				<div id="div-comment-1091393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091393">
			November 25, 2013 at 3:30 pm</a>		</div>

		<p>@Joker_vD: Sure the kernel can allocate memory for you.. now the question is &#8211; where? Even the Win32 API had historically more than one heap, then there&#39;s malloc, new, if you use a higher level language it may want to do its own memory allocation and so on. Now if it&#39;s purely on the user side you could just pass a function pointer for allocation around, but clearly that&#39;s impossible if you call the Kernel. </p>
<p>Yes you do twice as many function calls in the generally exceedingly rare scenario where you have to retry &#8211; designing your APIs in such a way that they&#39;re a bit more efficient in some rare cornercases is the best way how you end up with horrible APIs. Go ahead and measure in some large program how often you actually have to retry, for the vast majority of functions I&#39;ll guarantee you that that will be exceedingly rare.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091273">
				<div id="div-comment-1091273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eric Brown</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091273">
			November 25, 2013 at 9:33 am</a>		</div>

		<p>@Joker_vD: &nbsp;And who, exactly, is going to *free* that memory that the API allocated? &nbsp;And *where* is that memory going to be allocated *from*? &nbsp;The kernel doesn&#39;t allocate user-mode memory, and kernel-mode memory isn&#39;t accessible from user-mode&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1091293">
				<div id="div-comment-1091293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091293">
			November 25, 2013 at 10:27 am</a>		</div>

		<p>@ErikF: You don&#39;t need more than two calls to RegQueryValueEx.</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724911(v=vs.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/ms724911(v=vs.85).aspx</a></p>
<p>If the buffer specified by lpData parameter is not large enough to hold the data, the function returns ERROR_MORE_DATA ***and stores the required buffer size in the variable pointed to by lpcbData***</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091443">
				<div id="div-comment-1091443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091443">
			November 25, 2013 at 11:19 pm</a>		</div>

		<p>@voo: &quot;Even the Win32 API had historically more than one heap, then there&#39;s malloc, new, if you use a higher level language it may want to do its own memory allocation and so on. Now if it&#39;s purely on the user side you could just pass a function pointer for allocation around, but clearly that&#39;s impossible if you call the Kernel.&quot;</p>
<p>Where? Somewhere, I don&#39;t quite care: all I want to do is to have read permission for this area of memory. Every language&#39;s runtime somehow has to cope with using memory it doesn&#39;t own, so it&#39;s not a huge problem that you can&#39;t pass your own &quot;malloc&quot; arounf. Also consider this scheme: the API returns you the pointer to the data AND the pointer to the function which you have to call on the data pointer when you&#39;re done with it. And the best thing is, you don&#39;t even need to return the second pointer &mdash; just write in the docs that &quot;The returned pointer must be freed with the call to LocalFree&quot;. FormatMessage follows this, though it&#39;s arguably the function which doesn&#39;t suffer from &quot;data may change their size between two calls&quot;.</p>
<p>Also, just yesterday evening I stumbled upon &quot;Identifying and Exploiting Windows Kernel Race Conditions via Memory Access Patterns&quot; by M. Jurczyk and G. Coldwind. Which tells me that I can trick the kernel into believing the buffer provided to it is bigger than it actually is, and exploit it to log keypresses or elevate rights. Hmmm.</p>
<div class="post">[<em>You&#39;re missing the fact that the implementation is in <span style="text-decoration:underline;">kernel mode</span>. Kernel mode cannot call a callback function in user mode to allocate user-mode memory. It&#39;s in the wrong mode. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091663">
				<div id="div-comment-1091663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091663">
			November 26, 2013 at 12:29 pm</a>		</div>

		<p>Damn. The KeUserModeCallback is a lie.</p>
<p>Speaking seriously, I really wish I knew the perfect solution. The kernel knows how much memory it will need, but it can&#39;t allocate it. The user can allocate memory, but doesn&#39;t know how much he has to. And when the kernel reports the size needed, that information, in general case, becomes stale immediately. Making two consecutive calls {GetDataSize();GetActualSize();} an atomic operation is prohibitively expensive, as I&#39;d imagine. What&#39;s the answer? I don&#39;t know it.</p>
<div class="post">[<em>It&#39;s not a lie, but it&#39;s not what you want either. You cannot hold any resources when issuing the callout because the callout may hang or raise an exception. So either way, it&#39;s a retry loop. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091693">
				<div id="div-comment-1091693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091693">
			November 26, 2013 at 4:49 pm</a>		</div>

		<p>In theory, the system could have been designed in such a way that kernel mode could ask user mode for memory. I believe this should in theory be possible in NT-based Windows, but I&#39;d be happy to be proven wrong.</p>
<p>Lacking that, the retry loop could have been hidden by the API. I&#39;ve seen a lot of code with potential bugs involving memory allocation for return data, so I think it would have been much better if Microsoft had implemented this the right way once and for all.</p>
<p>Regardless, from the perspective of an application developer these look the same. And remind us of IMalloc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091763">
				<div id="div-comment-1091763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sven2</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091763">
			November 27, 2013 at 5:09 am</a>		</div>

		<p>@Anonymous &quot;the retry loop could have been hidden by the API.&quot;:</p>
<p>At the moment, the user can pass a buffer that&#39;s usually big enough in the first try and just reallocating in the rare case data doesn&#39;t fit. That may be an important performance optimization in some cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091813">
				<div id="div-comment-1091813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091813">
			November 27, 2013 at 8:50 am</a>		</div>

		<p>All the kernel has to do is create a snapshot of the data in paged pool, then call out to your user-mode callback to allocate the memory, copy the data from the paged pool into the pointer returned from the callback, and free the paged pool allocation.</p>
<p>It&#39;s so simple it makes you wonder why all APIs aren&#39;t implemented that way!</p>
<p>Of course, you&#39;d still have to have the current mechanism that lets you get the data without memory allocation, an additional copy, and another kernel transition. Do you add a memory allocation callback function pointer to every call or do you create a separate version of each API that requires it?</p>
<p>Wait, that mechanism won&#39;t work if your data is too big for a paged pool allocation. In that case maybe the kernel should just map pages into your address space so you can do the allocation and copy yourself if need be, then call VirtualFree when you&#39;re done. But your address space may be taken up by your heap and there may not be enough contiguous addresses to allocate, in which case you&#39;d have to fallback to the heap allocation anyway.</p>
<p>Hmm&#8230;maybe it&#39;s not so simple afterall.</p>
<div class="post">[<em>And what if the user-mode callback raises an exception or calls <code>Exit&shy;Thread</code>? Yay! Kernel pool memory leak! -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091853">
				<div id="div-comment-1091853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091853">
			November 27, 2013 at 10:37 am</a>		</div>

		<p>&gt;That may be an important performance optimization in some cases.</p>
<p>I have yet to see them. But I&#39;ve seen many many sometimes subtle API return value allocation errors.</p>
<p>&gt;Yay! Kernel pool memory leak!</p>
<p>Exiting a thread will always land you back in kernel mode, and there is no reason to believe the kernel couldn&#39;t clean up after itself.</p>
<p>Alternatively, have the kernel ask for user mode memory.</p>
<div class="post">[<em>So there would be some per-thread list of &quot;memory I need to free if this thread is terminated&quot;, and anybody who allocates kernel memory and then calls another function that could possibly result in a callout to user mode code must add the memory to that list, then remove it from the list when the memory is freed. And that list can get arbitrarily long. (Consider a user callback that calls another kernel function that needs to allocate memory.) This is getting really complicated and fragile. (&quot;Oh, sorry, when I wrote function X and had it call function Y, I didn&#39;t realize that function Y calls function Z which calls function Q which calls function R which calls to user mode. That&#39;s why we have a memory leak that crashes your server after 14 days of uptime.&quot;) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1091903">
				<div id="div-comment-1091903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">What happened to CW_USEDEFAULT?</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091903">
			November 27, 2013 at 6:56 pm</a>		</div>

		<p>&gt; AllocateMemoryForKernelApi(size_t size) &#8230; woe unto you&#8230;</p>
<p>AllocateMemoryForKernelApi should take an LPVOID * parameter for the allocated buffer and instead return an error code. That way if your callback cannot satisfy the kernel&#39;s requested memory allocation size you can return an error (and maybe set the output parameter to nullptr if that&#39;s your thang). Then the kernel can retry your function in chunks with a smaller requested buffer size, or assume that you&#39;ve taken corrective action after the first call and retry with the (maybe same if nothing else changed) size, or just fail out.</p>
<div class="post">[<em>What if somebody fails to read that part of the documentation and raises an exception anyway? What if somebody writes an intentionally misbehaving AllocateMemoryForKernelApi function? What if somebody does a Sleep(INFINITE) inside AllocateMemoryForKernelApi? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1091873">
				<div id="div-comment-1091873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131122-00/?p=2593#comment-1091873">
			November 27, 2013 at 1:26 pm</a>		</div>

		<p>In order for that to be an issue, the main continuation of the thread would have to be the memory allocation callback, which means the return value of the original function is never used (and it is hence only called in order to initiate the callback). A rather contrived scenario since it assumes that the system would allow this in the first place (and that your stack is infinite and some other weirdities). It won&#39;t be a problem.</p>
<p>I still prefer my idea of allocating user memory though. It&#39;s simpler since you have less to take into account since any screw up will only affect the user process.</p>
<div class="post">[<em>I&#39;m referring to something like this:<br /> void *AllocateMemoryForKernelApi(size_t size) {<br /> &nbsp;if (logging_enabled) {<br /> &nbsp;&nbsp;auto logfile_name = RegQueryValueAlloc(hkey, AllocateMemoryForKernelApiNoLogging);<br /> &nbsp;&nbsp;blah blah;<br /> &nbsp;&nbsp;delete[] (char*)logfile_name;<br /> &nbsp;}<br /> &nbsp;return new char[size];<br />}<br /> Notice that while kernel is allocating memory, we call back into kernel to allocate more memory. So now you need to keep a list of &quot;all the memory temporarily allocated by kernel waiting to be copied back into user space&quot; just in case a stack overflow or bad_alloc occurs. Plus there&#39;s the difficulty of getting this right on the kernel side since you now cannot simply get the answer and copy it to the buffer, then release your locks. Now you have to get the answer, copy it to a temporary buffer, drop all locks, allocate memory from user space, copy the result, the free the temporary buffer. And woe unto you if you have to do this more than once in a single call. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

