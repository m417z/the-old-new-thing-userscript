<html>
<head>
<title>Why did Win32 define BOOL as a signed int instead of an unsigned int?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why did Win32 define BOOL as a signed int instead of an unsigned int?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 28, 2011 / year-entry #74</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>48</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Igor Levicki wants somebody from Microsoft to explain why BOOL was defined as a signed int instead of an unsigned int. You don't need to work for Microsoft to figure this out. All the information you need is publically available. Quoting from K&R Classic, which was the operative C standards document at the time Windows...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>Igor Levicki wants somebody from Microsoft to explain <a href="http://blogs.msdn.com/oldnewthing/archive/2008/11/26/9143050.aspx#9157501"> why <code>BOOL</code> was defined as a <code>signed int</code> instead of an <code>unsigned int</code></a>.</p>
<p> You don't need to work for Microsoft to figure this out. All the information you need is publically available. </p>
<p> Quoting from K&amp;R Classic, which was the operative C standards document at the time Windows was being developed: </p>
<blockquote class="q"><p> 7.6 Relational Operators </p>
<p> The [relational operators] all yield 0 if the specified relation is false and 1 if it is true. The type of the result is <code>int</code>. </p>
</blockquote>
<p> Win32 defined <code>BOOL</code> as synonymous with <code>int</code> because Brian and Dennis said so. If you want to know why Brian and Dennis decided to have the result of relational operators be signed instead of unsigned, you'll have to ask them. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (48)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-903713">
				<div id="div-comment-903713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903713">
			March 28, 2011 at 7:07 am</a>		</div>

		<p>&quot;You don&#39;t need to work for Microsoft to figure this out. All the information you need is publically available.&quot; Well, except for the information on why it was important for BOOL to be the same type as relational operators return. C++ (and for that matter, C99 with its _Bool type) didn&#39;t make the same decision in the same situation.</p>
<div class="post">[<i>I thought the reason was obvious. You want to be able to say &quot;return a == b;&quot; and not &quot;return (BOOL)(a == b);&quot;. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903723">
				<div id="div-comment-903723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903723">
			March 28, 2011 at 7:16 am</a>		</div>

		<p>&quot;why it was important for BOOL to be the same type as relational operators return&quot; is outside the scope of this discussion. &nbsp;It was defined that way in the standard and Microsoft followed the standard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903733">
				<div id="div-comment-903733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MikMik</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903733">
			March 28, 2011 at 7:17 am</a>		</div>

		<p>And then we have things like functions declared as BOOL that return 0 if false and any other thing (not only 1) if true, e.g. ::IsPathDirectory, which returns 16 if the path is a directory (though the docs say, or said, it returns TRUE).</p>
<p>It would have been the same with unsigned int, but if the reason is they were following the standards, they could have followed them not only with type declarations, but also with how functions work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903743">
				<div id="div-comment-903743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903743">
			March 28, 2011 at 7:25 am</a>		</div>

		<p>random832 said: &quot;why it was important for BOOL to be the same type as relational operators return&quot;</p>
<p>Because if they weren&#39;t the same you would have two boolean types, &quot;Windows booleans&quot; and &quot;C booleans&quot;, which would have been very confusing.</p>
<p>@MikMik: returning zero/non-zero (as opposed to 0/1) is consistent with the C standard library (e.g. the isdigit function).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903753">
				<div id="div-comment-903753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joel Dillon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903753">
			March 28, 2011 at 7:31 am</a>		</div>

		<p>I might be misremembering, but I don&#39;t think K&amp;R specified whether int was signed or unsigned &#8211; it could be either (much as char can be signed or unsigned). Otherwise the &#39;signed&#39; keyword would be a bit of a waste. So technically Microsoft did decide that BOOL was signed because they decided that int was signed; not that that makes their decision invalid.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903763">
				<div id="div-comment-903763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903763">
			March 28, 2011 at 7:32 am</a>		</div>

		<p>@laonianren: Oh there&#39;s more than two boolean types <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/12/22/329884.aspx" rel="nofollow">blogs.msdn.com/&#8230;/329884.aspx</a> .</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903773">
				<div id="div-comment-903773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903773">
			March 28, 2011 at 7:36 am</a>		</div>

		<p>&quot;&quot;why it was important for BOOL to be the same type as relational operators return&quot; is outside the scope of this discussion. &nbsp;It was defined that way in the standard and Microsoft followed the standard.&quot;</p>
<p>It&#39;s not only <em>not outside</em> the scope of this discussion, it is the <em>entire</em> scope of this discussion. The standard says <em>nothing</em> about &quot;BOOL&quot;. It only says that relational operators return int. BOOL could still be an unsigned type <em>not returned by relational operators</em> and follow the standard. That was my point. Both C++ and C99 made similarly named types [bool and _Bool respectively] which are not int, so it&#39;s not like it would only be Microsoft doing that [they might not even be the first, depending on the timing of C++]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903783">
				<div id="div-comment-903783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903783">
			March 28, 2011 at 7:41 am</a>		</div>

		<p>@Joel Dillon:</p>
<p>&#39;int&#39; is always the same as &#39;signed int&#39;. Period. It&#39;s not implementation specific, or a matter of choice otherwise. Unlike &#39;char&#39;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903793">
				<div id="div-comment-903793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henning Makholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903793">
			March 28, 2011 at 7:42 am</a>		</div>

		<p>Joel Dillon: You&#39;re misremembering. It has never been possible for plain int to be unsigned; too many core C library functions use negative values as exceptional return values.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903813">
				<div id="div-comment-903813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">S</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903813">
			March 28, 2011 at 7:47 am</a>		</div>

		<p>@Random832</p>
<p>But C99 and C++ also changed the type that relational operators return. C++ changed it to bool, I don&#39;t know what C99 does because I don&#39;t know anything about it. Microsoft didn&#39;t have that luxury because they weren&#39;t redefining the language, so if they wanted BOOL to be interchangeable with relational operators they had to use int. C99 and C++ didn&#39;t exist, or at least weren&#39;t standardised, at the time this decision was made.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903803">
				<div id="div-comment-903803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903803">
			March 28, 2011 at 7:47 am</a>		</div>

		<p>Random832: &quot;Both C++ and C99 made similarly named types [bool and _Bool respectively] which are not int, so it&#39;s not like it would only be Microsoft doing that [they might not even be the first, depending on the timing of C++]&quot;</p>
<p>Except Microsoft isn&#39;t creating a new language in this case or changing what the relational operators return. &nbsp;If you had this function:</p>
<p>BOOL AreEqual(int x, int y) { return x == y; }</p>
<p>You don&#39;t want the compiler to give you a spurious warning about converting a signed integer to an unsigned integer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903833">
				<div id="div-comment-903833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903833">
			March 28, 2011 at 8:02 am</a>		</div>

		<p>And we can be happy about that. The more int and the less uint we use, the safer the code becomes. The advantage of using uints for array length pales to the problems that happen when you write &quot;if (array.length -n &gt; m)&quot; and fail to realize that in case of uints, this will often result in suboptimal results. I am using an in-house library which does it, and it&#39;s annoying.</p>
<p>I am sure people can come up with more issues that happen when you accidentally use uints, but there are few that happen when you accidentally use signed ints instead of uints.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903843">
				<div id="div-comment-903843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/chris_4000_chrismillward.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>chris@chrismillward.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903843">
			March 28, 2011 at 8:08 am</a>		</div>

		<p>Surely it&#39;s a simple as a 16-bit (at the time) int being the most-regularly used type (and closet to register size), and sign is irrelevant since the machine code produce is just a compare to 0, so any bit set will produce the right result. Since there was no special reason to make it something other than the most common primitive type, they didn&#39;t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903853">
				<div id="div-comment-903853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/chris_4000_chrismillward.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>chris@chrismillward.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903853">
			March 28, 2011 at 8:11 am</a>		</div>

		<p>I was talking about K+R more than Win32 btw.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903863">
				<div id="div-comment-903863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">S</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903863">
			March 28, 2011 at 8:12 am</a>		</div>

		<p>@K</p>
<p>The counter example here is for BOOL, if someone decides to &quot;optimize&quot; a BOOL by turning it into &quot;BOOL fSomething : 1&quot; signed makes it less safe. This is because fSomething can only have the values FALSE and -1 (assuming 2&#39;s complement), it is not possible for it to be TRUE. So if somewhere in the code you have if (fSomething == TRUE), signed numbers just made your life more difficult.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903873">
				<div id="div-comment-903873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JS Bangs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903873">
			March 28, 2011 at 8:26 am</a>		</div>

		<p>@s, anybody writing if (fSomething == TRUE) rather than just if (fSomething) needs to be beaten with a cluebat.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903883">
				<div id="div-comment-903883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JS Bangs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903883">
			March 28, 2011 at 8:26 am</a>		</div>

		<p>@s, anybody writing if (fSomething == TRUE) rather than just if (fSomething) needs to be beaten with a cluebat.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903893">
				<div id="div-comment-903893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903893">
			March 28, 2011 at 8:30 am</a>		</div>

		<p>&quot;but there are few that happen when you accidentally use signed ints instead of uints.&quot;</p>
<p>Don&#39;t worry, C has plenty of undefined behavior to go around. See <a rel="nofollow" target="_new" href="http://blog.regehr.org/archives/226" rel="nofollow">blog.regehr.org/&#8230;/226</a> for all sorts of fun examples of things going wrong when you use signed types instead of unsigned types. Problems with undefined signed operations not doing what you want can be much more pernicious than problems with unsigned types &#8212; at least there the behavior is defined, if unwanted.</p>
<p>@S:</p>
<p>That&#39;s a problem with how you define and use TRUE, not signedness. Writing &quot;if (fSomething == TRUE)&quot; is just wrong if you intend to mimick boolean semantics. In C, any nonzero value is true, so any comparison with a particular value standing in for true is wrong. In that respect, it doesn&#39;t matter how you define TRUE &#8212; as long as you&#39;re not perverse and define it to be 0. Alternatively, if you decide the test is correct, then the &quot;optimization&quot; is wrong &#8212; it should have used &quot;TRUE&quot;, not &quot;1&quot;, as the only legal values for BOOL would be TRUE and FALSE, not arbitrary integers. (MSDN helpfully says the values of BOOL &quot;should&quot; be &quot;TRUE&quot; and &quot;FALSE&quot; only, but of course you&#39;d be very foolish to count on this as a consumer.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903903">
				<div id="div-comment-903903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrkMatter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903903">
			March 28, 2011 at 8:30 am</a>		</div>

		<p>Asides from considerations of compiler warnings, isn&#39;t this whole discussion moot, considering you&#39;re not supposed to do anything with a boolean type except compare it for equality with 0?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903913">
				<div id="div-comment-903913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903913">
			March 28, 2011 at 8:32 am</a>		</div>

		<p>@S:</p>
<p>I&#39;m appalled that none of the three compliers I tried (VS 2008 with /W4, GCC with -W -Wall, and Comeau&#39;s online front end with -a -r) warns about that, because the reality is even worse than what you say: the only value that the standard guarantees &#39;fSomething&#39; can hold in that example is 0. You can&#39;t even rely on -1 without being technically non-portable.</p>
<p>Furthermore, if I add an actual comparison to 1, only GCC warns about it, and only with the -W flag.</p>
<p>struct Foo {</p>
<p>&nbsp;int field : 1;</p>
<p>};</p>
<p>void fun() {</p>
<p>&nbsp;Foo f;</p>
<p>&nbsp;if (f.field == 1); &nbsp; &nbsp;// gcc says &quot;comparison is always false due to limited range of data type&quot;</p>
<p>}</p>
<p>It&#39;s a pity MSVC doesn&#39;t give more diagonstics on that one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903923">
				<div id="div-comment-903923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">S</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903923">
			March 28, 2011 at 8:35 am</a>		</div>

		<p>@JM, @JS Bangs</p>
<p>Sure &#8211; I know that, and you know that. The problem is that not everyone knows that and it is hard to find those tests in a large code base. I wasn&#39;t in anyway suggesting that either the &quot;optimization&quot; or the test were correct, but that they were a possible failure mode of signed integers that I have seen in code I didn&#39;t write.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903933">
				<div id="div-comment-903933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903933">
			March 28, 2011 at 9:39 am</a>		</div>

		<p>@K:</p>
<p>Using signed integers for length can be a source of subtle security problems.</p>
<p>// This came from the network</p>
<p>struct mypacket {</p>
<p>&nbsp;int length;</p>
<p>&nbsp;char stuff[42];</p>
<p>};</p>
<p>void myfunction(struct mypacket *pkt)</p>
<p>{</p>
<p>&nbsp;char buf[42];</p>
<p>&nbsp;if (pkt-&gt;length &gt; 42)</p>
<p>&nbsp; &nbsp;return;</p>
<p>&nbsp;memcpy(buf, pkt-&gt;stuff, pkt-&gt;length);</p>
<p>&nbsp;// &#8230;</p>
<p>}</p>
<p>Looks good, right? We are testing that the length is not bigger than the destination buffer. Now, think about what happens if the length is NEGATIVE&#8230;</p>
<p>If you are using signed integers, you ALWAYS have to check for both less than zero and greater than the maximum length. If you are using unsigned integers, due to the way two&#39;s complement works, the test for &quot;less than zero&quot; is implicit within any test for &quot;greater than the maximum length&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903943">
				<div id="div-comment-903943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903943">
			March 28, 2011 at 10:02 am</a>		</div>

		<p>-1 is actually a quite common value for TRUE among the various other languages over the years, many of which do/did not differentiate between logical and bitwise boolean operations (using bitwise for both!)</p>
<p>The justification is simple, beautiful, and powerful:</p>
<p>TRUE should equal NOT FALSE</p>
<p>Thus if FALSE is the signed integer 0, then TRUE is by definition -1.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903953">
				<div id="div-comment-903953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arlie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903953">
			March 28, 2011 at 10:19 am</a>		</div>

		<p>&quot;@s, anybody writing if (fSomething == TRUE) rather than just if (fSomething) needs to be beaten with a cluebat.&quot;</p>
<p>If you saw exactly that code, you might think the author was an idiot. &nbsp;But that exact situation comes up, legitimately, in the real world. &nbsp;Consider this:</p>
<p>// in header file foo.h</p>
<p>#define OPTION_FOO_IS_ENABLED TRUE</p>
<p>// in source file bar.c</p>
<p>if (fSomething == OPTION_FOO_IS_ENABLED) { &#8230; }</p>
<p>That code looks much more reasonable, even though it suffers from the same problem. &nbsp;To eliminate the possibility of ambiguous boolean comparisons, you would have to do something like this:</p>
<p>// in source file bar.c</p>
<p>if (OPTION_FOO_IS_ENABLED ? (fSomething) : (!fSomething)) { &#8230; }</p>
<p>Which just looks bizarre. &nbsp;I&#39;ve also seen it done this way:</p>
<p>if (!!OPTION_FOO_IS_ENABLED == !!fSomething) { &#8230; }</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903963">
				<div id="div-comment-903963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeremy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903963">
			March 28, 2011 at 10:38 am</a>		</div>

		<p>I&#39;ve come across some pretty bizarre code that looks like this:</p>
<p>BOOL MyPathFileExists(const MyStringType &amp; pth)</p>
<p>{</p>
<p>&nbsp; &nbsp;return !!PathFileExists(pth.c_string());</p>
<p>}</p>
<p>At one time, that double-not idiom was pretty common in our codebase. &nbsp;Presumably because someone liked explicit comparisons with TRUE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903973">
				<div id="div-comment-903973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903973">
			March 28, 2011 at 11:33 am</a>		</div>

		<p>@Arlie:</p>
<p>Your code examples are so bad, that I don&#39;t know where to start.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-903983">
				<div id="div-comment-903983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903983">
			March 28, 2011 at 3:15 pm</a>		</div>

		<blockquote><p>
  anybody writing if (fSomething == TRUE) rather than just if (fSomething) needs to be beaten with a cluebat.
</p></blockquote>
<p>Unless of course they write</p>
<p>&nbsp; if (((fSomething == TRUE) == TRUE) == TRUE)</p>
<p>in which case they can be commended for wit and sarcasm.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-903993">
				<div id="div-comment-903993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Burak KALAYCI</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-903993">
			March 28, 2011 at 4:48 pm</a>		</div>

		<p>&gt; Win32 defined BOOL as synonymous with int because Brian and Dennis said so.</p>
<p>This makes sense only if you implicitly accept that using C was the only choice for Win32 at the time. Did Brian and Dennis also told Microsoft to write Win32 (or Win16) using C?</p>
<p>More importantly, if this is the real answer to Igor&#39;s question, then how will you be able to justify any Microsoft act that does not conform to standards?</p>
<div class="post">[<i>&quot;Because Brian and Dennis said so, and there was no compelling reason to disagree with them.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-904003">
				<div id="div-comment-904003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904003">
			March 28, 2011 at 6:50 pm</a>		</div>

		<p>@Burak: At that time, most of the compilers has support to link libraries using C calling convention, making code generation routine align with C standard can reduce overhead of these calls. (These were the days when reducing execution cycle consumptions does matters. Although BOOL defination certainly isn&#39;t part of the convertion, having everyone agrees on this makes function calls simpler.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904013">
				<div id="div-comment-904013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Toddsa</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904013">
			March 28, 2011 at 8:01 pm</a>		</div>

		<p>It is kind of funny how people disagree and argue so adamantly with even innocuous implementations of code. In reality most implementations are because that is how the developer at the time designed it and most designs are not done by a community, nor should they be.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-904023">
				<div id="div-comment-904023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904023">
			March 29, 2011 at 12:22 am</a>		</div>

		<p>Cheong: Win16 functions all used PASCAL calling convention (to save a cycle or two on every call maybe?), with the exception of variadic functions that are only possible with the C calling convention.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904053">
				<div id="div-comment-904053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904053">
			March 29, 2011 at 5:02 am</a>		</div>

		<p>A C enum with TRUE and FALSE would solve the fTrueVar!=TRUE problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-leo-davidson even thread-even depth-1" id="comment-904063">
				<div id="div-comment-904063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Leo+Davidson' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904063">
			March 29, 2011 at 5:21 am</a>		</div>

		<p>@640k:</p>
<p>I&#39;m not sure that would have solved anything as I don&#39;t think C even shows a warning if you assign a random int to an enum type. This compiles fine in a .c file (and C++ is not relevant as it did not exist back then, but even if it did you would introduce the need to cast every comparison function to your enum in that case):</p>
<p>typedef enum</p>
<p>{</p>
<pre><code>MYFALSE,

MYTRUE
</code></pre>
<p>} MYBOOL;</p>
<p>MYBOOL test()</p>
<p>{</p>
<pre><code>return 42;
</code></pre>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904073">
				<div id="div-comment-904073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904073">
			March 29, 2011 at 5:54 am</a>		</div>

		<p>Half the world doesn&#39;t understand boolean testing anyway, the number of times I see this in code:</p>
<p>&nbsp;BOOL booleanValue;</p>
<p>&nbsp;char *pointer;</p>
<p>&nbsp;if (booleanValue == FALSE)</p>
<p>&nbsp;if (!pointer)</p>
<p>which ought to be</p>
<p>&nbsp;if (!booleanValue)</p>
<p>&nbsp;if (pointer == NULL)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-904083">
				<div id="div-comment-904083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904083">
			March 29, 2011 at 6:21 am</a>		</div>

		<p>re:</p>
<p>if (!pointer)</p>
<p>&quot;should be&quot;</p>
<p>if (pointer == NULL)</p>
<p>Half the world doesn&#39;t understand language specification anyway. &nbsp;Just because you think the programmer should manually convert his pointer operand to bool, rather than letting the compiler do it, it doesn&#39;t follow that the rest of us agree.</p>
<p>Confession: I don&#39;t have any relevant C spec to hand, so I&#39;m relying on the C++ spec being similar, but it may not be: but ISO/IEC 14882:2003(E) says, in section 5.3.1 paragraph 8, &quot;the operand of the logical negation operator ! is implictly converted to bool&quot;.</p>
<p>The goal of &#39;style&#39; is surely to write in a way that is clear to readers; I find it difficult to believe that there&#39;s a competent C programmer who does not understand the &#39;if (!pointer)&#39; idiom.</p>
<p>Me, I like appropriately-terse coding. &nbsp;Don&#39;t be long-winded for no good reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn odd alt thread-odd thread-alt depth-1" id="comment-904093">
				<div id="div-comment-904093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904093">
			March 29, 2011 at 6:32 am</a>		</div>

		<p>@Burak: for languages other than C the question of signed/unsigned is, generally speaking, irrelevant. This strengthens the point of BOOL actually spaning two values : FALSE or not FALSE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-904143">
				<div id="div-comment-904143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rich the Engineer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904143">
			March 29, 2011 at 7:49 am</a>		</div>

		<p>My goodness, all this commotion over a two-valued construct. &nbsp;Good thing we didn&#39;t start with ternary logic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904173">
				<div id="div-comment-904173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">!bool</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904173">
			March 29, 2011 at 9:08 am</a>		</div>

		<p>@Rich: That&#39;s what nullable bool is for :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-904193">
				<div id="div-comment-904193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904193">
			March 29, 2011 at 9:45 am</a>		</div>

		<p>@Joseph Koss:</p>
<p>IIRC, C (and C++) does not define the evaluation order for parameters. The compiler is free to evaluate them in any order it wants (which might not be neither left-to-right nor right-to-left).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904203">
				<div id="div-comment-904203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904203">
			March 29, 2011 at 9:57 am</a>		</div>

		<p>From the C++ standard, 4.12 Boolean conversions [conv.bool]:</p>
<p>&quot;A zero value, null pointer value, or null member pointer value is converted to false any other value is converted to true.&quot;</p>
<p>From C standard, 6.5.3.3 Unary arithmetic operators</p>
<p>&quot;The expression !E is equivalent to (0==E).&quot;</p>
<p>That means to me that both &quot;if ( ptr )&quot; and &quot;if ( !ptr )&quot; are valid idioms in C and C++.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-904033">
				<div id="div-comment-904033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904033">
			March 29, 2011 at 3:10 am</a>		</div>

		<p>@Toddsa: It&#39;s the bike shed problem. Everyone knows how to build a bike shed (or at least can reasonably conceive of how to build one) and therefore, if you&#39;re looking for approval to build one, there are endless arguments about the fine details.</p>
<p>Something much more complicated is often easier to get past approvals because the board approving it usually *doesn&#39;t* know what you&#39;re talking about.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904043">
				<div id="div-comment-904043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904043">
			March 29, 2011 at 3:52 am</a>		</div>

		<p>@Gabe:</p>
<p>Win16 used PASCAL to save 3 bytes per call (see Raymond Chen&#39;s link below.)</p>
<p>Win32 of course uses STDCALL, often referred to as &quot;a hybrid of CDECL and PASCAL&quot; but not widely known is that its essentially the BASIC (as defined by early MASM and BASCOM) calling convention renamed. It is the same as PASCAL except that, like the CDECL convention (*), the parameters are pushed right to left instead of left to right.</p>
<p>Callee-cleanup really is the way to go. In addition to its space savings, its much safer from a debugging standpoint (CDECL has an annoying habit of &quot;hiding&quot; bugs where an incorrect number of parameters is passed to a function.) Sure, there are times when you really do need something like CDECL (printf) but with function overloading and stream operators that has thankfully become the exception and certainly no longer the rule.</p>
<p><a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/02/47184.aspx" rel="nofollow">blogs.msdn.com/&#8230;/47184.aspx</a></p>
<p>(*) I&#39;m not sure why right to left is considered a good idea given that nearly all languages define evaluation order of parameters as occurring left to right. This method does put the first parameter lowest in memory on x86 (the stack grows downwards) but that hardly seems important enough to justify it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-904263">
				<div id="div-comment-904263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904263">
			March 29, 2011 at 3:13 pm</a>		</div>

		<p>&quot;Sometimes I think I must be the only C (really, C++) guy out there who actually may prefer that to &quot;if (!booleanValue)&quot;.&quot;</p>
<p>You are not alone.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904163">
				<div id="div-comment-904163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Grier [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904163">
			March 29, 2011 at 9:03 am</a>		</div>

		<p>Re: !! to canonicalize Boolean values:</p>
<p>return !!PathFileExists(pth.c_string());</p>
<p>The problem with not having the !! is that while the *intent* of a BOOL returning function is clear, in practice, the PathFileExists() function may return an arbitrary value for &quot;TRUE&quot;, perhaps indicating the kind of path if it is found to exist.</p>
<p>If you don&#39;t canonicalize the value you return, returning whatever PathFileExists() happens to return becomes part of your API contract instead of TRUE vs. FALSE.</p>
<p>If your software is unpopular and unsuccessful, it doesn&#39;t matter and you saved a few milliseconds avoiding typing the !!. &nbsp;However if you are blessed with becoming popular and successful, you&#39;re stuck supporting the old behavior. &nbsp;Forever.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-904213">
				<div id="div-comment-904213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904213">
			March 29, 2011 at 10:30 am</a>		</div>

		<p>@D: &quot;Half the world doesn&#39;t understand boolean testing anyway, the number of times I see this in code: if (booleanValue == FALSE)&quot;</p>
<p>Sometimes I think I must be the only C (really, C++) guy out there who actually may prefer that to &quot;if (!booleanValue)&quot;. I think part of the reason is it can be relatively easy to miss the ! if you&#39;re just scanning over the code. (I also like &#39;if (ptr == NULL)&#39;, probably for a similar reason. Abbreviating that to &#39;if (ptr)&#39; I feel is exactly the *wrong* kind of terseness to strive for.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904283">
				<div id="div-comment-904283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904283">
			March 29, 2011 at 5:50 pm</a>		</div>

		<p>@Gabe: I know, but just recall that when they first developed Windows, most of the parts are written in C and assembly language.</p>
<p>It just make sense to follow the convention of the programming tools you use, especially since there weren&#39;t any QC process you have today. Using only ONE defination of boolean can significantly reduce possibility of introducing bugs than having to take care of checking and conversion. (Remenber, that&#39;s the time when compilers can have bugs. If you were given the choice to choose from (even if subconsciously), you&#39;ll want to make the rules as simple as it should be.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-904323">
				<div id="div-comment-904323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fred</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904323">
			March 30, 2011 at 3:50 am</a>		</div>

		<p>@Joseph: &quot;nearly all languages define evaluation order of parameters as occurring left to right&quot;&#8230; well, neither C nor C++ define that. &nbsp;In C and C++, the evaluation order of parameters is undefined. &nbsp;Compilers can and do evaluate them in any order, and enabling optimization can change the order.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-904383">
				<div id="div-comment-904383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110328-00/?p=11113#comment-904383">
			March 30, 2011 at 10:20 am</a>		</div>

		<p>@MikMik</p>
<p>I was a bit puzzled at why it returned 16, then it dawned on me that FILE_ATTRIBUTE_DIRECTORY is 0x10. &nbsp;So it&#39;s probably returning (dwAttributes &amp; 0x10) and someone thought it was good enough to not have to add ? TRUE : FALSE after that.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

