<html>
<head>
<title>Why was MoveTo replaced with MoveToEx?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why was MoveTo replaced with MoveToEx?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 20, 2009 / year-entry #222</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>42</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Commenter Ulric asks, "Where did MoveTo(HDC, int, int) go?" Back in the 16-bit days, the function to move the current point was called MoveTo, and its return value was a DWORD which encoded the previous position, packing two 16-bit coordinates into a single 32-bit value. As part of the transition to 32-bit Windows, GDI switched...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Commenter Ulric asks,
"<a HREF="http://blogs.msdn.com/oldnewthing/pages/407234.aspx#619634"
>Where did MoveTo(HDC, int, int) go?</a>"
</p>
<p>
Back in the 16-bit days, the function to move the current point
was called <code>MoveTo</code>,
and its return value was a <code>DWORD</code> which encoded the
previous position,
packing two 16-bit coordinates into a single 32-bit value.
As part of the transition to 32-bit Windows,
GDI switched to using 32-bit coordinates instead of the
wimpy 16-bit coordinates of old.
As a result, it was no longer possible to encode the original
position in a single <code>DWORD</code>.
Something new had to be developed.
</p>
<p>
That new thing was the <code>MoveToEx</code> function.
Instead of returning a single <code>DWORD</code>,
it accepted a final parameter which
received the previous coordinates.
If you didn't care about the previous coordinates,
you could just pass <code>NULL</code>.
All of the GDI functions which used to pack two 16-bit coordinates
into a single <code>DWORD</code>
got <code>Ex</code>-ified in this way so they could accommodate
the new 32-bit coordinate system.
</p>
<p>
But why did the old <code>MoveTo</cODE> function go away?
Why not keep it around for source code compatibility?
</p>
<p>
I find this an interesting question,
since most people seem to think that maintaining source code
compability between the 32-bit and 64-bit versions of Windows
was an idea whose
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2005/01/31/363790.aspx">
stupidity</a>
rivals
prosecuting a land war in Asia.
(If we had followed this advice,
people would just be asking,
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2008/12/08/9182990.aspx#9191060">
why did you replace <code>WinExec</code> with the much harder-to-use
<code>CreateProcess</code></a>?)
By the same logic, source code compatibility between 16-bit and 32-bit
Windows is equally absurd.
According to these people,
porting 16-bit code to
to 32-bit Windows is the <i>best time</i> to introduce
these sorts of incompatibilities,
in order to force people to rewrite their programs.
</p>
<p>
Anyway, the reason we lost <code>MoveTo</code> was that there
was no way to return 64&nbsp;bits of information in a 32-bit integer.
Now it's true that in many cases, the caller doesn't actually care
about the previous position,
but of course the <code>MoveTo</code> function doesn't know that.
It returns a value; it doesn't know whether the caller is going to
use that return value or not.
</p>
<p>
I guess one way out would have been to change the return value of
<code>MoveTo</code> to <code>void</code>.
That way, people who didn't care about the return value would still
compile, while people who did try to use the return value
would get a compile error and have to switch to <code>MoveToEx</code>.
</p>
<p>
Yeah, I guess that could've been done,
but you could also have done that yourself:
</p>
<pre>
#define MoveTo(hdc, x, y) ((void)MoveToEx(hdc, x, y, NULL))
</pre>
<p>
I find it interesting that most people who write their own
<code>MoveTo</code> macro don't use the <code>(void)</code> cast.
In most cases, this is a mistake in porting from 16-bit Windows.
(I can tell because the macro is mixed in with a bunch of other
porting macros.)
However, in other cases, it could be intentional.
The authors of the macro may simply not have known about the old
16-bit days and simply expected their macro to be used as if it
were prototyped as
<code>BOOL MoveTo(HDC, int, int)</code>.
</p>
<p>
These people will probably be baffled if they run across any
actual 16-bit Windows code that tried to extract the high word
from the return value of <code>MoveTo</code>.
"Why are you extracting the high word from a <code>BOOL</code>?"
</p>
<p>
<b>Historical exercise</b>:
Instead of adding a new parameter, why not just make
<code>MoveToEx</code> return an <code>__int64</code>?</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-755823">
				<div id="div-comment-755823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://adamrosenfield.com' rel='external nofollow' class='url'>Adam Rosenfield</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755823">
			July 20, 2009 at 10:06 am</a>		</div>

		<p>I&#8217;m guessing the 16-bit ABI didn&#8217;t specify how 64-bit values are returned, or something like that?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755833">
				<div id="div-comment-755833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">s</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755833">
			July 20, 2009 at 10:21 am</a>		</div>

		<p>I assume there couldn&#8217;t be a 64bit return value because at the time compiler support for 64bit values was patchy &#8211; hence ULARGE_INTEGER and FILETIME</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755843">
				<div id="div-comment-755843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755843">
			July 20, 2009 at 10:49 am</a>		</div>

		<p>Even if the compiler supported a 64-bit integer type, it wouldn&#8217;t be feasible because code that did MoveTo(x, y) &gt;&gt; 16 would be wrong. Not only would it be wrong, but it would still compile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755853">
				<div id="div-comment-755853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755853">
			July 20, 2009 at 11:42 am</a>		</div>

		<p>The function could return 64-bit value as POINT structure. This would not have much runtime overhead because this would be returned as EAX:EDX.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755863">
				<div id="div-comment-755863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DriverDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755863">
			July 20, 2009 at 12:49 pm</a>		</div>

		<p>&quot;Instead of adding a new parameter, why not just make MoveToEx return an __int64?&quot;</p>
<p>Because packing two descrete values into an integer, in the days of a multi-MB OS, is just lame. And it&#8217;s just asking for people to make careless mistakes.</p>
<p>C has data structures and pointers &#8211; use them!</p>
<p>I&#8217;m glad the Win32 folks did&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dwalker-wk odd alt thread-odd thread-alt depth-1" id="comment-755873">
				<div id="div-comment-755873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755873">
			July 20, 2009 at 1:20 pm</a>		</div>

		<p>@Alexandre Grigoriev: The 64-bit value is not a pointer, so it should not be returned as a POINT structure. &nbsp;That&#8217;s asking for trouble.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755883">
				<div id="div-comment-755883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755883">
			July 20, 2009 at 1:34 pm</a>		</div>

		<p>@DWalker59,</p>
<p>I don&#8217;t quite understand your objection. Are you saying that:</p>
<p>POINT MoveTo2(HDC hdc, int x, int y);</p>
<p>is not an acceptable function declaration?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755893">
				<div id="div-comment-755893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755893">
			July 20, 2009 at 2:07 pm</a>		</div>

		<blockquote><p>
  most people seem to think that maintaining source code compability between the 32-bit and 64-bit versions of Windows was an idea whose stupidity rivals prosecuting a land war in Asia.
</p></blockquote>
<p>I don&#8217;t know about &quot;most&quot;, it is often the disagreeing side which is the most vocal, since the agreeing side, well, has &#8216;won&#8217; and doesn&#8217;t feel so strongly about the situation.</p>
<p>Anyway, indeed backward compatibility is a very dividing subject and your blog sure helps grasping the many aspects of it. It should eventually tame the epidermic reactions to the subject.</p>
<p>So, thanks Raymond!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755903">
				<div id="div-comment-755903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755903">
			July 20, 2009 at 2:28 pm</a>		</div>

		<blockquote><p>
  &gt; POINT MoveTo2(HDC hdc, int x, int y);
</p></blockquote>
<ol>
<li>
<p>How about &quot;MoveTwo&quot; as a replacement name?</p>
</li>
<li>
<p>__int64 cannot be passed as an LPARAM or LRESULT in Win32 unlike DWORD. Win64 is a different story.</p>
</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755913">
				<div id="div-comment-755913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755913">
			July 20, 2009 at 2:50 pm</a>		</div>

		<p>@porter,</p>
<p>Any changes in API should:</p>
<ol>
<li>NOT break code that doesn&#8217;t need changes.</li>
<li>
<p>BREAK code (make it not compile) that needs changes.</p>
</li>
</ol>
<p>Changing MoveTo return type to POINT would achieve that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755923">
				<div id="div-comment-755923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755923">
			July 20, 2009 at 3:31 pm</a>		</div>

		<p>Of course it would be possible to assume that the few users of MoveTo that were using the return value were not using coordinates outside the range that 16-bit numbers could represent. Afterall, if the 16-bit version of the program didn&#8217;t use large coordinate values, why would the 32-bit version?</p>
<p>But then you have the danger of somebody using MoveTo in a 32-bit program that does use large coordinate values, only to get the MSW of each coordinate chopped off. They would have the same problem as most users of GetFileSize do now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755933">
				<div id="div-comment-755933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755933">
			July 20, 2009 at 4:56 pm</a>		</div>

		<p>16 bits ought to be enough for anybody.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755943">
				<div id="div-comment-755943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.henning.makholm.net/' rel='external nofollow' class='url'>Henning Makholm</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755943">
			July 20, 2009 at 7:15 pm</a>		</div>

		<p>&quot;16 bits ought to be enough for anybody.&quot;</p>
<p>Not if you&#8217;re printing on A3 paper with MM_HIMETRIC coordinates. Or, for that matter, MM_TEXT and a 2400 dpi device.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755963">
				<div id="div-comment-755963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://lahosken.san-francisco.ca.us/' rel='external nofollow' class='url'>Larry Hosken</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755963">
			July 20, 2009 at 8:42 pm</a>		</div>

		<p>Future compatability with fuzzy logic? Extracting the low word would be silly, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755973">
				<div id="div-comment-755973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://rosettacode.org/wiki/User:Short_Circuit' rel='external nofollow' class='url'>Michael Mol</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755973">
			July 20, 2009 at 10:56 pm</a>		</div>

		<p>My three guesses:</p>
<ol>
<li>
<p>We may eventually want device contexts with sufficiently high DPIs to require positional values greater than 32 bits will hold. &nbsp;However, for a 30 yard printed banner, that would require a dpi value itself approaching the limits of a 32-bit field; You would need a microscope to see the individual dots. &nbsp;A Mercator projection of the Earth&#8217;s surface would only require a horizontal resolution of about 1.5 billion pixels for 1dpi, but 2.72 dpi bumps it up against the 32-bit limit. &nbsp;You get 1 dpi at that limit if you go to an altitude of about 10,000 km. (radius * 2.7 &#8211; radius)</p>
</li>
<li>
<p>__int64 is a compiler extension. &#8216;Nuff said.</p>
</li>
<li>
<p>Switching to pass-by-reference allows the future addition of a Z parameter, for when three-dimensional displays become more popular. (Heh. GDI for 3D rendering? &nbsp;An amusing thought.)</p>
</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755983">
				<div id="div-comment-755983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">doynax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755983">
			July 21, 2009 at 2:49 am</a>		</div>

		<p>So why was 32-bit coordinates considered important for MoveTo while, say, WM_MOUSEMOVE still has to make do with 16-bit coordinates?</p>
<div class=post>[<i>I&#8217;m confident you can figure this out. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-755993">
				<div id="div-comment-755993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">doynax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755993">
			July 21, 2009 at 2:54 am</a>		</div>

		<p>Device coordinates vs pixel coordinates, and possibly printing?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-755953">
				<div id="div-comment-755953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-755953">
			July 20, 2009 at 7:58 pm</a>		</div>

		<p>&quot;Instead of adding a new parameter, why not just make MoveToEx return an __int64?&quot;</p>
<p>I suspect it has something to do with the fact that WIN32 could actualy run *under* WIN16.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756003">
				<div id="div-comment-756003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shaka</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756003">
			July 21, 2009 at 3:12 am</a>		</div>

		<p>@doynax,</p>
<p>I think that it is because WM_MOUSEMOVE, and the other mouse related messages, deal with&#8230; mouse coordinates as it moves around the screen. And I think that we must wait a bit to put our hands on a display that support resolutions upper than the 32K x 32K range used by WM_MOUSEMOVE &amp; co.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756013">
				<div id="div-comment-756013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skizz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756013">
			July 21, 2009 at 4:55 am</a>		</div>

		<p>@Shaka</p>
<p>Well, 16 2048xwhatever monitors side-by-side would hit the 32K range &#8211; and yes, I am trying to out-do Swordfish!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756023">
				<div id="div-comment-756023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756023">
			July 21, 2009 at 6:50 am</a>		</div>

		<p>The main reason I can think of is that if you had code that needed to run on both 16 bit and 32 bit Windows. &nbsp;Everytime you used MoveTo you would need an OS version check and two different return value decoding systems. &nbsp;It&#8217;s cleaner to just replace the function, and it has the added bonus of ensuring that a certain type of programmer who is hell-bent on doing things the wrong way despite all documentation and dire warnings is forced to do them the right way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756033">
				<div id="div-comment-756033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756033">
			July 21, 2009 at 6:52 am</a>		</div>

		<p>__int64 being a compiler extension isnt really a good arguement, since there also is no standard int, long int, long long, etc..</p>
<p>..the non-extensions, when used, are used in error. You shound&#8217;t be using &#8216;int&#8217; for 32-bit values since int&#8217;s might be 16-bit values, or 64-bit values..</p>
<p>I had another thought about this. Remember that NT doesnt exist only on x86 derivative platforms. It could very well be that 64-bit return values was verboten on some of the platforms supported by NT.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756043">
				<div id="div-comment-756043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.winamp.com' rel='external nofollow' class='url'>benski</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756043">
			July 21, 2009 at 8:29 am</a>		</div>

		<p>The __stdcall calling convention (Aka WINAPI and CALLBACK) specifies returning values going into the EAX register, which isn&#8217;t large enough to hold an __int64 or a POINT structure or anything like that. &nbsp;Returning a pointer is unsafe because you have a multithreaded race condition (like some other old Win16 APIs that Raymond has gone over the in the past).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756103">
				<div id="div-comment-756103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756103">
			July 21, 2009 at 10:30 am</a>		</div>

		<p>@doynax: I&#8217;m going to go out on a limb here and say it&#8217;s becuase WM_MOUSEMOVE is in screen coordinates (device units) whereas MoveTo() is in logical coordinates. &nbsp;The GDI mapping mode can be used to take huge coordinate systems (logical) and map them to a constrained set of device coordinates (physical). &nbsp;Current display technology is just about 2,000 pixels wide right now &#8212; we&#8217;ve got to get displays a lot bigger before we worry about overflowing 16 bits of pixel address.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756133">
				<div id="div-comment-756133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756133">
			July 21, 2009 at 10:41 am</a>		</div>

		<p>@Benski,</p>
<p>EAX:EDX is used to return 64 bit values or structures.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756223">
				<div id="div-comment-756223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756223">
			July 21, 2009 at 3:38 pm</a>		</div>

		<p>Alex:</p>
<p>Minor quibble, but thats EDX:EAX</p>
<p>(long time assembler programmer here)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756273">
				<div id="div-comment-756273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756273">
			July 21, 2009 at 6:02 pm</a>		</div>

		<blockquote><p>
  &gt; Minor quibble, but thats EDX:EAX
</p></blockquote>
<p>Ah, but i386 is little endian&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756283">
				<div id="div-comment-756283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756283">
			July 21, 2009 at 6:16 pm</a>		</div>

		<p>@porter,</p>
<p>Doesn&#8217;t matter, it&#8217;s always been high:low. ss:bp, es:bx, dx:ax, edx:eax.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756323">
				<div id="div-comment-756323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756323">
			July 21, 2009 at 8:48 pm</a>		</div>

		<p>The &#8216;:&#8217; in this case is used similar to a decimal point.</p>
<p>Programmers from both endians write values from most significant digit to least, because that is the standard convention.</p>
<p>EDX:EAX is standardized upon because the integral division instructions support double-wide numerators, which must be stored specifically in these registers in that order.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756353">
				<div id="div-comment-756353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756353">
			July 21, 2009 at 11:03 pm</a>		</div>

		<p>I&#8217;m gonna go ahead and make the statement that no one ever cared about the returned value MoveTo and no non-trival program used it. &nbsp;Who&#8217;s with me? :P I can&#8217;t recall seeing the return value used in 17 years. &nbsp;There was never really a need to restore the raster coordinate.</p>
<p>on a more serious note, not only the source code compat was broken, to me it felt inelegant that GDI no longer had a proper MoveTo function.</p>
<p>I&#8217;m curious about that __int64 bit though.</p>
<p>BTW, MFC insulated us from the source code change&#8230; &nbsp;CDC::MoveTo continued to exist and return a CPoint.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756363">
				<div id="div-comment-756363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756363">
			July 21, 2009 at 11:53 pm</a>		</div>

		<blockquote><p>
  &gt; I&#8217;m curious about that __int64 bit though.
</p></blockquote>
<p>As far as I know, __int64 still worked in WIN32S.</p>
<p>But for backward compatibility, Microsoft have bucked the trend of using 64 bit longs in 64 bit environments because of the screeds of code that assumes sizeof(long)==4.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756413">
				<div id="div-comment-756413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Caron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756413">
			July 22, 2009 at 7:58 am</a>		</div>

		<p>I am hardly an expert on this subject, but the obvious answer is that it&#8217;s because you want to avoid returning large amounts of data on the stack.</p>
<p>As was alluded above, a single 32-bit value can be returned in a register, but what about larger values? What if you need to return 96 bits?</p>
<p>All in all, better to just pass it by reference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756463">
				<div id="div-comment-756463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756463">
			July 22, 2009 at 2:26 pm</a>		</div>

		<blockquote><p>
  &gt; All in all, better to just pass it by reference.
</p></blockquote>
<p>Are you not arguing for return values to be prohibited from with Win32 API and all values to be returned by reference on the chance that they may change size?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756513">
				<div id="div-comment-756513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Caron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756513">
			July 22, 2009 at 6:40 pm</a>		</div>

		<p>No, I&#8217;m saying don&#8217;t return structs. Return ints, return BOOLs, return integral types/pointers. If you need to sling large data types around, do it by reference.</p>
<p>Plus, the compiler has to generate code to move your data from the stack into wherever you&#8217;re keeping it. I don&#8217;t know that a 64-bit struct would be returned in EAX:EDX (or however you say it, I don&#8217;t do assembly), since you&#8217;re not returning a 64-bit integer, you&#8217;re returning a struct whose length *happens* to be 64-bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756533">
				<div id="div-comment-756533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756533">
			July 23, 2009 at 1:02 am</a>		</div>

		<p>&gt;&gt; I don&#8217;t know that a 64-bit struct would be returned in EAX:EDX (or however you say it, I don&#8217;t do assembly), since you&#8217;re not returning a 64-bit integer, you&#8217;re returning a struct whose length *happens* to be 64-bits.</p>
<p>Win32 __stdcall does return an 8 byte struct in EDX:EAX. OS/2&#8217;s _System calling convention to which it is closely related didn&#8217;t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756613">
				<div id="div-comment-756613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756613">
			July 23, 2009 at 10:49 am</a>		</div>

		<p>What? &nbsp;&quot;Pass by reference&quot;? &nbsp;That doesn&#8217;t make sense to me. &nbsp;If the function returned a pointer, aka a &#8216;reference&#8217;, that would mean that the pointer would point to a structure would be somewhere in a global variable. &nbsp;This would be a total nightmare, as the next call would overwrite it, and there would need to be one such variable for each thread to make it thread safe. &nbsp;MoveToEx already solves all of that problem by copying the struct into your own</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756633">
				<div id="div-comment-756633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756633">
			July 23, 2009 at 12:34 pm</a>		</div>

		<p>Mike Caron:</p>
<p>Functions return values do not go on the stack. They return them in standardized registers.</p>
<p>Win32 STDCALL:</p>
<p>32-bit returns are in EAX.</p>
<p>64-bit returns are in EDX:EAX.</p>
<p>Floating point return values of all sizes are returned on top of the FPU stack (its registers are 80-bits wide)</p>
<p>The definition further says that structures up to 64-bits are returned within EDX:EAX (even if it contains a floating point value)</p>
<p>Anything beyond this is not part of the specification, however standard convention is for the function prototype to explicitly specify caller-provided pointers to hold additional, or nonstandard return values (caller-provided for obvious reasons)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756713">
				<div id="div-comment-756713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">porter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756713">
			July 23, 2009 at 6:21 pm</a>		</div>

		<p>Ironically the return values larger than 64bits breaks the __stdcall decorations designed to indicate how many bytes of arguments are on the stack, as the compiler pushes an additional pointer on the stack to point to where the return value should be put. So return values larger than 64bits are already passed by reference whether you like it or knew it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-756773">
				<div id="div-comment-756773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://rosettacode.org/wiki/User:Short_Circuit' rel='external nofollow' class='url'>Michael Mol</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756773">
			July 23, 2009 at 11:54 pm</a>		</div>

		<p>@Ulric</p>
<p>&quot;Pass by reference&quot; typically means that you use one of the function&#8217;s parameters to specify where you want the value to be put. &nbsp;In C, this would have to be passing a pointer to the variable where you want the value stored. &nbsp;In C++, you can use reference types (Which almost, but not quite, avoids the problem of an invalid reference; It&#8217;s possible to get dangling references in C++ if you&#8217;re too clever.), but we all know that the Win32 API is targeted at C.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-756783">
				<div id="div-comment-756783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://rosettacode.org/wiki/User:Short_Circuit' rel='external nofollow' class='url'>Michael Mol</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-756783">
			July 24, 2009 at 12:03 am</a>		</div>

		<p>@Joseph</p>
<p>Which is why Win32 provides WORD, DWORD, ULONGLONG, etc. &nbsp;I don&#8217;t know if Mr. Chen was implying the use of ULONGLONG, though, as he used __int64 specifically.</p>
<p>Perhaps a more interesting approach in this case might have been to use DWORD_PTR or UINT_PTR, under the assumption that those types represent the largest native pointer type, and under the assumption that the largest native pointer type corresponds to the largest native unsigned integer type.</p>
<p>While that would have expanded capabilities with the increase in type size, it would have required developers to do some extra trickery to account for varying sizes, which they already didn&#8217;t bother to do despite the fact that the C and C++ languages don&#8217;t make many guarantees about their type sizes. &nbsp;A workaround might have been to provide a type like UINT_HALFPTR, but a workaround to support a workaround is just&#8230;ugly.</p>
<p>Forget my earlier guesses. &nbsp;Pass by reference is just plain cleaner&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-757113">
				<div id="div-comment-757113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-757113">
			July 24, 2009 at 10:00 pm</a>		</div>

		<p>@Michel Mol</p>
<p>I know what Pass By Reference means, but I thought you guys were discussing a way to implement the return value, not the way MoveToEx was eventually implement returning the POINT through an argument</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-757253">
				<div id="div-comment-757253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090720-00/?p=17433#comment-757253">
			July 26, 2009 at 9:32 am</a>		</div>

		<p>Michael Mol:</p>
<p>Win32 definately does not target C since C&#8217;s calling convention, CDECL, is nowhere in sight.</p>
<p>STDCALL passes arguements right to left (just like the CDECL calling convention) but delegates stack cleanup to the function itself (just like the PASCAL calling convention.)</p>
<p>Microsoft has two DOS compilers that operated exactly like this even before Windows 3. One was the BASCOM/PDS line and the other was the QuickBASIC line. Even the required register preservation (albeit in 16-bit form instead of 32-bit form) for their &#8216;Quick Libraries&#8217; (which are similar to modern DLL&#8217;s) was the same.</p>
<p>Make what you want of that. I&#8217;d argue that the features of STDCALL were chosen independently and that it only coincedentaly matches that of their early Basic compilers due to having similar dynamic linking requirements.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

