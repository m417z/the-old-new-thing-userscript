<html>
<head>
<title>The case of the file that won't copy because of an Invalid Handle error message</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The case of the file that won&#8217;t copy because of an Invalid Handle error message</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 31, 2014 / year-entry #257</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>40</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer reported that they had a file that was "haunted" on their machine: Explorer was unable to copy the file. If you did a copy/paste, the copy dialog displayed an error. 1 Interrupted Action Invalid file handle &#x26bf;  Contract Proposal Size: 110 KB Date modified: 10/31/2013 7:00 AM Okay, time to roll up your...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
A customer reported that they had a file that was "haunted"
on their machine:
Explorer was unable to copy the file.
If you did a copy/paste, the copy dialog displayed an error.
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="border: solid 3px #ebebeb; font-family: Segoe UI, sans-serif;
           color: black; background-color: white">
<tr>
<td ALIGN=center STYLE="background-color: #ebebeb;
    padding: 5px">1 Interrupted Action</td>
</tr>
<tr>
<td STYLE="border: solid 1px #dadada; padding: 10px">
<p>Invalid file handle</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr>
<td VALIGN=middle STYLE="font-size: 40px">&#x26bf;&nbsp;</td>
<td>Contract Proposal<br>
    Size: 110 KB<br>
    Date modified: 10/31/2013 7:00 AM</td>
</tr>
</table>
</td>
</tr>
</table>
<p>
Okay, time to roll up your sleeves and get to work.
This investigation took several hours, but you'll be able to read
it in ten minutes
because I'm deleting all the dead ends and red herrings,
and because I'm skipping over a lot of horrible grunt work,
like tracing a variable in memory backward in time to see where
it came from.&sup1;
</p>
<p>
The <i>Invalid file handle</i> error was most likely coming from
the error code
<code>ERROR_<wbr>INVALID_<wbr>HANDLE</code>.
Some tracing of handle operations
showed that a call to
<code>Get&shy;File&shy;Information&shy;By&shy;Handle</code>
was being passed <code>INVALID_<wbr>FILE_<wbr>HANDLE</code>
as the file handle,
and as you might expect,
that results in the invalid handle error code.
</p>
<p>
Okay, but why was Explorer's file copying code getting confused
and trying to get information from an invalid handle?
</p>
<p>
Code inspection showed that the handle in question is normally
set to a valid handle during the file copying operation.
So the new question is,
"Why <i>wasn't</i> this variable set to a valid handle?"
</p>
<p>
Debugging why something didn't happen is harder than debugging
why it <i>did</i> happen,
because you can't set a breakpoint of the form
"Break when X doesn't happen."
Instead
you have to set a breakpoint in the code that you're
pretty sure is being executed,
then trace forward to see where execution strays from the intended path.
</p>
<p>
The heavy lifting of the file copy is done by the
<code>Copy&shy;File2</code> function.
Explorer uses the
<code>Copy&shy;File2&shy;Progress&shy;Routine</code> callback
to get information about the copy operation.
In particular, it gets a handle to the destination file by
making a duplicate of the
<code>hDestination&shy;File</code> in the
<code>COPY&shy;FILE2_<wbr>MESSAGE</code> structure.
The question is now,
"Why wasn't Explorer told about the destination file that
was the destination of the file copy?"
</p>
<p>
Tracing through the file copy operation showed that the file
copy operation actually <i>failed</i>
because the destination file already exists.
The failure would normally be reported as
<code>ERROR_<wbr>FILE_<wbr>EXISTS</code>,
and the offending
<code>Get&shy;File&shy;Information&shy;By&shy;Handle</code>
would never have taken place.
Somehow the file copy was being treated as having succeeded
even though it failed.
That's why we're using an invalid handle.
</p>
<p>
The <code>Copy&shy;File2</code> function goes roughly like this:
</p>
<pre>
HRESULT CopyFile2()
{
 BOOL fSuccess = FALSE;
 HANDLE hSource = OpenTheSourceFile(); // calls SetLastError() on failure
 if (hSource != INVALID_HANDLE_VALUE)
 {
  HANDLE hDest = CreateTheDestinationFile(); // calls SetLastError() on failure
  if (m_hDest != INVALID_HANDLE_VALUE)
  {
   if (CopyTheStuff(hSource, hDest)) // calls SetLastError() on failure
   {
    fSuccess = TRUE;
   }
   CloseHandle(hDest);
  }
  CloseHandle(hSource);
 }
 return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}
</pre>
<p>
<b>Note</b>: This is not the actual code,
so don't go whining about the coding style or the inefficiencies.
But it gets the point across for the purpose of this story.
</p>
<p>
The <code>Create&shy;The&shy;Destination&shy;File</code> function
failed because the file already existed,
and it called <code>Set&shy;Last&shy;Error</code> to set the
error code to
<code>ERROR_<wbr>FILE_<wbr>EXISTS</code>,
expecting the error code to be picked up when it returned to the
<code>Copy&shy;File2</code> function.
</p>
<p>
On the way out,
the <code>Copy&shy;File2</code> function
makes two calls to <code>Close&shy;Handle</code>.
<code>Close&shy;Handle</code> on a valid handle is not supposed
to modify the thread error state,
but somehow stepping over the <code>Close&shy;Handle</code>
call showed that the error code set by
<code>Create&shy;The&shy;Destination&shy;File</code> was
being reset back to <code>ERROR_SUCCESS</code>.
(Mind you, this was a poor design on the part of the
<code>Copy&shy;File2</code> function to leave the error code
lying around for an extended period,
since the error code is highly volatile, and you would be best
served to get it while it's still there.)
</p>
<p>
Closer inspection showed that the
<code>Close&shy;Handle</code> function
<i>had been hooked by some random DLL that had been
injected into Explorer</i>.
</p>
<p>
The hook function was somewhat complicated
(more time spent trying to reverse-engineer the hook function),
but in simplified form, it went something like this:
</p>
<pre>
BOOL Hook_CloseHandle(HANDLE h)
{
 HookState *state = (HookState*)TlsGetValue(g_tlsHookState);
 if (!state || !state-&gt;someCrazyFlag) {
  return Original_CloseHandle(h);
 }

 ... crazy code that runs if the flag is set ...
}
</pre>
<p>
Whatever that crazy flag was for,
it wasn't set on the current thread,
so the intent of the hook was to have no effect in that case.
</p>
<p>
But it <i>did</i> have an effect.
</p>
<p>
The
<a HREF="http://msdn.microsoft.com/library/ms686812">
<code>Tls&shy;Get&shy;Value</code> function</a>
modifies the thread error state,
even on success.
Specifically, if it successfully retrieves the thread local storage,
it sets the thread error state to
<code>ERROR_SUCCESS</code>.
</p>
<p>
Okay, now you can put the pieces together.
</p>
<ul>
<li>The file copy failed because the destination already exists.
<li>The <code>Create&shy;The&shy;Destination&shy;File</cODE>
    function called
    <code>Set&shy;Last&shy;Error(ERROR_<wbr>FILE_<wbr>EXISTS)</code>.</p>
<li>The file copy function did some cleaning up before retrieving
    the error code.</p>
<li>The cleanup functions are not expected to alter the thread error state.
<li>But the cleanup function had been patched by a rogue DLL,
    and the hook function <i>did</i> alter the thread error state.</p>
<li>This alteration caused the file copy function to think that the
    file was successfully copied even though it wasn't.</p>
<li>In particular, the caller of the file copy function expects
    to have received a handle to the copy during one of the copy callbacks,
    but the callback never occurred because the file was never copied.</p>
<li>The variable that holds the handle therefore remains uninitialized.
<li>This generates an invalid handle error when the code tries to use
    that handle.</p>
<li>This error is shown to the user.
</ul>
<p>
An injected DLL that patched a system call
resulted in Explorer looking like an idiot.
(As Alex and Gaurav well know,
Explorer is perfectly capable of looking like an idiot without any help.)
</p>
<p>
We were quite fortunate that the error
manifested itself as a failure to copy the file.
Imagine if Explorer didn't use
<code>Get&shy;File&shy;Information&shy;By&shy;Handle</code>
to get information about the file that was copied.
The <code>Copy&shy;File2</code> function returns <code>S_OK</code>
<i>even though it actually failed and no file was copied</i>.
Explorer would have happily reported,
"Congratulations, your file was copied successfully!"
</p>
<p>
Stop and think about that for a second.
</p>
<p>
A rogue DLL injected into Explorer patches a system call incorrectly
and ends up causing all calls to
<code>Copy&shy;File2</code> to report success even if they failed.
The user then deletes the original, thinking that the file was safely
at the destination,
then later discovers that, oops, looks like the file was not copied
after all.
Sorry, it looks like that rogue DLL (which I'm sure had the best
of intentions) had a subtle bug that caused you to <i>lose all your data</i>.
</p>
<p>
This is why, as a general rule,
Windows considers DLL injection and API hooking to be unsupported.
If you hook an API, you not only have to emulate all the documented
behavior, you also have to emulate all the <i>undocumented</i> behavior
that applications unwittingly rely on.
</p>
<p>
(Yes, we contacted the vendor of the rogue DLL.
Ideally, they would get rid of their crazy DLL injection and API hooking
because, y'know, <i>unsupported</i>.
But my guess is that they are going to stick with it.
At least we can try to get them to fix their bug.)
</p>
<p>
&sup1;
To do this, you identify the variable
and set a breakpoint when that variable is allocated.
(This can be tricky if the variable belongs to a class with
hundreds of instances;
you have to set the breakpoint on the correct instance!)
When that breakpoint is hit,
you set a write breakpoint on the variable,
then resume execution.
Then you hope that the breakpoint gets hit.
When it does,
you can see who set the value.
"Oh, the value was copied from that other variable."
Now you repeat the exercise with that other variable,
and so on.
This is very time-consuming but largely uninteresting
so I've skipped over it.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1159083">
				<div id="div-comment-1159083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159083">
			October 31, 2014 at 7:25 am</a>		</div>

		<p>Raymond, when Microsoft does contact a third party about bugs in their code, generally speaking, how receptive are to fixing things?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159103">
				<div id="div-comment-1159103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159103">
			October 31, 2014 at 7:37 am</a>		</div>

		<p>To be fail, if I were the vendor I&#39;d fix that bug very quickly by calling GetLastError and SetLastError and be looking at a patch release the next day.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159113">
				<div id="div-comment-1159113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159113">
			October 31, 2014 at 7:39 am</a>		</div>

		<p>To be fair not to be fail. Stupid autocorrect</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159123">
				<div id="div-comment-1159123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jmac_the_man</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159123">
			October 31, 2014 at 7:40 am</a>		</div>

		<p>Raymond/Raymond&#39;s Microsoft Friends,</p>
<p>A while ago, you posted a story that briefly mentioned Use Case documentation that Microsoft uses in system design has a standardized set of names of the actors, and the actor&#39;s first name implies their skill level and role. (So, for example, if you&#39;re reading a use case and you see the name &quot;Bob,&quot; you know he&#39;s a mid-level user, whereas &quot;Charlie&quot; is the supervisor of the user with their hands on the keyboard of the program under study or whatever.)</p>
<p>Is there any chance there&#39;s documentation available on this? </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159133">
				<div id="div-comment-1159133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159133">
			October 31, 2014 at 7:52 am</a>		</div>

		<p>Ignoring the rogue DLL (which is poor form, I agree), to me the real bug still seems to be in CopyFile2, which is relying on CloseHandle not to mess with the last error on success, which does not seem to be contractually obligated. So hopefully that at least got logged as a bug to the appropriate team.</p>
<div class="post">[<em>I agree that CopyFile2 could be more defensive, but on the other hand, the people who maintain CopyFile2 are also the people who maintain CloseHandle, so they would just be defending against themselves. If they change CloseHandle to mess with the last error code, then they can also change CopyFile2. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159143">
				<div id="div-comment-1159143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Count Zero</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159143">
			October 31, 2014 at 7:55 am</a>		</div>

		<p>@12BitSlab &#8211; While you was asking Raymond, let me &quot;say&quot; my answer to that as a non-Microsoft developer. It strongly depends. There are project companies, which are asked and payed to produce some software or software component (usually by another development company which sells the finished product), and get no financial benefit from fixing errors in already finished (and paid) products. I have worked for some of those. Those companies are always overrun with work and deadlines therefore they would not even have resources to fix buggy code if they were intended to (and usually upper management definetly forbids such fixes unless they are paid for).</p>
<p>The other type of software development firm typically develops only a few products and directly profits after the sales of those, so they have a financial interest in fixing bugs as soon as possible. I&#39;m working for one of those nowadays. Theres is something more to the non-project companies: their connection to their software (source code). They know, like, and live in symbiosis with that. They are always up-to-date about one-or-another aspect of the programs, constantly testing and developing it so if it is buggy they happily fix it. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159153">
				<div id="div-comment-1159153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159153">
			October 31, 2014 at 8:59 am</a>		</div>

		<p>&quot;When it does, you can see who set the value. &quot;Oh, the value was copied from that other variable.&quot; Now you repeat the exercise with that other variable, and so on.&quot;</p>
<p>We want time-travelling debuggers!</p>
<p>When do we want them?</p>
<p>Yesterday!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159163">
				<div id="div-comment-1159163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159163">
			October 31, 2014 at 10:05 am</a>		</div>

		<p>Hooking CloseHandle, what a capital suggestion. Nothing could possibly go wrong with that. The only right hook here is the one the programmer&#39;s face deserves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159173">
				<div id="div-comment-1159173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159173">
			October 31, 2014 at 10:11 am</a>		</div>

		<p>@JM: I&#39;ve seen it before when somebody hooked CreateFile to create a virtual file system from userspace. It&#39;s nearly a bad idea as it sounds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159193">
				<div id="div-comment-1159193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159193">
			October 31, 2014 at 10:36 am</a>		</div>

		<p>@Evan: Given a time-travelling debugger, I&#39;d rip out the debugger and replace it with a bomb before dispatching the package to whoever first dreamt up the &quot;errno&quot; idiom for reporting errors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159203">
				<div id="div-comment-1159203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159203">
			October 31, 2014 at 10:39 am</a>		</div>

		<p>&quot;At least we can try to get them to fix their bug.&quot;</p>
<p>Perhaps they could fix it by hooking SetLastError() ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159213">
				<div id="div-comment-1159213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159213">
			October 31, 2014 at 10:51 am</a>		</div>

		<p>@Ken Hagan: I wrote a time traveling debugger when debugging a crash so bad it would bring the process down immediately because it was in so bad a state even the debugger couldn&#39;t function in the process anymore.</p>
<p>Unfortunately the technique involved is read-only. Writing to the past didn&#39;t propagate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159233">
				<div id="div-comment-1159233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159233">
			October 31, 2014 at 2:49 pm</a>		</div>

		<p>I&#39;m also of the opinion that the bug is in the CopyFile2 implementation. &nbsp;They took a dependency on an undocumented (if it is documented that &quot;Close&shy;Handle on a valid handle is not supposed to modify the thread error state&quot;, I&#39;d love to see it&#8230; but there is no such statement in CloseHandle&#39;s own MSDN page) implementation detail. &nbsp;And GetLastError explicitly says:</p>
<p>&gt; Most functions that set the thread&#39;s last-error code set it when they fail. However, some functions also set the last-error code when they succeed. If the function is not documented to set the last-error code, the value returned by this function is simply the most recent last-error code to have been set; some functions set the last-error code to 0 on success and others do not.</p>
<p>&gt; Functions executed by the calling thread set this value by calling the SetLastError function. You should call the GetLastError function immediately when a function&#39;s return value indicates that such a call will return useful data. That is because some functions call SetLastError with a zero when they succeed, wiping out the error code set by the most recently failed function.</p>
<p>When a hook conformed to the documented interface, the function relying on the implementation details started failing. &nbsp;That shouldn&#39;t surprise any readers of this blog &#8212; Raymond is always writing about the superhuman efforts needed to bring implementation details into the contract to avoid breaking application software. &nbsp;This is just the opposite perspective; if there are multiple implementers, making the contract more tolerant of users breaks existing implementers.</p>
<p>I don&#39;t see that being the implementer of the shipped version of CloseHandle makes it ok for the CopyFile2 developer to ignore the actual rules documented for GetLastError and rely on details of one particular CloseHandle implementation. &nbsp;Yes, I know both functions live in the same DLL, but it&#39;s not like Detours is some third-party approach. &nbsp;Things would be different if they called a non-public function (probable name: ZwForInternalUseOnlyThisIsTheRealCloseHandle), of course, but they didn&#39;t.</p>
<div class="post">[<em>And then people who detour Close&shy;Handle will say, &quot;Hey, when a file is copied, we never see the handle get closed! Now we have a huge memory leak.&quot; And then maybe they will find Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;Close&shy;Handle, and detour that, and you&#39;re back where you started. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159243">
				<div id="div-comment-1159243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Y</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159243">
			October 31, 2014 at 3:36 pm</a>		</div>

		<p>Wait, so the end result is that the file wasn&#39;t haunted after all? &nbsp;Every attempt to copy a file that would involve an overwrite would have had the same effect? &nbsp;(On an unrelated note: I suppose that as a side effect of this adventure, the function has been changed to grab the error code sooner?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159253">
				<div id="div-comment-1159253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159253">
			October 31, 2014 at 4:26 pm</a>		</div>

		<p>How about a TlsGetValueEx function that doesn&#39;t do that weird SetLastError behavior?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159183">
				<div id="div-comment-1159183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159183">
			October 31, 2014 at 10:31 am</a>		</div>

		<p>@Joshua &#8211; there are defendable reasons for doing so &#8211; for *individual apps* &#8211; but not for the whole system ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159263">
				<div id="div-comment-1159263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159263">
			October 31, 2014 at 8:34 pm</a>		</div>

		<p>Bob: Anybody aware enough to realize the value of calling TlsGetValueEx could just as easily save and reset the last error.</p>
<p>BTW, I&#39;ve been bitten by the TlsGetValue bug, too. Fortunately my bug was reasonably easy to spot once I remembered the behavior. It&#39;s easy to forget that TlsGetValue can fail, so it&#39;s easy to forget that it sets the last error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159273">
				<div id="div-comment-1159273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159273">
			October 31, 2014 at 9:33 pm</a>		</div>

		<p>People who say that CopyFile2 should get the error code sooner are correct, but missing the point. &nbsp;Consider if a rogue dll hooked CopyFile2 instead with code like this:</p>
<p>HRESULT Hook_CopyFile2()</p>
<p>{</p>
<p> HRESULT hr = Original_CopyFile2();</p>
<p> HookState *state = (HookState*)TlsGetValue(g_tlsHookState);</p>
<p> if (state &amp;&amp; state-&gt;someCrazyFlag) {</p>
<p>.</p>
<p> &#8230; crazy code that runs if the flag is set &#8230;</p>
<p> }</p>
<p> return hr;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159323">
				<div id="div-comment-1159323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159323">
			November 1, 2014 at 4:49 am</a>		</div>

		<p>@Evan &#8211; Here you go: <a rel="nofollow" target="_new" href="http://www.thewindowsclub.com/microsoft-time-travel-tracing-diagnostic">http://www.thewindowsclub.com/microsoft-time-travel-tracing-diagnostic</a></p>
<p>I&#39;ve used it before &#8211; not an easy tool to operate, but it does work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159333">
				<div id="div-comment-1159333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159333">
			November 1, 2014 at 6:37 am</a>		</div>

		<p>It seems like the real problem here is relying on a global variable to communicate information across function calls. &nbsp;Earth shattering news, Global Variables Are Bad. &nbsp;If something is a return value from a function call, return it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159353">
				<div id="div-comment-1159353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159353">
			November 1, 2014 at 7:56 am</a>		</div>

		<p>@Thomas: That hook is clearly broken, because it doesn&#39;t conform to the documented rules which I quoted directly from MSDN.</p>
<p>The thing about the case Raymond presented is that the hook DOES conform to the documented contract.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159363">
				<div id="div-comment-1159363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159363">
			November 1, 2014 at 9:19 am</a>		</div>

		<p>@Ben Voigt:</p>
<p>The thing is, you are quoting rules about hooks and saying that CopyFile2 is broken because of it. But the first hook itself clearly doesn&#39;t follow all the quoted rules. Specifically</p>
<p>&quot;Most functions that set the thread&#39;s last-error code set it when they fail. However, some functions also set the last-error code when they succeed. If the function is not documented to set the last-error code, the value returned by this function is simply the most recent last-error code to have been set; some functions set the last-error code to 0 on success and others do not.&quot;</p>
<p>Because it is not documented what happens on success, and it is clearly documented that the behaviour on success isn&#39;t pre-determined, the hook function is breaking the contract by not saving the error code. From the re&#39;d code that Raymond posted, they don&#39;t even attempt to save the error code at all. This is obviously going to change the behaviour of the function it hooked.</p>
<p>I also agree with Raymond on the &quot;they will be defending against themselves&quot; part. They control both sides here, and they right the implementation. So in this case, they are not relying on undocumented or implementation defined behaviour, they are relying on behaviour that they write themselves. I&#39;m sure any large software implementation has this somewhere, but it is easy to bash Microsoft here because there is a concrete case of something going wrong, and it&#39;s Microsoft.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159283">
				<div id="div-comment-1159283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jas88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159283">
			November 1, 2014 at 2:35 am</a>		</div>

		<p>At least this only gave an inaccurate error message &#8211; I was immediately reminded of a few hours of hair loss years ago when my userspace program was triggering a BugCheck &#8211; when I closed a file handle. It turned out the AV product I had installed at the time (not an MS one) was, for obvious reasons, hooking file access &#8211; and, somehow, screwed up the ZwClose/NtClose hook. It looked as if they were *usually* allocating a buffer when a file was opened, then *always* freeing it when that file was closed &#8211; I&#39;d hit the corner case where it didn&#39;t allocate the buffer, but still tried to free it later, breaking the system in the process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command odd alt thread-odd thread-alt depth-1" id="comment-1159373">
				<div id="div-comment-1159373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159373">
			November 1, 2014 at 12:23 pm</a>		</div>

		<p>Every time I read an article about a strange behavior in Windows components, the reason is always hooking/injection or plug-ins.</p>
<p>Is it illogical to think Windows needs to outlaw hooking and develop a plug-in model for Explorer instead?</p>
<div class="post">[<em>Um, Explorer has had a plug-in model since day one. Some people abuse this plug-in model in order to inject themselves in to Explorer so they can hook it. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159383">
				<div id="div-comment-1159383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159383">
			November 1, 2014 at 1:26 pm</a>		</div>

		<p>@Fleet Command: Considering the techniques currently used, documenting well how to do it is far more likely to bring real quality results. The only way to outlaw hooks is to outlaw debuggers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159403">
				<div id="div-comment-1159403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nitpicker (Corner?)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159403">
			November 1, 2014 at 8:46 pm</a>		</div>

		<p>@Fleet Command &#8211; As soon as I saw the name of the post, I said (out loud) &#39;buggy shell extension&#39;. I wasn&#39;t too far off.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1159423">
				<div id="div-comment-1159423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159423">
			November 2, 2014 at 2:13 pm</a>		</div>

		<p>If you want to save you some grief, don&#39;t assume that last error doesn&#39;t change across some function calls. If you&#39;ll need it, save it to the variable immediately after the call of interest. Because you may later add tracing calls, printfs, etc, and break your GetLastError() state, unless you&#39;ve saved it.</p>
<p>I suspect, such approach was the reason the defective component didn&#39;t cause catastrophic damage in most other cases of CloseHandle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159433">
				<div id="div-comment-1159433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alois Kraus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159433">
			November 2, 2014 at 2:22 pm</a>		</div>

		<p>I guess you had a TT Trace which makes debugging back and forth in time much easier. Otherwise I would not think that you could do such an analysis within a few hours. How about giving this power to the official Windbg version? </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159473">
				<div id="div-comment-1159473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RadosÅ‚aw Cybulski</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159473">
			November 3, 2014 at 2:30 am</a>		</div>

		<p>As Alois pointed out &#8211; the real question is: when time travel will be available to everyone? Because the problem with CopyFile2 is easy once You dig into source code &#8211; it relies on not-visible-in-code dependency about CloseHandle not changing error code, when successed. Once it does (for any reason) the code breaks. </p>
<p>It doesnt really matter, that both functions are managed by the same people. That sort of invisible dependency makes source code much, much harder to read and change. Just code defensively and read the error code into local variable. This is CopyFile2 bug, unless CloseHandle is defined as not changing error code, when successed.</p>
<p>This paragraph about emulating undocumented behavior is simply wrong. As long as such a dependency is invisible, there&#39;s no difference between some happy coder in India writing a hook and also happy coder in microsoft, working in another division. They both wont see it coming, make the same error and in both cases sh*t will hit the fan later on. Either make the dependency visible (ie document it) or remove it from the code (ie copy error value to local variable right after failure).</p>
<p>You can also it CopyFile2 from different perspective. It stores its success flag in two different places, fSuccess boolean flag (Hungarian notation is so 80&#8230;) and in global variable returned by GetLastError. Function makes decision based on first, but returns the second. Which caller makes decision on. You dont need to check any documentation about used calls to know this spells troubles. In such case there should be an assert on exit, making sure fSuccess and returned value both report either success or error. This would make Your debugging lasts maybe 3 seconds.</p>
<p>Also global variables.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159493">
				<div id="div-comment-1159493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EduardoS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159493">
			November 3, 2014 at 7:19 am</a>		</div>

		<p>I think the bug is in GetLastError/SetLastError, in the sense, they exists at all, how many bugs already appeared because of those functions writing global variables?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1159513">
				<div id="div-comment-1159513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159513">
			November 3, 2014 at 9:00 am</a>		</div>

		<p>â€“ &quot;Um, Explorer has had a plug-in model since day one. Some people abuse this plug-in model in order to inject themselves in to Explorer so they can hook it. -Raymond&quot;</p>
<p>I mean a real deal: Plug-ins come in a package, there is a plug-in manager that can enable or disable them, etc. Like Chrome and Firefox. Current state is like IE: Individual components that each accomplish a non-atomic task are developed without any real tangible connection to form a bigger whole that remains abstract. So, overall, it does not have the properties of a model.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159523">
				<div id="div-comment-1159523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159523">
			November 3, 2014 at 9:27 am</a>		</div>

		<p>EduardoS: What do you suggest should have taken the place of GetLastError/SetLastError back in 1983?</p>
<p>Should every API have an out-parameter for the error? Or perhaps the return value from every function should be the return status and any returned value would have to be an out-parameter? Or maybe they should have invented structured exception handling?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159533">
				<div id="div-comment-1159533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Remko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159533">
			November 3, 2014 at 10:24 am</a>		</div>

		<p>That&#39;s why functions should return a boolean for succes or failure instead of calling getlasterror</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159553">
				<div id="div-comment-1159553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159553">
			November 3, 2014 at 10:54 am</a>		</div>

		<p>@Crescens2k: Good job cutting out the other half of the quote, the half that is pretty clear that the default contract has no postconditions on the thread last-error value when a function succeeds. &nbsp;If you define an interface as &quot;behaves exactly like the shipped implementation in all cases&quot;, that&#39;s no interface at all. &nbsp;A substitute implementation only has to abide by the documented contract; that&#39;s pretty fundamental to polymorphism.</p>
<p>@Raymond: &quot;maybe they will find Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;Close&shy;Handle, and detour that&quot; &nbsp;By non-public, I meant that it isn&#39;t even exported, and after optimization might not even exist as a separate entity. &nbsp;Besides, there&#39;s no memory leak the way I envision it, because you close handles with Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;Close&shy;Handle only if you opened them with Zw&shy;For&shy;Internal&shy;Use&shy;Only&shy;This&shy;Is&shy;The&shy;Real&shy;CreateFile (see: pairing of malloc=free, new=delete, new[]=delete[], CoTaskAlloc=CoTaskFree, etc), and the hook doesn&#39;t have any private data associated with the handle because it hasn&#39;t seen it. &nbsp;It is purely an implementation detail of CopyFile2. &nbsp;If hook developers get upset because hooks installed on the public interface don&#39;t catch all internal activities deep within kernel32.dll, too bad, they&#39;ve misunderstood what hooking a function does. &nbsp;Hooking CreateFile does not intercept all file access of any variety, anywhere, it intercepts calls to CreateFile.</p>
<div class="post">[<em>Then &quot;Why does CopyFile2 use undocumented APIs we cannot hook? We are hooking file I/O in order to implement our virtual file system.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159633">
				<div id="div-comment-1159633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159633">
			November 3, 2014 at 4:12 pm</a>		</div>

		<p>@Ben Voigt: If you&#39;re substituting a function that relies on global state, that global state is part of the contract too! I remember several TSRs that I used back in DOS days that didn&#39;t remember that and could crash the system in weird ways.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159823">
				<div id="div-comment-1159823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159823">
			November 4, 2014 at 4:55 am</a>		</div>

		<p>[Then &quot;Why does CopyFile2 use undocumented APIs we cannot hook? We are hooking file I/O in order to implement our virtual file system.&quot; -Raymond]</p>
<p>Anyone trying to do this should be forced to implement a real driver. Even and especially AV software should not hook into processes in some strange way, it should do it&#39;s real-time scanning by a filter driver, using the official interfaces.</p>
<p>So, from my point of view, your reason does not exist / is not justified.</p>
<div class="post">[<em>&quot;But there are some things you can&#39;t do in kernel mode, like display UI.&quot; Another scenario might be &quot;We are writing a diagnostic tool, and we want to log all I/O operations with stack traces and other metadata. Our traces do not include I/O due to file copying.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159843">
				<div id="div-comment-1159843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zack</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159843">
			November 4, 2014 at 6:17 am</a>		</div>

		<p>If I could go back to 1970 with a set of changes for Kernighan and Ritchie to implement in the very first version of C, along with mandatory prototyped function declarations, sane operator precedence, postfix unary *, and the extirpation of &lt;code&gt;gets&lt;code&gt;, I would seriously consider fixed-length, scalar-only multiple value return, so you could write</p>
<p>&lt;pre&gt;(err, fd) = open(&quot;path&quot;, flags);&lt;/pre&gt;</p>
<p>At the ABI level this is no more difficult than accepting multiple arguments to a single function, it eliminates all the problems with errno/GetLastError, and it doesn&#39;t have the yuck factor associated with out-parameters for the result the programmer actually wants.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1159903">
				<div id="div-comment-1159903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EduardoS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159903">
			November 4, 2014 at 8:26 am</a>		</div>

		<p>@Gabe, I think it would be nice if they invented structured exception handling in 1983, but 1983 doesn&#39;t matter, nobody cares about Windows 1.0, by the time 32 bit Windows come there was another option, HRESULT with an out parameter for the result, instead, MS made no effort to deprecate the old API.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1159913">
				<div id="div-comment-1159913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1159913">
			November 4, 2014 at 8:39 am</a>		</div>

		<p>EduardoS: It sounds like you are suggesting that Microsoft should have created a whole new API for Win32 that is completely different from Win16. This would prevent people from easily porting their code to Win32, preventing the adoption of Win32. </p>
<p>Or are you suggesting that old APIs still have the old error return mechanism while all new ones would use HRESULTs? That would result in lots of confusion among developers, making reliable code harder to write.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1160003">
				<div id="div-comment-1160003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EduardoS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141031-00/?p=43723#comment-1160003">
			November 4, 2014 at 3:05 pm</a>		</div>

		<p>@Gabe, a mix of the two, there should be a easy way to port from Win16, but it is porting, 16 bitness had some weird things (Global*/Local*, cooperative to preemptive, etc) so some changes were required, it wouldn&#39;t be that bad if a bit more changes were required, and this porting helper (wich may not even be part of the actual API, rather, could be just a header) should not be the default way to write new applications, COM come about the same time Win32 come out creating a lot of confusion anyway, MS could have cleared a bit the confusion by saying THIS is the new way to write apps and, of course, providing the full API in this new way.</p>
<p>BTW, COM had it&#39;s own problems and was a bit boring to use, but some things just needs time and effort to evolve wich half attempts never get.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

