<html>
<head>
<title>PulseEvent is fundamentally flawed</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>PulseEvent is fundamentally flawed</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 5, 2005 / year-entry #4</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>44</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The PulseEvent function releases one thread (or all threads, if manual-reset) which is/are waiting for the pulsed event, then returns the event to the unset state. If no threads happen to be waiting, then the event goes to the unset state without anything happening. And there's the flaw. How do you know whether the thread...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
<a HREF="http://msdn.microsoft.com/library/en-us/dllproc/base/pulseevent.asp">
The <code>PulseEvent</code> function</a>
releases one thread (or all threads, if manual-reset)
which is/are waiting for the pulsed event, then returns the
event to the unset state.
If no threads happen to be waiting, then the event goes to
the unset state without anything happening.
</p>
<p>
And there's the flaw.
</p>
<p>
How do you know whether the thread that you think is waiting on
the event really is?
Surely you can't use something like
</p>
<pre>
SignalSemaphore(hOtherSemaphore);
WaitForSingleObject(hEvent, INFINITE);
</pre>
<p>
because there is a race between the signal and the wait.
The thread that the semaphore is alerting might complete
all its work and pulse the event before you get around to
waiting for it.
</p>
<p>
You can try using
<a HREF="http://msdn.microsoft.com/library/en-us/dllproc/base/signalobjectandwait.asp">
the <code>SignalObjectAndWait</code> function</a>,
which combines the signal and wait into a single operation.
But even then, you can't be sure that the thread is waiting
for the event at the moment of the pulse.
</p>
<p>
While the thread is sitting waiting for the event,
a device driver or part of the kernel itself
might ask to borrow the thread to do some
processing (by means of a "kernel-mode APC").
During that time, the thread is <strong>not</strong> in the
wait state.
(It's being used by the device driver.)
If the <code>PulseEvent</code> happens while the thread
is being "borrowed", then it will <strong>not</strong>
be woken from the wait, because the <code>PulseEvent</code>
function wakes only threads that were waiting
<strong>at the time the <code>PulseEvent</code> occurs</strong>.
</p>
<p>
Not only are you (as a user-mode program) unable to prevent
kernel mode from doing this to your thread,
you cannot even detect that it has occurred.
</p>
<p>
(One place where you are likely to see this sort of thing happening
is if you have the debugger attached to the process, since the
debugger does things like suspend and resume threads,
which result in kernel APCs.)
</p>
<p>
As a result, the <code>PulseEvent</code> function is useless
and should be avoided.  It continues to exist solely for backwards
compatibility.
</p>
<p>
<strong>Sidebar</strong>:
This whole business with kernel APCs also means that you cannot
predict which thread will be woken when you signal a semaphore,
an auto-reset event, or some other synchronization object that
releases a single thread when signalled.  If a thread is "borrowed"
to service a kernel APC, then when it is returned to the wait list,
it "goes back to the end of the line".
Consequently, the order of objects waiting for a kernel object
is unpredictable and cannot be relied upon.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (44)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-239253">
				<div id="div-comment-239253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239253">
			January 5, 2005 at 7:17 am</a>		</div>

		<p>Do you know if this behavior also occurs in the .Net Monitor.PulseAll() method ? If so, what&#8217;s the preferred way of synchronizing threads ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239263">
				<div id="div-comment-239263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239263">
			January 5, 2005 at 7:20 am</a>		</div>

		<p>Was PulseEvent simply a mistake by the Windows design team, or is this problem an artifact of some subsequent change to Windows?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239273">
				<div id="div-comment-239273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239273">
			January 5, 2005 at 8:20 am</a>		</div>

		<p>Dave: &quot;not actually a .NET blog&quot; &#8211; try asking somebody from the .NET team, or work through the logic yourself.</p>
<p>mschaef: I don&#8217;t know the history behind PulseEvent. But given that the race condition is independent of the APC issue, it strikes me as having been flawed from the beginning.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239313">
				<div id="div-comment-239313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CPU</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239313">
			January 5, 2005 at 10:12 am</a>		</div>

		<p>Yes, it makes creating a condition variable (CV)very interesting. I wonder how posix does it.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239343">
				<div id="div-comment-239343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mailto:pinterkr@freemail.hu' rel='external nofollow' class='url'>krisztian pinter</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239343">
			January 5, 2005 at 11:54 am</a>		</div>

		<p>Can someone please tell me a real life situation where PulseEvent would be useful if it would not be defective?</p>
<p>Somehow I feel it is a contra-intuitive use of events, which normally should indicate some state, instead of, as the name suggests, an event (which is also contra-intuitive, but we have learned it)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239363">
				<div id="div-comment-239363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Montgomery</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239363">
			January 5, 2005 at 12:09 pm</a>		</div>

		<p>Raymond,</p>
<p>You often answer questions with, &quot;Ask someone from the &#8216;fill-in-the-blank&#8217; team&quot;.  This really helps no one.  It&#8217;s not like we work at MS.  None of know anyone on the &#8216;fill-in-the-blank&#8217; team, or else we &lt;would&gt; ask them.  You don&#8217;t seem to realize that for most people, you are the closest thing they have to someone who can answer inside questions about MS and windows becuase you do work there.</p>
<p>If asking someone on the correct team is easy, then perhaps posting an URL to a website for that person or an email they can be reached at would be helpful.  If you (who works at MS) don&#8217;t know a website or URL, then you can almost certainly guess that the great unwashed masses don&#8217;t know it either.  I have a number of questions I would love to ask the developers who work on DirectSound, but it&#8217;s not like I have any way of finding out who they are and contacting them.</p>
<p>This website is terrific, but every time you give this pat answer, you sound condescending.  I don&#8217;t belive you intend to sound this way, but you do.  Thanks again for all the interesting and informative writing, but don&#8217;t be surprised when people ask you for help that&#8217;s really not up your alley.  We all see you as a little lifeline into a giant corporation that affects most of us every day.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239393">
				<div id="div-comment-239393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.vibrant3d.com' rel='external nofollow' class='url'>Mark Mullin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239393">
			January 5, 2005 at 1:11 pm</a>		</div>

		<p>what you say makes sense iff the kernel is &#8216;borrowing&#8217; my threads, but I don&#8217;t understand why it&#8217;s borrowing them in the first place &#8211;  does this really mean that any worker thread, say my mersenne prime hunter that never bothers anyone or asks for anything (beyond cpu cycles) may be &#8216;borrowed&#8217; by the kernel or a device driver for some nefarious and utterly unrelated purpose (never mind the debugger thread issues, I think I get those)</p>
<p>If so, why &#8211;  isn&#8217;t a thread local to a process ?  What&#8217;s the kernel want with my piddly little user processes that don&#8217;t have any resources/permissions to speak of from the kernels perspective ? Why can&#8217;t the all powerful kernel make it&#8217;s own process/threads &#8211; hell, it made mine !</p>
<p>As far as the primary subject &#8211;  this could be seen as a handy behavior for certain types of threads that are awakened on a regular basis but don&#8217;t require a high degree of reliability &#8211;  I can think of cases where iff I have a thread that dozes off regularly and gets pulsed regularly, I might not care if it ignores a pulse and keeps dozing &#8211; and the fact that the next time I wait, I&#8217;ll wait without having to worry about it being a pointless operation because I&#8217;ve already been signalled &#8211; that actually works well here</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239403">
				<div id="div-comment-239403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239403">
			January 5, 2005 at 1:22 pm</a>		</div>

		<p>Nuts. I&#8217;m actually using PulseEvent in production code, to cause one thread to kick another in response to a keypress. It&#8217;s for a hand-held device running Windows CE which has a &#8216;scan&#8217; key, but which isn&#8217;t coupled directly to the built-in barcode scanner &#8211; at least not if you don&#8217;t want your scanned characters going straight into the keyboard buffer. Instead we reprogram the keyboard driver and call the (synchronous, blocking) &#8216;start decode&#8217; method exported by the scanner device driver.</p>
<p>It&#8217;s easiest to handle the keypress from a window, so we use RegisterHotKey to get the key handled by a particular window. When the key&#8217;s pressed, we pulse an auto-reset event. If the scanner is currently enabled, the &#8216;read from scanner&#8217; thread will be blocked on the event, it&#8217;s released, and starts decoding. There&#8217;s a small race between the application enabling the scanner and the user pressing the key, and between completing one scan and being ready to trigger the next, but I don&#8217;t think this is a problem. It&#8217;s not a great hardship if we miss an event, either. However, I might think about switching to SetEvent when the key is pressed, then ResetEvent when it&#8217;s released.</p>
<p>Dave: Monitor.PulseAll is a wrapper around Monitor.ObjPulseAll, which is an internal call to the CLR internal function ObjectNative::PulseAll. This in turn wraps ObjHeader::PulseAll, which wraps SyncBlock::PulseAll. This simply sits in a loop calling SetEvent until no more threads are waiting on the object. This information can be found in the Shared Source CLI. The CLR can get away with this kind of thing precisely because it&#8217;s a managed environment and knows which threads are waiting for what.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239413">
				<div id="div-comment-239413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239413">
			January 5, 2005 at 1:23 pm</a>		</div>

		<p>If your code is running when a hardware interrupt comes in, if your code takes a page fault, if your code gets pre-empted, if your code makes a system call, use your imagination. Consult the DDK if you need more inspiration.</p>
<p>&quot;Why isn&#8217;t a thread local to a process&quot; -&gt; It is.  But maybe the kernel needs to talk to your process. (Some other process might be doing a ReadProcessMemory out of your process, so the kernel needs to get into your process so it can read the memory.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239483">
				<div id="div-comment-239483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.virtualdub.org/' rel='external nofollow' class='url'>Phaeron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239483">
			January 5, 2005 at 4:37 pm</a>		</div>

		<p>It seems to me that the natural replacement for  flawed PulseEvent()-based code would be to use a semaphore. Unfortunately, under Win32, semaphores are kernel objects and thus involve kernel transitions. It&#8217;s not that hard to write one based on event and Interlocked* APIs, but I still wonder why fast semaphores weren&#8217;t added to the API (like critical sections vs. mutexes).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239493">
				<div id="div-comment-239493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239493">
			January 5, 2005 at 4:42 pm</a>		</div>

		<p>(Events are kernel objects too, so I&#8217;m not sure what the &quot;unfortunately&quot; is all about. Your old PulseEvent code was using a kernel object already.)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239503">
				<div id="div-comment-239503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene Hamilton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239503">
			January 5, 2005 at 6:37 pm</a>		</div>

		<p>I think what he means by &quot;unfortunately&quot; is that since Semaphores involve kernel transitions, performence takes a hit. (or maybe it doesn&#8217;t?) Wouldn&#8217;t it be faster to implement something like it entirely in user mode.  Sure it can&#8217;t be used across process bounderies, but some cases it would be better to use something more light-weight.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239513">
				<div id="div-comment-239513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239513">
			January 5, 2005 at 7:21 pm</a>		</div>

		<p>1/5/2005 1:23 PM Raymond Chen</p>
<p>&gt; If your code is running when a hardware<br />
<br />&gt; interrupt comes in,</p>
<p>then it was running not waiting on an event</p>
<p>&gt; if your code takes a page fault,</p>
<p>then it was running not waiting on an event, though the first thing it might do after the page gets swapped in is begin a wait that it was attempting to do (in which case the race is due to misprogramming in the application rather than the kernel)</p>
<p>&gt; if your code gets pre-empted,</p>
<p>then it was running not waiting on an event</p>
<p>&gt; if your code makes a system call,</p>
<p>then it was running not waiting on an event unless the system call was to wait (in which case the race is due to misprogramming in the application rather than the kernel)</p>
<p>&gt; use your imagination.</p>
<p>I don&#8217;t yet see why the kernel should borrow user threads and damage the status of whether they&#8217;re waiting or not.</p>
<p>Sure just about any use of PulseEvent on an auto-reset event is likely a fundamental flaw in an application because the application is just begging to create races and damage itself.  But there are cases where PulseEvent on a manual reset event would be meaningful if the kernel didn&#8217;t damage the waiting status of threads.  Sure PulseEvent even with manual reset events has race conditions, but there are cases with manual reset events where that doesn&#8217;t matter because a thread that happens to go to sleep a millisecond later would still get its signal the next time it happens.  When the kernel steals those signals, that causes problems.</p>
<p>When does the kernel really borrow a thread that was waiting on an object, and why does the kernel do so?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239523">
				<div id="div-comment-239523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon Potter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239523">
			January 5, 2005 at 7:38 pm</a>		</div>

		<p>I don&#8217;t think Raymond was talking about when a thread was waiting on an object, I think he meant when <em>you expect</em> it to be waiting on an object. For example, your thread may have been pre-empted just before the call to WaitForSingleObject &#8211; and so it hasn&#8217;t actually entered the wait state yet, even though you may assume that it has.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239353">
				<div id="div-comment-239353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/mpll' rel='external nofollow' class='url'>Pavel Lebedinsky</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239353">
			January 5, 2005 at 12:00 pm</a>		</div>

		<p>The KB article on the subject still claims that the problem happens *only* when a debugger is attached:</p>
<p>PRB: Synchronization Failure When Debugging<br />
<br /><a target="_new" href="http://support.microsoft.com/?id=173260" rel="nofollow">http://support.microsoft.com/?id=173260</a></p>
<p>&quot;Note that this symptom is not a bug, but rather a side effect of debugging under Windows NT. There are no current plans to change this behavior. It is also important to note that this anomaly will not occur outside of a debug environment.&quot;</p>
<p>I&#8217;ll submit a change request to get this fixed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239383">
				<div id="div-comment-239383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239383">
			January 5, 2005 at 12:33 pm</a>		</div>

		<p>Instead of &quot;Ask someone from the XYZ team&quot; should I just say &quot;I don&#8217;t know&quot;?  There&#8217;s a list of Microsoft bloggers on <a target="_new" href="http://www.microsoft.com/communities/blogs/" rel="nofollow">http://www.microsoft.com/communities/blogs/</a> &#8211; there&#8217;s even a categorized search feature. I can&#8217;t point you at anyone in particular since **I don&#8217;t know either**.</p>
<p>&quot;If you don&#8217;t know a website or URL, then you can almost certainly guess that the great unwashed masses don&#8217;t know it either.&quot; -&gt; But why ask me in the first place if you know the answer is going to be &quot;How should I know?&quot;</p>
<p>I get the impression that people assume I know everything about every Microsoft technology. Which is patent nonsense. Taking an article about the kernel PulseEvent function and following up with a .NET question seems like an unfair change of topic.  Yes, .NET has something that has characteristics similar to PulseEvent &#8211; but where was the expectation created that I should anything about it?  &quot;I saw a boy that looks a lot like your son, do you know where he lives?&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239533">
				<div id="div-comment-239533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Montgomery</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239533">
			January 5, 2005 at 9:27 pm</a>		</div>

		<p>You asked, &quot; Instead of &quot;Ask someone from the XYZ team&quot; should I just say &quot;I don&#8217;t know&quot;? &quot;</p>
<p>In my opinion, yes.  What&#8217;s wrong with, &quot;I don&#8217;t know.&quot;  Say it and you come across as honest.  I tell people  &quot;I don&#8217;t know&quot; all the time.  Basically, whenever I don&#8217;t know something, that&#8217;s what I say. </p>
<p>As for being surprised that people seem to think that you know everything, well don&#8217;t be.  You know a ton about the inner workings of Windows, you&#8217;ve set yourself up as someone who has a lot to share because he knows a lot, and once again, you are most people&#8217;s sole link to the inner workings of Windows.</p>
<p>Achieving any level of visibility or fame will automatically makes you someone who people will ask questions.  I live in LA, and my vet used to appear on the morning news from time to time doing segments about pets.  I saw him on TV once, and noticed that they didn&#8217;t give the name of his veterinary practice.  I asked him why.  He told me that it was because people would see him on TV and come to him with the worst cases he had ever seen.  Folks who had been to three and four and five other vets came to him thinking that he had some sort of miracle ability becuase they had seen him on TV.  The logic was that since he was on TV, he must be the best.</p>
<p>This is you, Raymond.  For better or worse, people will continue to ask you questions about topics you know nothing about simply because you have created a level of visiblity and fame for yourself via this blog.  Probably every programmer who comes to this blog is a local IT department for friends and family.  I myself get asked all the time to help out with computer problems for which I have no knowledge or experience.  My background is PC, but Mac people are forever asking me to help because they know I&#8217;m a programmer and hardware designer.  Do I know squat about the Mac?  No, but they ask anyway because they see me as a lifeline to help them when they feel they have no other alternative.  I&#8217;m not surprised by this, and neither should you.</p>
<p>Trust me Raymond, I visit your blog every day.  I think it&#8217;s terrific.  I&#8217;m just saying that I believe that you come across as either snarky, unrealistic, or annoyed when you give the &quot;ask someone from&quot; answer.  I don&#8217;t believe it&#8217;s your intention to do so, it just feels that way.  Yes, many people are lazy and should know better, but it&#8217;s always going to be this way.  If you didn&#8217;t want to teach, share, and draw attention to yourself, then you wouldn&#8217;t have started this blog.  It&#8217;s a little bit like the actor who works to become a movie star and then when they are famous, is annoyed that they can&#8217;t have any time alone.  I think it just comes with the territory.</p>
<p>PS &#8211; I think that if you did nothing more than change your wording to, &quot;Perhaps you can find a blog with someone from the XYZ team on the following site&quot;, that it would be more useful and still allow you to tell people you don&#8217;t know something without having to say, &quot;I don&#8217;t know.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239543">
				<div id="div-comment-239543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239543">
			January 5, 2005 at 10:16 pm</a>		</div>

		<p>Um, Norman, we&#8217;re talking about different things.  I was responding to Mike Dimmick&#8217;s scenario of a thread that is purely CPU-bound.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239553">
				<div id="div-comment-239553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.foxyshadis.com' rel='external nofollow' class='url'>foxyshadis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239553">
			January 5, 2005 at 10:39 pm</a>		</div>

		<p>He&#8217;s already indicated he doesn&#8217;t care about .Net. (When someone asks me how to pull a credit report or update a listing, I tell them to call a processor, usually Karen.) He&#8217;s gruff online, and he respects people who help themselves more than people who want him to answer all the easy questions (over and over). When did taking someone on their own terms go out of style?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239563">
				<div id="div-comment-239563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/mgrier' rel='external nofollow' class='url'>Michael Grier [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239563">
			January 5, 2005 at 11:53 pm</a>		</div>

		<p>The canonical example for threads losing their order in the wait queues are SetThreadContext, GetThreadContext and suspending threads.  The first two need to actually run code on the thread in question and probably everyone would be very suprised if/when a suspended thread which had been at the head of the wait queue for an auto-reset kernel event was the thread chosen to wake.</p>
<p>This pattern is exactly how debuggers interact with their debugees, and so the easiest place to see wait reordering happen is when a process is under control of a user-mode debugger.</p>
<p>These APIs aren&#8217;t only for debuggers so you can see it otherwise.  I&#8217;m 99% certain that ReadProcessMemory/WriteProcessMemory does not run a kernel APC and thus won&#8217;t generate this behavior in general.</p>
<p>All that said, fairness is in long-term conflict with scalability.  One of the solutions to the critical section lock convoy problem is to eliminate the previous fairness guarantee that they had.  (This was being discussed; I&#8217;m not sure if it&#8217;s been implemented&#8230;)</p>
<p>Luckily most people know not to use kernel objects for synchronization when possible in highly scalable applications, so it might be a while before any fairness guarantees have to be more explicitly broken.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239573">
				<div id="div-comment-239573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://groups-beta.google.com/group/comp.arch/msg/31b02c2264e6957c' rel='external nofollow' class='url'>Oliver</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239573">
			January 6, 2005 at 3:41 am</a>		</div>

		<p>This newsgroup post seems to indicate that the NT kernel has a design flaw inherited from its VMS origins, in that APCs are conceptually invisible WRT the code originally running on the thread but &quot;damage&quot; the thread&#8217;s context (i.e., the wait state).  It suggests that a better implementation could preserve the wait state until the thread finished executing the APC then unblock if it was signalled or pulsed.</p>
<p>Mike Dimmick &#8211; isn&#8217;t a SetEvent then ResetEvent equivalent to a PulseEvent because it has the same race condition (thread may not have completed WaitForSingleObject yet) and has the same problem with APCs (signal may occur while thread is executing APC and reset may occur before APC is completed).  Doesn&#8217;t this mean that Signal-&gt;Reset does not fix the problems of PulseEvent?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239583">
				<div id="div-comment-239583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239583">
			January 6, 2005 at 5:53 am</a>		</div>

		<p>Oliver: Yes, so it&#8217;s extremely difficult to use events correctly. Condition variables are much easier to use correctly but seem to be hard to implement on Win32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239593">
				<div id="div-comment-239593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.vinnychi.com/vince' rel='external nofollow' class='url'>Vince P</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239593">
			January 6, 2005 at 5:56 am</a>		</div>

		<p>Raymond: I want to be the anti-negatron to Peter&#8217;s negatron and cancel out the negative effect.  I appreciate the time you take to do this blog and the grief it probably brings you time to time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239613">
				<div id="div-comment-239613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sources.redhat.com/pthreads-win32/' rel='external nofollow' class='url'>Oliver</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239613">
			January 6, 2005 at 6:50 am</a>		</div>

		<p>&quot;Oliver: Yes, so it&#8217;s extremely difficult to use events correctly. Condition variables are much easier to use correctly but seem to be hard to implement on Win32.&quot;</p>
<p>Yes, that&#8217;s the conclusion we (the company I work for) came to.  We now use a condition variable algorithm from the &quot;Open Source POSIX Threads for Win32&quot; group (see URL) which seems to work quite well (it&#8217;s implemented using four semaphores and a mutex/crit-sec rather than some kind of SignalObjectAndWait+event method) and we eliminate a lot more race conditions using it.</p>
<p>Does anyone know if MS intends to implement a new kernel sync object in Longhorn which fixes the problems with events (a condition variable would be an excellent choice)?  Even fixing PulseEvent and Signal-&gt;Reset so that they always works after a thread has entered a wait state would probably benefit quite a few apps that are currently only working by coincidence&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239713">
				<div id="div-comment-239713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239713">
			January 6, 2005 at 9:47 am</a>		</div>

		<p>Mike Dimmick &#8211;<br />
<br />Sounds like you could replace your code with an auto-reset Event if you really wanted to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239803">
				<div id="div-comment-239803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Montgomery</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239803">
			January 6, 2005 at 11:41 am</a>		</div>

		<p>Vince,</p>
<p>Yeah, I&#8217;m such a dick.  I told Raymond his site is terrific and that I visit it everyday, but that sometimes he comes across as something I don&#8217;t think he intends to come across as.  What was I thinking?  I praised his site and tried to help him be a slightly better person.  God, I really am an awful person.  I don&#8217;t know what came over me.  Next time I&#8217;ll just look the other way and hope everything works out for the best and not bother trying to offer any comments that might be taken negatively.  Look, the sun is shining!  The sun is shining!!<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-239943">
				<div id="div-comment-239943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://andyandy.sprayblogg.no' rel='external nofollow' class='url'>Andreas H&#228;ber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239943">
			January 6, 2005 at 6:59 pm</a>		</div>

		<p>A way to ask someone from team xyz is to use the newsgroup for the product. Often you&#8217;ll get a nice answer from someone of the relevant team. For example to contact the team creating DirectSound try <a href="news://microsoft.public.directx.audio" rel="nofollow">news://microsoft.public.directx.audio</a>.</p>
<p>Also check out <a target="_new" href="http://discuss.microsoft.com" rel="nofollow">http://discuss.microsoft.com</a> for mailinglists where you often get answers from Microsoft-people as well :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-239953">
				<div id="div-comment-239953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-239953">
			January 6, 2005 at 7:29 pm</a>		</div>

		<p>1/5/2005 7:38 PM Jon Potter</p>
<p>&gt; I don&#8217;t think Raymond was talking about when<br />
<br />&gt; a thread was waiting on an object, I think<br />
<br />&gt; he meant when <em>you expect</em> it to be waiting<br />
<br />&gt; on an object.</p>
<p>Ah, if he meant when a thread is expected to be &quot;usually&quot; waiting on an object but has a short time window when it&#8217;s not there yet.  OK, if a programmer mistakes the &quot;usually&quot; for &quot;definitely&quot; (&quot;expect_&quot;) then of course the programmer has a bug.  But I thought he meant when the thread was really waiting.</p>
<p>&gt; For example, your thread may have been<br />
<br />&gt; pre-empted</p>
<p>Sure, preemption is completely different from being borrowed.</p>
<p>&gt; just before the call to WaitForSingleObject</p>
<p>(not adding anything here, just quoting the rest of the context).</p>
<p>1/5/2005 11:53 PM Michael Grier [MSFT]</p>
<p>&gt; fairness is in long-term conflict with<br />
<br />&gt; scalability</p>
<p>Fairness isn&#8217;t completely possible anyway, even without scaling.  I usually target a kind of partial fairness.  One process (or thread or client or whatever) might get a chance to jump the queue once without being noticed or detected, but it won&#8217;t get a chance to do so twice in a row.  If you don&#8217;t succeed at all in limiting the unfairness to some degree, then some processes might starve.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240053">
				<div id="div-comment-240053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shannon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240053">
			January 7, 2005 at 5:28 am</a>		</div>

		<p>Wow, Peter.  Truly you done me a service by not ignoring Raymond&#8217;s evil trangressions like the rest of the sheep.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240103">
				<div id="div-comment-240103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240103">
			January 7, 2005 at 7:33 am</a>		</div>

		<p>Oliver: you say &quot;Signal-&gt;Reset doesn&#8217;t work always&quot;. Can you please explain what you exactly mean?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240433">
				<div id="div-comment-240433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Oliver</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240433">
			January 7, 2005 at 12:52 pm</a>		</div>

		<p>AC &#8211; if you make a call to SetEvent, immediatly followed by a call to ResetEvent then IMHO it will exhibit the same problems of PulseEvent.</p>
<p>PulseEvent has two problems &#8211; one implicit to what it does, and one caused by the design of the NT kernel.</p>
<p>The first problem is a race condition caused by the fact that you cannot necessarily be sure that the thread(s) you intend to be unblocked by the call to PulseEvent have started waiting yet.  The thread may still be in the middle of the kernel call to WaitForSingleObject (or even doing something else entirely), and so you cannot be sure that PulseEvent will have any effect (it only unblocks threads that are already waiting).</p>
<p>The second problem is where a PulseEvent has no effect, even though one or more threads ARE waiting.  This can be caused by kernel APC (Asynchronous Procedure Call &#8211; like a Unix signal or VMS AST) delivery where the kernel temporarily moves a thread out of its wait state and causes it to execute some code (e.g., I/O completion, ReadProcessMemory etc.).  While the thread is executing the arbitrary code given to it by the kernel (and is no longer doing what you programmed it do!) the thread is considered to be running, not waiting on the event anymore and hence will miss the PulseEvent (e.g., when the thread finishes executing the APC, it will go back to waiting even if it was pulsed during the APC).</p>
<p>You can replace a call to PulseEvent with a call to SetEvent followed by an immediate call to ResetEvent and it will exhibit exactly the same behaviour as PulseEvent including the two problems I just listed.  If you set then reset the event, there will be a race condition (the thread may not have entered WaitForSingleObject before you&#8217;re call to SetEvent and if it hasn&#8217;t entered the wait state before the call to ResetEvent, it will miss the wakeup) and it could also miss a wakeup even if the thread is already waiting (if the event is signalled then reset before the thread finishes an APC, it will miss the wakeup).  I personally think this should be mentioned in the documentation for PulseEvent.</p>
<p>For these reasons, IMHO kernel event synchronisation objects are a bad idea for anything that requires broadcasting notifications to multiple threads (i.e., PulseEvent) &#8211; their semantics are just too broken.  POSIX condition variables are a much more elegant and safer to solution to this problem and I really wish MS would supply something like them as part of the base Win32 API.  At least then people would not try to emulate them in various broken ways (condition variables are hard to write under Win32, but the POSIX threads on Win32 open source project has come up with a good algorithm).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240543">
				<div id="div-comment-240543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240543">
			January 7, 2005 at 10:47 pm</a>		</div>

		<p>Re 1/7/2005 12:52 PM Oliver<br />
<br />Thank you Oliver, now I understand one problem (the second of the two that you listed), though I still think the other is a problem with broken applications rather than the kernel.</p>
<p>1.  A thread is solidly waiting on an event.<br />
<br />2.  Kernel APC delivery takes the thread off of wait in order to execute kernel-provided code.<br />
<br />3.  Another thread does a PulseEvent on the desired event.<br />
<br />4.  The kernel APC completes.<br />
<br />5.  The kernel returns the victim thread to waiting on the event.</p>
<p>The breakage is caused by a race condition between the kernel&#8217;s implementation of PulseEvent and the kernel&#8217;s implementation of APC delivery.  Isn&#8217;t this easy to fix?</p>
<p>In step 2 the kernel must still be keeping a record of the fact that the victim thread was waiting for the event, since otherwise step 5 would be impossible.  So is it not possible for PulseEvent (in step 3) observe that record and modify it, so that step 5&#8242; will release the thread?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240563">
				<div id="div-comment-240563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240563">
			January 8, 2005 at 12:03 am</a>		</div>

		<p>Note: Just guessing. I don&#8217;t work on the NT kernel.</p>
<p>This assumes that PulseEvent can even see that record. My guess is that it&#8217;s just implied in a local variable on the stack somewhere.  Now, perhaps you could have PulseEvent grovel the stack of other threads, but consider: While the thread has been pulled off the wait by a kernel APC (push event state), that kernel APC itself issues a wait on some other event &#8211; during that wait, a second kernel APC borrows the thread (push event state 2), etc. If all of those events are considered to be &quot;in waiting&quot; for that thread, you now have the situation where a thread could be waiting on an unbounded number of objects (and scarier: waiting for the same event more than once?). Normally, a thread can be waiting on at most MAXIMUM_WAIT_OBJECTS objects at a time &#8211; having a fixed maximum lets you use statically-allocated memory to thread the wait list; that way you avoid encountering an out-of-memory error when trying to wait on an object.</p>
<p>(It would also mean that a thread can be in a state that is simultaneously running and blocked &#8211; try explaining that to your grandmother!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240633">
				<div id="div-comment-240633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Oliver</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240633">
			January 8, 2005 at 3:49 am</a>		</div>

		<p>Norman &#8211; as I said, the first problem I listed is not a problem with the kernel, it is a problem with PulseEvent&#8217;s semantics which make it almost impossible to use correctly (unless you use SignalObjectAndWait to ensure atomicity such that interested threads are guaranteed to be waiting before it is possible for PulseEvent to be called as Raymond suggests in his article).</p>
<p>Raymond &#8211; hmmm, hadn&#8217;t considered the reentrancy issue.  I think that still argues for deprecating PulseEvent (which has been done) and adding a condition variable sync object whose Broadcast operation is equivalent to PulseEvent but without the two problems we&#8217;ve been talking about.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240693">
				<div id="div-comment-240693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240693">
			January 8, 2005 at 9:46 am</a>		</div>

		<p>A few APIs are also documented as using kernel APCs.  See TransmitPackets() for an example.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240783">
				<div id="div-comment-240783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240783">
			January 9, 2005 at 11:11 am</a>		</div>

		<p>Oliver: I guess that &quot;SetEvent followed by an immediate call to ResetEvent&quot; is not covered by design. AFAIK that&#8217;s exactly why there are &quot;auto-reset&quot; events (second param of CreateEvent). Then the reset is done by the woken thread. Is this a solution to your problem, and if it isn&#8217;t, why?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240823">
				<div id="div-comment-240823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Oliver</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-240823">
			January 9, 2005 at 11:41 am</a>		</div>

		<p>AC &#8211; I&#8217;m not actually having any problem at all &#8211; I was responding to Mike Dimmick&#8217;s post where he suggested Set-&gt;Reset as an alternative to PulseEvent.</p>
<p>Auto-reset only works if you&#8217;re only trying to &quot;pulse&quot; a single thread.  Sure, you can create multiple events, one for each thread you wish to &quot;pulse&quot; but why bother.  The POSIX condition variable&#8217;s broadcast operation is semantically similar to PulseEvent and is not subject to these race conditions due to its atomic use of a mutex.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246183">
				<div id="div-comment-246183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Gilbert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-246183">
			January 18, 2005 at 9:05 am</a>		</div>

		<p>I did a bit of research into how exactly the .NET synchronization works. Whether it is susceptible depends on one thing: While SetEvent followed immediately by ResetEvent might occur entirely within the window in which a thread is busy with a kernel APC, if ResetEvent is not called, will the thread unblock when the kernel APC releases it?</p>
<p>.NET&#8217;s design, assuming it is relatively similar to what is released in the shared source CLI, allocates a separate kernel &#8216;Event&#8217; object for each blocked thread at any given time, and it maintains its own queue of threads waiting on an object instead of relying on such a structure in the OS.</p>
<p>So, what happens when the following sequence of events occurs?:</p>
<p>&#8211; The event is initially unsignaled.<br />
<br />&#8211; Thread #1 calls WaitForSingleObject(hEvent). It is the only thread waiting on this hEvent.<br />
<br />&#8211; A kernel APC comes barging in and steals thread #1 for a bit.<br />
<br />&#8211; While the APC is still in progress, thread #2 calls SetEvent(hEvent). It does NOT call ResetEvent(hEvent).<br />
<br />&#8211; The APC finishes.</p>
<p>Will the thread notice that the event is signalled? Or will it sit there like a zombie until the event is first Reset and then re-Set?</p>
<p>If the answer is the former, then .NET&#8217;s Monitor.Pulse is immune to the effect described in this blog entry. If it is the latter, then .NET synchronization is just as easily broken as pretty much anything you write by hand using &#8216;Event&#8217; objects.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-249933">
				<div id="div-comment-249933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pergolesi.demon.co.uk/proc/threads/ToC.html' rel='external nofollow' class='url'>Martin Harvey &lt;martin@pergolesi.demon.co.uk&gt;</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-249933">
			January 27, 2005 at 1:53 pm</a>		</div>

		<p>I might add to this issue and say that from the point of view of the user mode programmer, pulse event would be if not &quot;flawed&quot;, then distinctly unuseful even were it not for the Kernel APC issue.</p>
<p>Consider that in a WaitForXXX call, until the CPU executing that call has actually aquired the dispatcher database spinlock&#8230; and there are no guarantees on how long it will take to get to that point after having left userland. So, from the P.O.V of &quot;Mr User&quot;, trying to work out which threads are actually waiting on the lock is an exercise in unreliability *anyway*.</p>
<p>Admittedly, were it not for the APC issue, one might like to write a program where all threads have been &quot;blocked&quot; on the event for (say) 30 seconds, and pulse event might be a nice way of being able to say: &quot;let&#8217;s give them all another go at performing some work item&quot;&#8230; however, IMO, any programmer with plenty of multithreading experience worth their salt should get a prickly feeling round the back of their neck&#8230; and the thought: &quot;but you can&#8217;t prove it to be correct&quot;. IMO far better to use semaphores or event in such a way that you can sit down with a piece (or ream) of paper, and demonstrate via diagrams or whatever, that there are no holes.</p>
<p>MH.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-280423">
				<div id="div-comment-280423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2005/06/07/426296.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-280423">
			June 7, 2005 at 11:03 am</a>		</div>

		<p>Watch your access masks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-304463">
				<div id="div-comment-304463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/larryosterman/archive/2005/09/08/462477.aspx' rel='external nofollow' class='url'>Larry Osterman's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-304463">
			September 8, 2005 at 12:56 pm</a>		</div>

		<p>It&#8217;s time for another &amp;quot;APIs you never heard of&amp;quot; article :)<br />
<br />This time, I&#8217;d like to talk about the time*&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-304513">
				<div id="div-comment-304513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/larryosterman/archive/2005/09/08/462477.aspx' rel='external nofollow' class='url'>Larry Osterman's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-304513">
			September 8, 2005 at 3:04 pm</a>		</div>

		<p>It&#8217;s time for another &amp;quot;APIs you never heard of&amp;quot; article :)<br />
<br />This time, I&#8217;d like to talk about the time*&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-354043">
				<div id="div-comment-354043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/03/13/550402.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-354043">
			March 13, 2006 at 10:00 am</a>		</div>

		<p>For the same reason that PulseEvent is fundamentally flawed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-394033">
				<div id="div-comment-394033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/06/22/642849.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803#comment-394033">
			June 22, 2006 at 10:01 am</a>		</div>

		<p>Think of it as a semaphore with a maximum of one token.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

