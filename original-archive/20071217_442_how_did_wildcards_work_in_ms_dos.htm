<html>
<head>
<title>How did wildcards work in MS-DOS?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How did wildcards work in MS-DOS?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 17, 2007 / year-entry #443</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>48</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The rules were simple but led to complicated results. MS-DOS files were eleven characters long with an implicit dot between characters eight and nine. Theoretically, spaces were permitted anywhere, but in practice they could appear only at the end of the file name or immediately before the implicit dot. Wildcard matching was actually very simple....</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>The rules were simple but led to complicated results.</p>
<p> MS-DOS files were eleven characters long with an implicit dot between characters eight and nine. Theoretically, spaces were permitted anywhere, but in practice they could appear only at the end of the file name or immediately before the implicit dot. </p>
<p> Wildcard matching was actually very simple. The program passed an eleven-character pattern; each position in the pattern consisted either of a file name character (which had to match exactly) or consisted of a question mark (which matched anything). Consider the file "<code>ABCD&middot;&middot;&middot;&middot;TXT</code>", where I've used <code>&middot;</code> to represent a space. This file name would more traditionally be written as <code>ABCD.TXT</code>, but I've written it out in its raw 11-character format to make the matching more obvious. Let's look at some patterns and whether they would match. </p>
<table border="1" style="border: solid .75pt black; border-collapse: collapse" cellpadding="3">
<tr>
<th>Pattern</th>
<th>Result</th>
<th>Explanation</th>
</tr>
<tr>
<td><code>ABCD&middot;&middot;&middot;&middot;TXT</code></td>
<td>Match</td>
<td>exact</td>
</tr>
<tr>
<td><code>???????????</code></td>
<td>Match</td>
<td>all positions are a wildcard so of course they match</td>
</tr>
<tr>
<td><code>ABCD????&middot;&middot;&middot;</code></td>
<td>No match</td>
<td>space (position 9) does not match <code>T</code></td>
</tr>
<tr>
<td><code>A?CD&middot;&middot;&middot;&middot;???</code></td>
<td>match</td>
<td>perfect match at <code>A</code>, <code>C</code>, <code>D</code>,         and the spaces; wildcard match at the question marks</td>
</tr>
</table>
<p> The tricky part is converting the traditional notation with dots and asterisks into the eleven-character pattern. The algorithm used by MS-DOS was the same one used by CP/M, since MS-DOS <a href="http://blogs.msdn.com/oldnewthing/archive/2004/03/16/90448.aspx"> worked hard at being backwards compatible with CP/M</a>. (You may find some people who call this the FCB matching algorithm, because file names were passed to and from the operating system in a structure called a File Control Block.) </p>
<ol>
<li>Start with eleven spaces and the cursor at position&nbsp;1. </li>
<li>Read a character from the input.     If the end of the input is reached, then stop. </li>
<li>If the next character in the input is a dot, then     set positions 9, 10, and 11 to spaces,     move the cursor to position&nbsp;9, and go back to step&nbsp;2. </li>
<li>If the next character in the input is an asterisk, then     fill the rest of the pattern with question marks, move     the cursor to position 12, and go back to step&nbsp;2.     (Yes, this is past the end of the pattern.) </li>
<li>If the cursor is not at position&nbsp;12,     copy the input character to the cursor position and advance the     cursor. </li>
<li>Go to step&nbsp;2. </li>
</ol>
<p> Let's parse a few patterns using this algorithm, since the results can be surprising. In the diagrams, I'll underline the cursor position. </p>
<p> First, let's look at the traditional "<code>ABCD.TXT</code>". </p>
<table border="1" style="border: solid .75pt black; border-collapse: collapse" cellpadding="3">
<tr>
<th>Input</th>
<th>Pattern</th>
<th>Description</th>
</tr>
<tr>
<td></td>
<td><code><u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Initial conditions</td>
</tr>
<tr>
<td>A</td>
<td><code>A<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>B</td>
<td><code>AB<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>C</td>
<td><code>ABC<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>D</td>
<td><code>ABCD<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>.</td>
<td><code>ABCD&middot;&middot;&middot;&middot;<u>&middot;</u>&middot;&middot;</code></td>
<td>Blank out positions 9, 10, and 11 and move cursor to position 9</td>
</tr>
<tr>
<td>T</td>
<td><code>ABCD&middot;&middot;&middot;&middot;T<u>&middot;</u>&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>X</td>
<td><code>ABCD&middot;&middot;&middot;&middot;TX<u>&middot;</u></code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>T</td>
<td><code>ABCD&middot;&middot;&middot;&middot;TXT<u>&nbsp;</u></code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
</table>
<p> The final result is what we expected: <code>ABCD&middot;&middot;&middot;&middot;TXT</code>. </p>
<p> Let's look at a weird case: the pattern is <code>ABCDEFGHIJKL</code>. </p>
<table border="1" style="border: solid .75pt black; border-collapse: collapse" cellpadding="3">
<tr>
<th>Input</th>
<th>Pattern</th>
<th>Description</th>
</tr>
<tr>
<td></td>
<td><code><u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Initial conditions</td>
</tr>
<tr>
<td>A</td>
<td><code>A<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>B</td>
<td><code>AB<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>C</td>
<td><code>ABC<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>D</td>
<td><code>ABCD<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>E</td>
<td><code>ABCDE<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>F</td>
<td><code>ABCDEF<u>&middot;</u>&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>G</td>
<td><code>ABCDEFG<u>&middot;</u>&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>H</td>
<td><code>ABCDEFGH<u>&middot;</u>&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>I</td>
<td><code>ABCDEFGHI<u>&middot;</u>&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>J</td>
<td><code>ABCDEFGHIJ<u>&middot;</u></code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>K</td>
<td><code>ABCDEFGHIJK<u>&nbsp;</u></code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
</table>
<p> Sure, this was extremely boring to watch, but look at the result: What you got was equivalent to <code>ABCDEFGH.IJK</code>. The dot is optional if it comes after exactly eight characters! </p>
<p> Next, let's look at the troublesome <code>A*B.TXT</code>. </p>
<table border="1" style="border: solid .75pt black; border-collapse: collapse" cellpadding="3">
<tr>
<th>Input</th>
<th>Pattern</th>
<th>Description</th>
</tr>
<tr>
<td></td>
<td><code><u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Initial conditions</td>
</tr>
<tr>
<td>A</td>
<td><code>A<u>&middot;</u>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>*</td>
<td><code>A??????????<u>&nbsp;</u></code></td>
<td>Fill rest of pattern with question marks and move to position 12</td>
</tr>
<tr>
<td>B</td>
<td><code>A??????????<u>&nbsp;</u></code></td>
<td>Do nothing since cursor is at position 12</td>
</tr>
<tr>
<td>.</td>
<td><code>A???????<u>&middot;</u>&middot;&middot;</code></td>
<td>Blank out positions 9, 10, and 11 and move cursor to position 9</td>
</tr>
<tr>
<td>T</td>
<td><code>A???????T<u>&middot;</u>&middot;</code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>X</td>
<td><code>A???????TX<u>&middot;</u></code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
<tr>
<td>T</td>
<td><code>A???????TXT<u>&nbsp;</u></code></td>
<td>Copy to cursor and advance the cursor</td>
</tr>
</table>
<p> Notice that the result is <a href="http://blogs.msdn.com/oldnewthing/archive/2006/12/05/1211409.aspx#1212196"> the same as you would have gotten from the pattern <code>A*.TXT</code></a>. Any characters other than a dot that come after an asterisk have no effect, since the asterisk moves the cursor to position&nbsp;12, at which point nothing changes the parse state except for a dot, which clears the last three positions and moves the cursor. </p>
<p> I won't work it out here, but if you stare at it for a while, you'll also discover that <code>*.*</code> is the same as <code>*</code> by itself. </p>
<p> In addition to the rules above, the MS-DOS command prompt had some quirks in its parsing. If you typed <code>DIR .TXT</code>, the command prompt acted as if you had typed <code>DIR *.TXT</code>; it silently inserted an asterisk if the first character of the pattern was a dot. This behavior was probably by accident, not intentional, but it was an accident that some people came to rely upon. When we fixed the bug in Windows&nbsp;95, more than one person complained that their <code>DIR .TXT</code> command wasn't working. </p>
<p> The FCB matching algorithm was abandoned during the transition to Win32 since it didn't work with long file names. Long file names can contain multiple dots, and of course files can be longer than eleven characters, and there can be more than eight characters before the dot. But some quirks of the FCB matching algorithm persist into Win32 because they have become idiom. </p>
<p> For example, if your pattern ends in <code>.*</code>, the <code>.*</code> is ignored. Without this rule, the pattern <code>*.*</code> would match only files that contained a dot, which would break probably 90% of all the batch files on the planet, as well as everybody's muscle memory, since everybody running Windows&nbsp;NT&nbsp;3.1 grew up in a world where <code>*.*</code> meant <i>all files</i>. </p>
<p> As another example, a pattern that ends in a dot doesn't actually match files which end in a dot; it matches files with no extension. And a question mark can match zero characters if it comes immediately before a dot. </p>
<p> There may be other weird Win32 pattern matching quirks, but those are the two that come to mind right away, and they both exist to maintain batch file compatibility with the old 8.3 file pattern matching algorithm. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (48)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-578123">
				<div id="div-comment-578123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Puckdropper</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578123">
			December 17, 2007 at 11:18 am</a>		</div>

		<p>Goplat,</p>
<p>I just tried in in DOS 6.22 on a virtual machine, and got the same results you did. &nbsp;I wonder if DOS 5 handles it differently? &nbsp;Unfortunately, I don&#8217;t have a copy handy. &nbsp;Somewhere I&#8217;ve got DOS 3.3 on a floppy (don&#8217;t we all?) but no room to set up a machine to run it on.</p>
<p>C:WFW311&gt;dir soundrecexe</p>
<p>soundrec.exe</p>
<p>soundrec.hlp</p>
<p>C:WFW311&gt;dir soundrec.exe</p>
<p>soundrec.exe</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578153">
				<div id="div-comment-578153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578153">
			December 17, 2007 at 11:40 am</a>		</div>

		<p>Unfortunately, no one can be told how wildcards worked in MS-DOS. You have to try it for yourself.</p>
<ul>
<li>Morpheus</li>
</ul>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578173">
				<div id="div-comment-578173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578173">
			December 17, 2007 at 12:09 pm</a>		</div>

		<p>Interesting. Out of habit, I still use &quot;del .&quot; to delete everything in the current directory. I never realized that behavior was accidental.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578183">
				<div id="div-comment-578183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph S.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578183">
			December 17, 2007 at 12:20 pm</a>		</div>

		<p>I seem to remember that one could also type &quot;dir.txt&quot; which was equivalent to &quot;dir .txt&quot;. Can anyone with a copy of DOS 6.22 in a VM try it out?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578193">
				<div id="div-comment-578193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578193">
			December 17, 2007 at 12:28 pm</a>		</div>

		<p>Was the Christmas reference intentional?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578203">
				<div id="div-comment-578203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anders Tellander</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578203">
			December 17, 2007 at 12:45 pm</a>		</div>

		<p>My favourite quirk was that if you typed &quot;dir.exe&quot; (yes, without the space) this would not actually invoice an executable called &quot;dir.exe&quot;, but was in fact the same as writing &quot;dir *.exe&quot;.</p>
<p>The reason for this was of course that dir was not an exe file, but rather part of command.com itself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578213">
				<div id="div-comment-578213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">strik</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578213">
			December 17, 2007 at 12:50 pm</a>		</div>

		<p>Steve: I do not think that &quot;del.&quot; works out of an accident. &quot;.&quot; is a valid filename: The current directory. This is how that del works.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578253">
				<div id="div-comment-578253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sandeep.weblogs.us/' rel='external nofollow' class='url'>Sandeep</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578253">
			December 17, 2007 at 2:35 pm</a>		</div>

		<blockquote><p>
  If you typed DIR .TXT, the command prompt acted as if you had typed DIR *.TXT
</p></blockquote>
<p>Heh, that was one &quot;feature&quot; I depended on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578263">
				<div id="div-comment-578263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578263">
			December 17, 2007 at 2:45 pm</a>		</div>

		<p>Each DOS program that needed filename matching had to pass the pattern to FindFirstFile. Matching wasn&#8217;t built into the shell, as in Unix.</p>
<p>The fun thing about CP/M was that it had no definition, even an implicit one, of what characters were allowed in a filename. Some of the core file utilities used different rules, so you could create a file with one and be unable to use it with another.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578283">
				<div id="div-comment-578283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578283">
			December 17, 2007 at 3:13 pm</a>		</div>

		<p>Looking at the CP/M 2.2 manual, apparently there were filename rules, but I distinctly remember reading that the utilities had that problem. Maybe they weren&#8217;t following the rules, or the spec was added in v2, or someone just made it up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578293">
				<div id="div-comment-578293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.tungware.com' rel='external nofollow' class='url'>henryskoglund@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578293">
			December 17, 2007 at 3:26 pm</a>		</div>

		<p>Nowadays, you have to type</p>
<p>DIR ABCD.TXT</p>
<p>to list the file (or use wildcards), but I seem to remember, in MS-DOS it sufficed to type</p>
<p>DIR ABCD</p>
<p>to list the exact same file.</p>
<p>P.S. Slightly offtopic: one other command.com feature I miss from Win9x, the &quot;cd &#8230;&quot; command. In WinXP you have to type &quot;cd &#8230;.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578343">
				<div id="div-comment-578343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ATZ Man</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578343">
			December 17, 2007 at 4:06 pm</a>		</div>

		<p>I&#8217;m looking forward to the day when extensions aren&#8217;t needed because Posix has a widely-supported metadata API for files, backported to CP/M 2.2</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578353">
				<div id="div-comment-578353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578353">
			December 17, 2007 at 4:20 pm</a>		</div>

		<p>&quot;No, it means any file with a dot in the name.&quot;</p>
<p>But since the effect of the lookup rules is to put an implicit dot in every name that doesn&#8217;t have an explicit one, that is the same as every file. This ensures that old programs that hardcoded the dot into the pattern still work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578363">
				<div id="div-comment-578363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578363">
			December 17, 2007 at 4:21 pm</a>		</div>

		<p>Aaargh!: &nbsp;That would work great, if Windows had such a thing as a standard place to store the MIME type in the filesystem metadata per file. &nbsp;You&#8217;re thinking BeOS, or maybe OS X, or maybe also some other OS I don&#8217;t know of.</p>
<p>;-)</p>
<p>(Now, yes, you could put it in an alternate data stream &#8212; but that&#8217;s not standard.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578383">
				<div id="div-comment-578383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578383">
			December 17, 2007 at 5:36 pm</a>		</div>

		<p>Aaargh!: adding more metadata is not an easy solution, unless you think that it would be easy to update millions of programs and protocols to understand this change.</p>
<p>I mean, sure, it&#8217;s an easy feature to add, at least to Windows. NTFS already stores all kinds of metadata, you would just need a standard way to store and retrieve it. The problem is that only new programs would understand the new file type. In order to keep old programs functional, you would still have to store the extension also. It&#8217;s not just old programs though, it&#8217;s old file servers, old CDs, and so on.</p>
<p>There are things like digital cameras that believe all JPEG files to have a filename that ends in .JPG and MP3 players that look for a certain extension. How would you deal with CD-ROMs? You can&#8217;t go back and change ISO 9660, you can only extend it. Then there are protocols like FTP which don&#8217;t know anything about filesystem metadata. You would have to manually set the filetype of any file transferred. And archive formats like tar don&#8217;t support arbitrary metadata either.</p>
<p>Maybe 20 years ago when most computers were used standalone you could get away with creating a feature like this. As a matter of fact, Apple did just that. They stored the filetype as an invisible piece of metadata, and even kept other resources related to the file in a separate stream. Nowadays most Mac files use extensions to indicate filetype and have their resources in a separate file.</p>
<p>I&#8217;m not saying that you should store MIME types in filesystem metadata, I&#8217;m merely suggesting that you will never be able to get rid of extensions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578393">
				<div id="div-comment-578393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578393">
			December 17, 2007 at 6:02 pm</a>		</div>

		<p>metadata: pffft! No-one ever gets it right (if there&#8217;s a manually-entered component). At least a file extension is correct.</p>
<p>I&#8217;d guess meta-data based filesystems are inherently less effecient than an extension-based system for certain operations (whether it&#8217;d be measurable or not, I don&#8217;t know). This&#8217;d be at the CMD/API level, I doubt Explorer would be any slower. eg: &quot;dir {TextFiles}&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578403">
				<div id="div-comment-578403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger Binns</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578403">
			December 17, 2007 at 6:14 pm</a>		</div>

		<p>For win32 matches are against the long and short filenames. &nbsp;For example you could have a directory of .html files but they will match the wildcard *.htm as that is the short filename extension.</p>
<p>There are so many nooks and crannies, special cases etc when trying to be compatible with Windows wildcard matching. &nbsp;In the CIFS/SMB I worked on over a decade ago I ended rewriting the code 4 times!</p>
<p>The Samba guys got even more frustrated. &nbsp;In the end Tridge wrote a &quot;proxy&quot; server that took a wildcard pattern and sent it to various versions of Windows to see which files they returned. &nbsp;IIRC no two Windows versions behaved exactly the same, and in some cases behaved differently depending on what the client operating system was.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578413">
				<div id="div-comment-578413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ChrisMcB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578413">
			December 17, 2007 at 6:25 pm</a>		</div>

		<p>[Is there still any need for this extension weirdness ? It used to be a hack to indicate the type of file, but nowadays it&#8217;s much easier to just store e.g. mime-type in the filesystem metadata.]</p>
<p>Seems to me to be WAY easier to store this metadata with the name of the file. Perhaps we can stick it on the end of the file name. Perhaps &quot;extend&quot; the filename?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578423">
				<div id="div-comment-578423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578423">
			December 17, 2007 at 7:03 pm</a>		</div>

		<blockquote><p>
  Now, yes, you could put it in an alternate data stream &#8212; but that&#8217;s not standard.
</p></blockquote>
<p>Yes, and it brings up the question of why they were added in the first place if they weren&#8217;t meant to be used for anything except Explorer&#8217;s &quot;unsafe file that came from web&quot; dialog and Kaspersky AV checksums.</p>
<blockquote><p>
  adding more metadata is not an easy solution&#8230;
</p></blockquote>
<p>CreateFile() could have performed the work behind the change. For example, if you passed &quot;blah.avi&quot;, it could&#8217;ve just created file &quot;blah&quot; and set its metadata based on the extension. Then when you want to open &quot;blah.avi&quot;, it would just strip the &quot;.avi&quot; and convert it into proper metadata and open the matching &quot;blah&quot; file.</p>
<p>Apart from the fact that it would not work with FAT/FAT32, there is only one problem which hasn&#8217;t been solved so far in any of the filesystems I know of:</p>
<p>What if you had two &quot;blah&quot; files? Sure they would differ by metadata, but you would still have the name conflict. So far no file system supports the creation of several files with the same name which I believe is not coherent with real life.</p>
<p>So, it all boils down to the simple question &#8212; why we can&#8217;t have multiple files with the same name when it is possible to implement it?</p>
<p>I believe that in order to break free from the extension hell filesystems have to start using something else than filename to differentiate between files (for example some GUID).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578103">
				<div id="div-comment-578103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goplat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578103">
			December 17, 2007 at 11:05 am</a>		</div>

		<p>I&#8217;m getting different behavior than described here, both in command.com&#8217;s &#8220;dir&#8221; as well as in a program I wrote to show the parsed filename at address 5Dh. (The two seem mostly the same, but &#8220;dir&#8221; allows any extension if you don&#8217;t use any dots &#8211; probably fills it with question marks initially)</p>
<p>First, I can&#8217;t get that effect where ABCDEFGHIJK would run into the extension. &#8220;dir scandiskexe&#8221; shows both the .EXE and the .INI, so the extension part of the mask didn&#8217;t get touched.</p>
<p>Second, I can&#8217;t get just a single * to fill out the whole mask &#8211; though in &#8220;dir&#8221; there&#8217;s no way to tell since it initializes the extension to question marks anyway, if you pass * to a program it receives in address 5D just eight question marks, and &#8220;del *&#8221; only deletes files without an extension.</p>
<p>Third, I can&#8217;t get the dot to move the position backwards to the start of the extension &#8211; *.foo.bar acts identical to *.foo.</p>
<p>Of course there are other DOS programs that do their own mask parsing and might work differently but this is what I&#8217;ve gotten from COMMAND.COM in both DOS and the Windows VDM. What program and version were you using?</p>
<div class=post>[<i>I tested on CP/M 2.2; I never noticed any discrepancy between MS-DOS&#8217;s parser and CP/M&#8217;s but I guess there is. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578113">
				<div id="div-comment-578113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Puckdropper</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578113">
			December 17, 2007 at 11:08 am</a>		</div>

		<p>A*B.txt = A*.txt</p>
<p>Yep, I remember stuff like that. &nbsp;I was quite happy to find out that Windows command line interpreted A*B to mean A{anything in between}B rather than A{Anything} .</p>
<p>Interesting to find out how it worked.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578443">
				<div id="div-comment-578443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roger Binns</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578443">
			December 17, 2007 at 7:13 pm</a>		</div>

		<p>See the first 2.5 pages of this <a rel="nofollow" target="_new" href="http://us1.samba.org/samba/ftp/slides/cifs2000_tridge.pdf" rel="nofollow">http://us1.samba.org/samba/ftp/slides/cifs2000_tridge.pdf</a> from 2000. &nbsp;Basically if you don&#8217;t get wildcards exactly right then various programs break. &nbsp;It also turns out that there are 5 wildcard characters, not just * and ? as detailed above and in the CIFS spec.</p>
<p>Metadata can be stored elsewhere. &nbsp;You have alternate data streams in NTFS, extended attributes in OS/2 and data forks in Mac/HFS. &nbsp;BeOS also used a similar concept to store mime type information. &nbsp;</p>
<p>The problem is that interchange with others treats files as a stream of bytes plus some meta information &#8211; name and dates usually. &nbsp;So you could make your email clients, zip programs, web servers etc also use/provide the extra information but people on other platforms will either not see that extra information, or be unable to process the files correctly. &nbsp;(Ever see HQX files outside of the Mac world?)</p>
<p>MacOS X tried to solve the problem in a compatible fashion with .DS_store folders. &nbsp;See <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/.DS_Store" rel="nofollow">http://en.wikipedia.org/wiki/.DS_Store</a> and Google it to see how much grief it also causes.</p>
<p>Something else they did nicely on MacOS X is to make extensions meaningful on directories (actually borrowed from Next). &nbsp;Applications are basically a directory structure where the top level directory has an extension of .app. &nbsp;That allows you to trivially move it around, uninstall by deleting it etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578463">
				<div id="div-comment-578463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578463">
			December 17, 2007 at 7:38 pm</a>		</div>

		<p>Roger: the extra wildcard characters are, IIRC, &quot;DOS dot&quot;, &quot;DOS asterisk&quot; and &quot;DOS question mark&quot;, which emulate the DOS quirks Raymond explained. They are documented in the IFS SDK (<a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/ms795371.aspx" rel="nofollow">http://msdn2.microsoft.com/en-us/library/ms795371.aspx</a>)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578473">
				<div id="div-comment-578473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578473">
			December 17, 2007 at 7:55 pm</a>		</div>

		<p>steveg: &quot;At least a file extension is correct.&quot;</p>
<p>I want to move to your planet.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578483">
				<div id="div-comment-578483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">edlin ftw</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578483">
			December 17, 2007 at 7:56 pm</a>		</div>

		<p>&quot;dir.txt&quot; worked because in command.com &quot;.&quot; was a delimiter. Similarly, &quot;echo.&quot; printed a blank line.</p>
<p>I was bitten by this in cmd too :p</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578163">
				<div id="div-comment-578163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ScottR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578163">
			December 17, 2007 at 12:04 pm</a>		</div>

		<p>I *so* miss being able to type &quot;dir .txt&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-578493">
				<div id="div-comment-578493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578493">
			December 17, 2007 at 9:42 pm</a>		</div>

		<p>KJK::Hyperion: I think Roger&#8217;s point is that the implementation differs from the documentation. Have a look at the document he posted: &quot;The CIFS documentation dismisses these three extra wildcard characters by providing a very simple mapping between these characters and the usual * and ? characters. Unfortunately this simple mapping is so simple because it is completely incorrect, as a few minutes of testing confirms.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578233">
				<div id="div-comment-578233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578233">
			December 17, 2007 at 1:58 pm</a>		</div>

		<p>Where did the globbing take place ? </p>
<p>IIRC &#8216;dir&#8217; was a built in command, but what happend if you did &quot;someapp.exe *.txt&quot; </p>
<p>Would someapp.exe see &quot;*.txt&quot; as it&#8217;s first argument or would it see &quot;1.txt&quot; &quot;2.txt&quot; (whatever was in the directory) as it&#8217;s arguments ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578303">
				<div id="div-comment-578303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.tungware.com' rel='external nofollow' class='url'>henryskoglund@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578303">
			December 17, 2007 at 3:37 pm</a>		</div>

		<p>Oh, I forget to mention my favorite CP/M wildcard parsing feature:</p>
<p>Guest what happened if you typed</p>
<p>*</p>
<p>on the command line?</p>
<p>Yep, it invoked the first executable file found in the current directory. Made for a thrilling life. Needless to say, *that* particular feature was not ported to QDOS/PC-DOS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578313">
				<div id="div-comment-578313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jcoby</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578313">
			December 17, 2007 at 3:41 pm</a>		</div>

		<p>I&#8217;ve seen other oddities in filename matching. &nbsp;Recently, we had a HDD formatted as NTFS with 99 directories, each with about 45k files, all with numeric filenames. &nbsp;This, of course, is very slow to deal with. &nbsp;So I tried to break up the directories even further by moving files with the same first digit into their own sub-directories. &nbsp;To figure out what to move, I ran:</p>
<p>dir 1*.jpg</p>
<p>This, for whatever reason, is equivalent to:</p>
<p>dir *1*</p>
<p>But apparently only when you hit some magical threshold for number of files in a directory (smaller test cases worked perfectly).</p>
<div class=post>[<i>Interesting but incorrect theory. I discussed this <a href="http://blogs.msdn.com/oldnewthing/archive/2005/07/20/440918.aspx" rel="nofollow">two years ago</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578323">
				<div id="div-comment-578323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578323">
			December 17, 2007 at 3:42 pm</a>		</div>

		<p>Why is the behaviour in Win32 considered as quriks? </p>
<p>*.* simply means exactly this: any filename, any extension. Of course this includes all files with no extension. The dot simply serves as delimiter between the filename and the extension, and it&#8217;s only natural that this separation is implied in the Win32 subsystem.</p>
<div class=post>[<i>That may be what you think it means, but a literal reading of the wildcard rules (before the quirks are applied) says that &#8220;*.*&#8221; means any string (*), followed by a period (.), followed by any string (*). The non-quirk wildcard rules don&#8217;t know what an &#8220;extension&#8221; is. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578333">
				<div id="div-comment-578333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaargh!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578333">
			December 17, 2007 at 3:56 pm</a>		</div>

		<p>&quot;*.* simply means exactly this: any filename, any extension. Of course this includes all files with no extension. The dot simply serves as delimiter between the filename and the extension, and it&#8217;s only natural that this separation is implied in the Win32 subsystem.&quot;</p>
<p>No, it means any file with a dot in the name. Wasn&#8217;t the whole filename dot extension thing dropped in Win95 when LFN&#8217;s where introduced ? A filename is just a string and it could have one or more dot&#8217;s in it.</p>
<p>Is there still any need for this extension weirdness ? It used to be a hack to indicate the type of file, but nowadays it&#8217;s much easier to just store e.g. mime-type in the filesystem metadata. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578373">
				<div id="div-comment-578373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jcoby</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578373">
			December 17, 2007 at 4:27 pm</a>		</div>

		<p>[Interesting but incorrect theory. I discussed this two years ago. -Raymond]</p>
<p>Interesting. &nbsp;If memory serves me, it did the same thing for 2*, 3*, up to 9*. &nbsp;There was a very good chance for 8-char conflicts (each file was a 7-digit id, followed by a dash, followed by a sequence number). &nbsp;Each of the 99 directories broke the file names up by the last two digits of the 7-digit ID.</p>
<p>In the end, we could not find any way to break the contents up by filename from the command line. &nbsp;Using Explorer wasn&#8217;t an option &#8211; that HDD brought every computer it touched to its knees.</p>
<p>25GB of images at about 12k each across 99 directories. &nbsp;NTFS wasn&#8217;t really happy with it.</p>
<div class=post>[<i>NTFS inherently is fine with that much data. You may have had better luck if you had disable 8.3 filename generation. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578513">
				<div id="div-comment-578513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foxyshadis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578513">
			December 18, 2007 at 1:18 am</a>		</div>

		<p>&quot;I&#8217;d guess meta-data based filesystems are inherently less effecient than an extension-based system for certain operations&quot;</p>
<p>Macs do fine with resource forks, it&#8217;s not a big deal. Looking shell handlers up in the registry and initializing them is orders of magnitude slower. The real crying shame is that attributes aren&#8217;t extracted to ADS as soon as they&#8217;re scanned &#8211; photo, music, and movie metadata in particular is crazy slow because it has to be re-extracted every time explorer&#8217;s cache is invalidated.</p>
<p>Hmm, sounds like a good idea for a custom shell extension, overriding the default shmedia.dll.</p>
<p>&quot;You can&#8217;t go back and change ISO 9660, you can only extend it.&quot;</p>
<p>Thankfully UDF has completely displaced ISO in all but the oldest equipment, even if most discs still have ISO/Joliet fallbacks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578523">
				<div id="div-comment-578523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">not gary kildall</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578523">
			December 18, 2007 at 2:10 am</a>		</div>

		<p>&quot;MS-DOS worked hard at being backwards compatible with CP/M.&quot;</p>
<p>That&#8217;s putting it rather charitably.</p>
<p><a rel="nofollow" target="_new" href="http://www.businessweek.com/magazine/content/04_43/b3905109_mz063.htm" rel="nofollow">http://www.businessweek.com/magazine/content/04_43/b3905109_mz063.htm</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578533">
				<div id="div-comment-578533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578533">
			December 18, 2007 at 3:02 am</a>		</div>

		<p>@not gary kildall</p>
<p>It&#8217;s not illegal to reverse engineer something and then emulate it, unless it&#8217;s patented. Which CPM wasn&#8217;t, as far as I can tell.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578453">
				<div id="div-comment-578453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miral</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578453">
			December 17, 2007 at 7:17 pm</a>		</div>

		<p>My (admittedly possibly fuzzy) recollection has it that *.* and * behaved differently in *some* version of DOS &#8212; although I&#8217;m certain that they were identical in DOS 7 (aka Win95).</p>
<p>Then again, maybe I&#8217;m just getting it confused with &quot;*.&quot;, which I&#8217;m certain meant &quot;files with no extension&quot; (and agrees with the rules Raymond&#8217;s posted).</p>
<p>The space character thing was quite useful; I recall a common trick for copy-protection and the like was to create a file with a space or char-255 (which looked like a space) somewhere in the middle of the filename. &nbsp;DOS didn&#8217;t care, it could let a program open and read the file just fine, but it made it trickier to deal with it on the command line, since many utilities wouldn&#8217;t accept wildcards and the filename-quoting thing hadn&#8217;t become generally established yet.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578503">
				<div id="div-comment-578503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578503">
			December 17, 2007 at 11:26 pm</a>		</div>

		<p>&quot;So, it all boils down to the simple question &#8212; why we can&#8217;t have multiple files with the same name when it is possible to implement it?&quot;</p>
<p>&#8211; It makes command-line file utilities impossible.*</p>
<p>&#8211; It breaks file operations in every programming language that has them.*</p>
<p>* Unless you&#8217;re prepared to use a filename syntax even worse than the one in VMS.</p>
<p>In case you&#8217;re wondering who&#8217;s _really_ to blame for all this &quot;filename extension&quot; business:</p>
<p>&#8211; Gary Kildall got it from the DEC PDP operating systems.</p>
<p>&#8211; DEC got it from CTSS, which created the modern concept of a file system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578583">
				<div id="div-comment-578583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578583">
			December 18, 2007 at 1:13 pm</a>		</div>

		<p>Oh yes please, let&#8217;s interrupt this discussion of Windows technical details to rehash myths and legends about what happened in 1980.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578713">
				<div id="div-comment-578713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578713">
			December 18, 2007 at 5:05 pm</a>		</div>

		<p>It always is good to learn something, but in this case, I will stick to what i already knew as the answer to &quot;Q: How did wildcards work in MS-DOS?&quot;. It is shorter, reasonably correct for anybody who did not use MS-DOS that much, and way easier to remember: &quot;A: Not&quot; :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578623">
				<div id="div-comment-578623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Elliott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578623">
			December 18, 2007 at 2:15 pm</a>		</div>

		<p>Further to Goplat&#8217;s comment, the parsing in CP/M 2.2 and MS-DOS 5 seems to be the same, but not what is described in the original article. (I&#8217;m using CP/M 2.2 under the z80pack emulator, <a rel="nofollow" target="_new" href="ftp://ftp.unix4fun.org/z80pack/" rel="nofollow">ftp://ftp.unix4fun.org/z80pack/</a> ). </p>
<p>Using underlines instead of spaces:</p>
<p>ABCDEFGHIJKL goes to ABCDEFGH___</p>
<p>* goes to ????????___</p>
<p>*.* goes to ???????????</p>
<p>.TXT goes to ________TXT</p>
<p>(This is looking at the parsed filename at 5Ch.)</p>
<p>Other notes:</p>
<p>In CP/M 2.2, DIR .TXT behaves like a naked DIR and lists all files (because if the first character in the FCB is a space, it replaces the whole FCB with ???????????). So that behaviour must have been introduced in MS-DOS.</p>
<p>Source for the CP/M parser is actually available (os2ccp.asm in cpm2src.zip on the above site; start at setname:). It has separate loops for the first 8 characters and the last 3.</p>
<p>In CP/M 2, the parser wasn&#8217;t available to application programs, so if a program wanted more than the two filenames at 5Ch and 6Ch it would have to roll its own, which probably didn&#8217;t follow the same rules.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578723">
				<div id="div-comment-578723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578723">
			December 18, 2007 at 5:15 pm</a>		</div>

		<p>I&#8217;m glad to see other commenters picked up on some of the things I noticed (* matches the same as *., not *.* in MS-DOS 6, if a dot isn&#8217;t present in a filename it&#8217;s implied at the end, before the dot is clipped to 8 chars, after the dot is clipped to 3).</p>
<p>One thing that wasn&#8217;t is &quot;spaces were permitted anywhere&quot;. &nbsp;I&#8217;m pretty sure they weren&#8217;t, because there was no quoting to enclose path names with spaces in those days. &nbsp;Short file names generated from LFNs have the spaces stripped out.</p>
<p>Once, my brother managed to save a file on an MS-DOS system with a space in the name. &nbsp;It created havoc! &nbsp;Any program that tried to open the file could not (which was why he asked for help).</p>
<p>I tried both MS-DOS commands and Windows 3.1 File Manager. &nbsp;Both DIR and FILEMAN would display the file correctly, but interacting with it would result in an error. &nbsp;DEL assumed you were trying to pass it TWO filenames and would of course not find either (or did it just ignore the second parameter? &nbsp;Whatever). &nbsp;Fileman probably did something similar internally.</p>
<p>I don&#8217;t believe substituting a ? for the space worked either, although I&#8217;m not sure now (happened a looong time ago). &nbsp;I think I eventually got rid of it by making a mask with a * at the end before or at the space&#8217;s position. &nbsp;IE if it was SOM FILE.EXT I did &quot;del so*.ext&quot;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578893">
				<div id="div-comment-578893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578893">
			December 19, 2007 at 7:18 am</a>		</div>

		<p>So, at the risk of being obvious, one of Raymond&#8217;s test cases was ABCDEFGHIJKL, which turned into ABCDEFGH.IJK, thus, No(e)L.</p>
<p>Merry Christmas!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-578903">
				<div id="div-comment-578903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sascha</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578903">
			December 19, 2007 at 7:46 am</a>		</div>

		<p>@Dan</p>
<p>&quot;spaces where permitted&quot; on the file system, they where still accessible for the normal api&#8217;s.</p>
<p>of course all command line parsers where unable to handle such a name.</p>
<p>having a file named &quot;con&quot; on the filesystem was worse ^^</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-578923">
				<div id="div-comment-578923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-578923">
			December 19, 2007 at 9:25 am</a>		</div>

		<p>Actually neil it turns into ABCDEFGH. :( &nbsp;When no dot is specified, it&#8217;s assumed to be on the end. &nbsp;And of course anything before it is cropped to three characters.</p>
<p>sascha: there&#8217;s &quot;nul&quot; and &quot;com#&quot; and &quot;lpt#&quot; and &quot;prn&quot; too (prn maps to lpt1 IIRC).</p>
<p>nul was good for detecting directory existence in batch files (IF EXIST dirnamenul etc). &nbsp;prn/lpt# was for redirecting output to the printer.</p>
<p>Con was also useful for input as well as output (copy con file.ext == a more usable text editor than vi! &lt;/hatingvi&gt; CTRL+Z to signal end of file to copy. &nbsp;copy file.ext con == type file.ext).</p>
<p>And by &quot;API&quot; I assume you mean BIOS interrupts or however the OS did it&#8217;s magic because all you ready had were your standard C (which for the filesystem meant fopen() etc). &nbsp;No WinAPI, or DOSAPI for that matter. &nbsp;IIRC. &nbsp;I didn&#8217;t really do a lot of C when I was 8.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579003">
				<div id="div-comment-579003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-579003">
			December 19, 2007 at 1:07 pm</a>		</div>

		<p>Dan: DOS APIs in this case refer to Int 21h, which was how you called into that part of the OS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-579223">
				<div id="div-comment-579223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-579223">
			December 20, 2007 at 9:18 am</a>		</div>

		<p>And for terminally stuck files, there was always Norton Disk Edit, which let you edit the dir entries byte-by-byte. And the FAT. And the partition table. It really helped me when I had to tend to 20 CIH-virus victims (which overwrote the MBR).</p>
<p>I miss the simpler times, when a binary disk editor was all you needed to really understand what&#8217;s going on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-579233">
				<div id="div-comment-579233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">no space</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071217-00/?p=24143#comment-579233">
			December 20, 2007 at 9:50 am</a>		</div>

		<p>&quot;dir.txt&quot; was very useful, to bad cmd doesn&#8217;t have this capability.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

