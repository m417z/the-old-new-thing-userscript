<html>
<head>
<title>What's so special about bitmaps and DCs?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>What&#8217;s so special about bitmaps and DCs?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>May 1, 2006 / year-entry #151</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>31</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">You can select pens, brushes, fonts and bitmaps into a DC with the SelectObject function, and from this list, bitmaps are special. Because, if you look carefully, bitmaps are the only modifiable objects on the list. Pens, brushes and fonts cannot be modified once they are created. But bitmaps, oh, bitmaps. A bitmap selected into...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>You can select pens, brushes, fonts and bitmaps into a DC with the <code>SelectObject</code> function, and from this list, bitmaps are special. Because, if you look carefully, bitmaps are the only modifiable objects on the list. Pens, brushes and fonts cannot be modified once they are created.</p>
<p> But bitmaps, oh, bitmaps. A bitmap selected into a DC changes as you draw into it. Selecting a bitmap into multiple DCs means that writing to the bitmap from one DC secretly changes it in another, which isn't a very nice thing to do to a DC. </p>
<p> So let's see, you can select pens, brushes, and fonts into multiple DCs, but you can't do it with bitmaps. Coincidence? You make the call. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (31)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-375503">
				<div id="div-comment-375503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375503">
			May 1, 2006 at 10:13 am</a>		</div>

		<p>except for the stock bitmap.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375633">
				<div id="div-comment-375633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375633">
			May 1, 2006 at 2:14 pm</a>		</div>

		<p>Frankly, I think the behavior of SelectObject is really kind of strange all around, and stems from an era where API designs weren&#8217;t planned around type-safe languages: &nbsp;SelectObject looks strikingly like it was designed to be called from assembly language. &nbsp;In a type-safe language, there&#8217;d be separate functions named SelectPen and SelectBrush and SelectBitmap for this, and, in fact, having designed it that way would have probably made GDI more efficient: &nbsp;It should be fairly obvious that somewhere deep inside SelectObject there&#8217;s a big switch() statment to handle all the different kinds of things it can be given, or a call-by-pointer &#8212; both of which would be unnecessary code with separately-named API calls.</p>
<p>Worse, though, this one-size-fits-all approach pervades Windows&#8217; entire design: &nbsp;Consider the semantics of CloseHandle or GetStockObject or even SetWindowLong/GetWindowLong. &nbsp;For all of these to work correctly, there must be a big switch statement in there or a call-by-pointer (or, in the case of SWL/GWL, if no switch statement, some serious parameter-validation code). &nbsp;These switch statements are, effectively, useless computation: &nbsp;Clock cycles that must be wasted solely because of the API design.</p>
<p>But, alas, what&#8217;s done is done, and Windows&#8217; design remains weird, with a lot of lingering quirky special cases like this one. &nbsp;But there&#8217;s hope on the horizon: &nbsp;The API designs &lt;b&gt;will&lt;/b&gt; be better in Vista, won&#8217;t they, Raymond?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375663">
				<div id="div-comment-375663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375663">
			May 1, 2006 at 2:45 pm</a>		</div>

		<p>&quot;Selecting a bitmap into multiple DCs&quot;</p>
<p>I know it&#8217;s bad form, but is this even legal under Win32?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375673">
				<div id="div-comment-375673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dean Earley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375673">
			May 1, 2006 at 3:12 pm</a>		</div>

		<p>mschaef, isn&#8217;t that the whole point of this post?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375703">
				<div id="div-comment-375703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KiwiBlue</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375703">
			May 1, 2006 at 4:02 pm</a>		</div>

		<p>SeanW wrote:<br />
<br />&quot;It should be fairly obvious that somewhere deep inside SelectObject there&#8217;s a big switch() statment to handle all the different kinds of things it can be given, or a call-by-pointer &#8212; both of which would be unnecessary code with separately-named API calls.&quot;</p>
<p>Ok, so how much performance would you gain by eliminating the indirect (&quot;by-pointer&quot;) call?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375713">
				<div id="div-comment-375713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cvbcvb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375713">
			May 1, 2006 at 4:06 pm</a>		</div>

		<p>plz don&#8217;t touch CloseHandle it goes out from nice design of object-oriented NT kernel and has no realtionship with weaky user32 sbusystem (that placed in win32k.sys). Thereis no switch inside of CloseHandle. Thereis NT object manager that looks appropriate object in its table and calls callback routines to close it (really there was developed C analogue of virtual objects inheritance).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375743">
				<div id="div-comment-375743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cvbcvb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375743">
			May 1, 2006 at 5:07 pm</a>		</div>

		<p>Firstly. Go away from win32 for a bit of time.<br />
<br />CloseHandle calls ZwCloseHandle routine that closes all kinds of NT kernel objects. It means &#8211; files, security descriptors, synchronisation objects, registry keys (yeah, advapi32 sometimes gives you fake handles that are not really kernel objects handles, both as FindFirstFile gives you some userspace stuff pointer that can be closed only by FindClose, that internally cleanup this stuff and calls ZwCloseHandle).<br />
<br />NT layer API are very generic and logical. Its design more better than win32 on my point of view. The crookedness starts immideately after ntdll.dll code and gets its maximum in user32 :)<br />
<br />The reason why you can&#8217;t pass GDI/USER handles to CloseHandle is a GDI/USER subsystems didn&#8217;t originally written to be kernel-level code and don&#8217;t interract with kernel object manager. Obviously there was a war between NT kernel team and team that put user subsystem into kernel space :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375753">
				<div id="div-comment-375753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cvbcvb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375753">
			May 1, 2006 at 5:10 pm</a>		</div>

		<p>btw i&#8217;m still doesn&#8217;t understand why FindClose was so neccessary :. I can implement FindFirstFile..etc using only nt api without keeping intermediate data in userspace.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375783">
				<div id="div-comment-375783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cvbcvb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375783">
			May 1, 2006 at 5:43 pm</a>		</div>

		<p>OK. Win32 API has poor design, I agree :)<br />
<br />But root@evil is that this API consists of many different onceptual parts that &quot;tried&quot; to interrogate each with other.<br />
<br />PS About linux&#8217;s kernel &#8211; it uses same pseudo-virtual inheritance when handling close (and other calls) ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375813">
				<div id="div-comment-375813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">alexandre.r.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375813">
			May 1, 2006 at 6:43 pm</a>		</div>

		<p>cvbcvb wrote:<br />
<br /> &nbsp; &nbsp;NT layer API are very generic and logical.<br />
<br /> &nbsp; &nbsp;Its design more better than win32 on my<br />
<br /> &nbsp; &nbsp;point of view. The crookedness starts<br />
<br /> &nbsp; &nbsp;immideately after ntdll.dll code and gets its<br />
<br /> &nbsp; &nbsp;maximum in user32 :)</p>
<p>In other words, the &quot;quality&quot; of the design of an API is inversely proportional to the number of people that uses it. I don&#8217;t believe this to be a coincidence&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375823">
				<div id="div-comment-375823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cvbcvb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375823">
			May 1, 2006 at 7:30 pm</a>		</div>

		<p>&quot;generic and logical&quot; not always simple in use. UNICODE_STRING, IO_STATUS_BUFFER and 5+ parameters in functions are not very friendly&#8230; But all other API are based on them (not including user32 calls).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375863">
				<div id="div-comment-375863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cvbcvb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375863">
			May 1, 2006 at 8:59 pm</a>		</div>

		<p>wow. try<br />
<br />#define CloseKernelObjectHandle CloseHandle</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375883">
				<div id="div-comment-375883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375883">
			May 1, 2006 at 10:51 pm</a>		</div>

		<p>The problem isn&#8217;t with CloseHandle. &nbsp;The problem is with functions handing out handles that can&#8217;t be closed with it. &nbsp;Or perhaps that there is no way to create a CloseHandle-able handle is user space?</p>
<p>Or would you also complain about IUnknown::Release?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375733">
				<div id="div-comment-375733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375733">
			May 1, 2006 at 4:49 pm</a>		</div>

		<p>KiwiBlue: &nbsp;You only gain a few clock cycles by eliminating the indirect call (although there might be a slightly higher gain on modern processors, since the branch-predictor wouldn&#8217;t get so confused by it). &nbsp;Some might say, &quot;Well, so what? &nbsp;It&#8217;s only a few clocks.&quot; &nbsp;But this is a circumstance where the clock cycles didn&#8217;t *need* to be wasted; an alternate design could&#8217;ve avoided that loss *and* been easier to use and to understand. &nbsp;That said, that&#8217;s a few wasted clock cycles for almost every single WM_PAINT message, and that adds up over time, particularly with modern opaque-dragging and opaque-resizing techniques.</p>
<p>cvbcvb: Remember that &quot;nice&quot; is in the eye of the beholder. &nbsp;NT is an object-oriented design built on top of a non-object-oriented language (C). &nbsp;C code should use C techniques; and C++ code should use C++ techniques. &nbsp;When you have conceptual overlap, you get messes like NT handles or Xt widgets. &nbsp;CloseHandle, by attempting to be all things to all handles, falls into the peril that programmers can assume it really *is* all things to all handles, and try to use it to close a handle that doesn&#8217;t work. &nbsp;You can&#8217;t feed it any handles from USER or GDI or ADVAPI, and there are even kernel objects that can&#8217;t be destroyed with it (hence the need for functions like DeleteCriticalSection, DeleteAtom, and HeapDestroy). &nbsp;Having a function like CloseHandle should really be an all-or-nothing proposition in framework design: &nbsp;Either design the function to be a true abstract multimethod that any object can take advantage of, it shouldn&#8217;t be included at all, and there should be separate private methods for each type. &nbsp;Anything in between might *seem* elegant, but it frequently just engenders confusion among lesser-skilled programmers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kjkhyperion even thread-even depth-1" id="comment-375893">
				<div id="div-comment-375893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375893">
			May 2, 2006 at 12:27 am</a>		</div>

		<p>cvbcvb: FindClose is required because FindFirstFile opens a handle to the directory, and FindNextFile needs it open</p>
<p>Sean: the fact that certain handles cannot be passed to CloseHandle should alone be a big hint that they aren&#8217;t &quot;kernel&quot; objects. Also atoms aren&#8217;t objects, they are properties of a single object (the handle table), inaccessible from user mode. And Win32 has lived quite fine without an NT kernel for years, thank you. It&#8217;s rather NT that picked up bad habits from Win32, I&#8217;d say &#8211; OS/2 looked much more &quot;NT-ish&quot; than Win32</p>
<p>josh: the Toolhelp32 API is the only user-mode API that creates handles that can be closed with CloseHandle. The trick is simple: the handle refers to a section object, that contains all the data that was captured in CreateToolhelp32Snapshot. The drawbacks to this approach compared to simply allocating heap memory and returning its pointer as a &quot;handle&quot; are added complexity and a lot of overhead in terms of memory usage</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375773">
				<div id="div-comment-375773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375773">
			May 1, 2006 at 5:36 pm</a>		</div>

		<p>cvbcvb: &nbsp;I *am* looking at it from a non-Win32 perspective; I&#8217;m comparing it to a dozen other operating system designs, as well as dozens of frameworks in a dozen different languages, and ot framework design in general. &nbsp;An OS API is a framework, and as framework designs go, Win32 as a *whole* is not that impressive. &nbsp;You can&#8217;t separate the NT kernel from Win32 &#8212; yes, you can do it programmatically, but the two products are never shipped separately, and their manufacturer would like us to think of them as a single unit (hence the very large public documentation on Win32 and the very minimal public documentation on the NtXxx and ZwXxx functions). &nbsp;The API that is exposed is Win32, so that&#8217;s the one I&#8217;m commenting on; whether the underlying implementation of CloseHandle() is NtCloseHandle() or a Linux kernel&#8217;s close() or a Mach kernel&#8217;s close() isn&#8217;t really relevant, because that&#8217;s not the exposed API. &nbsp;Regardless of the underlying implementation, the exposed API is not clean and orthogonal: &nbsp;There are a hundred types of handles in Win32, and CloseHandle can only deal with about a dozen of them. &nbsp;That&#8217;s not a very good design.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375793">
				<div id="div-comment-375793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375793">
			May 1, 2006 at 6:23 pm</a>		</div>

		<p>I didn&#8217;t say that pseudo-virtual inheritance is necessarily wrong: &nbsp;Just that it&#8217;s often (usually) misused. &nbsp;In the case of Win32, if you&#8217;re going to have a function named CloseHandle(), its name strongly implies that it closes handles &#8212; *all* handles. &nbsp;A Un*x-flavored close() system call can close any file descriptor, no matter where it came from. &nbsp;Granted, FDs share a smaller scope than Win32 handles do, but you can use a close() system call to close just about anything that the kernel can open, be it a file, a network port, or a serial connection to a toaster oven. &nbsp;I&#8217;m a strong proponent of naming functions after what they do, and close() closes &#8212; just about anything, as its name implies. &nbsp;CloseHandle() closes &#8212; but it only works on about one out of every ten handles you encounter, which I consider a pretty severe design flaw. &nbsp;If it was only supposed to close kernel handles, it should&#8217;ve been named CloseKernelHandle().</p>
<p>(In the meme of naming functions after their actions, what does this imply SelectObject would &quot;naturally&quot; do? &nbsp;Near as I can figure, it would be a function that would award a prize to the best chunk of code and data given to it&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kjkhyperion odd alt thread-odd thread-alt depth-1" id="comment-375903">
				<div id="div-comment-375903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375903">
			May 2, 2006 at 2:15 am</a>		</div>

		<p>By the way, I think you can indirectly select the same bitmap in two DCs, or even share the a bitmap between processes, by creating two different DIBs from the same section (or two sections mapping the same area of the same file, or whatever level of indirection at which GDI stops caring). Sharing video surfaces seems to be a big taboo, IIRC it&#8217;s still not &quot;legal&quot; in DirectX 10 (which introduces virtual video memory)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-375833">
				<div id="div-comment-375833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375833">
			May 1, 2006 at 8:19 pm</a>		</div>

		<p>Sean W: I would say that CloseHandle is a BETTER name than the Unix &quot;close&quot;. CloseHandle at least implies that it closes *handles*, whereas what does &quot;close&quot; close? Files? sockets? Doors? Books?</p>
<p>You argue that CloseHandle should be named &quot;CloseKernalHandle&quot; (because that&#8217;s what it does), but wouldn&#8217;t that logic also say that &quot;close&quot; should be called &quot;close_file_descriptor&quot;?</p>
<p>Oh, and having one entry-point do multiple things saves space in your DLLs import table, which in turn decreases your working set. That may give you better performance than avoiding some imagined &quot;call-by-pointer&quot; (which any call into a DLL is essentially, anyway)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375853">
				<div id="div-comment-375853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375853">
			May 1, 2006 at 8:54 pm</a>		</div>

		<p>Dean: CloseHandle() is a better name than close() in some ways, but it&#8217;s still not descriptive of its actions. &nbsp;And close_file_descriptor() (or, better yet, close_fd(), since most Un*x programmers know quite well that &quot;fd&quot; means a file descriptor) might be a better name for the similar Un*x kernel function. &nbsp;That said, the scope of close() is the system kernel, so it&#8217;s reasonable to expect that it applies to kernel data and to no other data (whereas the scope of CloseHandle() is that of all of Win32, including at least KERNEL/USER/GDI/ADVAPI and possibly a few other DLLs and therefore ought to apply to all handles managed by these same DLLs). &nbsp;So the claim of whether close() is a better name than CloseHandle() (or vice versa) is a little debatable, but I think we can unanimously agree that they&#8217;re *both* bad names.</p>
<p>I would say that saving your working set a kilobyte or two is a poor excuse for using an otherwise poor design. &nbsp;Memory is cheaper than clock cycles, and getting cheaper still as every day goes by. &nbsp;But a good design beats memory, clock cycles, disk space, or that most scarce of commodities, pixels, and *design* is the sole reason for the success of higher-level Algol-flavored languages like Java and C# and of scripting languages like PHP and Python and Ruby. &nbsp;These environments don&#8217;t concentrate as much on saving every single byte as they do on being appropriate for the tasks to which they are put, which is a smarter model to follow in the long run.</p>
<p>A call into a DLL *is* already a call-by-pointer, as you claim, which is exactly why you want to avoid doing *another* one on top of that: &nbsp;A single call-by-pointer should always be sufficient to fully direct a &quot;message&quot; to the recipient code (in message-passing terminology). &nbsp;If it isn&#8217;t, you likely have an overly-general design or one that&#8217;s overcomputing to accomplish its task.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375923">
				<div id="div-comment-375923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375923">
			May 2, 2006 at 3:59 am</a>		</div>

		<p>cvbcvb: &nbsp;Here&#8217;s an exercise for you: &nbsp;Provide three different reasons why #defining an alternate name is an extremely bad idea.</p>
<p>KJK: &quot;&#8230;the fact that certain handles cannot be passed to CloseHandle should alone be a big hint that they aren&#8217;t &#8216;kernel&#8217; objects.&quot; &nbsp;This is not a very well-considered statement; let me propose this as a thought experiment, and maybe you&#8217;ll see why: &nbsp;Let&#8217;s say that Microsoft introduces two new handle types, named HA and HB. &nbsp;One of these is closable by CloseHandle(), and one of these is closable by a new CloseUser32Handle() function in USER. &nbsp;Now here&#8217;s your exercise: &nbsp;Explain which handle must be closed by which function, using only the given information above. &nbsp;And then on the basis of your answer, explain why this thought experiment is relevant to the existing handle types in Win32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-375933">
				<div id="div-comment-375933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375933">
			May 2, 2006 at 4:49 am</a>		</div>

		<p>“what does &quot;close&quot; close? Files? sockets? Doors? Books?”</p>
<p>It closes anything you can open() or dup() and by extension anything that is a file descriptor.</p>
<p>Files? Yes; sockets? yes; doors? no, you can&#8217;t open() them either AFAIK (Solaris feature) and no, Books seem like more of a VMS thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375943">
				<div id="div-comment-375943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375943">
			May 2, 2006 at 6:04 am</a>		</div>

		<p>Why should API&#8217;s be designed around type safe languages? Non type safe languages exist and are still sometimes needed, and type safe languages can wrap up the unsafe APIs all they want.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kjkhyperion odd alt thread-odd thread-alt depth-1" id="comment-376103">
				<div id="div-comment-376103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-376103">
			May 2, 2006 at 12:46 pm</a>		</div>

		<p>Sean, I really don&#8217;t see the point. To me it seems a very petty and irrelevant point, the kind of thing you complain about while sitting on a high throne of never-having-written-an-operating-system</p>
<p>The fact that a handle is closable by CloseHandle tells you everything you need to know about that handle under a resource management point of view (when closed, a kernel object is dereferenced, possibly freed; can be duplicated; etc.). To introduce &quot;type-safe&quot; wrappers would only introduce noise, because there&#8217;s no &quot;type safety&quot; concerning kernel objects and resource management: it works the same for all kinds of them</p>
<p>Also, see the STRICT #define and the DECLARE_HANDLE() macro. That&#8217;s one way type safety is enforced. The other way is that a pointer cannot possibly be a (kernel) handle, because handles have 16 significative bytes (13, actually), i.e. they are always &lt; 65536 (except on Win64, where the kernel actually has enough address space to make a larger handle table meaningful), and no valid pointer can have a value in that range (unless you explicitely allocate memory in the reserved 0-65535 range, but that&#8217;s a case of shooting yourself a full clip in the foot with a sniper rifle)</p>
<p>Finally: GDI handles are not meaningless random values. They are encoded pointers. The encoded value contains, among others, the type of the object pointed and the offset in the shared object table. Also I think that they always have at least one of the &quot;tag bits&quot; set, i.e. the lowest three bits, which are never set in kernel handles. You have to try really hard to pass an &quot;invalid enough&quot; handle to any of those functions</p>
<p>In general, you are completely pissing over history, conveniently forgetting where does this stuff come from and for how long it has been around, and conveniently ignoring type-safe &quot;wrappers&quot; (silly rabbit, everything is a &quot;wrapper&quot;), and conveniently ignoring other much worse instances of type-unsafe APIs (see lParam &amp; wParam) which you can&#8217;t criticize as easily</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-375973">
				<div id="div-comment-375973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-375973">
			May 2, 2006 at 6:27 am</a>		</div>

		<p>Chris: Why not design for the highest level of safety in your interface? &nbsp;Observe how MFC wraps SelectObject() and you&#8217;ll see part of the answer to your own question: &nbsp;If you want a type-safe interface, you should design one; you shouldn&#8217;t assume somebody will add one on later, because the add-on is likely to be hacky and buggy. &nbsp;Ever heard of defensive coding? &nbsp;Defensive design is the next practice up the ladder, and just as important. &nbsp;It&#8217;s very easy to pass a generic HANDLE to SelectObject() and get a weird, unexpected, or meaningless result. &nbsp;But it&#8217;s much harder to pass a generic HANDLE to a theoretical SelectPen() function, no matter what your language: &nbsp;Even in a type-unsafe language like K&amp;R C, it&#8217;s pretty easy to see you&#8217;re doing the wrong thing by calling SelectPen(black_brush) and the right thing by calling SelectPen(black_pen). &nbsp;It&#8217;s much harder instead to see at a glance if your code is right or wrong if it says something like SelectObject(RGB(255,0,0)) or CloseHandle(hWnd). &nbsp;If you design your APIs to prevent their users from making mistakes, you&#8217;ll discover&#8230; &nbsp;that they *will* still make mistakes &#8212; but it&#8217;ll be far, far fewer!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-376303">
				<div id="div-comment-376303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cvbcvb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-376303">
			May 2, 2006 at 7:20 pm</a>		</div>

		<p>About type-safety: of course it is(was) possible to design type-safe system API. But naturally, this typesafety would be lost somewhere on the way inside of OS. Since providing completely-independent mechanism for handling different objects will leave to syntaxically overheaded code. And such design is extremely difficult to extend. So the only problem is to provide documented type-unsafe API or leave it hidden (and possible mutable) inside of OS and provide some layered over it type-safe API.</p>
<p>About #define &#8230; . It was only joke :). But in every joke thereis a piece of truth:</p>
<p>winbase.h:<br />
<br />#ifdef UNICODE<br />
<br />#define CreateFile &nbsp;CreateFileW<br />
<br />#else<br />
<br />#define CreateFile &nbsp;CreateFileA<br />
<br />#endif // !UNICODE<br />
<br />;)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-376093">
				<div id="div-comment-376093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-376093">
			May 2, 2006 at 12:31 pm</a>		</div>

		<p>Sean, you&#8217;re getting your knickers in a twist over an API which was designed 20 years ago, possibly longer. </p>
<p>By the way, 20 years ago, that working set issue *was* important.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-376143">
				<div id="div-comment-376143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-376143">
			May 2, 2006 at 1:48 pm</a>		</div>

		<p>KJK: This isn&#8217;t a question of age. &nbsp;I know how old the API is and that at its inception it was built for very different hardware. &nbsp;But choice of hardware is still no excuse for poor design. &nbsp;The designers, in the 1980s, could very easily have replaced SelectObject with a set of five or six separated entry points named SelectPen, SelectBrush, and yes, SelectTargetBitmap. &nbsp;(Notice that by writing it as &quot;TargetBitmap&quot; you immediately identify it as having different semantics than the other Select functions.) &nbsp;CloseHandle could easily have been named CloseKernelHandle when it was exported to Win32 in the early &#8217;90s; or, alternatively, a RegisterHandle callback function could have been added to allow user handles to be registered so that all HANDLE objects could be safely closed by a generic CloseHandle function. &nbsp;Admittedly, using RegisterHandle to register every new handle solely so that a uniform CloseHandle could close it is probably wildly inefficent, so the better solution is probably just to rename CloseHandle to CloseKernelHandle. &nbsp;Still, it *could* have been built that way.</p>
<p>All of this could have been done &#8212; even given the limitations of the day &#8212; and it was not.</p>
<p>And please don&#8217;t make claims about what I&#8217;ve done in the past without researching them first, okay? &nbsp;You don&#8217;t know how many millions of lines of code I&#8217;ve written or on what projects. &nbsp;I do not accept the premise that simply because Microsoft designed it, it is inherently the best design. &nbsp;Some of their designs are good, and some are bad. &nbsp;I would encourage you to think critically about them and make a reasonable attempt to sift the wheat from the chaff. &nbsp;Raymond has challenged all of us to do that here, quite regularly, and in some cases, a reasonable conclusion must be that Windows got it right; and in some cases, a reasonable conclusion must be that Windows got it wrong.</p>
<p>Simon: You make a good point about the age of the API. &nbsp;It *was* built under different design constraints, although I don&#8217;t necessarily buy that 100 additional bytes spent on the GDI export table and an extra 1K of code would have spelled the immediate flaming death of Windows 2.0. &nbsp;And yes, I know it&#8217;s been the way it is for sufficiently long that it&#8217;ll probably never change. &nbsp;Even so, though, that still doesn&#8217;t mean we shouldn&#8217;t attempt to analyze the design to find its qualities and its faults; far too much synthesis happens in this industry and far too little analysis. &nbsp;Good science should have both.</p>
<p>&#8212;&#8212;&#8212;-</p>
<p>And I&#8217;m not even going to *try* to talk about the design nightmare that is wParam and lParam. &nbsp;That topic&#8217;s worthy of an entire book.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-376553">
				<div id="div-comment-376553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-376553">
			May 3, 2006 at 1:04 pm</a>		</div>

		<p>The kernel handle doesn&#8217;t seem like a problem. &nbsp;What would be a small useful change (especially for newcomers) would be to have documentation (at least) explain when a HANDLE is a kernel HANDLE, a gdi HANDLE, or just some random pointer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-376693">
				<div id="div-comment-376693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">8</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-376693">
			May 4, 2006 at 4:36 am</a>		</div>

		<p>I really don&#8217;t have much trouble with keeping my handles seperate. After all, I requested them, so I know how to close them properly. It &quot;conveniantly&quot; says so in the MSDN docs. Also, how can you confuse a HANDLE with an HDC or GDIOBJ fcol.</p>
<p>IMHO more diving into the details of the implementation then neccessary will result in more breakage, and maybe Raymond&#8217;s hair-pulling getting stronger and stronger. His insightful articles on how programs break and he had to fix it in Windows are here for a reason -_-</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-376703">
				<div id="div-comment-376703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">required</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060501-34/?p=31353#comment-376703">
			May 4, 2006 at 4:51 am</a>		</div>

		<blockquote><p>
  you can select pens, brushes, and fonts into multiple DCs, but you can&#8217;t do it with bitmaps</p>
<p>&quot;Can&#8217;t&quot; meaning &quot;must not&quot;, &quot;cannot&quot; [i.e. it is actually impossible], or &quot;weird sh1t will happen if you do&quot;?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

