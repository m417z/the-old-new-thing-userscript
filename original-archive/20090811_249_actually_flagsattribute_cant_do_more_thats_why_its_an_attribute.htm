<html>
<head>
<title>Actually, FlagsAttribute can't do more; that's why it's an attribute</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Actually, FlagsAttribute can&#8217;t do more; that&#8217;s why it&#8217;s an attribute</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 11, 2009 / year-entry #250</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>27</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A few years ago, Abhinaba wondered why FlagsAttribute didn't also alter the way enumeration values are auto-assigned. Because attributes don't change the language. They are instructions to the runtime environment or (in rarer cases) to the compiler. An attribute can instruct the runtime environment to treat the function or class in a particular way. For...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>A few years ago, <a href="http://blogs.msdn.com/abhinaba/archive/2006/08/30/731426.aspx"> Abhinaba wondered why FlagsAttribute didn't also alter the way enumeration values are auto-assigned</a>.</p>
<p> Because attributes don't change the language. They are instructions to the runtime environment or (in rarer cases) to the compiler. An attribute can instruct the runtime environment to treat the function or class in a particular way. For example, you can use an attribute to tell the runtime environment that you want the program entry point to run in a single-threaded apartment, to tell the runtime environment how to look up your p/invoke function, or to tell the compiler to suppress a particular class of warnings. </p>
<p> But changing how values for enumerations are assigned, well that actually changes the language. An attribute can't change the operator precedence tables. An attribute can't change the way overloaded functions are resolved. An attribute can't change the statement block tokens from curly braces to square braces. An attribute can't change the IL that gets generated. The code still compiles to the same IL; the attribute just controls the execution environment, such as how the JIT compiler chooses to lay out a structure in memory. </p>
<p> Attribute or not, enumerations follow the same rule for automatic assignment: An enumeration symbol receives the value one greater than the previous enumeration symbol. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (27)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-761473">
				<div id="div-comment-761473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mathieu Garstecki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761473">
			August 11, 2009 at 10:45 am</a>		</div>

		<p>I find this explanation strange, I would have considered the behavior of FlagsAttribute a modification of the language, or isn&#8217;t modifying the type of operands an operator can work on a modification of its definition ?</p>
<p>In fact, there already are attributes that modify the generated IL anyway, take the Conditional attribute for example.</p>
<p>The behaviour wanted by Abhinaba seems more like a possible functionnality that has not been included in C#: just choose the values of your flags yourself.</p>
<div class="post">[<i>ConditionalAttribute is the &#8220;or (in rarer cases) to the compiler&#8221;. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761523">
				<div id="div-comment-761523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761523">
			August 11, 2009 at 11:49 am</a>		</div>

		<p>IANAC#P, but it seems like [Flags] does modify the compiler in some way, in that it doesn&#8217;t generate a warning if you try to OR two values together from the same enum. &nbsp;I&#8217;m not quite sure how that&#8217;s different from modifying the compiler to generate different auto-assigned values.</p>
<p>&#8230; unless of course the [Flags] attribute is really just adding an overloaded | operator.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-761563">
				<div id="div-comment-761563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761563">
			August 11, 2009 at 12:27 pm</a>		</div>

		<p>There&#8217;s nothing to stop someone from writing a .net language that behaves this way; doing so might even be considered sensible. So I agree with the others that the reason c# behaves this is historical. If it had occured to them in time might well have made the original specification. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761573">
				<div id="div-comment-761573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761573">
			August 11, 2009 at 12:32 pm</a>		</div>

		<p>ConditionalAttribute does not alter the language semantics, it just excludes a piece of code from compiling (nothing more than a nobilitated #if).</p>
<p>What RC was about to say is that Attributes can change compiler behavior (like #pragma warning or #if etc. in C/C++), can change interaction on reflecting code, but not change the underlying language semantics (like enum value assignments, or not raising errors for invalid code.. for example you cannot have a IKnowHowToSwitchAttribute which enables C-like switch statements because they are invalid C# code).</p>
<p>What FlagsAttribute should do, is just stop the compiler to complain about perfectly valid code (logic operator usage) and help reflecting code over the type (for IntelliSense, or a smarter PropertyGrid).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-761613">
				<div id="div-comment-761613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gregory</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761613">
			August 11, 2009 at 1:22 pm</a>		</div>

		<p>But some language features are implemented with help of attributes (extension methods is example).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761673">
				<div id="div-comment-761673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gregory</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761673">
			August 11, 2009 at 2:09 pm</a>		</div>

		<blockquote><p>
  FlagsAttribute itself changes the behavior of the compiler in whether bitwise operations are allowed to be done on values of the enum type without casting to the underlying integer type.
</p></blockquote>
<p>This is not the case, bitwise operations are allowed on any enumeration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-761683">
				<div id="div-comment-761683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erzengel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761683">
			August 11, 2009 at 2:14 pm</a>		</div>

		<p>I&#8217;m sorry Raymond, but I completely disagree with this reasoning.</p>
<p>A scripting language I maintain changes a few pieces of syntactic sugar depending on the Attributes the functions, classes, and enums particularly.</p>
<p>Like you said, &#8220;They are instructions &#8230; (in rarer cases) to the compiler&#8221;. With a simple switch I can change the operator precedence table for a method or line within my compiler.</p>
<p>Why doesn&#8217;t it? Because features start off not implemented. Someone has to think of the feature and implement it. That is the only reason. Attributes can change compiler behavior, the compiler I maintain does so.</p>
<p>Sorry Raymond, I just don&#8217;t agree with your logic based upon empirical experience.</p>
<div class="post">[<i>s/the compiler/the C# compiler/g. If you design your own language, you can make attributes do whatever you want. But C# prefers to segregate language from metadata. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761693">
				<div id="div-comment-761693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timothy Fries</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761693">
			August 11, 2009 at 3:02 pm</a>		</div>

		<blockquote><p>
  This is not the case, bitwise operations are allowed on any enumeration.
</p></blockquote>
<p>You&#8217;re right, I don&#8217;t know where that came from. &nbsp;The other two examples still stand.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-761703">
				<div id="div-comment-761703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erzengel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761703">
			August 11, 2009 at 4:59 pm</a>		</div>

		<p>[s/the compiler/the C# compiler/g. If you design your own language, you can make attributes do whatever you want. But C# prefers to segregate language from metadata. -Raymond]</p>
<p>My point is, the C# compiler CAN if it wanted to. But since the feature is not a part of the standard, it doesn&#8217;t. Not because attributes can&#8217;t do that, but because it was &#8220;decided&#8221; (probably because the decision never came up, therefore the &#8220;default&#8221; value of &#8220;not implemented&#8221; was &#8220;decided&#8221;) in the standards that it doesn&#8217;t. This is a pure design decision, or lack thereof, rather than a technical limitation of attributes. That&#8217;s just my opinion from my experience with a custom compiler.</p>
<div class="post">[<i>Well, yeah, it could if it wanted to, but that sort of goes against the spirit of attributes. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761723">
				<div id="div-comment-761723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MadQ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761723">
			August 11, 2009 at 6:16 pm</a>		</div>

		<p>Actually, the FlagsAttribute does change the way the values are generated. It even causes all the correct bitmasks to be assigned!</p>
<p>[Flags]</p>
<p>enum Meh</p>
<p>{</p>
<p>&nbsp; &nbsp;One = 1,</p>
<p>&nbsp; &nbsp;Two,</p>
<p>&nbsp; &nbsp;TwoOrOneMask,</p>
<p>&nbsp; &nbsp;Four,</p>
<p>&nbsp; &nbsp;FourOrOneMask,</p>
<p>&nbsp; &nbsp;FourOrTwoMask,</p>
<p>&nbsp; &nbsp;FourOrTwoOrOneMask,</p>
<p>&nbsp; &nbsp;Eight</p>
<p>}</p>
<p>But contrary to Abhinaba&#8217;s statement, we did gain a lot from the FlagsAttribute. The Enum.ToString() method and Debuggers use it to decide how to display an enum value. It aids in static analysis. It tells other developers something about the purpose of the enum type. If you&#8217;re really ambitious and have CPU cycles to spare, you can write a single method to validate values of all your enum types, taking into account whether a particular enum type has the FlagsAttribute or not.</p>
<p>&quot;Gosh, I&#8217;m smart!&quot; &#8211; Richard Feynman</p>
<p>P.S. Extra points if you can create a Feynman diagram for the Meh enum.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-761533">
				<div id="div-comment-761533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timothy Fries</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761533">
			August 11, 2009 at 11:57 am</a>		</div>

		<p>I find the explanation strange too, since like Mathieu mentioned, ConditionalAttribute is a striking counterexample &#8212; not just because it affects the resulting IL, but because it also affects the language pre-IL generation as well (it becomes a compile error to use a method with ConditionalAttribute for explicit or implicit delegate construction); which runs counter to the reasoning given for why FlagsAttribute doesn&#8217;t have the behavior described.</p>
<p>ExtensionAttribute is another example of an attribute affecting the language (though in that case there&#8217;s corresponding keyword support as well).</p>
<p>But both of these examples seem to me to be a valid argument for why the C# language *could* handle FlagsAttribute to alter the logic for assigning values to an enum.</p>
<p>The counter-argument (which I suspect is probably closer to the actual reason) is that none of the attributes that alter language behavior were around for C# 1.0 so at the time FlagsAttribute came into being, there was no precedent for the desired behavior; and that ConditionalAttribute and ExtensionAttribute are purely additive, they change behavior explicitly in new code only and neither ever existed without its language special behavior. Changing the behavior of FlagsAttribute now would be a breaking change to a recompile of existing, unchanged code; and the C# team hates breaking changes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761753">
				<div id="div-comment-761753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Don Reba</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761753">
			August 11, 2009 at 7:15 pm</a>		</div>

		<p>If C# were to embrace the possibility of changing the language via attributes, then it would have required a full-blown metaprogramming model, like Nemerle, for instance. It would have been too bold a step for Microsoft to make.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-761763">
				<div id="div-comment-761763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761763">
			August 11, 2009 at 7:40 pm</a>		</div>

		<p>I don&#8217;t think it would have made sense to change the way the auto-assigned values worked. Certainly, you couldn&#8217;t really do it in the general case. For example, if they did change things to auto-increment by powers-of-two instead of by just adding 1, what would this do:</p>
<p>[Flags]</p>
<p>enum MyFlags</p>
<p>{</p>
<p>&nbsp;Foo = 3,</p>
<p>&nbsp;Bar,</p>
<p>&nbsp;FooBar,</p>
<p>}</p>
<p>?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761773">
				<div id="div-comment-761773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761773">
			August 11, 2009 at 7:46 pm</a>		</div>

		<p>@Don Reba: Agreed. C# and .Net were sufficiently bold for the time. That is what you meant, wasn&#8217;t it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dino_viehlandhotmail-com even thread-even depth-1" id="comment-761783">
				<div id="div-comment-761783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DinoV' rel='external nofollow' class='url'>DinoV</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761783">
			August 11, 2009 at 8:00 pm</a>		</div>

		<p>C# does change overload resolution based upon attributes. &nbsp;In .NET 1/2/3 it changes based upon the ParamArrayAttribute. &nbsp;</p>
<p>In .NET 4 C# recognizes DefaultParameterValueAttribute and OptionalAttribute although I believe these are both technically pseudo-custom attributes &#8211; but ParamArrayAttribute is definitely a normal attribute which changes how the compiler behaves when calling a method.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761623">
				<div id="div-comment-761623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timothy Fries</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761623">
			August 11, 2009 at 1:35 pm</a>		</div>

		<p>&gt; Attributes can change compiler behavior, can change interaction on reflecting code, but not change the underlying language semantics</p>
<p>ExtensionAttribute changes the behavior of the compiler in choosing how to implement a callsite.</p>
<p>ConditionalAttribute changes the behavior of the compiler in choosing whether to implement a callsite, and whether a line of code is valid for determining whether locals have been initialized, and whether a method is valid to use in a delegate constructor (both implicit and explicit).</p>
<p>FlagsAttribute itself changes the behavior of the compiler in whether bitwise operations are allowed to be done on values of the enum type without casting to the underlying integer type.</p>
<p>All three of these are behaviorial changes at the compiler level that are least similar in scope to an attribute being able to alter how the compiler assigns default values to enum fields. &nbsp; The argument that it *can&#8217;t* be done because Attributes don&#8217;t affect compilation doesn&#8217;t hold water in the face of the counterexamples.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-761853">
				<div id="div-comment-761853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ShuggyCoUk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761853">
			August 12, 2009 at 4:11 am</a>		</div>

		<p>I would add that there is one attribute which unequivocally does cause different IL:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.methodimplattribute.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.methodimplattribute.aspx</a></p>
<p>[MethodImpl(MethodImplOptions.Synchronized)]</p>
<p>Which makes the compiler emit the required lock(this) equivalent instructions.</p>
<p>Since this is something that shouldn&#8217;t be used it&#8217;s not like it&#8217;s a big deal but there you go.</p>
<p>I don&#8217;t like auto assigned values much anyway since they break binary compatibility unless you always add to the end so frankly I&#8217;d prefer an attribute to say explicitly that you don&#8217;t want such behaviour&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-761863">
				<div id="div-comment-761863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ShuggyCoUk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761863">
			August 12, 2009 at 4:13 am</a>		</div>

		<p>Ignore me I tell a lie, <a rel="nofollow" target="_new" href="http://blogs.msdn.com/ricom/archive/2004/05/05/126542.aspx" rel="nofollow">http://blogs.msdn.com/ricom/archive/2004/05/05/126542.aspx</a> the JIT emits the relevant instructions so I&#8217;m talking rubbish&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-761893">
				<div id="div-comment-761893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-761893">
			August 12, 2009 at 7:42 am</a>		</div>

		<p>Hm. Whether some change in behaviour is a change in the language yes or no seems a bit metaphysical to me. Main point is that the behaviour has changed; where the boundary &nbsp;between the language and other aspects of the programming environment lies is more or less arbitrary. Suppose I wrote a preprocessor that would detect &quot;import braces&quot; in Python code and act on it? The decision to include the statement in the preprocessor or compiler as such is of course a change to the language, but suppose its presence for a moment. Would the actual usage of this import change the language? I don&#8217;t know, and frankly I don&#8217;t care. Because nothing follows from the answer to that question and thus the question is meaningless. So using &quot;because it would change the language&quot; as an argument doesn&#8217;t really work.</p>
<p>That said, in my opinion it would have been cleaner to add a flags statement, that would check whether the contents are non-overlapping valid flags or explicitly ored from the others, etc. But that is an opinion, a design decision, whatever you want to call it. I will not pretend that I think this would be better because I think the behaviour would be a change to the language or the existing behaviour of [flags] already would be. I just think it&#8217;s cleaner because flags don&#8217;t really enumerate a set of constants and I think putting an attribute on flags to fix that is an ugly hack. But that&#8217;s just an opinion. An aesthetic decision if you will. I can&#8217;t say that it logically must be so, and neither can the designers of C#.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mihailik odd alt thread-odd thread-alt depth-1" id="comment-762323">
				<div id="div-comment-762323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mihailik' rel='external nofollow' class='url'>Mihailik</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-762323">
			August 13, 2009 at 12:27 pm</a>		</div>

		<p>[Well, yeah, it could if it wanted to, but that sort of goes against the spirit of attributes. -Raymond]</p>
<p>So much for writing an article then spectacularly contradicting themselves in comments :-)</p>
<p>If it&#8217;s all about spirit, Raymond, you should have shed more light on spirit and bother less for IL generation.</p>
<div class="post">[<i>I guess I didn&#8217;t make it clear. Obviously, a language can do anything it wants, but the point was that modifying the language itself based on attributes is not why attributes are there. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mihailik even thread-even depth-1" id="comment-762333">
				<div id="div-comment-762333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mihailik' rel='external nofollow' class='url'>Mihailik</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-762333">
			August 13, 2009 at 12:32 pm</a>		</div>

		<p>Speaking about spirit, whole idea of having FlagsAttribute was a tiny spiritual mistake.</p>
<p>That&#8217;s clear in the hindsight, now point a finger at a C# developer who knows what is the actual material difference between having and not having that on a type?</p>
<p>Nobody knows because nobody cares. Therefore whole discussion is a mute point, or a moo point as Joey liked to say. Certainly introducing a behaviour to never-used feature is a road to the pain land.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-762353">
				<div id="div-comment-762353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://ra3s.com/wordpress/dysfunctional-programming/' rel='external nofollow' class='url'>aaron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-762353">
			August 13, 2009 at 1:16 pm</a>		</div>

		<p>This seems to be generating a comment storm really fast. &nbsp;I think this is really another case of _standard disclaimers apply_.</p>
<p>For instance, multiple comments before mine point out that &#8220;An attribute can&#8217;t change the IL that gets generated&#8221; is strictly incorrect &#8212; the ConditionalAttribute changes the behavior of a method call expression in Microsoft&#8217;s C# language implementation. &nbsp;</p>
<p>_However_, we seem to have forgotten this blogs disclaimers:</p>
<p>&#8220;Statements are not independently fact-checked. They are based on personal experience and recollection, augmented by informed guesswork&#8221;</p>
<p>Occasional errors to be expected.</p>
<div class="post">[<i>I did say &#8220;with rare exceptions&#8221;. Perhaps I should have linked to ConditionalAttribute. I still maintain that attributes should not alter the core language. Sure you can create a language where it does, but I would argue that that is an abuse of attributes, because it makes it harder to reason about code. What next [AlterOperatorPrecedenceAttribute]? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mihailik even thread-even depth-1" id="comment-762723">
				<div id="div-comment-762723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mihailik' rel='external nofollow' class='url'>Mihailik</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-762723">
			August 14, 2009 at 4:22 pm</a>		</div>

		<p>Raymond, that is still your mistake thinking ConditionalAttribute is a unique case.</p>
<p>There are several prominent cases, &#8216;exceptions&#8217; if you would.</p>
<p>You&#8217;re wrong saying attributes should not affect language meaning. In fact that very purpose was intended in attributes by design, amongst several others.</p>
<p>One major usage of attributes is to let language designers be more creative than underlying platform is, by injecting special meaning into compiled assemblies, recognizing it and modifying the behaviour.</p>
<p>Most of non-conventional languages heavily use attributes. C# itself when implementing non-conventional (by previous standards) features often employs them too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-762923">
				<div id="div-comment-762923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.interact-sw.co.uk/iangblog/' rel='external nofollow' class='url'>Ian Griffiths</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-762923">
			August 16, 2009 at 10:51 am</a>		</div>

		<p>While things like ParamArrayAttribute, ExtensionAttribute, and ConditionalAttribute may seem like they contradict this blog entry, there&#8217;s a slightly different way of looking at it. Those attributes don&#8217;t have any more power to change the language than FlagsAttribute does. All these attributes do nothing. But many compilers elect to change how they generate code in the face of these exceptional attributes.</p>
<p>So it&#8217;s certainly true that the designers of the C# language could have decided to make it do something different when FlagsAttribute is present just like it does for these other attributes. But the fact would remain that FlagsAttribute does nothing. The choice here lies with the compiler writer, not the attribute author.</p>
<p>And while this may seem like splitting hairs (as Anonymous Coward above seems to think, although &#8216;metaphysical&#8217; seems a tad melodramatic) it highlights an important point about why you want language-altering attributes kept to a minimum. For a language-altering attribute to work consistently, it requires the compilers for every .NET language to know about and add support for that attribute, because only compilers have the power to realise the effect the attribute promises. This amounts to a tax on compiler writers, which is undesirable in a framework designed to accommodate many languages.</p>
<p>Or to look at it from the response a prospective attribute author might get from compiler writers: what makes your attribute so great that every compiler vendor in the world should bend over backwards to support it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-762963">
				<div id="div-comment-762963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erzengel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-762963">
			August 17, 2009 at 2:30 am</a>		</div>

		<blockquote><p>
  Or to look at it from the response a prospective attribute author might get from compiler writers: what makes your attribute so great that every compiler vendor in the world should bend over backwards to support it?
</p></blockquote>
<p>Who says that the attribute author wants that? Like I said before, I use attributes as part of the scripting language compiler I maintain (and helped develop). The attributes were authored by the same people who authored the script compiler, and that&#8217;s the only compiler that&#8217;s expected to &quot;bend over backward to support it&quot;. It&#8217;s there only to support language features, just like ParamArray and Extension do in C#. And just like those attributes, ignoring the attributes attached by the script&#8217;s compiler (or manually attached in C#, as happens) is acceptable so long as you provide all the data.</p>
<p>For example, there&#8217;s a ScriptContextAttribute that the scripting language treats similar to C#&#8217;s implicit &quot;this&quot; reference. The &quot;context&quot; keyword, when used, requires the ScriptContextAttribute be attached to the function and a Script reference be passed as the first (non-this) parameter.</p>
<p>In the script, this is all done automatically. The signature looks like &quot;void func(int i)&quot;. In C#, the function&#8217;s signature is seen as &quot;[ScriptContext] void func(Script context, int i)&quot;. So long as you provide a meaningful Script for the context parameter, it works. You don&#8217;t have to pay attention to that attached attribute, just the function&#8217;s signiture.</p>
<p>As far as I&#8217;m aware, I&#8217;m not requesting any compiler to &quot;bend over backwards&quot; for our attributes. &nbsp;Only our own compiler has to do that.</p>
<p>If we thought it necessary, I could implement Abhinaba&#8217;s [Flags] changing how enums assign incremental values in our scripting language. But it would only work in our scripting language, and would be a feature of our compiler, not of FlagsAttribute.</p>
<p>The thing is, most attributes that change the language are language features in that language. You don&#8217;t apply [ParamArray] directly, instead you do &quot;params object[] Parameters&quot;. You don&#8217;t apply [Extension], you do &quot;this IEnumerator This&quot;. In my language, you don&#8217;t apply [ScriptContext], you just use the context keyword or a function with the ScriptContextAttribute (If you&#8217;re making a library in C# that is going to be used by my scripting language, then you&#8217;ll have to apply ScriptContextAttribute yourself when needed). If C# wanted to change the behavior of enums assigning incremental values, there should probably be a &quot;flags&quot; keyword you can put in front of the enum keyword, just as you can put static in front of class.</p>
<p>I think that&#8217;s the point Raymond is trying to make. Sure, attributes are used by compilers to change semantics, but usually you don&#8217;t apply the attribute yourself, the compiler does. When you have to apply the attribute manually, don&#8217;t expect if to change the compiler&#8217;s behavior.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-763003">
				<div id="div-comment-763003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">streuth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-763003">
			August 17, 2009 at 7:53 am</a>		</div>

		<p>The only thing that matters to me is that an enum can be used as a member of a struct, in conjunction with the bitfield operator.</p>
<p>Perhaps it&#8217;s scary, but it works, and helps (me at least).</p>
<p>The thing for me is that if you alter the way the enum works, it has the potential to break anything that expects typical enum behaviour.</p>
<p>In addition, if you want to make an enum represent flags, it&#8217;s not at all clear how the flags would auto arrange. For example, is the enumeration element &quot;Zero&quot; bit 0 set, or is it actually an arbitrary length word set to zero?</p>
<p>The thing for me that sways this, is that if you wanted the functionality that Abhinaba was looking for, he could have a struct, and named the individual bits using the bitfield operator.</p>
<p>As it stands you can do both things, albeit by a lateral method. If you change the way enum works, you risk making one of these things work no longer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-763013">
				<div id="div-comment-763013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">streuth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20090811-00/?p=17153#comment-763013">
			August 17, 2009 at 7:58 am</a>		</div>

		<p>I possibly ought to say that I personally would like to see a &quot;bit&quot; type in C++. Perhaps SystemC will oblige, if I ever need it!</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

