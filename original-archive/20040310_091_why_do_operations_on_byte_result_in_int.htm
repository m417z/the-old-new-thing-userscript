<html>
<head>
<title>Why do operations on "byte" result in "int"?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why do operations on &#8220;byte&#8221; result in &#8220;int&#8221;?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 10, 2004 / year-entry #92</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>38</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">(The following discussion applies equally to C/C++/C#, so I'll use C#, since I talk about it so rarely.) People complain that the following code elicits a warning: byte b = 32; byte c = ~b; // error CS0029: Cannot implicitly convert type 'int' to 'byte' "The result of an operation on 'byte' should be another...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>(The following discussion applies equally to C/C++/C#, so I'll
use C#, since I talk about it so rarely.)</p>
<p>
People complain that the following code elicits a warning:</p>
<pre>
byte b = 32;
byte c = ~b;
// error CS0029: Cannot implicitly convert type 'int' to 'byte'
</pre>
<p>
"The result of an operation on 'byte' should be another 'byte',
not an 'int'," they claim.
</p>
<p>
Be careful what you ask for. You might not like it.
</p>
<p>
Suppose we lived in a fantasy world where operations on 'byte'
resulted in 'byte'.
</p>
<pre>
byte b = 32;
byte c = 240;
int i = b + c; // what is i?
</pre>
<p>
In this fantasy world, the value of i would be 16!
Why?
Because the two operands to the + operator are both bytes, so
the sum "b+c" is computed as a byte, which results in 16 due to
integer overflow.
(And,
<a HREF=/oldnewthing/archive/2004/01/29/64389.aspx>
as I noted earlier,
integer overflow is the new security attack vector</a>.)</p>
<p>
Similarly,</p>
<pre>
int j = -b;
</pre>
<p>would result in j having the value 224 and not -32, for the
same reason.</p>
<p>
Is that really what you want?
</p>
<p>
Consider the following more subtle scenario:
</p>
<pre>
struct Results {
 byte Wins;
 byte Games;
};

bool WinningAverage(Results captain, Results cocaptain)
{
 return (captain.Wins + cocaptain.Wins) >=
        (captain.Games + cocaptain.Games) / 2;
}
</pre>
<p>
In our imaginary world, this code would return incorrect
results once the total number of games played exceeded 255.
To fix it, you would have to insert annoying int casts.</p>
<pre>
 return ((int)captain.Wins + cocaptain.Wins) >=
        ((int)captain.Games + cocaptain.Games) / 2;
</pre>
<p>So no matter how you slice it, you're going to have to insert
annoying casts.  May as well have the language err on the side
of safety (forcing you to insert the casts where you know that
overflow is not an issue) than to err on the side of silence
(where you may not notice the missing casts until your Payroll
department asks you why their books don't add up at the end of
the month).</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (38)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-152723">
				<div id="div-comment-152723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152723">
			March 10, 2004 at 7:21 am</a>		</div>

		<p>&gt;int j = -b;<br />
<br />&gt;<br />
<br />&gt;would result in j having the value 224 and not &gt;-32, for the same reason.<br />
<br />&gt;<br />
<br />&gt;Is that really what you want? </p>
<p>YES! Oh god yes! I so hate dealing with the abomination that is signed bytes in Java that I could spit. Having well-behaved bytes is a godsend.</p>
<p>&gt;struct Results {<br />
<br />&gt; byte Wins;<br />
<br />&gt; byte Games;<br />
<br />&gt;};</p>
<p>Bytes are for screwing around with bytes, not basketball scores. Use shorts if you care.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152753">
				<div id="div-comment-152753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152753">
			March 10, 2004 at 7:33 am</a>		</div>

		<p>Okay, then how about this:</p>
<p>struct Packet {<br />
<br />byte Size;<br />
<br />&#8230;<br />
<br />};</p>
<p>int SizeRequired(Packet packet1, Packet packet2, Packet3 packet3)<br />
<br />{<br />
<br /> return packet1.Size + packet2.Size + packet3.Size;<br />
<br />}</p>
<p>If you use this to compute the amount of memory required to store three packets, you just earned yourself a buffer overflow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152763">
				<div id="div-comment-152763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152763">
			March 10, 2004 at 7:33 am</a>		</div>

		<p>Um&#8230; if I declare my variables as bytes, then yes, I would expect overflow when performing arithmetic that uses the ninth (or sign) bit.</p>
<p>I don&#8217;t expect the C compiler to protect me from my own dumb mistakes.</p>
<p>This seems very &quot;anti-C-ish&quot; to me.</p>
<p>But as always in Raymond&#8217;s posts, very interesting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152793">
				<div id="div-comment-152793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Brown</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152793">
			March 10, 2004 at 7:59 am</a>		</div>

		<p>I never expected, or even wanted, a compiler to protect me from my own dumb mistakes. What, me worry?! I thought I had it all figured out. </p>
<p>Then I learned my lesson. Perhaps you can benefit from my experience. </p>
<p>I made a dumb mistake. The C compiler didn&#8217;t complain. It figured I knew what I was doing &#8212; or more likely that if I was a fool, I deserved what I got. </p>
<p>The Java compiler voiced its concerns: &quot;She&#8217;s gonna turn into her mother, pal. You&#8217;ll live to regret this. You know what they say about buying a cow, don&#8217;t you? And speaking of cows, LOOK AT HER MOTHER!&quot;</p>
<p>But I didn&#8217;t listen. </p>
<p>I just didn&#8217;t listen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152803">
				<div id="div-comment-152803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Serge Wautier</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152803">
			March 10, 2004 at 7:59 am</a>		</div>

		<p>I completely second Matt.</p>
<p>&gt; int j = -b;</p>
<p>If you end up negating an unsigned value, i&#8217;d say that error is more probably in the design than in the code.</p>
<p>&gt; byte c = ~b;</p>
<p>OK, so what&#8217;s the problem keeping a byte here ?</p>
<p>&gt; return packet1.Size + packet2.Size + packet3.Size;<br />
<br />&gt; &lt;&#8230;&gt; you just earned yourself a buffer overflow. </p>
<p>So did you if Packet.Size is an int and the sizes are large enough. Less likely to happen ? Maybe. But these rules were designed in the C language at a time where most int were 16 bits. int overflow in arithmetic was way more usual at that time.</p>
<p>I discovered this rule (how is named ? integer promotion ?) some day when I decided that I wanted a new piece of code at to compile at warning level 4 with no warnings allowed (warnings = errors).<br />
<br />Adding to embed nasty casts in basic statements was horrible : Code less readable, BIG comment required in each such statement to explain why the cast are there and must stay there,&#8230;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152813">
				<div id="div-comment-152813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eyal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152813">
			March 10, 2004 at 8:31 am</a>		</div>

		<p>Well, i live in the fantasy world of Delphi and it seems to work ok there:</p>
<p>procedure Test;<br />
<br />var a,b,c: Byte;<br />
<br />    I: Integer;<br />
<br />begin<br />
<br />  b := 32;<br />
<br />  c := 240;<br />
<br />  i := b+c; // i= 272<br />
<br />  a := b+c; // a= 16<br />
<br />end;</p>
<p>if there&#8217;s no explicit type then int will be used i.e:</p>
<p>if (a+b)&gt;200 // will return True</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152823">
				<div id="div-comment-152823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152823">
			March 10, 2004 at 8:34 am</a>		</div>

		<p>This appears to be a different fantasy world, one where int-to-byte truncation does not raise an error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152833">
				<div id="div-comment-152833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jerry Pisk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152833">
			March 10, 2004 at 8:40 am</a>		</div>

		<p>Raymond, by your logic int should automatically be promoted to long (64-bit int) if the calculation would result in an overflow. I must absolutely agree with everybody, if I use a byte then I want the compiler to work with byte. Period.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152843">
				<div id="div-comment-152843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152843">
			March 10, 2004 at 8:44 am</a>		</div>

		<p>Okay well it looks like I lose this round.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152853">
				<div id="div-comment-152853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152853">
			March 10, 2004 at 9:23 am</a>		</div>

		<p>C and C++ promote to int (the &#8216;natural&#8217; size of the platform) because it&#8217;s more efficient to compute in integers. C++ has a slight difference from C in that the type of a character literal (e.g. &#8216;a&#8217;) is char &#8211; in C, it&#8217;s int.</p>
<p>Microsoft&#8217;s 64-bit C/C++ compilers break this &#8216;natural size&#8217; recommendation: long and int are only 32 bits.</p>
<p>Frankly, using a byte rather than an int is pointless &#8211; you won&#8217;t save any memory due to the compiler&#8217;s packing anyway. If you alter the packing, you may get masking and shifting operations under the covers &#8211; and you must remember to align your data appropriately, or you&#8217;ll get unaligned accesses (which is slower or raises exceptions on some processors).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152863">
				<div id="div-comment-152863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">B.Y.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152863">
			March 10, 2004 at 9:25 am</a>		</div>

		<p>I think the rule should be: promote integer values to the highest integer level in the expression. So:</p>
<p>    byte a,b; int i;</p>
<p>    a=~b; //no warning<br />
<br />    i=a-b; //no warning<br />
<br />    b=i; //warning</p>
<p>I thought this is what C++ does.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152873">
				<div id="div-comment-152873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Pavloff</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152873">
			March 10, 2004 at 9:36 am</a>		</div>

		<p>I made myself a little integer promotion table some years back.  MSDN has the complete set of rules:</p>
<p><a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_pluslang_arithmetic_conversions.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_pluslang_arithmetic_conversions.asp</a></p>
<p>I&#8217;m a C++ programmer. I can&#8217;t tell you how annoyed I get when I&#8217;ve got to use VB for any operation that requires some precision in the size and behavior of integers.</p>
<p>And while we&#8217;re here, can someone PLEASE tell me why VB _still_ doesn&#8217;t support Signed Bytes, Unsigned Words, and Unsigned Double Words?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152883">
				<div id="div-comment-152883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jpayne@NOSPAM.serif.com' rel='external nofollow' class='url'>Jonathan Payne</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152883">
			March 10, 2004 at 9:55 am</a>		</div>

		<p>I was a little surprised by the warnings this code generated:</p>
<p> typedef char BYTE;</p>
<p> BYTE a = 0;<br />
<br /> BYTE b = 0;</p>
<p> a += b;    // warning C4244: &#8216;+=&#8217; : conversion from &#8216;int&#8217; to &#8216;BYTE&#8217;<br />
<br /> a = a + b; // no warning</p>
<p>Why does &#8216;+=&#8217; differ from &#8216;+&#8217; and &#8216;=&#8217; for simple types?  If anything, I would expect the second statement to promote &#8216;a + b&#8217; to an int and then generate a warning at the assign and the first statement to compile OK as a and b are the same type and the statement would resolve to the internal equivalent of &#8216;char operator+=(char)&#8217;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152903">
				<div id="div-comment-152903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nathan Downey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152903">
			March 10, 2004 at 10:40 am</a>		</div>

		<p>I actually don&#8217;t mind this all that much. It doesn&#8217;t prevent you from doing anything, it just forces you to be explicit about your intentions.</p>
<p>Now, should it be the job of the compiler or runtime to enforce explicitness when it encounters suspect code?  I think it depends on the situation. C# has saved my ass a couple of times&#8230;. take this trivial example:</p>
<p>int one = 1;<br />
<br />if (one = 1) { return; }</p>
<p>COMPILE ERROR:<br />
<br />C:sandboxoutRefTestClass1.cs(18): Cannot implicitly convert type &#8216;int&#8217; to &#8216;bool&#8217;</p>
<p>You could make the argument that a *good* developer would use something like this:</p>
<p>if (1 == one) { return; }</p>
<p>All your doing here is making the expression explicit. Stating your intentions. </p>
<p>Even good developers make mistakes, and mediocre developer make lots of them. I don&#8217;t see anything wrong with the compiler asking the developer.</p>
<p>&quot;Are you sure you want to commit this act of stupidy?&quot;</p>
<p> </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152913">
				<div id="div-comment-152913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.tallent.us/' rel='external nofollow' class='url'>Richard Tallent</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152913">
			March 10, 2004 at 11:05 am</a>		</div>

		<p>Overloading the addition operator &quot;+&quot; with an append/concatenate operation is wrong. Addition operations are commutative, append is not. VB.NET solves this by having a proper concatenate operator (&quot;&amp;&quot;), but the C* world is left with ambiguity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-152953">
				<div id="div-comment-152953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Maks Verver</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152953">
			March 10, 2004 at 11:41 am</a>		</div>

		<p>If implicit conversion is so great, why does it only work with operands of a smaller size than int? The following example is &#8216;broken&#8217;:<br />
<br />  int x = 2147483647, y = 2147483647;<br />
<br />  long long int z = x + y;<br />
<br />z becomes -2 instead of 4294967294 and a cast on x is required to make it work as intended.</p>
<p>It&#8217;s nice that you can save yourself a few casts here and there with the implicit conversion to int and it probably does prevent a few bugs you wouldn&#8217;t have thought about, but the implicit conversion is just a partial fix to a much broader (potential) problem. After all, even something as simple and common as an integer addition possibly overflows. Surely, you can&#8217;t expect the compiler (and definitely not a C compiler) to ensure that all result types are large enough to completely avoid overflow, as this would incur a significant performance overhead on integral types that exceed the &#8216;native&#8217; size of integers (usually 32 or 64 bits).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-152963">
				<div id="div-comment-152963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-152963">
			March 10, 2004 at 11:47 am</a>		</div>

		<p>&quot;Even good developers make mistakes, and mediocre developer make lots of them. I don&#8217;t see anything wrong with the compiler asking the developer.&quot;</p>
<p>The problem is that its inconsistant with other examples in the language.  Serge Wautier pointed out that the same problems can occur if you sum two ints.  The compiler doesn&#8217;t complain about that though, does it?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153013">
				<div id="div-comment-153013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sean Terry</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153013">
			March 10, 2004 at 2:22 pm</a>		</div>

		<p>I had posed a question about this behaviour to Eric Gunnerson a few weeks ago and I felt the same way many people here do&#8230; that I want a byte to act like a byte.</p>
<p><a target="_new" href="http://blogs.msdn.com/ericgu/archive/2004/02/02/66345.aspx" rel="nofollow">http://blogs.msdn.com/ericgu/archive/2004/02/02/66345.aspx</a></p>
<p>I have &quot;accepted&quot; this kind of behaviour, and have moved all my bitflags to ints instead of bytes so the sake of not polluting the readability of my code with gobs of explicit conversions.</p>
<p>Is there a happy medium here?  As a developer who on occasion needs to perform some good-ole-fashioned binary manipulation and just drop the frigging 9th/17th/33rd bit&#8230; I would like a compiler option to allow such implicit conversions.</p>
<p>I&#8217;ve had to explain this to co-workers four times in the last few weeks.<br />
<br />Them: Why are you using an int for that?  Just use a byte.<br />
<br />Me: The C# compiler won&#8217;t let me.<br />
<br />Them: *boggle* &lt;insert dig at Microsoft here&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153023">
				<div id="div-comment-153023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153023">
			March 10, 2004 at 2:26 pm</a>		</div>

		<p>And other people would say, &quot;Why are C#&#8217;s integer promotion rules different from C and C++ on such a fundamental issue?&quot;</p>
<p>Basically no matter what decision you make, somebody will be upset.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153043">
				<div id="div-comment-153043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.JCABs-Rumblings.com' rel='external nofollow' class='url'>JCAB</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153043">
			March 10, 2004 at 2:41 pm</a>		</div>

		<p>I agree you have made a (obviously debatable) point with the arithmetic operations.</p>
<p>Nevertheless, bitwise operations (like your initial example of bit-negation) are not causes of overflow, so I don&#8217;t see a reason at all, except to keep all operators working in exactly the same manner, no matter how unrelated to each other they are.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153063">
				<div id="div-comment-153063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153063">
			March 10, 2004 at 2:51 pm</a>		</div>

		<p>True, but imagine the confusion if you make bit operators have different promotion rules from arithmetic operations! You would have</p>
<p>byte b;</p>
<p>b &amp; 0x1F; // result is &quot;byte&quot;?<br />
<br />b % 0x20; // result is &quot;int&quot;?</p>
<p>b &lt;&lt; 1; // result is &quot;byte&quot;?<br />
<br />b * 2; // result is &quot;int&quot;?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153083">
				<div id="div-comment-153083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dmitriy Zaslavskiy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153083">
			March 10, 2004 at 3:35 pm</a>		</div>

		<p>Raymond, I think one the original reason for promotions was that not all hardware can perform ops on values smaller that &quot;natural size&quot; And the designers didn&#8217;t want to hide that fact.</p>
<p>Just a speculation</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153093">
				<div id="div-comment-153093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153093">
			March 10, 2004 at 3:39 pm</a>		</div>

		<p>bookending the discussion ;)</p>
<p>Raymond sez:<br />
<br />&gt;Okay, then how about this:<br />
<br />&gt;<br />
<br />&gt;struct Packet {<br />
<br />&gt;byte Size;<br />
<br />&gt;&#8230;<br />
<br />&gt;}; </p>
<p>If the packets are known structs, then I&#8217;ll use defines. If they&#8217;re datapackets, I&#8217;ll use shorts and write network pack/unpack routines for each packet. Bytes are bytes and ints are ints &#8211; they should be separate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153263">
				<div id="div-comment-153263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Factory</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153263">
			March 11, 2004 at 12:25 am</a>		</div>

		<p>  Hmm I thought that the C&#8217;s desire to use int as much as possible was from it&#8217;s parent language of BCPL, in which all variables were of the same size. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153293">
				<div id="div-comment-153293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wilhelm Svenselius</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153293">
			March 11, 2004 at 12:55 am</a>		</div>

		<p>Actually, there&#8217;s is a language in the &quot;C* world&quot; (unless you interpret that to only mean languages that begin with C &#8211; I interpret it as languages in the same &quot;family&quot;) which has a proper operator for appending strings &#8211; PHP with operator &#8216;.&#8217; (period). Very nice and useful.</p>
<p>$some_var = &quot;Hello &quot;.$name.&quot;, how are you today?&quot;;</p>
<p>Then again, in PHP you can just do</p>
<p>$some_var = &quot;Hello $name, how are you today?&quot;;</p>
<p>but I try to avoid this form, it makes code harder to read IMO, and it&#8217;s not practical for all cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153313">
				<div id="div-comment-153313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">project</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153313">
			March 11, 2004 at 1:27 am</a>		</div>

		<p>&gt;In this fantasy world, the value of i would be 16!<br />
<br />I&#8217;d like to be in this world!<br />
<br />Nobody claims that in this code d equals to 1:<br />
<br />  int a=3;<br />
<br />  int b=2;<br />
<br />  double d=a/b;</p>
<p>&gt;Similarly,<br />
<br />&gt;int j = -b;<br />
<br />&gt;would result in j having the value 224<br />
<br />&gt;and not -32, for the same reason.<br />
<br />If b is unsigned, 224 seems quite reasonable.</p>
<p>&gt;Is that really what you want?<br />
<br />YES</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153323">
				<div id="div-comment-153323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">projects</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153323">
			March 11, 2004 at 1:33 am</a>		</div>

		<p>Sorry.<br />
<br />I meant &quot;nobody _complains_ that d equals to 1&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153333">
				<div id="div-comment-153333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Shuttlewood</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153333">
			March 11, 2004 at 1:42 am</a>		</div>

		<p>Not that I disagree with the design per-se, but isn&#8217;t this rather an interesting demonstration of inconsistency?</p>
<p>int a,b,c;<br />
<br />a = Integer.MAX_VALUE;<br />
<br />b = Integer.MAX_VALUE;<br />
<br />c = a + b;</p>
<p>Why isn&#8217;t the result of a + b a long?</p>
<p>and similarly upwards?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153343">
				<div id="div-comment-153343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153343">
			March 11, 2004 at 1:47 am</a>		</div>

		<p>Okay already &#8211; I get the point. You folks want C# to have different integer promotion rules from C and C++. </p>
<p>I personally think that&#8217;s nuts &#8211; if you&#8217;re designing a language, you don&#8217;t want to make it gratuitously different from the language people are coming from. But then again, it looks like I&#8217;m in the minority.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153353">
				<div id="div-comment-153353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Shuttlewood</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153353">
			March 11, 2004 at 1:57 am</a>		</div>

		<p>Actually, I think it would be more interesting if C# fixed the consistency the other way maybe.</p>
<p>As you say, integer overflow is the current attack vector of choice, yet in Java (not really played with C# yet, I don&#8217;t see how I check if an int has overflowed. Or a long, or &#8230;.). (obviously you could cludge a check). Maybe as a community we should bite the bullet and use more complex types to represent integers in order to prevent integer overflow issues.</p>
<p>Java made the decision to eliminate unsigned types, and although done for other reasons, it almost seems prescient &#8211; how many bugs or casts are there when people are casting to unsigned types. The flaw discovered in IE5 with BMPs was exactly the result of casting a signed integer to an unsigned one. By preventing the issue, it protects you somewhat.</p>
<p>Anyway, I dunno, I imagine it would be hard to guarantee the type of safety that people want and still get the sort of performance that they want, but it would be interesting to try.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153413">
				<div id="div-comment-153413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MilesArcher</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153413">
			March 11, 2004 at 8:11 am</a>		</div>

		<p>Raymond,</p>
<p>Then why did they make VBdotnet gratuitously different from VB 6?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153423">
				<div id="div-comment-153423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153423">
			March 11, 2004 at 8:17 am</a>		</div>

		<p>You&#8217;ll have to ask them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153463">
				<div id="div-comment-153463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Florian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153463">
			March 11, 2004 at 12:03 pm</a>		</div>

		<p>In my fantasy world, when writing</p>
<p>byte b = 32;<br />
<br />byte c = 240;<br />
<br />int i = b + c;</p>
<p>then i would be 272 and</p>
<p>int j = -b;</p>
<p>j would be -32. But</p>
<p>byte a = ~b;</p>
<p>would still not be an error. Why? Because</p>
<p>byte a = b + c;</p>
<p>would result in a being 16 indeed. In my fantasy world the compiler would take the time to look at the type that the result is expected to be and do the computation accordingly. If I want a byte result when adding bytes I don&#8217;t need no integer promotion. If the result is an int, then yes, I want the integer promotion. My choice as a programmer. And in the cases where the compiler can&#8217;t know what type I expected the result to be (as in: if ( a+b &gt; 250 ) ) then I want to get a warning or an error which will save me from my possible mistake. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153543">
				<div id="div-comment-153543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153543">
			March 11, 2004 at 1:46 pm</a>		</div>

		<p>(Note that the style for C-family languages is that the type of an expression is not context-sensitive.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153703">
				<div id="div-comment-153703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153703">
			March 11, 2004 at 8:09 pm</a>		</div>

		<p>Traditionally, if one wanted to get correct results without suffering from overflow, one used a language that had bignums.  If one wanted to get performance at reasonable (such as it was then) speed or cost, then one used a language somewhat closer to assembly language and wrote additional code only when deemed necessary to check for overflows.  Traditionally languages with bignums were unpopular because of their expense, both in the bignums themselves and in their dependence on frivolities such as garbage collection, and because of their ugly syntax.</p>
<p>When object orientation was invented, some people felt that its syntax should look like Smalltalk so people reading it could be sure that they weren&#8217;t reading Fortran or Lisp or C.  But then lo and behold, someone gradually built up an almost object oriented language by bits and pieces, with a syntax based on C.  (And someone else did the same to Lisp.)</p>
<p>C# has syntax less ugly than Lisp, while it does have garbage collection.  Starting from this base, it would have been useful to make it a higher level language in other ways as well, such as avoiding overflow and using bignum as a standard type.  By being the mixture that it is, C# is still a language, it just isn&#8217;t serving any really useful purpose.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153743">
				<div id="div-comment-153743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.redwoodroot.org' rel='external nofollow' class='url'>Peter Evans</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153743">
			March 11, 2004 at 9:43 pm</a>		</div>

		<p>I have to agree that &quot;byte&quot; operations on &quot;byte&quot; declared operands should result in either &quot;byte&quot; type or throw typical number system errors such as overflow or underflow from C# or other CLS compliant compilers.</p>
<p>IMO C# was designed for making code express conversions explicitly and for having its type system enforce consistency.</p>
<p>I find the arbitrary promotion rules in C/C++ cumbersome for today&#8217;s programmer who may never have to write device drivers or highly efficient bit codecs.  </p>
<p>Yes, new C# application programs can be blind to some of this low level understanding, but why force them to think in these low-level terms.  I believe C# has an optimal performance with its strict type system for its intended audience.</p>
<p>However, I am expecting the upcoming CLI/C++ mapping to fill the need Ramond desires for the traditional type promotion rules intermixed with a compliant compilation.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153823">
				<div id="div-comment-153823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-153823">
			March 12, 2004 at 6:15 am</a>		</div>

		<p>I think C# should of used saturated arithmetic with no promotion of types (unless both sides of the operator are different) but it&#8217;s way too late now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-188333">
				<div id="div-comment-188333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040310-00/?p=40323#comment-188333">
			June 28, 2004 at 4:54 pm</a>		</div>

		<p>Commenting on this entry has been closed.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

