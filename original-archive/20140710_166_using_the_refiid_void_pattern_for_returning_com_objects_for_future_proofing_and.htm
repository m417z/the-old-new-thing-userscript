<html>
<head>
<title>Using the REFIID/void** pattern for returning COM objects for future-proofing and to avoid problems with dependencies</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Using the REFIID/void** pattern for returning COM objects for future-proofing and to avoid problems with dependencies</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 10, 2014 / year-entry #167</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>36</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Suppose you have a function that creates a reference to a COM object: // pixie.h STDAPI CreateShellItemFromPixieDust( const PIXIEDUST *ppd, IShellItem **ppsi); There are a few issues with this design. First of all, it requires that whoever uses your header file must have included shlobj.h first, since that's where IShell­Item is defined. You could solve...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Suppose you have a function that creates a reference to a COM object:
</p>
<pre>
// pixie.h

STDAPI CreateShellItemFromPixieDust(
    const PIXIEDUST *ppd,
    IShellItem **ppsi);
</pre>
<p>
There are a few issues with this design.
</p>
<p>
First of all, it requires that whoever uses your header file
must have included <code>shlobj.h</code> first,
since that's where <code>IShell&shy;Item</code> is defined.
You could solve that problem by putting
<code>#include &lt;shlobj.h&gt;</code> at the top of
<code>pixie.h</code>,
but that creates its own problems.
For example, many header files alter their behavior based
on symbols that have been <code>#define</code>d,
and including that other header file as part of
<code>pixie.h</code> means that it's going to use the settings
that were active at the time <code>pixie.h</code> was included
(which may not be what the clients of your header file are expecting).
For example:
</p>
<pre>
#include &lt;windows.h&gt;
#include &lt;ole2.h&gt;
#include &lt;pixie.h&gt;
#define <a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2013/01/24/10387757.aspx">STRICT_TYPED_ITEMIDS</a>
#include &lt;shlobj.h&gt;
</pre>
<p>
This program wants to use strict typed item IDs,
so it defines the magic symbol before including
<code>shlobj.h</code>.
Unfortunately, that request is ignored because
the <code>pixie.h</code> header file secretly included
<code>shlobj.h</code> prematurely.
</p>
<p>
This can get particularly messy if somebody wants to
include <code>shlobj.h</code> with particular preprocessor
tricks temporarily active.
</p>
<pre>
#include &lt;windows.h&gt;
#include &lt;ole2.h&gt;
#include &lt;pixie.h&gt;

// The WINDOWDATA structure added in Windows Vista conflicts
// with the one we defined back in 2000, so rename it to
// WINDOWDATA_WINDOWS.
#define WINDOWDATA WINDOWDATA_WINDOWS
#include &lt;shlobj.h&gt;
#undef WINDOWDATA

// Here's our version of WINDOWDATA
#include &lt;contosotypes.h&gt;
</pre>
<p>
This code works around a naming conflict that was created
when Windows Vista added a structure called
<code>WINDOW&shy;DATA</code> to <code>shlobj.h</code>.
The application already had a structure with the same name,
so it has to rename the one in <code>shlobj.h</code> to
some other name to avoid a redefinition error.
</p>
<p>
If you made <code>pixie.h</code> include
<code>shlobj.h</code> on its own,
it would do so without this fancy renaming, and the
developers of that code will curse and say something like this:
</p>
<pre>
#include &lt;windows.h&gt;
#include &lt;ole2.h&gt;

// The WINDOWDATA structure added in Windows Vista conflicts
// with the one we defined back in 2000, so rename it to
// WINDOWDATA_WINDOWS.
#define WINDOWDATA WINDOWDATA_WINDOWS

<font COLOR=blue>// pixie.h secretly includes shlobj.h so we have to put its #include
// under WINDOWDATA protection.
#include &lt;pixie.h&gt;</font>

#include &lt;shlobj.h&gt;

#undef WINDOWDATA


// Here's our version of WINDOWDATA
#include &lt;contosotypes.h&gt;
</pre>
<p>
Another problem with the
<code>Create&shy;Shell&shy;Item&shy;From&shy;Pixie&shy;Dust</code>
function is that it hard-codes the output interface to
<code>IShell&shy;Item</code>.
When everybody moves on to
<code>IShell&shy;Item2</code>,
all the callers will have to 
follow the
<code>Create&shy;Shell&shy;Item&shy;From&shy;Pixie&shy;Dust</code>
call with a <code>Query&shy;Interface</code> to get the interface
they really want.
(Which, if your object is out-of-process,
could mean another round trip to the server.)
</p>
<p>
The solution to both of these problems is to simply make the
caller specify what type of object they want.
</p>
<pre>
// pixie.h

STDAPI CreateShellItemFromPixieDust(
    const PIXIEDUST *ppd,
    REFIID riid,
    void **ppv);
</pre>
<p>
Now that we are no longer mentioning
<code>IShell&shy;Item</code> explicitly,
we don't need to include <code>shlobj.h</code> any more.
And if the caller wants <code>IShell&shy;Item2</code>,
they can just ask for it.
</p>
<p>
Your creation function used to look like this:
</p>
<pre>
STDAPI CreateShellItemFromPixieDust(
    const PIXIEDUST *ppd,
    IShellItem **ppsi)
{
    *ppsi = nullptr;
    IShellItem *psiResult;
    HRESULT hr = ... do whatever ...;
    if (SUCCEEDED(hr))
    {
       *ppsi = psiResult;
    }
    return hr;
}
</pre>
<p>
You simply have to tweak the way you return the pointer:
</p>
<pre>
STDAPI CreateShellItemFromPixieDust(
    const PIXIEDUST *ppd,
    <font COLOR=blue>REFIID riid,
    void **ppv</font>)
{
    *ppv = nullptr;
    IShellItem *psiResult;
    HRESULT hr = ... do whatever ...;
    if (SUCCEEDED(hr))
    {
       <font COLOR=blue>hr = psiResult-&gt;QueryInterface(riid, ppv);
       psiResult-&gt;Release();</font>
    }
    return hr;
}
</pre>
<p>
Callers of your function would go from
</p>
<pre>
IShellItem *psi;
hr = CreateShellItemFromPixieDust(ppd, &amp;psi);
</pre>
<p>
to
</p>
<pre>
IShellItem *psi;
hr = CreateShellItemFromPixieDust(ppd, <font COLOR=blue>IID_PPV_ARGS(&amp;psi)</font>);
</pre>
<p>
If the caller decides that they really want an
<code>IShell&shy;Item2</code>,
they merely have to change their variable declaration;
the call to the creation function is unchanged.
</p>
<pre>
<font COLOR=blue>IShellItem2 *psi;</font>
hr = CreateShellItemFromPixieDust(ppd, IID_PPV_ARGS(&amp;psi));
</pre>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (36)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1137383">
				<div id="div-comment-1137383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137383">
			July 10, 2014 at 7:29 am</a>		</div>

		<p>Ah yes namespace pollution and how to mitigate it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137403">
				<div id="div-comment-1137403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xv8</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137403">
			July 10, 2014 at 8:19 am</a>		</div>

		<p>@Karellen</p>
<p>Even if they do reserve it, it doesn&#39;t stop people ignoring the reservation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137423">
				<div id="div-comment-1137423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137423">
			July 10, 2014 at 8:38 am</a>		</div>

		<p>Compile-time error:</p>
<p>{code}</p>
<p>STDAPI CreateShellItemFromPixieDust(</p>
<p> &nbsp; &nbsp;const PIXIEDUST *ppd,</p>
<p> &nbsp; &nbsp;REFIID riid,</p>
<p> &nbsp; &nbsp;void **ppv)</p>
<p>{</p>
<p> &nbsp; &nbsp;*ppsi = nullptr; &nbsp; &nbsp; // ERROR: Variable ppsi is not declared.</p>
<p> &nbsp; &nbsp;IShellItem *psiResult;</p>
<p>{code}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137433">
				<div id="div-comment-1137433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137433">
			July 10, 2014 at 9:01 am</a>		</div>

		<p>Yes, every bit of COM is well designed and thought out, and the result is still ugly and hard to use.</p>
<div class="post">[<em>Is there an easier/prettier solution that still solves the same problems? (Language-independence, remotability, etc.) Otherwise you&#39;re just complaining that hard things are hard, which doesn&#39;t really advance the discussion. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137453">
				<div id="div-comment-1137453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137453">
			July 10, 2014 at 10:08 am</a>		</div>

		<p>[Is there an easier/prettier solution that still solves the same problems? (Language-independence, remotability, etc.)]</p>
<p>Maybe a remoteable solution should not be used where remoteability is not required.</p>
<p>Maybe when using a remoteable solution, call by name is not too expensive.</p>
<p>Maybe if most objects didn&#39;t care what thread model was in use.</p>
<p>Maybe if the file-open dialog box didn&#39;t screw up on threads using COM objects of a different thread model.</p>
<p>Maybe if the file-open dialog box set the COM model back to unspecified if it set it on a thread that has yet to start COM.</p>
<p>Maybe people are pissed off at the fragility of the COM registry that still plagues us even in Windows 8 where as system component goes mysteriously unregistered and there&#39;s no way to find out which DLL it&#39;s supposed to be in.</p>
<div class="post">[<em>Um, you do recall that remotability was the reason why COM was originally invented? (Embedding a Word document in an Excel spreadsheet.) Also, call-by-name is basically IDispatch, which means you lose compile-time type safety and user-defined types. I don&#39;t know why I allow myself to get sidetracked like this. The point of today&#39;s article &quot;Assuming you&#39;re using COM, here&#39;s how to be more forward-compatible. If you&#39;re not using COM, then ignore today&#39;s article.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137493">
				<div id="div-comment-1137493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137493">
			July 10, 2014 at 10:27 am</a>		</div>

		<p>(2/2) In the case of the iostream library, there&#39;s actually a separate, smaller header iosfwd which includes just the declarations of the various I/O classes, not their full definitions. &nbsp;So if you need to, say, declare operator&lt;&lt;(std::ostream&amp;, const MyClass&amp;), you should include iosfwd in your header file but NOT iostream. &nbsp;For libraries which neither provide forward declaration headers nor documented declarations, you have no choice but to include the full definition header to portably use their types in your headers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137523">
				<div id="div-comment-1137523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137523">
			July 10, 2014 at 11:10 am</a>		</div>

		<p>@Zf-12: Not in the header file you don&#39;t. &nbsp;Of course you need the full definition of IShellItem in the cpp file which implements CreateShellItemFromPixieDust(), but you don&#39;t need the definition in just the declaration of the function in pixie.h.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137533">
				<div id="div-comment-1137533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zf-12</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137533">
			July 10, 2014 at 11:20 am</a>		</div>

		<p>@Adam Rosenfield: By using a forward declaration in the header you&#39;ve introduced an additional burden on every user of the library: Not only do they need to include pixie.h, but also shlobj.h. A cleaner design is to have the header file include all its dependencies including shlobj.h. As for your compilation performance problem, this is generally solved via the &quot;Pimpl idiom&quot; instead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137563">
				<div id="div-comment-1137563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137563">
			July 10, 2014 at 11:29 am</a>		</div>

		<p>By the way, I should say that the forward declaration may or may not help with the &quot;IShellItem2&quot; issue; but it would with the first.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137603">
				<div id="div-comment-1137603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137603">
			July 10, 2014 at 12:31 pm</a>		</div>

		<p>@Azarien</p>
<p>MS does have an &quot;easy&quot; version of COM &#8211; managed code. &nbsp;Like every other choice in life, there are trade-offs. &nbsp;With COM, execution speed is better. &nbsp;With managed code, development speed is better. &nbsp;With COM, you get more flexibility. &nbsp;With managed code, you are encouraged to stay inside the framework. &nbsp;Either way, you get to choose which things are most important to you.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137633">
				<div id="div-comment-1137633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137633">
			July 10, 2014 at 2:01 pm</a>		</div>

		<p>I kinda like there advice, but I hate the motivation. Header of the function needs no includes (shlobj.h or other), if dangers of that are real, then a forward declaration of PIXIEDUST and IShellItem is a way out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137643">
				<div id="div-comment-1137643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zf-12</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137643">
			July 10, 2014 at 2:14 pm</a>		</div>

		<p>@ Joshua Muskovitz: Well-designed header files shouldn&#39;t be a kitchen sink in first place. So the case where a users wants only some part of the interface while at the same time other parts introduce a compilation performance problem should be rare.</p>
<p>Therefore the solution shouldn&#39;t be to forward-declare everything, but rather split the header into it&#39;s logical parts. That&#39;s basically the opposite of what Windows.h does.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137393">
				<div id="div-comment-1137393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137393">
			July 10, 2014 at 7:32 am</a>		</div>

		<p>&quot;For example, many header files alter their behavior based on symbols that have been #defined, and including that other header file as part of pixie.h means that it&#39;s going to use the settings that were active at the time pixie.h was included&quot;</p>
<p>But that might happen anyway. Any header file might need to include other header files of components &quot;lower&quot; in the stack to ensure that types it uses are visible. This is especially notable for system header files, e.g. if a header defined functions that use time_t or FILE *, but can also include higher components if a header defines functions that use e.g. a database-connection-type (SqlServerConnection * ?)</p>
<p>Therefore, if you are using #defines to change the behaviour of a header file you use, you need to do that before you include *any* header file.</p>
<p>e.g.</p>
<p>#define STRICT_TYPED_ITEMIDS</p>
<p>#include &lt;windows.h&gt;</p>
<p>#include &lt;ole2.h&gt;</p>
<p>#include &lt;pixie.h&gt;</p>
<p>#include &lt;shlobj.h&gt;</p>
<p>(Note &#8211; this also applies on POSIX systems with e.g. #define _POSIX_C_SOURCE, or with plain C for #define _ISOC99_SOURCE/_ISOC11_SOURCE)</p>
<p>&quot;// The WINDOWDATA structure added in Windows Vista conflicts</p>
<p>// with the one we defined back in 2000, so rename it to</p>
<p>// WINDOWDATA_WINDOWS.&quot;</p>
<p>Does Windows not reserve a part (or parts) of the global namespace for it&#39;s own use, such as WINDOW*, much like the C standard does for str*, mem*, is*, to*, _*, etc&#8230;, to try and prevent clashes like this?</p>
<div class="post">[<em>Standard header files are not allowed to include other standard header files. 4.1.2 &quot;Standard headers&quot;: &quot;Each header declares and defines only those identifiers listed in its associated section.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137413">
				<div id="div-comment-1137413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137413">
			July 10, 2014 at 8:37 am</a>		</div>

		<p>Why would you include shlobj.h when you could just use a forward declaration? &nbsp;The header file certainly doesn&#39;t need the complete type definition to declare a pointer.</p>
<p>// pixie.h</p>
<p>class IShellItem; &nbsp;// or struct, depending on __cplusplus and other macros</p>
<p>STDAPI CreateShellItemFromPixieDust(const PIXIEDUST *ppd, IShellItem **ppsi);</p>
<p>That doesn&#39;t solve the problem of what if the caller wants to use IShellItem2 instead of IShellItem, but it does solve all of those header file issues (which are rather uncommon, in my experienceâ€”I&#39;ve seen lots of library headers include Windows headers and not ran into these types of issues. &nbsp;NDEBUG before assert.h is probably the only time I&#39;ve seen that).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137443">
				<div id="div-comment-1137443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137443">
			July 10, 2014 at 9:14 am</a>		</div>

		<p>@Adam &#8211; Why would you write your own forward declarations when you could just include a header file? That&#39;s *what the header file is there for*.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137463">
				<div id="div-comment-1137463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marvin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137463">
			July 10, 2014 at 10:09 am</a>		</div>

		<p>I usually wholeheartedly agree with everything Raymond says but this particular advice is BS.</p>
<p>If you want to throw type safety out if the window you need a damn good reason to do so.</p>
<p>Of the two reasons Raymond shows first is bogus (more in a bit) while the second is likely to be useless optimization in vast majority if cases.</p>
<p>So the first reason is bogus. In C and C++ you are never guaranteed particular fact or order of header inclusion. The first example &#8211; setting a macro &quot;for a header&quot; is a bad anti-pattern because of that. You set such things in your compiler arguments or in a precompiled header before any inclusions. Anything else is inviting ODR violations and shooting yourself in the foot.</p>
<p>The second example &#8211; renaming is why namespaces where invented and why macros and such should have namespace like prefixes. If you are in a crappy situation where you must resort to that then the proper way to set such rename is to first organize your includes: all system headers, followed by standard library, followed by 3rd party in order of generality, followed by project ones. Then wrap what you need in a macro. Not foolproof but close. This is basic dependency management.</p>
<p>None of these issues warrant breaking type safety.</p>
<p>The second issue *might* be important in some rare cases but for a vast majority of users? You are using an out of proc server, create new objects and one extra call is going to break you perf-wise? Sounds like your system is broken already :)</p>
<p>(I assume you are not using cross machine DCOM here. If you do then you deserve what you get)</p>
<div class="post">[<em>News flash: There are crappy header files out there. You may be forced to use them. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137683">
				<div id="div-comment-1137683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137683">
			July 10, 2014 at 5:12 pm</a>		</div>

		<p>&quot;Standard header files are not allowed to include other standard header files.&quot;</p>
<p>Yeah, sorry, I didn&#39;t make myself very clear there. By &quot;system header files&quot;, I intended to mean those provided by the operating system, rather than those provided by the C implementation, like &quot;windows.h&quot; on Win32, or &quot;unistd.h&quot; on POSIX. Being a layer above the C standard header files, they can include e.g. &quot;stdio.h&quot; for FILE * and &quot;time.h&quot; for time_t, without violating the C standard. (Because C has very little to say about what operating system header files may or may not do.)</p>
<p>And as you go higher in your include heirarchy, other header files are likely to include &quot;windows.h&quot; to get the definition of things like HANDLE or REFIID or DWORD or TCHAR or&#8230; (Unless they were written by Adam Rosenfeld, and forward-declare all these things themselves instead.)</p>
<p>Therefore, I stand by my opinion that you should always put all your behaviour-altering #defines before you #include your first header file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-1137473">
				<div id="div-comment-1137473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137473">
			July 10, 2014 at 10:23 am</a>		</div>

		<p>&gt; Another problem with the Create&shy;Shell&shy;Item&shy;From&shy;Pixie&shy;Dust function is that it hard-codes the output interface to IShell&shy;Item. When everybody moves on to IShell&shy;Item2, all the callers will have to follow the Create&shy;Shell&shy;Item&shy;From&shy;Pixie&shy;Dust call with a Query&shy;Interface to get the interface they really want.</p>
<p>Or you make a CreateShellItem2FromPixieDust to go along with the existing CreateShellItemFromPixieDust.</p>
<p>In theory I could make a single &quot;void DoSomething(void*)&quot; function with a set of dynamically changing rules that prevent me from *ever* having to change my function definition; but, ew.</p>
<div class="post">[<em>You&#39;re presupposing a time machine. pixie.h was written before IShell&shy;Item2 was invented. Suppose IShell&shy;Item3 gets invented tomorrow. Do you call up Contoso Corporation and say, &quot;Hey, can you release a new version of your component that has a Create&shy;Shell&shy;Item3&shy;From&shy;Pixie&shy;Dust function?&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137483">
				<div id="div-comment-1137483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137483">
			July 10, 2014 at 10:26 am</a>		</div>

		<p>@Karellen: Because often you only need the *declaration* of a struct/class, not its whole *definition*. &nbsp;Once you start having every header file including lots of other header files for definitions it doesn&#39;t really need, your compile times will start to go through the roof for large projects (to say nothing of potential circular dependency issues).</p>
<p>If a type is documented as having a particular declaration, it&#39;s perfectly acceptable (and encouraged) to redeclare that yourself with the same declaration. &nbsp;Things get a little trickier when things aren&#39;t fully spec&#39;ed out by the documentation, like certain classes in the C++ STL (you can&#39;t forward declare std::string because it a typedef for std::basic_string&lt;char, some_more_traits_and_allocator_stuff&gt;, for example).</p>
<p>(splitting up this post into 2 because the blogging software thinks this comment is spam&#8230;.sigh)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137513">
				<div id="div-comment-1137513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zf-12</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137513">
			July 10, 2014 at 10:37 am</a>		</div>

		<p>&gt; @Adam Rosenfield: Once you start having every header file including lots of other header files for definitions it doesn&#39;t really need,</p>
<p>You *do* need the &quot;IShellItem&quot; in Raymonds example, so there&#39;s no point in using a forward declaration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137543">
				<div id="div-comment-1137543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137543">
			July 10, 2014 at 11:22 am</a>		</div>

		<p>@Karellan: &quot;Why would you write your own forward declarations when you could just include a header file? That&#39;s *what the header file is there for*.&quot;</p>
<p>I thought Raymond just created a whole post explaining why you might not want to just include the header. If you buy those arguments, you could omit the header *and still keep type safety* with a forward declaration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137553">
				<div id="div-comment-1137553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137553">
			July 10, 2014 at 11:28 am</a>		</div>

		<p>@Zf-12: No, that&#39;s not true at all. &nbsp;Using a forward declaration in a header does *not* force any of your users to include additional headers they wouldn&#39;t otherwise needâ€”that&#39;s the whole point of forward declarations! &nbsp;If pixie.h has &quot;class IShellItem;&quot; in it without including shlobj.h, then if foo.cpp includes pixie.h and just wants to use a PIXIEDUST instance, it doesn&#39;t need to include shlobj.h at all.</p>
<p>The Pimpl idiom is just a wrapper around forward declarations, it&#39;s not all that different. &nbsp;The only reason it&#39;s needed in C++ is because you can&#39;t define a class&#39;s interface (i.e. it&#39;s member functions) without also defining the implementation details of its member variables and private methods (C# solves this problem by allowing partial classes).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137573">
				<div id="div-comment-1137573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zf-12</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137573">
			July 10, 2014 at 11:56 am</a>		</div>

		<p>&gt; Adam Rosenfield: Using a forward declaration in a header does *not* force any of your users to include additional headers</p>
<p>Yes, a forward declaration does not force the inclusion of additional headers. But the user *using* a feature does.</p>
<p>To make long matters short, the point is: forward declarations in header files only make sense for private implementation details, but not for features that the user of the header wants to use, e.g. parts of function signatures.</p>
<p>So if PIXIEDUST is what is needed by the user of the header, but IShellItem is just an implementation detail that happens to be visible in the header, but is not part of the interface then a forward declaration is fine. If IShellItem is not an implementation detail, say it&#39;s part of a function signature for users of the header to consume, then the header should include &quot;shlobj.h&quot;, because in this case the user will have to include it anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137613">
				<div id="div-comment-1137613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">stickboy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137613">
			July 10, 2014 at 1:13 pm</a>		</div>

		<p>&gt; If IShellItem is not an implementation detail, say it&#39;s part of a function signature for users of the header to consume, then the header should include &quot;shlobj.h&quot;, because in this case the user will have to include it anyway.</p>
<p>@Zf-12: Only if the caller wants to invoke CreateShellItemFromPixieDust. &nbsp;If it wants to call some other function declared in pixie.h, it won&#39;t need shlobj.h. &nbsp;Furthermore, callers of CreateShellItemFromPixieDust are going to need to include shlobj.h *anyway* if using the REFIID/void** pattern.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137623">
				<div id="div-comment-1137623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua Muskovitz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137623">
			July 10, 2014 at 1:17 pm</a>		</div>

		<p>@Zf-12,</p>
<p>You are mistaken. If a user wants to *use* that feature of PIXIEDUST, then they would have to include shlobj.h. But if that were the case, they would have already needed to include it, since they are themselves using IShellItem in their own code. Forcing *everyone* to include a header with all its inherent risks (order of includes is often a huge nightmare) so that *some* people won&#39;t have to add one line of code (and just an include, at that) is silly. And if they don&#39;t need to manipulate the IShellItem directly, but only need it to be able to pass it as a pointer to some other function, then they *never* need the include, so it should be left inside the .cpp file to limit its exposure.</p>
<p>Remember: Your use case probably doesn&#39;t match everyone else&#39;s use case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137743">
				<div id="div-comment-1137743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">manuell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137743">
			July 11, 2014 at 2:24 am</a>		</div>

		<p>Typo in the final version of CreateShellItemFromPixieDust.</p>
<p>*ppsi = nullptr;</p>
<p>should be</p>
<p>*ppv = nullptr;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137753">
				<div id="div-comment-1137753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137753">
			July 11, 2014 at 3:29 am</a>		</div>

		<p>Even understanding that these are samples not designed to demonstrate error handling (and therefore the first sample doesn&#39;t try to release a partly-created psiResult at all), the second version appears to discourage correct code by including a release in a suboptimal place (a separate if (psiResult) psiResult-&gt;Release(); before the return would correspond best to where a smart pointer would do it).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137733">
				<div id="div-comment-1137733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137733">
			July 11, 2014 at 1:59 am</a>		</div>

		<p>IID_PPV_ARGS is undefined, according to C/C++ aliasing rules. &nbsp;It is not legal to type-pun/union &quot;void *&quot; with &quot;IUnknown *&quot; like this. &nbsp;(Then again, I suppose that Microsoft can just say it&#39;s defined, since they control the compiler&#8230;)</p>
<p>The strict-aliasing-correct way to do this is as follows:</p>
<p>IShellItem2 *psi;</p>
<p>void *pv;</p>
<p>hr = CreateShellItemFromPixieDust(ppd, __uuidof(*psi), &amp;pv);</p>
<p>if (SUCCEEDED(hr))</p>
<p>{</p>
<p> &nbsp; &nbsp;psi = static_cast&lt;IShellItem2 *&gt;(pv);</p>
<p>}</p>
<p>It&#39;s not legal to do the static_cast unless SUCCEEDED(hr) is true, because otherwise you&#39;re performing an undefined operation: casting a potentially-uninitialized or invalid pointer. &nbsp;Even if you don&#39;t use it, merely forming the pointer is illegal C++. &nbsp;(reinterpret_cast would be OK to do in this context, provided the pointer is not used until the type is confirmed.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137893">
				<div id="div-comment-1137893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137893">
			July 11, 2014 at 3:37 pm</a>		</div>

		<p>I don&#39;t mind it. In fact I think it&#39;s a good idea. If I&#39;m using COM then me (or some agent of mine) would have had to have called CoCreateInstance/Ex at some point, which uses this pattern also.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137833">
				<div id="div-comment-1137833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137833">
			July 11, 2014 at 10:26 am</a>		</div>

		<p>@Myria, where do you get your information from?</p>
<p>In C, you can provide any pointer to void*, and vice-versa, in the standard since C89.</p>
<p>In C++, you can provide any pointer to void*, but you must cast the other way around, standard since C++98.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137853">
				<div id="div-comment-1137853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">stickboy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137853">
			July 11, 2014 at 11:42 am</a>		</div>

		<p>@John Doe:</p>
<p>I think what Myria meant is that while casting between void* and T* is legal, casting between void** and T** is not necessarily safe (although Microsoft gets to define the behavior). &nbsp;For example, imagine a system where sizeof(void*) &gt; sizeof(struct S*).</p>
<div class="post">[<em>Win32 requires that sizeof(void*) == sizeof(T*) for all T. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137863">
				<div id="div-comment-1137863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137863">
			July 11, 2014 at 12:36 pm</a>		</div>

		<p>@John Doe: Yes, and my example uses such a cast through void *. &nbsp;What *isn&#39;t* legal, though, is accessing the pointer itself through a &quot;void **&quot; pointer rather than the correct &quot;IShellItem2 **&quot; pointer. &nbsp;There is actually no guarantee in C/C++ that &quot;void *&quot; and &quot;IShellItem2 *&quot; are physically stored in the same format. &nbsp;I&#39;ve never seen a compiler that varies the physical storage of pointer by their type, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1137903">
				<div id="div-comment-1137903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137903">
			July 11, 2014 at 4:07 pm</a>		</div>

		<p>&gt; You&#39;re presupposing a time machine.</p>
<p>How so? If CreateShellItemFromPixieDust can return an object that implements IShellItem2, that assumes that code has been updated. If code can be updated, so can a header file.</p>
<p>I appreciate that the point of the blog post is &quot;hey, if you use this technique, you can update your code (or consume code that can be updated) without having to update your header&quot;. My point I&#39;m trying to make in response is that sometimes there is value in having the header match the code.</p>
<p>&gt; STDAPI CreateShellItemFromPixieDust( const PIXIEDUST *ppd, REFIID riid, void **ppv );</p>
<p>At this point you may as well call the function CreateFromPixieDust(&#8230;). You no longer need to update the header file ever again (yay!) but you do need to figure out how to document what interfaces can be created (or refer to the documentation for the components you are internally consuming.)</p>
<div class="post">[<em>CreateShellItemFromPixieDust studies the pixie dust and then calls a function like SHCreateShellItem with the appropriate parameters. The IShellItem2 is coming from SHCreateShellItem, not CreateShellItemFromPixieDust. CreateShellItemFromPixieDust is just a middle man. The point of CreateShellItemFromPixieDust is that it creates a shell item (via SHCreateShellItem), but you can pick which aspect of the shell item you want to receive. This is different from CreateFromPixieDust which could create an IStream from pixie dust, and then it would have to study the riid to decide whether to call SHCreateShellItem or BindToObject. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1137923">
				<div id="div-comment-1137923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137923">
			July 12, 2014 at 7:48 am</a>		</div>

		<p>[Um, you do recall that remotability was the reason why COM was originally invented?]</p>
<p>In fact yes. I guess what gets on my nerves is all these shell APIs that aren&#39;t ever going to remote.</p>
<div class="post">[<em>Some shell interfaces can be marshaled. Are you suggesting that an alternative interface be used for the ones that can&#39;t be marshaled? And then what if somebody decides to add marshaling support to an existing interface? Would there be two different interfaces to the same functionality, a COM-based one that can be marshaled, and a non-COM-based one that cannot? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1137963">
				<div id="div-comment-1137963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1137963">
			July 14, 2014 at 9:12 am</a>		</div>

		<p>[Would there be two different interfaces to the same functionality, a COM-based one that can be marshaled, and a non-COM-based one that cannot? -Raymond]</p>
<p>In my opinion a good thing. Too many cases come up where I want to do something that should work but the only interface is a COM interface that tries to call in several hundred MB of address space and then load some third-party DLL and several hundred MB more address space (due to failure to dedupe C runtime libraries) to do something like get an icon for a file. Address space is still a scarce resource.</p>
<div class="post">[<em>Um, the non-COM interface (e.g. <code>SHGet&shy;File&shy;Info</code> is going to load the same third-party DLLs, seeing as the third party is the icon provider. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1138643">
				<div id="div-comment-1138643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140710-00/?p=533#comment-1138643">
			July 15, 2014 at 6:03 pm</a>		</div>

		<p>@Myria, I stand corrected.</p>
<p>@Joshua, but but&#8230; you can always delegate to a COM out-of-proc server that actually fetches the icons and returns them with remotable interfaces. &nbsp;This way, it&#39;s not your process&#39; address space, it&#39;s more stable and reliable, and it&#39;s cacheable for the whole user session, so it can in fact become faster in the not-so-longer term. &nbsp;How easier could it be?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

