<html>
<head>
<title>How do FILE_FLAG_SEQUENTIAL_SCAN and FILE_FLAG_RANDOM_ACCESS affect how the operating system treats my file?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How do FILE_FLAG_SEQUENTIAL_SCAN and FILE_FLAG_RANDOM_ACCESS affect how the operating system treats my file?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 20, 2012 / year-entry #26</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>39</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">There are two flags you can pass to the Create­File function to provide hints regarding your program's file access pattern. What happens if you pass either of them, or neither? Note that the following description is not contractual. It's just an explanation of the current heuristics (where "current" means "Windows 7"). These heuristics have changed at...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>There are two flags you can pass to the <code>Create&shy;File</code> function to provide hints regarding your program's file access pattern. What happens if you pass either of them, or neither?</p>
<p> <b>Note that the following description is not contractual.</b> It's just an explanation of the current heuristics (where "current" means "Windows&nbsp;7"). These heuristics <i>have changed</i> at each version of Windows, so consider this information as a tip to help you choose an appropriate access pattern flag in your program, not a guarantee that the cache manager will behave in a specific way if you do a specific thing. </p>
<p> If you pass the <code>FILE_<wbr>FLAG_<wbr>SEQUENTIAL_<wbr>SCAN</wbr></wbr></wbr></code> flag, then the cache manager alters its behavior in two ways: First, the amount of prefetch is doubled compared to what it would have been if you hadn't passed the flag. Second, the cache manager marks as available for re-use those cache pages which lie entirely behind the current file pointer (assuming there are no other applications using the file). After all, by saying that you are accessing the file sequentially, you're promising that the file pointer will always move forward. </p>
<p> At the opposite extreme is <code>FILE_<wbr>FLAG_<wbr>RANDOM_<wbr>ACCESS</wbr></wbr></wbr></code>. In the random access case, the cache manager performs no prefetching, and it does not aggressively evict pages that lie behind the file pointer. Those pages (as well as the pages that lie ahead of the file pointer which you already read from or wrote to) will age out of the cache according to the usual most-recently-used policy, which means that heavy random reads against a file will not pollute the cache (the new pages will replace the old ones). </p>
<p> In between is the case where you pass neither flag. </p>
<p> If you pass neither flag, then the cache manager tries to detect your program's file access pattern. This is where things get weird. </p>
<p> If you issue a read that begins where the previous read left off, then the cache manager performs some prefetching, but not as much as if you had passed <code>FILE_<wbr>FLAG_<wbr>SEQUENTIAL_<wbr>SCAN</wbr></wbr></wbr></code>. If sequential access is detected, then pages behind the file pointer are also evicted from the cache. If you issue around six reads in a row, each of which begins where the previous one left off, then the cache manager switches to <code>FILE_<wbr>FLAG_<wbr>SEQUENTIAL_<wbr>SCAN</wbr></wbr></wbr></code> behavior for your file, but once you issue a read that no longer begins where the previous read left off, the cache manager revokes your temporary <code>FILE_<wbr>FLAG_<wbr>SEQUENTIAL_<wbr>SCAN</wbr></wbr></wbr></code> status. </p>
<p> If your reads are not sequential, but they still follow a pattern where the file offset changes by the same amount between each operation (for example, you seek to position 100,000 and read some data, then seek to position 150,000 and read some data, then seek to position 200,000 and read some data), then the cache manager will use that pattern to predict the next read. In the above example, the cache manager will predict that your next read will begin at position 250,000. (This prediction works for decreasing offsets, too!) As with auto-detected sequential scans, the prediction stops as soon as you break the pattern. </p>
<p> Since people like charts, here's a summary of the above in tabular form: </p>
<table border="1" bordercolor="black" style="border-collapse: collapse" cellpadding="3">
<tr>
<th>Access pattern</th>
<th>Prefetch</th>
<th>Evict-behind</th>
</tr>
<tr>
<td>Explicit random</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Explicit sequential</td>
<td>Yes (2&times;)</td>
<td>Yes</td>
</tr>
<tr>
<td>Autodetected sequential</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Autodetected very sequential</td>
<td>Yes (2&times;)</td>
<td>Yes</td>
</tr>
<tr>
<td>Autodetected linear</td>
<td>Yes</td>
<td>?</td>
</tr>
<tr>
<td>None</td>
<td>No</td>
<td>?</td>
</tr>
</table>
<p> There are some question marks in the above table where I'm not sure exactly what the answer is. </p>
<p> <b>Note</b>: These cache hints apply only if you use <code>Read&shy;File</code> (or moral equivalents). Memory-mapped file access does not go through the cache manager, and consequently these cache hints have no effect. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (39)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-961853">
				<div id="div-comment-961853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaron.E</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961853">
			January 20, 2012 at 7:40 am</a>		</div>

		<p>So, if you&#39;ve triggered the &quot;Autodetected very sequential&quot; condition and then break the pattern, presumably the size of the prefetch gets halved. &nbsp;What happens to the cached pages that were already prefetched? &nbsp;Are those immediately marked as &#39;available for re-use&#39;, or do they stick around and just get gradually aged-out?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961863">
				<div id="div-comment-961863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Patrick Huizinga</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961863">
			January 20, 2012 at 8:02 am</a>		</div>

		<p>So what happens if you pass both the random and the sequential flags?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961873">
				<div id="div-comment-961873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961873">
			January 20, 2012 at 8:24 am</a>		</div>

		<p>The cache manager, presumably, will not cache for things that are impossible against a file handle, so it is another justification for always requesting only the access rights you need and nothing more. Many people request over broad access rights, because it&#39;s just simpler to think about things that way. (This mentality led to many of the LUA bugs that we see today.)</p>
<p>@Patrick Huizinga, semantically they are mutually exclusive, so I would have presumed the call to CreateFile will fail. The documentation does not explicitly state this, perhaps because it&#39;s just such an obvious contradiction.</p>
<p>The two flags map to NtCreateFile&#39;s FILE_SEQUENTIAL_ONLY and FILE_RANDOM_ACCESS flags. The documentation there also does not state they are incompatible with each other, again, perhaps because it is just so obvious.</p>
<p>It may be that there is some compatibility behaviour that where both are specified, it ignores both flags and leaves it to the system&#39;s heuristics. Why don&#39;t you try it and see?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961893">
				<div id="div-comment-961893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961893">
			January 20, 2012 at 8:39 am</a>		</div>

		<p>@Joshua Yes, definitely, and that&#39;s implicit &#8211; but there is a huge difference between curiosity / discovering an edge case behaviour and then going and depending on it in a &#39;real&#39; application.</p>
<p>The only way you could find both flags being set in such an application, if it even works, would be where the programmer was under a profound cloud of confusion.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961903">
				<div id="div-comment-961903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961903">
			January 20, 2012 at 8:39 am</a>		</div>

		<p>I just tried calling CreateFile with FILE_FLAG_SEQUENTIAL_SCAN|FILE_FLAG_RANDOM_ACCESS, and I was surprised to see that CreateFile succeeded, instead of failing with ERROR_INVALID_PARAMETER. So I think Patrick has a valid question in how the file data is cached/prefetched.</p>
<div class="post">[<i>I assume you&#39;re asking purely out of curiosity? Because you can&#39;t rely on any of this stuff, as I highlighted at the top of the article. I suspect &quot;something weird&quot; happens in terms of caching and prefetch, since the cache manager probably doesn&#39;t really expect you to set both. (While the behavior may be suboptimal, it will still be correct, since these flags are purely advisory.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961933">
				<div id="div-comment-961933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961933">
			January 20, 2012 at 9:26 am</a>		</div>

		<p>I am certainly curious in that, prima facie, there appears to be poor validation of input here. A mutually exclusive set of flags is accepted without ERROR_INVALID_PARAMETER being returned &#8211; I agree that what happens behind the scene, considering they are accepted, is a private implementation detail &#8211; but it would be nice to know why the call does not fail and what happens currently.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961943">
				<div id="div-comment-961943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961943">
			January 20, 2012 at 9:35 am</a>		</div>

		<p>How does these hints cope with alternate data streams?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961953">
				<div id="div-comment-961953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sean McGeough</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961953">
			January 20, 2012 at 9:39 am</a>		</div>

		<p>@640k I would be very surprised if it&#39;s not cached independently on a per-data stream basis.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961963">
				<div id="div-comment-961963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961963">
			January 20, 2012 at 9:45 am</a>		</div>

		<p>I would actually not expect CreateFile to fail if both flags are passed. These flags are caching hints only; they do not affect the ability to perform operations on the file and they do not mandate any particular behaviour. Similarly, if you pass FILE_FLAG_SEQUENTIAL_SCAN and then break the sequential access pattern, the operation should not fail, even though the caching behaviour may be suboptimal. According to MSDN: &quot;However, correct operation is still guaranteed.&quot;</p>
<p>The documentation states that they should not be used together, not that it &quot;must not&quot; be done.</p>
<p>I agree, though, that any experimental results regarding the effects of these flags should not be relied on. I&#39;m sure there are better ways to deliberately slow down your I/O if that&#39;s what you really want!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961973">
				<div id="div-comment-961973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sean McGeough</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961973">
			January 20, 2012 at 9:59 am</a>		</div>

		<p>@Falcon At the layer behind CreateFile, NtCreateFile, the flag is FILE_SEQUENTIAL_ONLY &#8211; you&#39;re telling the cache manager, as the documentation says, &quot;All accesses to the file are sequential.&quot;.</p>
<p>The other flag is FILE_RANDOM_ACCESS, you&#39;re telling the cache manager there that &quot;Accesses to the file can be random, so no sequential read-ahead operations should be performed on the file by FSDs or the system.&quot;.</p>
<p>While correct operation is guaranteed if the application tells the cache manager that it&#39;s going to use the handle for sequential I/O and then doesn&#39;t, that doesn&#39;t mean that a contradictory set of flags should be accepted in the call to CreateFile &#8211; it&#39;s impossible to satisfy both.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961983">
				<div id="div-comment-961983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961983">
			January 20, 2012 at 10:07 am</a>		</div>

		<p>@640: ADS&#39; are distinct streams. You open each data stream individually with a call to CreateFile with a distinct set of parameters. What else is there to cope with?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-961993">
				<div id="div-comment-961993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961993">
			January 20, 2012 at 10:24 am</a>		</div>

		<p>Do these flags affect (formerly) dirty page eviction after they&#39;ve been flushed, in case of a file open for writing?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-962003">
				<div id="div-comment-962003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962003">
			January 20, 2012 at 10:30 am</a>		</div>

		<p>Re: both flags specified</p>
<p>Since these flags are advisory only, the only requirement is that if both are specified, it should not cause any pathological or unusual behavior of the cache manager. One possible valid behavior is that both would be just ignored. After all, it&#39;s a valid behavior to just ignore any of them at any time, even if only one is specified.</p>
<p>Also, if such a flag is specified with FILE_FLAG_NO_BUFFERING, it would be ignored. It might be NOT ignored, if FILE_FLAG_NO_BUFFERING doesn&#39;t apply to the target device, but I don&#39;t know for sure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962013">
				<div id="div-comment-962013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962013">
			January 20, 2012 at 10:53 am</a>		</div>

		<p>What I would like to see is some statistical data on which flags software actually pass and which flags would have yielded best performance.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962023">
				<div id="div-comment-962023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/timothy_4000_roseharp.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>timothy@roseharp.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962023">
			January 20, 2012 at 11:33 am</a>		</div>

		<p>&quot;What I would like to see is some statistical data on which flags software actually pass and which flags would have yielded best performance.&quot;</p>
<p>Good idea! Please post the results of your test.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-rat odd alt thread-odd thread-alt depth-1" id="comment-962033">
				<div id="div-comment-962033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/hacksoncode' rel='external nofollow' class='url'>hacksoncode</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962033">
			January 20, 2012 at 1:26 pm</a>		</div>

		<p>Clearly, the ability to specify both flags is a forward looking design for when quantum computing becomes mainstream.</p>
<p>Then the cache manager will both pre-fetch and not pre-fetch, as well as both evicting behind and not evicting behind (it might even evict ahead just in case :-).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962043">
				<div id="div-comment-962043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NT</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962043">
			January 20, 2012 at 1:48 pm</a>		</div>

		<p>The use of the word &quot;promising&quot; near the end of the second paragraph is curious. &nbsp;Surely the &quot;not a contract&quot; nature of these flags works both ways, and passing FILE_FLAG_SEQUENTIAL_SCAN need not actually be a promise as to the way you&#39;ll use the file.</p>
<div class="post">[<i>You are correct. Poor wording on my part. &quot;Indicating&quot; would have been a better choice. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962053">
				<div id="div-comment-962053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962053">
			January 20, 2012 at 2:55 pm</a>		</div>

		<p>How do these flags play in with CopyFileEx and the COPY_FILE_NO_BUFFERING flag? I&#39;m assuming CopyFileEx has internal logic around using FILE_FLAG_SEQUENTIAL_SCAN, but I&#39;ve never really been sure on how the COPY_FILE_NO_BUFFERING flag affects things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962063">
				<div id="div-comment-962063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962063">
			January 20, 2012 at 3:19 pm</a>		</div>

		<p>NT: Raymond used the term &quot;promise&quot; in the politician&#39;s sense of the word. That is, an agreement which will only be kept when convenient.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961883">
				<div id="div-comment-961883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-961883">
			January 20, 2012 at 8:32 am</a>		</div>

		<p>@Nick Lowe, Patrick Huizinga: &quot;Why don&#39;t you try it and see?&quot;</p>
<p>I would recommend *not* depending on the results of that experiment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-962073">
				<div id="div-comment-962073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962073">
			January 20, 2012 at 6:19 pm</a>		</div>

		<p>On the other hand, the documentation of CreateFile2() in Windows 8 developer preview <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh449422(v=vs.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/hh449422(v=vs.85).aspx</a> explicitly tell you not to combine FILE_FLAG_RANDOM_ACCESS with FILE_FLAG_SEQUENTIAL_SCAN. So perheps the documentation folks are aware of it afterall.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962083">
				<div id="div-comment-962083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962083">
			January 20, 2012 at 6:44 pm</a>		</div>

		<p>@cheong00 &#8211; Good find!</p>
<p>&quot;Some of these flags should not be combined. For instance, combining FILE_FLAG_RANDOM_ACCESS with FILE_FLAG_SEQUENTIAL_SCAN is self-defeating.&quot;</p>
<p>This implies that the system ignores both when they are combined as they nullify each other.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962093">
				<div id="div-comment-962093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962093">
			January 20, 2012 at 7:44 pm</a>		</div>

		<p>I wonder how the cacheing strategy could chance in the future in the presence of SSDs? &nbsp;Performing prefetching of larger blocks on the assumption that a small seek will end up in prefetched data is OK for mechanical storage, but when seeks are free there might be more optimal cacheing strategies. &nbsp;Or does the current cache manager optimise for data reads and not bother too much about potential latency issues?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962133">
				<div id="div-comment-962133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962133">
			January 21, 2012 at 3:01 am</a>		</div>

		<p>This reminds me of the read behaviour of WordPerfect, which apparently typically started at the end of the file and worked backwards. Hopefully this would be autodetected as linear with decreasing offsets.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962113">
				<div id="div-comment-962113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962113">
			January 21, 2012 at 2:13 am</a>		</div>

		<p>@Dave: Ram disks have been around forever. On those seeks are even more free. On those I assume you should *not* hint at anything, because the cache manager is probably too stupid to take this into consideration. And maybe disable buffering also.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-andycadley2 odd alt thread-odd thread-alt depth-1" id="comment-962173">
				<div id="div-comment-962173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/AndyCadley' rel='external nofollow' class='url'>AndyCadley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962173">
			January 21, 2012 at 12:21 pm</a>		</div>

		<p>@Neil: There was a Channel 9 video on the Cache Manager a few years back and I&#39;m pretty sure they mentioned that backwards sequential access would also be detected and optimised for. Naturally though there&#39;s no guarantee that behaviour (or any other) still applies.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962203">
				<div id="div-comment-962203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Mach</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962203">
			January 22, 2012 at 3:26 am</a>		</div>

		<p>And then I read the Note at the end of this postâ¦</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962213">
				<div id="div-comment-962213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex G</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962213">
			January 22, 2012 at 4:49 pm</a>		</div>

		<p>By the way, CreateFile2 has very important feature:</p>
<p>&quot;exclusive access to a file or directory is only granted if the Metro style app has write access to the file&quot;. THis makes sure an unprivileged application is not able to block access to a system file. I&#39;d love to have this extended to regular CreateFile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962223">
				<div id="div-comment-962223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962223">
			January 22, 2012 at 5:17 pm</a>		</div>

		<p>Requiring the caller to have the ability to be granted the FILE_WRITE_DATA access right, or to have the SE_RESTORE_NAME privilege held, to be able to take an exclusive lock of some sort seems very sensible. It should not, obviously, require FILE_WRITE_DATA to be explicitly asked for in the desired access parameter though.</p>
<p>Unless I am missing something, which is very possible!, I cannot see why it should not be applied to CreateFile et al.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962233">
				<div id="div-comment-962233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lowe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962233">
			January 22, 2012 at 5:22 pm</a>		</div>

		<p>Additionally, I would have thought to permit a lock for deletion / renaming, the caller should have the ability to be granted the DELETE standard access right or the call should fail.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962253">
				<div id="div-comment-962253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Engywuck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962253">
			January 22, 2012 at 10:44 pm</a>		</div>

		<p>If I interpret this article correctly *not* passing any flags should generally yield best results, because the &quot;linear hopping&quot; case is only available that way. So unless you are absolutely sure you have sequential (or random) access not passing any parameter only has a slight performance penalty at the beginning plus the benefit of getting best results even when your program behaves differently than your expectations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962323">
				<div id="div-comment-962323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962323">
			January 23, 2012 at 12:53 pm</a>		</div>

		<p>I do not believe there to be many cases where you wouldnt know for certain that a file will be sequentially accessed. Either you are processing the whole file in one pass, or you aren&#39;t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-962373">
				<div id="div-comment-962373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962373">
			January 23, 2012 at 4:48 pm</a>		</div>

		<p>Joseph, what if you open a file and then pass it to a third-party library to read from it? &nbsp;You now have no idea whether the file is processed in one pass or not, unless that library tells you what it plans to do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962313">
				<div id="div-comment-962313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962313">
			January 23, 2012 at 9:54 am</a>		</div>

		<p>If your program behaves differently than/from/to(*) your expectations with respect to whether it&#39;s reading a file sequentially or not, I suspect you have bigger problems to worry about.</p>
<p>(*) probably a case of &quot;two countries separated by a common language&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962413">
				<div id="div-comment-962413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962413">
			January 24, 2012 at 5:44 am</a>		</div>

		<p>GregM, are you suggesting that you do that often enough for it it be called &#39;many cases&#39;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-962583">
				<div id="div-comment-962583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962583">
			January 24, 2012 at 9:38 am</a>		</div>

		<p>Are you suggesting that the cases where I do that aren&#39;t significant? &nbsp;What exactly was the point of your comment?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962673">
				<div id="div-comment-962673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962673">
			January 24, 2012 at 11:39 am</a>		</div>

		<p>GregM, I&#39;m suggesting that you made a counter-point (that had already been made many times already) to a point never made within my post. &#39;What ifs&#39; are not &#39;many cases&#39; but since you now even refuse to entertain that notion, have a nice day.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-962723">
				<div id="div-comment-962723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962723">
			January 24, 2012 at 2:36 pm</a>		</div>

		<p>Joseph, you said &quot;Either you are processing the whole file in one pass, or you aren&#39;t.&quot; &nbsp;The counterpoint was that there is a third option, &quot;you don&#39;t know&quot;. &nbsp;Another possible option is &quot;you are currently doing it, but it may change in the future.&quot; &nbsp;If that wasn&#39;t the point of your comment, what was? &nbsp;Obviously if you know you are doing sequential, you pass it. &nbsp;If you know that you aren&#39;t, then you don&#39;t. &nbsp;Were you trying to say something beyond that, because that point had already been made too?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962763">
				<div id="div-comment-962763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kuhr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120120-00/?p=8493#comment-962763">
			January 25, 2012 at 1:06 am</a>		</div>

		<p>Do these two flags only give hints to the cache manager of the local machine when calling CreateFile for a file on a local hard disk or do they also get transmitted to a remote machine when calling CreateFile for a file on a remote share so the cache manager of the remote box can optimize its behaviour for a remote client?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

