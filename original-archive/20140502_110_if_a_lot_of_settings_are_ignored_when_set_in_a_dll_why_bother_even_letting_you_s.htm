<html>
<head>
<title>If a lot of settings are ignored when set in a DLL, why bother even letting you set them on a DLL?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>If a lot of settings are ignored when set in a DLL, why bother even letting you set them on a DLL?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>May 2, 2014 / year-entry #111</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">There are many settings that are ignored when set in a DLL. /LARGE­ADDRESS­AWARE. Size­Of­Stack­Reserve and Size­Of­Stack­Commit. There are plenty of others. Commenter 640k asks why these settings even exist for DLLs if they has no effect. Because they are settings for PE modules in general. If there were separate file formats for EXEs and DLLs,...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>There are many settings that are ignored when set in a DLL. <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/09/22/10065933.aspx"> <code>/LARGE&shy;ADDRESS&shy;AWARE</code></a>. <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/08/24/10199218.aspx"> <code>Size&shy;Of&shy;Stack&shy;Reserve</code> and <code>Size&shy;Of&shy;Stack&shy;Commit</code></a>. There are plenty of others. Commenter 640k asks <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/09/22/10065933.aspx#10066537"> why these settings even exist for DLLs if they has no effect</a>.</p>
<p> Because they are settings for PE modules in general. </p>
<p> If there were separate file formats for EXEs and DLLs, then there would have to be two different module loaders, one for EXEs and one for DLLs. This creates extra work for no particular benefit aside from <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/09/13/10208973.aspx"> satisfying some anal-retentive compulsion that nothing be wasted</a>. As far as I can tell, all operating systems use a common file format for both executables and libraries. </p>
<p> If it really bothers you, you can consider this flags as <i>Reserved for future use</i> when applied to DLLs. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-koldude even thread-even depth-1" id="comment-1122673">
				<div id="div-comment-1122673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122673">
			May 2, 2014 at 7:24 am</a>		</div>

		<p>/LARGEADDRESSAWARE does actually affect DLLs at least in 64bit. I&#39;ve had problems on a legacy application that was being ported from 32 to 64bit that only showed up if that flag was set. Not surprisingly they were all related to casting pointers to ints and back. In this case setting the flag would cause the loader to load the DLL above 4gb in the address space thus corrupting the results of the casts if a pointer to a DLL resource or function was passed through it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122683">
				<div id="div-comment-1122683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SMW</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122683">
			May 2, 2014 at 7:39 am</a>		</div>

		<p>@kantos: I&#39;m guessing you had the flag set on the build of the EXE and not on the build of the DLL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-even depth-1" id="comment-1122693">
				<div id="div-comment-1122693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122693">
			May 2, 2014 at 7:46 am</a>		</div>

		<p>@SMW We tested that, it actually was the DLL itself that mattered. We specifically tested the EXE with and without it set, with the flag not set on the DLL. We could only reproduce the issue with the flag set on the DLL itself. It was very frustrating to figure out that was what was causing it.</p>
<p>On a side note: Windows 8 does seem to ignore it, but Windows 7 does not. As I was on Windows 8, my colleagues on Windows 7 were unable to reproduce the problem until the flag was set.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122703">
				<div id="div-comment-1122703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eric Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122703">
			May 2, 2014 at 8:09 am</a>		</div>

		<p>A think the more salient question would have been &quot;given they have no effect, why does Visual Studio display these settings in dll projects? &nbsp;Isn&#39;t that just causing confusion?&quot; &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1122713">
				<div id="div-comment-1122713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122713">
			May 2, 2014 at 8:16 am</a>		</div>

		<p>@kantos:</p>
<p>Haven&#39;t you got a memo that you&#39;re supposed to use INT_PTR/DWORD_PTR/ULONG_PTR from like ten years ago?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-odd thread-alt depth-1" id="comment-1122723">
				<div id="div-comment-1122723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122723">
			May 2, 2014 at 8:19 am</a>		</div>

		<p>@alegr1 or their C++ standard equivalents intptr_t, uintptr_t etc? Yes, however this code was ancient and originally written for Mac.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-davebacher even thread-even depth-1" id="comment-1122733">
				<div id="div-comment-1122733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122733">
			May 2, 2014 at 8:33 am</a>		</div>

		<p>@kantos:</p>
<p>I&#39;d be fairly surprised if the code for LoadModule didn&#39;t look something like this:</p>
<p>=====</p>
<p>HMODULE LoadModuleKernel(&#8230;)</p>
<p>{</p>
<p> &nbsp; &nbsp;PE_HEADER PE = LoadHeader(&#8230;);</p>
<p> &nbsp; &nbsp;BOOL bLOAD_BELOW_3GB = FALSE;</p>
<p> &nbsp; &nbsp;if (!PE.LARGE_ADDRESS_AWARE)</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;bLOAD_BELOW_3GB = TRUE;</p>
<p> &nbsp; &nbsp;if (ProcIs32Bit())</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;bLOAD_BELOW_3GB = TRUE;</p>
<p> &nbsp; &nbsp;if (bLOAD_BELOW_3GB)</p>
<p> &nbsp; &nbsp; &nbsp; return DoLameModuleLoad(&#8230;);</p>
<p> &nbsp; &nbsp;else</p>
<p> &nbsp; &nbsp; &nbsp; return DoSaneModuleLoad(&#8230;);</p>
<p>}</p>
<p>=====</p>
<p>That is &#8212; I&#39;d expect that it called the kernel, and asked for the module to load. &nbsp;In times of yore (Windows 3.1, 2.0, 1.04), LoadModule didn&#39;t care if it was a DLL, an EXE &#8212; it just loaded the module.</p>
<p>And so while this would not provide all the functionality for LARGE_ADDRESS_AWARE, it would have the observable side effects from the module loader. &nbsp;And therefore if Microsoft changes the module loader in a way that removes those observable side effects &#8212; say due to ASLR &#8212; then you&#39;d break.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-odd thread-alt depth-1" id="comment-1122743">
				<div id="div-comment-1122743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122743">
			May 2, 2014 at 8:51 am</a>		</div>

		<p>@Dave Bacher I suspect that&#39;s exactly what goes on at least in win7, like I said the issue occured on win8 regardless. Given the changed semantics of /LARGEADRESSAWARE in 64 ( <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/wz223b1z.aspx">msdn.microsoft.com/&#8230;/wz223b1z.aspx</a> and more importantly: <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa384271(v=vs.85).aspx">msdn.microsoft.com/&#8230;/aa384271(v=vs.85).aspx</a> ) it wouldn&#39;t surprise me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman even thread-even depth-1" id="comment-1122753">
				<div id="div-comment-1122753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122753">
			May 2, 2014 at 9:00 am</a>		</div>

		<p>&quot;[And what happens when a building is built further north than any previous building? Use negative numbers? &quot;I&#39;ll meet you at building B-3.&quot; &quot;Hey, I&#39;m at B3 and I can&#39;t find you.&quot; &quot;No, not B3. B-3. That&#39;s letter B, number negative 3.&quot; And good luck finding letters less than A. -Raymond]&quot;</p>
<p>I think that&#39;s why some maps have insets. Also why Alaska and Hawaii are not shown in tru locations on a lot of US maps. As long as there is a reference point on the inset (like a street intersection) it doesn&#39;t &quot;fall apart&quot; as you suggested in the linked to blog post.</p>
<div class="post">[<em>So the building name is &quot;Inset 1, B3&quot;? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122763">
				<div id="div-comment-1122763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122763">
			May 2, 2014 at 10:00 am</a>		</div>

		<p>Too bad SizeOfStackReserve is ignored. Oh well.</p>
<p>Unfortunately the stack size the application needs to reserve for kernel32 calls isn&#39;t documented. Sometimes memory really is tight and reducing the size of spawned threads is a good idea.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122793">
				<div id="div-comment-1122793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark (The Other Mark)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122793">
			May 2, 2014 at 11:23 am</a>		</div>

		<p>[So the building name is &quot;Inset 1, B3&quot;? -Raymond]</p>
<p>Could be even more flexible- Often, Insets overlap. So it might be B3 on Inset 1, but B17 on Inset 4.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122803">
				<div id="div-comment-1122803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122803">
			May 2, 2014 at 11:36 am</a>		</div>

		<p>&quot;@alegr1 or their C++ standard equivalents intptr_t, uintptr_t etc? Yes, however this code was ancient and originally written for Mac.&quot;</p>
<p>If it was really ancient, it might have been using ptrdiff_t and size_t, since C solved this particular problem several decades ago. (And yes, I&#39;m aware that Win64 made a bit of a mess of the traditional C integer sizes.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122843">
				<div id="div-comment-1122843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122843">
			May 2, 2014 at 12:01 pm</a>		</div>

		<p>@Ken: you&#39;re giving C too much credit. Neither size_t nor ptrdiff_t are necessarily adequate types for storing converted pointers, though they will be on a lot of implementations. The language doesn&#39;t care much how you do this conversion, since it&#39;s implementation-defined; if you want to do this, you&#39;re supposed to know how anyway. intptr_t and uintptr_t weren&#39;t added to C until C99, and even then they&#39;re optional.</p>
<p>And even so, you can&#39;t expect the legions of people who &quot;know&quot; an int is exactly 32 bits to appreciate something as delicate as ptrdiff_t. Of course, the moment you start thinking &quot;typedef long LONG;&quot; is a good idea, you&#39;ve already lost&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122863">
				<div id="div-comment-1122863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122863">
			May 2, 2014 at 12:30 pm</a>		</div>

		<p>[So the building name is &quot;Inset 1, B3&quot;? -Raymond]</p>
<p>Don&#39;t be ridiculous! In order to be useful the insets can&#39;t overlap any actual building, so they can use the same grid. That way building B3 can be north of B1 even though numbers increase going southward.</p>
<p>Of course eventually you&#39;ll run out of room for non-overlapping insets and will have to redraw the map with more grid squares. At that point the buildings will all get different coordinates, so you will need to have the building names qualified with the map version in order to eliminate ambiguities.</p>
<p>In other words, the building once known as 1995A-B3 might now be known as 2014C-AX23, but once map revision 2014C is ubiquitous you&#39;ll be able to just call it AX23.</p>
<p>See how easy it all could be? Now isn&#39;t that a small price to pay for not having to deal with seemingly random building names?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122873">
				<div id="div-comment-1122873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">M Hotchin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122873">
			May 2, 2014 at 12:36 pm</a>		</div>

		<p>It makes no sense for the loader to special case these flags, but what about the linker? &nbsp;It already &#39;knows&#39; if it&#39;s producing a DLL or an EXE, could it not issue a warning when nonsense flags are applied?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122893">
				<div id="div-comment-1122893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122893">
			May 2, 2014 at 1:04 pm</a>		</div>

		<p>Sorry, in the above, I obviously meant &quot;that it&#39;s at least as big as a &#39;short&#39;&quot;. Of course it&#39;s at least as big as a &quot;char&quot; as well, since &quot;short&quot; is, but if I&#39;m not mentioning all integer types I should only mention the immediate neighbors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122903">
				<div id="div-comment-1122903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122903">
			May 2, 2014 at 2:29 pm</a>		</div>

		<p>@JM: Prior to Windows x64, all the FAQs for C said for 64 bit integer on 64 bit machine use int. The documentation in the K&amp;R book for ANSI C called for int to be the natural or most performant integer supported by the platform.</p>
<p>&gt; &quot;The design error in C here went very long uncorrected.&quot;</p>
<p>The design error of not having intptr_t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122813">
				<div id="div-comment-1122813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122813">
			May 2, 2014 at 11:39 am</a>		</div>

		<p>@Joshua: if memory is as tight as that, better not spawn threads to begin with. In fact, if *memory* is the restricting factor for a thread-heavy application on Windows, you&#39;re almost certainly doing it wrong.</p>
<p>Source: painful memories of wrestling with code written to assume threads are free (some ported from other platforms, where they&#39;re at least cheaper).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122833">
				<div id="div-comment-1122833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122833">
			May 2, 2014 at 11:57 am</a>		</div>

		<p>By the way, /LARGEADDRESSAWARE actually *does* make a difference on 64-bit *EXEs*, it&#39;s just that the linker defaults it to on for obvious reasons. &nbsp;If you link a 64-bit EXE with /LARGEADDRESSAWARE:NO, it will be limited to 2 GB =) &nbsp;I suppose that you could use this along with GCC to make an &quot;x32&quot; environment like Linux has, but you&#39;d get no help from the C runtime or Win32 in this regard &#8211; you&#39;d still have to call Win32 with 64-bit pointers.</p>
<p>@Joshua: The trick I use to have a large stack for the main thread but a small default stack size for spawned threads is to set the small stack size in the EXE header, then swap stacks in wWinMain. &nbsp;To swap stacks to a larger one, ConvertThreadToFiber, CreateFiberEx with new stack size and wWinMain replacement, SwitchToFiber, DeleteFiber original fiber, ConvertFiberToThread to exit fiber mode.</p>
<p>@Raymond: Is it *safe* to set /LARGEADDRESSAWARE and /TSAWARE on DLLs, or does doing so risk future incompatibility? &nbsp;Just wondering, with the way you worded them about being reserved bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122853">
				<div id="div-comment-1122853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122853">
			May 2, 2014 at 12:27 pm</a>		</div>

		<p>&gt; typedef long LONG</p>
<p>The idea is to edit the typedef for different compilers or architectures. It&#39;s merely archaic not wrong. This way of thinking finally broke down when 64 bit came along and threw a monkey-wrench into everything when int needed to be 64 bit on some platforms thus making 32 bit integer a non-accessible type.</p>
<p>(Windows use of int as a 32 bit integer is an error according to the C standard for all platforms other than x64 which has the correct instructions in its opcode table so that 32 bit memory reads to 64 bit registers perform as well as 64 bit memory reads to 64 bit registers).</p>
<p>ptrdiff_t = intptr_t is true of all flat architectures and most others. The only exceptions I know are DOS compact and DOS large where a single object can&#39;t be &gt;64kb in size. (Note that casting a code pointer to void * is not guaranteed to cast back except in flat architectures &#8212; use void (*)() instead). The design error in C here went very long uncorrected.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122883">
				<div id="div-comment-1122883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122883">
			May 2, 2014 at 12:59 pm</a>		</div>

		<p>@Joshua: &quot;The idea is to edit the typedef for different compilers or architectures. It&#39;s merely archaic not wrong.&quot;</p>
<p>C&#39;s integer sizes allow code to be flexible in sizing to whatever the architecture can support. Rather than writing for an exact number of bits, you can write for &quot;natural&quot; sizes, and the limits of your program are determined by your platform. Unfortunately, programmers basically said &quot;screw that, I want a high-level assembly language and I need an integer type that is precisely 32 bits&quot;, when C offers no such type (or offered, I should say, since from C99 onwards it does offer such types if the platform has them). Arguably, writing for a type system that gives exact type sizes is easier, and the loss in flexibility is no great loss, given that portability (actual portability, not the one achieved by hiding everything behind #defines) is not on most people&#39;s priority lists anyway. The trouble only starts when people find out that, ironically, their exact-sized types weren&#39;t differentiated enough because (oh dear) it turns out pointers need to be not exactly 32 bits after all.</p>
<p>As such, &quot;typedef long INT32&quot; would be barely acceptable, with the provision that you would replace &quot;long&quot; with whatever type on your platform is 32 bits wide. &quot;typedef long LONG&quot; helps nobody &#8212; if you want a C long, use &quot;long&quot;, if you want an integer type that can hold values of at least 32 bits, use &quot;long&quot; (since that&#39;s what a C long *is*), if you want an integer type that is precisely 32 bits, use int32_t on C99 and whatever your platform has before that &#8212; but then don&#39;t call the typedef something confusing like LONG.</p>
<p>&quot;Windows use of int as a 32 bit integer is an error according to the C standard for all platforms other than x64 which has the correct instructions in its opcode table so that 32 bit memory reads to 64 bit registers perform as well as 64 bit memory reads to 64 bit registers&quot;</p>
<p>What you just said is meaningless in the context of the C standard, which says nothing about instructions, opcodes or performance. The standard says the type &quot;int&quot; is guaranteed to hold values in the range -32767 through 32767, that it&#39;s at least as big as a &quot;char&quot;, that it&#39;s at most as big as a &quot;long&quot;, and that&#39;s about it.</p>
<p>&quot;The design error in C here went very long uncorrected.&quot;</p>
<p>Where was the design error in *C*? DOS was an unpleasant platform, but C supported it just fine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122913">
				<div id="div-comment-1122913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122913">
			May 2, 2014 at 11:43 pm</a>		</div>

		<p>&quot;The documentation in the K&amp;R book for ANSI C called for int to be the natural or most performant integer supported by the platform.&quot;</p>
<p>Which is absolutely ridiculous. If you&#39;re writing a for loop then you need to know how large a number the variable can contain. If you do:</p>
<p>for (int i = 0; i &lt; 2000; i++)</p>
<p>and then compile that for a 6502 where the most performant integer is 8 bits then you have a problem.</p>
<p>K&amp;R are like your grandpa, they might have done great things during their lives but they don&#39;t have anywhere near enough exposure at the coal face these days to make any kind of recommendations.</p>
<p>C++ would ideally have a way of saying &quot;I need this variable to be exactly 32 bits&quot; and also &quot;I need this variable to hold this number of bits or more&quot;.</p>
<p>Something like int8, int8+, int16, int16+, int32, int32+, int64, int64+ etc</p>
<p>Potentially you could have &quot;I need a variable that is as fast as possible, but no more then n bits&quot;. But I don&#39;t know how you&#39;d write code that used that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122923">
				<div id="div-comment-1122923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122923">
			May 3, 2014 at 4:13 am</a>		</div>

		<p>@If there were separate file formats for EXEs and DLLs, then there would have to be two different module loaders, one for EXEs and one for DLLs.</p>
<p>Or the file format could be designed to be solely concerned with mapping the image into memory. Everything that has nothing to do with that can go somewhere else.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122933">
				<div id="div-comment-1122933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122933">
			May 3, 2014 at 9:33 am</a>		</div>

		<p>@Ken Hagan: if it was ancient, it might be using &quot;a long is at least as wide as a pointer&quot; (that is, a pointer fits within a long), which was true for any sane system before Win64 decided that a long was 32-bit even with 64-bit pointers. Before 1999, we didn&#39;t have C99 with its helpful stdint.h (AFAIK, the Microsoft C compilers still don&#39;t have stdint.h, but there are generic stdint.h headers for Windows which can be used), so if the code was older than that, it wouldn&#39;t be surprising for it to use a &quot;long&quot; to store a pointer, instead of uintptr_t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1122943">
				<div id="div-comment-1122943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122943">
			May 3, 2014 at 11:46 am</a>		</div>

		<p>@smf: you might want to look at &lt;cstdint&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122953">
				<div id="div-comment-1122953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122953">
			May 4, 2014 at 1:22 am</a>		</div>

		<p>&quot;If it really bothers you, you can consider this flags as Reserved for future use when applied to DLLs.&quot;</p>
<p>Fair point. I find myself no longer worried.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-andycadley2 even thread-even depth-1" id="comment-1122963">
				<div id="div-comment-1122963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/AndyCadley' rel='external nofollow' class='url'>AndyCadley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122963">
			May 4, 2014 at 5:34 am</a>		</div>

		<p>@Joshua: In that case, it was the FAQs that were wrong, no how Windows handles things on x64. FWIW though, I believe both K&amp;R have subsequently said that the whole business over &quot;natural&quot; sizes in the C spec turned out to be bad design and one of those things they&#39;d have done differently with the benefit of hindsight.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1122983">
				<div id="div-comment-1122983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1122983">
			May 4, 2014 at 10:35 am</a>		</div>

		<p>@Myria</p>
<p>No need to worry.</p>
<p>As usual, MS wount re-use any flags on future windows versions becuase it risks breaking badly written apps.</p>
<p>On 128-bit windows there will be a flag like /LARGEADDRESSAWARE128, instead of using any already well known flags.</p>
<p>Now when I think about it, didn&#39;t it exist a image flag which 16-bit binaries could set which indicated they was aware of flat 32-bit addresses?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1123003">
				<div id="div-comment-1123003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Edward M. Grant</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1123003">
			May 4, 2014 at 7:00 pm</a>		</div>

		<p>&quot;The design error of not having intptr_t.&quot;</p>
<p>If there was a design error, it was allowing programmers to cast pointers to integers and vice-versa. We learned not to do that back in the early 90s, because it inevitably caused problems with any kind of portable code, and there was never a good reason to do it in user code. Yeah, maybe there was some optimization that saved a few clock cycles, but it cost days of developer time to debug when it broke on a new OS or architecture.</p>
<p>Is there really any good reason to do such things in the 21st century, other than calling some weird system call interface that passes arbitrary data as an integer?</p>
<p>Back on topic, I&#39;ve also noticed that Windows 7 x64 seems to obey the flag when set on a DLL. I&#39;ve tried flagging some games to use more than 2GB as they were crashing with big mods installed, and they didn&#39;t seem to do so unless I set the flag on every DLL they load. Not needing to do that would be good if true, but it doesn&#39;t seem to be the case?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1123013">
				<div id="div-comment-1123013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1123013">
			May 4, 2014 at 10:59 pm</a>		</div>

		<p>@640k : Anyway because of physical limitation of CPU (also known as &quot;5nm will be the end of Moore&#39;s law&quot;), I doubt we&#39;ll see it be put into mass production before 2020 or even 2030.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1123023">
				<div id="div-comment-1123023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">blah</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1123023">
			May 5, 2014 at 3:52 am</a>		</div>

		<p>@smf:</p>
<p>&gt; C++ would ideally have a way of saying &quot;I need this variable to be exactly 32 bits&quot; and also &quot;I need this variable to hold this number of bits or more&quot;.</p>
<p>You mean like int_least32_t/int_fast32_t?</p>
<p><a rel="nofollow" target="_new" href="http://en.cppreference.com/w/cpp/types/integer">en.cppreference.com/&#8230;/integer</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1123133">
				<div id="div-comment-1123133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1123133">
			May 5, 2014 at 11:32 am</a>		</div>

		<p>@Edward M. Grant: intptr_t was always the right type for the baton. Lots of places used void * instead.</p>
<p><a rel="nofollow" target="_new" href="http://svn.haxx.se/dev/archive-2002-07/0396.shtml">svn.haxx.se/&#8230;/0396.shtml</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1123283">
				<div id="div-comment-1123283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1123283">
			May 6, 2014 at 3:57 am</a>		</div>

		<p>@blah &nbsp; </p>
<p>Already pointed out on this thread, I obviously haven&#39;t kept up with all the new stuff added for c++11 (the c++ projects I work on are old and need to compile on old unsupported platforms too). Quite why they weren&#39;t in the original C standard has always been beyond me, register widths in 1978 were less standardised than they are now.</p>
<p>I ended up having to write C for a Z80 project that for speed and size reasons, small loops would be written as</p>
<p>unsigned char i;</p>
<p>for (i = 0; i &lt; 10; i++)</p>
<p>using an int or even a char produced slower and larger code. The same code also ran on arm and intel processors but size and speed overheads were less of an issue there, so we just lived with it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1123293">
				<div id="div-comment-1123293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Obnoxious Human</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140502-00/?p=1093#comment-1123293">
			May 6, 2014 at 5:40 am</a>		</div>

		<p>In regards to the building numbers:</p>
<p>I already knew that Microsoft took backwards compatibility to a ludicrous extreme. I had no idea that this also extended to the numbering of buildings! There was a major expansion; great time to update the building numbers! (yes, actually change a buildings designator! Shocking!) A couple of emails and maybe a week of &quot;what&#39;s building 7 called now?&quot;, and everything is right with the world. Sheesh. You could apply this to Windows as well, and maybe it would have a little less entropy. </p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

