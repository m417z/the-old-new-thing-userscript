<html>
<head>
<title>When DLL_PROCESS_DETACH tells you that the process is exiting, your best bet is just to return without doing anything</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>When DLL_PROCESS_DETACH tells you that the process is exiting, your best bet is just to return without doing anything</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 5, 2012 / year-entry #7</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>52</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">When the Dll­Main function receives a reason code of DLL_PROCESS_DETACH, the increasingly-inaccurately-named lpReserved parameter to is used to indicate whether the process is exiting. And if the process is exiting, then you should just return without doing anything. No, really. Don't worry about freeing memory; it will all go away when the process address space...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>When <a href="http://msdn.microsoft.com/library/ms682583.aspx"> the <code>Dll&shy;Main</code> function</a> receives a reason code of <code>DLL_<wbr>PROCESS_<wbr>DETACH</wbr></wbr></code>, the increasingly-inaccurately-named <code>lpReserved</code> parameter to is used to indicate whether the process is exiting.</p>
<p> And if the process is exiting, then you should just return without doing anything. </p>
<p> No, really. </p>
<p> Don't worry about freeing memory; it will all go away when the process address space is destroyed. Don't worry about closing handles; handles are closed automatically when the process handle table is destroyed. Don't try to call into other DLLs, because those other DLLs may already have received their <code>DLL_<wbr>PROCESS_<wbr>DETACH</wbr></wbr></code> notifications, in which case they may behave erratically in the same way that a <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/05/23/10167156.aspx#10167462"> Delphi</a> object behaves erratically if you try to use it after its destructor has run. </p>
<p> <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/11/18/10238335.aspx"> The building is being demolished</a>. Don't bother sweeping the floor and emptying the trash cans and erasing the whiteboards. And don't line up at the exit to the building so everybody can move their in/out magnet to <i>out</i>. All you're doing is making the demolition team wait for you to finish these pointless housecleaning tasks. </p>
<p> Okay, if you have internal file buffers, you can write them out to the file handle. That's like remembering to take the last pieces of mail from the mailroom out to the mailbox. But don't bother closing the handle or freeing the buffer, in the same way you shouldn't bother updating the "mail last picked up on" sign or resetting the flags on all the mailboxes. And ideally, you would have flushed those buffers as part of your normal wind-down before calling <code>Exit&shy;Process</code>, in the same way mailing those last few letters should have been taken care of before you called in the demolition team. </p>
<p> I regularly use a program that doesn't follow this rule. The program allocates a lot of memory during the course of its life, and when I exit the program, it just sits there for several minutes, sometimes spinning at 100% CPU, sometimes churning the hard drive (sometimes both). When I break in with the debugger to see what's going on, I discover that the program isn't doing anything productive. It's just methodically freeing every last byte of memory it had allocated during its lifetime. </p>
<p> If my computer wasn't under a lot of memory pressure, then most of the memory the program had allocated during its lifetime hasn't yet been paged out, so freeing every last drop of memory is a CPU-bound operation. On the other hand, if I had kicked off a build or done something else memory-intensive, then most of the memory the program had allocated during its lifetime has been paged out, which means that the program pages all that memory back in from the hard drive, just so it could call <code>free</code> on it. Sounds kind of spiteful, actually. "Come here so I can tell you to go away." </p>
<p> All this anal-rententive memory management is pointless. The process is exiting. All that memory will be freed when the address space is destroyed. <i>Stop wasting time and just exit already</i>. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (52)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-957053">
				<div id="div-comment-957053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957053">
			January 5, 2012 at 7:10 am</a>		</div>

		<p>And doing all that uses up extra battery power. &nbsp;Apple has an iOS programming guideline somewhere saying that when your app is exiting, don&#39;t bother trying to free all of your memory to avoid wasting battery power, since the OS takes care of all that when you exit.</p>
<p>The one case where you do want to free every byte on exit is if you&#39;re checking for memory leaks, but you should not be doing that in shipping software, only in debug builds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mngoldeneagle odd alt thread-odd thread-alt depth-1" id="comment-957073">
				<div id="div-comment-957073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957073">
			January 5, 2012 at 7:30 am</a>		</div>

		<p>JS Bangs: If your program regularly allocates anywhere from 200MB to 2GB+ of RAM each time it&#39;s run and then tries to deallocate everything when it receives a shutdown notification from the OS, then it&#39;s doing a disservice to both the user and the computer by taking five to ten minutes to do all that unnecessary cleanup. <span style="color:#ff0000;">Program XXX</span> does this regularly for me, and while I don&#39;t run into the issue often (as I rarely close <span style="color:#ff0000;">the program</span>), I do run into it whenever I need to install an addon or update to the latest version. It can be very annoying sometimes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957083">
				<div id="div-comment-957083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957083">
			January 5, 2012 at 7:37 am</a>		</div>

		<p>This is a deep problem of current language design, IMO. &nbsp;If this guarantee had been available many years ago, modern languages could well be designed with support for &quot;system exiting, don&#39;t bother&quot;. &nbsp;It could well be rolled into the standard runtime libraries that Microsoft supplies for Visual C++ and into .NET directly.</p>
<p>Trivial uses of this concept can help modern software: for obvious large-buffer allocation one could easily write the additional code necessary to know whether to discard the buffers or actually deallocate them.</p>
<p>But as a system issue, new language support (or at least library support) will be necessary IMO.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957093">
				<div id="div-comment-957093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">avakar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957093">
			January 5, 2012 at 7:45 am</a>		</div>

		<p>A simple solution would be to turn <code>free</code> into a no-op when the application begins termination.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957113">
				<div id="div-comment-957113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957113">
			January 5, 2012 at 7:54 am</a>		</div>

		<p>I agree with JS. &nbsp;I doubt the issue is that the app is &quot;bothering&quot; to do anything. &nbsp;The memory clean-up probably happens as a natural consequence of the way the program is structured.</p>
<p>That being said, I can think of a few ways you could deal with this situation, even using the RAII pattern. &nbsp;For example, you could just call ExitProcess() to short cut the destructors. &nbsp;You could also override operator delete so that it doesn&#39;t do anything on shutdown.</p>
<p>Anyway, in general I don&#39;t think this is something you should worry about. &nbsp;Take such measures only if you see a performance problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957133">
				<div id="div-comment-957133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mijzelf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957133">
			January 5, 2012 at 8:00 am</a>		</div>

		<p>My programs also always cleanup everything. This way you can check whether it has not been leaking. Of course this is only necessary in debug builds, but when you switch it off in release builds, this might introduce other bugs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957143">
				<div id="div-comment-957143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Patrick Simpson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957143">
			January 5, 2012 at 8:06 am</a>		</div>

		<p>I tend to set up my programs so all state is reached through one singleton object. In the debug build I destroy this when exiting, in the release build I don&#39;t bother. This gives me all the benefits of finding leaks in debug builds without taking ages to shut down in the release version.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957153">
				<div id="div-comment-957153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957153">
			January 5, 2012 at 8:08 am</a>		</div>

		<p>Leo Davidson: it should be safe to skip the destructors of global objects, regardless of what they do; after all you could experience a power failure, or the user could kill the process using Task Manager. Or Windows itself might kill the process; I&#39;ve seen this happen when an application took too long to close on system shutdown.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957173">
				<div id="div-comment-957173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957173">
			January 5, 2012 at 8:15 am</a>		</div>

		<p>Exception: Shared memory used for IPC. Freeing it is irrelevant but you probably need to tell the other end you&#39;re hanging up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957183">
				<div id="div-comment-957183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JS Bangs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957183">
			January 5, 2012 at 8:25 am</a>		</div>

		<p>If you actually care about this issue in your app, then the thing to do is to manually perform whatever cleanup is absolutely necessary, then call TerminateProcess(). Boom, no more process, no extra cleanup, no dlls getting notifications, nothing.</p>
<p>Obviously you shouldn&#39;t do this in a shared library.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dwalker-wk even thread-even depth-1" id="comment-957223">
				<div id="div-comment-957223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957223">
			January 5, 2012 at 9:20 am</a>		</div>

		<p>@Leo Davidson: &nbsp;You&#39;re mostly right, but if you combine lots of small allocations within your program into a situation where you ask the OS for one large piece of memory, and then you use various parts of that larger piece for your program, then you are essentially writing a second level of memory allocation/deallocation. &nbsp;You might have to handle the semantics of your program no longer needing one of the small pieces of memory within the larger chunk, and so on. &nbsp;Are you going to rewrite all of that code which the language and/or the language libraries already provide? &nbsp;</p>
<p>The tradeoffs get complicated&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957243">
				<div id="div-comment-957243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Philip Taron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957243">
			January 5, 2012 at 9:28 am</a>		</div>

		<p>It must be noted that Application Verifier <a href="http://www.microsoft.com/download/en/details.aspx?displaylang=en&amp;id=20028" target="_new" rel="nofollow">http://www.microsoft.com/&#8230;/details.aspx</a> will flag your application as having many memory and handle leaks should you do this. There are also resources, such as SQL connections or shared memory or other non-system managed but persistent and long-lived connections that you may truly have to close at this time. Perhaps this is analogous to removing highly flammable materials from your building before it is demolished.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957253">
				<div id="div-comment-957253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957253">
			January 5, 2012 at 9:39 am</a>		</div>

		<p>The solution is to use private heaps in the application code.</p>
<p>Here is how C++ class should look in that case:</p>
<ol>
<li>Constructor calls HeapCreate() and stores a heap handle.</li>
<li>
<p>Add a method GetMem() for a class &#8211; it will use heap handle for small allocations</p>
</li>
<li>
<p>Destructor calls HeapDestroy() &#8211; it is better than 1000s of calls to HeapFree</p>
</li>
</ol>
<p>Now, make that class a base class for other sub-components.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-957263">
				<div id="div-comment-957263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957263">
			January 5, 2012 at 9:46 am</a>		</div>

		<p>Make sure to have your towel with you, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jader3rd even thread-even depth-1" id="comment-957283">
				<div id="div-comment-957283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jader3rd' rel='external nofollow' class='url'>jader3rd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957283">
			January 5, 2012 at 11:17 am</a>		</div>

		<p>So how would you go about teaching and designing the proper behavior? I think that most &#39;good&#39; programs will be modularized well and each module will know how to clean itself up properly, but in a way which allows for the application to keep running. But when the whole process shuts down all it knows to do is to call cleanup on all of the individual modules, which don&#39;t differentiate between proper clean up and &quot;just flush the buffers because we&#39;re abandoning the building&quot;.</p>
<p>Visual Studio is the worst offender because they send their SQM data on shutdown which can create some very long shutdowns. A process shouldn&#39;t start doing an action on shutdown.</p>
<div class="post">[<i>I suspect Visual Studio is not sending SQM data during DLL_PROCESS_DETACH. They&#39;re probably doing it before the <code>ExitProcess</code>. Because issuing an HTTP request during DLL_PROCESS_DETACH will almost certainly hang. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957293">
				<div id="div-comment-957293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cleek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957293">
			January 5, 2012 at 11:26 am</a>		</div>

		<p>@jader3rd</p>
<p>god, i hate Visual Studio shutdowns. Friday afternoon, 5pm rolls around i&#39;m packing up. i have to allocate five minutes to shut down the VS instances i&#39;ve left running all week.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957313">
				<div id="div-comment-957313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cleek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957313">
			January 5, 2012 at 11:42 am</a>		</div>

		<p>@Paul M. Parks</p>
<p>some days, i do. but i always feel a little nervous about it. i don&#39;t want to interrupt VS if it&#39;s doing something important with my files.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957343">
				<div id="div-comment-957343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957343">
			January 5, 2012 at 12:58 pm</a>		</div>

		<p>it&#39;s common sense that you don&#39;t need to free ram on exit because is being freed anyway.</p>
<p>But in practice, it&#39;s an horrible thing to get into or recommend to other developers. &nbsp;Once you start leaking on exit because &quot;it&#39;s ok&quot;, the developers no longer check for CRT leaks on exit (In VC++&#39;s output window, for example) because there is too much stuff in there anyway, and software beings to leak memory all over the place. It&#39;s dumb to try to build a whole new testing system to try to avoid that, when the developers can test their code for years every time they exit the app from the debugger for free.</p>
<p>@avakar Stubbing out &#39;free&#39; during an exit (in Ship anyway)? That&#39;s a pretty clever idea.</p>
<div class="post">[<i>It&#39;s more than just freeing memory. It&#39;s all the other random cleanup stuff that happens. If you try it during <code>DLL_PROCESS_ATTACH</code>, you may discover that your cleanup code calls into a DLL that has <span style="text-decoration:underline;">already been uninitialized</span>, and then craziness ensues. See paragraph 4. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957353">
				<div id="div-comment-957353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957353">
			January 5, 2012 at 1:05 pm</a>		</div>

		<p>Why single out Delphi here? If you try to access data after you&#39;ve freed it you&#39;ll get unpredictable behavior in any language.</p>
<div class="post">[<i>If you follow the link, you&#39;ll see that Burak was complaining that my writing is too C++-focused and he uses Delphi. So I figured I&#39;d make this a Delphi-focused entry. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957363">
				<div id="div-comment-957363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957363">
			January 5, 2012 at 1:17 pm</a>		</div>

		<p>@Mason Wheeler: Follow the link and search &quot;Delphi&quot; in the page</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957373">
				<div id="div-comment-957373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957373">
			January 5, 2012 at 2:15 pm</a>		</div>

		<p>C++ 11 got std::quick_exit for this. The only thing I don&#39;t know is when and how it&#39;ll be implemented. (and so how usefull it&#39;ll be)</p>
<p>Ref: <a rel="nofollow" target="_new" href="http://en.cppreference.com/w/cpp/utility/program/quick_exit" rel="nofollow">en.cppreference.com/&#8230;/quick_exit</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957393">
				<div id="div-comment-957393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957393">
			January 5, 2012 at 2:41 pm</a>		</div>

		<p>@benajmin: I saw one application that needed to be closed gracefully.</p>
<p>It turns out the developer version of mumps db runs from the notification area, and if killed without a graceful shutdown, wait 30 minutes for it to consistency check its databases on startup.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957413">
				<div id="div-comment-957413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Garrick McPherson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957413">
			January 5, 2012 at 3:07 pm</a>		</div>

		<p>You still must be careful to dispose of the memory of the process. It cannot be guaranteed that all the memory the process allocated is freed because the process could have hidden some memory elsewhere (a favourite place is in USB memory sticks). &nbsp;You should check for plugged in memory sticks before shutting down the process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957063">
				<div id="div-comment-957063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JS Bangs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957063">
			January 5, 2012 at 7:21 am</a>		</div>

		<p>The problem, of course, is that you may not be able to stop the cleanup tasks from running, or to eliminate them without greatly complicating your program. An obvious example: if your program is written in C++ and you&#39;ve used RAII everywhere, then all of your destructors are going to run during process shutdown, and those will deallocate memory, close file handles, flush buffers, etc. You can&#39;t tell the C++ runtime &quot;don&#39;t call any destructors during process shutdown&quot; (and doing so would be asking for trouble later). You *could* have a global flag that says &quot;process shutdown in progress&quot; and have all of the destructors do nothing if the flag is set, but that&#39;s a lot of extra work to go through for what is, most of the time, a very marginal benefit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957443">
				<div id="div-comment-957443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957443">
			January 5, 2012 at 3:41 pm</a>		</div>

		<p>Why specific to DLL_PROCESS_DETACH?</p>
<p>Shouldn&#39;t the title be: &quot;When your process is exiting&#8230;&quot;</p>
<p>&quot;I regularly use a program that doesn&#39;t follow this rule.&quot; No name and shame? We all know you&#39;re talking about Visual Studio :)</p>
<div class="post">[<i>It&#39;s specific to DLL_PROCESS_DETACH because in DLL_PROCESS_ATTACH you may not be able to guarantee that your DLL gets its DLL_PROCESS_DETACH <span style="text-decoration:underline;">before</span> another DLL that you depend on. (And &quot;name and shame&quot; is explicitly contrary to the <a href="http://blogs.msdn.com/oldnewthing/archive/2004/02/21/77681.aspx" rel="nofollow">ground rules</a>.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957103">
				<div id="div-comment-957103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Leo Davidson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957103">
			January 5, 2012 at 7:54 am</a>		</div>

		<p>Programs that spend a long time freeing memory &#8212; at process exit or otherwise &#8212; can often be improved by putting all those tiny allocations into one or more separate memory heaps/pools which can be thrown away in a single, fast operation when needed.</p>
<p>It&#39;s often the case that the same problem affects other situations &#8212; e.g. closing a &#39;document&#39; but not the whole program &#8212; so tackling the more general case seems better to me. And I agree with JS Bangs: I&#39;d rather just write my code to work properly in the general case than have to write, test and maintain special-case logic to skip clean-up on shutdown.</p>
<p>As was said in the main post, you can&#39;t skip *all* clean-up without inspecting what it does, so it&#39;s not as simple as killing the process and bypassing all destructors/clean-up code.</p>
<p>If I have to think about which objects and sub-objects to destroy, why I&#39;m destroying them, which parts of the code to skip depending on the circumstances, re-evaluating all those choices when child objects change (anyone who has had to add IDisposable to a .Net object that&#39;s already in use will know that problem), etc&#8230; then that seems like a lot of effort, all to help only one situation, when making the clean-up fast in all situations is often no more effort in the short term (and definitely less effort in the long term) and benefits more situations.</p>
<p>I guess what I&#39;m saying is, the fact that the program can&#39;t clean up its unwanted memory quickly is the real problem, not that it is cleaning up before shutdown.</p>
<p>But, okay, I agree there are cases where the advise is sound. If you know that process shutdown is and will forever be the only time that a buffer will be freed, and you don&#39;t care about leak-checking tools, then it makes sense not to free the buffer. I just don&#39;t think it&#39;s a good idea in the general case, where you don&#39;t know those things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957463">
				<div id="div-comment-957463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timmy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957463">
			January 5, 2012 at 5:20 pm</a>		</div>

		<p>A few years a go you said: It is not good to leak memory and let the operating system clean up your mess and now you are saying leak-away ?!</p>
<p>Take this blog post for example: <a href="http://blogs.msdn.com/b/oldnewthing/archive/2007/07/19/3945339.aspx" target="_new" rel="nofollow">blogs.msdn.com/&#8230;/3945339.aspx</a></p>
<p>(bing search really do suck at finding stuff, even at microsofts own websites, gee)</p>
<p>So what is it ? Is leaking memory / handels good or bad ?</p>
<p>This is confusing.</p>
<div class="post">[<i>Somebody who thinks they can clean up window handles in DLL_PROCESS_ATTACH has already messed up, because windows have thread affinity. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957473">
				<div id="div-comment-957473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957473">
			January 5, 2012 at 5:57 pm</a>		</div>

		<p>@Timmy I wouldn&#39;t be nitpicking here if the design of your applications caused you to having to clean up window handles in DLL_PROCESS_DETACH. Talk about horrible design..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957483">
				<div id="div-comment-957483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim Lyon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957483">
			January 5, 2012 at 6:11 pm</a>		</div>

		<p>+1 for TerminateProcess. Especially during an abnormal exit. Especially in shutting down a multi-threaded monster.</p>
<p>I&#39;ve seen too many people waste too much time architecting and debugging a clean shutdown. It&#39;s seldom worth it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-957493">
				<div id="div-comment-957493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957493">
			January 5, 2012 at 6:23 pm</a>		</div>

		<p>@Timmy: Your DLL should provide function to cleanup handles that it allocated to perform it&#39;s function. The calling application should be calling them to free the handles before your DLL recevie DLL_PROCESS_DETACH. If the application do not call them, your DLL shouldn&#39;t attempt to free them for the application on DLL_PROCESS_DETACH.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957503">
				<div id="div-comment-957503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957503">
			January 5, 2012 at 7:14 pm</a>		</div>

		<p>@Anonymous coward: &quot;it should be safe to skip the destructors of global objects, regardless of what they do; after all you could experience a power failure, or the user could kill the process using Task Manager.&quot;</p>
<p>Of course, it&#39;s also understood that it&#39;s generally reasonably acceptable to lose data in situations such as those. And even if you don&#39;t lose data, that the program may have to do some extra work on next startup to check its own consistency.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957303">
				<div id="div-comment-957303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul M. Parks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957303">
			January 5, 2012 at 11:38 am</a>		</div>

		<p>@cleek: You *could* just be a brute by closing your projects, opening task manager, and killing all instances of devenv.exe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957383">
				<div id="div-comment-957383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">benjamin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957383">
			January 5, 2012 at 2:19 pm</a>		</div>

		<p>This kind of reminds me of people that feel the need to exit any running program (including stuff in the systr&#8211;excuse me, notification area) before rebooting.</p>
<p>It&#39;s *already* restarting, broheim, don&#39;t worry about it.</p>
<p>What&#39;s funny is that I know people that continue this behavior with their phones, where they&#39;ll close any app on their iPhone before rebooting it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957423">
				<div id="div-comment-957423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe White</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957423">
			January 5, 2012 at 3:14 pm</a>		</div>

		<p>Of course, as you commented in a previous blog entry, if you&#39;ve allocated lots of window handles or GDI handles (I forget which), it will take the OS a long time to free them, because the program *is* supposed to clean those up before it exits, and you don&#39;t optimize the OS for ill-behaved programs.</p>
<p>Then again, you should probably be freeing your window handles well before you get to DLL_PROCESS_DETACH.</p>
<div class="post">[<i>Right. If you&#39;re cleaning up window handles in DLL_PROCESS_ATTACH, then you messed up your design pretty horrible. After all, you don&#39;t control what thread gets the DLL_PROCESS_DETACH! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957543">
				<div id="div-comment-957543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957543">
			January 6, 2012 at 5:41 am</a>		</div>

		<p>@Timmy</p>
<p>Generally, in DLL_PROCESS_ATTACH you are doing the minimum required to get the DLL itself up and running. So the only things you should be allocating here are kernel objects (mutex, TLS, shared memory) and memory. These get cleaned up immediately after process termination so if you haven&#39;t cleaned these up then there is no real pressing concern. So what Raymond was saying is that during DLL_PROCESS_DETACH, don&#39;t worry about kernel objects or memory, these get cleaned up right away. It is less frustrating for your users if you close down quickly by not doing pointless cleaning up.</p>
<p>What that article you linked to was refering to was user and GDI handles. There is a bit of a difference in how these are handled as they don&#39;t get cleaned up immediately like kernel handles do. But I guess this also requires understanding what you are doing in the DLL startup code, and when I said minimum required to get the DLL up and running, that doesn&#39;t include creating windows or allocating GDI objects. Anyway, part of the DllMain documentation explicitly states</p>
<p>&quot;Calling functions that require DLLs other than Kernel32.dll may result in problems that are difficult to diagnose. For example, calling User, Shell, and COM functions can cause access violation errors, because some functions load other system components. Conversely, calling functions such as these during termination can cause access violation errors because the corresponding component may already have been unloaded or uninitialized.&quot;</p>
<p>so it is against good practice to even attempt silly things like creating the kinds of handles that the link was refering to.</p>
<p>But to clear up two things. This is talking about DLL specific cleanup not process general cleanup. So you shouldn&#39;t take this in the context of what happens when the entire application is exiting, but in the brief period of time during the entire applicaiton exiting where the single DLL that you wrote is processing DLL_PROCESS_DETACH. Secondly, Raymond&#39;s posts often require you to use some common sense and if you have something that requires cleaning up then you should do it anyway regardless. He never used words like must or required. He used words like should or best bet. This indicates that it is advice, and that you are free to ignore it, but please seriously concider doing it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957553">
				<div id="div-comment-957553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957553">
			January 6, 2012 at 5:52 am</a>		</div>

		<p>@Raymond, re: &quot;It&#39;s specific to DLL_PROCESS_DETACH because&#8230;&quot;</p>
<p>If I understand you correctly, you&#39;re saying &quot;Don&#39;t bother sweeping the floor because you can&#39;t do it correctly in DLL_PROCESS_DETACH anyway, and also you&#39;re wasting time because the building is being demolished.&quot;</p>
<p>My previous comment was trying to ask, isn&#39;t the &quot;wasting time&quot; argument sufficient? Would it be reasonable to say &quot;Don&#39;t sweep the floor if you know the building is being demolished (whether or not you&#39;re in DllMain)&quot;?</p>
<div class="post">[<i>Sure, you could generalize it if you wanted to. But remember, <a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/11/04/9917052.aspx" rel="nofollow">good advice comes with a rationale so you can tell when it becomes bad advice</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957563">
				<div id="div-comment-957563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957563">
			January 6, 2012 at 7:19 am</a>		</div>

		<p>@Jon</p>
<p>I have actually read advice before that if a service is shutting down, especially on system shutdown to do it as fast as possible and just leak whatever you need to shut down as fast as possible.</p>
<p>So you could easily extend it to process shutdown in general, as long as you stick to kernel handles and memory then there should be very few consequences. (Of course, common sense applies here too.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957583">
				<div id="div-comment-957583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957583">
			January 6, 2012 at 8:00 am</a>		</div>

		<p>@Crescens2k: I don&#39;t trust DllMain() for setup or teardown anymore because I was bitten long ago when I wrote a system hook DLL. Originally I had the setup logic in DLL_PROCESS_ATTACH, but often the hook procedure would be called before DllMain got a chance to get things going! Fortunately I didn&#39;t have a need for cleanup in that DLL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957663">
				<div id="div-comment-957663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957663">
			January 6, 2012 at 8:52 am</a>		</div>

		<p>@avakar</p>
<p>Remember that turning Free() in a nop doesn&#39;t solve the problem. Assume i start with a pointer to a list of objects that has been paged out. i can&#39;t just free the pointer, i must free the objects. So now i have to page-in my list of 10,000 customers. That&#39;s because each customer contains pointers to more data (For example a CustomerName string). Then each Customer can have a list of contacts. Each contact must be paged in, so i can free them.</p>
<p>The expensive part isn&#39;t the actual freeing of memory. The performance hit is iteratively following every pointer down, chasing down every last pointer, until you&#39;ve traversed every object you have allocated. That recursive process is a waste.</p>
<p>But it&#39;s 10,000% worse if those pages have been swapped out to disk.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957723">
				<div id="div-comment-957723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">harningt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957723">
			January 6, 2012 at 9:55 am</a>		</div>

		<p>Just a note &#8211; we&#39;ve been bitten by a bug in Outlook since it calls TerminateProcess to kill itself to avoid cleanup slowdown&#8230; problem is&#8230; PCSC (via winscard.dll) requires &#39;clean&#39; shutdown, else device transactions are held open. We ran into problems w/ leaked transactions and put something in DllMain and noticed afterwards that it just isn&#39;t called&#8230; further debugging w/ Depends let us see that no Dll cleanup was performed at all on shutdown &#8211; yielding the TerminateProcess conclusion for Outlook 2010. From a KB article about a 2007 &#39;slow shutdown fix&#39;, I am guessing in Outlook 2007 they switched to TerminateProcess to close out so that Outlook plugins/etc couldn&#39;t slow things down (too bad Outlook or the KB doesn&#39;t document the low-level reality).</p>
<p>Technically PCSC should know the process is dead, but we had to take other complicated measures to perform the clean up.</p>
<p>If only there was another call made on shutdown to notify DLLs that they are going to be dead soon, so perform some nice cleanup before closing out kills all threads/etc&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-957743">
				<div id="div-comment-957743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957743">
			January 6, 2012 at 10:05 am</a>		</div>

		<p>@Garrick McPherson:</p>
<blockquote><p>
  process could have hidden some memory elsewhere (a favourite place is in USB memory sticks).
</p></blockquote>
<p>I&#39;m afraid what you&#39;re saying makes no sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-957753">
				<div id="div-comment-957753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957753">
			January 6, 2012 at 10:07 am</a>		</div>

		<blockquote><p>
  This kind of reminds me of people that feel the need to exit any running program (including stuff in the systr&#8211;excuse me, notification area) before rebooting
</p></blockquote>
<p>I guess they&#39;re conditioned into that by a &quot;helpful&quot; Vista+ list of &quot;hung&quot; applications, that doesn&#39;t allow you to respond to the application prompts for saving files. Me, at least.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ws-livestarkov-name even thread-even depth-1" id="comment-957773">
				<div id="div-comment-957773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Roman.St' rel='external nofollow' class='url'>Roman.St</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957773">
			January 6, 2012 at 10:51 am</a>		</div>

		<p>My god Raymond, this is so true. I&#39;ve always wondered why C++ programmers bother so carefully to free their static global objects <em>just before</em> the program exits anyway. That seems like a most pointless way of spending CPU cycles.</p>
<p>It&#39;s a real shame that essentially nobody distinguishes mandatory cleanup (like flushing buffers) from optional resource-freeing (like memory and handles)&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957793">
				<div id="div-comment-957793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957793">
			January 6, 2012 at 11:35 am</a>		</div>

		<p>romkyns: Actually .NET now has the notion of &quot;critical finalizers&quot;, which refers to things that really need to perform mandatory cleanup. This is used to ensure that buffers get flushed, but you could also use one for deleting temp files, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957843">
				<div id="div-comment-957843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gregory</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957843">
			January 7, 2012 at 12:01 am</a>		</div>

		<p>&quot;I regularly use a program that doesn&#39;t follow this rule. The program allocates a lot of memory during the course of its life, and when I exit the program, it just sits there for several minutes, sometimes spinning at 100% CPU, sometimes churning the hard drive (sometimes both).&quot;</p>
<p>I know what you&#39;ve been through. I&#39;m also using <span style="color:red;">Program X</span> a lot.</p>
<div class="post">[<i>You seem not to have gotten the hint when I deleted your first comment for violation of <a href="http://blogs.msdn.com/oldnewthing/archive/2004/02/21/77681.aspx" rel="nofollow">the Ground Rules</a> linked to from every page, so this time I&#39;m leaving your comment up but with the violation removed. And nobody has yet guessed correctly. NOT THAT I WANT ANYBODY TO BE GUESSING IN THE FIRST PLACE. Because like it says in the ground rules, &quot;the purpose is to discuss problems and solutions, not to assign blame and ridicule.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957873">
				<div id="div-comment-957873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957873">
			January 7, 2012 at 4:43 am</a>		</div>

		<p>Apparently even the CRT calls free on shutdown, if the comments in <a rel="nofollow" target="_new" href="http://mxr.mozilla.org/mozilla-central/source/memory/mozutils/Makefile.in#100" rel="nofollow">mxr.mozilla.org/&#8230;/Makefile.in</a> are to be believed. (I couldn&#39;t get the debug 32-bit CRT to call free_dbg on shutdown, but I could get the debug 64-bit CRT to.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957883">
				<div id="div-comment-957883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957883">
			January 7, 2012 at 11:01 am</a>		</div>

		<p>@romkyns: That&#39;s the total opposite of what I&#39;ve always heard from C++ fans, who love the &quot;uniform treatment of resources&quot; that RAII provides.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957893">
				<div id="div-comment-957893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957893">
			January 7, 2012 at 2:23 pm</a>		</div>

		<p>The trick to make shutdown work with RAII is to call exit() from high on the stack and never fall off main. Then most RAII cleanup never happens. You have to go out of your way to flush buffers unless you&#39;re using stdio or iostreams which is hardwired to know about it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957903">
				<div id="div-comment-957903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">don't be so sure</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957903">
			January 7, 2012 at 3:34 pm</a>		</div>

		<p>This isn&#39;t always true. Plugins implemented via dlls will unload via process detach, but it doesn&#39;t mean the process is exiting.</p>
<p>Attach a debugger to winamp or somthing and watch what happens when you fiddle with the plugins.</p>
<p>Freeing memory and closing file handles isn&#39;t going to peg your cpu so long you notice or care. Something else is probablt going on with your favorite prgram</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-957913">
				<div id="div-comment-957913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jas71_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jas71@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957913">
			January 7, 2012 at 4:42 pm</a>		</div>

		<p>&quot;Freeing memory and closing file handles isn&#39;t going to peg your cpu so long you notice or care. Something else is probablt going on with your favorite prgram&quot;</p>
<p>It will if it&#39;s a long-running app with either a memory leak or a long history implemented by something like a linked list. If it&#39;s, say, Raymond&#39;s web browser/music player/text editor, keeping a 4 kb block of current state with a pointer to the previous state etc back to the start, you could easily end up with lots and lots of disk thrashing. Each of those blocks will have been paged out &#8211; potentially at different times, hence to different bits of the pagefile &#8211; at which point every single block will involve a disk seek. That 1 Gb undo/history buffer which seemed so reasonable at the time just became the cause of a quarter-million disk seeks, tying up a typical drive for 20 minutes in the worst case! (In practice, I&#39;m sure many of those page-ins would happen to be readahead cache hits, but it&#39;s still painful.)</p>
<p>Maxing out the CPU as well as/instead of the disk? Someone complained about the app taking a gigabyte of RAM/swap, so the developer switched to storing it in a file &#8211; and to deal with complaints about the size, stuck in a simple compression library. Whoops: now each time it frees a single block of data, it&#39;s uncompressing and recompressing a bigger block of data and writing that back to disk.</p>
<p>I don&#39;t know or particularly care what Raymond&#39;s specific &#39;X&#39; is: the important thing is that we can all imagine what it&#39;s doing and why. The programs MNGoldenEagle, Gregory and Raymond are thinking of probably aren&#39;t the same; I&#39;ve seen this myself, in a program Raymond probably doesn&#39;t run. It&#39;s possible they all get this from linking to the same library for something &#8211; more likely, it&#39;s just a common mistake.</p>
<p>In fact, I seem to recall either Raymond or Mark Russinovich had an example program which allocated a silly number of Windows objects, then exited (optionally being a &#39;good&#39; program by cleaning itself up first), and letting the system clean up the resources implicitly by exiting was much, much faster than doing it yourself first. I can&#39;t seem to find the post right now, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-957933">
				<div id="div-comment-957933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-957933">
			January 7, 2012 at 10:22 pm</a>		</div>

		<p>@don&#39;t be so sure</p>
<p>The thing is, he wasn&#39;t talking about that case since it is easy to distinguish between when DLL_PROCESS_DETACH is being called because of FreeLibrary and when it is being called at process exit.</p>
<p>In this case Raymond was not talking about the DLL being dynamically unloaded, he was talking about it being unloaded as part of process shutdown.</p>
<p>The very first thing you do in the detach is check the lpReserved parameter.</p>
<p>if(lpReserved == NULL)</p>
<p>{</p>
<p>&nbsp; &nbsp;//free memory and resources here</p>
<p>}</p>
<p>You see, it is clearly documented that that parameter is used to determine the difference between dynamic loads/unloads and static loads/unloads. Anyway, common sense dictates that you would make sure you do this in a dynamic unload anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-958023">
				<div id="div-comment-958023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120105-00/?p=8683#comment-958023">
			January 9, 2012 at 6:06 am</a>		</div>

		<p>@alegr1 About hiding memory in USB, I really hope the original comment was meant as a joke.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

