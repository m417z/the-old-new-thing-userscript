<html>
<head>
<title>Closing over the loop variable is just as harmful in JavaScript as it is in C#, and more cumbersome to fix</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Closing over the loop variable is just as harmful in JavaScript as it is in C#, and more cumbersome to fix</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 5, 2014 / year-entry #140</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>38</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Prerequisite reading: Closing over the loop variable considered harmful. JavaScript has the same problem. Consider: function hookupevents() { for (var i = 0; i < 4; i++) { document.getElementById("myButton" + i) .addEventListener("click", function() { alert(i); }); } } The most common case where you encounter this is when you are hooking up event handlers in...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Prerequisite reading:
<a HREF="http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx">
Closing over the loop variable considered harmful</a>.
</p>
<p>
JavaScript has the same problem.
Consider:
</p>
<pre>
<i>function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  document.getElementById("myButton" + i)
   .addEventListener("click",
         function() { alert(i); });
 }
}</i>
</pre>
<p>
The most common case where you encounter this is when you are hooking
up event handlers in a loop, so that's the case I used as an example.
</p>
<p>
No matter which button you click, they all alert <code>4</code>,
rather than the respective button number.
</p>
<p>The reason for this is given in the prerequisite reading:
You closed over the loop variable,
so by the time the function actually executed,
the variable <code>i</code> had the value <code>4</code>,
since that's the leftover value after the loop is complete.
</p>
<p>
The cumbersome part is fixing the problem.
In C#, you can just copy the value to a scoped local
and capture the local,
but that doesn't work in JavaScript:
</p>
<pre>
<i>function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  <font COLOR=blue>var j = i;</font>
  document.getElementById("myButton" + i)
   .addEventListener("click",
         function() { alert(<font COLOR=blue>j</font>); });
 }
}</i>
</pre>
<p>
Now the buttons all alert <code>3</code> instead of <code>4</code>.
The reason is that JavaScript variables have
<i>function</i> scope, not block scope.
Even though you declared <code>var j</code> inside a block,
the variable's scope is still the entire function.
In other words, it's as if you had written
</p>
<pre>
<i>function hookupevents() {
 <font COLOR=blue>var j;</font>
 for (var i = 0; i &lt; 4; i++) {
  <font COLOR=blue>j = i;</font>
  document.getElementById("myButton" + i)
   .addEventListener("click",
         function() { alert(j); });
 }
}</i>
</pre>
<p>
Here's a function which emphasizes this
"variable declaration hoisting" behavior:
</p>
<pre>
function strange() {
 k = 42;
 for (i = 0; i &lt; 4; i++) {
  var k;
  alert(k);
 }
}
</pre>
<p>
The function alerts <code>42</code> four times
because the variable <code>k</code> refers to the same
variable <code>k</code> throughout the entire function,
<i>even before it has been declared</i>.
</p>
<p>
That's right.
JavaScript lets you use a variable before declaring it.
</p>
<p>
The scope of JavaScript variables is the function,
so if you want to create a variable in a new scope,
you have to put it in a new function,
since functions define scope.
</p>
<pre>
function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  <font COLOR=blue>var handlerCreator = function(index) {
   var localIndex = index;
   return function() { alert(localIndex); };
  };
  var handler = handlerCreator(i);</font>
  document.getElementById("myButton" + i)
   .addEventListener("click", <font COLOR=blue>handler</font>);
 }
}
</pre>
<p>
Okay, now things get weird.
We need to put the variable into its own function,
so we do that by declaring a helper function
<code>handler&shy;Creator</code> which creates event handlers.
Since we now have a function, we can create a new local variable
which is distinct from the variables in the parent function.
We'll call that local variable <code>local&shy;Index</code>.
The handler creator function saves its parameter in the
<code>local&shy;Index</code> and then creates and returns the actual handler
function, which uses <code>local&shy;Index</code> rather than <code>i</code>
so that it uses the captured value rather than the original variable.
</p>
<p>
Now that each handler gets a separate copy of <code>local&shy;Index</code>,
you can see that each one alerts the expected value.
</p>
<p>
Now, I wrote out the above code the long way for expository purposes.
In real life, it's shrunk down quite a bit.
</p>
<p>
For example, the <code>index</code> parameter itself can be used
instead of the <code>local&shy;Index</code> variable,
since parameters can be viewed as merely conveniently-initialized
local variables.
</p>
<pre>
function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  var handlerCreator = function(index) {
   return function() { alert(<font COLOR=blue>index</font>); };
  };
  var handler = handlerCreator(i);
  document.getElementById("myButton" + i)
   .addEventListener("click", handler);
 }
}
</pre>
<p>
And then the <code>handler&shy;Creator</code> variable
can be inlined:
</p>
<pre>
function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  var handler = <font COLOR=blue>(function(index) {
   return function() { alert(index); })</font>(i);
  document.getElementById("myButton" + i)
   .addEventListener("click", handler);
 }
}
</pre>
<p>
And then the <code>handler</code> itself can be inlined:
</p>
<pre>
function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  document.getElementById("myButton" + i)
   .addEventListener("click",
       <font COLOR=blue>(function(index) {
         return function() { alert(index); })(i)</font>);
 }
}
</pre>
<p>
The pattern
<code>(function (x) { ... })(y)</code>
is misleadingly called
the <i>self-invoking function</i>.
It's misleading because the function doesn't invoke itself;
the outer code is invoking the function.
A better name for it would be the
<i>immediately-invoked function</i>
since the function is invoked immediately upon definition.
</p>
<p>
The next step is to change
then the name of the helper <code>index</code> variable
to simply <code>i</code> so that the connection
between the outer variable and the inner variable can be made
more obvious (and more confusing to the uninitiated):
</p>
<pre>
function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  document.getElementById("myButton" + i)
   .addEventListener("click",
       <font COLOR=blue>(function(<font COLOR=blue>i</font>) {
         return function() { alert(<font COLOR=blue>i</font>); })(i)</font>);
 }
}
</pre>
<p>
The pattern
<code>(function (x) { ... })(x)</code>
is an idiom that means
"For the enclosed block of code,
capture <code>x</code> <i>by value</i>."
And since functions can have more than one parameter,
you can extend the pattern to
<code>(function (x, y, z) { ... })(x, y, z)</code>
to capture multiple variables by value.
</p>
<p>
It is common to move the entire loop body into the pattern,
since you usually refer to the loop variable multiple times,
so you may as well capture it just once and reuse the captured
value.
</p>
<pre>
function hookupevents() {
 for (var i = 0; i &lt; 4; i++) {
  <font COLOR=blue>(function(i) {</font>
   document.getElementById("myButton" + i)
    .addEventListener("click", function() { alert(i); });
  <font COLOR=blue>})(i);</font>
 }
}
</pre>
<p>
Maybe it's a good thing that the fix is more cumbersome in JavaScript.
The fix for C# is easier to type, but it is also rather subtle.
The JavaScript version is quite explicit.
</p>
<p>
<b>Exercise</b>:
The pattern doesn't work!
</p>
<pre>
var o = { a: 1, b: 2 };
document.getElementById("myButton")
 .addEventListener("click",
   (function(o) { alert(o.a); })(o));
o.a = 42;
</pre>
<p>
This code alerts <code>42</code> instead of <code>1</code>,
even though I captured <code>o</code> by value.
Explain.
</p>
<p>
<b>Bonus reading</b>:
C# and ECMAScript approach solving this problem in two different ways.
In C# 5,
<a HREF="http://www.mindscapehq.com/blog/index.php/2012/03/18/what-else-is-new-in-c-5/">
the loop variable of a <code>foreach</code> loop
is now considered scoped to the loop</a>.
ECMAScript code name Harmony
<a HREF="http://ariya.ofilabs.com/2013/05/es6-and-block-scope.html">
proposes a new <code>let</code> keyword</a>.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (38)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1129293">
				<div id="div-comment-1129293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129293">
			June 5, 2014 at 7:13 am</a>		</div>

		<p>OK C# is weird. Expected block scope but function lifetime but then again natural methods of compilation choke on returning closures.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129303">
				<div id="div-comment-1129303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129303">
			June 5, 2014 at 7:14 am</a>		</div>

		<p>Because Javascript values are references, and hence the &quot;value&quot; of o is the reference to the object, whose &quot;a&quot; field you changed to 42.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129313">
				<div id="div-comment-1129313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129313">
			June 5, 2014 at 7:15 am</a>		</div>

		<p>This is why jQuery.each is such a godsend.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129333">
				<div id="div-comment-1129333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129333">
			June 5, 2014 at 7:31 am</a>		</div>

		<p>Actually, there&#39;s a significantly shorter version:</p>
<p>function hookupevents() {</p>
<p>for (var i = 0; i &lt; 4; i++) {</p>
<p>&nbsp; document.getElementById(&quot;myButton&quot; + i)</p>
<p>&nbsp; &nbsp;.addEventListener(&quot;click&quot;, function(i) { alert(i); }.bind(this, i));</p>
<p>&nbsp;}</p>
<p>}</p>
<p>}</p>
<p>(This also, incidentally, removes the need for the &#39;var self = this&#39; hack and lets you refer to this inside the closure just fine.) In the future, you&#39;ll be able to do the same fix as C# by declaring your variables with let rather than var. If you iterate with Array.prototype.forEach rather than a for loop, you also avoid this problem.</p>
<div class="post">[<em>Ah, <code>bind</code>. I wish more people knew about <code>bind</code>. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1129343">
				<div id="div-comment-1129343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129343">
			June 5, 2014 at 7:38 am</a>		</div>

		<p>JavaScript: FORTRAN of XXI century.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129353">
				<div id="div-comment-1129353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129353">
			June 5, 2014 at 7:44 am</a>		</div>

		<p>I can deal with a lot of JavaScript&#39;s faults, and I think they&#39;re exaggerated in many cases, but the function scoping and variable hoisting are just awful design decisions and cause problems almost every time I write JavaScript. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129393">
				<div id="div-comment-1129393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129393">
			June 5, 2014 at 7:51 am</a>		</div>

		<p>And my previous post was too long so I split it.</p>
<p>Exercise: If you had overwritten the ENTIRE o object, you&#39;d get 1, since you&#39;d be clobbering the o object with a new value and the old o would still exist as the variable you passed into the function. &nbsp;But instead you are changing the object&#39;s property. &nbsp;Javascript arguments are always passed by reference; even primitives:</p>
<p>var a = 1;</p>
<p>(function(a) {</p>
<p> &nbsp;setTimeout(function() {</p>
<p> &nbsp; &nbsp;console.log(a.b);</p>
<p> &nbsp;});</p>
<p>})(a);</p>
<p>a.b = 2;</p>
<p>This outputs &quot;2&quot;. &nbsp;If numbers were passed by value, you&#39;d get &quot;undefined&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129403">
				<div id="div-comment-1129403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129403">
			June 5, 2014 at 7:56 am</a>		</div>

		<p>@David Best part is it&#39;s easy enough to write a shim for legacy IE browsers if you need to do that.</p>
<p>jQuery even has a shim built in: $.proxy.</p>
<p>@Tim Easy enough to avoid though&#8230; just don&#39;t use closure. &nbsp;There are usually &quot;proper&quot; ways to pass stuff around unless you&#39;re using some of the behaviors of closure to do stuff like simulate static private variables for a class.</p>
<p>But then debugging tools can&#39;t see those variables, since they are out of scope. &nbsp;Would be nice to have proper JS support for classes&#8230; but then again I have to code for IE7/8 so it&#39;s not like I&#39;d be using them any time this decade&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129423">
				<div id="div-comment-1129423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Blank</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129423">
			June 5, 2014 at 8:21 am</a>		</div>

		<p>The real way to do this in JS is:</p>
<p>function hookupevents() {</p>
<p> for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp;let localIndex = i;</p>
<p> &nbsp;document.getElementById(&quot;myButton&quot; + localIndex)</p>
<p> &nbsp; .addEventListener(&quot;click&quot;, function() { alert(localIndex); });</p>
<p> }</p>
<p>}</p>
<p>Of course, if you can shuffle things around a bit, you can do it like this:</p>
<p>function hookupevents() {</p>
<p> &nbsp;for (let button of document.getElementsByClass(&quot;ourbuttons&quot;))</p>
<p> &nbsp; &nbsp;button.addEventListener(&quot;click&quot;, () =&gt; alert(button.getAttribute(&quot;index&quot;));</p>
<p>}</p>
<p>but then you wouldn&#39;t be having the issue at hand anyway. (You would, instead, be having the issue of your script not working on anything that&#39;s not Firefox, which you could alleviate somewhat by using Array.prototype.forEach.call(), but that&#39;s just nasty.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129453">
				<div id="div-comment-1129453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129453">
			June 5, 2014 at 10:14 am</a>		</div>

		<p>Python has this problem too. &nbsp;Variables are just names, so like with Javascript, you can&#39;t just create a &quot;new&quot; variable. &nbsp;The most common technique is to exploit another gotcha to cancel the first gotcha out. &nbsp;Namely, function argument default values are only evaluated once, when the function is declared. &nbsp;Normally, this causes problems for people who want to use a mutable value as the default for an argument. &nbsp;But in this case, it means we can force eager evaluation of the loop variable:</p>
<p>l = []</p>
<p>for i in range(10):</p>
<p> &nbsp; &nbsp;l.append(lambda x=i: x)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129483">
				<div id="div-comment-1129483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">prprcupofcoffee</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129483">
			June 5, 2014 at 10:47 am</a>		</div>

		<p>Amazing. Javascript has the same variable declaration semantics as VB6 &#8211; a variable declared anywhere in a function can be used anywhere in the function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129503">
				<div id="div-comment-1129503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129503">
			June 5, 2014 at 10:58 am</a>		</div>

		<p>@The MAZZTer, @Mike Caron, you&#39;re both right, kind of.</p>
<p>Old JScript (and that means IE in &lt;= 8 mode) will clobber the enclosing block or the global open. It clobs the name of a named function expression when executed.</p>
<p>But even from JavaScript 1.5 / ECMAScript 3rd Edition, it shouldn&#39;t. &nbsp;It&#39;s a bug you&#39;ll have to deal with when supporting old IE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129523">
				<div id="div-comment-1129523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ancient_Hacker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129523">
			June 5, 2014 at 12:01 pm</a>		</div>

		<p>All this internal variables to a closure makes my brain ache.</p>
<p>How about we just revert back to plain unassailable TEXT so we are SURE that a constant is being used, something like:</p>
<p>for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp; var func = eval( &nbsp; &nbsp; &nbsp;&quot;function() { alert(&quot; + i + &quot;); }&quot; &nbsp; &nbsp;);</p>
<p> &nbsp; document.getElementById( &quot;myButton&quot; + i ).addEventListener( &quot;click&quot;, func ); &nbsp; </p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129273">
				<div id="div-comment-1129273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Christian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129273">
			June 5, 2014 at 7:09 am</a>		</div>

		<p>The example in the exercise alerts 42 because the function gets the same instance &quot;o&quot; and the last line changes a field of the *same* instance. Instead of using another instance.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129283">
				<div id="div-comment-1129283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Damien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129283">
			June 5, 2014 at 7:11 am</a>		</div>

		<p>You captured the object *reference* by value, not the object itself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129383">
				<div id="div-comment-1129383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129383">
			June 5, 2014 at 7:51 am</a>		</div>

		<p>Ooh I write JS for a living, this stuff is easy for me.</p>
<p>JavaScript closure (allowing you to embed functions inside functions and use variables from higher up) is powerful but as you showed can be confusing if you&#39;re not aware of the intricacies.</p>
<p>Another example, let&#39;s say you have the following code:</p>
<p>$(&quot;.jqueryrocks&quot;).each(function() {</p>
<p> &nbsp;open = $(this).attr(&quot;open&quot;);</p>
<p> &nbsp;if (open) {</p>
<p> &nbsp; &nbsp;$(this).removeAttr(&quot;open&quot;);</p>
<p> &nbsp; &nbsp;// do something with the value</p>
<p> &nbsp;}</p>
<p>});</p>
<p>Since open is undeclared, the JS engine looks through closure for a declared variable. &nbsp;When it can&#39;t find one, it uses the property on the global object (window), creating it if it didn&#39;t exist.</p>
<p>But it already exists. &nbsp;Congrats, your undeclared variable has just blown away the built-in function window.open. &nbsp;This is a fun bug if your code uses a window property, especially if the code that clobbers it or the code that uses is only called under specific conditions, and especially if the property value is simple enough that you can&#39;t immediately recognise where it came from. &nbsp;I have seen a lot of window.i in my day, who knows where those are getting set from.</p>
<p>A more confusing variant, though it doesn&#39;t have to do with closure:</p>
<p>Let&#39;s say you have this code:</p>
<p>SomeClass.prototype.open = function() {</p>
<p> &nbsp;/* &#8230; */</p>
<p>}</p>
<p>Now, let&#39;s say someone else gets their hand on this code, and their fancy text editor has a feature that allows you to view all function names in the file&#8230; but this function has no name and the editor is not smart enough to figure out it is &quot;open&quot; so it does not show up properly.</p>
<p>So they figure, &quot;I&#39;ll just do this!&quot;</p>
<p>SomeClass.prototype.open = function open() {</p>
<p> &nbsp;/* &#8230; */</p>
<p>}</p>
<p>Again&#8230; you&#39;ve clobbered window.open. &nbsp;As a bonus, on legacy versions of it, it looks like IE creates two instances of your function for both places! &nbsp;I worked on a project where this was standard syntax for DreamWeaver support (though everyone stopped using it long ago). &nbsp;Fun.</p>
<p>As for the stuff in this post&#8230; I have a different method of solving this problem:</p>
<p>function hookupevents() {</p>
<p> for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp;var element = document.getElementById(&quot;myButton&quot; + i);</p>
<p> &nbsp;element.index = i;</p>
<p> &nbsp;element.addEventListener(&quot;click&quot;, function() { alert(this.index); });</p>
<p> }</p>
<p>}</p>
<p>Though if I could I&#39;d use jQuery, DOM work is so much easier:</p>
<p>function hookupevents() {</p>
<p> for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp;$(&quot;#myButton&quot; + i).data(&quot;index&quot;, i).click(function() { alert($(this).data(&quot;index&quot;)); });</p>
<p> }</p>
<p>}</p>
<p>Beautiful. &nbsp;To be fair I&#39;m not sure what .data() does that makes it&#39;s verboseness worth it&#8230; however when you clone nodes you lose custom properties, and I assume based on how I know .data() works you end up duplicating the data on node clone.</p>
<p>As long as I&#39;m here:</p>
<p>function hookupevents() {</p>
<p> &nbsp;// Assuming we can just add a css class onto all buttons. &nbsp;Look, we can add as many buttons as we want now!</p>
<p> &nbsp;$(&quot;.myButton&quot;).click(function() { alert($(this).data(&quot;index&quot;)); }).each(function(index) {</p>
<p> &nbsp; &nbsp;$(this).data(&quot;index&quot;, index);</p>
<p> &nbsp;});</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129553">
				<div id="div-comment-1129553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129553">
			June 5, 2014 at 3:49 pm</a>		</div>

		<p>@Ancient_Hacker:</p>
<p>Sometimes, the variable you want to close over can&#39;t be trivially converted to text and back again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129443">
				<div id="div-comment-1129443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Caron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129443">
			June 5, 2014 at 10:02 am</a>		</div>

		<p>@The MAZZter</p>
<p>&gt; SomeClass.prototype.open = function open() {</p>
<p>&gt; &nbsp;/* &#8230; */</p>
<p>&gt; }</p>
<p>&gt; </p>
<p>&gt; Again&#8230; you&#39;ve clobbered window.open.</p>
<p>That doesn&#39;t do what you claim it does. It allows the function to invoke itself by name (open()) rather than through the class you were assigning to (someClassInst.open()). It doesn&#39;t touch window.open, although it does hide it if you don&#39;t qualify which open you are referring to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129573">
				<div id="div-comment-1129573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SomeGuyOnTheInternet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129573">
			June 5, 2014 at 6:20 pm</a>		</div>

		<p>VB.NET 2012 Winforms example&#8230; (VB.NET gives a compiler warning on the MsgBox line about it, yay VB.NET!)</p>
<p>Public Class Form1</p>
<p> &nbsp;Sub New()</p>
<p> &nbsp; &nbsp;&#39; This call is required by the designer.</p>
<p> &nbsp; &nbsp;InitializeComponent()</p>
<p> &nbsp; &nbsp;&#39; Add any initialization after the InitializeComponent() call.</p>
<p> &nbsp; &nbsp;For i As Integer = 1 To 4</p>
<p> &nbsp; &nbsp; &nbsp;Dim btn As Button = DirectCast(Me.Controls.Find(&quot;Button&quot; &amp; i.ToString, True)(0), Button)</p>
<p> &nbsp; &nbsp; &nbsp;Dim ce = Sub(sender As Object, e As EventArgs)</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MsgBox(i.ToString)</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End Sub</p>
<p> &nbsp; &nbsp; &nbsp;AddHandler btn.Click, ce</p>
<p> &nbsp; &nbsp;Next i</p>
<p> &nbsp;End Sub</p>
<p>End Class</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1129583">
				<div id="div-comment-1129583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129583">
			June 5, 2014 at 6:36 pm</a>		</div>

		<p>@The MAZZTer: For the same reason you had better not to create methods with the same name as document/window members. If you have to you should always attach a prefix to it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129593">
				<div id="div-comment-1129593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dsn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129593">
			June 5, 2014 at 9:23 pm</a>		</div>

		<p>@ancient_hacker</p>
<p>What if we were iterating over strings, and someone put in a string like &quot;); doBadStuff(&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129603">
				<div id="div-comment-1129603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">whatever</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129603">
			June 5, 2014 at 10:14 pm</a>		</div>

		<p>There&#39;s one more option that I like even more and that&#39;s a partially applied function for these cases.</p>
<p>Some JavaScript libraries (Prototype.js?) have a function for creating them (in JavaScript) already, and it&#39;s not that complicated to roll your own anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129613">
				<div id="div-comment-1129613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129613">
			June 6, 2014 at 2:12 am</a>		</div>

		<p>Is C++ the only language where you get to choose if you want to capture each variable by reference or value?</p>
<p>Avoids all these problems. (And probably introduces a load of new ones :P )</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129633">
				<div id="div-comment-1129633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129633">
			June 6, 2014 at 3:51 am</a>		</div>

		<p>The Java version&#8230; well, using inner classes, since I don&#39;t know whether Java has closures yet, avoids the problem by requiring captured variables to be final. This pretty much requires you to make a local copy inside the loop.</p>
<p>And here&#39;s an ugly JavaScript version for completeness:</p>
<p>function Alerter(i) {</p>
<p> &nbsp;this.i = i;</p>
<p>}</p>
<p>Alerter.prototype.handleEvent = function(e) {</p>
<p> &nbsp;alert(this.i);</p>
<p>};</p>
<p>function hookupevents() {</p>
<p> &nbsp;for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp; &nbsp;document.getElementById(&quot;myButton&quot; + i)</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.addEventListener(&quot;click&quot;, new Alerter(i));</p>
<p> &nbsp;}</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129713">
				<div id="div-comment-1129713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129713">
			June 6, 2014 at 9:46 am</a>		</div>

		<p>John: &nbsp;&quot;Is C++ the only language where you get to choose if you want to capture each variable by reference or value?&quot; &nbsp;In VB.Net, functions and subroutines have a ByRef and ByVal keyword for each variable on the parameter definition. &nbsp;Likely in C# too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129723">
				<div id="div-comment-1129723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129723">
			June 6, 2014 at 10:06 am</a>		</div>

		<p>DWalker: Variables captured by a closure are not formal parameters to the function. C# does not allow you to specify that a captured variable is copied at the time of closure creation, and I suspect VB does not either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129773">
				<div id="div-comment-1129773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129773">
			June 6, 2014 at 12:57 pm</a>		</div>

		<p>@The MAZZter: None of the examples given have really anything to do with the &quot;intricacies&quot; of closures. Closures are a perfectly simple concept. It&#39;s just that JavaScript&#39;s idea of scoping is particularly stupid and don&#39;t even start talking about implicit globals. God be thanked the latest standard fixes some of the most egregious mistakes. </p>
<p>On a side note: Poor Brendan Eich. He&#39;s a clever guy and considering the circumstances he actually did a really good job (you come up with a language in a week and implement it). Still in the end most people will remember him for creating one of the worst languages ever specified.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129783">
				<div id="div-comment-1129783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129783">
			June 6, 2014 at 1:12 pm</a>		</div>

		<p>Is the .net language powershell it&#39;s possible to explict call GetNewClosure() whenever you want to close a scriptblock over variables.</p>
<p>Unfortunately the closure is assosiated with the scope of the module, not with the code, a design fail which makes closures useless.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129823">
				<div id="div-comment-1129823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129823">
			June 6, 2014 at 3:04 pm</a>		</div>

		<p>@voo, that, the 640k enough for everyone and the reality distortion field. &nbsp;What do they have in common?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1129903">
				<div id="div-comment-1129903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129903">
			June 7, 2014 at 3:25 am</a>		</div>

		<p>The breaking change in C# was evil. </p>
<p>You don&#39;t change language semantics like that. Now nothing is certain. The next version may change the meaning of int.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1129983">
				<div id="div-comment-1129983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1129983">
			June 8, 2014 at 7:24 am</a>		</div>

		<p>@Azarien: Wait you wrote honest-to-goodness code that *relied* on the changed behavior? Seriously?</p>
<p>Please post it, I have to see that.</p>
<p>@John Doe: I guess the first two are both generally taken out of context these days, but since the &quot;10 days to implement the first version&quot; is a quote from Brendan Eich himself and I haven&#39;t see any proof that he invented this to look better in retrospective, I&#39;m really not sure what your point is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130023">
				<div id="div-comment-1130023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1130023">
			June 8, 2014 at 3:12 pm</a>		</div>

		<p>@voo: no I didn&#39;t, at least in production. Once I wrote a simple program with lambda in a loop to see what would happen. Something happened, and I remembered this (original) behavior. Later I found that they broke what I&#39;ve learned in a new release ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130053">
				<div id="div-comment-1130053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">n</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1130053">
			June 8, 2014 at 9:45 pm</a>		</div>

		<p>function hookupevents() {</p>
<p> for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp;document.getElementById(&quot;button&quot; + i)</p>
<p> &nbsp; .addEventListener(&quot;click&quot;,alert.bind(window,i));</p>
<p> }</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130063">
				<div id="div-comment-1130063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eamon Nerbonne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1130063">
			June 9, 2014 at 12:33 am</a>		</div>

		<p>There&#39;s a syntax error in many of or immediately evaluated functions expressions; you&#39;re missing the &quot;};&quot; closing token for the returned handler.</p>
<p>e.g.</p>
<p> &nbsp; function hookupevents() {</p>
<p> &nbsp; &nbsp; for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp; &nbsp; &nbsp; document.getElementById(&quot;myButton&quot; + i)</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; .addEventListener(&quot;click&quot;,</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (function(index) {</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return function() { alert(index); })(i));</p>
<p> &nbsp; &nbsp; }</p>
<p> &nbsp; }</p>
<p>should be</p>
<p> &nbsp; function hookupevents() {</p>
<p> &nbsp; &nbsp; for (var i = 0; i &lt; 4; i++) {</p>
<p> &nbsp; &nbsp; &nbsp; document.getElementById(&quot;myButton&quot; + i)</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; .addEventListener(&quot;click&quot;,</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (function(index) {</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return function() { alert(index); };})(i));</p>
<p> &nbsp; &nbsp; }</p>
<p> &nbsp; }</p>
<p>or something similar.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130113">
				<div id="div-comment-1130113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1130113">
			June 9, 2014 at 9:32 am</a>		</div>

		<p>Eric, you said that for this bit of code:</p>
<p>function strange() {</p>
<p>k = 42;</p>
<p>for (i = 0; i &lt; 4; i++) {</p>
<p>&nbsp;var k;</p>
<p>&nbsp;alert(k);</p>
<p>}</p>
<p>}</p>
<p>You&#39;re using the variable k before declaring it, but really what you&#39;re doing is just declaring k in global scope (not function scope because you omitted the var keyword), then changing its scope to the function by putting var k in the loop.</p>
<p>You can test for whether or not k is in global scope with this snippet:</p>
<p>&nbsp; console.log(Object.keys(window));</p>
<p>With this, you can see that when you write &quot;k = 42&quot; followed by &quot;var k&quot;, k is not in global scope. But if you wrote just &quot;k = 42&quot;, k is suddenly in global scope.</p>
<div class="post">[<em>You yourself confirmed that in the function &quot;strange&quot;, there is no k in global scope, so I&#39;m not sure what you&#39;re trying to say. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130173">
				<div id="div-comment-1130173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1130173">
			June 9, 2014 at 10:58 am</a>		</div>

		<p>@voo, he prototyped it in 10 days with lots of experience. &nbsp;Let&#39;s disseminate this:</p>
<p>&#8211; Prototype. &nbsp;It was slow, it didn&#39;t do closures (inner functions were only valid for the duration of the outer function), it didn&#39;t have Unicode support, time and date support sucked, etc. &nbsp;And as far as we can all tell, we (the general public) have never seend this first prototype, so I&#39;m basically talking about JavaScript 1.0, which was definitely not done in 10 days; just think about GC.</p>
<p>&#8211; Experience. &nbsp;I remember Eich saying he used to implement languages for fun. &nbsp;And professionally, he&#39;d done a couple of times before, so parsing, byte-compiling, interpreting, etc. was not really a quest for him. &nbsp;I admit that 10 days is still quite a feat, but if you add it up, it&#39;s two full weeks, and it was a prototype. &nbsp;He admittedly borrowed lots of ideas from other languages: Java (most of the syntax, he says he was forced to do it), Self (only the idea of object prototyping) and Scheme (only the idea of first-class functions).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1130213">
				<div id="div-comment-1130213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">hagenp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1130213">
			June 10, 2014 at 2:46 am</a>		</div>

		<p>Can you use an expression to force the current value of &#39;i&#39; being used?</p>
<p>Like this:</p>
<p>function hookupevents() {</p>
<p>for (var i = 0; i &lt; 4; i++) {</p>
<p>&nbsp;document.getElementById(&quot;myButton&quot; + i)</p>
<p>&nbsp; .addEventListener(&quot;click&quot;,</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; function() { alert(i + 0); });</p>
<p>}</p>
<p>}</p>
<div class="post">[<em>Try it and see. (The expression will be evaluated when the function is invoked, i.e., when the click occurs. It will then calculate <code>i + 0</code> based on the value of <code>i</code> at the time, which will probably be 4.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1130333">
				<div id="div-comment-1130333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">imma</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140605-00/?p=803#comment-1130333">
			June 10, 2014 at 9:32 am</a>		</div>

		<p>@hagenp No, not like that. You&#39;ve just used the value of i at time of the listener function execution &#8230; plus 0</p>
<p>Do this instead, like suggested further up :</p>
<p>function hookupevents() {</p>
<p> &nbsp;for (var i = 0; i &lt; 4; i++)</p>
<p> &nbsp; &nbsp;function(index){</p>
<p> &nbsp; &nbsp; &nbsp;document.getElementById(&quot;myButton&quot; + index).addEventListener(</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;&quot;click&quot;,</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;function() {</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;alert(index);</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;});</p>
<p> &nbsp; &nbsp;}(i);</p>
<p> &nbsp;}</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

