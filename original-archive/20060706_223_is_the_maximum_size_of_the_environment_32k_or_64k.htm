<html>
<head>
<title>Is the maximum size of the environment 32K or 64K?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Is the maximum size of the environment 32K or 64K?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 6, 2006 / year-entry #224</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>39</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">There appears to be some confusion over whether the maximum size of the environment is 32K or 64K. Which is it? Both. The limit is 32,767 Unicode characters, which equals 65,534 bytes. Call it 32K or 64K as you wish, but make sure you include the units in your statement if it isn't clear from...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>There appears to be some confusion over whether the maximum size of the environment is 32K or 64K. Which is it?</p>
<p> Both. </p>
<p> The limit is 32,767 Unicode characters, which equals 65,534 bytes. Call it 32K or 64K as you wish, but make sure you include the units in your statement if it isn't clear from context. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (39)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-397573">
				<div id="div-comment-397573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://drv.nu/' rel='external nofollow' class='url'>Daniel</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397573">
			July 6, 2006 at 10:08 am</a>		</div>

		<p>In any case, much better than 256 bytes. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-397583">
				<div id="div-comment-397583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397583">
			July 6, 2006 at 10:41 am</a>		</div>

		<p>When is &quot;K&quot; /ever/ used to mean &quot;Kilocharacters&quot;?</p>
<p>&quot;K&quot; without an additional unit specifier (e.g. &quot;b&quot;, &quot;B&quot;, &quot;g&quot;, etc&#8230;) in a computing context /always/ means Kilobytes[0]. &quot;K&quot; is a unit. Calling it &quot;64K&quot; does include a unit and is completely unambiguous.</p>
<p>If you want to count characters, yes, use an appropriate unit. &quot;K&quot; is /not/ an appropriate unit. &quot;Kilocharacters&quot; would be. &quot;Kc&quot; /might/ be, but I don&#8217;t know if anyone else would understand you.</p>
<p>If the environment is 64 kilobytes, it is 64K. It is not 32K, and never will be.</p>
<p>([0] Unless it means Kibibytes if you insist on the computing fraternity not being able to reappropriate &quot;Kilo&quot; to mean &quot;1024&quot;, but that&#8217;s a whole nother off-topic discussion&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-397593">
				<div id="div-comment-397593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397593">
			July 6, 2006 at 10:45 am</a>		</div>

		<p>Is such a limit a problem for any program out there? I&#8217;m curious what people do with the environment these days. I had an entire runtime library designed around the fact that you can (ab)use the environment as a global variable, and stored the root bookkeeping structure in a TLS slot whose index I recalled using a certain environment variable. It is pretty wacky, but I wanted to see if I could get away with not needing users to link to something.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-397663">
				<div id="div-comment-397663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pcooper</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397663">
			July 6, 2006 at 12:30 pm</a>		</div>

		<p>And to be completely pedantic, by &quot;unicode characters&quot;, you probably mean UTF-16 code units.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-397683">
				<div id="div-comment-397683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://meat.net/' rel='external nofollow' class='url'>dbt</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397683">
			July 6, 2006 at 12:54 pm</a>		</div>

		<p>there is no such thing as UCS-2. &nbsp;There is only UTF-16.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-397693">
				<div id="div-comment-397693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397693">
			July 6, 2006 at 1:02 pm</a>		</div>

		<p>No such thing as UCS-2?</p>
<p>Wikipedia begs to differ: <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/UCS-2" rel="nofollow">http://en.wikipedia.org/wiki/UCS-2</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-397833">
				<div id="div-comment-397833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397833">
			July 6, 2006 at 4:37 pm</a>		</div>

		<p>The environment is a UNICODE_STRING structure which has a 2-byte header for the count of bytes in the string. Since the 2-byte value would overflow at 65,536 and 65,535 isn&#8217;t a valid number of bytes for a UCS-2 string, the maximum usable length is 65,534 bytes for the string. Because of the count, no null termination is required.</p>
<p>Note that the structure holds the length of the string and the length of the allocated buffer. You could argue that they should have made the structure use 4-byte values for the length, but that would waste 4 bytes for every string in the system.</p>
<p>I suppose they could have made the counts hold the number of characters instead of bytes, but that would only double the possible string length, while making string handling code more confusing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com000300008195987d odd alt thread-odd thread-alt depth-1" id="comment-397673">
				<div id="div-comment-397673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Spire' rel='external nofollow' class='url'>Spire</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397673">
			July 6, 2006 at 12:31 pm</a>		</div>

		<p>If you want to be *really* unambiguous: The limit is 32,767 UCS-2 characters, which equals 65,534 bytes.</p>
<p>Microsoft documentation almost always means &quot;UCS-2&quot; when it uses the term &quot;Unicode&quot;, but in reality UCS-2 is just one of many different Unicode character encodings. Not everyone is aware of this convention, so it is safer to use the correct term, especially when there is a chance that it might be taken out of context.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-397703">
				<div id="div-comment-397703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397703">
			July 6, 2006 at 1:09 pm</a>		</div>

		<p>J. Edward: Don&#8217;t you have that backwards? I&#8217;d have thought that the limit *is* 65535 bytes, into which you can happen to put 32767 UCS-2 characters. (Or between 16383 and 32767 UTF-16 characters, depending on how many of them are outside the BMP)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com000300008195987d odd alt thread-odd thread-alt depth-1" id="comment-397723">
				<div id="div-comment-397723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Spire' rel='external nofollow' class='url'>Spire</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397723">
			July 6, 2006 at 1:47 pm</a>		</div>

		<p>dbt: Officially, UCS-2 may be obsolete/deprecated, but that doesn&#8217;t mean that it is no longer in use anywhere.</p>
<p>Adam: My statement was about equivalence, not causality. However, I&#8217;m guessing that you&#8217;re correct that the real limit is technically 65,535 bytes &#8212; not 65,534 bytes as Raymond seemed to imply.</p>
<p>(And of course we haven&#8217;t even gotten into the amount of *usable* space, taking null termination into account.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-397883">
				<div id="div-comment-397883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397883">
			July 6, 2006 at 9:21 pm</a>		</div>

		<blockquote><p>
  &quot;K&quot; without an additional unit specifier (e.g. &quot;b&quot;, &quot;B&quot;, &quot;g&quot;, etc&#8230;) in a computing context /always/ means Kilobytes[0]. &quot;K&quot; is a unit. Calling it &quot;64K&quot; does include a unit and is completely unambiguous.</p>
<p>In my experience, that&#8217;s imposing a convention that simply doesn&#8217;t exist. &nbsp;I see the &quot;K&quot; suffix used to mean 1024 (and occasionally 1000, but that&#8217;s another topic) quite often, with the unit being inferred from the context. &nbsp;A unit of bytes (or octets) is definitely not assumed without the context.</p>
<p>&quot;KB&quot;, on the other hand, does mean kilobytes.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-397923">
				<div id="div-comment-397923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397923">
			July 7, 2006 at 3:56 am</a>		</div>

		<p>Did you not see the &quot;in a computing context&quot; part, which you quoted?</p>
<p>Or do you mean that &quot;K&quot; is used &quot;quite often&quot;, in a computing context, without other units being mentioned, and <em>not</em> mean KB?</p>
<p>Do you have any examples of such use?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-397933">
				<div id="div-comment-397933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Centaur</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397933">
			July 7, 2006 at 4:26 am</a>		</div>

		<p>K never means 1000. k does.<br />
<br />I was surprised to find out that kilobits and megabits are decimal, despite the computing context…</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-397953">
				<div id="div-comment-397953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.soulsphere.org/' rel='external nofollow' class='url'>fraggle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397953">
			July 7, 2006 at 4:43 am</a>		</div>

		<p>Here&#8217;s a more important question: why on earth is there a limit on the environment size?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-397963">
				<div id="div-comment-397963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397963">
			July 7, 2006 at 6:17 am</a>		</div>

		<blockquote><p>
  Or do you mean that &quot;K&quot; is used &quot;quite often&quot;, in a computing context, without other units being mentioned, and <em>not</em> mean KB?</p>
<p>Yes; a common one is when talking about line speeds (cable and DSL especially), where it usually refers to units of bits. &nbsp;And 1000 instead of 1024, unfortunately.</p>
<p>For some descriptions of hashtables or cache architectures, I&#8217;ve see terms like &quot;4K entry&quot; to refer to the number of slots (where each slot is N bytes on its own), but I don&#8217;t have a reference for that offhand. &nbsp;Then there&#8217;s the whole Y2K thing&#8230;</p>
<p>As Centaur also notes, there are &quot;correct&quot; forms, but such conventions seem to go out the window in common use. &nbsp;I tend to use the context to figure out what is meant first, and only analyze the suffix if the context isn&#8217;t clear.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-397983">
				<div id="div-comment-397983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-397983">
			July 7, 2006 at 7:03 am</a>		</div>

		<p>Don&#8217;t forget the &quot;hard drive manufacturer&quot;&#8217;s definitions of units. </p>
<p>I have often seen drives advertised as xGB and a note saying &quot;1GB=1,000,000,000 bytes&quot;. Same goes for USB pens and other storage devices.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398003">
				<div id="div-comment-398003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.int6.net' rel='external nofollow' class='url'>Phoenix</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398003">
			July 7, 2006 at 7:40 am</a>		</div>

		<p>However; according to the Intel, 4kb is 0x1000bytes (4096)<br />
<br />There is a big lack standarts&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398023">
				<div id="div-comment-398023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.morganalley.com' rel='external nofollow' class='url'>Dewi Morgan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398023">
			July 7, 2006 at 9:17 am</a>		</div>

		<p>&quot;There is a big lack standarts&#8230;&quot;</p>
<p>Not so: there are standards, but since the movers and shakers (MS, et al) don&#8217;t uphold them, nobody else does. Many don&#8217;t even know of them.</p>
<p>Kb to denote 10^3 is a standard.</p>
<p>Kb to denote 2^10 is forbidden by the SI, the IEC, and the IEEE.</p>
<p>Instead, the recommended form for binary values is the prefixes kibi-, mebi-, gibi-, tebi-, pebi-, exbi-, written Ki, Mi, Gi, Ti, Pi, Ei. The postfix units are bit (b), byte (B) and octet (o).</p>
<p>Thus, the environment storage is 64Kib, or 64Kio, since I believe the two are the same even on Win64.</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Kibibyte" rel="nofollow">http://en.wikipedia.org/wiki/Kibibyte</a></p>
<p>Raymond is correct that the storage would often be listed as 32K with the units left off, since there&#8217;s no official notation for &quot;arbitrary width character&quot;.</p>
<p>So if someone asks &quot;What string length can I fit in the environment?&quot; (which is a far more important and practical question than &quot;how many bytes&quot;, they will most likely be told 32K.</p>
<p>He was right to point out that it&#8217;s important to get the units right but as others pointed out, it&#8217;s almost as important to get the base indicator right: the environment is &quot;32Ki characters&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398053">
				<div id="div-comment-398053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Jones</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398053">
			July 7, 2006 at 11:01 am</a>		</div>

		<p>This brings up another question&#8230; XML files typicaly use UTF-8 encoding which is a really encoding: for &quot;regular&quot; characters its the same as olde text files, but can expand to hold the most complex Unicode characters. &nbsp;UTF-16 which we see all over the Windows API is a pain to use and can not hold those high numbered Unicode characters. &nbsp;It was a bad choice.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398223">
				<div id="div-comment-398223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398223">
			July 7, 2006 at 5:18 pm</a>		</div>

		<p>Yes, both UTF-8 and UTF-16 are variable-width encodings and can handle the entire range of Unicode characters. &nbsp;UTF-16 is the right choice for most general-purpose APIs; it strikes a balance between storage and processing overhead.</p>
<p>UTF-8&#8217;s big advantage is compatibility with ASCII, since Unicode keeps code points 0 to 127 identical to the ASCII standard. &nbsp;UTF-8 uses the 8th bit to indicate encoding for code points 128 and above, but uses up to 4 code units to do it. &nbsp;This wide range adds to some processing overhead. &nbsp;There&#8217;s also the need to deal with invalid but logically possible code unit sequences; a simple implementation could easily take &quot;C0 80&quot; to mean &quot;00&quot;. &nbsp;The problem of having multiple representations for the same character can lead to security flaws. &nbsp;There are several well-known exploits of this, including one for an old version of IIS. &nbsp;UTF-8 is also at a memory disadvantage for much of the common East Asian character set, as it requires 3 octets to represent what UTF-16 can do it 2.</p>
<p>UTF-16 trades the minimum 2 octets per code unit memory cost, and lack of ASCII compatibility, for easier processing. &nbsp;Using surrogate code points, UTF-16 only ever expands to 2 code units, and the surrogate encoding does not have the same multiple-representation problem UTF-8 does.</p>
<p>Most general purpose Unicode systems made the same choice, notably Java and Mac OS X. &nbsp;The Web and related technology in general has gone with ASCII compatibility, a decision which makes sense for its specific domain.</p>
<p>How various parts of Windows actually handles surrogate code pairs is another story entirely. &nbsp;One that&#8217;s been told before:<br />
<br /><a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2004/05/31/144893.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2004/05/31/144893.aspx</a><br />
<br /><a rel="nofollow" target="_new" href="http://blogs.msdn.com/michkap/archive/2005/05/11/416552.aspx" rel="nofollow">http://blogs.msdn.com/michkap/archive/2005/05/11/416552.aspx</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398063">
				<div id="div-comment-398063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398063">
			July 7, 2006 at 11:07 am</a>		</div>

		<p>I am pretty sure that UTF-16 *can* hold characters whose code point is greater than 65535, though. &nbsp;To do it, you use two (or more?) UTF-16 values, one of which is an escape.</p>
<p>(Or it&#8217;s done using &quot;combining characters&quot;, which may amount to the same thing. &nbsp;Or possibly something else.)</p>
<p>In short: UTF-16 does not mean that each character is always 16 bits&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398243">
				<div id="div-comment-398243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Jones</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398243">
			July 7, 2006 at 6:39 pm</a>		</div>

		<p>Since UTF-16 can also expand for high-numbered characters we can&#8217;t accurately say the environment which is limited to 64 kilobytes can hold 32 kilo-UTF-16-chars since a UTF-16 character can be more than 2 bytes. &nbsp;We can only says it holds AT MOST 32 kilo-UTF-16-chars &#8230; but maybe less.</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398253">
				<div id="div-comment-398253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398253">
			July 7, 2006 at 7:03 pm</a>		</div>

		<p>Don&#8217;t forget that when Windows NT was being designed in the early 1990s, there was nothing but UCS-2. UTF-8 wasn&#8217;t presented to the public until the same year that NT was first released, and not a formal standard until after NT 4.0 was released.</p>
<p>I don&#8217;t think there were any characters that required more than two bytes in UTF-16 until after Windows 2000 was released. The characters that require more than 2 bytes are just special purpose things like old languages and math/music symbols. Considering that, I think UTF-16 was a perfectly logical choice for encoding.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398323">
				<div id="div-comment-398323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398323">
			July 8, 2006 at 4:43 am</a>		</div>

		<p>Random Reader &#8211; In practice though UTF-16 has been a disaster everywhere it has been &quot;implemented&quot; (scare quotes to represent the reality that in practice so much UTF-16 code is really just re-branded UCS-2 code with all the consequences that entails).</p>
<p>Look at the state of Unicode on a typical user&#8217;s Windows desktop after 15 years of &quot;support&quot;. Probably only half of their apps are Unicode capable at all, and few if any of those work properly outside the BMP. Why? Because UTF-16 is a lot of extra work for the programmers, and even Microsoft&#8217;s own tech writers don&#8217;t seem to understand UTF-16 Unicode scenarios well enough to document them properly as Raymond helpfully illustrates here.</p>
<p>The security differential is null, you must get your implementation details absolutely correct or there are security problems in either encoding. Microsoft screwed up both their UTF-8 and UTF-16 handling from a security point of view, and we&#8217;re supposed to be happy that in 2003 or so this is finally mostly fixed.</p>
<p>IMNSHO Most platforms that married UTF-16 did it because they were already engaged to UCS-2. UTF-16 has all the disadvantages of UCS-2, which were already considerable, plus the burden of being a variable length encoding. The worst of both worlds. It&#8217;s like getting to the altar and the bride whispers, &quot;Oh, I forgot, I&#8217;m actually sleeping with someone else. I hope that won&#8217;t be a problem for our marriage&quot;.</p>
<p>ASCII compatibility wasn&#8217;t enough reason to use UTF-8 on the Internet, CESU or other encodings would have met that requirement. UTF-8 won on the Internet because it has the least disadvantages of any encoding. It&#8217;s smaller for most of today&#8217;s and tomorrow&#8217;s data (especially after you factor in the real size with &#8216;deflate&#8217; as the only compression in practical use); it preserves the code point ordering; it&#8217;s endian-neutral and it recovers correctly from dropped bytes, still a common data corruption today.</p>
<p>And on the platforms that married UTF-8 non-Unicode applications are now an endangered species. Because it was so easy to dip a toe into the water, most programmers were swimming before they even knew it. The BMP is nothing special in UTF-8, so your Unicode support doesn&#8217;t stop at its edge either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398353">
				<div id="div-comment-398353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398353">
			July 8, 2006 at 7:32 pm</a>		</div>

		<p>There&#8217;s nothing inherent in UTF-16 that makes the platforms that use them a &quot;disaster&quot; in practice &#8212; Java certainly isn&#8217;t, nor is ECMAscript or .NET.</p>
<p>I didn&#8217;t mean to say that ASCII compatibility was the only consideration for Internet use, just that it was a major factor in deciding to use an encoding with 8bit code units. &nbsp;You do bring up a general point I neglected earlier: the Internet is concerned with information exchange/transfer, not processing. &nbsp;The two concepts have different goals.</p>
<p>(As a side note, I&#8217;ve seen that comment about UTF-8 recovering from arbitrary lost bytes before. &nbsp;I must be hanging out in entirely the wrong parts of the &#8216;net, because I&#8217;ve never encountered a situation where it was the responsibilty of a character encoding to handle such things. &nbsp;UTF-8 doesn&#8217;t even have error detection! &nbsp;These are the responsibilities of transport protocols, not language-oriented standards.)</p>
<p>The platforms I&#8217;m referring to, OSes and VMs and what have you, are concerned with processing that data. &nbsp;UTF-16, even with its variable width, is simply easier to process than UTF-8. &nbsp;A general-purpose platform like an OS also can&#8217;t make the assumption that the East Asian languages simply won&#8217;t be &quot;common&quot; &#8212; it needs to handle all cases and handle them well. &nbsp;UTF-16 is a nice balance for doing that. &nbsp;The security point I brought up is specific to the UTF-8 encoding; I&#8217;m not aware of any others that are specific to either UTF-8 or UTF-16. &nbsp;There are plenty for Unicode in general, depending on the use context. &nbsp;The whole IDN thing is a recent example.</p>
<p>You seem to be confusing support for an encoding with actual user-ready support for Unicode. &nbsp;The two are very far apart. &nbsp;As a trivial example, look at how many applications support &quot;case-insensitive&quot; operations on UTF-8 backing stores &#8212; but only for the ASCII characters. &nbsp;This problem affects everything from PHP to text editors. &nbsp;Many applications &quot;handle&quot; UTF-8 quite by accident, as it simply doesn&#8217;t get in the way of the ASCII bytes they recognize. &nbsp;That&#8217;s a great property for pass-through transfer, but meaningless for doing actual work on data.</p>
<p>As far as Windows goes, there are some contributing factors to that. &nbsp;(15 years? &nbsp;What are you counting from? &nbsp;The first seriously public implementation was NT4, 1996.) &nbsp;One is the API situation: Windows 9x simply didn&#8217;t support most of them, and the MSLU was inconvenient when it appeared. &nbsp;For the general consumer, a UTF-16 platfom wasn&#8217;t available until XP, 2001-2002. &nbsp;Without that general availability, not many would want to target it. &nbsp;And in order to target the UTF-16 APIs at all, you have to want to do Unicode &#8212; it&#8217;s not accidental like the ASCII-&gt;UTF-8 transition is. &nbsp;Wanting to do Unicode at all is also a relatively recent thing.</p>
<p>Which brings me to the real point: Unicode is hard. &nbsp;Even the major web search engines can&#8217;t do it right. &nbsp;(Search Micheal Kaplan&#8217;s blog for some fun comparisons.) &nbsp;It takes much more work than just supporting a particular encoding.</p>
<p>Encodings are easy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398383">
				<div id="div-comment-398383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398383">
			July 9, 2006 at 8:23 pm</a>		</div>

		<p>Friday, July 07, 2006 4:26 AM by Centaur<br />
<br />&gt; K never means 1000. k does.</p>
<p>When I needed a 47K resistor, K didn&#8217;t mean 1024.</p>
<p>Friday, July 07, 2006 7:03 AM by Stu<br />
<br />&gt; Don&#8217;t forget the &quot;hard drive manufacturer&quot;&#8217;s<br />
<br />&gt; definitions of units.</p>
<p>Here&#8217;s someone else who won&#8217;t forget:<br />
<br /><a rel="nofollow" target="_new" href="http://www.wdc.com/settlement/" rel="nofollow">http://www.wdc.com/settlement/</a></p>
<p>Friday, July 07, 2006 11:01 AM by Mike Jones<br />
<br />&gt; XML files typicaly use UTF-8 encoding which<br />
<br />&gt; is a really encoding: for &quot;regular&quot;<br />
<br />&gt; characters its the same as olde text files,</p>
<p>No it is not. &nbsp;It is an encoding but it is not the same as old national encodings. &nbsp;(Except in a country which I think is the world&#8217;s third largest by population, and a few smaller countries or parts thereof.)</p>
<p>Friday, July 07, 2006 7:03 PM by Gabe<br />
<br />&gt; I don&#8217;t think there were any characters that<br />
<br />&gt; required more than two bytes in UTF-16 until<br />
<br />&gt; after Windows 2000 was released.</p>
<p>Close. &nbsp;The characters existed in the world&#8217;s largest country (by population). &nbsp;Obviously there&#8217;s no encoding for them in UCS-2 and I&#8217;m not sure when UTF-16 was invented in order to allow for them. &nbsp;Also I don&#8217;t know the national encodings of that country (nor provinces thereof) so don&#8217;t know if national encodings included those characters.</p>
<p>In Japan there was some debate over whether to add encodings to represent miswritings of characters, because miswritings had been performed by government officials in registering people&#8217;s names, and those people had to use the government-assigned characters rather than the correct characters. &nbsp;(Sorry I don&#8217;t know the outcome. &nbsp;I don&#8217;t even know if the issue has been decided yet.)</p>
<p>Saturday, July 08, 2006 4:43 AM by Nick Lamb<br />
<br />&gt; and even Microsoft&#8217;s own tech writers don&#8217;t<br />
<br />&gt; seem to understand UTF-16 Unicode scenarios</p>
<p>Nor even UCS-2, depending on which MSDN pages you read. &nbsp;Nor ANSI code pages, depending on which MSDN pages you read.</p>
<p>&gt; UTF-8 won on the Internet because it has the<br />
<br />&gt; least disadvantages of any encoding. It&#8217;s<br />
<br />&gt; smaller for most of today&#8217;s and tomorrow&#8217;s<br />
<br />&gt; data</p>
<p>That depends on how you define &quot;most&quot;.</p>
<p>&gt; it preserves the code point ordering;</p>
<p>Does not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-398403">
				<div id="div-comment-398403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398403">
			July 9, 2006 at 11:36 pm</a>		</div>

		<blockquote><p>
  UTF-8 doesn&#8217;t even have error detection!</p>
<p>It &quot;sort of&quot; does, in that you can tell just by looking at a single byte whether you&#8217;re in the middle of a multi-byte sequence, or at the start of a new one. I think that&#8217;s what he meant.</p>
<p>The thing is, UTF-16 IS better for data processing than UTF-8. Technically, since they both represent the same data, anything you can implement in UTF-16 you can also implement directly on the UTF-8 bytes. But generally when processing Unicode data, you would transform the UTF-8 into UTF-16, do the processing, then transform back (if you want everything in UTF-8).</p>
<p>For example, linguistic sorting, normalization, and so on are all MUCH simpler when working in UTF-16. Sure, it&#8217;s POSSIBLE to do it directly in UTF-8, but nobody would WANT to.</p>
<p>Also, the way surrogates work, you can mostly just process them like combining characters. For example, a + an acute accent could be &lt;U+00C1&gt; or it could be &lt;U+0041 U+0301&gt;.</p>
<p>This means that in UTF-8, a + acute accent could be: 0xC3 0x81 (which is the precomposed form) or it could be: 0x41 0xCC 0x81 (which is the decomposed form) Notice that this is NOT the same as a simple &quot;variable number of bytes per character&quot; that UTF-8 uses anyway. This is &quot;multiple code-points per logical character&quot; which something else.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398443">
				<div id="div-comment-398443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398443">
			July 10, 2006 at 6:03 am</a>		</div>

		<p>I pointed out that UTF-8 preserves the binary code point ordering of Unicode, and Norman replied concisely but inaccurately &quot;Does not&quot;. Anyone who wonders about this can trivially visit Unicode.org and read the UTF-8 standard for themselves. I suppose if Norman still thinks he is right he could try to provide an actual example next time&#8230;</p>
<p>Dean, if you were going to transform Unicode text into one of the UTF encodings as a convenience for writing text processing algorithms it would be UTF-32. Of course the additional memory bandwidth means a sober analysis is needed here. Are you really going to do this piece of programming over and over? If not, why not get it right in your native encoding just once and save the overhead? Sure enough, on this UTF-8 system the linguistic sorting, normalisation, case transforms and similar operations are done on UTF-8 strings.</p>
<p>The idea that you can muddle the surrogates and combining forms doesn&#8217;t work, it just creates more bugs. It is interesting how often Win32 developers, exhausted by problems with UTF-16, wish them all away by pretending that surrogates aren&#8217;t important enough to handle correctly (even Michael Kaplan wondered if he could treat them as ligatures). This means more places where developers get confused and give up, returning to the sanctuary of their &quot;ANSI&quot; codepages.</p>
<p>Random, it&#8217;s hard to argue that Java or .NET are much better here, programmers just have no choice &#8211; they never had any support for other encodings. You could as well say that Java&#8217;s IPv6 implementation is great &#8211; programmers use it, bugs and all because there&#8217;s no alternative. The &quot;major web search engines&quot; all have problems just past the edge of the BMP. Obviously this doesn&#8217;t prove that the problem is UTF-16, but it&#8217;s a funny coincidence isn&#8217;t it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398453">
				<div id="div-comment-398453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://codeka.com/blogs' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398453">
			July 10, 2006 at 9:56 am</a>		</div>

		<p>Nick: UTF-32 doesn&#8217;t save you from combining characters, it&#8217;s the same thing in UTF-8, UTF-16 and UTF-32 (or any other encoding of Unicode). I&#8217;m not saying it&#8217;s exactly the same thing, just that it&#8217;s a similar problem, and since it&#8217;s one that ALL conformant Unicode implementations (be they UTF-8 or UTF-16) need to solve, most of the work for surrogates in UTF-16 is already in place.</p>
<p>Anyway, this is getting off-topic now&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398703">
				<div id="div-comment-398703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398703">
			July 10, 2006 at 11:35 pm</a>		</div>

		<p>Sunday, July 09, 2006 11:36 PM by Dean Harding<br />
<br />&gt;&gt; UTF-8 doesn&#8217;t even have error detection! </p>
<p>&gt; It &quot;sort of&quot; does, in that you can tell just by looking at a single byte whether you&#8217;re in the middle of a multi-byte sequence, or at the start of a new one. I think that&#8217;s what he meant.</p>
<p>Yeah, I figured he was referring to the fact that the UTF-8 decoder has enough information to sense and ignore broken multi-unit sequences, but that&#8217;s just a side effect of the encoding form putting size considerations first. &nbsp;It can&#8217;t, for example, detect the loss of a single code point in the ASCII range, or a whole multi-unit sequence.</p>
<p>A real error detection mechanism could do that. &nbsp;The classic solution is checksums, which most data transport systems already have in abundance.</p>
<p>Monday, July 10, 2006 6:03 AM by Nick Lamb<br />
<br />&gt; It is interesting how often Win32 developers, exhausted by problems with UTF-16 &#8230;</p>
<p>You keep referring to major problems with UTF-16 (that apparently don&#8217;t exist in UTF-8), but you haven&#8217;t mentioned anything specific. &nbsp;What do you mean?</p>
<p>&gt; Random, it&#8217;s hard to argue that Java or .NET are much better here, programmers just have no choice &#8211; they never had any support for other encodings.</p>
<p>I&#8217;m not following this thought. &nbsp;To summarize our conversation so far, you said that UTF-16 has been a disaster everywhere, I replied saying there&#8217;s nothing inherently disastrous about it, and now you&#8217;re saying&#8230;? &nbsp;It&#8217;s impossible to determine whether .NET and Java are disasters because they only use UTF-16? &nbsp;Huh?</p>
<p>As far as support goes, they both can convert to and from UTF-8 just fine. &nbsp;They merely use UTF-16 natively, the same way a UTF-8 processing tool uses UTF-8 natively.</p>
<p>&gt; The &quot;major web search engines&quot; all have problems just past the edge of the BMP.</p>
<p>Actually I was referring to things like this:<br />
<br /><a rel="nofollow" target="_new" href="http://blogs.msdn.com/michkap/archive/2005/11/15/492301.aspx" rel="nofollow">http://blogs.msdn.com/michkap/archive/2005/11/15/492301.aspx</a><br />
<br />It&#8217;s completely unrelated to BMP or the encoding used.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398713">
				<div id="div-comment-398713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398713">
			July 11, 2006 at 12:00 am</a>		</div>

		<p>Monday, July 10, 2006 6:03 AM by Nick Lamb<br />
<br />&gt; I pointed out that UTF-8 preserves the binary<br />
<br />&gt; code point ordering of Unicode, and Norman<br />
<br />&gt; replied concisely but inaccurately &quot;Does not&quot;</p>
<p>Maybe I need to quote more of your posting that I replied to.<br />
<br />Saturday, July 08, 2006 4:43 AM by Nick Lamb<br />
<br />&gt; ASCII compatibility wasn&#8217;t enough reason to<br />
<br />&gt; use UTF-8 on the Internet, CESU or other<br />
<br />&gt; encodings would have met that requirement.</p>
<p>It looks like you&#8217;re talking about compatibility with code pages. &nbsp;For some reason I thought you were in the UK where you already need a code page bigger than the 128 code points that ASCII has, so I assumed you didn&#8217;t really mean just ASCII. &nbsp;If you did mean that one high priority requirement for internet communications should be codepoint compatibility with one country&#8217;s national standard, then I made a wrong assumption, sorry.</p>
<p>&gt; UTF-8 won on the Internet because it has the<br />
<br />&gt; least disadvantages of any encoding. It&#8217;s<br />
<br />&gt; smaller for most of today&#8217;s and tomorrow&#8217;s<br />
<br />&gt; data (especially after you factor in the real<br />
<br />&gt; size with &#8216;deflate&#8217; as the only compression<br />
<br />&gt; in practical use); it preserves the code<br />
<br />&gt; point ordering;</p>
<p>It looks like you were explaining how UTF-8 has fewer disadvantages than others, where one of the others is UTF-16 and one is the more general way that HTTP headers specify what encoding is used in the content.</p>
<p>In fact HTTP headers that specify the encoding allow preservation of 100% of the codepoint ordering of whatever national encoding was used. &nbsp;Furthermore, those HTTP headers work. &nbsp;Of course those HTTP don&#8217;t work when not used (for example when foreign sites leave the encoding to the viewer&#8217;s default but they forgot to encode their content in EUC or Shift-JIS) but they do work when they are used.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398733">
				<div id="div-comment-398733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Meg Nanimous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398733">
			July 11, 2006 at 3:01 am</a>		</div>

		<p>Megabyte = how many?<br />
<br /><a rel="nofollow" target="_new" href="http://www.thedailywtf.com/Images/200607/win2k_sig_figs.png" rel="nofollow">http://www.thedailywtf.com/Images/200607/win2k_sig_figs.png</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-398763">
				<div id="div-comment-398763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398763">
			July 11, 2006 at 4:40 am</a>		</div>

		<p>Dean, it&#8217;s the &quot;same thing&quot;, but not &quot;exactly the same thing&quot; ? Does that mean you don&#8217;t &quot;exactly&quot; disagree with me after all ?</p>
<p>Random, the robustness which you refer to as a &quot;side effect&quot; was a design criterion for the encoding. If you look at earlier variable length character encodings this feature is missing. UTF-16 had the same requirement at the code unit level, because without it seeking is painful, but because transports are /byte/-oriented it&#8217;s a less complete fix.</p>
<p>So, you asked, what&#8217;s wrong with Java? It took a good part of a decade for Java to implement UTF-8 correctly (and internally it still uses a CESU-8 like hack for serialisation, making development tools and interoperability one step trickier). There&#8217;s lots of Java code that assumes (as Sun wrote in their original documentation) that one Java character = one Unicode character, which means it will break, perhaps spectacularly outside the BMP. Now the &quot;character&quot; type in Java is more or less useless. It&#8217;s not a byte (which Java already has) and it&#8217;s not a string (the minimum unit which can hold a Unicode character) it&#8217;s just an arbitrary UTF-16 code unit. Bye bye abstraction.</p>
<p>Yes, there are several bugs in search engines. Some of those bugs are fundamental character encoding problems, which I&#8217;d argue (without seeing the code) are symptoms of UCS-2 support masquerading as UTF-16.</p>
<p>Norman, the phrase I used was &quot;code point ordering of Unicode&quot;. If that phrase didn&#8217;t mean anything to you, why write that you disagree? ISO 10646 provides a mapping from numbers to characters (and control codes, symbols, etc.) and each of the encodings converts those numbers into byte sequences. This mapping, which underpins all of Unicode, is ordered. UTF-8 encoding preserves the ordering, as explained in its standards documents. UTF-16 does not, because of the surrogate characters introduced mid-way through the code range.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-398773">
				<div id="div-comment-398773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-398773">
			July 11, 2006 at 4:43 am</a>		</div>

		<p>Ugh, now they have me doing it. &quot;surrogate characters&quot; don&#8217;t exist, it should read &quot;surrogate code points&quot; in the last line above.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-399403">
				<div id="div-comment-399403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-399403">
			July 11, 2006 at 8:30 pm</a>		</div>

		<p>Tuesday, July 11, 2006 4:40 AM by Nick Lamb<br />
<br />&gt; Norman, the phrase I used was &quot;code point<br />
<br />&gt; ordering of Unicode&quot;.</p>
<p>Mr. Lamb, your messages of July 8 and July 10 are visible on this page for you to see as well as me. &nbsp;On July 8 you did not say &quot;code point ordering of Unicode&quot;. &nbsp;On July 9 (in the timezone of blogs.msdn.com) I replied to what you wrote on July 8. &nbsp;During this part of the discussion, your July 10 retroactive rephrasing of your July 8 message had not yet taken effect. &nbsp;On July 11 I reminded you of what I originally replied to.</p>
<p>&gt; ISO 10646 provides a mapping from numbers to<br />
<br />&gt; characters</p>
<p>It does indeed. &nbsp;On July 8 it didn&#8217;t look like that&#8217;s what you were talking about. &nbsp;Meanwhile ISO 10646 causes some confusion because it preserves compatibility with SOME national codepoint orderings. &nbsp;In order to create an environment where everyone could see the issues involved and work to overcome the issues, it would have been better to have a (alternate reality here) ISO 10646 whose codepoint ordering was incompatible with every national code page.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-399423">
				<div id="div-comment-399423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-399423">
			July 11, 2006 at 9:12 pm</a>		</div>

		<blockquote><p>
  Dean, it&#8217;s the &quot;same thing&quot;, but not &quot;exactly the same thing&quot; ? Does<br />
  <br />&gt; that mean you don&#8217;t &quot;exactly&quot; disagree with me after all ?</p>
<p>My first post said didn&#8217;t say it was the &quot;same thing&quot;, it said was mostly the same: &quot;Also, the way surrogates work, you can MOSTLY just process them like combining characters.&quot; (added emphasis)</p>
<p>&gt; Norman, the phrase I used was &quot;code point ordering of Unicode&quot;</p>
<p>I don&#8217;t think it matters anyway. What&#8217;s the big deal in preserving the code-point ordering? There&#8217;s no reason to ever want to actually SORT by code-point &#8211; it&#8217;s almost never the linguistically-correct sort order. And if you don&#8217;t care about being linguistically-correct (e.g. it&#8217;s only used internally or something and not displayed to a user), having non-BMP characters sorted &quot;out-of-order&quot; is nothing to lose sleep over.</p>
<p>&gt; Now the &quot;character&quot; type in Java is more or less useless.<br />
  <br />&gt; It&#8217;s not a byte (which Java already has) and it&#8217;s not a string<br />
  <br />&gt; (the minimum unit which can hold a Unicode character) it&#8217;s just an arbitrary UTF-16 code unit.</p>
<p>That&#8217;s like saying the &quot;char&quot; type in C/C++ is more-or-less useless because it can&#8217;t represent a full Unicode character either.</p>
<p>&gt; Yes, there are several bugs in search engines. Some of<br />
  <br />&gt; those bugs are fundamental character encoding problems, which<br />
  <br />&gt; I&#8217;d argue (without seeing the code) are symptoms of<br />
  <br />&gt; UCS-2 support masquerading as UTF-16.</p>
<p>I don&#8217;t think you understand the concept of combining characters. Combining characters are totally independent of what encoding you&#8217;re using, be it UTF-8, UTF-16 or UTF-32. The character &#8216;&#225;&#8217; can be represent as either &lt;U+00C1&gt; or it could be represented as &lt;U+0041 U+0301&gt;. In UTF-8, that would be either 0xC3 0x81 or 0x41 0xCC 0x81. Those two byte sequences are what we call &quot;canonically equivalent&quot;. That means, if I enter 0xC3 0x81 into a search box, it should also find the byte sequence 0x41 0xCC 0x81. THAT is the problem that current search engines have, they DON&#8217;T find the other normalization forms. It has nothing to do with how the text is encoded.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-399343">
				<div id="div-comment-399343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-399343">
			July 11, 2006 at 6:02 pm</a>		</div>

		<p>Tuesday, July 11, 2006 4:40 AM by Nick Lamb </p>
<p>&gt; Random, the robustness which you refer to as a &quot;side effect&quot; was a design criterion for the encoding. If you look at earlier variable length character encodings this feature is missing. UTF-16 had the same requirement at the code unit level, because without it seeking is painful, but because transports are /byte/-oriented it&#8217;s a less complete fix.</p>
<p>* Compact variable-width encoding requires the number of code units in the sequence to be explicitly indicated within the sequence itself, lest one be stuck with escape-type schemes to avoid run-ons, or end markers to allow incremental processing.</p>
<p>* Enabling random access or reverse scanning requires differentiating the first code unit from all others in the sequence.</p>
<p>Those two requirements result in a decoder having enough information about sequences to detect broken ones, but that&#8217;s not a designed-in reliability mechanism. &nbsp;As you pointed out, UTF-16 has the same invalid sequence detection as a result of the same requirements, and both it and UTF-8 operate on the code unit level. &nbsp;Neither one cares about the underlying transport, be it bits, bytes, or something else. &nbsp;If a design goal of UTF-8 was detecting byte-oriented transport errors, it would detect missing _bytes_ (i.e. code units in the ASCII range, or whole sequences). &nbsp;It doesn&#8217;t.</p>
<p>&gt; Now the &quot;character&quot; type in Java is more or less useless. It&#8217;s not a byte (which Java already has) and it&#8217;s not a string (the minimum unit which can hold a Unicode character) it&#8217;s just an arbitrary UTF-16 code unit. Bye bye abstraction.</p>
<p>I think your argument revolves around a percieved notion that UTF-16 is being treated as a &quot;Unicode character&quot; abstraction, and therefore UTF-16 is worthless. &nbsp;Well, uhm, no, that&#8217;s why we&#8217;re talking about an encoding. &nbsp;UTF-8 platforms are no different.</p>
<p>When you work on a &quot;Unicode character&quot; abstraction, or a &quot;Unicode glyph&quot; abstraction, the encoding is an irrelevant implementation detail. &nbsp;You may very well be right that many platforms that attempted to use such abstractions pervasively have failed to maintain them, but that isn&#8217;t what we&#8217;ve been talking about.</p>
<p>&gt; Yes, there are several bugs in search engines. Some of those bugs are fundamental character encoding problems, which I&#8217;d argue (without seeing the code) are symptoms of UCS-2 support masquerading as UTF-16.</p>
<p>That would imply they got the Unicode details correct within UCS-2 &#8212; combining characters, full case folding, etc &#8212; and the problem is merely a case of not handling surrogates. &nbsp;Do you have examples of such a thing?</p>
<p>&gt; Ugh, now they have me doing it. &quot;surrogate characters&quot; don&#8217;t exist, it should read &quot;surrogate code points&quot; in the last line above.</p>
<p>One of the most irritating things about Unicode is the terminology. &nbsp;&quot;Character&quot; used to be so simple :(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-399483">
				<div id="div-comment-399483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-399483">
			July 12, 2006 at 5:29 am</a>		</div>

		<p>Random, I wrote that UTF-8 recovers correctly, ie the remainder of the text can be decoded, whereas a dropped byte in UTF-16 corrupts the remaining text.</p>
<p>It seems a bit strange to have an entire datatype devoted to an &quot;irrelevant implementation detail&quot; in a high level language like Java doesn&#8217;t it? To have tutorials and API families dedicated to such a type&#8230;</p>
<p>You&#8217;re right, as I already said, that there are lots of different kinds of Unicode bugs in search engines, but only one of them is relevant to the choice of encoding. Some of Notepad&#8217;s Unicode bugs aren&#8217;t caused by the use of UTF-16 ether&#8230;</p>
<p>And of course characters were always complicated, it&#8217;s just that before Unicode people were usually solving only a subset of the problem.</p>
<p>Norman, I see where your misunderstanding arose now. Of course UTF-8 must encode ISO 10646 as it actually is, and not how you might imagine it could be.</p>
<p>Dean, you used those two phrases next to one another in a single post. I&#8217;m sure you didn&#8217;t mean for me to make that contrast, but it&#8217;s there.</p>
<p>The C &#8216;char&#8217; datatype isn&#8217;t useless because it is conveniently byte sized. You can&#8217;t store Unicode characters in it, of course, only UTF-8 code units because those are also byte sized. A Unicode character can be stored as a C &#8216;char *&#8217; string.</p>
<p>I can&#8217;t see why you would think I&#8217;m ignorant about combining characters, nor why you seem to believe that normalisation is related to processing of surrogates in UTF-16. On the whole I think you&#8217;re very confused about Unicode, and I hope you find out a lot more before writing any code that processes Unicode data.</p>
<p>The lack of normalisation (which would be easy in the search front end, but trickier for the bulk robots) is just one of many problems in today&#8217;s popular search engines. Specifically it&#8217;s a problem that&#8217;s /not relevant/ to character encodings, unlike the trouble beyond the BMP.</p>
<p>I don&#8217;t think there&#8217;s much more to add, and we&#8217;ve deviated far off topic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-399883">
				<div id="div-comment-399883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060706-12/?p=30623#comment-399883">
			July 12, 2006 at 7:49 pm</a>		</div>

		<blockquote><p>
  Random, I wrote that UTF-8 recovers correctly, ie the remainder of the text can be decoded, whereas a dropped byte in UTF-16 corrupts the remaining text.</p>
<p>For &quot;it recovers correctly from dropped bytes, still a common data corruption today&quot; the implication is that it has features oriented toward use with a particular kind of unreliable byte-oriented transport. &nbsp;I was pointing out that this implication is not correct. &nbsp;UTF-8 and UTF-16 both have the &quot;detect a lost code unit that was part of a larger sequence&quot; property at the <em>code unit</em> level, not the <em>transport unit</em> level. &nbsp;It may seem like I&#8217;m nitpicking, but there&#8217;s a very large semantic difference between the two. &nbsp;UTF-8 and UTF-16 decoders have enough information to skip code unit sequences that were made invalid by incorrect truncation or concatenation of code unit processors. &nbsp;Implying that this property can handle the various corruption scenarios of certain lossy transports is akin to claiming ASCII is robust for lossy bit-oriented transports because bit 8 is always 0. &nbsp;It&#8217;s just not an impression you want to give.</p>
<p>In other words, for the practical applications of this property, UTF-8 and UTF-16 are on even ground. &nbsp;Since it&#8217;s not a designed-in reliability feature, it relies on specific scenarios with specific decoders &#8212; which basically means it should not be considered much of a feature for either encoding. &nbsp;(I consider the fact that invalid sequences can be detected at all to be very much a feature for reliable programming, though. &nbsp;It&#8217;s always &nbsp;good to know when something is wrong.)</p>
<p>&gt; It seems a bit strange to have an entire datatype devoted to an &quot;irrelevant implementation detail&quot; in a high level language like Java doesn&#8217;t it? To have tutorials and API families dedicated to such a type&#8230;</p>
<p>If you&#8217;ll recall, I originally stated that UTF-16 is the most appropriate encoding for general-purpose processing, so I don&#8217;t find it strange at all that there&#8217;s a datatype dedicated to that.</p>
<p>You&#8217;re also twisting my words a bit; I said the encoding is an irrelevant implementation detail when you&#8217;re working with a &quot;Unicode character&quot; abstraction. &nbsp;I didn&#8217;t make any claims about .NET, Java, or ECMAScript applying such an abstraction to their basic datatypes. &nbsp;I simply noted that they are platforms that have adopted UTF-16 natively.</p>
<p>The situation isn&#8217;t any different on UTF-8 platforms, as you note yourself with the comment on C&#8217;s char datatype. &nbsp;(As a side note, the default signed char is usually inconvenient for UTF-8 processing; I often see a typedef used for those cases in C. &nbsp;Most platforms with a datatype designed for UTF processing have an unsigned default.)</p>
<p>In your response to Dean,</p>
<p>&gt; I can&#8217;t see why [&#8230;] you seem to believe that normalisation is related to processing of surrogates in UTF-16.</p>
<p>He was referring to the fact that much of the parsing logic for handling surrogates is already required by the need to handle combining characters. &nbsp;It&#8217;s mentioned in Unicode 4.0 section 5.4 under &quot;Strategies for Surrogate Pair Support&quot;.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

