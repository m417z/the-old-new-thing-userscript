<html>
<head>
<title>MsgWaitForMultipleObjects and the queue state</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>MsgWaitForMultipleObjects and the queue state</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>February 17, 2005 / year-entry #41</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>37</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">One danger of the MsgWaitForMultipleObjects function is calling it when there are already messages waiting to be processed, because MsgWaitForMultipleObjects returns only when there is a new event in the queue. In other words, consider the following scenario: PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) returns TRUE indicating that there is a message. Instead of processing the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
One danger of
<a HREF="http://msdn.microsoft.com/library/en-us/dllproc/base/msgwaitformultipleobjects.asp">
the <code>MsgWaitForMultipleObjects</code> function</a>
is calling it when there are already messages waiting
to be processed, because <code>MsgWaitForMultipleObjects</code>
returns only when there is a <strong>new</strong> event in the queue.
</p>
<p>
In other words, consider the following scenario:
</p>
<ul>
<li><code>PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE)</code>
    returns <code>TRUE</code> indicating that there is a message.</p>
<li>Instead of processing the message, you ignore it and call
    <code>MsgWaitForMultipleObjects</code>.
</ul>
<p>
This wait will <strong>not</strong> return immediately, even though
there is a message in the queue. That's because the call to
<code>PeekMessage</code> told you that a message was ready,
and you willfully ignored it.  The
<code>MsgWaitForMultipleObjects</code> message tells you only
when there are new messages; any message that you already knew
about doesn't count.
</p>
<p>
A common variation on this is the following:
</p>
<ul>
<li><code>MsgWaitForMultipleObjects</code> returns that there is a message.
<li>You call <code>PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)</code>
    and process that message.</p>
<li>You call <code>MsgWaitForMultipleObjects</code> to wait for more messages.
</ul>
<p>
If it so happens that there were <strong>two</strong> messages
in your queue, the <code>MsgWaitForMultipleObjects</code> does not
return immediately, because there are no new messages; there is an
old message you willfully ignored, however.
</p>
<p>
When <code>MsgWaitForMultipleObjects</code> tells you that there is
a message in your message queue, you have to process <strong>all</strong>
of the messages until <code>PeekMessage</code> returns <code>FALSE</code>,
indicating that there are no more messages.
</p>
<p>
Note, however, that this sequence is not a problem:
</p>
<ul>
<li><code>PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE)</code>
    returns <code>FALSE</code> indicating that there is no message.</p>
<li>A message is posted into your queue.
<li>You call <code>MsgWaitForMultipleObjects</code> and include
    the <code>QS_ALLPOSTMESSAGE</code> flag.
</ul>
<p>
This wait does return immediately, because the incoming posted
message sets the "There is a new message in the queue that nobody
knows about" flag, which <code>QS_ALLPOSTMESSAGE</code> matches
and therefore causes <code>MsgWaitForMultipleObjects</code> to
return immediately.
</p>
<p>
<a HREF="http://msdn.microsoft.com/library/en-us/dllproc/base/msgwaitformultipleobjectsex.asp">
The <code>MsgWaitForMultipleObjectsEx</code> function</a>
lets you pass the <code>MWMO_INPUTAVAILABLE</code> flag
to indicate that it should check for previously-ignored input.
</p>
<p>
Armed with this knowledge, explain why the observed behavior with the
following code is "Sometimes my program gets stuck and reports one
fewer record than it should.  I have to jiggle the mouse to get the
value to update.  After a while longer, it falls two behind, then three..."
</p>
<pre>
// Assume that there is a worker thread that processes records and
// posts a WM_NEWRECORD message for each new record.

BOOL WaitForNRecords(HANDLE h, UINT cRecordsExpected)
{
  MSG msg;
  UINT cRecords = 0;
  while (true) {
    switch (MsgWaitForMultipleObjects(1, &amp;h,
                         FALSE, INFINITE, QS_ALLINPUT)) {
    case WAIT_OBJECT_0:
      DoSomethingWith(h); // event has been signalled
      break;
    case WAIT_OBJECT_1:
      // we have a message - peek and dispatch it
      if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
      }
      if (SendMessage(hwndNotify, WM_GETRECORDCOUNT,
                      0, 0) &gt;= cRecordsExpected) {
        return TRUE; // we got enough records
      }
      break;
    default:
      return FALSE; // unexpected failure
    }
  }
}
</pre>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-256303">
				<div id="div-comment-256303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256303">
			February 17, 2005 at 7:33 am</a>		</div>

		<p>Shouldn&#8217;t that be:</p>
<p>while (PeekMessage &#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256313">
				<div id="div-comment-256313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">George</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256313">
			February 17, 2005 at 8:28 am</a>		</div>

		<p>No, that was Raymond&#8217;s whole point!  If you peek, then wait, it fails as Raymond pointed out.  While it is possible that you could write it as a PeekMessage loop, just writing while(PeekMessage()) isn&#8217;t enough.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256323">
				<div id="div-comment-256323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CN</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256323">
			February 17, 2005 at 8:38 am</a>		</div>

		<p>If while&#8217;s used to replace the current if, that should be enough, I think&#8230;</p>
<p>Raymond, in your example, is there actually any work done in the windows proc for WM_NEWRECORD? I currently don&#8217;t understand why the falling behind would increase unless the counter was actually increased inside the window proc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256333">
				<div id="div-comment-256333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256333">
			February 17, 2005 at 8:45 am</a>		</div>

		<p>I guess I wasn&#8217;t explicit enough. I assumed people would have figured out that the window procedure goes something like this: </p>
<p>case WM_NEWRECORD:<br />
<br />process the new record;<br />
<br />records++;<br />
<br />display new record count in window;<br />
<br />break;<br />
<br />case WM_GETRECORDCOUNT:<br />
<br />return records;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256343">
				<div id="div-comment-256343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256343">
			February 17, 2005 at 9:03 am</a>		</div>

		<p>When we have a message notification, we should process all available messages and check if the event is signalled .</p>
<p>   case WAIT_OBJECT_1:<br />
<br />      // we have message(s) &#8211; peek and dispatch<br />
<br />      while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) {<br />
<br />        if(WaitForSingleObject(h,0) == WAIT_OBJECT_0)<br />
<br />      DoSomethingWith(h); // event has been signalled </p>
<p>    TranslateMessage(&amp;msg);<br />
<br />        DispatchMessage(&amp;msg);<br />
<br />      }<br />
<br />      if (SendMessage(hwndNotify, WM_GETRECORDCOUNT,<br />
<br />                      0, 0) &gt;= cRecordsExpected) {<br />
<br />        return TRUE; // we got enough records<br />
<br />      }<br />
<br />      break;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256363">
				<div id="div-comment-256363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256363">
			February 17, 2005 at 9:15 am</a>		</div>

		<p>Thanks for posting this entry. It, looks like I was doing it the wrong way in my code but never noticed any ill effects. There goes 95 and NT 4.0 support.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256373">
				<div id="div-comment-256373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.cs.wisc.edu/~rkennedy/' rel='external nofollow' class='url'>Rob Kennedy</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256373">
			February 17, 2005 at 9:22 am</a>		</div>

		<p>The WaitMessage function works the same way. It only returns on NEW messages.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256383">
				<div id="div-comment-256383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Wright</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256383">
			February 17, 2005 at 10:41 am</a>		</div>

		<p>Can somebody post what is the correct code?  I&#8217;ve spent some time reading everything, but I don&#8217;t want to be left guessing whether I understood it all correctly.<br />
<br />Thx!</p>
<p>Very helpful topic, BTW.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256413">
				<div id="div-comment-256413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasmusic.com' rel='external nofollow' class='url'>Joshua Schaeffer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256413">
			February 17, 2005 at 12:36 pm</a>		</div>

		<p>I would rather have had the ability to open a read-only handle to a live event object created by the message queue. It&#8217;d be way more flexible than trying to kludge MsgWaitForMultipleObjects into whatever scheme or framework I&#8217;m working with.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256433">
				<div id="div-comment-256433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/mpll' rel='external nofollow' class='url'>Pavel Lebedinsky</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256433">
			February 17, 2005 at 2:11 pm</a>		</div>

		<p>Ray: reentrancy is a general problem in code that uses Windows message queues. This is just something you have to deal with &#8211; the system can&#8217;t protect you from all possible scenarios.</p>
<p>Joshua: simply exposing an event would be very inefficient if you are only interested in a certain type of messages. You&#8217;d need some mechanism to tell the system when to signal the event. And then you&#8217;d have to deal with cases where two or more threads are waiting on the same event (should this be illegal? or should each thread get its own event object?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256443">
				<div id="div-comment-256443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/mpll' rel='external nofollow' class='url'>Pavel Lebedinsky</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256443">
			February 17, 2005 at 2:19 pm</a>		</div>

		<p>Ray: reentrancy is a general problem in code that uses Windows message queues. This is just something you have to deal with &#8211; the system can&#8217;t protect you from all possible scenarios.</p>
<p>Joshua: simply exposing an event would be very inefficient if you are only interested in a certain type of messages. You&#8217;d need some mechanism to tell the system when to signal the event. And then you&#8217;d have to deal with cases where two or more threads are waiting on the same event (should this be illegal? or should each thread get its own event object?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256483">
				<div id="div-comment-256483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256483">
			February 17, 2005 at 4:13 pm</a>		</div>

		<p>Jiggling the mouse to get a response is a common occurence in the Windows 2000 Start menu and Windows XP Classic version Start menu.  It is so common that it doesn&#8217;t even take thinking.  But this base note does make me wonder.  You know, click on the Start button, move up to Programs, move to the right and locate the folder containing the link you really want to click on, but that folder doesn&#8217;t expand.  You have to move the mouse to hover over another folder and then move back to the one you really wanted to expand.  So does Start menu processing contain the bug described here?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256493">
				<div id="div-comment-256493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256493">
			February 17, 2005 at 4:17 pm</a>		</div>

		<p>No that&#8217;s caused by a global foreground idle hook. Remember? You complained about this last year and I debugged it for you.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256503">
				<div id="div-comment-256503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel Bowen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256503">
			February 17, 2005 at 4:57 pm</a>		</div>

		<p>ATL includes a function &quot;AtlWaitWithMessageLoop&quot;.  Back a while ago on the ATL mailing lists, there was discussion of some deadlock possibilities with it (in part due to the issue you raise here), and how it might be improved.  Here&#8217;s the version that I came up with and currently use.  I&#8217;ve often wondered if the approach I use has any possible problems. What improvements could be made to this version?  (the formatting might get messed up)</p>
<p>BOOL WaitWithMessageLoop(<br />
<br />    HANDLE hHandleToWaitOn,<br />
<br />    DWORD dwInitialTimeOutMilliseconds = 0,<br />
<br />    DWORD dwIterateTimeOutMilliseconds = 500)<br />
<br />{<br />
<br />    DWORD dwRet=0;<br />
<br />    MSG msg={0};</p>
<p>    dwRet = ::WaitForSingleObject(hHandleToWaitOn, dwInitialTimeOutMilliseconds);<br />
<br />    if(dwRet == WAIT_OBJECT_0)<br />
<br />    {<br />
<br />        // The object is already signalled.<br />
<br />        return TRUE;<br />
<br />    }</p>
<p>    while(true)<br />
<br />    {<br />
<br />        // There are one or more window message available. Dispatch them.<br />
<br />        while(::PeekMessage(&amp;msg,NULL,NULL,NULL,PM_REMOVE))<br />
<br />        {<br />
<br />            ::TranslateMessage(&amp;msg);<br />
<br />            ::DispatchMessage(&amp;msg);<br />
<br />            dwRet = ::WaitForSingleObject(hHandleToWaitOn, 0);<br />
<br />            if(dwRet == WAIT_OBJECT_0)<br />
<br />            {<br />
<br />                // The object is already signalled.<br />
<br />                return TRUE;<br />
<br />            }<br />
<br />        }</p>
<p>        // Now we&#8217;ve dispatched all the messages in the queue.<br />
<br />        // Use MsgWaitForMultipleObjects to either tell us there are<br />
<br />        // more messages to dispatch, or that our object has been signalled.</p>
<p>        dwRet = ::MsgWaitForMultipleObjects(1, &amp;hHandleToWaitOn, FALSE,<br />
<br />                dwIterateTimeOutMilliseconds, QS_ALLINPUT);</p>
<p>        if(dwRet == WAIT_OBJECT_0)<br />
<br />        {<br />
<br />            // The event was signaled.<br />
<br />            return TRUE;<br />
<br />        }<br />
<br />        else if(dwRet == WAIT_OBJECT_0 + 1)<br />
<br />        {<br />
<br />            // New messages have come that need to be dispatched.<br />
<br />            continue;<br />
<br />        }<br />
<br />        else if(dwRet == WAIT_TIMEOUT)<br />
<br />        {<br />
<br />            // We hit our time limit, continue with the loop.<br />
<br />            continue;<br />
<br />        }<br />
<br />        else<br />
<br />        {<br />
<br />            // Something else happened.<br />
<br />            return FALSE;</p>
<p>        }<br />
<br />    }</p>
<p>    return FALSE;<br />
<br />}<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256513">
				<div id="div-comment-256513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256513">
			February 17, 2005 at 5:39 pm</a>		</div>

		<p>Ah&#8230; This is exactly one problem that I&#8217;ve encountered during my serial port application development. I was totally puzzled at the random lost of records. We (the development team) did tried to figure out the pattern of problem but never success, so the problem hang there until a new collegue told us about this&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256403">
				<div id="div-comment-256403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256403">
			February 17, 2005 at 10:52 am</a>		</div>

		<p>Gads&#8230; this function is so florked up that several articles have appeared in Windows Developer/MSDN magazine about it (I wrote one of them, so it stuck in my mind).</p>
<p>A much more fundamental danger of this function is that it can break the synchronization of the mutex if you&#8217;re not careful how you use it (recursive waits in particular are problematic). </p>
<p>Consider the case where you have a Lock() function that properly first calls MsgWaitForMultipleObjects, then processes the pending messages in a loop as Raymond suggests.</p>
<p>Now consider two different message handlers that need to access the protected resource:</p>
<p>case WM_PAINT:<br />
<br />  Lock();<br />
<br />  if (pProtected) {<br />
<br />    // Call some function that calls some other<br />
<br />    // function that does the following:<br />
<br />    Lock(); // This recursive Lock is broken<br />
<br />    pProtected-&gt;ProcessPaint();<br />
<br />    Unlock();<br />
<br />  }<br />
<br />  Unlock();</p>
<p>case WM_KILLFOCUS:<br />
<br />  Lock();<br />
<br />  if (pProtected) {<br />
<br />    delete pProtected;<br />
<br />    pProtected = NULL;<br />
<br />  }<br />
<br />  Unlock();</p>
<p>The Lock above that&#8217;s labelled &quot;This recursive lock is broken&quot; can process a WM_KILLFOCUS message which will successfully delete the protected resource (the thread already holds the mutex, so the wait will suceed). This, of course, causes a crash in the next line.</p>
<p>This all seems to be due to the fact that MsgWaitForMultipleObjects checks the message queue *first* rather than checking the state of the waited-for object first. </p>
<p>So, effectively, the necessity for processing the messages with a Peek() loop has generated a little preemptive operating system of its own, and since it&#8217;s in the same thread that has the locked resource, the mutex doesn&#8217;t protect.</p>
<p>The only solution I was able to come up with is to always put a &quot;if (WaitForSingleObject(hMutex, 0) != WAIT_OBJECT_0)&quot; before you try to use MsgWaitForMultipleObjects. </p>
<p>It should have been implemented this way in the OS, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256523">
				<div id="div-comment-256523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CJP</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256523">
			February 17, 2005 at 7:03 pm</a>		</div>

		<p>What happens if a message is enqueued between the call to MsgWaitForMultipleObjects and the call to PeekMessage&#8230;</p>
<p>E.G:</p>
<p>&lt;- (worker thread) Message 1 Added<br />
<br />(processing thread) MsgWaitForMultipleObjects<br />
<br />&lt;- (worker thread) Message 2 Added<br />
<br />(processing thread) PeekMessage<br />
<br />(processing thread) Message 2 processed</p>
<p>Since PeekMessage is only looking at the top message on the queue would not the first message be &#8216;lost&#8217; since it will be considered &#8216;old&#8217; as far as MsgWaitForMultipleObjects is concerned?</p>
<p>Of course, I could be barking up the wrong tree, I don&#8217;t have much experience with windows messaging and I suck at concurrency.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256533">
				<div id="div-comment-256533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256533">
			February 17, 2005 at 7:19 pm</a>		</div>

		<p>2/17/2005 4:17 PM Raymond Chen</p>
<p>&gt; No that&#8217;s caused by a global foreground idle<br />
<br />&gt; hook. Remember? You complained about this</p>
<p>Sorry, I don&#8217;t remember.  Thank you for pointing it out.  Perhaps I should keep notes :-)</p>
<p>&gt; last year and I debugged it for you. </p>
<p>Thank you again.  Do you know if it will be in Windows XP SP3 and Windows 2000 SP5?  (I don&#8217;t think I need to ask if you have the power to put it there, but can still ask if you know.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256423">
				<div id="div-comment-256423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JDM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256423">
			February 17, 2005 at 1:51 pm</a>		</div>

		<p>Can someone tell me if the following would be acceptable in the message loop for a window thread, or if I am still using the MsgWaitForMultipleObjects the wrong way.  Sorry, in advance, if the code shows up incorrectly, I have never posted here before.<br />
<br />Thanks.</p>
<p>/*	Start message loop for this thread. */<br />
<br />HANDLE[] hArray = { GetCurrentThread() };<br />
<br />while (TRUE)<br />
<br />{<br />
<br />  MSG msg;<br />
<br />  DWORD dwWait;<br />
<br />  while (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE))<br />
<br />  {<br />
<br />    if (msg.message == WM_QUIT)<br />
<br />    {<br />
<br />      ExitThread(0);<br />
<br />      return 1;<br />
<br />    }<br />
<br />    TranslateMessage(&amp;msg);<br />
<br />    DispatchMessage(&amp;msg);<br />
<br />  }<br />
<br />  dwWait =  MsgWaitForMultipleObjectsEx (1,     hArray, INFINITE, QS_ALLINPUT, 0);<br />
<br />  if (dwWait == (WAIT_OBJECT_0 + 1))<br />
<br />  {<br />
<br />    continue;<br />
<br />  }else{<br />
<br />    //  Do something..<br />
<br />  }<br />
<br />}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256543">
				<div id="div-comment-256543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256543">
			February 17, 2005 at 10:05 pm</a>		</div>

		<p>It was some program you installed that was messing with foreground idle. A translation program or something as I recall. Perhaps you could complain to the vendor of that program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256563">
				<div id="div-comment-256563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom M</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256563">
			February 18, 2005 at 1:40 am</a>		</div>

		<p>Don&#8217;t you have to  do something like while(::PeekMessage(&amp;msg,NULL,NULL,NULL,PM_REMOVE))<br />
<br />{<br />
<br />::TranslateMessage(&amp;msg);<br />
<br />::DispatchMessage(&amp;msg);<br />
<br />}<br />
<br />on WAIT_OBJECT_0 too, or else you can forget about those messages as well?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256573">
				<div id="div-comment-256573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://hallvards.blogspot.com/' rel='external nofollow' class='url'>Hallvard Vassbotn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256573">
			February 18, 2005 at 4:15 am</a>		</div>

		<p>&gt; The MsgWaitForMultipleObjectsEx function lets you pass the MWMO_INPUTAVAILABLE flag to indicate that it should check for previously-ignored input. </p>
<p>But this flag is not supported on NT.</p>
<p>&gt; You call MsgWaitForMultipleObjects and include the QS_ALLPOSTMESSAGE flag</p>
<p>What is the difference between </p>
<p>QS_ALLPOSTMESSAGE       = $0100;</p>
<p>and</p>
<p>QS_POSTMESSAGE          = $0008;</p>
<p>?</p>
<p>The MSDN docs says the same for both:</p>
<p><a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/msgwaitformultipleobjectsex.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/msgwaitformultipleobjectsex.asp</a></p>
<p>&quot;QS_POSTMESSAGE A posted message (other than those just listed) is in the queue.&quot;</p>
<p>&quot;QS_ALLPOSTMESSAGE A posted message (other than those listed here) is in the queue&quot;</p>
<p>IMO, this is a really messy API, but I think we are using it correctly &#8211; we use an object oriented wrapper (in Delphi) around the raw API calls, but it really boils down to calling </p>
<p>MsgWaitForMultipleObjects with the flag:</p>
<p>  QS_ALLINPUT = (QS_INPUT or QS_POSTMESSAGE or QS_TIMER or QS_PAINT or QS_HOTKEY or QS_SENDMESSAGE);</p>
<p>and when it returns WAIT_OBJECT_0 + FObjCount we basically return to Delphi VCL&#8217;s TApplication.ProcessMessages routine that will empty the message queue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256593">
				<div id="div-comment-256593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256593">
			February 18, 2005 at 7:26 am</a>		</div>

		<p>The very bottom of the MsgWaitForMultipleObjectsEx page says: &quot;The QS_ALLPOSTMESSAGE and QS_POSTMESSAGE flags differ in when they are cleared&quot; and some more detail after that.</p>
<p>I sure hope an answer key is forthcoming&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256683">
				<div id="div-comment-256683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Blekhman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256683">
			February 19, 2005 at 1:35 am</a>		</div>

		<p>In my opinion, situations that justify MsgWaitForMultipleObjects are quite rare nowadays. In the past thread were expensive and developers needed to scratch their heads how to cram in gazillion things in one thread. Today it’s just doesn’t worth it. Besides, this is annoying when you have message loops splattered here and there in the code. If I need to process some data which involves synchronization issues, then I don’t even want to think about messing it with GUI. Just stash it in worker thread, do the job, then notify GUI in some flexible and lazy way (say, with PostMessage).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256813">
				<div id="div-comment-256813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256813">
			February 20, 2005 at 7:42 pm</a>		</div>

		<p>2/17/2005 10:05 PM Raymond Chen</p>
<p>&gt; It was some program you installed that was<br />
<br />&gt; messing with foreground idle.</p>
<p>That is a completely unrelated issue.  The matter of the Start menu, at random times not expanding folders unless the mouse is moved to a different folder and moved back, occurs even when all applications come from Microsoft.  It is intermittently reproducible both on real PCs and virtual PCs.  Now I resume thinking that your base note here looks like a likely explanation.  The symptom really resembles the example you gave.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256823">
				<div id="div-comment-256823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256823">
			February 20, 2005 at 7:54 pm</a>		</div>

		<p>Hm well I&#8217;ve never experienced it. But I doubt it&#8217;s this problem. Menus don&#8217;t mix user and kernel waits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256873">
				<div id="div-comment-256873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/archive/2005/02/21/377337.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256873">
			February 21, 2005 at 10:00 am</a>		</div>

		<p>The dichotomy breaks in the other direction, too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256903">
				<div id="div-comment-256903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256903">
			February 21, 2005 at 11:03 am</a>		</div>

		<p>Is there a way to tell Windows to &quot;from now on pretend i don&#8217;t know about any messages in the queue&quot; function? Basically undo the strangeness that PeekMessage does.</p>
<p>Does MsgWaitForMultipleObjects also tag queued messages as &quot;read&quot; like PeekMessage. i.e. Once i &quot;realize&quot; there is a message in the queue with MsgWaitForMultipleObjects, am i then forced to process all messages in the queue?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256953">
				<div id="div-comment-256953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">daev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-256953">
			February 21, 2005 at 1:35 pm</a>		</div>

		<p>&quot;In my opinion, situations that justify MsgWaitForMultipleObjects are quite rare nowadays. In the past thread were expensive and developers needed to scratch their heads how to cram in gazillion things in one thread.&quot;</p>
<p>Actually MsgWaitForMultipleObjects turns out to be very useful in multithread situations.</p>
<p>It&#8217;s the only way for you to add a user-defined window message that works like WM_PAINT &#8212; a very low priority message, and there&#8217;s only one of them in the queue no matter how many times you post it.</p>
<p>I used a message loop based on MsgWaitForMultipleObjects when I had a program with a worker thread that did computation and wrote output text.  There was also a main UI thread which controlled the window, so the worker thread should not be allowed to change the window contents itself.</p>
<p>When the worker thread (which you can imagine as printing a million digits of Pi) has some text to output, it must post a message to the UI thread to get the text displayed.  But if you used ordinary user-defined messages, you could get thousands of tiny WM_USERs clogging up the message queue.</p>
<p>The solution is to have a text buffer that holds the new output.  Any time new text is added to the buffer, the worker thread posts a WM_PAINT-type message to the UI thread.  There&#8217;s only one WM_PAINT at any time, and it&#8217;s always handled after more critical interactive messages (like scroll-bar manipulation).  When the UI thread services the message, it outputs all the text in the buffer at once, just as a WM_PAINT handler updates the whole invalidated region of the window, regardless of how many smaller invalidations composed it.</p>
<p>But since you can&#8217;t define your own WM_PAINT-type message, you can get the same effect by using MsgWaitForMultipleObjects and replacing &quot;post a message&quot; with &quot;flip on the event object.&quot;  If you write the loop correctly (as described by Raymond) you get the same behavior.</p>
<p>(Raymond and others:  Are there any potential gotchas to this approach?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-257053">
				<div id="div-comment-257053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Blekhman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-257053">
			February 22, 2005 at 12:35 am</a>		</div>

		<p>daev wrote:<br />
<br />&quot;Actually MsgWaitForMultipleObjects turns out to be very useful in multithread situations. </p>
<p>It&#8217;s the only way for you to add a user-defined window message that works like WM_PAINT &#8212; a very low priority message, and there&#8217;s only one of them in the queue no matter how many times you post it.&quot;</p>
<p>I agree. That&#8217;s the example of MsgWaitForMultipleObjects where it&#8217;s handy. However, with two reservations:</p>
<p>1. You use it to &quot;improve&quot; regular main message loop, not to implement bastard message loop somewhere in program.</p>
<p>2. While less elegant, simple WM_TIMER with polling of text buffer is much less confusing than MsgWaitForMultipleObjects. Unless you really need to update GUI ASAP, updating it 3-5 times in second will be indistinguishable from user&#8217;s point of view. Consider how significantly less explanation requires WM_TIMER to maintenace programmer than esoteric gotchas of MsgWaitForMultipleObjects.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-257063">
				<div id="div-comment-257063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Blekhman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-257063">
			February 22, 2005 at 12:36 am</a>		</div>

		<p>daev wrote:<br />
<br />&quot;Actually MsgWaitForMultipleObjects turns out to be very useful in multithread situations. </p>
<p>It&#8217;s the only way for you to add a user-defined window message that works like WM_PAINT &#8212; a very low priority message, and there&#8217;s only one of them in the queue no matter how many times you post it.&quot;</p>
<p>I agree. That&#8217;s the example of MsgWaitForMultipleObjects where it&#8217;s handy. However, with two reservations:</p>
<p>1. You use it to &quot;improve&quot; regular main message loop, not to implement bastard message loop somewhere in program.</p>
<p>2. While less elegant, simple WM_TIMER with polling of text buffer is much less confusing than MsgWaitForMultipleObjects. Unless you really need to update GUI ASAP, updating it 3-5 times in second will be indistinguishable from user&#8217;s point of view. Consider how significantly less explanation requires WM_TIMER to maintenace programmer than esoteric gotchas of MsgWaitForMultipleObjects.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-257503">
				<div id="div-comment-257503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-257503">
			February 24, 2005 at 10:56 am</a>		</div>

		<blockquote><p>
  Ray: reentrancy is a general problem in code<br />
  <br />&gt; that uses Windows message queues. This is just<br />
  <br />&gt; something you have to deal with &#8211; the system<br />
  <br />&gt; can&#8217;t protect you from all possible scenarios. </p>
<p>This is, of course, true. And as I mentioned there are numerous ways you can screw yourself, by yourself, if you&#8217;re not careful.</p>
<p>However, this function is the only one I know of where the action is entirely implicit. I.e. you&#8217;re not calling something that you can know is going to be doing a SendMessage in the context of the current thread. You, in fact, can&#8217;t know what it will do at all.</p>
<p>As a result, when you&#8217;re talking about a mutex that&#8217;s grabbed by message handlers (which is one of the main uses of this kind of function&#8230; to avoid the inevitable deadlock that will happen if you ever do anything that requires message processing in such a handler), the only safe thing to do is to always return without processing any pending messages if the mutex is already held. </p>
<p>Not only does this function not do that by default (which obviates almost its entire point), there&#8217;s not even an option for it&#8230; you have to code that additional check by hand yourself or you&#8217;re looking at a complete maintenance nightmare. </p>
<p>It&#8217;s not the end of the world, but it is an extremely obscure pitfall.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-261293">
				<div id="div-comment-261293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-261293">
			March 5, 2005 at 3:54 pm</a>		</div>

		<blockquote><p>
  It&#8217;s the only way for you to add a user-defined window message that works like WM_PAINT &#8212; a very low priority message, and there&#8217;s only one of them in the queue no matter how many times you post it.</p>
<p>I seem to remember WM_COALESCE_FIRST … WM_COALESCE_LAST were supposed to have had similar semantics in that there&#8217;s only one of each in the queue.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-345013">
				<div id="div-comment-345013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/01/26/517849.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-345013">
			February 10, 2006 at 11:54 am</a>		</div>

		<p>Putting together pieces you already know.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-417323">
				<div id="div-comment-417323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/timng/archive/2006/09/06/743795.aspx' rel='external nofollow' class='url'>Tim Ng</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-417323">
			September 7, 2006 at 12:51 am</a>		</div>

		<p>Disclaimer: I hesitated posting this because this is a topic that is extremely complicated and deep,&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-668773">
				<div id="div-comment-668773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sarathc.wordpress.com/2008/09/19/when-and-how-should-we-use-msgwaitformultipleobjects/' rel='external nofollow' class='url'>When and How should we use MsgWaitForMultipleObjects? &laquo; Sharing my thoughts&#8230;</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-668773">
			September 19, 2008 at 1:23 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://sarathc.wordpress.com/2008/09/19/when-and-how-should-we-use-msgwaitformultipleobjects/" rel="nofollow">http://sarathc.wordpress.com/2008/09/19/when-and-how-should-we-use-msgwaitformultipleobjects/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-690343">
				<div id="div-comment-690343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.cromis.net/blog/2008/12/active-sleep-procedure-aftermath/' rel='external nofollow' class='url'>From Zero To One &raquo; Active Sleep procedure - Aftermath</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050217-00/?p=36423#comment-690343">
			December 6, 2008 at 9:17 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.cromis.net/blog/2008/12/active-sleep-procedure-aftermath/" rel="nofollow">http://www.cromis.net/blog/2008/12/active-sleep-procedure-aftermath/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

