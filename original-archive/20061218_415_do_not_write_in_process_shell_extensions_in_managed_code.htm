<html>
<head>
<title>Do not write in-process shell extensions in managed code</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Do not write in-process shell extensions in managed code</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 18, 2006 / year-entry #416</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>42</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Jesse Kaplan, one of the CLR program managers, explains why you shouldn't write in-process shell extensions in managed code. The short version is that doing so introduces a CLR version dependency which may conflict with the CLR version expected by the host process. Remember that shell extensions are injected into all processes that use the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p> Jesse Kaplan, one of the CLR program managers, explains <a href="http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=125283&amp;SiteID=1"> why you shouldn't write in-process shell extensions in managed code</a>. The short version is that doing so introduces a CLR version dependency which may conflict with the CLR version expected by the host process. Remember that shell extensions are injected into all processes that use the shell namespace, either explicitly by calling <code>SHGetDesktopFolder</code> or implicitly by calling a function like <code>SHBrowseForFolder</code>, <code>ShellExecute</code>, or even <code>GetOpenFileName</code>. Since only one version of the CLR can be loaded per process, it becomes a race to see who gets to load the CLR first and establish the version that the process runs, and everybody else who wanted some other version loses. </p>
<p> <b>Update 2013</b>: Now that version 4 of the .NET Framework supports in-process side-by-side runtimes, is it now okay to write shell extensions in managed code? <a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/02/22/10396079.aspx"> The answer is still no</a>. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-453793">
				<div id="div-comment-453793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">c</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453793">
			December 18, 2006 at 11:15 am</a>		</div>

		<p>Wasn&#8217;t this one of the big reasons for the Reset?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-453813">
				<div id="div-comment-453813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.broadheath.com' rel='external nofollow' class='url'>Frank Wilhoit</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453813">
			December 18, 2006 at 11:49 am</a>		</div>

		<p>It would seem to me that desired CLR versions ought to be specified as a threshold, i.e. I need version GREATER THAN OR EQUAL TO N.N.N .</p>
<div class=post>[<i>That assumes that there will never be any breaking changes to the CLR. Whether that&#8217;s a valid assumption or not I leave you to determine. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453843">
				<div id="div-comment-453843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453843">
			December 18, 2006 at 12:31 pm</a>		</div>

		<p>Is it just me or were some of those responses horrifying? &nbsp;It seemed like people were thumbing their nose of two people who know a metric ton more about the inner workings of CLR and WindowsShell than anyone else on the planet, and yet they were trying to argue the point. &nbsp;If it was all hypothetical, then that&#8217;s one thing&#8230;but I don&#8217;t believe it was.</p>
<p>Raymond, is Rowland right? &nbsp;Did MS release a RawImage thumnail extension written in .Net?</p>
<p>Steve</p>
<div class=post>[<i>I don&#8217;t know. (I&#8217;m going to invoke my right not to answer questions I don&#8217;t want to, so don&#8217;t expect &#8220;I don&#8217;t know&#8221; or &#8220;I don&#8217;t care&#8221; answers to every question.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-453853">
				<div id="div-comment-453853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453853">
			December 18, 2006 at 12:32 pm</a>		</div>

		<p>&quot;[That assumes that there will never be any breaking changes to the CLR. Whether that&#8217;s a valid assumption or not I leave you to determine. -Raymond]&quot;</p>
<p>Yes it&#8217;s a valid assumption. &nbsp;When .NET 2.0 just entered public beta, my company released a .NET 1.1 program. &nbsp;It didn&#8217;t work on 2.0. &nbsp;The CLR team has no problem breaking stuff between major releases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453863">
				<div id="div-comment-453863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453863">
			December 18, 2006 at 12:39 pm</a>		</div>

		<p>Any change can be considered a &quot;breaking&quot; change, because it is possible to make a program rely on a specific behavior no matter how incorrect or obscure.</p>
<p>For example, let&#8217;s say you have a CLR 1.1 shell extension Foo that does FTP, and is has a class called FtpRequest. When you run it on CLR 1.2 which implements its own FtpRequest class, Foo stops working because it gets the CLR&#8217;s FtpRequest instead of your own.</p>
<p>Of course you could just put the class in a namespace (like you should have done in the first place) and recompile, but your customers can&#8217;t recompile. They already have the broken version and upgrading their CLR will break it no matter what.</p>
<p>You could mark Foo as requiring CLR 1.1, but if the next extension to load requires CLR 1.2 then it will fail.</p>
<p>The correct behavior in this case seems to be to just allow multiple versions of the CLR in a process. Unfortunately this means every single app with so much as a File Open dialog will end up loading every version of the CLR because one extension will be marked with v1.1, another will be v1.0, another will be v2.0, etc.</p>
<p>Since that would be a disaster, it&#8217;s best to stay away from managed shell extensions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-453883">
				<div id="div-comment-453883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">andy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453883">
			December 18, 2006 at 12:46 pm</a>		</div>

		<p>Is this the reason why the Windows Sidebar has a .NET object model(<a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/aa965853.aspx" rel="nofollow">http://msdn2.microsoft.com/en-us/library/aa965853.aspx</a>) but gadgets must be developed using HTML + scripting using this object model. Or did I miss something about Gadget-development?</p>
<p>Hopefully somebody at Microsoft is working to remedy this issue for the next release of Windows and/or .NET!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453893">
				<div id="div-comment-453893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">andy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453893">
			December 18, 2006 at 12:53 pm</a>		</div>

		<p>&quot;is Rowland right? &nbsp;Did MS release a RawImage thumnail extension written in .Net?&quot;</p>
<p>Yes, (s)he is correct. See</p>
<p><a rel="nofollow" target="_new" href="http://www.microsoft.com/downloads/details.aspx?familyid=D48E808E-B10D-4CE4-A141-5866FD4A3286&amp;displaylang=en" rel="nofollow">http://www.microsoft.com/downloads/details.aspx?familyid=D48E808E-B10D-4CE4-A141-5866FD4A3286&#038;displaylang=en</a></p>
<p>Maybe some intern developed it or somebody in their spare time. Anyways would be appropriate with some kind of warning at that download page so customers become aware that installing this extension might cause incompatibility issues.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-453903">
				<div id="div-comment-453903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wang-Lo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453903">
			December 18, 2006 at 1:06 pm</a>		</div>

		<p>It&#8217;s so comforting to see that the famously successful methods developed over the past couple of decades for managing DLL version dependencies have been adopted without modification for managing the analogous CLR problem.</p>
<p>-Wang-Lo.</p>
<div class=post>[<i>I&#8217;m not sure why you&#8217;re congratulating me on something I had nothing to do with. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453913">
				<div id="div-comment-453913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gwyn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453913">
			December 18, 2006 at 1:58 pm</a>		</div>

		<p>Raymond, I&#8217;m pretty sure that Wang-Lo&#8217;s comment was just dripping with sarcasm.</p>
<div class=post>[<i>As was my response. My point is that if you have an issue with the CLR, complaining to me won&#8217;t accomplish anything. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-453933">
				<div id="div-comment-453933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453933">
			December 18, 2006 at 2:26 pm</a>		</div>

		<p>Gabe:</p>
<blockquote><p>
  For example, let&#8217;s say you have a CLR 1.1 shell extension Foo that does FTP, and is has a class called FtpRequest. When you run it on CLR 1.2 which implements its own FtpRequest class, Foo stops working because it gets the CLR&#8217;s FtpRequest instead of your own.
</p></blockquote>
<p>That&#8217;s your fault for mucking around in someone else&#8217;s package :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-453963">
				<div id="div-comment-453963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anthony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453963">
			December 18, 2006 at 3:48 pm</a>		</div>

		<blockquote><p>
  Since only one version of the CLR can be loaded per process, it becomes a race to see who gets to load the CLR first and establish the version that the process runs, and everybody else who wanted some other version loses.
</p></blockquote>
<p>I was worried what this might imply, and found that on the referenced link at the top, you pointed out:</p>
<blockquote><p>
  The key point is that you have to avoid injecting the CLR into processes that aren&#8217;t expecting it. COM is just a conduit for the injection. Don&#8217;t focus on the COM part; focus on the injection part. If all the processes that use your COM object are expecting the CLR (e.g. because you wrote them) then there&#8217;s no problem since there is no injection.
</p></blockquote>
<p>So, if I read you correctly, building generally consumable in-process COM objects with managed code is a potential no-no. &nbsp;</p>
<p>I&#8217;m not fully up to speed with .NET, but I believe there&#8217;s a COM wrapper you can use around a .NET interface. &nbsp;Do these run out of process to circumvent the potential conflict?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-453973">
				<div id="div-comment-453973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-453973">
			December 18, 2006 at 5:15 pm</a>		</div>

		<blockquote><p>
  Do these run out of process to circumvent the potential conflict?
</p></blockquote>
<p>No, it&#8217;s exactly this wrapper that causes the problems.</p>
<p>I&#8217;ve been toying with writing an out-of-process shell extension plugin for a while (like with IIS &amp; ASP.NET). The extension would just pass requests to a &quot;worker&quot; process to handle the actual work. You could then have one worker process per version of the CLR that you needed. It should work for most extensions (property pages being the most difficult one) but I&#8217;m not sure what the performance would be like&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454013">
				<div id="div-comment-454013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Elliott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454013">
			December 18, 2006 at 6:24 pm</a>		</div>

		<p>This came up where I work, trying to write an MFC app that called a .NET component using the COM wrapper &#8211; and the component only worked on CLR 1.1, not 2.0. The eventual solution we reached was for the MFC program to load CLR 1.1 using CorBindToRuntime before instantiating the component.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454043">
				<div id="div-comment-454043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Stewien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454043">
			December 18, 2006 at 6:48 pm</a>		</div>

		<p>I like Dean Harding&#8217;s idea. I&#8217;m thinking this is a problem because shell extensions are done through DLLs. The alternative though is that you have to run all your shell extensions as services which then communicate with the shell. I would think the Singularity team at Microsoft Research have been looking into this as the O/S they have developed doesn&#8217;t have support for DLLs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454053">
				<div id="div-comment-454053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://code.magicprints.com/' rel='external nofollow' class='url'>Daniel Colascione</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454053">
			December 18, 2006 at 6:50 pm</a>		</div>

		<p>The versioning problem is unavoidable for in-process objects anyway, since a function can only have one definition (and two-level namespaces, ala OS X, are a cure worse than the disease). We run into the same problem in unixland with multiple incompatible libstdc++ versions in programs with plugins.</p>
<p>The real WTF here is that shell extensions are loaded into every process that happens to use the shell namespace. Why wasn&#8217;t it designed to talk using IPC with some shell daemon from the get-go? It&#8217;s like the Unix NSS problem magnified a thousand-fold. If code injection is the answer, you&#8217;re probably asking the wrong question.</p>
<div class=post>[<i>Remember, Windows&nbsp;95 had to run in 4MB of memory. (Besides, imagine how many services would be running if every shell extension were a service. And imagine the new security vulnerabilities.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454063">
				<div id="div-comment-454063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://code.magicprints.com/' rel='external nofollow' class='url'>Daniel Colascione</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454063">
			December 18, 2006 at 6:55 pm</a>		</div>

		<p>John Stewien:</p>
<p>There are two traditional uses for shared library:</p>
<p>A) Sharing code for efficiency&#8217;s sake (e.g., libc or msvcrt), and</p>
<p>B) Loading potentially changing modules into a process (shell namespace extensions, unixland NSS, winamp plugins, etc.)</p>
<p>While A, with proper versioning, is a huge win, I think that B often brings more trouble than it&#8217;s worth. Every modern OS uses that architecture at some level, though, but I don&#8217;t see why. Would using IPC really cost that much more? I can see a case for B in plugins that are tightly integrated into a host program&#8217;s GUI, but even that would be manageable with some kind of out-of-process COM trickery, I imagine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-454083">
				<div id="div-comment-454083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454083">
			December 18, 2006 at 7:15 pm</a>		</div>

		<p>&gt; every shell extension were a service</p>
<p>That&#8217;s not how I would do it. My extension would essentially be a &#8220;framework&#8221; that developers would write their .NET extensions against. I&#8217;d only load one worker process per version of the CLR that you needed &#8211; each extension would simply reside in an AppDomain of that worker process.</p>
<p>Obviously, it wouldn&#8217;t be a service, either. The worker process would just run under the same account as the launching explorer.exe.</p>
<div class=post>[<i>Daniel appeared to be applying this principle globally, not just to managed extensions. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454123">
				<div id="div-comment-454123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454123">
			December 18, 2006 at 8:48 pm</a>		</div>

		<blockquote><p>
  Remember, Windows 95 had to run in 4MB of memory. (Besides, imagine how many services would be running if every shell extension were a service. And imagine the new security vulnerabilities.) -Raymond
</p></blockquote>
<p>What security vulnerabilities? You&#8217;re running services on the box; since they expect to be explorer extensions, they&#8217;re only accessible from that box. The question is how to partition something like that when multiple users are on the box &#8211; you may end up with some sort of corba like beast.</p>
<p>All I can see from this thread is that C# isn&#8217;t nearly as handy as straight C++. Wouldn&#8217;t it be nice if we had some lightweight messaging interface? You could write an extension as out of proc and have the CLR and proc issues handled automatically, while designing APIs that didn&#8217;t drag ass in large directories and other extreme cases. Of course, this is complicated, and wouldn&#8217;t fly too well when the guy writing the exception is at the level of a typical VB6 programmer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454163">
				<div id="div-comment-454163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">HS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454163">
			December 19, 2006 at 12:23 am</a>		</div>

		<p>&lt;blockquote&gt;Yes it&#8217;s a valid assumption. &nbsp;When .NET 2.0 just entered public beta, my company released a .NET 1.1 program. &nbsp;It didn&#8217;t work on 2.0. &nbsp;The CLR team has no problem breaking stuff between major releases. &#8211; J&lt;/blockquote&gt;</p>
<p>I think they have no qualms about maintaining compatibility because the CLR is versioned.</p>
<p>You can&#8217;t run your 1.1 program on CLR 2.0, but on the other hand, you can install CLR 1.1 on the same machine that runs CLR 2.0 and both will co-exist and programs written for both versions can co-exist and run by correctly loading the version of the CLR it needs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454203">
				<div id="div-comment-454203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454203">
			December 19, 2006 at 1:32 am</a>		</div>

		<p>Originally, the CLR team specifically denied any claim that future versions of the CLR would be backwards compatible. Instead, IIRC, they claimed that all versions of the CLR would work side-by-side.</p>
<p>Now, this solution isn&#8217;t perfect, and nobody wants 10 versions of the CLR installed, but it seems like it was probably the best solution for 1.0, 1.1, and 2.0, as .NET is changing very quickly and compatibility issues are certainly going to be a problem.</p>
<p>Even so, strong backwards compatibility was an important goal for 1.1 and 2.0. Neither one has perfect back-compat, but they&#8217;re not terribly bad, either. Of course, it only takes one back-compat issue to make YOUR app (the most important app in the world) not work.</p>
<p>For now, it isn&#8217;t terribly outrageous to have 1.0, 1.1, and 2.0 installed, allowing you to bypass most back-compat issues (assuming nobody does something silly like load two different .NET DLLs with different requirements into the same process).</p>
<p>In the future, a whole new CLR for each revision becomes less maintainable. In addition, as more components want to share the process space, cross-CLR compatibility will become more important. And as the platform matures, this will become more possible.</p>
<p>For example, notice that .NET 3.0 uses the same execution engineas .NET 2.0, so it can share the same process space. I&#8217;ve heard that other, less visible changes have also been made under the covers that will allow this to continue even with changes to the execution engine.</p>
<p>In any case, while .NET hasn&#8217;t been perfect, it is not fair to say they didn&#8217;t learn anything. It is leagues ahead of plain-vanilla DLLs and COM in versioning strategy, and avoids so many versioning issues in both the framework and in end-user apps.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454283">
				<div id="div-comment-454283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454283">
			December 19, 2006 at 6:44 am</a>		</div>

		<p>The root question is: why is the CLR linked against the managed executable using what is in effect a process-wide namespace? Because if multiple CLRs could co-exist, an extension needing CLR 1.0 would link against that CLR, and another could link against CLR 2.0. That doesn&#8217;t sound hard: if an managed app wants symbols from CLR 1.0, in the compiler simply prefix every symbol with <strong>CLR10</strong>. If from 1.1, <strong>CLR11</strong>.</p>
<p>Of course, you would still end up with a big Shell that way, but that is probably not too important. If it is important (1000+ customers or so), you&#8217;d be looking at stuff like LIBCTINY, not .NET.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454313">
				<div id="div-comment-454313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454313">
			December 19, 2006 at 9:04 am</a>		</div>

		<p>&#8220;Remember, Windows 95 had to run in 4MB of memory. &#8221;</p>
<p>So? Vista requires at least 512MB. The .Net framework is not even<br />
available for Windows 95, so it is irrelevant to this discussion.</p>
<p>The &#8216;proper&#8217; solution to this problem would be something like Dean<br />
Harding is suggesting, only supplied as standard with, say .NET 3.2 and<br />
made the recommended way to create shell extensions, with a couple of<br />
templates included in the next iteration of Visual Studio.</p>
<p>Of course, this solution would have violated Windows 95&#8217;s holy 4MB, but nobody cares about that anymore.</p>
<p>And when will Microsoft seriously start to &#8216;dogfood&#8217; .Net? </p>
<p>So far the only &#8216;serious&#8217; commercial applications written in .Net<br />
released are the hardly-heard-of-let-alone-used Microsoft Expression<br />
Suite.</p>
<p>Come on! How about at least re-writing the Windows Accessories in C# or porting Visual Studio to .Net? </p>
<p>Maybe then Microsoft will find more of these &#8216;limitations&#8217; of .Net<br />
and have more incentive to fix them, rather than treating .Net<br />
developers as second-class-citizens (except when it comes to new UI<br />
stuff).</p>
<div class="post">[<i>The original comment was that the shell extension<br />
mechanism should have been based on out-of-proc servers. That would not<br />
have been practical in 4MB. Therefore, the shell extension mechanism is<br />
in-proc. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454323">
				<div id="div-comment-454323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">c++ 4ever</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454323">
			December 19, 2006 at 9:10 am</a>		</div>

		<p>Load .net framework multiple times? Stupid architecture.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454333">
				<div id="div-comment-454333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454333">
			December 19, 2006 at 9:18 am</a>		</div>

		<p>Daniel Colascione:</p>
<blockquote><p>
  A) Sharing code for efficiency&#8217;s sake (e.g., libc or msvcrt), and</p>
<p>  B) Loading potentially changing modules into a process (shell namespace extensions, unixland NSS, winamp plugins, etc.)
</p></blockquote>
<p>How about C) Being able to fix a security vulnerability in one library (e.g. zlib) and have it applied to every process that uses that library, across the whole system. &nbsp;Maybe that&#8217;s not a &quot;traditional&quot; use of libraries, but it&#8217;s sure a good use.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454493">
				<div id="div-comment-454493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">useless neway</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454493">
			December 19, 2006 at 11:27 am</a>		</div>

		<blockquote><p>
  Remember, Windows 95 had to run in 4MB of memory.
</p></blockquote>
<p>That&#8217;s off topic because .net fw doesn&#8217;t run in win95</p>
<p>.net framework 1.1 cannot run Comapct framework 1.0 apps even if .netFW is supposed to be a superset of CF.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454623">
				<div id="div-comment-454623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.vyvojar.cz/jachymko' rel='external nofollow' class='url'>jachymko</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454623">
			December 19, 2006 at 1:06 pm</a>		</div>

		<p>Burak KALAYCI:</p>
<p>yeah, but it didnt refuse to start on a 4MB box. if it had out-of-process shell extensions, you wouldn&#8217;t be able to start the shell at all.</p>
<p>I pity you if you make all your decisions this fast. Managed code makes lot of tasks easier. It has some drawbacks you need to be aware of, just like everything else.</p>
<p>Stu:</p>
<p>[cite]So far the only &#8216;serious&#8217; commercial applications written in .Net released are the hardly-heard-of-let-alone-used Microsoft Expression Suite.[/cite]</p>
<p>Have you heard of SQL Server, Visual Studio Team System, Office Server, BizTalk Server&#8230; Microsoft has lot of quite serious .NET-based products. There is no point in rewriting legacy code just for the rewrite sake.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454743">
				<div id="div-comment-454743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.asvguy.com' rel='external nofollow' class='url'>Burak KALAYCI</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454743">
			December 19, 2006 at 2:23 pm</a>		</div>

		<p>&gt; yeah, but it didnt refuse to start on a 4MB box.</p>
<p>Yes it did start, I have to credit that.</p>
<p>I remember something like the base mem for executables were at 4MB default and W95 had to fix all jumps before running them in a 4MB box and that caused extra slowness. I always had the impression that it wasn&#8217;t really designed for 4MB&#8230;</p>
<p>&gt; I pity you if you make all your decisions this fast.</p>
<p>Fast? I made my decision around May 1990. It was between 80&#215;86 assembly and gwbasic. I feel no remorse.</p>
<p>Best regards,</p>
<p>Burak</p>
<div class=post>[<i>? Non sequitur. Physical address space is not linear address space. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454923">
				<div id="div-comment-454923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.asvguy.com' rel='external nofollow' class='url'>Burak KALAYCI</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454923">
			December 19, 2006 at 5:55 pm</a>		</div>

		<p>&gt; Non sequitur. Physical address space is not linear address space.</p>
<p>I may be totally wrong. What I was talking about is the image base set by linker being at 4MB by default causing extra relocation effort when loading on a system with just 4MB memory. I had read it somewhere, I&#8217;m not sure if it really makes sense (or if I remember it correctly).</p>
<p>Best regards,</p>
<p>Burak</p>
<div class=post>[<i>The images are loaded at their preferred linear address of 4MB. No relocation is needed. I shouldn&#8217;t need to explain this. I assume my readers know this stuff already. If I had to keep explaining the basic stuff I&#8217;d never get around to discussing the advanced stuff. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-454943">
				<div id="div-comment-454943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.asvguy.com' rel='external nofollow' class='url'>Burak KALAYCI</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454943">
			December 19, 2006 at 6:32 pm</a>		</div>

		<p>Guess I was talking about the following,</p>
<p><a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/ms809762.aspx" rel="nofollow">http://msdn2.microsoft.com/en-us/library/ms809762.aspx</a></p>
<p>&#8216;In executables produced for Windows NT, the default image base is 0x10000. For DLLs, the default is 0x400000. In Windows 95, the address 0x10000 can&#8217;t be used to load 32-bit EXEs because it lies within a linear address region shared by all processes. Because of this, Microsoft has changed the default base address for Win32 executables to 0x400000. Older programs that were linked assuming a base address of 0x10000 will take longer to load under Windows 95 because the loader needs to apply the base relocations.&#8217;</p>
<p>Turns out my memory is not as good as I&#8217;d have liked.</p>
<p>Best regards,</p>
<p>Burak</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-454423">
				<div id="div-comment-454423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.asvguy.com' rel='external nofollow' class='url'>Burak KALAYCI</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454423">
			December 19, 2006 at 10:36 am</a>		</div>

		<p>&quot;Remember, Windows 95 had to run in 4MB of memory. &quot;</p>
<p>I remember that! I&#8217;d say it &#8216;crawled&#8217; with 4MB. 8MB was the real minimum it managed to &#8216;run&#8217; (Though I haven&#8217;t tested any memory size inbetween).</p>
<p>My take: Don&#8217;t write *anything* in managed code.</p>
<p>Best regards,</p>
<p>Burak</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-454963">
				<div id="div-comment-454963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-454963">
			December 19, 2006 at 6:54 pm</a>		</div>

		<blockquote><p>
  I made my decision around May 1990
</p></blockquote>
<p>How did you choose not to write apps in .NET in 1990?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-455033">
				<div id="div-comment-455033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455033">
			December 19, 2006 at 9:50 pm</a>		</div>

		<p>Gabe,</p>
<blockquote><p>
  &gt; For example, let&#8217;s say you have a CLR 1.1 shell extension Foo that does FTP, and is has a class called FtpRequest. When you run it on CLR 1.2 which implements its own FtpRequest class, Foo stops working because it gets the CLR&#8217;s FtpRequest instead of your own.
</p></blockquote>
<p>The class name resolution rules, at minimum, also include a reference the containing assembly. &nbsp;The CLR knows FtpRequest in your assembly is not the same class as FtpRequest in any other assembly, so this situation cannot occur.</p>
<p>Michiel,</p>
<blockquote><p>
  &gt; The root question is: why is the CLR linked against the managed executable using what is in effect a process-wide namespace? Because if multiple CLRs could co-exist, an extension needing CLR 1.0 would link against that CLR, and another could link against CLR 2.0. That doesn&#8217;t sound hard: if an managed app wants symbols from CLR 1.0, in the compiler simply prefix every symbol with <strong>CLR10</strong>. If from 1.1, <strong>CLR11</strong>.
</p></blockquote>
<p>The CLR is not a library that is linked to an executable; it is a runtime. &nbsp;On newer versions of Windows, a flag in the managed .exe header instructs the OS loader to launch and initialize the CLR, which then loads and executes the managed code from the .exe. &nbsp;(On older versions of Windows, a native-code shim in the .exe&#8217;s entry point launches the CLR instead.)</p>
<p>Because it is a full runtime, which manages detailed characteristics of the low-level process environment, it is not possible for it to play well with any other code that wishes to do the same thing. &nbsp;Consider the Garbage Collector, which needs to understand memory usage in the process, in order to correctly self-tune. &nbsp;Two such GCs would end up fighting each other, much as two processes that try to efficiently use all available RAM on a server would behave. &nbsp;(There&#8217;s an old blog post somewhere about, IIRC, IIS and SQL Server that describes a similar case.)</p>
<p>Or for something more high-level, consider the WinForms part of the Framework. &nbsp;Naturally it requires a message loop for a managed thread, and there can be only one main message loop (broadcasts, non-window messages, etc). &nbsp;How are WinForms 1.x and 2.x supposed to both have a main message loop at the same time on the same thread?</p>
<p>So it&#8217;s not just a simple symbol naming issue :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-455073">
				<div id="div-comment-455073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455073">
			December 20, 2006 at 12:15 am</a>		</div>

		<p>RandomReader, here&#8217;s what I said &quot;Of course you could just put the class in a namespace (like you should have done in the first place) and recompile, but your customers can&#8217;t recompile.&quot;</p>
<p>The CLR will only know that your main assembly is asking for a class called &quot;FtpRequest&quot;. Since this putative app is not directly referencing Foo.FtpRequest, the CLR will look for FtpRequest and its own version first.</p>
<p>Like I said, there are trivial steps to take ahead of time (strong names, namespaces, etc.). If you didn&#8217;t do this when compiling your apps the first time, though, you&#8217;re in trouble if your client only has the old version of the app and the new version of the CLR.</p>
<p>In the case of a shell extension, you don&#8217;t get to choose which version of the CLR to load, the app or the first managed shell extension does. The only way to guarantee it working in this case is to send out a recompiled version using properly bound names.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-455083">
				<div id="div-comment-455083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Stewien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455083">
			December 20, 2006 at 12:56 am</a>		</div>

		<p>Gabe,</p>
<p>shouldn&#8217;t people be using signed assemblies on released products, and thus not have this problem?</p>
<p>Also isn&#8217;t the take home message of all this &quot;Don&#8217;t use managed code in shell extensions&quot;? Managed code should just be used for fancy GUI stuff and web apps surely. Is C/C++ really that hard? It&#8217;s all I used up until 5 years ago.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-455123">
				<div id="div-comment-455123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455123">
			December 20, 2006 at 3:26 am</a>		</div>

		<p>Gabe,</p>
<blockquote><p>
  &gt; The CLR will only know that your main assembly is asking for a class called &quot;FtpRequest&quot;. Since this putative app is not directly referencing Foo.FtpRequest, the CLR will look for FtpRequest and its own version first.
</p></blockquote>
<p>That&#8217;s what I&#8217;m saying is incorrect: if your app&#8217;s assembly name is Foo (normally filenamed Foo.exe as well, but that isn&#8217;t relevant), all references to FtpRequest will in fact be to FtpRequest <em>in assembly Foo</em>.</p>
<p>Explicit namespaces are necessary for organizational reasons, but not for type resolution.</p>
<p>This is the same concept as for native executables: the PE import table references a specific DLL, not just a symbol from anywhere at random.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-455003">
				<div id="div-comment-455003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.asvguy.com' rel='external nofollow' class='url'>Burak KALAYCI</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455003">
			December 19, 2006 at 8:05 pm</a>		</div>

		<p>&gt; How did you choose not to write apps in .NET in 1990?</p>
<p>I will give a short answer as this is quite off topic.</p>
<p>At the time, there was gwbasic (interpretted and managed) and Assembly option (with Debug for .COM files), both came free with DOS, on my 12MHz 286 with 1MB ram and 40MB harddisk.</p>
<p>I simply realized that for my programming pleasure, *I* had to &#8216;manage&#8217; all aspects of what I write as much as possible. It&#8217;s like manual transmisson vs. automatic transmission preference (in cars)&#8230;</p>
<p>Best regards,</p>
<p>Burak</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-455223">
				<div id="div-comment-455223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://esmithy.net' rel='external nofollow' class='url'>Eric Smith</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455223">
			December 20, 2006 at 12:15 pm</a>		</div>

		<p>What about Office add-ins?</p>
<p>I&#8217;m having trouble reconciling the discussion here with the apparent encouragement to write managed add-ins for Office represented by the existence of VSTO. Doesn&#8217;t the same problem exist there (although without the file dialog issue)? Is VSTO only practical in completely controlled environments where all add-ins are guaranteed to use the same CLR?</p>
<p>Sorry, I know this is straying off-topic for Raymond&#8217;s expertise; you&#8217;ve got a knowledgable community here, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-455353">
				<div id="div-comment-455353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455353">
			December 20, 2006 at 5:37 pm</a>		</div>

		<p>Eric: Office add-ins are a little different. The problem with explorer extensions is that your extension gets injected into every other process that tries to open a file-open dialog (or other things). Office add-ins are only run in the Office executable (well, usually &#8211; I&#8217;m not sure what happens with OLE in this case).</p>
<p>When you call a CCW (that is, a .NET object implementing a COM interface) from a native application, the infrastructure (by default) loads the most recent version of framework that&#8217;s installed. So Office will typically be running .NET 2.0. This is not a problem for most .NET 1.1 add-ins, which will mostly run quite happily under .NET 2.0.</p>
<p>With explorer, it doesn&#8217;t always work like that. If you have a process that has ALREADY loaded the 1.1 framework, then it tries to open a file-open dialog and load your .NET 2.0 extension&#8230; bang!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kjkhyperion even thread-even depth-1" id="comment-455473">
				<div id="div-comment-455473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455473">
			December 21, 2006 at 7:02 am</a>		</div>

		<p>Eric, Dean: Office components always run out-of-process when started through COM, so it&#8217;s not an issue in that case</p>
<p>Daniel, Cooney: I&#8217;m always surprised at the lengths people will go to try and contradict Microsoft&#8217;s design choices, often apparently for the heck of it. The &quot;try to fix this Windows bug&quot; challenge was especially eye-opening</p>
<p>To everyone else: don&#8217;t mix .NET and native code, it&#8217;s a terrible practice. Do it only if forced to do so, but don&#8217;t incorporate it in an architecture developed from scratch</p>
<p>It&#8217;s inefficient and terribly embarassing to the runtime, which never has the slightest idea how to handle native calls &#8211; will it corrupt the managed heap? will it close one of my internal handles? will it violate security policies? etc. Internal framework functions are not P/Invoke, for a good reason &#8211; their C++ implementations are so filled with static code checking annotations (pssst, .NET sources are public) as to virtually offer the same guarantees as managed code</p>
<p>Nevertheless, if you absolutely have to, make it so managed calls native and not the other way around. Native code rarely owns a whole process (notable exceptions are DBMSs, in fact .NET 2.0 was specifically tuned to be hosted by SQL Server) the way a runtime does, so despite the huge inefficiency it&#8217;s not quite as dramatic as pulling the runtime in a random process</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-455583">
				<div id="div-comment-455583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455583">
			December 21, 2006 at 12:28 pm</a>		</div>

		<blockquote><p>
  To everyone else: don&#8217;t mix .NET and native code, it&#8217;s a terrible practice
</p></blockquote>
<p>I thought it just works.</p>
<blockquote><p>
  Native code rarely owns a whole process
</p></blockquote>
<p>Really? I wonder what all these exe&#8217;s I&#8217;ve been writing for years are.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-455713">
				<div id="div-comment-455713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-455713">
			December 22, 2006 at 12:20 am</a>		</div>

		<blockquote><p>
  Office components always run out-of-process when started through COM, so it&#8217;s not an issue in that case.
</p></blockquote>
<p>Are you sure about that? I use both Lookout and Newgator in Outlook, both of which are .NET add-ins and both of which run in-process. Perhaps they don&#8217;t use VSTO, though&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-466193">
				<div id="div-comment-466193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/benkaras/archive/2007/01/29/property-handler-decisions-and-preparation.aspx' rel='external nofollow' class='url'>The Great Flying Tortoise</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061218-01/?p=28693#comment-466193">
			January 30, 2007 at 1:47 am</a>		</div>

		<p>Viewed as a data flow component, a property handler has a single file stream input and outputs a one</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

