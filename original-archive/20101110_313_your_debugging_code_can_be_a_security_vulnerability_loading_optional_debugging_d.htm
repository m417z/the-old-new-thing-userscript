<html>
<head>
<title>Your debugging code can be a security vulnerability: Loading optional debugging DLLs without a full path</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Your debugging code can be a security vulnerability: Loading optional debugging DLLs without a full path</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 10, 2010 / year-entry #314</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>49</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Remember, the bad guys don't care that your feature exists just for debugging purposes. If it's there, they will attack it. Consider the following code: DOCLOADINGPROC g_pfnOnDocLoading; void LoadDebuggingHooks() { HMODULE hmodDebug = LoadLibrary(TEXT("DebugHooks.dll")); if (!hmodDebug) return; g_pfnOnDocLoading = (DOCLOADINGPROC) GetProcAddress(hmodDebug, "OnDocLoading"); ... } HRESULT LoadDocument(...) { ... if (g_pfnOnDocLoading) { // let the debugging...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Remember, the bad guys don't care that your feature exists
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2005/12/12/502719.aspx">
just for debugging purposes</a>.
If it's there, they will attack it.
</p>
<p>
Consider the following code:
</p>
<pre>
DOCLOADINGPROC g_pfnOnDocLoading;

void LoadDebuggingHooks()
{
 HMODULE hmodDebug = LoadLibrary(TEXT("DebugHooks.dll"));
 if (!hmodDebug) return;
 g_pfnOnDocLoading = (DOCLOADINGPROC)
               GetProcAddress(hmodDebug, "OnDocLoading");
 ...
}

HRESULT LoadDocument(...)
{
 ...
 if (g_pfnOnDocLoading) {
   // let the debugging hook replace the stream
   g_pfnOnDocLoading(&amp;pstmDoc);
 }
 ...
}
</pre>
<p>
When you need to debug the program, you can install the
<code>DebugHooks.dll</code> DLL into the application directory.
The code above looks for that DLL and if present, gets
some function pointers from it.
For illustrative purposes, I've included one debugging hook.
The idea of this example
(and it's just an example,
so let's not argue about whether it's a good example)
is that when we're about to load a document,
we call the <code>OnDocLoading</code> function,
telling it about the document that was just loaded.
The <code>OnDocLoading</code> function
wraps the <code>IStream</code> inside another object
so that the contents of the document can be logged
byte-by-byte as it is loaded, in
an attempt to narrow down exactly where document loading fails.
Or it can be used for testing purposes to inject I/O errors
into the document loading path to confirm that the program
behaves properly under those conditions.
Use your imagination.
</p>
<p>
But this debugging code is also a security vulnerability.
</p>
<p>
Recall that the library search path searches directories
in the following order:
</p>
<ol>
<li>The directory containing the application EXE.
</li>
<li>The system32 directory.
</li>
<li>The system directory.
</li>
<li>The Windows directory.
</li>
<li>The current directory.
</li>
<li>The PATH.
</li>
</ol>
<p>
When debugging your program, you install <code>DebugHooks.dll</code>
into the application directory so that it is found in step&nbsp;1.
But when your program isn't being debugged,
the search in step&nbsp;1 fails,
and the search continues in the other directories.
The DLL is not found in steps 2&nbsp;through&nbsp;4,
and then we reach step&nbsp;5: The current directory.
</p>
<p>
And now you're pwned.
</p>
<p>
Your application typically does not have direct control over
the current directory.
The user can run your program from any directory,
and that directory ends up as your current directory.
And then your <code>LoadLibrary</code> call searches
the current directory,
and if a bad guy put a rogue DLL in the current directory,
your program just becames the victim of code injection.
</p>
<p>
This is made particularly dangerous when your application
is associated with a file type,
because the user can run your application just by
double-clicking an associated document.
</p>
<p>
When you double-click a document, Explorer sets the
current directory of the document handler application
to the directory that contains the document being opened.
This is necessary for applications which look around
in the current directory for supporting files.
For example,
consider
a hypothetical application <code>LitWare Writer</code>
associated with <code>*.LIT</code> files.
A LitWare Writer document
<code>ABC.LIT</code> file is really just the representative
for a family of files,
<code>ABC.LIT</code> (the main document),
<code>ABC.LTC</code> (the document index and table of contents),
<code>ABC.LDC</code> (the custom spell check dictionary for the document),
<code>ABC.LLT</code> (the custom document layout template),
and so on.
When you open the document <code>C:\PROPOSAL\ABC.LIT</code>,
LitWare Writer looks for the other parts of your document
in the current directory,
rather than in <code>C:\PROPOSAL</code>.
To help these applications find their files,
Explorer specifies to the <code>CreateProcess</code> function
that it should set the initial current directory of
LitWare Writer to <code>C:\PROPOSAL</code>.
</p>
<p>
Now, you might argue that programs like LitWare Writer
(which look for the ancillary files of a multi-file document
in the current directory instead of the directory containing
the primary file of the multi-file document) are
poorly-written, and I would agree with you,
but Windows needs to work even with poorly-written programs.
(<b>Pre-emptive snarky comment</b>: Windows is itself
a poorly-written program.)
There are a lot of poorly-written programs out there,
some of them industry leaders in their market (<b>see above
pre-emptive snarky comment</b>)
and if Windows stopped accommodating them, people would
say it was the fault of Windows and not the programs.
</p>
<p>
I can even see in my mind's eye the bug report that resulted
in this behavior being added to the MS-DOS Executive:
</p>
<p>
"This program has worked just fine in MS-DOS,
but in Windows, it doesn't work.
Stupid Windows."
</p>
<p>
Customers tend not to be happy with the reply,
"Actually, that program has simply been lucky for the past X years.
The authors of the program never considered the case where
the document being opened is not in the current directory.
And it got away with it, because the way you opened the document
was to use the <code>chdir</code> command to move to the directory
that contained your document,
and then to type
<code>LWW ABC.LIT</code>.
If you had ever done
<code>LWW C:\PROPOSAL\ABC.LIT</code> you would have run into the
same problem.
The behavior is by design."
</p>
<p>
In response to "The behavior is by design" is usually
"Well, a design that prevents me from getting my work done is
a crappy design."
or a much terser "No it's not, it's a bug."
(Don't believe me? Just read Slashdot.)
</p>
<p>
So to make these programs work in spite of themselves,
the MS-DOS Executive sets the current directory of the program
being launched to the directory containing the document itself.
This was not an unreasonable decision because it gets the program
working again, and it's not like the program cared about the
current directory it inherited from the MS-DOS Executive,
since it had no control over that either!
</p>
<p>
But it means that if you launched a program by double-clicking
an associated document, then unless that program takes steps to
change its current directory, it will have the document's containing
folder as its current directory, which prevents you from deleting
that directory.
</p>
<p>
<b>Bonus chatter</b>:
I wrote this series of entries nearly two years ago,
and even then,
I didn't consider this to be anything particularly groundbreaking,
but apparently some people rediscovered it a few months ago
and are falling all over themselves to claim credit
for having found it first.
It's like a new generations of teenagers who think they invented sex.
For the record, here is some
<a HREF="http://support.microsoft.com/kb/2389418">
official guidance</a>.
(And just to be clear,
that's official guidance on the current directory attack,
not
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2006/10/26/875991.aspx">
official guidance on sex</a>.)
</p>
<p>
<b>History chatter</b>:
Why is the current directory even considered at all?
The answer goes back to CP/M.
In CP/M, there was no PATH.
Everything executed from the current directory.
The rest is a chain of backward compatibility.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (49)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-872973">
				<div id="div-comment-872973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-872973">
			November 10, 2010 at 7:26 am</a>		</div>

		<p>The problem with that position is that there is no incentive for developers to improve; if Windows continues to support bad programs then people will continue to write bad programs.</p>
<div class="post">[<i>I think you&#39;ve lost sight of the goal. Customers want Windows to support bad programs. The goal of Windows is to solve customer problems, not to create a beautiful research project. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-872983">
				<div id="div-comment-872983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-872983">
			November 10, 2010 at 7:35 am</a>		</div>

		<p>I&#39;m guessing that CP/M didn&#39;t have .DLLs. So not searching the current directory for DLLs would not have broken anything when DLLs were introduced.</p>
<p>Further, when PATH were first introduced, back-compat could have been done so that if there were no PATH then an implicit PATH is used which contains the current directory. However, if PATH existed then the current directory would not be searched unless PATH explicitly contained &quot;.&quot;. To explicitly set no PATH, PATH could have been set to the empty string, or a single separator if DOS could not distinguish between an unset and a set-but-empty environment variable.</p>
<p>If only I had a time machine&#8230; :-)</p>
<div class="post">[<i>CP/M had DLLs (called &quot;overlays&quot;). How short our memories have become. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-872993">
				<div id="div-comment-872993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-872993">
			November 10, 2010 at 7:37 am</a>		</div>

		<p>&quot;In the following code example, the library is loaded directly by using a fully qualified path. There is no risk of the attacker introducing malicious code unless he already has write permissions to the application&rsquo;s target directory.</p>
<p>HMODULE handle = LoadLibrary(&quot;c:\windows\system32\schannel.dll&quot;);&quot;</p>
<p>Wow, this looks like fun. &nbsp;What happens if the user is using a version of Windows that is installed into C:WINNT, or even D:Windows? &nbsp;There is no guarantee a C: drive even exists. &nbsp;Once I installed XP and it somehow decided the system drive should be drive E:. &nbsp;Never quite figured out what caused that to happen.</p>
<p>It would seem to me you should use the Windows APIs to get the location of the windows or system32 directory first.</p>
<p>The other solutions suggested seem far more reasonable&#8230;</p>
<p>LoadLibrary with just the dll name is probably OK as long as you take the CWD out of the equation. &nbsp;There are legitimate (well, depending on who you ask I guess) reasons for wanting to trick an app into loading another DLL, for example wrapping nonexistent functionality to get a legacy app working on a modern OS, or extending an old program to teach it new tricks&#8230; friend of mine is working on a wrapper to get an old DX5 game running with DX9 to let him hack in all sorts of new stuff&#8230; like mousewheel support! &nbsp;Or getting Vista/DX10 games running on XP/DX9 (surprisingly well, even), but I won&#39;t name specific names.</p>
<div class="post">[<i>The full path in the LoadLibrary was clearly for illustration purposes. Does MSDN now need a nitpicker&#39;s corner? (How does one tell whether an attempt to trick an app into loading another DLL is &quot;legitimate&quot; or &quot;a security vulnerability&quot;?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873003">
				<div id="div-comment-873003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873003">
			November 10, 2010 at 7:37 am</a>		</div>

		<p>Best is to disable the current directory as DLL search path in any case, anyway.</p>
<div class="post">[<i><a href="http://msdn.microsoft.com/en-us/library/ms686203(VS.85).aspx" rel="nofollow">Feel free to do that</a> in your programs. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873013">
				<div id="div-comment-873013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tommy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873013">
			November 10, 2010 at 7:47 am</a>		</div>

		<p>Which DOS program used LoadLibrary?</p>
<p>Because if none did, you could make load library not search the current directory by default, which would have solved this issue.</p>
<div class="post">[<i>Many DOS programs loaded libraries, but they weren&#39;t called DLLs. They were usually called OVL. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873023">
				<div id="div-comment-873023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henke37</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873023">
			November 10, 2010 at 7:54 am</a>		</div>

		<p>I am sure some dos program out there where doing their own loadable library system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873033">
				<div id="div-comment-873033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873033">
			November 10, 2010 at 8:02 am</a>		</div>

		<p>@John: How so? I don&#39;t think anyone actively sets out to write bad programs, it&#39;s more that they (we) are &nbsp;not aware of doing so as long as it works with the targeted Windows version(s). And when a new Windows version comes along to possibly break those bad programs, the original programmers might be long gone and can remain happily oblivious.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873043">
				<div id="div-comment-873043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873043">
			November 10, 2010 at 8:06 am</a>		</div>

		<p>@Tommy</p>
<p>Back in the good-old days of DOS, we only had 640K and liked it! &nbsp;That being said, some applications were too large to fit into even that amount of memory. &nbsp;The solution was something Raymond hinted to &#8212; overlays. &nbsp;The idea was that a small portion of your program resided at a specific (often low) address in memory, and it was responsible for swapping in the code from an overlay for the function or mode in which the program was to operate. &nbsp;The manager could swap between the overlays as necessary, even going back to ones it had loaded previously. &nbsp;Naturally, dealing with global and heap-allocated data was a bit tricky since the code you were loading didn&#39;t have any clue as to when or who allocated the memory, but that could easily be solved by storing pointers at well-known addresses, probably in the manager&#39;s address space.</p>
<p>If memory serves, overlays were supported by DOS directly, so there wasn&#39;t anything special that applications had to do to get that support.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873053">
				<div id="div-comment-873053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Louis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873053">
			November 10, 2010 at 8:30 am</a>		</div>

		<p>@John: Incentive to improve must come from within. If Windows does not support the bad behavior, then &quot;It&#39;s Windows&#39; fault that my application doesn&#39;t run.&quot; It Windows does support the bad behavior, then &quot;Windows is responsible for bad code.&quot; Either way, people will blame Windows rather than taking responsibility for themselves.</p>
<p>This phenomenon is not limited to Windows or even computers. I have worked as a Mathematics tutor for over 15 years. Students don&#39;t want understanding, they want homework answers. And then, when they fail on the test because they never learned the concept to begin with, it&#39;s either the tutor&#39;s or instructor&#39;s fault. I laugh every time I hear, &quot;My instructor didn&#39;t explain this.&quot; Really? What did he or she talk about for 1 &#8211; 1.5 hours? At the end of every semester, you&#39;ll hear students make one of two statements: &quot;I got an A,&quot; or, &quot;My instructor gave me an F.&quot;</p>
<p>Ultimately, the issue is less about code, and more about responsibility to do the right thing and own up when you don&#39;t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873063">
				<div id="div-comment-873063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873063">
			November 10, 2010 at 8:47 am</a>		</div>

		<p>@NB: I was not referring to individual developers; I was referring to developers in general. &nbsp;If Windows X and Windows X + 1 both allow the same bad behavior then new programs will continue to be written badly for Windows X + 1. &nbsp;If you break that bad behavior in Windows X + 1 then, going forward, new programs will be written not quite so badly.</p>
<p>I understand there is only so much you can do to prevent bad programs from being written, and there are valid compatibility concerns, but if you continue to allow something to happen then don&#39;t complain when it happens.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-873073">
				<div id="div-comment-873073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873073">
			November 10, 2010 at 8:55 am</a>		</div>

		<p>This has been discussed on Ars Technica:</p>
<p><a target="_new" href="http://arstechnica.com/microsoft/news/2010/08/new-windows-dll-security-flaw-everything-old-is-new-again.ars" rel="nofollow">arstechnica.com/&#8230;/new-windows-dll-security-flaw-everything-old-is-new-again.ars</a></p>
<div class="post">[<i>They also get it wrong, claiming that the current directory is searched ahead of system32 by default. (Thank you, Yuhong for once again stating something that I tried to preempt in the bonus chatter.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873083">
				<div id="div-comment-873083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873083">
			November 10, 2010 at 9:14 am</a>		</div>

		<p>[I think you&#39;ve lost sight of the goal. Customers want Windows to support bad programs. The goal of Windows is to solve customer problems, not to create a beautiful research project. -Raymond]</p>
<p>Customers want a lot of things, some of which occasionally conflict with each other. &nbsp;UAC broke a lot of bad programs, but it still shipped.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873093">
				<div id="div-comment-873093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Some guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873093">
			November 10, 2010 at 9:43 am</a>		</div>

		<p>[Giving it another try. Sorry if this shows up multiple times.]</p>
<p>With so many people complaining that using PATH and the CWD to search for libraries is &quot;obviously stupid&quot;, I&#39;m still wondering why&#8230;</p>
<p>Isn&#39;t this a case of being &quot;on the other side of the air tight hatchway&quot; if you can already plant DLLs?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873103">
				<div id="div-comment-873103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kelden</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873103">
			November 10, 2010 at 9:50 am</a>		</div>

		<p>I don&#39;t understand why you have done it in this way. Why not a new checkbox in the compatibility tab &quot;Set current working &#8230; (security risk!)&quot;.</p>
<p>Most programs would get patched and if not, you can still run it.</p>
<p>So no developer gets a feedback that something is broken.</p>
<div class="post">[<i>I&#39;m not sure about the &quot;most programs would get patched.&quot; Most programs are not written by large organizations with well-defined software update policies. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-leo-davidson even thread-even depth-1" id="comment-873113">
				<div id="div-comment-873113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Leo+Davidson' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873113">
			November 10, 2010 at 9:52 am</a>		</div>

		<p>I&#39;d be interested to know how many programs intentionally look in the current dir (rather than the program dir etc.) for DLLs. I&#39;m sure there are some like the hypothetical LitWare but surely only a handful. Maybe I&#39;m wrong. I have never seen the metrics if they exist.</p>
<p>I&#39;ve had the registry flag set to remove the CD from the DLL search path system-wide for ages now and, to my knowledge, nothing at all has stopped working. Of course, that&#39;s just my machine, I avoid running junk on it, and maybe stuff has broken that I just haven&#39;t attributed to it.</p>
<p>I call SetDllDirectory in my exes, too, but there&#39;s nothing to stop some DLL I load messing that up, and some people actually cannot call SetDllDirectory in time. (e.g. I&#39;ve heard the start-up code for some MFC versions attempts to LoadLibrary(DWM.DLL) before it hands control to the main code. Fine on Vista/7 but bad on XP.)</p>
<p>As a developer I can&#39;t think of any real situations where I&#39;d want to search the CD. My guess is that so few programs need it that it could have been handled more like DEP is, rather than leaving a known, gaping security hole open by default. (And certainly, given how long the problem has been known, the defaults could have been changed for x64.)</p>
<p>Presumably the compatibility stuff in Windows could detect a LoadLibrary call in a situation where it actually would pick up a DLL from the CD and flag that, much like if you turn DEP on and something is terminated because of it you are told what happened.</p>
<div class="post">[<i>I don&#39;t have numbers, but I do know that one major enterprise system (think something as big and important as say SQL Server) relied on LoadLibrary loading from the current directory. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-leo-davidson odd alt thread-odd thread-alt depth-1" id="comment-873123">
				<div id="div-comment-873123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Leo+Davidson' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873123">
			November 10, 2010 at 10:01 am</a>		</div>

		<p>@Some guy:</p>
<p>&lt;&lt; Isn&#39;t this a case of being &quot;on the other side of the air tight hatchway&quot; if you can already plant DLLs? &gt;&gt;</p>
<p>Consider these scenarios:</p>
<p>1) You go into a directory full of JPEGs and double-click one. It&#39;s a network dir or just one on your computer that other users have write access to.</p>
<p>2) You download a big zip full of JPEGs, extract it, then double-click one of the images.</p>
<p>In both you run the risk of running arbitrary code out of those directories. To avoid it you have to check that there are no DLLs in the folder and be sure that nobody else can modify the folder after you&#39;ve done that check.</p>
<p>People aren&#39;t used to doing that kind of check, even in situations where it&#39;s possible. It should be safe to load a data file out of a directory, but it&#39;s not.</p>
<p>The issue is almost as dangerous as a buffer-overflow bug since it turns what looks like data into a code-execution risk. (In some ways it&#39;s more dangerous because it&#39;s a lot easier to trigger reliably; OTOH, it&#39;s also easier to notice.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873133">
				<div id="div-comment-873133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873133">
			November 10, 2010 at 10:27 am</a>		</div>

		<p>John: If you break that bad behavior in Windows X + 1 then, going forward, users will stay on Windows X. In fact, Windows is now up to X + 2 and yet most people are still on Windows X!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873143">
				<div id="div-comment-873143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Koro</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873143">
			November 10, 2010 at 10:28 am</a>		</div>

		<p>For system DLLs which are on the KnownDLLs list, I think all this &quot;look up&quot; is avoided and a named section object is directly opened and mapped, so it should be safe to refer to system DLLs by name only.</p>
<p>Although, I will start calling SetDllDirectory in my future programs, and I would like to know more about the registry switch to enable it system-wide.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873153">
				<div id="div-comment-873153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ThermoNuke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873153">
			November 10, 2010 at 10:37 am</a>		</div>

		<p>I find it interesting that Raymond promotes the snarky comments from obscure comments from people I can easily dismiss as trolls to a prominent place where I can&#39;t help but see them.</p>
<p>Please, ignore the trolls. Much less stressful for you and less stressful for me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873173">
				<div id="div-comment-873173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">oldami</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873173">
			November 10, 2010 at 11:20 am</a>		</div>

		<p>WTF? &nbsp;If a bad person can install a DLL (or any executable) on your computer, then you are already screwed.</p>
<p>See #1, 2 and 3 in &quot;10 Immutable Laws of Security&quot;</p>
<p><a rel="nofollow" target="_new" href="http://technet.microsoft.com/en-us/library/cc722487.aspx" rel="nofollow">technet.microsoft.com/&#8230;/cc722487.aspx</a></p>
<p>Sure, it is a good idea to avoid this risk, but it seems to be a minor one to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873183">
				<div id="div-comment-873183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873183">
			November 10, 2010 at 11:29 am</a>		</div>

		<p>@Some Guy: &quot;Isn&#39;t this a case of being &quot;on the other side of the air tight hatchway&quot; if you can already plant DLLs?&quot;</p>
<p>Many years ago, this vulnerability is what caused me to stop using Eudora as my email client. &nbsp;Eudora&#39;s attachment handling behaviour was to scan all incoming messages for attachments and decode them into a specific directory, then stick a reference in the email to the file in that directory so you could click it to open the file. &nbsp;At some point, somebody noticed that that leaves you open to this problem. &nbsp;They figured out the name of a DLL that MS Word would load from the current directory, and started sending out emails that contained both word docs and a dll of the correct name. &nbsp;If you clicked the word doc (or, indeed, any word doc in any email you had been sent), the DLL was loaded and code from it executed.</p>
<p>So, no, this isn&#39;t really a theoretical problem. &nbsp;It is (or, at least, has been in the past) a real security issue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873193">
				<div id="div-comment-873193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873193">
			November 10, 2010 at 11:35 am</a>		</div>

		<p>@oldami: &quot;If a bad person can install a DLL (or any executable) on your computer, then you are already screwed. See #1, 2 and 3 in &quot;10 Immutable Laws of Security&quot;&quot;</p>
<p>I see them, and don&#39;t see how they apply.</p>
<p>&quot;Law #1: If a bad guy can persuade you to run his program on your computer, it&#39;s not your computer anymore&quot;</p>
<p>You don&#39;t have to run a program to install a DLL. &nbsp;A DLL is just a file, and there are plenty of ways it can get onto the target system without you running a program first. &nbsp;E.g. leave it on a flash drive and drop it outside the target&#39;s house.</p>
<p>&quot;Law #2: If a bad guy can alter the operating system on your computer, it&#39;s not your computer anymore &quot;</p>
<p>See response to #1. &nbsp;You don&#39;t have to alter the operating system to put a DLL file on somebody&#39;s computer. &nbsp;</p>
<p>&quot;Law #3: If a bad guy has unrestricted physical access to your computer, it&#39;s not your computer anymore&quot;</p>
<p>See response to #1. &nbsp;You don&#39;t need physical access to get files onto somebody&#39;s computer. There are many quite obvious ways of achieving this that can be performed remotely, often using quite simple social engineering techniques, not to mention design flaws in other programs (see my comments re Eudora above).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-leo-davidson even thread-even depth-1" id="comment-873203">
				<div id="div-comment-873203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Leo+Davidson' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873203">
			November 10, 2010 at 12:09 pm</a>		</div>

		<p>[I don&#39;t have numbers, but I do know that one major enterprise system (think something as big and important as say SQL Server) relied on LoadLibrary loading from the current directory. -Raymond]</p>
<p>I figure things like that (large, well-known products) could&#39;ve been handled by compatibility shims, assuming (perhaps incorrectly) there are only a handful of apps that need them.</p>
<p>I imagine there&#39;s a fear that changing the default behaviour might break unknown, possibly internal apps that people rely on. But it seems like there wouldn&#39;t be many of them, and a system that alerted the user (or an admin) if an app appeared to try &amp; fail to get a DLL from the CD would let people pick those up in testing and apply an app-compat policy to them.</p>
<p>Perhaps this problem is more widespread than I think, though.</p>
<div class="post">[<i>It&#39;s a tip-of-the-iceberg problem. If a high-profile app gets it wrong, then there&#39;s no hope for the apps that fly below the radar. And you don&#39;t make friends in IT admin circles by making them re-test <a href="http://blogs.msdn.com/b/oldnewthing/archive/2006/11/06/999999.aspx" rel="nofollow">9000 internal applications</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873223">
				<div id="div-comment-873223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873223">
			November 10, 2010 at 12:42 pm</a>		</div>

		<p>@oldami:</p>
<p>WEBDAV files is the problem. An application opens a file from WEBDAV (as a result of a link click), and the current directory is set to that path.</p>
<div class="post">[<i>More generally, network file systems, of which WEBDAV is just one. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-873233">
				<div id="div-comment-873233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873233">
			November 10, 2010 at 12:54 pm</a>		</div>

		<p>Chris: Best is to disable the current directory as DLL search path in any case, anyway.</p>
<p>[&lt;a href=&quot; link to SetDllDirectory &quot;&gt;Feel free to do that&lt;/a&gt; in your programs. -Raymond]</p>
<p>I don&#39;t see how SetDllDirectory helps. &nbsp;From the link:</p>
<p>After calling SetDllDirectory, the DLL search path is:</p>
<p>1.The directory from which the application loaded.</p>
<p>2.The directory specified by the lpPathName parameter. &lt;&#8211; this is the new one</p>
<p>3.The system directory. Use the GetSystemDirectory function to get the path of this directory. The name of this directory is System32.</p>
<p>4.The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</p>
<p>5.The Windows directory. Use the GetWindowsDirectory function to get the path of this directory.</p>
<p>6.The directories that are listed in the PATH environment variable. &lt;&#8211; this is still here</p>
<div class="post">[<i>But &quot;the current directory&quot; is not, and that was Chris&#39;s recommendation. This game of &quot;gotcha&quot; is tiring. A: &quot;You should do X.&quot; B: &quot;Feel free to use method M to do X.&quot; C: &quot;Gotcha! Method M doesn&#39;t do Y!&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-873243">
				<div id="div-comment-873243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873243">
			November 10, 2010 at 12:56 pm</a>		</div>

		<p>Oh, I see, PATH is trusted.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873253">
				<div id="div-comment-873253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873253">
			November 10, 2010 at 1:12 pm</a>		</div>

		<p>Jules: I remember that about Eudora. I experimented and discovered that Windows will refuse to load DLLs that it can&#39;t open for FILE_EXECUTE access, so I denied FILE_EXECUTE on all files contained in the attachments directory (I think I made a post about it on the Full Disclosure mailing list, but it wasn&#39;t that well received). It was inevitable I&#39;d be exposed to this issue, as I was working on ReactOS at the time, and our buggy incomplete msvcrt.dll had a bad habit of being in the wrong current directory and breaking applications (including our build system)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-873263">
				<div id="div-comment-873263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873263">
			November 10, 2010 at 1:26 pm</a>		</div>

		<p>[They also get it wrong, claiming that the current directory is searched ahead of system32 by default. (Thank you, Yuhong for once again stating something that I tried to preempt in the bonus chatter.) -Raymond]</p>
<p>Which was true before XP SP2.</p>
<div class="post">[<i>The article uses the present tense, not the past tense. Wait, why am I bothering to respond to you? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873283">
				<div id="div-comment-873283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873283">
			November 10, 2010 at 1:52 pm</a>		</div>

		<p>The interesting questions is why SafeDllSearchMode just moved the currentdirectory in the search order instead of removing it.</p>
<div class="post">[<i>Because removing it would have broken even more programs. Recall that the flag was added in a service pack, so you don&#39;t have the multi-year compatibility pass that you do for a full product release. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873303">
				<div id="div-comment-873303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873303">
			November 10, 2010 at 2:22 pm</a>		</div>

		<p>[The goal of Windows is to solve customer problems, not to create a beautiful research project. -Raymond]</p>
<p>You know, I think that&#39;s .sig worthy. &nbsp;Way too many people (in companies and groups other than just Microsoft) forget it all too often.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873343">
				<div id="div-comment-873343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Semi Essessi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873343">
			November 10, 2010 at 4:38 pm</a>		</div>

		<p>I don&#39;t think its just a bad example &#8211; the entire premise here is bad.</p>
<p>Whatever happened to proper release builds? Sure you need to debug things away from the debugger, or without debug versions of things, or even in the customer&#39;s environment, but don&#39;t do it with the build you normally ship to your customer &#8211; use different builds &#8211; even if its just the same one with symbols so you can debug a crash dump or step though the code/disassembly. I tend to use a debug/release/final set of configs &#8211; the two provided by default in VS are just not enough for a really serious project.</p>
<p>Saying that though I&#39;m constantly amazed by how much of what I think of as VS project defaults and tend to scrap immediately as /my/ default behaviour are simply left in real world commercial projects. Like the debug/release configs, header/source filters and even the silly coding conventions from appwizard code etc. Its not like there is no tangible cost or quality benefits from doing these things properly&#8230; you spend less time struggling with those bugs that only reproduce without the debug heap, less time navigating the tree to open files, and good, consistent conventions make it much quicker to read, understand, debug and fix code, this quickly breaks even with the tiny time investment required to set these things up at the beginning&#8230;</p>
<p>I&#39;m surprised no one has made this point yet&#8230; the problem must be much worse than I think. Either that or I am totally ignorant of a large class of situations where you have no choice but to debug your app in this rather peculiar way&#8230; :I</p>
<p>Reading a lot of the misguided comments as well &#8211; don&#39;t forget, the intended user might also be the bad guy &#8211; that&#39;s a situation that its safest to assume is always going to be the case along with them having full admin rights, X spare machines and unlimited resources to perpetrate their attacks.</p>
<div class="post">[<i>There is the complementary principle &quot;test what you ship.&quot; If you do all your testing (e.g., failure injection) on the debug build and ship the release build, then you&#39;re not testing what you ship. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873353">
				<div id="div-comment-873353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873353">
			November 10, 2010 at 5:55 pm</a>		</div>

		<p>From what I can think of now, a game patch for &quot;a popular game that released 10+ years ago and have updated to 1.13 last year&quot; will attempt to load every single DLL be found in search path using DLL search rule. Many application that will load any plug-in exposing some particular function for somethin like &quot;components&quot; folder&#8230; These kinds of application will be vulunable to this kind of attack.</p>
<p>No wonder Windows Vista+ have to disable writes to &quot;Progam Files&quot; and it&#39;s subfolder by default.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873363">
				<div id="div-comment-873363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873363">
			November 10, 2010 at 6:10 pm</a>		</div>

		<p>Vista didn&#39;t disable writes to Progam Files. Vista redirects writes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873163">
				<div id="div-comment-873163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873163">
			November 10, 2010 at 10:53 am</a>		</div>

		<p>@Gabe: &nbsp;It is admittedly a trade-off, but if you never broke bad behavior then everyone would still be running Windows 95. &nbsp;Hell, some people probably are still running Windows 95. &nbsp;*shudder*</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873403">
				<div id="div-comment-873403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873403">
			November 10, 2010 at 10:25 pm</a>		</div>

		<p>Reading this post today has reminded me of some past horrors I&#39;ve seen myself.</p>
<p>These days I always recommend using some way to easily get the path to the applications install directory, Windows systen directory etc. Then make it well known that bad things reall can happen if you don&#39;t do this. Although I&#39;m still wondering how many people actually listened to me.</p>
<p>@Semi Essessi</p>
<p>Why scrap the debug build? In the end there are certain kinds of bugs which you can find easier with the debug build. But it seems you have the wrong impression of what the debug build is there for. The debug build is really there to help you find errors easier in your code, nothing more.</p>
<p>For me, during the development I do generally use the debug build in the very early stages. But when the program starts coming together I switch so that I use the release build with logging for the tests, only switching to the debug build to hunt more problematic bugs.</p>
<p>Doing the tests on the debug build can be daft because it is not what you ship, but also doing your debugging without the debug build is, in my opinion, just as daft because you lack one very powerful tool in tracking down errors.</p>
<p>Depending on various things, I end up with two to three builds.</p>
<p>Debug, which is unoptimised and has full logging on by default, but this is only used to hunt difficult to find bugs or pinpoint the location of a bug.</p>
<p>Release with full logging, which is what I do most of my testing and debugging with. Using the application logs to trace function calls to see what it actually does and check returns.</p>
<p>Release with minimal logging, which may also be release with full logging, but the logging being controled with a registry entry or command line option. This would be what would get the majority of the tests since this is the release code. Because most of the time I use only one release build then it is fairly easy to say to someone to turn on logging then do what they did again, then get them to send you the logs.</p>
<p>The debug build is one more tool in your toolbox, and not using it as much of a waste as a carpenter not using a hammer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873413">
				<div id="div-comment-873413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873413">
			November 10, 2010 at 11:43 pm</a>		</div>

		<p>Anyone asking for Microsoft to break compatibility once in a while to fix issues like this must have a short memory, because Microsoft did it. It was called Vista. And the XP-&gt;Vista transition was painful because a lot of things broke. About 2 years later, things settled down nicely and Vista works decently. But Windows 7 got released and it&#39;s getting all the good press that Vista really laid the foundations for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873323">
				<div id="div-comment-873323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">back2BASIC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873323">
			November 10, 2010 at 3:51 pm</a>		</div>

		<p>How many programs broke because of the directory search order change in xp sp2? That *creates* problems for customers.</p>
<p>&gt; When you double-click a document, Explorer sets the current directory of the document handler application to the directory that contains the document being opened</p>
<p>This is not true for unc paths. Apps are required to handle it anyway, therefore windows should never try to set it.</p>
<div class="post">[<i>Interesting principle. &quot;If doing X cannot be done 100% of the time, then it should be done 0% of the time.&quot; Suppose you have a program that requires the current directory to be equal to the document directory. It works for local files and not for UNC files. Is that better or worse than a program that doesn&#39;t work at all? (What if the company never uses it to open UNC files?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-873423">
				<div id="div-comment-873423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873423">
			November 11, 2010 at 1:13 am</a>		</div>

		<p>[The article uses the present tense, not the past tense.]</p>
<p>Sorry, didn&#39;t read carefully.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873433">
				<div id="div-comment-873433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873433">
			November 11, 2010 at 5:46 am</a>		</div>

		<p>When LoadLibrary was invented, there WERE programs loading overlays from the current directory. However, those programs didnt use LoadLibrary. So there was no backwards compatibility reason to make LoadLibrary search the current working directory by default.</p>
<div class="post">[<i>You have it backwards. LoadLibrary used function 4B, not vice versa. (In fact, in Windows 1.0, you didn&#39;t call LoadLibrary to load a DLL. You just used function 4B directly.) (It frightens me that I knew the opcode off the top of my head.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873443">
				<div id="div-comment-873443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter da Silva</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873443">
			November 11, 2010 at 6:37 am</a>		</div>

		<p>The way you do a transition like this is create a new call (eg &quot;LoadLibrary2(library, path_mask)&quot;) and mark the old API as legacy. Yes, sometimes this means you&#39;re still calling a system call &quot;lseek&quot; instead of &quot;seek&quot; 20 years after the last 16-bit computer was shipped, but so what? This isn&#39;t a user-visible interface.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873453">
				<div id="div-comment-873453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Korn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873453">
			November 11, 2010 at 6:48 am</a>		</div>

		<p>Just do something like this in the header file for your DLL:</p>
<p>#define OnDocLoading xdfh9083hfdjcn3op0rvqbvqorbv3rv</p>
<p>Good luck to any hacker trying to guess what that function does and implement it in their own DLL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873463">
				<div id="div-comment-873463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdbsd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873463">
			November 11, 2010 at 6:59 am</a>		</div>

		<p>@Dan Korn: This is called security through obscurity. And it&#39;s not so hard to guess what the function does, when you have it&#39;s source code right there, in assembler. PITA, yeah, but definitely possible.</p>
<div class="post">[<i>You don&#39;t even need that. Just write a DLL that does something evil in its DllMain. That&#39;s called as soon as the DLL is loaded. Sure, the GetProcAddress will fail, but by then it&#39;s too late. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873473">
				<div id="div-comment-873473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873473">
			November 11, 2010 at 7:07 am</a>		</div>

		<p>Good luck to any hacker trying to guess what that function does and implement it in their own DLL.</p>
<p>Why, it calls ShellExecute(&quot;cmd.exe /c rmdir /s /q C:&quot;), of course.</p>
<p>They don&#39;t <em>need</em> to know what it does. They can probably figure out from the disassembly around the call how to return a failure/void result, if they need your program to appear to keep running.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873533">
				<div id="div-comment-873533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TG</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873533">
			November 11, 2010 at 9:21 am</a>		</div>

		<p>If a program with this vulnerability is running with no extra privileges, and is the type of program for which it makes no sense to associate a file type; in other words, the sort of program that just gets run by double clicking it or its installed shortcuts, is there any way for this to be exploited?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-873553">
				<div id="div-comment-873553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873553">
			November 11, 2010 at 10:00 am</a>		</div>

		<p>Is it just me, or does the recommended use of Process Explorer in the official guidance KB article linked by Raymond not actually solve the problem? &nbsp;Only files that didn&#39;t exist on the system search path will create a request in the current directory, hence files that were found, this time on this particular computer, won&#39;t be flagged. &nbsp;But when you move to another Windows version, failed app install (or partial uninstall), etc., suddenly Windows goes looking in the current directory: security hole.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-873603">
				<div id="div-comment-873603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Semi Essessi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873603">
			November 11, 2010 at 10:22 am</a>		</div>

		<p>@ Crescens2k: I never said to scrap the debug build at all, or not to use it as a tool. Just don&#39;t ship it. I may have ranted slightly about the tendency for programmers to not think properly and just use what Visual Studio gives them out of the box&#8230; but I don&#39;t think I said to remove the debug build, just that having debug/release alone, as they are configured out of the box is often inadequate if you have a serious project.</p>
<p>@ Raymond re: &quot;test what you ship&quot; &#8211; that is a good doctrine, but what I describe doesn&#39;t prevent you from testing the build you will ship either&#8230; it just means that if a particularly difficult to diagnose problem comes is identified in a shipped build, then you can not use he Visual Studio debugger, debug symbols or debug specific code to diagnose and fix it, instead you use other builds as tools to diagnose and fix the problem. I guess there could be the scenario where it just won&#39;t recreate, but I&#39;ve been lucky enough to never hit it&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-873693">
				<div id="div-comment-873693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-873693">
			November 11, 2010 at 2:03 pm</a>		</div>

		<p>&quot;(In fact, in Windows 1.0, you didn&#39;t call LoadLibrary to load a DLL. You just used function 4B directly.)&quot;</p>
<p>And BTW DLLs had the EXE extension back then.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm odd alt thread-odd thread-alt depth-1" id="comment-874063">
				<div id="div-comment-874063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-874063">
			November 12, 2010 at 5:55 pm</a>		</div>

		<p>&quot;if a particularly difficult to diagnose problem comes is identified in a shipped build, then you can not use he Visual Studio debugger, debug symbols or debug specific code to diagnose and fix it&quot;</p>
<p>Debugging a problem in a shipped build does not prevent you from using the visual studio debugger or debug symbols. &nbsp;In fact, if you don&#39;t have debug symbols for your shipped builds, I&#39;d say you&#39;re doing it wrong. &nbsp;(Granted, the default for a retail build for years has been no symbols, so you have to change it yourself.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-874233">
				<div id="div-comment-874233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Wooding</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101110-00/?p=12313#comment-874233">
			November 15, 2010 at 5:33 am</a>		</div>

		<p>[Interesting principle. &quot;If doing X cannot be done 100% of the time, then it should be done 0% of the time.&quot; Suppose you have a program that requires the current directory to be equal to the document directory. It works for local files and not for UNC files. Is that better or worse than a program that doesn&#39;t work at all? (What if the company never uses it to open UNC files?) -Raymond]</p>
<p>Tricky. &nbsp;I&#39;d agree with the stated principle, though. &nbsp;Both 0% and 100% correspond to `predictable behaviour&#39;. &nbsp;Values in between mean that you don&#39;t know enough to reliably predict the behaviour: either there are additional variables which need to be considered, or it&#39;s just nondeterministic. &nbsp;The latter is obviously just awful; the former means that users have to extend their mental models to include the necessary additional variables, which isn&#39;t a disaster but doesn&#39;t lead anywhere good if you do it too often.</p>
<p>Addressing Raymond&#39;s question: Is it better that the programs fail only sometimes rather than reliably? &nbsp;If Program X never loads documents from a double click in an Explorer window , I suspect I&#39;ll learn quickly that I should start Program X from the Start menu and then Open my document from within Program X. &nbsp;If Program Y sometimes loads documents from a double-click and sometimes fails, then it might take me a while to sort out why. &nbsp;I might just decide that computers are weird and go do some mathematics instead&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

