<html>
<head>
<title>Wouldn't the Recycle Bin sample program have been simpler without COM?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Wouldn&#8217;t the Recycle Bin sample program have been simpler without COM?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 20, 2013 / year-entry #337</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>17</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Steve Wolf suggests that the sample program would have been much simpler had the shell extension model been a flat Win32 interface. Okay, let's try it. Since this is an extension model, each extension needs to specify the callbacks for each namespace operation. Perhaps it could have been done like this: HRESULT (CALLBACK *SHELLFOLDER_EXTENDHANDLER)( void...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Steve Wolf suggests that
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2011/08/31/10203215.aspx#10203669">
the sample program would have been much simpler had the shell
extension model been a flat Win32 interface</a>.
</p>
<p>
Okay, let's try it.
</p>
<p>
Since this is an extension model, each extension needs to specify
the callbacks for each namespace operation.
Perhaps it could have been done like this:
</p>
<pre>
HRESULT (CALLBACK *SHELLFOLDER_EXTENDHANDLER)(
    void *lpContext,
    OBJECTTYPE type, void **phObject);
HRESULT (CALLBACK *SHELLFOLDER_PARSEDISPLAYNAMEHANDLER)(
    void *lpContext,
    HWND hwnd, LPBINDCTX pbc, LPWSTR pszDisplayName,
    ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes);
HRESULT (CALLBACK *SHELLFOLDER_ENUMOBJECTSHANDLER)(
    void *lpContext,
    HWND hwnd, SHCONTF grfFlags, HENUMIDLIST *pheidl);
HRESULT (CALLBACK *SHELLFOLDER_BINDTOOBJECTHANDLER)(
    void *lpContext,
    PCUIDLIST_RELATIVE pidl, LPBINDCTX pbc,
    OBJECTTYPE type, void **phObject);
HRESULT (CALLBACK *SHELLFOLDER_BINDTOSTRAGEHANDLER)(
    void *lpContext,
    PCUIDLIST_RELATIVE pidl, LPBINDCTX pbc,
    OBJECTTYPE type, void **phObject);
HRESULT (CALLBACK *SHELLFOLDER_COMPAREIDSHANDLER)(
    void *lpContext,
    LPARAM lParam, PCUIDLIST_RELATIVE pidl1,
    PCUIDLIST_RELATIVE pidl2);
... (etc) ...

HFOLDER CreateShellFolderImplementation(
    SHELLFOLDER_EXTENDHANDLER pfnExtend,
    SHELLFOLDER_PARSEDISPLAYNAMEHANDLER pfnParseDisplayName,
    SHELLFOLDER_ENUMOBJECTSHANDLER pfnEnumObjects,
    SHELLFOLDER_BINDTOOBJECTHANDLER pfnBindToObject,
    SHELLFOLDER_BINDTOSTRAGEHANDLER pfnBindToStorage,
    SHELLFOLDER_COMPAREIDSHANDLER pfnCompareIDs,
    ... (etc) ...
    void *lpContext);
</pre>
<p>
This would be the function that allows a third party to create a
shell folder implementation.
You pass it a bunch of flat callback functions, one for each
operation that a shell folder supports,
so that when the application tries to perform that operation on your
custom folder, the operating system can ask your custom implementation
to do that thing.
</p>
<p>
If additional shell folder operations are added in the future,
the operating system needs to know how to ask your shell extension
whether it knows how to do  those extended things.
That's what the <code>Extend</code> method is for.
The operating system could ask to extend your object to one
that supports <code>HFOLDER2</code> operations.
</p>
<p>
Actually, if you look at it, these are exactly the same as
COM methods.
The first parameter says what object you are operating on
("<code>this</code>"),
and the rest are the parameters.
</p>
<p>
Okay, so I'm setting up a straw man that looks just like COM.
So let's do something that looks very different from COM.
We could use the window procedure paradigm:
</p>
<pre>
HRESULT (CALLBACK *SHELLFOLDER_INVOKE)(
    void *lpContext,
    FOLDERCOMMAND cmd, void *parameters);

HFOLDER CreateShellFolderImplementation(
    SHELLFOLDER_INVOKE pfnInvoke,
    void *lpContext);
</pre>
<p>
Your invoke function receives a <code>FOLDER&shy;COMMAND</code>
enumeration which specifies what command the client is trying to
perform,
and then switches on the command to perform the command,
or returns <code>E_NOT&shy;IMPL</code> if you don't handle the command.
Since each of the methods takes different parameters,
we have to do some work to pack them up into a generic parameter
block, and then unpack it on the receiving end.
Let's assume some helper functions that do this packing and unpacking.
</p>
<pre>
HRESULT UnpackParseDisplayName(
    void *parameters,
    HWND *phwnd,
    LPBINDCTX *ppbc,
    LPWSTR *ppszDisplayName,
    ULONG **ppchEaten,
    PIDLIST_RELATIVE **ppidl,
    ULONG **ppdwAttributes);
);

HRESULT UnpackEnumObjects(
    void *parameters,
    HWND *phwnd,
    SHCONTF *pgrfFlags,
    HENUMIDLIST **ppheidl);

HRESULT AwesomeShellFolderInvoke(
    void *lpContext,
    FOLDERCOMMAND cmd,
    void *parameters)
{
  HRESULT hr = E_NOTIMPL;
  CAwesome *self = reinterpret_cast&lt;CAwesome*&gt;(lpContext);

  switch (cmd) {
  case FOLDERCOMMAND_PARSEDISPLAYNAME:
    {
      HWND hwnd;
      LPBINDCTX pbc;
      LPWSTR pszDisplayName;
      ULONG *ppchEaten;
      PIDLIST_RELATIVE *pidl;
      ULONG *pdwAttributes;
      hr = UnpackParseDisplayName(parameters, &amp;hwnd, &amp;pbc,
              &amp;pszDisplayName, &amp;ppchEaten, &amp;pidl,
              &amp;pdwAttributes);
      if (SUCCEEDED(hr)) {
        hr = ... do the actual work ...
      }
    }
    break;

  case FOLDERCOMMAND_ENUMOBJECTS:
    {
      HWND hwnd;
      SHCONTF grfFlags;
      HENUMIDLIST *pheidl;
      hr = UnpackEnumObjects(parameters, &amp;hwnd, &amp;grfFlags,
              &amp;pheidl);
      if (SUCCEEDED(hr)) {
        hr = ... do the actual work ...
      }
    }
    break;
    ... (etc) ...
  }
  return hr;
}
</pre>
<p>
This could be made a lot simpler with the addition of some helper
functions.
</p>
<pre>
HRESULT DispatchParseDisplayName(
  HRESULT (CALLBACK *)(
    void *lpContext,
    HWND hwnd, LPBINDCTX pbc, LPWSTR pszDisplayName,
    ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes),
  void *lpContext,
  void *parameters);

HRSEULT DispatchEnumObjects(
  HRESULT (CALLBACK *)(
    void *lpContext,
    HWND hwnd, SHCONTF grfFlags, HENUMIDLIST *pheidl),
  void *lpContext,
  void *parameters);
</pre>
<p>
The implementation would then go like this:
</p>
<pre>
HRESULT AwesomeParseDisplayName(
    void *lpContext,
    HWND hwnd, LPBINDCTX pbc, LPWSTR pszDisplayName,
    ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes)
{
  CAwesome *self = reinterpret_cast&lt;CAwesome*&gt;(lpContext);
  HRESULT hr;
  ... do the actual work ...
  return hr;
}

HRESULT AwesomeEnumObjects(
    void *lpContext,
    HWND hwnd, SHCONTF grfFlags, HENUMIDLIST *pheidl),
{
  CAwesome *self = reinterpret_cast&lt;CAwesome*&gt;(lpContext);
  HRESULT hr;
  ... do the actual work ...
  return hr;
}

HRESULT AwesomeShellFolderInvoke(
    void *lpContext,
    FOLDERCOMMAND cmd,
    void *parameters)
{
  switch (cmd) {
  case FOLDERCOMMAND_PARSEDISPLAYNAME:
    return DispatchParseDisplayName(AwesomeParseDisplayName,
              lpContext, parameters);

  case FOLDERCOMMAND_ENUMOBJECTS:
    return DispatchEnumObjects(AwesomeEnumObjects,
              lpContext, parameters);
    ... (etc) ...
  }
  return E_NOTIMPL;
}
</pre>
<p>
You might decide to make the parameter packing transparent
instead of opaque, so that they are passed as, say,
an array of generic types like <code>VARIANT</code>s.
(Note that I'm abusing <code>VARIANT</code>s here.
These are not valid <code>VARIANT</code>s,
but it saves me from having to declare my own generic type.
This is just a design discussion, not an actual implementation.)
</p>
<pre>
HRESULT (CALLBACK *SHELLFOLDER_INVOKE)(
    void *lpContext,
    FOLDERCOMMAND cmd,
    VARIANT *rgvarArgs,
    UINT cArgs);

// error checking elided for expository purposes
// In real life, you would have to validate cArgs
// and the variant types.

HRESULT AwesomeShellFolderInvoke(
    void *lpContext,
    FOLDERCOMMAND cmd,
    VARIANT *rgvarArgs,
    UINT cArgs)
{
  CAwesome *self = reinterpret_cast&lt;CAwesome*&gt;(lpContext);

  switch (cmd) {
  case FOLDERCOMMAND_PARSEDISPLAYNAME:
    return self-&gt;ParseDisplayName(
      reinterpret_cast&lt;HWND&gt;(rgvarArgs[0]-&gt;byref),
      reinterpret_cast&lt;LPBINDCTX&gt;(rgvarArgs[1]-&gt;byref),
      reinterpret_cast&lt;LPWSTR&gt;(rgvarArgs[2]-&gt;byref),
      reinterpret_cast&lt;ULONG*&gt;(rgvarArgs[3]-&gt;byref),
      reinterpret_cast&lt;PIDLIST_RELATIVE*&gt;(rgvarArgs[4]-&gt;byref),
      reinterpret_cast&lt;ULONG**&gt;(rgvarArgs[5]-&gt;byref));

  case FOLDERCOMMAND_ENUMOBJECTS:
    return self-&gt;EnumObjects(
      reinterpret_cast&lt;HWND&gt;(rgvarArgs[0]-&gt;byref),
      reinterpret_cast&lt;SHCONTF&gt;(rgvarArgs[1]-&gt;lVal),
      reinterpret_cast&lt;HENUMIDLIST *&gt;(rgvarArgs[2]-&gt;byref));

    ... (etc) ...
  }
  return E_NOTIMPL;
}
</pre>
<p>
(This is basically the plug-in model that
<a HREF="https://developer.mozilla.org/en-US/docs/NPClass">
some people have chosen to pursue</a>.
It is also basically the same as
<code>IDispatch::Invoke</code>.)
</p>
<p>
Okay, that's how you implement the plug-in.
Now how do you call it?
</p>
<p>
You would have to pack the parameters, then call through the
<code>Invoke</code> method with your command ID.
For example, a call to
<code>FOLDER&shy;COMMAND_<wbr>ENUM&shy;OBJECTS</code>
would go like this:
</p>
<pre>
// was: hr = psf-&gt;EnumObjects(hwnd, shcontf, &amp;peidl);
// now:
HENUMIDLIST heidl;
VARIANT args[3];

args[0].vt = VT_BYREF;
args[0].byref = hwnd;

args[1].vt = VT_I4;
args[1].lVal = shcontf;

args[2].vt = VT_BYREF;
args[2].byref = &amp;heidl;

hr = InvokeShellFolder(hsf, FOLDERCOMMAND_ENUMOBJECTS, args, 3);
</pre>
<p>
Yuck.
</p>
<p>
Let's assume that the shell provides helper functions that do all
this parameter packing for you.
(This is
<a HREF="https://developer.mozilla.org/en-US/docs/NPN_Invoke">
more than certain plug-in models give you</a>.)
</p>
<pre>
HRESULT ShellFolder_ParseDisplayName(
    HSHELLFOLDER hsf,
    HWND hwnd, LPBINDCTX pbc, LPWSTR pszDisplayName,
    ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes)
{
  VARIANT args[6];

  args[0].vt = VT_BYREF;
  args[0].byref = hwnd;

  args[1].vt = VT_BYREF;
  args[1].byref = pbc;

  args[2].vt = VT_BYREF;
  args[2].byref = pszDisplayName;

  args[3].vt = VT_BYREF;
  args[3].byref = pchEaten;

  args[4].vt = VT_BYREF;
  args[4].byref = ppidl;

  args[5].vt = VT_BYREF;
  args[5].byref = pdwAttributes;

  return InvokeShellFolder(hsf, FOLDERCOMMAND_PARSEDISPLAYNAME,
                           args, 6);
}

HRESULT ShellFolder_EnumObjects(
    HSHELLFOLDER hsf,
    HWND hwnd, SHCONTF grfFlags, HENUMIDLIST *pheidl)
{
  VARIANT args[3];

  args[0].vt = VT_BYREF;
  args[0].byref = hwnd;

  args[1].vt = VT_I4;
  args[1].lVal = shcontf;

  args[2].vt = VT_BYREF;
  args[2].byref = &amp;heidl;

  return InvokeShellFolder(hsf, FOLDERCOMMAND_ENUMOBJECTS, args, 3);
}
... (etc) ...
</pre>
<p>
The naming convention above is kind of awkward, so let's give them
a bit less clumsy names.
</p>
<pre>
HRESULT ParseShellFolderDisplayName(
    HSHELLFOLDER hsf,
    HWND hwnd, LPBINDCTX pbc, LPWSTR pszDisplayName,
    ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes);
HRESULT EnumShellFolderObjects(
    HSHELLFOLDER hsf,
    HWND hwnd, SHCONTF grfFlags, HENUMIDLIST *pheidl);
... (etc) ...
</pre>
<p>
Okay, now that we have a flat API,
let's convert
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2011/08/30/10202076.aspx">
the original code</a>.
The first function now goes like this:
</p>
<pre>
HRESULT BindToCsidl(int csidl,
    // <font COLOR=red><strike>REFIID riid, void **ppv</strike></font>
    <font COLOR=blue>HSHELLFOLDER</font> *phsf)
{
 HRESULT hr;
 PIDLIST_ABSOLUTE pidl;
 hr = SHGetSpecialFolderLocation(NULL, csidl, &amp;pidl);
 if (SUCCEEDED(hr)) {
  // <font COLOR=red><strike>IShellFolder *psfDesktop;</strike></font>
  <font COLOR=blue>HSHELLFOLDER hsfDesktop;</font>
  hr = SHGetDesktopFolder(&amp;hsfDesktop);
  if (SUCCEEDED(hr)) {
   if (pidl->mkid.cb) {
    // hr = <font COLOR=red><strike>psfDesktop-&gt;BindToObject(</strike></font>pidl, NULL, <font COLOR=red><strike>riid, ppv</strike></font>);
    hr = <font COLOR=blue>BindToShellFolderObject(hsfDesktop,</font> pidl, NULL, <font COLOR=blue>phsf</font>);
   } else {
    // <font COLOR=red><strike>hr = psfDesktop-&gt;QueryInterface(riid, ppv);</strike></font>
    <font COLOR=blue>*phsf = hsfDesktop;
    hsfDesktop = nullptr; // transfer to owner
    hr = S_OK;</font>
   }
   // <font COLOR=red><strike>psfDesktop-&gt;Release();</strike></font>
   <font COLOR=blue>if (hsfDesktop) ShellFolder_Destroy(hsfDesktop);</font>
  }
  CoTaskMemFree(pidl);
 }
 return hr;
}
</pre>
<p>
What happened here?
The <code>IShell&shy;Folder</code>
interface was replaced by a
<code>HSHELL&shy;FOLDER</code> flat handle.
Flat APIs use handles to refer to objects instead of interface pointers.
</p>
<p>
A method call on an interface pointer becomes a flat API call.
In general,
<code>pInterface-&gt;VerbNoun(args)</code> gets flattened to
<code>VerbInterfaceNoun(h, args)</code>.
But that's just renaming and doesn't change the underlying complexity
of the issue.
</p>
<p>
I could've added reference counting to these flat objects,
but then I would be accused of intentionally making it look like COM,
so let's say that these flat objects are not reference-counted.
Therefore, we have to be more careful about not destroying the object
we plan on returning.
</p>
<p>
On to the next two functions:
</p>
<pre>
void PrintDisplayName(
    // <font COLOR=red><strike>IShellFolder *psf,</strike></font>
    <font COLOR=blue>HSHELLFOLDER hsf</font>,
    PCUITEMID_CHILD pidl, SHGDNF uFlags, PCTSTR pszLabel)
{
 <a HREF="http://blogs.msdn.com/oldnewthing/archive/2004/08/23/218837.aspx">STRRET</a> sr;
 // HRESULT hr = <font COLOR=red><strike>psf-&gt;GetDisplayNameOf(</strike></font>pidl, uFlags, &amp;sr);
 HRESULT hr = <font COLOR=blue>GetShellFolderDisplayNameOf(hsf,</font> pidl, uFlags, &amp;sr);
 if (SUCCEEDED(hr)) {
  PTSTR pszName;
  hr = StrRetToStr(&amp;sr, pidl, &amp;pszName);
  if (SUCCEEDED(hr)) {
   _tprintf(TEXT("%s = %s\n"), pszLabel, pszName);
   CoTaskMemFree(pszName);
  }
 }
}

void PrintDetail(
    // <font COLOR=red><strike>IShellFolder2 *psf,</strike></font>
    <font COLOR=blue>HSHELLFOLDER hsf</font>,
    PCUITEMID_CHILD pidl,
    const SHCOLUMNID *pscid, PCTSTR pszLabel)
{
 VARIANT vt;
 // HRESULT hr = <font COLOR=red><strike>psf-&gt;GetDetailsEx(</strike></font>pidl, pscid, &amp;vt);
 HRESULT hr = <font COLOR=blue>GetShellFolderDetailsEx(hsf,</font> pidl, pscid, &amp;vt);
 if (SUCCEEDED(hr)) {
  hr = VariantChangeType(&amp;vt, &amp;vt, 0, VT_BSTR);
  if (SUCCEEDED(hr)) {
   _tprintf(TEXT("%s: %ws\n"), pszLabel, V_BSTR(&amp;vt));
  }
  VariantClear(&amp;vt);
 }
}
</pre>
<p>
Not really all that different.
Last function:
</p>
<pre>
int __cdecl _tmain(int argc, PTSTR *argv)
{
 HRESULT hr = CoInitialize(NULL);
 if (SUCCEEDED(hr)) {
  // <font COLOR=red><strike>IShellFolder2 *psfRecycleBin;</strike></font>
  <font COLOR=blue>HSHELLFOLDER hsfRecycleBin;</font>
  hr = BindToCsidl(CSIDL_BITBUCKET, <font COLOR=blue>&amp;hsfRecycleBin</font>);
  if (SUCCEEDED(hr)) {
   // <font COLOR=red><strike>IEnumIDList *peidl;</strike></font>
   <font COLOR=blue>HENUMIDLIST heidl;</font>
   // hr = <font COLOR=red><strike>psfRecycleBin-&gt;EnumObjects(</strike></font>NULL,
   hr = <font COLOR=blue>EnumShellFolderObjects(hsfRecycleBin,</font> NULL,
     <a HREF="http://blogs.msdn.com/oldnewthing/archive/2010/04/02/9989235.aspx">SHCONTF_FOLDERS | SHCONTF_NONFOLDERS</a>, &amp;heidl);
   if (hr == S_OK) {
    PITEMID_CHILD pidlItem;
    // while (<font COLOR=red><strike>peidl-&gt;Next(</strike></font>1, &amp;pidlItem, NULL) == S_OK) {
    while (<font COLOR=blue>EnumerateNextShellFolderObject(heidl,</font> 1, &amp;pidlItem, NULL) == S_OK) {
     _tprintf(TEXT("------------------\n"));

     PrintDisplayName(<font COLOR=blue>hsfRecycleBin</font>, pidlItem,
                      SHGDN_INFOLDER, TEXT("InFolder"));
     PrintDisplayName(<font COLOR=blue>hsfRecycleBin</font>, pidlItem,
                      SHGDN_NORMAL, TEXT("Normal"));
     PrintDisplayName(<font COLOR=blue>hsfRecycleBin</font>, pidlItem,
                      SHGDN_FORPARSING, TEXT("ForParsing"));

     PrintDetail(<font COLOR=blue>hsfRecycleBin</font>, pidlItem,
                 &amp;SCID_OriginalLocation, TEXT("Original Location"));
     PrintDetail(<font COLOR=blue>hsfRecycleBin</font>, pidlItem,
                 &amp;SCID_DateDeleted, TEXT("Date deleted"));
     PrintDetail(<font COLOR=blue>hsfRecycleBin</font>, pidlItem,
                 &amp;PKEY_Size, TEXT("Size"));

     CoTaskMemFree(pidlItem);
    }
   }
   // <font COLOR=red><strike>psfRecycleBin-&gt;Release();</strike></font>
   <font COLOR=blue>DestroyShellFolder(hsfRecycleBin);</font>
  }
  CoUninitialize();
 }
 return 0;
}
</pre>
<p>
So we see that flattening the API didn't really change the code
at all.
You're still invoking methods on objects.
Whether you use a flat API to do it or an object-based API
is just changing the decorations.
The underlying logic doesn't change.
</p>
<p>
One disadvantage of the flat version is that it requires everything
to be mediated by the shell.
Instead of invoking a method directly on the object,
you have to call the flat function in the shell,
which then packages up the call and dispatches it,
and the recipient then needs to unpack the parameters
(possibly with help from the shell)
before finally getting around to doing the actual work.
</p>
<p>
It also means that any interface change requires an operating system
upgrade,
since the mediator (the shell) needs to understand the new interface.
</p>
<p>
But if this whole object-oriented syntax
really annoys you and you want a flat API,
then feel free to add the line
</p>
<pre>
#define CINTERFACE
</pre>
<p>
before including COM header files.
If you do that, then
you get the old flat C-style version of COM.
Instead of the
<code>p-&gt;Method(args)</code> new hotness,
you can stick to the old trustworthy
<code>p-&gt;lpVtbl-&gt;Method(p, args)</code> version,
or use the
<code>InterfaceName_MethodName(p, args)</code> helper macro.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (17)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1095703">
				<div id="div-comment-1095703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095703">
			December 20, 2013 at 7:10 am</a>		</div>

		<p>Indeed implementing shell objects or altering their behavior requires infrastructure that is most of COM. But merely calling them could have been much simpler with a little ingenuity.</p>
<p>COM without CINTERFACE has this weird artifact of depending on the C++ memory layout (which is not normally a platform constant).</p>
<div class="post">[<em>I also showed how calling them could be done with a flat API. But it&#39;s just a difference in how you type the words. Either <code>pObject-&gt;Verb(Args)</code> or <code>VerbObject(p, Args)</code>. Or did you have something more radical in mind? Why not share your idea with us? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095713">
				<div id="div-comment-1095713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095713">
			December 20, 2013 at 7:45 am</a>		</div>

		<p>&quot;Show me the implementation&quot;</p>
<p>When a non-dev presents an alternative, they can be excused when they don&#39;t show the code.</p>
<p>When a dev presents an alternative, they need to have code to show.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095723">
				<div id="div-comment-1095723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cracky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095723">
			December 20, 2013 at 8:04 am</a>		</div>

		<p>For myself, working out how IAdvise (proper) coped with network failure, etc was vexing and then head banging in its simplicity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1095733">
				<div id="div-comment-1095733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095733">
			December 20, 2013 at 8:06 am</a>		</div>

		<p>&quot;How about we make the drivers OO, but because we want to save memory, we put the methods into a single per-driver table&quot;. And this is why Windows drivers have to have the same dispatch routines for all device objects they create, which is so inconvenient for some types of drivers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095743">
				<div id="div-comment-1095743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095743">
			December 20, 2013 at 8:26 am</a>		</div>

		<p>@Joshua: which only means that there is only One True memory layout for C++ on Windows. Using something different in your compiler is asking for troubles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-odd thread-alt depth-1" id="comment-1095753">
				<div id="div-comment-1095753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095753">
			December 20, 2013 at 8:48 am</a>		</div>

		<p>@Joshua actually COM was deliberately designed to follow the windows implementation of the C++ memory layout, I believe Raymond actually mentioned this a post awhile back talking about why the shell class headers were exposed directly (because the internals are C due to when the shell was written, and they manually build the vTables).</p>
<div class="post">[<em><a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/10/05/238050.aspx">I already covered this</a>. That&#39;s why we have macros like <code>BEGIN_INTERFACE</code>. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-wndsks even thread-even depth-1" id="comment-1095773">
				<div id="div-comment-1095773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/skSdnW' rel='external nofollow' class='url'>skSdnW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095773">
			December 20, 2013 at 12:01 pm</a>		</div>

		<p>And guess what, the shell already uses the message based extension model in some places.</p>
<p>When implementing/extending the default IShellView (DefView) you even get to choose if you want a callback function (LPFNVIEWCALLBACK) or a COM object with a single method (IShellFolderViewCB). You also have IShellMenuCallback for menu bands? and IContextMenuCB when you need to provide a IContextMenu.</p>
<p>In typical Microsoft fashion if you actually try to use this stuff you often hit a wall of poor documentation and lots of undocumented messages&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095783">
				<div id="div-comment-1095783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095783">
			December 20, 2013 at 2:04 pm</a>		</div>

		<p>[Not sure how you intend to do this in a flat C-like API while still supporting extensibility. This isn&#39;t C# where you can reflect on objects. -Raymond]</p>
<p>The shell folder tree has an apparently small number of objects (really interfaces). The trick involved is to reduce the number of interfaces to 1. The only reflection still required would be the single bit &quot;is this a kind of entity that could have children&quot; which should by handled by the enumerate operation, and the custom menu verbs which aren&#39;t specific interfaces right now.</p>
<div class="post">[<em>Now you&#39;re answering a question different from the one that was asked. The original question was &quot;Wouldn&#39;t a flat C API be simpler?&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095763">
				<div id="div-comment-1095763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095763">
			December 20, 2013 at 10:22 am</a>		</div>

		<p>[I also showed how calling them could be done with a flat API. But it&#39;s just a difference in how you type the words. Either pObject-&gt;Verb(Args) or VerbObject(p, Args). Or did you have something more radical in mind? Why not share your idea with us? -Raymond]</p>
<p>You would have had to change the fundamental design so that almost all verbs are universal and objects (not just directories) can be accessed by descending a path through the shell namespace and single-op verbs do not require taking references on their own object.</p>
<p>Potential verb list (this is really hard to make exhaustive one one pass):</p>
<p>* New (descends like 95-XP &#8212; folder, shortcut, file from template)</p>
<p>* GetBackingPath **</p>
<p>* GetHandle</p>
<p>* ReleaseHandle</p>
<p>* Copy</p>
<p>* Move</p>
<p>* Delete</p>
<p>* Rename</p>
<p>* Enum-Menu-Verbs</p>
<p>* Menu-Verb (calls whetever verbs returned by Enum-Menu-Verbs)</p>
<p>* GetIconFromForm (works on invalid paths such as *.doc)</p>
<p>* GetIcon</p>
<p>* GetIconOverlay</p>
<p>* OpenWith</p>
<p>* Get-Properties</p>
<p>* Set-Properties</p>
<p>* Get-Extended-Properties (details in the UI)</p>
<p>* Set-Extended-Properties (when they can be edited)</p>
<p>** GetBackingPath for a file is the full path. GetBackingPath for things like documents is SHGetSpecialFolder. GetBackingPath for Desktop returns the current user&#39;s desktop for the obvious reason.</p>
<p>Most verbs would need a flag that says whether or not a UI is acceptable to show.</p>
<p>For this design to be coherent, SHGetSpecialFolder must be moved to kernel32 where it should have been in the first place.</p>
<div class="post">[<em>Not sure how you intend to do this in a flat C-like API while still supporting extensibility. This isn&#39;t C# where you can reflect on objects. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095793">
				<div id="div-comment-1095793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095793">
			December 21, 2013 at 12:09 am</a>		</div>

		<p>I&#39;m not sure about Extensibility either.</p>
<p>Adding new verbs either means you need to ask the &quot;object&quot; about the verbs it supports and call through a pointer (like COM) or you&#39;re just jamming extra calls into whatever will pass as the vtable &amp; then hopefully versioning it so you don&#39;t ever try to call something past the end of the vtable ( which is how AmigaOS worked circa 1985).</p>
<p>I&#39;d be more interested in how you&#39;d implement something like COM in BCPL or Objective C :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095803">
				<div id="div-comment-1095803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095803">
			December 21, 2013 at 7:51 am</a>		</div>

		<p>[Now you&#39;re answering a question different from the one that was asked. The original question was &quot;Wouldn&#39;t a flat C API be simpler?&quot; -Raymond]</p>
<p>I think I&#39;m answering the question in the spirit of what was asked.</p>
<div class="post">[<em>Okay, fine, then be specific. You haven&#39;t really made a concrete proposal so much as presented a list of goals. How exactly do you have universal verbs in a flat C API? Are you saying that it should be<br /> <code>VARIANT args[2];<br /> args[0].vt = VT_BYREF;<br /> args[0].byref = pszNewName;<br /> args[1].vt = VT_I4;<br /> args[1].lVal = flags;<br /> InvokeUniversalVerbOnObjectWithArguments(hObject, ShellVerb_Rename, args, 2);</code><br /> ? This is basically the same as <code>AwesomeShellFolderInvoke</code>. And if the verb doesn&#39;t take a reference to the object, then there is no <code>hObject</code> parameter, so how does it know which object to operate on? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095873">
				<div id="div-comment-1095873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095873">
			December 23, 2013 at 10:32 am</a>		</div>

		<p>[The issues you have with COM are not actually issues with COM]</p>
<p>Issue #1 with COM is X-apartment model resulting in incompatibility. E.g. OpenFileDialog doesn&#39;t work very will with multi-thread apartment. This results in certain sets of COM components being completely incompatible with each other.</p>
<p>Issue #2 with COM is it&#39;s got this habit of loading DLLs at stupid times. Plug-in in this context means not implemented in shell32.dll.</p>
<p>Issue #3 with COM is memory corruption due to buggy third-party shell extension.</p>
<div class="post">[<em>What is the threading model for your alternative? Are all objects free-threaded, or do they have thread affinity? (Remember, whatever decision you make affects all implementations.) Also, defining a plug-in by what DLL implements them is very fragile. Components move around between DLLs a lot. (Control panel items in particular.) What would prevent your alternative from loading DLLs at stupid times? And buggy third party shell extensions don&#39;t go away when you switch from COM to a custom plug-in model, so it&#39;s not clear why you are blaming COM. And what is your extensibility model? What if a plug-in wants to add a new verb? (&quot;Add to Playlist&quot; or something.) Do they have to ask Microsoft to add an API for that new verb and then hope everybody upgrades to the next version of Windows? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095883">
				<div id="div-comment-1095883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095883">
			December 23, 2013 at 11:34 am</a>		</div>

		<p>[What is the threading model for your alternative? Are all objects free-threaded, or do they have thread affinity?]</p>
<p>This should be defined independently per interface rather than per memory space.</p>
<p>[(Control panel items in particular.)]</p>
<p>No case where I have to care needs to load control panel items or anything else that isn&#39;t a directory, drive, network share, computer, desktop, start menu, or special folder that behaves like desktop (think quick launch or send to). I don&#39;t have to care about recycle bin either but it is likely somebody else would.</p>
<p>[What would prevent your alternative from loading DLLs at stupid times?]</p>
<p>Either flag or sensible error handling when LoadLibrary returns EGOAWAY (i.e. don&#39;t stop enumeration if this object can&#39;t be started. Either pretend it&#39;s a file object or skip it).</p>
<p>[And buggy third party shell extensions don&#39;t go away when you switch from COM to a custom plug-in model, so it&#39;s not clear why you are blaming COM]</p>
<p>Because COM is defined in a way that COM interfaces can be hijacked by overriding registration. This should be flat-out impossible.</p>
<p>[And what is your extensibility model?]</p>
<p>I actually did think of the idea of making new shell folders via plugins. As I said before the actual implementation on the extender&#39;s side looks like COM with a few more variables floating.</p>
<p>[(&quot;Add to Playlist&quot; or something.)]</p>
<p>Same way I did in Windows 95. Add a new verb in the file types dialog that spawns a program with specific options. This is what I call Menu-Verb above.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1095893">
				<div id="div-comment-1095893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095893">
			December 23, 2013 at 2:29 pm</a>		</div>

		<p>&gt;Because COM is defined in a way that COM interfaces can be hijacked by overriding registration.</p>
<p>ANY plug-in model can be hijacked by overriding registration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095903">
				<div id="div-comment-1095903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095903">
			December 23, 2013 at 2:42 pm</a>		</div>

		<p>&gt; ANY plug-in model can be hijacked by overriding registration.</p>
<p>But a built-in component shouldn&#39;t be overridable that way. This limits plugins to overriding other plugins.</p>
<div class="post">[<em>Whether a registration can be overridden doesn&#39;t have anything to do with whether the Recycle Bin sample program would have been simpler with a flat API model. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1095853">
				<div id="div-comment-1095853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095853">
			December 23, 2013 at 9:56 am</a>		</div>

		<p>What I call root here is more like current directory but we can have arbitrary N of them.</p>
<p>NT Native API has the same concept.</p>
<p>Operations that display pre-defined dialogs may accept a list of strings to populate the dialog.</p>
<p>The most prominent of these is new shortcut. Menu-verb has the same artifact.</p>
<p>The idea of XSTR is it&#39;s a string that&#39;s only reference counted if you return it. If passed one,</p>
<p>don&#39;t assume you can keep it after returning. I&#39;m assuming that auto_ptr hasn&#39;t been discovered yet.</p>
<p>Since we now have exactly 1 interface, we may almost completely depend on strong typing (no need for VT_&#8230;) and declare C functions for them as so:</p>
<p>/* declarations */</p>
<p>#define SHFLAG_NOUI 1</p>
<p>#define SHFLAG_DONTLOADPLUGINS 2 /* for processes that must function with special memory-model constraints */</p>
<p>#define SHEFLAG_CANDESCEND 1</p>
<p>#define SHEFLAG_NOBACKINGFILE 2</p>
<p>#define SHEFLAG_NOSTATE 4 /* requires SHEFLAG_NOBACKINGFILE */</p>
<p>/* these are the only entities that exist at the root of the shell namespace */</p>
<p>/* All valid file paths are also valid SHNAME paths */</p>
<p>/* These teplates exist at root level to keep people from deleting them */</p>
<p>#define SHNAME_DESKTOP &quot;\\!\desktop&quot;;</p>
<p>#define SHNAME_TEMPLATE_EMPTY &quot;NUL&quot;;</p>
<p>#define SHNAME_TEMPLATE_FOLDER &quot;\\!\{::newfolder}&quot;;</p>
<p>#define SHNAME_TEMPLATE_SHORTCUT &quot;\\!\{::newshortcut}&quot;;</p>
<p>#define SHNAME_TEMPLATE_TEMPLATEDIR &quot;\\!\{::templates};&quot;</p>
<p>#define SHNAME_MY_COMPUTER &quot;\!desktopcomputer&quot;;</p>
<p>/* Most of these exist ONLY to identify shell special folders independent of name */</p>
<p>#define PROVIDER_FILESYSTEM MKGUID(&#8230;)</p>
<p>#define PROVIDER_TEMPLATE MKGUID(&#8230;)</p>
<p>#define PROVIDER_DESKTOP MKGUID(&#8230;)</p>
<p>#define PROVIDER_RECYCLE_BIN MKGUID(&#8230;)</p>
<p>typedef struct _xstr { ssize_t owner_refcnt; size_t sz, wchar_t *data; } XSTR;</p>
<p>typedef struct _verb { DWORD flags, GUID providerid, DWORD nmargs /* most stock have 0 here */, XSTR verb; } SHVERB;</p>
<p>typedef struct _entity { DWORD flags, GUID providerid, DWORD attributes, FILETIME moddatetime, QWORD inum, XSTR name); } SHENTITY</p>
<p>inline XSTR StringToXSTR(wchar_t str) { XSTR x { -1 /* cannot be freed */, _wstrlen(str), str}; return x; }</p>
<p>HRESULT SHGetBackingPath(HANDLE root, XSTR path, OUT *XSTR backing);</p>
<p>HRESULT SHGetHandle(HANDLE root, XSTR path, OUT *HANDLE child);</p>
<p>HRESULT SHReleaseHandle(HANDLE root);</p>
<p>HRESULT SHNew(HANDLE root, DWORD flags, HWND owner, XSTR template, XSTR newname, size_t nargs, IN XSTR *args);</p>
<p>HRESULT SHCopy(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname);</p>
<p>HRESULT SHMove(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname);</p>
<p>HRESULT SHRename(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname_nameonly);</p>
<p>HRESULT SHDelete(HANDLE root, DWORD flags, HWND owner, XSTR name);</p>
<p>HRESULT SHGetMenuVerbs(HANDLE root, XSTR path, OUT DWORD *verbs, OUT SHVERB *verbs);</p>
<p>HRESULT SHFindOpen(HANLDE root, XSTR path, OUT *enumhandle);</p>
<p>HRESULT SHFindNext(HANLDE enumerator, OUT SHENTITY *entity);</p>
<p>HRESULT SHFindClose(HANLDE enumerator);</p>
<p>/* &#8230; */</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1095863">
				<div id="div-comment-1095863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20131220-00/?p=2313#comment-1095863">
			December 23, 2013 at 9:57 am</a>		</div>

		<p>[please shorten your comment to 3072 bytes or less] ok breaking</p>
<p>So the rename recycle bin would look like:</p>
<p>int main(int argc, char **argv)</p>
<p>{</p>
<p>wchar_t *newname = /* gimmie first arg as whar_t */</p>
<p>HRESULT hr;</p>
<p>SHENTITY e;</p>
<p>HANDLE h;</p>
<p>hr = SHFindOpen(NULL, SHNAME_DESKTOP, h);</p>
<p>if (SUCCEEDED(hr)) {</p>
<p>while (1) {</p>
<p>SHFindNext(h, entity);</p>
<p>if (e.name.sz == 0) break; /* EOL */</p>
<p>if (e.providierid == PROVIDERID_RECYCLE_BIN) {</p>
<p>XSTR rc = JoinXstrs(3, SHNAME_DESKTOP, &quot;\&quot;, e.name);</p>
<p>SHRename(rc, SHFLAG_NOUI, NULL, rc, StringToXSTR(newname));</p>
<p>ReleaseXSTR(rc);</p>
<p>}</p>
<p>}</p>
<p>SHFindClose(h);</p>
<p>}</p>
<p>}</p>
<p>For an example of implementation disptach (this is a library function that would already be provided): SHRename</p>
<p>HRESULT SHRename(HANDLE root, DWORD flags, HWND owner, XSTR oldname, XSTR newname_nameonly)</p>
<p>{</p>
<p>XSTR folder;</p>
<p>XSTR file;</p>
<p>HANDLE h;</p>
<p>HRESULT hr;</p>
<p>if (!XSTRGetFolderAndFile(oldname, &amp;folder, &amp;file)) /* if no folder component, returns &quot;.&quot; */</p>
<p>return EBADPATH;</p>
<p>hr = SHGetHandle(root, folder, &amp;hr);</p>
<p>if (!SUCCEEDED(hr)) return hr;</p>
<p>hr = ((struct internalentity *)h)-&gt;vtbl-&gt;rename(flags, owner, file, newname_nameonly);</p>
<p>SHReleasehandle(h);</p>
<p>return hr;</p>
<p>}</p>
<p>Key differences between this and COM such that no wrapper could ever be written:</p>
<p>1. Does not impose any memory model or message pumping requirements if the _NOUI flag is passed.</p>
<p>2. The SHFLAG_DONTLOADPLUGINS exists, which permits access to core shell functions without imposing any more memory model constraints than WIN32. This would allow things like SQL server to use this directly.</p>
<div class="post">[<em>The issues you have with COM are not actually issues with COM. They are issues with the shell interface itself. For example, there is COM-imposed reason why there can&#39;t be a &quot;DONTLOADPLUGINS&quot; flag. That&#39;s a shell limitation. Internally, <span style="text-decoration:underline;">everything</span> is a plug-in. Control Panel? That&#39;s a plug-in. Files on disk? That&#39;s a plug-in. It happens to be a plug-in provided with Windows, but from the shell namespace&#39;s standpoint, it&#39;s still a plug-in. So as far as I can tell, your complaints have nothing to do with COM. You merely wish the shell interfaces were designed some other way. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

