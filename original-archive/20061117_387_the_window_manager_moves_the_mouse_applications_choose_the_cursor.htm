<html>
<head>
<title>The window manager moves the mouse; applications choose the cursor</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The window manager moves the mouse; applications choose the cursor</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 17, 2006 / year-entry #388</td></tr>
<tr><td><b>Tags:</b></td><td>tipssupport</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">You can sometimes narrow down the source of a problem just by looking at the screen and moving the mouse. When you move the mouse, the cursor on the screen moves to match. This work is done in the window manager in kernel mode. The mouse hardware notifies the window manager, "Hey, I moved left...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>You can sometimes narrow down the source of a problem just by looking at the screen and moving the mouse.</p>
<p> When you move the mouse, the cursor on the screen moves to match. This work is done in the window manager in kernel mode. The mouse hardware notifies the window manager, "Hey, I moved left twenty units." The window manager takes this value, accelerates or decelerates it according to your mouse acceleration settings, calls any low-level mouse hooks that are installed, and then tells the display driver, "Move that sprite left about thirty pixels" (say). It then <a href="http://blogs.msdn.com/oldnewthing/archive/2003/10/01/55108.aspx"> sets the "the mouse moved" flag</a> so that the program who owns the window under the new mouse position will get a <code>WM_MOUSEMOVE</code> message. The window manager also sets the cursor to the "virtual cursor state" corresponding to the window beneath the cursor. The "virtual cursor state" remembers the cursor that the thread (or threads, if input has been attached) responsible for the window most recently set. Maintaining the virtual cursor state is important, for if a thread calls <code>SetCursor</code> to change the cursor to an hourglass and then stops processing messages (because it is busy), you really want the cursor to change back to an hourglass when it moves over the thread's windows. </p>
<p> What does it mean if <a href="http://blogs.msdn.com/oldnewthing/archive/2005/06/27/432303.aspx#433193"> the cursor doesn't move at all when you move the mouse</a>? Could it be caused by an application? If you read through the flowchart I described above, the only place applications get involved in the "move the mouse cursor" code flow is if they are filtering out the mouse motion in a low-level mouse hook. (Another way an application can "lock up" the mouse is by calling the <code>ClipCursor</code> function, but vanishingly few applications do this. I'm assuming you aren't the victim of malicious software but instead are trying to figure out what program, if any, is <strong>accidentally</strong> freezing the mouse.) </p>
<p> Low-level mouse hooks are comparatively uncommon since they exact a high performance penalty on the system. If you're moving your mouse and don't see the cursor move around on the screen, my guess is that there is a problem in the kernel-mode side of the equation. If you're seeing the entire system freeze up, then it's probably a device driver that has started acting up and held a lock for too long. </p>
<p> A flaky hard drive can have the same effect. If the window manager itself takes a page fault, it has to wait for the hard drive to page in the data. and if the window manager happened to be holding a lock when this happened, that lock is held across the entire I/O operation. If your hard drive is flaky and, say, takes ten seconds to produce a sector of data instead of several milliseconds, then it will look like the system has frozen for ten seconds, since the window manager is stuck waiting on your disk, which is in turn grunting and recalibrating in a desperate attempt to produce the data the memory manager requested. </p>
<p> In other words: If the cursor won't move, it's likely a driver or hardware problem. (Figuring out which driver/hardware will require hooking up a kernel debugger and poking around. Not for the faint of heart.) </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-443313">
				<div id="div-comment-443313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steve.wiseman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443313">
			November 17, 2006 at 1:48 pm</a>		</div>

		<p>That explains it. Earlier this year my Sony Viao started having a freeze up problem. It was everything &#8211; including the mouse. I scanned for spyware, viruses anything I could think of. Found nothing. It wasn&#8217;t until it was late one night and it was really quiet that I could hear the hard drive re-reading the same area over and over. Put in a new HD, and it never did it again. I thought this was strange that it would cause a lockup like that since you would think that the mouse would still work while the HD was trying to re-read the drive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443323">
				<div id="div-comment-443323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nobody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443323">
			November 17, 2006 at 2:12 pm</a>		</div>

		<p>Similarly, the NumLock key can indicate just how locked up your system is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443333">
				<div id="div-comment-443333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443333">
			November 17, 2006 at 2:59 pm</a>		</div>

		<p>My story comes from a video card pooping out. The mouse didn&#8217;t freeze per se &#8211; it was jittery. Slow, steady movements of the mouse would result in fast+stop jumps across the desktop. In my case I was able to run Process Explorer to see &#8216;DPCs&#8217; get small junks of time at the same time the mouse would jitter. A quick google search turned up DPC&#8217;s being a hardware failure. So several hours later doing safe-mode boots enabling devices one at a time finally started jittering when the video driver was installed. Updating the driver didn&#8217;t help. Dell replaced the video card and viola!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443343">
				<div id="div-comment-443343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443343">
			November 17, 2006 at 4:19 pm</a>		</div>

		<p>Well, DPCs aren&#8217;t &quot;a hardware failure&quot;, I don&#8217;t think. &nbsp;DPCs are the way the kernel does interrupt-related work from a non-interrupt context. &nbsp;Since interrupt handlers can&#8217;t do a lot of work (e.g., they can&#8217;t sleep, so they can&#8217;t take locks, and there&#8217;s generally a limit on how long they can take to execute because they run with interrupts disabled), they generally just grab the required data out of the device (or the DMA region that the device copied it to), queue it somewhere, and set up a DPC to do the rest of the processing.</p>
<p>(NICs, for instance, generally work like this. &nbsp;When they get a received-frame indication from the hardware, which usually means the NIC has DMA&#8217;ed a frame into a buffer somewhere, they copy it out of the buffer and queue a DPC. &nbsp;The DPC, which runs in a non-interrupt context, handles the rest of the frame-receipt logic &#8212; e.g. giving the frame to NDIS, and from there to user-space.)</p>
<p>So getting DPCs isn&#8217;t an indication that your hardware is failing. &nbsp;However, getting a lot more DPCs than normal, or having DPCs take a long time to process, may be. &nbsp;(It may also just be a broken driver, although it wasn&#8217;t in your case.) &nbsp;Lots of DPCs just means you&#8217;re getting lots of interrupts, which may be caused by the driver telling the device to retry over and over again because each retry fails. &nbsp;Or they may be caused by e.g. a lot of stuff that looks like network traffic but isn&#8217;t (especially if you use a software driven wireless card).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443353">
				<div id="div-comment-443353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443353">
			November 17, 2006 at 4:22 pm</a>		</div>

		<p>I&#8217;m puzzled by your description of the origin of the WM_MOUSEMOVE messages: &nbsp;I don&#8217;t think I&#8217;ve seen the behavior I&#8217;m about to describe on the WinNT flavors, but it was very common on Win9x and before.</p>
<p>On Win9x, if you experienced a significant crash of the system, sometimes the only way that you would know for certain that the system was dead was that you&#8217;d waggle the mouse around for a while, and then suddenly the PC&#8217;s internal speaker would start clicking loudly, one click for what seemed to be every motion the mouse made. &nbsp;It did this for the keyboard, too, but not for anything else that generated interrupts (network, audio cards, timers, etc.). &nbsp;Sometimes the cursor would move, sometimes it wouldn&#8217;t: &nbsp;But the clicks were a dead giveaway that the system was toast and the only option you had left was the Big Red Switch.</p>
<p>I always took this to assume that the system had some sort of internal message queue that had filled up with a few hundred low-level &#8220;mouse move&#8221; messages and that it was &#8220;beeping&#8221; to indicate that the queue was full and not being serviced. &nbsp;This seemed especially true since it seemed to require about the same number of input messages after a crash to cause it to happen.</p>
<p>Further, I&#8217;ve seen times on Win9x where an app suddenly received not one &#8220;spurious&#8221; WM_MOUSEMOVE messages, but dozens or hundreds of them, in effect &#8220;catching up&#8221; to its correct state from when the system was &#8220;sleepy&#8221;. &nbsp;I&#8217;ve even seen my own apps do that when the system got overloaded, and I know for a fact that I don&#8217;t have any sort of secondary queuing mechanism in those.</p>
<p>I can&#8217;t remember seeing the same behavior on any of the WinNT flavors, although that doesn&#8217;t necessarily guarantee anything.</p>
<p>Now, if, as you say, the Win9x window manager were just setting a flag every time an interrupt fires, you wouldn&#8217;t expect to see either of the two behaviors described above. &nbsp;So what&#8217;s the real story here? &nbsp;Was Win9x&#8217;s window manager implemented significantly differently than NT? &nbsp;Quirky drivers? &nbsp;Side-effects of having the old Win16 code in there? &nbsp;This obviously doesn&#8217;t affect any software anybody writes today, but I&#8217;m really curious as to why that old legacy mouse-move behavior seemed contrary to what you said here.</p>
<div class=post>[<i>A bunch of work happens before that bit gets set since you have to compute <u>which thread&#8217;s</u> bit to set. Hardware input is queued into the raw input thread and the raw input thread does the work. The beeping means that the raw input thread queue is full. I ignored this implementation detail since it wasn&#8217;t relevant to the discussion. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443373">
				<div id="div-comment-443373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">marlinj</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443373">
			November 17, 2006 at 4:40 pm</a>		</div>

		<p>Alternate explanation for why doesn&#8217;t the cursor move with the mouse: &nbsp;Filthy Mouse.</p>
<p>Crud on the ball or internal rollers for the mechano-optical type or little bit of something, as small as half an inch of a single hair, stuffed up in the hole over the light receiver on a true optical mouse, and so forth.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443393">
				<div id="div-comment-443393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443393">
			November 17, 2006 at 5:50 pm</a>		</div>

		<p>The beeping issue is interesting, because I get similar behavior on my XP box, specifically when I run a specific game (GZDoom if you must know).</p>
<p>Sometimes, when it starts, it doesn&#8217;t seem to take input, and I hear beeps when I press a key or move the mouse. After a while it &quot;catches up&quot; and a blur of motion is seen on the screen, presumably the input that was &quot;missed&quot; earlier.</p>
<p>So, this definately is an application issue, yet it causes the beeping which occurs at a very low level. Any guess as to what is going on?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443403">
				<div id="div-comment-443403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Philip Taylor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443403">
			November 17, 2006 at 6:01 pm</a>		</div>

		<p>I&#8217;ve had the clicking-sound-on-mouse-and-key-input-while-frozen in Windows 2000 several times, especially when working on one particular program which disagrees with the VS2005 debugger (though I don&#8217;t know why) &#8211; it occasionally gets in a state where the whole computer mostly-freezes after breaking/stepping in the debugger, and Windows appears to process one input message (mouse movement, click, key press) every ten seconds or so. If I wiggle the mouse enough, it&#8217;s presumably hitting the same queue limit, and it starts beeping. (That sound always makes me very nervous, like I&#8217;m overtightening a clockwork toy and the spring is about to break, though I can reason on a logical level that it&#8217;s not going to do anything bad.)</p>
<p>Unfortunately my heart is too faint to try debugging the cause of the problem &#8211; depending on how much I feel like working, I either hit the &#8216;stop debugging&#8217; button as soon as possible and wait half a minute until it reacts, or else sit back and relax and wait a few more minutes until it unfreezes itself and carries on debugging happily. I particularly like 6-minute games of Zoo Keeper on the DS during those breaks, which is probably why I never get as much work done as I would like&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443423">
				<div id="div-comment-443423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443423">
			November 17, 2006 at 7:13 pm</a>		</div>

		<p>[Doing it your way means that the input manager can lose things like the mouse button being pressed and released in rapid succession if the raw input thread doesn&#8217;t process the events fast enough.]</p>
<p>Yes, and it wouldn&#8217;t be the first time that inputs on computer equipment got lost because they were typed/pressed/sent too quickly; both old and new software and hardware have suffered from this for a variety of reasons. &nbsp;My point was that some other systems handle input processing that way, so it was a viable option to consider when trying to work out how the window manager treated these things. &nbsp;I didn&#8217;t claim it was the end-all be-all of input-processing solutions: &nbsp;Only that it couldn&#8217;t be ruled out without additional knowledge of the implementation of the window manager. &nbsp;Which you&#8217;ve now provided.</p>
<p>(And, in fact, it&#8217;s a rather poor way to handle input, but it works surprisingly well in many cases. &nbsp;You don&#8217;t necessarily need a &#8220;big&#8221; solution like a long queue to handle input: &nbsp;The GameBoy Advance and Nintendo DS both use polling for their input, and the Apple II computers had a keyboard-input queue that was exactly one entry deep.)</p>
<div class=post>[<i>Game consoles and the Apple II don&#8217;t have virtual memory. This changes the rules considerably. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443433">
				<div id="div-comment-443433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443433">
			November 17, 2006 at 11:22 pm</a>		</div>

		<p>[quote]</p>
<p>ots of DPCs just means you&#8217;re getting lots of interrupts, which may be caused by the driver telling the device to retry over and over again because each retry fails. &nbsp;Or they may be caused by e.g. a lot of stuff that looks like network traffic but isn&#8217;t (especially if you use a software driven wireless card).</p>
<p>[/quote]</p>
<p>For another possible reason, our company recently got hitted by Viking worm, and noted an exceptionally high (&gt; 60%) CPU time devoted to DPCs. Likely because the worm is trying the passwords of other machines&#8217; share.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443443">
				<div id="div-comment-443443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://levicki.blogspot.com/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443443">
			November 17, 2006 at 11:45 pm</a>		</div>

		<p>There is another much simpler thing that can happen so that your mouse doesn&#8217;t move &#8212; broken PS/2 or USB cable.</p>
<p>You can twist it a bit and the mouse starts moving again. I usually throw such mice away and buy a new one but they can be fixed.</p>
<p>It is actually easy, open the mouse and disconnect the cable from the printed circuit board. There are four wires in the cable and they usually break near the entrance into the mouse casing so it is easy to figure out which one is broken by pulling on them one by one until one of them comes out of the cable. Next you have to cut the cable at the appropriate place and solder the wires directly to the PCB. It helps if you have vacuum (suction) pump to remove the connector and clear the holes, even better if you have spare pins and crimping tool. The only important thing is not to mix the wires but since they are colored it is hard to make a mistake.</p>
<p>As for the software side of the problem, I was always astonished by Windows inability to keep GUI responsive regardless of what happens in the system. It amazes me that even though you have all that protective stuff in place one program can still bring the system to its knees or kill it alltogether.</p>
<p>From user perspective, unresponsive GUI is the worst experience in computing especially if you want to multi-task and you have another intensive task running. Not to mention that you can choke Windows to death if you make it start swapping.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-larryosterman odd alt thread-odd thread-alt depth-1" id="comment-443453">
				<div id="div-comment-443453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Larry+Osterman+%5BMSFT%5D' rel='external nofollow' class='url'>Larry Osterman [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443453">
			November 18, 2006 at 12:46 am</a>		</div>

		<p>Raymond, I seem to remember an message you sent many years ago that involved a twitch game that called into the keyboard interrupt handler from the timer interrupt handler to do what Shawn is suggesting.</p>
<p>It was a bad idea back in the Win9x days, it&#8217;s still a bad idea.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443383">
				<div id="div-comment-443383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443383">
			November 17, 2006 at 4:53 pm</a>		</div>

		<p>[A bunch of work happens before that bit gets set since you have to compute which thread&#8217;s bit to set. Hardware input is queued into the raw input thread and the raw input thread does the work. The beeping means that the raw input thread queue is full. I ignored this implementation detail since it wasn&#8217;t relevant to the discussion. -Raymond]</p>
<p>Okay, so there *is*, in fact, one more lower-level input queue involved at the stage of &#8220;The mouse hardware notifies the window manager, &#8216;Hey, I moved left twenty units.'&#8221; &nbsp;I find this to be a significant detail only because there&#8217;s no requirement that any sort of queuing happen at that stage for it to work correctly. &nbsp;The mouse driver could simply fire off an interrupt that says, &#8220;Hey, I changed,&#8221; and all that interrupt does is raise an Event somewhere, and then the window manager would then later notice the Event and query the mouse about its *current* state. &nbsp;This may sound like a weird way to do it, especially since an intervening input change could be lost, but that&#8217;s how a *lot* of video game consoles handle their input, so it&#8217;s not really as weird as it sounds.</p>
<p>So one last question, and then I&#8217;ll let this drop: &nbsp;How large is (was) the low-level input queue? &nbsp;I realize this is an implementation-dependent detail, but I&#8217;m mainly curious because I could never seem to perfectly count how many messages there were before the clicking started. &nbsp;It was somewhere between 100 and 1000, I think, but I could never quite nail it down.</p>
<div class=post>[<i>You can&#8217;t do hit-testing at hardware interrupt time. The internal hardware queue in Windows 95 was 100 events. You owe me 15 minutes of my life. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443413">
				<div id="div-comment-443413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.werkema.com' rel='external nofollow' class='url'>Sean W.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443413">
			November 17, 2006 at 6:21 pm</a>		</div>

		<p>Guess I can&#8217;t quite let it drop, since I apparently wasn&#8217;t clear last time.</p>
<p>[You can&#8217;t do hit-testing at hardware interrupt time.]</p>
<p>I know that; and I wasn&#8217;t suggesting that the processing might have been moved more toward the interrupts, but rather the other direction. &nbsp;The interrupt would be basically a three-line chunk of code that sets a flag saying the mouse&#8217;s status changed, and then the interrupt handler would leave all the remaining details of figuring out *what* changed &#8212; of pulling the data from the mouse and actually dealing with it &#8212; to some other thread. &nbsp;That&#8217;s a perfectly reasonable way to handle input processing, and the difference would&#8217;ve been nearly invisible to the end-user. &nbsp;In that scenario, no queue is required &#8212; just a flag. &nbsp;But some events could be lost, since the mouse doesn&#8217;t get queried for its data immediately after the interrupt fires. &nbsp;Compare the pseudocode:</p>
<p>Method #1:</p>
<p>Mouse Interrupt:</p>
<p>&nbsp; PostInternalInputMessage(QueryMouse())</p>
<p>&nbsp; ret</p>
<p>Window manager thread:</p>
<p>&nbsp; WaitForSingleObject(internal input queue)</p>
<p>&nbsp; switch (event) {</p>
<p>&nbsp; case MOUSE:</p>
<p>&nbsp; &nbsp; &nbsp; mouse_state = ComputeNewMouseState(event.mouse_deltas)</p>
<p>&nbsp; &nbsp; &nbsp; hwnd = FindWindow(mouse_state)</p>
<p>&nbsp; &nbsp; &nbsp; PostMessage(hwnd, mouse_state)</p>
<p>&nbsp; }</p>
<p>Method #2:</p>
<p>Mouse Interrupt:</p>
<p>&nbsp; mouse_deltas += QueryMouse()</p>
<p>&nbsp; SetEvent(mouse_has_input)</p>
<p>&nbsp; ret</p>
<p>Window manager thread:</p>
<p>&nbsp; WaitForMultipleObjects(various input events)</p>
<p>&nbsp; if (mouse_has_input) {</p>
<p>&nbsp; &nbsp; &nbsp; mouse_state = ComputeNewMouseState(mouse_deltas)</p>
<p>&nbsp; &nbsp; &nbsp; mouse_deltas = 0</p>
<p>&nbsp; &nbsp; &nbsp; hwnd = FindWindow(mouse_state)</p>
<p>&nbsp; &nbsp; &nbsp; PostMessage(hwnd, mouse_state)</p>
<p>&nbsp; }</p>
<p>See the difference? &nbsp;Method #1 is how Windows does it, more-or-less. &nbsp;In method #2, there&#8217;s no input queue, and none is required, because the data aggregates by itself at each interrupt; the window manager only needs to collect the data and reset it each time it &#8220;notices&#8221; something happened. &nbsp;Method #2 (or something like it) is used for a variety of input devices on other hardware, and was a semi-popular way of handling button-state-changes on the GameBoy Advance, among other consoles (a lot of developers preferred polling, but some developers used the interrupt too).</p>
<p>[The internal hardware queue in Windows 95 was 100 events.]</p>
<p>That&#8217;s quite a bit shorter than I would&#8217;ve guessed. &nbsp;You must&#8217;ve had pretty fast processing to keep that from overloading. &nbsp;I was thinking it was in the 500-ish ballpark. &nbsp;*shrug*</p>
<p>[You owe me 15 minutes of my life. -Raymond]</p>
<p>I&#8217;ll consider it an even trade for the time I&#8217;ve spent tracing bugs through USER, GDI, and KERNEL. :P</p>
<div class=post>[<i>Doing it your way means that the input manager can lose things like the mouse button being pressed and released in rapid succession if the raw input thread doesn&#8217;t process the events fast enough. Even if you&#8217;re going to discount that a human being can click fast enough to make this noticeable, and that there will be no page faults in the code path (since page faults take time to process), you still have to worry about programmatically-generated input (SendInput). As for the USER, GDI, and KERNEL bugs, I&#8217;m pretty sure I didn&#8217;t create the bug and then ask you personally to investigate it. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com000300008195987d even thread-even depth-1" id="comment-443463">
				<div id="div-comment-443463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Spire' rel='external nofollow' class='url'>Spire</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443463">
			November 18, 2006 at 2:46 am</a>		</div>

		<blockquote><p>
  What does it mean if the cursor doesn&#8217;t move at all when you move the mouse?
</p></blockquote>
<p>It means that on some corner on your desk, a wayward stylus has somehow managed to roll onto your Wacom tablet, locking the mouse position to that precise spot.</p>
<p>Yes, it&#8217;s happened to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443493">
				<div id="div-comment-443493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://db48x.net/' rel='external nofollow' class='url'>db48x</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443493">
			November 18, 2006 at 6:46 am</a>		</div>

		<p>Sean: Mice don&#8217;t use two way communication. The mouse just sends Δx, Δy and the button states to the computer when there&#8217;s a change. I suppose it could be different in the case of usb mice, but those are a recent wrinkle, and frankly I&#8217;ve never seen a mouse that had any reason to accept input from the computer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443503">
				<div id="div-comment-443503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.morganalley.com' rel='external nofollow' class='url'>Dewi Morgan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443503">
			November 18, 2006 at 8:00 am</a>		</div>

		<p>Another reason to queue mouse events may be graphics programs. Assuming I&#8217;m not as horribly mistaken as I opften am.</p>
<p>I recommend a slow, cpu-intensive interpreted GUI language on a slow machine for this experiment. Create something basic: a white gui panel that draws lines between each mousemove event.</p>
<p>If you wiggle your mouse, you get (after several seconds dalay as it slowly draws) the line drawn prettymuch as you drew it, rather than just between the start point and end point. You do not need to build a per-application event queue.</p>
<p>In the days of Dos, many graphics apps would do the straight-line thing instead. I think some early windows apps did this too, though, so it may not be related and I may be talking nonsense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443513">
				<div id="div-comment-443513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erzengel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443513">
			November 18, 2006 at 4:01 pm</a>		</div>

		<blockquote><p>
  Similarly, the NumLock key can indicate just how locked up your system is.
</p></blockquote>
<p>Unless you happen to have a &quot;Microsoft Internet Keyboard&quot;, which turns on/off Numlock even when the computer is frozen (&quot;I bet someone got a raise for that&quot;). Caps/Scroll lock still wait until the computer responds, though.</p>
<blockquote><p>
  and frankly I&#8217;ve never seen a mouse that had any reason to accept input from the computer.
</p></blockquote>
<p>I guess you haven&#8217;t seen a force feedback mouse, then.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443523">
				<div id="div-comment-443523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443523">
			November 18, 2006 at 6:26 pm</a>		</div>

		<p>[frankly I&#8217;ve never seen a mouse that had any reason to accept input from the computer.]</p>
<p>I think that a mouse probably won&#8217;t need to get any input regarding it&#8217;s movement (a direct reply), but I can think of many ways a mouse may need to acquire some set of data from the computer.</p>
<p>Erzengel mentions force feedback, and another example is my wireless Logitech mouse. It needs to receive commands from the mouse software, in addition it has indicators for IM/email notifications (that don&#8217;t work with Outlook or MSN Messenger even though the box clearly says it does&#8211;marketing and engineering not talking with each other I suppose).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443533">
				<div id="div-comment-443533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.michael-puff.de' rel='external nofollow' class='url'>Michael Puff</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443533">
			November 18, 2006 at 9:54 pm</a>		</div>

		<p>I have exactly the described problem when I open a folder with the explorer. But only with my Administrator account. My normal User account works perfecly well.</p>
<p>I took FileMon to see what happens when ever I open a folder:</p>
<p>16 &nbsp; 0.00013242 &nbsp; explorer.exe:3152 &nbsp; OPEN &nbsp; F: 1 System &#8211; Anwendungen</p>
<p>WinXPTools7Zipdesktop.ini &nbsp; FILE NOT FOUND &nbsp; Options: Open &nbsp;Access: All</p>
<p>17 &nbsp; 0.00001928 &nbsp; explorer.exe:3152 &nbsp; QUERY INFORMATION &nbsp; F: 1 System &#8211;</p>
<p>Anwendungen WinXPTools7Zip &nbsp; SUCCESS &nbsp; Attributes: D</p>
<p>18 &nbsp; 0.00011677 &nbsp; explorer.exe:3152 &nbsp; OPEN &nbsp; F: 1 System &#8211; Anwendungen</p>
<p>WinXPTools7Zip &nbsp; SUCCESS &nbsp; Options: Open &nbsp;Access: All</p>
<p>19 &nbsp; 0.00002123 &nbsp; explorer.exe:3152 &nbsp; READ &nbsp; &nbsp;F: 1 System &#8211; Anwendungen</p>
<p>WinXPTools7Zip &nbsp; INVALID DEVICE REQUEST &nbsp; Offset: 0 Length: 24</p>
<p>20 &nbsp; 0.00005531 &nbsp; explorer.exe:3152 &nbsp; OPEN &nbsp; F: 1 System &#8211; Anwendungen</p>
<p>WinXPTools7Zip:{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}:$DATA &nbsp; FILE NOT</p>
<p>FOUND &nbsp;Options: Open &nbsp;Access: All</p>
<p>21 &nbsp; 0.00003604 &nbsp; explorer.exe:3152 &nbsp; OPEN &nbsp; F: 1 System &#8211; Anwendungen</p>
<p>WinXPTools7Zip:SummaryInformation:$DATA &nbsp; FILE NOT FOUND &nbsp; Options: Open</p>
<p>Access: All</p>
<p>22 &nbsp; 0.00003436 &nbsp; explorer.exe:3152 &nbsp; OPEN &nbsp; F: 1 System &#8211; Anwendungen</p>
<p>WinXPTools7Zip:Docf_SummaryInformation:$DATA &nbsp; FILE NOT FOUND &nbsp; Options:</p>
<p>Open Access: All</p>
<p>If I open the same folder with my user account I get no erros, everything works fine.</p>
<p>I haven&#8217;t found out yet what causes the explorer hangs. Any ideas?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443543">
				<div id="div-comment-443543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Mastros</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443543">
			November 19, 2006 at 7:43 am</a>		</div>

		<p>AIM does a global mouse hook in order to count idle time on the system. &nbsp;I assume other messengers do likewise, though I haven&#8217;t investigated them in quite so much detail. &nbsp;Do these not count as low-level hooks? &nbsp;(Also, I feel rel. secure that a fair number of games do low-level mouse hooks, but those probably don&#8217;t count as normal for you.)</p>
<div class="post">[<i>The term &#8220;low-level&#8221; is not one of opinion. It&#8217;s a technical term. WH_MOUSE is a global mouse hook. WM_MOUSE_LL is a low-level mouse hook. (Nevermind that AIM should have used GetLastInputInfo and no hooks at all!) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443553">
				<div id="div-comment-443553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443553">
			November 19, 2006 at 1:05 pm</a>		</div>

		<p>Speaking of DPC floods, it sure would be nice if there were some way of determining what&#8217;s queueing all those DPCs without having to hook up a kernel debugger! Every so often I&#8217;ll wake up my laptop and some device is using up 30% of the CPU with DPCs.</p>
<p>Of course that behavior makes the fan turn on, which makes the battery die even faster, and it cannot be put back to sleep or hibernated, so shutting down is the only way to make it stop. If I knew what piece of hardware/software was causing this, I might be able to figure out how to prevent it in the future.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443563">
				<div id="div-comment-443563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://keyj.s2000.ws/' rel='external nofollow' class='url'>KeyJ</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443563">
			November 19, 2006 at 2:25 pm</a>		</div>

		<p>What about applications that &#8220;lock&#8221; the cursor by calling SetCursorPos(const,const) on each WM_MOUSEMOVE? As far as I see, this is the most common approach for games to make sure that the they always get relative movements. If such a window is active and for some reason didn&#8217;t make the cursor invisible, you can see a cursor that jitters some pixels, but doesn&#8217;t actually move away.</p>
<div class="post">[<i>I specifically excluded such programs from discussion since the issue was not a program actively preventing the mouse from moving but rather some problem inside the system. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443583">
				<div id="div-comment-443583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443583">
			November 19, 2006 at 8:35 pm</a>		</div>

		<p>&gt; A flaky hard drive can have the same effect.</p>
<p>&gt; If the window manager itself takes a page</p>
<p>&gt; fault, it has to wait for the hard drive to</p>
<p>&gt; page in the data. and if the window manager</p>
<p>&gt; happened to be holding a lock when this</p>
<p>&gt; happened, that lock is held across the entire</p>
<p>&gt; I/O operation.</p>
<p>Then the same effect can occur even when the hard drive is in pristine condition. &nbsp;For me this has been a common occurence shortly after awakening from hibernation but not shortly after an ordinary boot (but hibernation is still faster and preferable for lots of reasons). &nbsp;Now I understand why tons of hard disk accesses can cause this effect, thank you. &nbsp;I still think there are more possible reasons though.</p>
<p>Friday, November 17, 2006 4:22 PM by Sean W. </p>
<p>&gt; On Win9x, if you experienced a significant</p>
<p>&gt; crash of the system, sometimes the only way</p>
<p>&gt; that you would know for certain that the</p>
<p>&gt; system was dead was that you&#8217;d waggle the</p>
<p>&gt; mouse around for a while, and then suddenly</p>
<p>&gt; the PC&#8217;s internal speaker would start</p>
<p>&gt; clicking loudly, one click for what seemed to</p>
<p>&gt; be every motion the mouse made. &nbsp;It did this</p>
<p>&gt; for the keyboard, too,</p>
<p>Happens on Windows XP too. &nbsp;The funny thing is that sometimes Windows XP recovers from this condition, though 9x never did (at least not in my experience). &nbsp;If it happens after all of the apps have entered non-responding mode then Windows XP doesn&#8217;t recover from it.</p>
<p>Vista seems to have a change here. &nbsp;After all of the apps enter non-responding mode then Ctrl+Alt+Del plus a wait might bring up an error message about inability to start the task manager instead of just hanging. &nbsp;I don&#8217;t recall hearing those clicks from Vista.</p>
<p>[Raymond Chen:]</p>
<p>&gt; As for the USER, GDI, and KERNEL bugs, I&#8217;m</p>
<p>&gt; pretty sure I didn&#8217;t create the bug and then</p>
<p>&gt; ask you personally to investigate it.</p>
<p>Sean W.&#8217;s message is still visible, and he didn&#8217;t create the mouse event queue and then ask you personally to investigate it, he merely narrated his guess that the size was between 100 and 1000. &nbsp;Your decision to investigate was a far more voluntary decision than his was.</p>
<div class="post">[<i>&#8220;So one last question, and then I&#8217;ll let this drop: How large is (was) the low-level input queue?&#8221; You&#8217;re saying that wasn&#8217;t asking me personally to investigate it? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443613">
				<div id="div-comment-443613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443613">
			November 20, 2006 at 1:01 am</a>		</div>

		<p>&quot;&quot;\&quot;So one last question, and then I&#8217;ll let this drop: How large is (was) the low-level input queue?\&quot;&quot;&quot;</p>
<p>Sorry, my mistake. &nbsp;I owe you 5 minutes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443623">
				<div id="div-comment-443623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Flurgendorf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443623">
			November 20, 2006 at 1:51 am</a>		</div>

		<p>You can ameliorate this to some extent by setting &nbsp;HKLMSYSTEMCurrentControlSetControlSession ManagerMemory ManagementDisablePagingExecutive to 1, this consumes a bit more memory but also ensures that Windows will never have to wait to page in bits of itself from disk.</p>
<div class="post">[<i>Windows needs to page more than code. There&#8217;s also data. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443573">
				<div id="div-comment-443573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miral</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443573">
			November 19, 2006 at 6:59 pm</a>		</div>

		<p>There&#8217;s another way to lock up the mouse, though: get a REALTIME_PRIORITY_CLASS process with some high-priority threads (I&#8217;m not sure exactly how high they need to be) and put one of the threads into an infinite busy-loop. &nbsp;Instant mouse-death.</p>
<p>I *believe* the reason for this is that the mouse handling is done by csrss, and its threads are lower priority than realtime, so if a realtime process is sapping all your CPU then they don&#8217;t get to run and you don&#8217;t get any mouse movement.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443653">
				<div id="div-comment-443653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.ringrose.name' rel='external nofollow' class='url'>Ian Ringrose</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443653">
			November 20, 2006 at 4:58 am</a>		</div>

		<p>If you have a wireless mouse, it may just be that it needs new batteries. &nbsp;</p>
<p>We know get this often as for some reason Dell ships wireless mousse/keyboards on desktops introducing unnecessary points of trouble, and leading to more support calls etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443663">
				<div id="div-comment-443663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443663">
			November 20, 2006 at 6:54 am</a>		</div>

		<blockquote><p>
  &gt;Similarly, the NumLock key can indicate just how locked up your system is.</p>
<p>  Unless you happen to have a &quot;Microsoft Internet Keyboard&quot;, which turns on/off Numlock even when the computer is frozen (&quot;I bet someone got a raise for that&quot;). Caps/Scroll lock still wait until the computer responds, though.
</p></blockquote>
<p>I don&#8217;t think that&#8217;s specific to Microsoft keyboards &#8211; an old Compaq keyboard of mine exhibits the same behaviour &#8211; thus confusing me for some time when an driver upgrade kept locking up CSRSS with an infinite loop in a DPC.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443683">
				<div id="div-comment-443683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443683">
			November 20, 2006 at 9:47 am</a>		</div>

		<p>I noticed that the mouse pointer easily gets stuck (or at least very jittery) if you have pointer shadow enabled, or if you use color (not black-and-white) pointers, and the machine is under heavy load.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443633">
				<div id="div-comment-443633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443633">
			November 20, 2006 at 3:32 am</a>		</div>

		<p>&gt; [Windows needs to page more than code.</p>
<p>&gt; There&#8217;s also data. -Raymond]</p>
<p><a href="http://www.microsoft.com/technet/prodtechnol/windows2000serv/reskit/regentry/29931.mspx?mfr=true" target="_new" rel="nofollow">http://www.microsoft.com/technet/prodtechnol/windows2000serv/reskit/regentry/29931.mspx?mfr=true</a></p>
<p>says:</p>
<p>* &nbsp;* Tip</p>
<p>* &nbsp;Setting this value to 1 is useful when</p>
<p>* &nbsp;debugging drivers, because all of the code</p>
<p>* &nbsp;and data is always memory resident.</p>
<p>OK, it doesn&#8217;t quite say that all of the code and data is always memory resident even when not debugging drivers, but it&#8217;s pretty close. &nbsp;I think I&#8217;ve redeemed the 5 minutes I owed you.</p>
<div class="post">[<i>Interesting. I wonder how much kernel data that switch covers. (Win32 memory is allocated in a different way from regular driver memory.) No wait, I don&#8217;t wonder because I don&#8217;t care. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443933">
				<div id="div-comment-443933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-443933">
			November 20, 2006 at 7:19 pm</a>		</div>

		<p>&gt; No wait, I don&#8217;t wonder because I don&#8217;t care.</p>
<p>I have no complaint about your cynicism. &nbsp;It is well earned. &nbsp;But now I wonder, when you complained about my cynicism, where were your complaints coming from?</p>
<p>(You are under no obligation to answer. &nbsp;You can leave me wondering.)</p>
<div class="post">[<i>That wasn&#8217;t cynicism. It was disinterest. I don&#8217;t want to spend however many months it takes to learn kernel mode programming to be able to investigate a question whose answer is irrelevant to me. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-444653">
				<div id="div-comment-444653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ahxhlq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-444653">
			November 23, 2006 at 8:34 pm</a>		</div>

		<p>&#8220;Our slogan is: you can talk when you need!Thare is no problem what we can not solve.&#8221;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-444703">
				<div id="div-comment-444703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://levicki.blogspot.com/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061117-03/?p=28973#comment-444703">
			November 23, 2006 at 11:16 pm</a>		</div>

		<p>&quot;frankly I&#8217;ve never seen a mouse that had any reason to accept input from the computer&quot;</p>
<p>Just wait to see this one:</p>
<p><a rel="nofollow" target="_new" href="http://www.razerzone.com/Products/Gaming-Mice/Razer-Diamondback-Gaming-Mouse/" rel="nofollow">http://www.razerzone.com/Products/Gaming-Mice/Razer-Diamondback-Gaming-Mouse/</a></p>
<p>It has firmware updates too.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

