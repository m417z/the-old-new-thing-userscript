<html>
<head>
<title>The __fortran calling convention isn't the calling convention used by FORTRAN</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The __fortran calling convention isn&#8217;t the calling convention used by FORTRAN</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 22, 2010 / year-entry #351</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>36</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Although the Microsoft C compiler supports a calling convention called __fortran, that's just what the calling convention is called; its relationship with the FORTRAN programming language is only coincidental. The __fortran keyword is now just an old-fashioned synonym for __stdcall. Various FORTRAN compilers use different calling conventions; the one I describe here applies to the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Although the Microsoft C compiler supports a calling convention called
<code>__fortran</code>,
that's just what the calling convention is called;
its relationship with the FORTRAN programming language is only coincidental.
The <code>__fortran</code> keyword is now just an old-fashioned
synonym for <code>__stdcall</code>.
</p>
<p>
Various FORTRAN compilers use different calling conventions;
the one I describe here applies to the now-defunct
Microsoft Fortran PowerStation.
</p>
<p>
Fortran Powerstation pushes parameters on the stack right-to-left,
with callee-cleanup.
(So far, this matches
<code>__fortran</code> aka <code>__stdcall</code>.)
Function names are
<a HREF="http://msdn.microsoft.com/en-us/library/aa278674(VS.60).aspx">
converted to all-uppercase, with an underscore
at the beginning and <code>@n</code> appended</a>,
where <code>n</code> is the number of bytes of parameters.
(This still matches <code>__stdcall</code> aside from the uppercase
conversion.)
</p>
<p>
As for how the parameters are passed, well, that's where things
get weird.
FORTRAN natively
<a HREF="http://msdn.microsoft.com/en-us/library/aa294334(VS.60).aspx">
passes all parameters by reference</a>.
This is the source of a famous classic FORTRAN bug known as
<i>constants aren't</i>.
</p>
<pre>
      PROGRAM MYSTERY
      CALL MAGIC(1)
      PRINT *, 'According to the computer, 3 + 1 is ', ADDUP(3, 1)
      END

      FUNCTION ADDUP(I, J)
      ADDUP = I + J
      END

C     What does this subroutine actually do?
      SUBROUTINE MAGIC(I)
      I = 9
      RETURN

      END
</pre>
<p>
(It's been a long time since I've written a FORTRAN program,
so I may have gotten some of the details wrong,
but any errors shouldn't detract from the fundamental issue.)
</p>
<p>
When you run this program, it says
</p>
<pre>
According to the computer, 3 + 1 is 12
</pre>
<p>
How did that happen?
We called a function that adds two numbers together,
and instead of getting 4, we get 12?
</p>
<p>
The reason is the subroutine <code>MAGIC</code>:
We passed it the constant <code>1</code>,
and since all FORTRAN parameters are passed by reference,
the assignment <code>I&nbsp;=&nbsp;9</code>
<i>modifies the constant&nbsp;1</i>.
In C:
</p>
<pre>
int One = 1;
int Three = 3;
int Nine = 9;

void Magic(int *i) { *i = Nine; }
int AddUp(int *i, int *j) { return *i + *j; }

void main()
{
 Magic(&One);
 printf("According to the computer, 3 + 1 is %d\n",
        AddUp(&amp;Three, &amp;One));
}
</pre>
<p>
Since <code>Magic</code> modified the constant <code>One</code>,
any further use of the constant&nbsp;1 ends up using the value&nbsp;9!
(According to the FORTRAN standard,
modifying a constant results in undefined behavior.)
</p>
<p>
Okay, back to calling conventions.
Other significant differences between C and FORTRAN:
In FORTRAN,
<a HREF="http://msdn.microsoft.com/en-us/library/aa293547(VS.60).aspx">
array indices begin at 1, not 0,
and arrays are stored in column-major order</a>
rather than row-major as in C.
</p>
<p>
<code>COMPLEX</code> variables in FORTRAN
<a HREF="http://msdn.microsoft.com/en-us/library/aa296568(VS.60).aspx">
are stored as two floating point numbers</a>
(corresponding to the real and imaginary components).
</p>
<p>
Functions which return <code>COMPLEX</code> or
<a HREF="http://msdn.microsoft.com/en-us/library/aa236488(VS.60).aspx">
<code>CHARACTER*(*)</code></a>
are internally rewritten as subroutines where the location to store the
return value is passed as a hidden first parameter.
(This is analogous to how C returns large structures.)
</p>
<p>
The final commonly-encountered
weirdness of FORTRAN is that <code>CHARACTER*n</code> data types
(which are used to hold strings) are
<a HREF="http://msdn.microsoft.com/en-us/library/aa236488(VS.60).aspx">
passed as <i>two</i> parameters</a>:
The address of the character buffer,
followed by the size of the buffer&nbsp;(n).
Note that FORTRAN <code>CHARACTER*n</code> variables are
fixed-length;
if you assign a string shorter than the buffer,
it is padded with spaces.
There is no null terminator.
</p>
<p>
Anyway, I sort of got carried away with the FORTRAN calling convention.
It's definitely more complicated than just sticking
<code>__fortran</code> in front of your function.
But at least the <code>__fortran</code> keyword takes care of the
part that can't be expressed in C.
The rest you can manage on your own.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (36)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-883723">
				<div id="div-comment-883723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mott555</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883723">
			December 22, 2010 at 7:32 am</a>		</div>

		<p>FORTRAN is way before my time so thanks for the article, I actually find that fascinating! But I bet it leads to some really strange and hilarious bugs in actual FORTRAN applications, especially if newbie programmers are involved who don&#39;t understand the calling conventions and are used to more modern languages.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883733">
				<div id="div-comment-883733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timbo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883733">
			December 22, 2010 at 7:44 am</a>		</div>

		<p>The shocking fact for me isn&#39;t that they pass the &quot;constants&quot; by reference.</p>
<p>It is that the &quot;1&quot; that seems to be a numeric literal in the eyes of a C programmer, I could only describe as &quot;implicitely defined local(?) variable with the name of the literal, pre-initialized to its numeric value&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883743">
				<div id="div-comment-883743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883743">
			December 22, 2010 at 7:59 am</a>		</div>

		<p>With every article on the subject of string handling I lose more respect for the C designers&#39; string handling decision. This article is no exception.</p>
<p>On the other hand, the ‘constants aren&#39;t’ bug is pretty atrocious. Although it does bring back fond memories of a similar issue in some C compilers concerning string constants.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883753">
				<div id="div-comment-883753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883753">
			December 22, 2010 at 8:06 am</a>		</div>

		<p>If you really want to complicate things, check out the FORTRAN EQUIVALENCE statement. It allowed you to say that a bunch of variables shared the same memory. So you could change a variable of one type and see it reflected in a variable of another type that had been made &quot;equivalent&quot;. APL, now that was a language :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883763">
				<div id="div-comment-883763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883763">
			December 22, 2010 at 8:11 am</a>		</div>

		<p>Ok, now I understand the second part of Osborn&#39;s Law: &quot;Variable&#39;s won&#39;t, Constants aren&#39;t&quot; :)</p>
<p>But what about the first part? Where does that come from?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zamescurran odd alt thread-odd thread-alt depth-1" id="comment-883773">
				<div id="div-comment-883773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/James+Curran' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883773">
			December 22, 2010 at 8:25 am</a>		</div>

		<p>@Joseph Koss: Actually, the default base in Basic is 0. &nbsp;It just most basic programs just ignore the zero element. &nbsp;</p>
<p>In the first Fortran system I had to work on, I run into a real-world MAGIC() function.</p>
<p>If was the applications standard formatted output routine it took a variable number of pairs of parameters, e.g., something like:</p>
<p>&nbsp; PRINT(100, &quot;first num:&quot;, &nbsp;101, X, &nbsp; 901, 30, 100, &quot;Second Num:&quot;, 102, Y, &nbsp;902, pos, 901, 132-pos, 100, &quot;more text&quot;)</p>
<p>Each pair would be a code, followed by the data to act on. &nbsp;In this example, &quot;100&quot; means &quot;Print next parameter as text&quot;, 101 means &quot;format as integer (aka fixed)&quot;, &amp; 102, &quot;format as float&quot;. &nbsp;The interesting bit come with the 900 codes. &nbsp;901 would mean &quot;skip to the column position given by next parameter&quot;, and 902 means &quot;set next parameter to the current column position&quot;. &nbsp;Hence a simple mistake of 902 where you meant 901 could redefine a constant. &nbsp;(of course, as the problem wouldn&#39;t show up until the next time you used that particularly number, have fun debugging that!)</p>
<p>(nit-pickers will of course note that there is a difference between fixed &amp; integer)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883783">
				<div id="div-comment-883783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883783">
			December 22, 2010 at 8:27 am</a>		</div>

		<p>@Tim: &nbsp;Didn&#39;t you just describe a C/C++ union (while it may be undefined to set one union member then read another, your description of Fortran&#39;s EQUIVALENCE sounds like the standard implementation of that behavior in a union)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883793">
				<div id="div-comment-883793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883793">
			December 22, 2010 at 8:31 am</a>		</div>

		<p>In general, you call Fortran functions in a DLL from some other language. It would be pretty perverse (though perfectly possible) to write a front-end GUI in Fortran that calls number-crunching functions in a Visual Basic DLL…</p>
<p>Anyway, I generally find it is much, much easier to force the Fortran compiler to use a &#39;normal&#39; calling convention for the functions exported from the DLL. It means a little bit of extra work sometimes marshalling parameters of these exported functions in the Fortran code, but it saves a lot of headaches in the long run.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zamescurran even thread-even depth-1" id="comment-883803">
				<div id="div-comment-883803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/James+Curran' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883803">
			December 22, 2010 at 8:33 am</a>		</div>

		<blockquote><p>
  &gt; With every article on the subject of string handling I lose more respect for the C designers&#39; string handling decision.
</p></blockquote>
<p>@Anon, &nbsp;Actually, it wasn&#39;t that bad, for the time (i.e., the time of extremely low RAM and disk sizes.).</p>
<p>Note that because some strings would go beyond 255 characters, if a size is used, it would have to be at least 16-bits for ALL strings. &nbsp;With ASCIIZ string, all strings can use an 8-bit terminator. &nbsp;Further, most uses of a string involve iterating through it anyway, so having a separate size isn&#39;t buying you much.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zamescurran odd alt thread-odd thread-alt depth-1" id="comment-883813">
				<div id="div-comment-883813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/James+Curran' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883813">
			December 22, 2010 at 8:41 am</a>		</div>

		<blockquote><p>
  &gt; Fortran&#39;s EQUIVALENCE sounds like the standard implementation of that behavior in a union
</p></blockquote>
<p>@SimonRev Only accidentally. &nbsp;The actually GOAL of EQUIVALENCE is to make the variables public, i.e., this list of variables I use in this module are the same as that list of variables I use in that module.</p>
<p>So, it&#39;s not like a union where you have an int &amp; a pointer. Imagine a union made up of two structs (each with many elements) The names of the elements aren&#39;t expected to match &#8212; but the types are. It&#39;s only if you screw up the order does freakiness occur.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883823">
				<div id="div-comment-883823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883823">
			December 22, 2010 at 9:50 am</a>		</div>

		<p>FORTRAN is old, so memory for compiled binaries was kind of scarce. That is why constant &#39;1&#39; from call to MAGIC has the same address as constant &#39;1&#39; passed to ADD function. FORTRAN compiler simply remembers the VALUE of the constant, so when another such constant appears in code &#8212; it simply finds the first instance and re-uses the same address instead of reserving more memory. C compiler can do something similar with constant strings, but it is optional. I wonder if that code will produce same results in modern FORTRAN compiler, say Intel Fortran.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883833">
				<div id="div-comment-883833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883833">
			December 22, 2010 at 10:02 am</a>		</div>

		<p>Wow, that brings back memories (and some nightmares as well). &nbsp;I had to write a C interface wrapper around a third party FORTRAN library back in the dark ages. &nbsp;It was all sorts of fun trying to figure all of these things out without any documentation on the calling convention. &nbsp;The fact that the machine we were running was an old style VAX just made it more interesting. &nbsp;:-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883853">
				<div id="div-comment-883853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883853">
			December 22, 2010 at 10:54 am</a>		</div>

		<p>@ZammesCurran:</p>
<p>Most of the Structured Basics that I have seen for the past two decades or so have allowed ARBITRARY bases..</p>
<p>Dim foo(13 To 37)</p>
<p>..or even..</p>
<p>x = 778</p>
<p>y = 779</p>
<p>Dim bar(x To y)</p>
<p>This is much worse than having a base of 1. A function could be passed an array of literally any base (and any number of dimensions too.. another issue)</p>
<p>VB.NET enforces a 0 base, and dimensionality is explicit.. but VB6/VBA is still much more popular in the business world (I would go out on a limb and say that globally, more lines of VBA code have been written than any other language.. due to the complete dominance of MS Office)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883863">
				<div id="div-comment-883863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CarlD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883863">
			December 22, 2010 at 11:17 am</a>		</div>

		<p>@AsmGuru62 There&#39;s more (and less) to it than simply memory being scarce: &nbsp;On the machines typical of the age when Fortran was created, addresses were smaller than values, so storing the constant once and passing it by address actually saved memory. &nbsp;For example, on one series of CDC machines that I worked on, an Integer occupied 60 (or 64) bits of memory, while an address was only 18 bits.</p>
<p>Today it&#39;s frequently the other way around &#8211; addresses are larger than the stored value, so passing by address actually uses more memory instead of less.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883873">
				<div id="div-comment-883873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883873">
			December 22, 2010 at 11:37 am</a>		</div>

		<p>Humans have counted lists of things starting at 1 for hundreds of thousands of years (or thereabouts). &nbsp;Starting arrays at 0 is convenient for array indexing in computer code (fetching from the starting address plus (index times item size)), but it&#39;s not the natural place to start counting a list of things. &nbsp;If I tell you that Mary has 5 apples, and Bill takes two, I wouldn&#39;t number Mary&#39;s apples from 0 to 4. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883883">
				<div id="div-comment-883883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Brooks</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883883">
			December 22, 2010 at 12:05 pm</a>		</div>

		<p>This brings back a horrible memory: the fact that the early versions of Primos (the Prime Computer operating systems) were written in Fortran. Shudder&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883913">
				<div id="div-comment-883913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lefty</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883913">
			December 22, 2010 at 12:56 pm</a>		</div>

		<p>So do I understand this right?</p>
<p>The __fortran calling convention is really the __stdcall calling convention, but it&#39;s not the calling convention that the FORTRAN compiler (at least the now-defunct Microsoft Fortran PowerStation) uses?</p>
<p>Do current FORTRAN compilers use the __fortran calling convention? &nbsp;Or do you have to resort to custom assembly routines to interface FORTRAN and C on Windows?</p>
<p>These are really rhetorical questions, since I personally deal with these issues by not doing anything with FORTRAN anymore, thankfully. &nbsp;I don&#39;t even know if you&#39;re still supposed to write &quot;FORTRAN&quot; in all uppercase. And I can&#39;t be bothered with looking it up on Google.</p>
<div class="post">[<i>The __fortran calling convention establishes a FORTRAN-compatible stack convention, but you have to finish the job yourself by passing the parameters in a FORTRAN-compatible way. __fortran just makes the whole thing possible. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883923">
				<div id="div-comment-883923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Poochner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883923">
			December 22, 2010 at 1:57 pm</a>		</div>

		<p>@CarlD (shudder), the days of 6-bit bytes, or variable-length characters if you want both upper and lower case, and colons being strong magic.</p>
<p>Fortran&#39;s not quite dead, just long in the tooth. For example, the GCC project includes a Fortran-95 compiler. &nbsp;The web page says it includes legacy Fortran-77 support, even though the g77 binary has been dropped.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zamescurran even thread-even depth-1" id="comment-883933">
				<div id="div-comment-883933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/James+Curran' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883933">
			December 22, 2010 at 2:02 pm</a>		</div>

		<p>@Joseph K:</p>
<p>The point I was make is that if you jsut say</p>
<p>DIM X(10)</p>
<p>It&#39;s the same as</p>
<p>DIM X(0 TO 10)</p>
<p>while many vb programmers believe it is</p>
<p>DIM X(1 TO 10)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883943">
				<div id="div-comment-883943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Trillian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883943">
			December 22, 2010 at 2:21 pm</a>		</div>

		<p>class Mystery</p>
<p>{</p>
<p>&nbsp; &nbsp;static void Main()</p>
<p>&nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Magic(&quot;3&quot;);</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(&quot;According to the computer, &#39;3&#39; concatenated with &#39;1&#39; is &quot; + Concat(&quot;3&quot;, &quot;1&quot;));</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;static string Concat(string i, string j)</p>
<p>&nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;return i + j;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;// &nbsp;What does this method actually do?</p>
<p>&nbsp; &nbsp;static unsafe void Magic(string i)</p>
<p>&nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;fixed (char* ptr = i) ptr[0] = &#39;9&#39;;</p>
<p>&nbsp; &nbsp;}</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883713">
				<div id="div-comment-883713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883713">
			December 22, 2010 at 7:20 am</a>		</div>

		<p>I think I could tolerate everything but arrays being 1-based. I suppose its better than leveraging support of an arbitrary base (BASIC, etc..) but not by much, since most often the usage of an arbitrary base *IS* 1.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883963">
				<div id="div-comment-883963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883963">
			December 22, 2010 at 5:32 pm</a>		</div>

		<p>@Joseph Koss: I&#39;ve seen people writing VB code using &quot;For i = LBound(arrX) to UBound(arrX)&quot; pattern. I guess I know the reason now&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883973">
				<div id="div-comment-883973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883973">
			December 22, 2010 at 7:45 pm</a>		</div>

		<p>Today&#39;s post is either an eerie coincidence, Raymond, or you read the ancient Usenet newsgroup alt.folklore.computers like I do.</p>
<p>A couple of days ago, someone started this a.f.c thread asking about the &quot;fortran&quot; keyword in K&amp;R C:</p>
<p>&nbsp;<a rel="nofollow" target="_new" href="http://groups.google.com/group/alt.folklore.computers/browse_thread/thread/9b11f1503f888f53" rel="nofollow">groups.google.com/&#8230;/9b11f1503f888f53</a></p>
<p>&#8230;and notice who the first reply is from. &nbsp;(That&#39;s the sort of reason I keep reading that newsgroup.) &nbsp;Then someone brings up the __fortran keyword in MSC, which actually matches the use of the &quot;fortran&quot; keyword on VMS: &quot;use the OS calling convention instead of the C one.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883983">
				<div id="div-comment-883983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brooks Moses</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883983">
			December 22, 2010 at 9:35 pm</a>		</div>

		<p>As a slightly-curmudgeonly Fortran programmer (and unabashed Fortran apologist), I want to point out that this particular bug is almost more of an urban legend at this point than a bug &#8212; I don&#39;t think it affects any Fortran compilers written since, say, Windows 1.0 entered development, and probably not many since 1970. &nbsp;I certainly have never managed to get it to &quot;happen&quot; on any of the compilers I&#39;ve used. &nbsp;Aside from a painful lack of error-checking that&#39;s long-since been rectified, it requires a confluence of a number of implementation choices like constant pools that are no longer common, and certainly are not required by the Fortran language.</p>
<p>(A digression there, since Timbo found the effects of using a constant pool odd &#8212; this isn&#39;t a Fortran thing, but a general implementation detail that could affect any language. &nbsp;It came about on machines that didn&#39;t have an easy way to express in machine code &quot;load this literal number into memory&quot;. &nbsp;To do that, you&#39;d have to construct the value with several instructions &#8212; load this 8-bit literal, shift it 8 bits, load another 8-bit literal, add them, repeat until all 32 bits are loaded, or somesuch like that. &nbsp;And so the compiler would instead find all the literal numbers used in the code, set up a memory pool to contain them, and initialize them all once at the beginning of the program. &nbsp;Also, if your address space is smaller than your constant values, it saves code space to do it that way.)</p>
<p>I&#39;d also note the technicality that &quot;Fortran passes everything by reference&quot; is also a not-entirely-accurate generalization; what Fortran (as a standardized language) does is allow a function to modify any of its arguments, and its up to the particular Fortran implementation how exactly that works. &nbsp;You can do that with pass-by-reference, but you can also do it with pass-by-value-and-return, or other methods. &nbsp;And, since Fortran 90, the programmer can also annotate arguments as &quot;intent(in)&quot; to indicate that they aren&#39;t going to modify them, and the compiler can consider that in implementing the calling interface.</p>
<p>Also, to answer Lefty&#39;s question about linking Fortran and C, the more recent Fortran standards have official ways to link C functions, which addresses part of this. &nbsp;Otherwise, it depends on the compiler, but for most compilers it&#39;s reasonably straightforward if tedious. &nbsp;Finally, starting with Fortran 90, the official capitalization is &quot;Fortran&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-884003">
				<div id="div-comment-884003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884003">
			December 22, 2010 at 10:03 pm</a>		</div>

		<p>&quot;The last two Fortran Standards have a requirement that Fortran allow calls directly to C&quot; In what way does that remove the need for this? You didn&#39;t mention if there is a requirement for Fortran to allow being called from C.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-884013">
				<div id="div-comment-884013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Burak KALAYCI</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884013">
			December 23, 2010 at 3:22 am</a>		</div>

		<p>It is my understanding that an index starts at 1, an offset starts at 0. If something that looks like an index starts at 0, then there is something wrong, however convenient it may seem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-884023">
				<div id="div-comment-884023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884023">
			December 23, 2010 at 4:04 am</a>		</div>

		<p>&quot;Since Magic modified the constant One, any further use of the constant 1 ends up using the value 9!&quot;</p>
<p>TRWTF is stuff like that.</p>
<p>I&#39;ve heard of people doing &quot;if (1 == i) { &#8230; }&quot; in order to get the warning when/if they do &quot;if (1 = i) { &#8230; }&quot;. Get it the other way round, and i becomes 1. Like this, 1 cannot become i and there is much wailing and gnashing of teeth. Except with fortran.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883993">
				<div id="div-comment-883993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">katchu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-883993">
			December 22, 2010 at 9:38 pm</a>		</div>

		<p>Almost nothing in the calling convention discussed here is Standard Fortran. &nbsp;(Including the spelling which changed to Fortran about 1977, 33 years ago). I understand we are talking about MS Powerstation Fortran which had many excellent attributes not the least of which was that it was nowhere near any Fortran standard in its implementation. The calling convention under discussion is a terminology invented by some C programmers to allow C and Fortran program procedures to call one another. It has nothing to do with the Fortran Language _per se_ (It never was part of the Fortran standard but was an implementation-dependent convention made of necessity if not desperation). &nbsp;The last two Fortran Standards have a requirement that Fortran allow calls directly to C, so these non-standard &quot;standard&quot; calling conventions (ouch) are actually quite foreign to Fortran nowadays.</p>
<p>For the last 20 years (since Fortran 90) a *conforming* program can&#39;t modify constants. Indeed the intent to modify (or not) any dummy arguments (variable or not) must be expressed explicitly with interface blocks or implicitly using modules with argument definition flourishes. Also, the implementation details of how a subroutine vs. function works is processor-dependent. And whether variables are passed by reference or value is processor-dependent. Processor-dependent means it is up to the C programmers who write the Fortran compiler and is nowhere defined in the Fortran Standard. </p>
<p>&quot;Ye Olde FORTRAN&quot; had arrays that began with 1 and that is still the default, however this is certainly not true now, and not for 20 years. (To be fair C today is NOT K&amp;R &nbsp;C either). </p>
<p>&quot;Ye Olde FORTRAN&quot; was not &quot;Highly Evolved&quot;, however anyone with eyes to read the 1990, 1995, 2003 and 2008 Fortran Standards will perceive significant evolution. </p>
<p>Zames &quot;Print&quot; statement conforms to no Fortran Standard I&#39;ve ever seen and he shows something that 1) he did not understand or recall correctly, or 2) was not a Fortran Print statement but a user-defined function or ungodly compiler extension, or 3) worse. The Fortran Format statement that he might be referencing is a language unto itself (shudder).</p>
<p>The Gnu Compiler Collection does include a Fortran compiler, named gfortran. (Do not confuse this with g95 which is a different compiler). gfortran differs greatly from 1977 Fortran. It implements the Fortran 95 Standard, most of the Fortran 2003 Standard and (I believe) might implement some Fortran 2008 functionality. &nbsp;It can compile proper Fortran 77 programs for compatibility purposes, given that there are several million lines of quite efficient old Fortran code around.</p>
<p>FORTRAN 66 is indeed &quot;long in the tooth&quot; but then so is Kernighan and Ritchie C. I don&#39;t suppose anyone would compare K&amp;R C to the latest C# language definition, so let&#39;s not do the same with FORTRAN 66 to any other current language (OR to modern Fortran).</p>
<p>Fortran continues to exist because it is an evolving language, adapting to the needs of its user base. &nbsp;To be sure other languages have been created to more promptly deal with inadequacies in existing languages (including Fortran, C, C++, Java, whatever). &nbsp;There must be something positive to be said of Fortraners who persist using the same language name while completely changing the language itself. &nbsp;Myself, I gave up at Fortran 95.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zamescurran even thread-even depth-1" id="comment-884033">
				<div id="div-comment-884033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/James+Curran' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884033">
			December 23, 2010 at 7:02 am</a>		</div>

		<p>@katchu: The function I described was definitely user-defined. &nbsp;I only described some 1xx and 9xx codes, but there were also 2xx, 3xx, 4xx etc codes which formatted our internal use data structures in particular ways.</p>
<p>SO, it was the standard method of output used by applications in that company (this was circa 1985, and they tended to be a bit behind the technology curve, so it may not have been even a full Fortran77 compiler).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-884053">
				<div id="div-comment-884053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884053">
			December 23, 2010 at 8:43 am</a>		</div>

		<p>Fortran 77 for Engineers and Scientists. First book about a language I ever used at Uni&#8230; 18 years ago amidst talk of Fortran 90-something. Gotta love a language that advertises its age, like personalised license plates. That&#39;s awesome Trillian. Even if one has to explicitly allow unsafe in the project settings the fact you can do Concat(&quot;3&quot;, &quot;1&quot;)&#8230;</p>
<p>VS2010: According to the computer, &#39;3&#39; concatenated with &#39;1&#39; is 91.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-884083">
				<div id="div-comment-884083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884083">
			December 23, 2010 at 9:55 am</a>		</div>

		<p>off-topic, probably&#8230;</p>
<p>I wonder how are these 1-based indexes are implemented? Like, when array access happens by index, stored in another variable: A(I) &#8211; does it mean that decrement of index value happens just before memory access? Or, ALL Fortran arrays have a &#39;spare&#39; element at the beginning of each array dimension, so index may be not incremented, but used as is? First approach will slow down the code, second will increase memory footprint.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-884093">
				<div id="div-comment-884093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Burak KALAYCI</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884093">
			December 23, 2010 at 10:33 am</a>		</div>

		<p>@AsmGuru62 I think implementation details are not that important. Maybe array address is stored so that it points to -1st offset (as if there were a 0th element but in fact there isn&#39;t) and so there&#39;s no leaking disadvantage.</p>
<p>1-based index values are the natural ones. If a language implements this, it is a nice feature &#8211; nothing else.</p>
<p>High level languages do have disadvantages because of trade-offs. This is expected. A feature like 1-based index values IMHO brings a language way higher (closer to humans) than crap like garbage collection.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-884113">
				<div id="div-comment-884113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RonBass</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884113">
			December 23, 2010 at 11:31 am</a>		</div>

		<p>As someone who started writing FORTRAN (FORTRAN II and IV) code in the mid 60&#39;s, this post is seriously amusing. &nbsp;Back in the day, there was no stack, which had at least three important consequences.</p>
<p>The first was that all local variables in a function/subroutine were &quot;static&quot;, in that they remembered their values from call to call. &nbsp;It was quite common for a routine to have two entries, the first of which would be called to set up the local variable values that would then be used in calls to the second entry. &nbsp;A lot of engineering and physics code that was still in use in the late 80&#39;s still used this &quot;feature&quot;.</p>
<p>The second was the way that arguments and the return address were passed to a routine. &nbsp;With no stack, the return address had to be stored in the called routine. &nbsp;On the IBM mainframes of the 60&#39;s, the machine code used for a call to a routine stored the return address in the first word of the routine and returned by jumping to this address (with a suitable offset). &nbsp;The offset took account of the fact that the addresses of the arguments were stored immediately after the call to the routine.</p>
<p>The third was that recursion was strictly illegal. &nbsp;Since a second call to a routine would cause the return address to for the first call be overwritten, there was no way to exit the routine. Programmers of the time learned to use iteration instead of recursion.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-884163">
				<div id="div-comment-884163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">katchu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884163">
			December 24, 2010 at 1:11 am</a>		</div>

		<p>@Random832. I don&#39;t know about anything in the Fortran Standard that specifically addresses Fortran being called by C programs. This is my ignorance&#8211;as I said I bailed out at Fortran 95 and this facility came in with Fortran 2003. (sigh). I wrote a lot of Fortran wrappers to Win32 functions using compiler-specific facilities (Thanks, Raymond, you were a great help with that). I seldom wrote Fortran code to be called by C programs. (Probably because I&#39;d most likely use C in that case anyway ;^).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-884153">
				<div id="div-comment-884153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">katchu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884153">
			December 24, 2010 at 12:56 am</a>		</div>

		<p>@ZamesCurran. Yeah, I worked with some old Fortran like that. I often wrote my own I/O routines in an attempt to simplify formatting within some project&#39;s specifications. The challenge was to make it *simpler* and *less* error prone than what I&#39;d do with the native Fortran I/O methods. I commiserate with you on that horrid convention you were forced to use. I put myself in that box a few times.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-884423">
				<div id="div-comment-884423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kallee</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101222-00/?p=11943#comment-884423">
			December 27, 2010 at 6:45 am</a>		</div>

		<p>fortran calling convention is indistinguishable from pascal</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

