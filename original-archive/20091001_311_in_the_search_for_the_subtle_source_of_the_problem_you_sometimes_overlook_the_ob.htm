<html>
<head>
<title>In the search for the subtle source of the problem, you sometimes overlook the obvious one</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>In the search for the subtle source of the problem, you sometimes overlook the obvious one</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 1, 2009 / year-entry #312</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>36</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer was encountering a problem with lots of duplicate GUIDs. How is that possible? The whole point of the GUID generation algorithm is to work hard to avoid duplication. Was one of the fundamental assumptions of the algorithm broken? Maybe there was a duplicate MAC? Was the clock regressing? One of my colleagues pointed...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>A customer was encountering a problem with lots of duplicate GUIDs. How is that possible? The whole point of <a href="http://blogs.msdn.com/oldnewthing/archive/2008/06/27/8659071.aspx"> the GUID generation algorithm</a> is to work hard to avoid duplication. Was one of the fundamental assumptions of the algorithm broken? Maybe there was a duplicate MAC? Was the clock regressing?</p>
<p> One of my colleagues pointed out that in the search for the subtle source of the problem, you sometimes overlook the obvious one. In fact, this is the most common source of problems with so-called duplicate GUIDs. As he so tersely puts it: "A GUID can easily be duplicated by simply copying it." </p>
<p> In other words, you have a duplicate GUID because you duplicated the GUID. This can happen, for example, if you have a <code>Clone</code> method on an object which creates an exact duplicate of the object. Since the <code>GUID</code> is a property of the object, it too gets cloned. Then you add the clone to the same database as the original. </p>
<p> Boom, instant duplicate. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (36)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-773173">
				<div id="div-comment-773173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773173">
			October 1, 2009 at 12:32 pm</a>		</div>

		<p>We have some GUIDs in a SQL database. &nbsp;We have more than one development database, and a QA database, and a user-acceptance-testing database, and a user-training database (with some &quot;anonymized&quot; data), and a production database. &nbsp;</p>
<p>Some of the GUIDs are the same across these databases, even when they are used as record IDs, since they mean the same things from database to database. &nbsp;And some of the GUIDs are created on the fly and are not meant to be the same anywhere.</p>
<p>It&#8217;s tempting to dismiss using GUIDs as database keys, since they are &quot;so long&quot; (128 bits), but once you have realized that if someone passes you an ID and they claim it&#8217;s a customer number, and you can tell them no, it&#8217;s not a customer number, it&#8217;s an order number, then you may realize their value. &nbsp; You can&#8217;t do that if all tables have IDs that are auto-incrementing numbers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773223">
				<div id="div-comment-773223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773223">
			October 1, 2009 at 3:01 pm</a>		</div>

		<p>Reminds me of the time somebody copy-pasted some code that he considered &quot;boiler plate&quot;. &nbsp;It contained a GUID that really had to be unique for multiple of these &quot;boiler plate&quot; sections to coexist. &nbsp;This was, of course, realized much later when it actually became a problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773253">
				<div id="div-comment-773253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773253">
			October 1, 2009 at 5:01 pm</a>		</div>

		<p>So what you&#8217;re saying is that the subtle source of the problem is that dummy in front of the computer, otherwise known as a PEBKAC error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773263">
				<div id="div-comment-773263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773263">
			October 1, 2009 at 5:14 pm</a>		</div>

		<p>There&#8217;s at least a few different &quot;versions&quot; of the globally (allegedly) unique ID &#8211; and thanks to privacy concerns, the MAC address is no longer a popular choice.</p>
<p>And unless you have a source of uniqueness, it actually is possible (though unlikely) to get duplicate IDs generated.</p>
<p>Dumb developers just use &quot;the GUID generation algorithm&quot; and expect it to work. Good developers understand it, and know the tradeoffs involved in the many different GUID algorithms they&#8217;re choosing from.</p>
<p>Of course, the subtle problems aren&#8217;t the only ones &#8211; really dumb developers blindly copy GUIDs in all sorts of crazy places.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773283">
				<div id="div-comment-773283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773283">
			October 1, 2009 at 5:31 pm</a>		</div>

		<p>@bob: &quot;the MAC address is no longer a popular choice&quot;</p>
<p>I don&#8217;t believe you. &nbsp;I think the MAC address is part of the algorithm. &nbsp;But I could be wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773293">
				<div id="div-comment-773293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Scott Berry</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773293">
			October 1, 2009 at 5:59 pm</a>		</div>

		<p>@David Walker: probably instead of saying &quot;I don&#8217;t believe you&quot;, it would be good to check: <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Globally_Unique_Identifier" rel="nofollow">http://en.wikipedia.org/wiki/Globally_Unique_Identifier</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773303">
				<div id="div-comment-773303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carl Daniel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773303">
			October 1, 2009 at 5:59 pm</a>		</div>

		<p>@David:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/aa379322.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/aa379322.aspx</a></p>
<p>&quot;For security reasons, UuidCreate was modified so that it no longer uses a machine&#8217;s MAC address to generate UUIDs. UuidCreateSequential was introduced to allow creation of UUIDs using the MAC address of a machine&#8217;s Ethernet card.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773323">
				<div id="div-comment-773323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773323">
			October 1, 2009 at 6:29 pm</a>		</div>

		<p>@Ken Cox:</p>
<p>Ok, you&#8217;re probably just kidding, but there are of course ways to prove if a GUID is, in fact, globally unique. The exact proof depends on the method used.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773333">
				<div id="div-comment-773333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.Stum.de' rel='external nofollow' class='url'>Michael Stum</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773333">
			October 1, 2009 at 7:18 pm</a>		</div>

		<p>And just to add: Using Random() four times to generate the 4 parts of a GUID is NOT a good method. And yes, I&#8217;ve seen code for GUID generating that did this. Actually, I&#8217;ve seen many really bad &quot;GUID&quot; generators as code for languages that don&#8217;t have anything built in.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773273">
				<div id="div-comment-773273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.kencox.ca/' rel='external nofollow' class='url'>Ken Cox [MVP]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773273">
			October 1, 2009 at 5:14 pm</a>		</div>

		<p>Hey guys,</p>
<p>Don&#8217;t try to convince me that GUIDs are unique until you test *all* of them against each other. Until you do, their uniqueness is merely idle speculation! &lt;grin&gt;</p>
<p>Ken</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773373">
				<div id="div-comment-773373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773373">
			October 2, 2009 at 1:45 am</a>		</div>

		<p>I remember having to write a GUID generator from scratch &#8211; there were very few facilities I could use &#8211; I barely had a C library.</p>
<p>I used the MAC as it was unique, and the onboard fast-running counter &#8211; that&#8217;s all I had.</p>
<p>Coding PXE support into a bootloader&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773383">
				<div id="div-comment-773383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773383">
			October 2, 2009 at 1:52 am</a>		</div>

		<p>Addenda to above:</p>
<p>No RTC &#8211; the clock ticked from zero every power-on. Presumably it ran NTP or something once the OS booted.</p>
<p>PXE was used to load in a bigger bootloader with more support &#8211; the boot flash was tiny and we only had around 64kB to be able to load the big loader from (much larger) NAND storage, validate it, and if not (e.g., corrupted or not present), do PXE to find a serve that could serve us the right bootloader, and write it into NAND.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773413">
				<div id="div-comment-773413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773413">
			October 2, 2009 at 3:59 am</a>		</div>

		<ol>
<li>
<p>Mail account GUIDs in Exchange are not unique? Why?</p>
</li>
<li>
<p>Several stupid people I know are copying project files (vbproj). VS doesn&#8217;t warn about this when loading av multiproject solutions (doesn&#8217;t check for dupes i suppose), but behaves strangely/erroneously when debugging. Why?</p>
</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773423">
				<div id="div-comment-773423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773423">
			October 2, 2009 at 7:23 am</a>		</div>

		<blockquote><p>
  Ok, you&#8217;re probably just kidding, but there</p>
<p>  are of course ways to prove if a GUID is, in &gt;fact, globally unique. The exact proof</p>
<p>  depends on the method used.
</p></blockquote>
<p>Hogwash. A GUID has 128 bits. If you generate 2^129 GUIDS you will definitely have duplicates. How are you going to prove that nobody on the planet has ever generated a certain GUID?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773563">
				<div id="div-comment-773563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin Eshbach</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773563">
			October 2, 2009 at 11:45 am</a>		</div>

		<p>What&#8217;s really scarey is when a lazy developer just randomly increments one of the guid&#8217;s digits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773573">
				<div id="div-comment-773573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773573">
			October 2, 2009 at 11:59 am</a>		</div>

		<p>@Thomas:</p>
<p>With the right method, the sun will likely burn out before you run out of GUIDs. Do you have any idea how big a number 2^129 is??</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773663">
				<div id="div-comment-773663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ooh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773663">
			October 2, 2009 at 2:04 pm</a>		</div>

		<p>@someone else: You&#8217;re practically right, there are so many possibilities that the probability of a duplicate is low. However this doesn&#8217;t mean that it can&#8217;t happen.</p>
<p>That&#8217;s why Thomas is right: you can&#8217;t prove that there won&#8217;t ever be duplicates or that anybody else has not already generated the same GUID. Try to prove it and you&#8217;ll get:</p>
<p>Step 1: In total there are 2^128 possible GUIDs.</p>
<p>Step 2: Thus as soon as 2^128+1 GUIDs have been created (by all people on all computers on the whole world) then at least one of them has to be a dup (pigeonhole principle).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-773713">
				<div id="div-comment-773713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773713">
			October 2, 2009 at 3:34 pm</a>		</div>

		<p>OK, I may have been wrong about the MAC address. &nbsp;However, that link also says: &quot;Computers with ethernet/token ring addresses generate UUIDs that are guaranteed to be globally unique&quot;. &nbsp;How does it guarantee them to be globally unique if some portion of the Ethernet or token ring hardware is not part of the equation?</p>
<p>As for the size of the GUID address space, while I&#8217;m sure some commenters were kidding, it&#8217;s claimed to be large enough to assign a unique GUID to every atom in the universe. &nbsp;</p>
<p>This universe, of course; we don&#8217;t consider multiverses here.</p>
<p>Which means, obviously, that you can&#8217;t even store them all. &nbsp;The address space is many, many orders of magnitude larger than you can even imagine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-773743">
				<div id="div-comment-773743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/Matthew_van_Eerde' rel='external nofollow' class='url'>Maurits</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-773743">
			October 2, 2009 at 4:29 pm</a>		</div>

		<p>While it is true that the pigeonhole principle doesn&#8217;t kick in until we hit 2^128 GUIDs, probabilistic methods suggest we&#8217;ll hit our first (non-trivial) duplicate GUID after 2^64 or so (birthday paradox.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774113">
				<div id="div-comment-774113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774113">
			October 4, 2009 at 3:09 pm</a>		</div>

		<p>Ok, let&#8217;s look at this GUID algorithm that I just made up (because it works):</p>
<p>The first 48 bits will be the generators MAC address. The second will be a timestamp.</p>
<p>An 80-bit counter is enough for 38,334,786,263 years if you generate a GUID every nanosecond. Per computer. That should do.</p>
<p>Of course, there are still privacy concerns. Just think of a machine hooked up to the Internet where everybody can get one if needed and which is not supervised by anyone (we hope).</p>
<div class=post>[<i>Well, you can&#8217;t use all 80 bits for the counter because some bits of the GUID are reserved (in order to prevent collisions among various algorithms), and you have to worry about two processors generating a GUID at the same time, plus various clock-related tweaks. But basically you reinvented the classical GUID algorithm. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774143">
				<div id="div-comment-774143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774143">
			October 4, 2009 at 6:49 pm</a>		</div>

		<p>“[Don&#8217;t forget to handle the case when somebody asks for two GUIDs in rapid sucession (less than 1 microsecond apart). -Raymond]”</p>
<p>Um&#8230; Wait for a microsecond? Actually, I was thinking more along the lines of “the GUID generator generates GUIDs as fast as possible (and necessary; if none are needed, none are generated), and even if it generates a million per second, it will still last &lt;insert long time span here&gt;.” If you need GUIDs faster than it can generate, use a second one.</p>
<div class=post>[<i>&#8220;If you need GUIDs faster than it can generate, use a second one.&#8221; If you have two GUID generators, how do you ensure that they don&#8217;t both spit out the same GUID? Indeed the simplified algorithm virtually guarantees that they will! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774103">
				<div id="div-comment-774103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Menno van Lavieren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774103">
			October 4, 2009 at 11:51 am</a>		</div>

		<p>Birthday paradox indeed. But you should also consider the probability that two GUID&#8217;s will &#8216;meet&#8217;.</p>
<p>Pesonaly I think for GUID to implement Clone() is a bug. It doesn&#8217;t makes sense and is wrong. Clone is about creating a different object, so that when I poke in one the other stays unaffected. The objects have their own identity from the cloning on.</p>
<p>Come to think of it, you can abuse clone() to implement transactional behaviour.</p>
<div class=post>[<i>It&#8217;s not that GUID implements Clone(). The structure inside which the GUID is embedded has a Clone() which does a memberwise copy. Watch: </p>
<pre>S *CloneStructure(const S *p)
{
 S *q = new S;
 *q = *p;
 return q;
}
</pre>
<p>-Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774123">
				<div id="div-comment-774123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774123">
			October 4, 2009 at 4:06 pm</a>		</div>

		<p>Oh, that should have been microsecond, not nano. Damn prefixes &#8230;</p>
<p>A GUID generator should be single threaded. And failsafe (first increase the counter, *then* generate the GUID). And even a 64-bit counter would last long enough (584,942 years at one GUID per microsecond).</p>
<p>(I didn&#8217;t look up the exact algorithm because that wasn&#8217;t necessary for the proof.)</p>
<div class=post>[<i>Don&#8217;t forget to handle the case when somebody asks for two GUIDs in rapid sucession (less than 1 microsecond apart). -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774163">
				<div id="div-comment-774163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774163">
			October 4, 2009 at 11:48 pm</a>		</div>

		<p>@someone else:</p>
<p>That doesn&#8217;t even begin to guarantee global uniqueness. &nbsp;What it tries to do is guarantee uniqueness between different users of the same software. &nbsp;But consider what happens when someone without an Ethernet card generates a GUID. &nbsp;Or someone else&#8217;s GUID software uses (timestamp, MAC) instead of (MAC, timestamp). &nbsp;You can easily have collisions with other algorithms. &nbsp;Which is why there cannot be a proof of uniqueness.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774313">
				<div id="div-comment-774313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774313">
			October 5, 2009 at 12:30 pm</a>		</div>

		<p>Don&#8217;t forget that &#8220;when someone without an Ethernet card generates a GUID&#8221;, it&#8217;s not likely that anyone will ever know, hence there won&#8217;t be a collision in a meningful sense. &nbsp;The computer without an Ethernet card is pretty much limited to living in its own little world. </p>
<p>Unless the computer communicates with the outside world in some non-Ethernet or non-Ethernet-like way.</p>
<div class=post>[<i>In the old days (before laptops had network hardware built-in), this was pretty common. Your machine has no network card, but you generate CLSIDs for your COM object from it. When you return to the office, you dock your laptop (connecting it to the network) and upload your project to the network. You can still see some GUIDs created this way in the registry today.-Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774333">
				<div id="div-comment-774333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774333">
			October 5, 2009 at 12:54 pm</a>		</div>

		<p>You&#8217;re right, Raymond, I overlooked that possibility.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774203">
				<div id="div-comment-774203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeroen Mostert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774203">
			October 5, 2009 at 7:28 am</a>		</div>

		<p>GUIDs are not absolutely unique across all situations. They have 128 bits, not an infinite number of bits. The appropriate question is not to ask if there can be collisions (there can be) but how likely they are in a given situation. No matter how crafty your algorithm, you could always be tripped up by some clown with another algorithm designed to collide with yours. In particular, a trivial way of doing this is by repeating already generated GUIDs. Which is the subject of this post, so that&#8217;s coming full circle for you.</p>
<p>That reminds me of a debate I had on how to create a temporary file (ignoring the existing library functions for a moment). I proposed using a GUID for the file name and failing if a file by that name couldn&#8217;t be created, and was chewed out by two people who pointed out that GUIDs, despite the name, are not necessarily unique, not even on the same machine. In particular, it was pointed out that this didn&#8217;t take into account the existing files in the directory that might clash, despite the fact that this is much less likely to happen with GUIDs than with most other schemes (like GetTempFileName(), which is easily thwarted by a mere 65,536 pre-existing files of a particular name), even taking malice into account.</p>
<p>Instead they unequivocally agreed that using an algorithm that would deterministically fail only when the available names ran out was a better choice, even if that algorithm was less efficient. My argument that the *likelihood* of the GUID not being unique was so incredibly small that you would much sooner need to worry about your file system, your computer or your solar system breaking down was scoffed at; the possibility of failure by the algorithm itself, no matter how jawdroppingly minuscule, was unacceptable. They went to great lengths to point out my idea was &quot;playing the odds&quot; and fundamentally flawed.</p>
<p>I learned from that that some (most?) programmers do not appreciate probabilistic arguments and will only respect &quot;certainty&quot;, even if the &quot;certain&quot; algorithm will &quot;certainly&quot; fail in reality much sooner than the &quot;unpredictable&quot; algorithm will, and even if the &quot;certain&quot; algorithm has other undesirable properties. This distrustful attitude towards small probabilities is healthy in general (you don&#8217;t want to hear someone argue that &quot;this race condition is so unlikely&quot;) but elevating it to dogma is going too far.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774373">
				<div id="div-comment-774373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774373">
			October 5, 2009 at 3:44 pm</a>		</div>

		<p>“[&#8220;If you need GUIDs faster than it can generate, use a second one.&#8221; If you have two GUID generators, how do you ensure that they don&#8217;t both spit out the same GUID? Indeed the simplified algorithm virtually guarantees that they will! -Raymond]”</p>
<p>Because they have different network cards, and hence, different GUIDs. By “generator,” I meant an actual physical thingy, not a program.</p>
<div class=post>[<i>Oh, good luck getting people to buy a GUID generator device whenever they need a GUID. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-774383">
				<div id="div-comment-774383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774383">
			October 5, 2009 at 6:56 pm</a>		</div>

		<p>“[Oh, good luck getting people to buy a GUID generator device whenever they need a GUID. -Raymond]”</p>
<p>That&#8217;s what we have the Internet for. Have some trusted parties set up public GUID generators. Yes, I firmly believe in (flat, reliable and reasonably fast) Internet access for everyone.</p>
<div class=post>[<i>I&#8217;m pretty sure those public GUID generators would be asked to generate GUIDs faster than 1 per microsecond. &#8220;Your GUID requests are important to us, and they will be serviced in the order they were received.&#8221; (I can see the bug reports now. &#8220;Your program runs slowly because the GUID generator is overloaded.&#8221;) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-774403">
				<div id="div-comment-774403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-774403">
			October 5, 2009 at 8:42 pm</a>		</div>

		<p>Using my patent-pending GUID generator physical thingy internet serivce, you can get all the unique GUIDs you want for the low, low price of US$0.05 each. &nbsp;</p>
<p>Remember that each GUID is completely unique &#8211; no two are alike. &nbsp;Therefore their value as collectables can only increase over time.</p>
<p>To get you started with your own GUID collection, here are 6 GUIDs *absolutely free*!!!. &nbsp;</p>
<p> &nbsp; &nbsp;&#8211; 1084b315-e21f-4fed-86e4-b2550c054b31</p>
<p> &nbsp; &nbsp;&#8211; 9a02559b-af6d-41b2-9e85-f25d0440d732</p>
<p> &nbsp; &nbsp;&#8211; fded0036-69da-498d-a000-24f04b47027c</p>
<p> &nbsp; &nbsp;&#8211; ed6fae15-a98c-4375-b359-b53e55334bcd</p>
<p> &nbsp; &nbsp;&#8211; 3e4f612b-9e8d-4894-b4e3-128b006db38d</p>
<p> &nbsp; &nbsp;&#8211; bce26c02-ea8f-4c64-9cd3-0b8eeda827be</p>
<p>You&#8217;ll never find an offer like this anywhere else or at any other time. &nbsp;Hurry before they run out!!!</p>
<p>Visit <a rel="nofollow" target="_new" href="http://www.guid-ducks.com" rel="nofollow">http://www.guid-ducks.com</a></p>
<p>Operators are waiting!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-775003">
				<div id="div-comment-775003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-775003">
			October 6, 2009 at 12:50 pm</a>		</div>

		<p>“[I&#8217;m pretty sure those public GUID generators would be asked to generate GUIDs faster than 1 per microsecond. &quot;Your GUID requests are important to us, and they will be serviced in the order they were received.&quot; (I can see the bug reports now. &quot;Your program runs slowly because the GUID generator is overloaded.&quot;) -Raymond]”</p>
<p>Cache, distribute, compress. Instead of transmitting every single GUID, you get the OK from the generator to get GUIDs [fixed part].N to [fixed part].(N+1000) (that dot is concatenation). And you can query several generators at the same time.</p>
<p>(And since pseudorandom GUIDs can be predicted reasonably well, there is little reason not to use consecutive numbers).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-775113">
				<div id="div-comment-775113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">non-unique global identifer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-775113">
			October 6, 2009 at 3:09 pm</a>		</div>

		<p>Then what if you want to genereate 2^128+1 uuids in 1 second? The whole concept with generating &quot;unique&quot; values with a fixed bitlength is flawed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-775163">
				<div id="div-comment-775163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeroen Mostert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-775163">
			October 6, 2009 at 4:05 pm</a>		</div>

		<p>&quot;Then what if you want to genereate 2^128+1 uuids in 1 second?&quot;</p>
<p>A system fast enough to generate them would be only six orders of magnitude away from doing operations in Planck time, which is the smallest meaningful unit of time under current known natural laws. There is no conceivable use for that many unique identifiers in such a short timespan. By the time hardware arrives that&#8217;s capable of this and scenarios that require it, though (if ever) we should have the GUID2, which will have 256 bits.</p>
<p>I agree that a fully general solution (with truly unique values) needs an infinite number of bits. Obviously, this approach comes with its own implementation issues, but in many cases it can be approximated by using the binary representation of whatever you want to assign a unique identifier to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-775243">
				<div id="div-comment-775243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">avek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-775243">
			October 6, 2009 at 5:02 pm</a>		</div>

		<blockquote><p>
  There is no conceivable use for that many unique identifiers in such a short timespan.
</p></blockquote>
<p>Not only that, but it also requires ridiculous amounts of memory to store all that IDs. Something like 500000 times the weight of Earth with today&#8217;s technology.</p>
<p>But it doesn&#8217;t matter, after all. Variable-length string IDs won&#8217;t be duplicated by Clone() method, just the same as fixed-length GUIDs will not be. No matter how long the identifier is, if it&#8217;s blindly propagated into copies without change, it won&#8217;t be unique in those copies.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-775413">
				<div id="div-comment-775413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-775413">
			October 7, 2009 at 12:51 am</a>		</div>

		<p>Menno, I think it would be a bug if GUID didn&#8217;t implement Clone(). Don&#8217;t forget that sometimes (most of the time) you WANT the GUID to be copied. It&#8217;s only when you&#8217;re generating a new object from an old object with a GUID that you want a new one to be generated.</p>
<p>For example, if I have an object with GUIDs for identity and parentIdentity, I might want a copy of the object to have a new identity but I want it to always have the same parentIdentity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-775373">
				<div id="div-comment-775373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone else</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20091001-00/?p=16533#comment-775373">
			October 6, 2009 at 10:01 pm</a>		</div>

		<p>“Not only that, but it also requires ridiculous amounts of memory to store all that IDs. Something like 500000 times the weight of Earth with today&#8217;s technology.”</p>
<p>And at least 6.9 zettajoule of energy. That&#8217;s 128 * 2^128 * 1 eV or almost 2 exawatt-hours or over 275,000,000,000 years of Three Mile Island&#8217;s reactor output.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

