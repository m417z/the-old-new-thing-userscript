<html>
<head>
<title>Modality, part 1: UI-modality vs code-modality</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Modality, part 1: UI-modality vs code-modality</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>February 18, 2005 / year-entry #42</td></tr>
<tr><td><b>Tags:</b></td><td>code;modality</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>26</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">From the end-users' point of view, modality occurs when the users are locked into completing a task once it is begun, with the only escape being to cancel the entire operation. Opening a file is an example of a modal operation: Once the "Open" command has been selected, users have no choice but to select...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
From the end-users' point of view, modality occurs when the
users are locked into completing a task once it is begun,
with the only escape being to cancel the entire operation.
Opening a file is an example of a modal operation:
Once the "Open" command has been selected, users have
no choice but to select a file for opening (or to cancel
the operation).  While attempting to open a document,
the users cannot interact with the existing
document (for example, scroll it around to look for some
text that would give a clue as to what file to open next).
</p>
<p>
From a programmer's point of view, modality can be
viewed as a function that performs some UI and doesn't
return until that UI is complete.
In other words, modality is
a nested message loop that continues processing
messages until some exit condition is reached.
In our example above, the modality is inherent in
the <code>GetOpenFileName</code> function, which does not return
until the user selects a filename or cancels the dialog box.
</p>
<p>
Note that these concepts do not necessarily agree.
You can create something that is UI-modal&mdash;that is,
does not let the user interact with the main window
until some other action is complete&mdash;while internally
coding it as a non-modal function.
</p>
<p>
Let's code up an example of this behavior,
to drive the point home.
</p>
<p>
As always,
<a href="http://blogs.msdn.com/oldnewthing/archive/2003/07/23/54576.aspx">
start with our scratch program</a>.
</p>
<pre>
#include &lt;commdlg.h&gt;

HWND g_hwndFR;
TCHAR g_szFind[80];
FINDREPLACE g_fr = { sizeof(g_fr) };
UINT g_uMsgFindMsgString;

void CreateFindDialogUIModally(HWND hwnd)
{
  if (!g_hwndFR) {
    g_uMsgFindMsgString = RegisterWindowMessage(FINDMSGSTRING);
    if (g_uMsgFindMsgString) {
      g_fr.hwndOwner = hwnd;
      g_fr.hInstance = g_hinst;
      g_fr.lpstrFindWhat = g_szFind;
      g_fr.wFindWhatLen = 80;
      g_hwndFR = FindText(&amp;g_fr);
    }
  }
}

void OnChar(HWND hwnd, TCHAR ch, int cRepeat)
{
  switch (ch) {
  case ' ': CreateFindDialogUIModally(hwnd); break;
  }
}

void OnFindReplace(HWND hwnd, FINDREPLACE *pfr)
{
  if (pfr->Flags &amp; FR_DIALOGTERM) {
      DestroyWindow(g_hwndFR);
      g_hwndFR = NULL;
  }
}

// Add to WndProc
    HANDLE_MSG(hwnd, WM_CHAR, OnChar);

    default:
      if (uiMsg == g_uMsgFindMsgString &amp;&amp; g_uMsgFindMsgString) {
        OnFindReplace(hwnd, (FINDREPLACE*)lParam);
      }
      break;

// Edit WinMain
    while (GetMessage(&amp;msg, NULL, 0, 0)) {
        <font COLOR=blue>if (g_hwndFR &amp;&amp; IsDialogMessage(g_hwndFR, &amp;msg)) {
        } else {</font>
          TranslateMessage(&amp;msg);
          DispatchMessage(&amp;msg);
        <font COLOR=blue>}</font>
    }
</pre>
<p>
This is an unexciting example of a modeless dialog;
in our case, the Find dialog is displayed
when you hit the space bar.  Observe that you can click
back to the main window while the Find dialog is up;
that's because the Find dialog is modeless.
As is typical for modeless dialogs, dispatching its
messages is handled in the main message loop with
a call to
<a HREF="http://msdn.microsoft.com/library/en-us/winui/WinUI/WindowsUserInterface/Windowing/DialogBoxes/DialogBoxReference/DialogBoxFunctions/IsDialogMessage.asp">
the <code>IsDialogMessage</code> function</a>.
</p>
<p>
We can turn this into a UI-modal dialog very simply:
</p>
<pre>
void CreateFindDialogUIModally(HWND hwnd)
{
  if (!g_hwndFR) {
    g_uMsgFindMsgString = RegisterWindowMessage(FINDMSGSTRING);
    if (g_uMsgFindMsgString) {
      g_fr.hwndOwner = hwnd;
      g_fr.hInstance = g_hinst;
      g_fr.lpstrFindWhat = g_szFind;
      g_fr.wFindWhatLen = 80;
      g_hwndFR = FindText(&amp;g_fr);
      <font COLOR=blue>if (g_hwndFR) {
        EnableWindow(hwnd, FALSE);
      }</font>
    }
  }
}

void OnFindReplace(HWND hwnd, FINDREPLACE *pfr)
{
  if (pfr->Flags &amp; FR_DIALOGTERM) {
      <font COLOR=blue>EnableWindow(hwnd, TRUE);</font>
      DestroyWindow(g_hwndFR);
      g_hwndFR = NULL;
  }
}
</pre>
<p>
Notice that we carefully observed
<a href="http://blogs.msdn.com/oldnewthing/archive/2004/02/27/81155.aspx">
the rules for enabling and disabling windows</a>.
</p>
<p>
When you run this modified program, everything seems the
same except that the Find dialog is now modal.  You can't
interact with the main window until you close the Find
dialog.  The Find dialog is modal in the UI sense.
However, the code is structured in the non-modal manner.
There is no dialog loop; the main window
loop dispatches dialog messages as necessary.
</p>
<p>
One typically does not design one's modal UI in this manner
because it makes the code harder to structure.
Observe, for example, that the code to manage the dialog box
is scattered about and the management of the dialog needs to
be handled as a state machine since each phase returns back
to the main message loop.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (26)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-256603">
				<div id="div-comment-256603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256603">
			February 18, 2005 at 7:46 am</a>		</div>

		<p>Even when modal windows seem appropriate they can really hurt usability. Every few months I run into this with Outlook. I get an email saying &quot;Your new email account is ready, here&#8217;s the username and password.&quot; My first instinct is to open up the Tools, Accounts, New dialog and try to copy/paste the information from the message to the dialog. No can do, the dialog is modal and Outlook&#8217;s message window is disabled. The Office Clipboard stacks copies/pastes and might be useful, but it is not available in the dialog!<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256613">
				<div id="div-comment-256613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RichB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256613">
			February 18, 2005 at 8:23 am</a>		</div>

		<p>Correct me if I&#8217;m wrong &#8211; but isn&#8217;t this the way to handle fakemenu style popups?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256623">
				<div id="div-comment-256623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256623">
			February 18, 2005 at 8:29 am</a>		</div>

		<p>It is &quot;a&quot; way, but hardly &quot;the&quot; way. Not even the fakemenu sample itself uses this technique.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256633">
				<div id="div-comment-256633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Candy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256633">
			February 18, 2005 at 9:53 am</a>		</div>

		<p>Maybe part 2 will be real modal dialog, like the search in the last usuable MSDN viewer (Oct 2001). It has a cancel button that seems to store the cancel message till the dialog finishes (never been sure the point of this cancel).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256643">
				<div id="div-comment-256643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MYG</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256643">
			February 18, 2005 at 11:21 am</a>		</div>

		<p>Actually, isn&#8217;t this another perfect use for fibers or threads? You can have your modality and a single message loop (which is sometimes important) at the same time. </p>
<p>The code that provides the logic backing the UI runs on a fiber or thread and can wait until the dialog box state becomes appropriate before continuing. So its easier to &quot;hide the state machine.&quot;</p>
<p>-MYG<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256653">
				<div id="div-comment-256653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kathy Wathers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256653">
			February 18, 2005 at 1:18 pm</a>		</div>

		<p>I&#8217;d like to see this used more often&#8230; </p>
<p>For example, if there&#8217;s a dialog box in Internet Explorer (invoked by user and forgotten, or sometimes invoked by the program), then any links clicked from other programs that would normally open in IE are simply vanishing in thin air.</p>
<p>If anyone watched last Apple keynote, the same thing happened to Steve Jobs previewing OS X Tiger in front of many people &#8212; iPhoto was stuck with some sort of dialog box and ignored import functions from another program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256663">
				<div id="div-comment-256663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasmusic.com' rel='external nofollow' class='url'>Joshua Schaeffer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256663">
			February 18, 2005 at 2:12 pm</a>		</div>

		<p>Assuming that the code structure is fine, is it a UI sin to make every possible thing modeless (i.e. Open and About windows too) unless an algorithm absolutely requires modal?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256673">
				<div id="div-comment-256673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://po.ca' rel='external nofollow' class='url'>Slaven</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256673">
			February 19, 2005 at 1:31 am</a>		</div>

		<p>It is generally understood that any modal operations are a &quot;bad&quot; thing in UI design, so making as much of your program as modeless as possible would actually be a good thing. I think we are simply stuck with certain level of modality in Windows, but UI purists would probably argue that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256703">
				<div id="div-comment-256703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256703">
			February 19, 2005 at 7:41 am</a>		</div>

		<blockquote><p>
  It is generally understood that any modal operations are a &quot;bad&quot; thing in UI design</p>
<p>No it isn&#8217;t.  It is silly blanket statements such as this that produce some of the worst UI ever created by man.</p>
<p>Use the right thing for the right task.  Making something modeless just because of some rule is the wrong way to design UI.  You must look at the UI workflow.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256713">
				<div id="div-comment-256713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">modal is the easy way</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256713">
			February 19, 2005 at 11:33 am</a>		</div>

		<blockquote><p>
  It is generally understood that any modal operations are a &quot;bad&quot; thing in UI design, so making as much of your program as modeless as possible would actually be a good thing.</p>
<p>I totally agree. But it&#8217;s usually much harder to make a popupwindow modeless, beacuse the state of the main window can be modified.</p>
<p>A common problem is contextmenus that open popupwindow, if that popupwindow is modeless then the object which was rightclicked could be changed/removed/whatever, and then the popupwindow have to reflect/handle that. With a modal popupwindow one can rely on the contextobjekt is constant under the popupwindow&#8217;s lifespan.</p>
<p>Similar problems arise with a threaded gui.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256693">
				<div id="div-comment-256693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Centaur</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256693">
			February 19, 2005 at 3:44 am</a>		</div>

		<p>&gt; One typically does not design one&#8217;s modal UI<br />
<br />&gt; in this manner because it makes the code<br />
<br />&gt; harder to structure.</p>
<p>*One* typically doesn’t. But, if I’m not mistaken, classic versions of Borland Delphi and C++ Builder do implement modal dialogs exactly this way. In fact, they aren’t even *dialogs* in the strict sense; they are not based on a dialog box template and do not use DialogBox or DialogBoxIndirect.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256723">
				<div id="div-comment-256723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://po.ca' rel='external nofollow' class='url'>Slaven</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256723">
			February 19, 2005 at 11:51 am</a>		</div>

		<p>&quot;No it isn&#8217;t. It is silly blanket statements such as this that produce some of the worst UI ever created by man.&quot;</p>
<p>What I stated is correct &#8211; it is generally accepted amongst UI experts that modality is bad. You may disagree with that, I&#8217;m by no means an UI expert but all the research I&#8217;ve done on this topic in the past 10 years <em>generally</em> comes to the same conclusion.</p>
<p>&quot;Use the right thing for the right task.&quot;</p>
<p>What they would argue is that you haven&#8217;t thought the task through correctly from the user&#8217;s point of view if your solution is modality. Again, don&#8217;t shoot the messenger&#8230; :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256733">
				<div id="div-comment-256733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256733">
			February 19, 2005 at 12:43 pm</a>		</div>

		<p><a target="_new" href="http://www.datanation.com/fallacies/anon.htm" rel="nofollow">http://www.datanation.com/fallacies/anon.htm</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256743">
				<div id="div-comment-256743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256743">
			February 19, 2005 at 12:57 pm</a>		</div>

		<p>BTW, I have been doing UI design for 20 years along with the research required to do a good job.</p>
<p>But like you, stating such is just another logical fallacy.</p>
<p>There is nothing &quot;bad&quot; about modal dialogs.  However, they can be used inappropriately and often are.  For reasons already stated (i.e. ease of implementation), they are commonly used when a modeless solution is better.  But that still doesn&#8217;t change the fact that there are many instances where they are the right decisions.  I think we would all be very hard pressed to find an application of significant complexity that are 100% modeless.  Obviously such applications can be created since all you would have to do is avoid the situations where modal is a better choice.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256753">
				<div id="div-comment-256753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://po.ca' rel='external nofollow' class='url'>Slaven</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256753">
			February 19, 2005 at 1:00 pm</a>		</div>

		<p><a target="_new" href="http://www.amazon.com/exec/obidos/tg/detail/-/0764526413/qid=1108846080/sr=8-1/ref=pd_bbs_1/002-2549661-9035239?v=glance&amp;s=books&amp;n=507846" rel="nofollow">http://www.amazon.com/exec/obidos/tg/detail/-/0764526413/qid=1108846080/sr=8-1/ref=pd_bbs_1/002-2549661-9035239?v=glance&#038;s=books&#038;n=507846</a></p>
<p><a target="_new" href="http://www.cooper.com/content/company/about_cooper.asp" rel="nofollow">http://www.cooper.com/content/company/about_cooper.asp</a></p>
<p>It is pretty easy to see why modality is considered bad in UI design. Take Ray&#8217;s example from the first paragraph above: the only reason Open Dialog has been made modal is to help us, programmers, from worrying about minutia of interface management. Arguing that a modal Open Dialog is in some way better than modeless one can be done from the programmer&#8217;s perspective, but the user would obviously prefer to be able to switch from window to window as they please.</p>
<p>Are there examples of bad modeless design out there? You bet! That does&#8217;t mean that all modeless design is bad. But there is a lot more bad modal design:</p>
<p><a target="_new" href="http://www.rha.com/ui_hall_of_shame.htm" rel="nofollow">http://www.rha.com/ui_hall_of_shame.htm</a> </p>
<p>Scroll to the Quicken example half way down the page &#8211; if you think that is uncommon think again. I just had to deal with modality from hell the other day as I was changing some settings for my display adapter. I think I had 4 modal dialogs open one over the other, average user would definitely get lost long before then. There are many similar examples in Outlook, Word, etc.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256763">
				<div id="div-comment-256763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://po.ca' rel='external nofollow' class='url'>Slaven</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256763">
			February 19, 2005 at 1:04 pm</a>		</div>

		<p>&quot;But that still doesn&#8217;t change the fact that there are many instances where they are the right decisions.&quot;</p>
<p>Hey, I use them all the time. But I think ideally every modal scenario has a better modeless implementation. It just may be a lot more costly to implement. </p>
<p>&quot;I think we would all be very hard pressed to find an application of significant complexity that are 100% modeless.&quot;</p>
<p>Agreed! This is all theoretical.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256773">
				<div id="div-comment-256773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256773">
			February 19, 2005 at 1:11 pm</a>		</div>

		<p>Just for clarification.</p>
<p>What I am arguing about is how the statement is worded.</p>
<p>&quot;It is generally understood that any modal operations are a &quot;bad&quot; thing in UI design, so making as much of your program as modeless as possible would actually be a good thing.&quot;</p>
<p>You are basically staying that people shouldn&#8217;t use modal windows without giving them the knowledge of when a modal is good and when it isn&#8217;t.  It leads to mindless striving towards a goal that people don&#8217;t understand why it is a good goal, but much worse, they don&#8217;t understand the limitations of the goal.  Thus you end up hurting the end user by forcing a workflow on them that isn&#8217;t optimal.</p>
<p>If we are talking about a new kid just out of school, I am all for giving them solid rules.  However, as people gain the experience and understanding of the limitations of the rules, they should be allowed the freedom to decide for themselves what is right and what is wrong.</p>
<p>Gotos are not evil, they are just grossly inappropriate.  If you don&#8217;t believe me, read  Dijkstra&#8217;s paper on gotos where he discusses a few of the cases where gotos solve problems well.  Knuth also has a very interesting paper on the subject where he purposely leaves the reader not knowing if he is in favor or against gotos.</p>
<p>Give people the knowledge instead of rules.  Let them decide which is best.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256783">
				<div id="div-comment-256783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://po.ca' rel='external nofollow' class='url'>Slaven</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256783">
			February 19, 2005 at 5:12 pm</a>		</div>

		<p>I think you are discussing this from a programmer&#8217;s point of view. My statement is in the realm of user interface design &#8211; I don&#8217;t know of any UI expert (someone who has done research and papers on the subject) that advocate modal design. If you know any please let me know. Many books have been written on the subject so I can&#8217;t really impart much wisdom in these posts, just summarize it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256803">
				<div id="div-comment-256803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Carstens [carstens AT seattleu DOT edu]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256803">
			February 20, 2005 at 4:44 pm</a>		</div>

		<p>I can&#8217;t say that there&#8217;s no legitimate application of a modal dialog box; this is one of those arguments over practical technique wherein no stance on the issue can be supported formally.</p>
<p>However, I can propose an alternative to modal dialog boxes that would probably work in most situations.</p>
<p>Suppose I have a window that contains a list of icons (think along the lines of Explorer).  Now, suppose the user&#8217;s interactions with the icons will result in a state change somewhere else in the system (e.g. deleting an icon deletes a file, moving an icon moves a file, etc).  Many of these state-altering interactions occur within the container window.  Some occur within a dialog box (e.g. the &quot;Properties&quot; dialog).</p>
<p>Now, if the user invokes the &quot;Properties&quot; dialog box on an icon, and prior to dismissing the dialog deletes the icon, what happens?  Is the user suddenly setting the properties of a non-existant icon?</p>
<p>This type of problem can be generalized: there are some dialogs that only make sense within the context of a particular state.  If the relevant state can be altered while the dialog is present, we enter the realm of uncertainty.</p>
<p>So when we encounter a situation where this might occur, we often use modal dialog boxes.  Why?  Simple: by making the dialog modal, we prevent the user from changing the state out from under us.  We have, in effect, put the underlying system into read-only mode.</p>
<p>Except that with modal dialog boxes, you can&#8217;t even read, necessarily.  You make the whole thing a non-issue by rendering the underlying window useless.</p>
<p>So instead of using a modal dialog box, why not just disable the icon-modifiers in the underlying window?  This makes the window read-only, while still allowing the user to actually read the contents of the window.</p>
<p>Be warned, however: this alternative is dangerous when incorrectly applied.  One of the best ways to confuse a user is to make changes in the UI that are not an obvious, direct result of a user&#8217;s actions.  Thus, if you decide to make the underlying window read-only, make it obvious that you have done so, and why.</p>
<p>In the interest of better understanding this design issue, I am interested in hearing about flaws to the read-only approach, or scenarios where it would not work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256833">
				<div id="div-comment-256833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256833">
			February 21, 2005 at 12:05 am</a>		</div>

		<p>I guess making underlying window &quot;read only&quot; is implementing modality in a different way. Result is the same &#8211; user should not be able to change things while properties are visible. The only difference I see is that user will be able to switch back to main window. That may lead to a confuse &#8211; a user may try to delete/move/whatever an icon but system will deny it, which will result a complain from the user &quot;damn thing doesn&#8217;t work&quot;.</p>
<p>Second problem with modeless design is that application should keep track of which windows are opened, otherwise you may end with dozens Help/About windows on screen.</p>
<p>Asking me, modal is good when used properly</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256843">
				<div id="div-comment-256843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ram</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256843">
			February 21, 2005 at 12:08 am</a>		</div>

		<blockquote><p>
  &gt; modal is good when used properly</p>
<p>I guess that is a tautology. More generic version is &#8216;&lt;x&gt; is good when used properly in the context &lt;y&gt;&#8217; where x and y are variables.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-256853">
				<div id="div-comment-256853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Carstens [carstens AT seattleu DOT edu]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256853">
			February 21, 2005 at 2:10 am</a>		</div>

		<p>This is why I was careful to mention that it must be made clear to the user that the window is in a read-only state, as well as why it is in this state.</p>
<p>The notion that modal dialogs are &quot;good when used properly&quot; is a self-satisfying statement.  I believe I can elaborate on it without losing any meaning.</p>
<p>&quot;Modal dialogs are good when they are the best solution to a problem.&quot;  This begs the question: are there any problems for which a modal dialog is the best solution?  If we are using modal dialog boxes to lock us into an underlying state, then I believe that a read-only window is a superior choice, since it allows the user to look back to the window for reference if they need to (Chen touched on this in the original post).</p>
<p>But, once more, this can confuse the user unless it&#8217;s obvious what has happened.  It looks like I need to be more explicit and provide an example design.</p>
<p>Consider Word&#8217;s table &quot;properties&quot; dialog (Tom Saxton was my calculus teacher in h.s.).  Instead of using a modal dialog, I propose that the properties are displayed in a pane to the side of the document.  This  makes it impossible for the user to lose the dialog in the z-order, and allows the user to see the properties and the document at the same time without moving windows around.</p>
<p>To make it blindingly obvious to the user that the window is in read-only mode, and that this mode was entered because of the properties pane (it&#8217;s a pane now, remember?), we might have an alpha-blended image over the document that says, in great big words, &quot;READ ONLY,&quot; followed by a large-print statement about how the user needs to dismiss the pane.  If we want to get really pedantic, we might even include an option to disable this message.</p>
<p>And there we have it: the underlying state won&#8217;t change out from under the dialog, but the user can still read the document.  When the dialog is dismissed everything goes back to normal.  We&#8217;ve introduced a big, obvious sign that tells the user that we&#8217;ve gone read-only and -why- we&#8217;ve gone read-only.</p>
<p>Incidentally, I have observed users (older family members in particular) who get confused by modal dialog boxes.  I can see why this is: you see, with a modal dialog box, the very presence of the dialog alters the behavior of another window that is not obviously related.  Worse, no explanation of this correlation is provided to the user.</p>
<p>From where I stand, modal dialog boxes are starting to look pretty poor in the general case.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-256883">
				<div id="div-comment-256883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carl Sobeski (carlso)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-256883">
			February 21, 2005 at 9:02 am</a>		</div>

		<p>&quot;What I stated is correct &#8211; it is generally accepted amongst UI experts that modality is bad.&quot;</p>
<p>As others have mentioned, this is not necessarily true. Modes have often been misued by program designers and there are many examples of where their use has caused problems. However, modes in general aren&#8217;t bad. It&#8217;s their incorrect use that is bad.</p>
<p>Ask the question, &quot;what is wrong with modes?&quot; Many UI experts will tell you that modes cause trouble when a user is placed in a mode and there is no feedback to indicate that they are in a mode. The typical scenario here is that the user is unaware of being in a mode and then tries to do some action that is usually performed in the normal &quot;non-mode&quot; state and either the action is not allowed in the modal state, or worse, produces a different result in the modal state. Another problem with modes arises when the user doesn&#8217;t know how to get out of a mode.</p>
<p>Good uses of modes are all around us. Many painting and drawing applications use a palette of tools, where you select, say the pencil tool, and you draw with a pencil. This is a mode. Because the user is given good feedback (e.g., cursor looks like a pencil) and the user can easily get out of the mode (e.g., select another tool or click on a menu item), this is not bad.</p>
<p>Also, consider the use of a scroll bar or menu. These all use temporary modal interaction. For example, when you click on the thumb of a scroll bar and move the mouse to scroll, you are essentially placed in a mode. Notice how other operations (e.g., pressing alt-F to access a File menu) do not work while scrolling. Again, these aren&#8217;t considered bad because the user is still in direct control &#8211; they can easily get out of the mode by simply releasing the mouse or, in the case of a menu, clicking elsewhere to dismiss the menu.</p>
<p>Getting back to modal dialogs. Generally, problems arise here when the user is required to answer some question or perform some action that requires information from another area of the program that has been made inaccessible by the use of the modal dialog. In such cases, often the user is forced to cancel the dialog, go back to the area of the program to find the information, and then attempt the original operation again which brought up the modal dialog. Obviously, such a scenario is bad. But, this is usually due to poor design of the modal dialog and poor workflow design. By redesigning the workflow or dialog, such problems can be avoided. Modal dialogs are not bad in themselves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-257253">
				<div id="div-comment-257253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ram</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-257253">
			February 22, 2005 at 10:46 pm</a>		</div>

		<blockquote><p>
  &gt; Modal dialogs are not bad in themselves.</p>
<p>I guess we are back to self-fulfilling statements which doesn&#8217;t mean a damn thing. I guess, the only conclusion we can arrive at is that &#8216;do what you want to do and hope that users will like it&#8217;.</p>
<p>Actually, it is not a bad idea to do usablity tests for your software so that you get some idea about whether your user like the modal or modeless interface or for that matter overall UI experience. Empirical evidence in these cases should triumph over unproven philosophical ponderings (or should i say ramblings)&#8230;
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-262633">
				<div id="div-comment-262633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MikHaven</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-262633">
			March 9, 2005 at 9:16 pm</a>		</div>

		<p>What the hey, I haven&#8217;t seen the one discussion on this topic that should have been said.   Everyones arguing on the semantics of the issue, but use them everyday, and seem to have forget how good a model dialog is.</p>
<p>Now before you jump all over me, for a blanket statement, think of this example, you use it everyday, and I wouldn&#8217;t have it any other way.   When windows starts up for the first time, you sometimes want to set it to ask you to log in, well guess what that is a model dialog, you are required to enter a password and name to beable to continue in a new mode.</p>
<p>A GOOD example of a model dialog, and it&#8217;s use would be just that, if you wanted to verify a user, than you would bring up a model dialog and have them enter their user information, what good would be the dialog if they can do something else, even anything else.   Once you know they are not who they say they are, your program can handle that, or if they are verified your free to do what you want.</p>
<p>MikHaven</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-479983">
				<div id="div-comment-479983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.adrianmccarthy.com/blog/?p=52' rel='external nofollow' class='url'>Adrian McCarthy &raquo; Blog Archive &raquo; Phantom Bug Update</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050218-00/?p=36413#comment-479983">
			March 7, 2007 at 7:56 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.adrianmccarthy.com/blog/?p=52" rel="nofollow">http://www.adrianmccarthy.com/blog/?p=52</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

