<html>
<head>
<title>Myth: You need /3GB if you have more than 2GB of physical memory</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Myth: You need /3GB if you have more than 2GB of physical memory</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 11, 2004 / year-entry #304</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>38</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Physical memory is not virtual address space. In my opinion, this is another non sequitur. I'm not sure what logical process led to this myth. It can't be a misapprehension of a 1-1 mapping between physical memory and virtual memory, because that mapping is blatantly not one-to-one. You typically have far more virtual memory than...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p> Physical memory is not virtual address space. </p>
<p> In my opinion, this is another <i>non sequitur</i>. I'm not sure what logical process led to this myth. It can't be a misapprehension of a 1-1 mapping between physical memory and virtual memory, because that mapping is blatantly not one-to-one. You typically have far more virtual memory than physical memory. Free physical memory doesn't have any manifestation in any virtual address space. And shared memory has manifestations in multiple virtual address spaces yet correspond to the same physical page. </p>
<p> Though this brings up a historical note. </p>
<p> In Windows/386, the kernel just so happened to map all physical memory into the kernel-mode virtual address space. There was a function <code><a href="http://www.faqs.org/faqs/windows/programming/vxd/">_MapPhysToLinear</a></code>. You gave it a physical memory range and it returned the base of a range of linear addresses that could be used to access that physical memory. Some driver developers discovered that the kernel mapped all of physical memory and just handed out pointers into that single mapping. As a result, they called <code>_MapPhysToLinear(0, 0x1000)</code> and whenever they wanted to access physical memory in the future, they just added the address to the return value from that single call. In other words, they assumed that </p>
<pre> _MapPhysToLinear(p, x) = _MapPhysToLinear(0, x) + p </pre>
<p> In Windows&nbsp;95, the memory manager was completely rewritten and the above coincidence was no longer true. To conserve kernel-mode virtual address space, physical memory was now mapped linearly only as necessary. </p>
<p> Of course, the drivers that relied on the old behavior were now broken because the undocumented behavior they relied upon was no longer present. </p>
<p> As a result, when it starts up, Windows&nbsp;95 looks around to see if any drivers known to rely on this undocumented behavior are loaded. (Windows 3.1 didn't support dynamically-loaded kernel drivers so looking at boot time was sufficient.) If so, then it went ahead and mapped all of physical memory into the kernel-mode virtual address space to keep those driver happy. This wasted virtual address space but kept your machine running. </p>
<p> I can already hear people saying, "Microsoft shouldn't have made those buggy drivers work. They should have just let the computer crash in order to put pressure on the authors of those drivers to fix their bugs." This assumes, of course, that the cause of the crash could be traced back to the buggy driver in the first place. A very common manifestation of a stray pointer in kernel mode is memory corruption, which means that the component that crashes is rarely the one that caused the problem in the first place. </p>
<p> For example, nearly all <a href="http://support.microsoft.com/?kbid=253241"> Windows&nbsp;95 bluescreen crashes in <code>VMM(01)</code></a> are caused by memory corruption. <code>VMM(01)</code> is the non-swappable part of the Windows&nbsp;95 kernel which is where the memory manager lives. If a driver corrupts the kernel-mode heap, a bluescreen in the memory manager is typically how the corruption manifests itself. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (38)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-202503">
				<div id="div-comment-202503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com/' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202503">
			August 11, 2004 at 8:31 am</a>		</div>

		<p>Based on your last few posts, and the comments, I&#8217;d say it&#8217;s pretty obvious that quite a lot of people just don&#8217;t &#8216;get&#8217; virtual memory at all. I suppose this means that it&#8217;s doing its job &#8211; after all, it&#8217;s supposed to be transparent to a user-mode process and to a user-mode programmer.</p>
<p>I can&#8217;t remember if I grokked it the first time through my Operating Systems course at University. The second time through (I had to retake a number of courses after changing programmes) I recall drawing diagrams of how x86 differed from the system the lecturer was demonstration &#8211; never identified, but probably IBM hardware.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202523">
				<div id="div-comment-202523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miles Archer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202523">
			August 11, 2004 at 9:09 am</a>		</div>

		<p>If you think the problem is bad with programmers, you should try to explain it to users. </p>
<p>Usually it&#8217;s no problem when virtual address space is much larger than the practical physical memory that someone can put in a computer. We are in the odd part of the CPUs life cycle when it&#8217;s feasible to have more physical memory than virtual. Once we move to 64bit address space, the problem will be pushed back for another decade or so and we won&#8217;t need to explain all this to users.</p>
<p>By the way, I remember hearing a lecture from an Intel guy when I was in college talking about the 4GB virtual address space for the upcoming 286 (or was it 386 I can&#8217;t remember). This was at a time when hard disks held less than 40 meg and a typical PC had 256K. I thought that 4GB ought to be enough for anyone ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202533">
				<div id="div-comment-202533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202533">
			August 11, 2004 at 9:32 am</a>		</div>

		<p>Where is your diagram explaining the relation between &quot;virtual address space&quot; and &quot;virtual memory&quot;? Highly anticipated item!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202553">
				<div id="div-comment-202553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack Mathews</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202553">
			August 11, 2004 at 9:47 am</a>		</div>

		<p>vince:</p>
<p>1) You can&#8217;t change the past.  Hindsight it 20/20<br />
<br />3) Pack the number of users of Windows (and developers) onto Linux and you&#8217;ll find plenty of shit programs being written.</p>
<p>I have multiple 8+ year old programs that work fine on Windows now too.  Big deal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202563">
				<div id="div-comment-202563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202563">
			August 11, 2004 at 9:47 am</a>		</div>

		<p>I already described this in the article. Windows 95 did not auto-detect that a driver was buggy. It consulted a list of &quot;known buggy drivers&quot;. The list of known buggy drivers (and the workaround for each one) was developed only after years of debugging in test labs. </p>
<p>What would be the point of putting up the warning? It&#8217;s not actionable. There&#8217;s nothing the user can do short of uninstalling whatever driver it was (if they could even figure out what the &quot;BGMEM386&quot; driver was and how to uninstall it). </p>
<p>&quot;Aren&#8217;t there Microsoft Certification things for device drivers to somehow keep this from happening?&quot; </p>
<p>How do you prove that a driver is not making invalid assumptions?</p>
<p>&quot;I don&#8217;t understand Microsoft&#8217;s obsession with backwards bug compatibility.&quot; </p>
<p>Did you see the story where IBM telling its employees not to install XP SP2 because of backwards compatibility problems?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202573">
				<div id="div-comment-202573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202573">
			August 11, 2004 at 10:36 am</a>		</div>

		<p>&quot;Did you see the story where IBM telling its employees not to install XP SP2 because of backwards compatibility problems?&quot;</p>
<p>Yes, I did, and it&#8217;s a perfect example of why you should do the right thing as you move forward.  By not making everything backward compatible, XP SP2 is not compromising the security enhancements that help everyone, and it&#8217;s forcing IBM to fix their (internal) apps, which only hurts them in the short term.</p>
<p>A few object lessons like this, and I think you&#8217;d find a lot fewer problems going forward.  APIs that do a better job validating proper usage (when possible) could also help avoid  letting these broken apps from getting into the wild in the first place.</p>
<p>Besides, I&#8217;ve experienced many breakages from Windows updates, even when the application was coded to the API.  Things like printing and user-mode communication through serial ports have changed more times that I can could since Windows 3.1.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202583">
				<div id="div-comment-202583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave stokes</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202583">
			August 11, 2004 at 10:39 am</a>		</div>

		<p>[Mike Dimmick]<br />
<br />&gt;&gt;Based on your last few posts, and the comments, I&#8217;d say it&#8217;s pretty obvious that quite a lot of people just don&#8217;t &#8216;get&#8217; virtual memory at all. I suppose this means that it&#8217;s doing its job &#8211; after all, it&#8217;s supposed to be transparent to a user-mode process and to a user-mode programmer.&lt;&lt;</p>
<p>Is it? Why? If you&#8217;re writing in C# I guess it&#8217;s mostly not an issue. When you start using say memory mapped files and shared memory you do begin to get confronted with the issues. I notice many questions in Forums which indicate that the poster didn&#8217;t have a basic idea of what an address space is, or that other programs&#8217; storage is not even directly addressable (and let&#8217;s not mention shared data sections!) Even with modern hardware and software some knowledge of storage access patterns to optimise paging activity for example might be of value in certain applications. I write a lot of code in assembler and deal with things like cross memory accesses to other address spaces. Lots of this stuff runs in &quot;user&quot; mode, some of it in some system mode, but that&#8217;s only to do with needing to be authorised for certain things, it doesn&#8217;t alter the amount of understanding necessary (admittedly, it&#8217;s not for Windows).</p>
<p>The only people who really need to know the ins and outs of virtual storage in depth are probably the guys who write real and virtual memory managers and invent paging algorithms, but there&#8217;s still a lot to be said for having a basic understanding of what&#8217;s going on.</p>
<p>I notice for example (just a bit off topic, perhaps, but not completely) that VB.Net 2005 has now got something called &quot;My&quot;, which (among quite a few other things) will solve the problems of all those ex-VB6 programmers who can&#8217;t understand how to access a second VB Form in VB.Net, because they just don&#8217;t have a basic (pun unintentional) understanding of what an object is. Good for them maybe, whether it will add to the average quality of future programs is disputable.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202593">
				<div id="div-comment-202593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Qwerty</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202593">
			August 11, 2004 at 11:01 am</a>		</div>

		<p>&quot;I suppose this means that it&#8217;s doing its job &#8211; after all, it&#8217;s supposed to be transparent &quot;</p>
<p>Yes, I completely agree with this.  You can get an &quot;A&quot; in your Intro to Operating Systems class, but I don&#8217;t think it really sinks in till you spend lots of time with MapViewOfFile or the PE file format (file pos -&gt; RVA -&gt; VA, what fun).</p>
<p>Since this is quickly becoming a virtual mem myths series.  How about this one:  &quot;Putting your swap file on a RAM drive is faster than having no swap at all!&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202603">
				<div id="div-comment-202603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://zpbbs.minidns.net/blog' rel='external nofollow' class='url'>Fei Liu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202603">
			August 11, 2004 at 11:19 am</a>		</div>

		<p>I only see your explanation of the relation between &quot;virtual address&quot; and &quot;physical address&quot;, something I have concluded in my previous comment. So what&#8217;s the relation between &quot;virtual address space&quot; and &quot;virtual memory&quot;? Oh and what does it mean when two ptrs have two different values and when you say &quot;They both map the same virtual memory&quot;? </p>
<p>8-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202613">
				<div id="div-comment-202613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202613">
			August 11, 2004 at 11:28 am</a>		</div>

		<p>Raymond wrote: &quot;In Windows/386, the kernel just so happened to map all physical memory into the kernel-mode virtual address space. There was a function _MapPhysToLinear. &#8230; the kernel mapped all of physical memory and just handed out pointers into that single mapping.&quot;</p>
<p>This is exactly what Linux normally does, only it uses a macro so there&#8217;s no point in bypassing it for speed. (Of course this means that drivers have to be rebuilt if the kernel is reconfigured to allow for larger amounts of virtual and/or physical memory, but the kernel developers have never pretended to maintain binary compatibility of drivers.) I&#8217;m surprised that Windows 95 didn&#8217;t continue to do the same, given that it was meant for quite small systems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202623">
				<div id="div-comment-202623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/carmencr' rel='external nofollow' class='url'>Carmen Crincoli</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202623">
			August 11, 2004 at 11:45 am</a>		</div>

		<p>&quot;A few object lessons like this, and I think you&#8217;d find a lot fewer problems going forward. &quot;</p>
<p>Adrian, that&#8217;s one of those statements that&#8217;s very easy to make when you haven&#8217;t suffered through the consequences of a decision like that.</p>
<p>If we made a change that was &quot;right&quot;, but caused the system to crash whenever X-product (that sold 10 million copies) is installed, no one would want to hear it.  I&#8217;ve lived through this (one that slipped through) and it&#8217;s not pretty.</p>
<p>This is why you don&#8217;t let idealists/purists run massive engineering enterprises, IMO.  Imagine if they tried to build the Apollo lander making no comprimises.  Sure, it&#8217;d be reliable and safe, but they&#8217;d still be engineering today.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202633">
				<div id="div-comment-202633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.positivenetworks.net' rel='external nofollow' class='url'>Steve Dispensa</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202633">
			August 11, 2004 at 12:20 pm</a>		</div>

		<p>Remember what life was like in 1994.  NT was only barely in the world, and nobody used it.  Windows 3.1 was common to see, but was still mostly viewed as an add-on to DOS (you had to type &#8216;win&#8217; to get there).  While Microsoft was obviously dominant with regard to DOS, it didn&#8217;t have nearly the lock on the GUI OS market that it has today, and there were other DOS extenders, multitaskers, and GUIs.</p>
<p>They needed, more than anything else, to get Windows 95 to be accepted, so that Win32 programs would start being written, so that Windows NT would eventually become viable in the market.  It&#8217;s easy to see why Microsoft was so eager to make Windows 95 as backward-compatible as possible, in order to encourage a high adoption rate.</p>
<p> -sd<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202653">
				<div id="div-comment-202653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202653">
			August 11, 2004 at 2:16 pm</a>		</div>

		<p>I agree that refusing to load a driver from the list of known-to-be-buggy drivers would have been the most elegant solution.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202673">
				<div id="div-comment-202673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202673">
			August 11, 2004 at 2:42 pm</a>		</div>

		<p>What to do about non-standards compliant code/data has always been a big issue.  If you let the non-compliant stuff by then it never gets fixed and propagates (but your customers are happy) and if you are stringent about it, things eventually get fixed but the developers and customers will blame you until that happens.</p>
<p>To a certain extent the blame rests with authors of the standards, who should really have provided a way to check that code/data does in fact comply.  Microsoft did a good job with the driver verifier so that the issue is addressed in the future, but I don&#8217;t think a verifier was even possible in the days of Windows/386 and 3.1.</p>
<p>I am having my own experience with all this at the moment.  It turns out that with the exception of my own program, there isn&#8217;t a single program out there on Windows, Linux or Mac that I can find that actually correctly implements the vcard standard.  In most cases it seems like the developers only checked importing their own vcards that they exported.</p>
<p>And the vcard standards non-compliance isn&#8217;t over deeply technical things.  It is stuff like getting field names wrong, or not decoded quoted printable fields.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202693">
				<div id="div-comment-202693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202693">
			August 11, 2004 at 2:54 pm</a>		</div>

		<p>What to do about non-standards compliant code/data has always been a big issue.  If you let the non-compliant stuff by then it never gets fixed and propagates (but your customers are happy) and if you are stringent about it, things eventually get fixed but the developers and customers will blame you until that happens.</p>
<p>To a certain extent the blame rests with authors of the standards, who should really have provided a way to check that code/data does in fact comply.  Microsoft did a good job with the driver verifier so that the issue is addressed in the future, but I don&#8217;t think a verifier was even possible in the days of Windows/386 and 3.1.</p>
<p>I am having my own experience with all this at the moment.  It turns out that with the exception of my own program, there isn&#8217;t a single program out there on Windows, Linux or Mac that I can find that actually correctly implements the vcard standard.  In most cases it seems like the developers only checked importing their own vcards that they exported.</p>
<p>And the vcard standards non-compliance isn&#8217;t over deeply technical things.  It is stuff like getting field names wrong, or not decoded quoted printable fields.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202703">
				<div id="div-comment-202703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://geekswithblogs.net/jbrayton/' rel='external nofollow' class='url'>Jeremy Brayton</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202703">
			August 11, 2004 at 3:11 pm</a>		</div>

		<p>&quot;Microsoft shouldn&#8217;t have made those buggy drivers work. They should have just let the computer crash in order to put pressure on the authors of those drivers to fix their bugs.&quot; </p>
<p>What about slapping said developers? There&#8217;s nothing against Bill and Microsoft laying an open fisted slap right across the face of those that use undocumented functions and bitch about it when they&#8217;re broken in the next release. If it&#8217;s undocumented, it&#8217;s bound to break eventually so why rely on it? </p>
<p>If I was developing Windows I would have let them get pissed I think. Sure I would have lost Application X but only for 10 minutes. They would have figured out that it&#8217;s way too much work to redo everything for Apple and Linux and stuck with making a couple of changes to their existing code base. </p>
<p>It makes me also wonder if any vulnerabilities were caused from this very mindset. I&#8217;m sure it&#8217;s possible that while fixing Windows to make driver X work, you opened a hole in the process. I would love to see the ratios to see if vulnerabilities were caused by new code or these types of &quot;patches&quot;. If more vulnerabilities came out of patches versus new code then I would stop doing those kinds of patches. Application X may suffer a little bit but I&#8217;d rather have a more secure OS than let Application X open a hole in my system. Application X wouldn&#8217;t be blamed for the hole because Microsoft is the one who put it there in the first place. </p>
<p>I like hearing about how you have to cater to lazy developers even if it makes me want to slap the living crap out of them. I&#8217;m glad that virtually everything you talk about you give those little caveats. It&#8217;ll frustrate me at some point since I&#8217;m so anal about standards and practices but I want to hear about stuff like this. I think it should be widely known so we can ridicule those developers. Microsoft should have PR releases every time it makes some of these changes and give the exact reason why MS had to do it. I want to know when Application X isn&#8217;t following your specifications so that I can stay clear from their product. I&#8217;m not about to shell out money to developer&#8217;s who can&#8217;t program correctly in the first place. The application may work now but if it breaks in a service pack release I don&#8217;t want it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202543">
				<div id="div-comment-202543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">vince</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202543">
			August 11, 2004 at 9:36 am</a>		</div>

		<p>Why couldn&#8217;t the buggy behavior be traced back to the faulty driver and reported to the user?  Just a paragraph earlier you said the work around detected the behavior and worked around it, surely it could have warned you that your machine was being crippled performancewise.</p>
<p>User confusion I bet you&#8217;d say.  *sigh*</p>
<p>Aren&#8217;t there Microsoft Certification things for device drivers to somehow keep this from happening?</p>
<p>I don&#8217;t understand Microsoft&#8217;s obsession with backwards bug compatibility.  It just rewards lazy programmers and hurts everyone else.</p>
<p>I am glad I only use Linux where usally the &quot;right thing&quot; is done even if it causes some pain.  It makes things so much easier.</p>
<p>And before you go off on backwards compatibility, I have multiple 8+ year old Linux programs that work perfectly on modern distributions.  Linux is excellent with backwards compatibility as long as you stick to *published* interfaces.</p>
<p>And even Microsoft compatibility isn&#8217;t that great.  There are DOS games I have that play much better under dosbox on Linux than they do on win98.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202723">
				<div id="div-comment-202723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202723">
			August 11, 2004 at 5:19 pm</a>		</div>

		<p>Soem of the issues raised by this (and Raymond&#8217;s entire series of 3GB posts) remind me of Apple&#8217;s old distinction between 24 and 32 bit addressing.</p>
<p>If you don&#8217;t remember (or never knew), the Apple Macintosh started out using the Motorola 68000 CPU, a chip designed for 32-bit wide flat addresses, but implemented with a 24-bit wide address bus. Apparantly, the way this was done is that when a pointer was dereferenced, the upper eight bits (of 32) got discarded. This made it pretty easy for developers to stick flag bits (for Lisp-like tagged pointers, etc.) into the discarded upper eight bits.</p>
<p>Now, fast-forward three years and Apple switches to the 68020 Microprocessor, which fully realizes the 32-bit potential of the 68K architecture. Now, rather than discarding the upper eight bits of addresses, the chip actually drives them out onto the address bus&#8230; even if they&#8217;re tag bits. Oops.</p>
<p>The way Apple handles this was actually pretty novel.  On the Mac II motherboard was a socket for an optional 68851 PMMU, a device that handles memory paging of the sort that this series of articles talks about (and was used to support Apple&#8217;s A/UX Unix and Virtual Memory under Systems &gt;=7).  If the PMMU was not installed, Apple shipped AN alternative chip, the AMU.  The AMU was mainly able to optionally mask off the upper eight bits of CPU addresses to allow software written (poorly) for the older 68000 to run unmodified. For a long time, this older software included the OS ROM&#8217;s on the system motherboard. It wasn&#8217;t until the early 90&#8217;s (with the 68040 based Centris 660AV, IIRC) that Apple finally discarded the ability to put their hardware in 24-bit compatibility mode.</p>
<p>They did, however, eventually stop supporting the brokenness inherent in these old 24-bit only applications. I realize that Apple isn&#8217;t exactly the model of software industry success, but IMO, this is perhaps the way to do it.  Handle the broken software for a couple years, make it clear that this support will be going away soon to allow companies to transition, and then drop support in a well documented manner. That seems far preferable to me than dragging support for all the old broken cruft the industry can produce through the ages into successive versions of an OS.</p>
<p>(Alternatively, and like so many others on this blog have proposed, now that VM technology is more mature, as long as old software can run in a VM on the older OS, and stay connected to its environment, who really cares&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202733">
				<div id="div-comment-202733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Perry Lorier</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202733">
			August 11, 2004 at 6:48 pm</a>		</div>

		<p>x86 computers had a similar thing when they moved to the 286 where they put an AND gate on the 20th address line.</p>
<p>Also, logging these things somewhere for developers to realise that their program is broken, and to inform users (that understand enough to read the logs) that the application they are running is making bad assumptions and get an update.  Normal users aren&#8217;t irritated, but developers get the message and the problem gets fixed quickly.</p>
<p>For instance, the 2.6 kernel under Linux reports something like &quot;tcpdump uses obsolete (PF_INET,SOCK_PACKET)&quot;.  It is still supported by the kernel via a backwards compatibility layer, but everyone (other than users who don&#8217;t care) is informed about the problem, and in the next major release it can be removed.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202643">
				<div id="div-comment-202643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/archive/2004/08/11/212720.aspx#212925' rel='external nofollow' class='url'>Adrian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202643">
			August 11, 2004 at 12:45 pm</a>		</div>

		<p>&quot;This is why you don&#8217;t let idealists/purists run massive engineering enterprises, IMO.&quot;</p>
<p>On the contrary, eschewing backward compatibility hacks is the pragmatic approach.  In the long term, back-hacks build upon each other to create intractable problems.</p>
<p>I *have* worked on software that sells millions of copies.  And I&#8217;ve been bit by a wildly popular printer with a buggy driver come out just after we shipped a few million copies.  Yes, we provided a shim for customers with this printer, but we did not compromise performance and functionality for everyone else (which is what many of Raymond&#8217;s stories say Windows did).</p>
<p>Now, in this case, Windows only supported the old behavior for users with known-bad drivers, but it puts the entire system into the backward compatibility mode, leading to further conflicts.  Nothing else on such a machine gets the benefit of the enhancement.  (I assume there was value to tha change, otherwise they would just undo the change rather than support two modes of operation.)</p>
<p>Consider now, a company that tests the heck out of their new (unrelated) drivers on a machines that are not in this backward compatibility mode.  They probably don&#8217;t even know the second mode exists.  What if their driver breaks in the other mode?  If they do learn of the other mode, they have to double their testing.  Next thing you know, there are four modes, then eight, and so one.  Eventually, the problem becomes intractable, all because you went too far trying to support a buggy driver that nobody has today.</p>
<p>Was it worth it?  Does Microsoft have a good reputation for maintaining backward compatibility?  Maybe the stats are good, but the perception isn&#8217;t.  DLL Hell, drivers that break anyway.  Heck, I can&#8217;t even successfully install the .NET framework on my vanilla Windows 98 box (fails without explanation).</p>
<p>Back to the problem at hand.  What should Microsoft do on machines that have some (buggy) drivers that only work in backward compatibility mode and some (also buggy) others that only work in normal mode?  You&#8217;ll eventually end up with contradictions like this.</p>
<p>This isn&#8217;t idealism, is pragmatism.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202763">
				<div id="div-comment-202763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202763">
			August 11, 2004 at 9:40 pm</a>		</div>

		<p>Perry,<br />
<br />  One very big difference: On the 286 machines, the A20 line was disabled by default.</p>
<p>  And when A20 support was added, you had to explicitly enable the A20 line, do your thing, and disable the A20 line.  That was to prevent the myriad known applications from breaking.  There was a device driver known as himem.sys that was added to arbitrate this process.</p>
<p>  If you followed the guidelines, the only things that broke were T&amp;SR&#8217;s that depended on address wrap.  There were some (I had to work around some of them in the DOS LM redirector when I added himem support to it) but very few.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202683">
				<div id="div-comment-202683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202683">
			August 11, 2004 at 2:45 pm</a>		</div>

		<p>Carmen Crincoli wrote:  &quot;This is why you don&#8217;t let idealists/purists run massive engineering enterprises, IMO.&quot;</p>
<p>On the contrary, eschewing backward compatibility hacks is the pragmatic approach.  In the long term, back-hacks build upon each other to create intractable problems.</p>
<p>I *have* worked on software that sells millions of copies.  And I&#8217;ve been bit by a wildly popular printer with a buggy driver come out just after we shipped a few million copies.  Yes, we provided a shim for customers with this printer, but we did not compromise performance and functionality for everyone else (which is what many of Raymond&#8217;s stories say Windows did).</p>
<p>Now, in this case, Windows only supported the old behavior for users with known-bad drivers, but it puts the entire system into the backward compatibility mode, leading to further conflicts.  Nothing else on such a machine gets the benefit of the enhancement.  (I assume there was value to tha change, otherwise they would just undo the change rather than support two modes of operation.)</p>
<p>Consider now, a company that tests the heck out of their new (unrelated) drivers on a machines that are not in this backward compatibility mode.  They probably don&#8217;t even know the second mode exists.  What if their driver breaks in the other mode?  If they do learn of the other mode, they have to double their testing.  Next thing you know, there are four modes, then eight, and so one.  Eventually, the problem becomes intractable, all because you went too far trying to support a buggy driver that nobody has today.</p>
<p>Was it worth it?  Does Microsoft have a good reputation for maintaining backward compatibility?  Maybe the stats are good, but the perception isn&#8217;t.  DLL Hell, drivers that break anyway.  Heck, I can&#8217;t even successfully install the .NET framework on my vanilla Windows 98 box (fails without explanation).</p>
<p>Back to the problem at hand.  What should Microsoft do on machines that have some (buggy) drivers that only work in backward compatibility mode and some (also buggy) others that only work in normal mode?  You&#8217;ll eventually end up with contradictions like this.</p>
<p>This isn&#8217;t idealism, is pragmatism.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202713">
				<div id="div-comment-202713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox [MS]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202713">
			August 11, 2004 at 4:39 pm</a>		</div>

		<p>I think one of the reasons people think that it&#8217;s better to just break stuff and &quot;slap&quot; developers into making better code is that everybody assumes that the bad developers are always other people.</p>
<p>Just like almost everybody thinks that they are an above average driver, almost every developer thinks that when we&#8217;re talking about non-compliant and dubious behavior we must be talking about somebody else.</p>
<p>Trust me, before I joined MS, I had a pretty similar attitude. Because obviously my code was great, and it was only those *other* developers that made dumb mistakes or took stupid shortcuts.</p>
<p>Then I came across one of Raymond&#8217;s internal rants about bad applications he had to fix for Windows 95 compat. And guess what, on the list were apps that I had worked on. Now, it turned out that the particular piece of offending code wasn&#8217;t mine, but it easily could have been &#8211; it wasn&#8217;t like my team was full of bad developers, it was mostly full of developers just like me, developers who I considered to be pretty good at what they did.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202783">
				<div id="div-comment-202783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202783">
			August 12, 2004 at 12:38 am</a>		</div>

		<p>One more thing&#8230; how would MS expect ppl NOT to use undocumented features, if in fact MS supports applications that uses them. If I am a developer  and I know &quot;all of the above&quot; &#8211; that MS will keep makes things compatible, I definetly won&#8217;t hesitate to use them &#8211; if these things MY life easier, why should I bother &#8211; let&#8217;s make MS life harder :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202803">
				<div id="div-comment-202803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AlisdairM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202803">
			August 12, 2004 at 4:04 am</a>		</div>

		<p>I see a couple of recurring themes in the complaints about MS going the extra mile to support bad applications.</p>
<p>i/ assumption is that it is lazy developers, rather than stressed developers in under-resourced departments being pushed by non-technical managers that don&#8217;t care about the details, causing the problems.</p>
<p>ii/ Assumption is that the company that wrote the code is still around to fix it.  With economic fluctuations over the last decade or so, that is a mighty big assumption.  While you might not depend on decade-old software, other do, sometimes for &#8216;mission critical&#8217; tasks.  Should MS discard these customers, just to make our lives as developers easier?</p>
<p>I would really like to see some sort of &#8216;forced deprecation&#8217; process, where misbahaving programs aer shamed in one release, and forced to run in some kind of compatibility sandbox in the next (much like DOS apps today) to keep hacked-support out of the OS mainline.  I am also free to dream, as I don&#8217;t actually have to implement/support this stuff ;&#172; )</p>
<p>Just remember the press MS gets on this stuff today.  Imagine how much worse it would be if they actualy DID allow large numbers of installations to break!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202813">
				<div id="div-comment-202813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom Seddon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202813">
			August 12, 2004 at 5:01 am</a>		</div>

		<p>Wasn&#8217;t there something weird in Windows 3.1 that meant it <em>was</em> faster to have a swap file in a RAM drive than no swap file at all?</p>
<p>(Or maybe it was Windows 3.0.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202823">
				<div id="div-comment-202823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202823">
			August 12, 2004 at 6:02 am</a>		</div>

		<p>Re: ASDF &#8211; as far as I know the Windows API has never changed incompatibly (ie ABI breaks).</p>
<p>Basically I think people would have fewer issues with these sorts of hacks if in userland the APIs were versioned properly. Windows API policy has always been versioning on the function call/flag level, so you have CreateWindowEx but never a new version of the actual windowing infrastructure.</p>
<p>Obviously maintaining backwards compatibility as long as possible is crucial for performance: if you have 1 old app using USER32 v1 and the rest use v2, because some backwards compat hacks that were removed in v2, that&#8217;s still double the memory usage that could have been avoided if you&#8217;d just kept USER32 compatible.</p>
<p>Now, that policy must have made a great deal of sense back in the day (like the non-blinking clock) but is it still true today?</p>
<p>I don&#8217;t know. All I know is that reading Raymonds blog and the comments posted herein have changed my mind about OS backwards compatibility dramatically.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202843">
				<div id="div-comment-202843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202843">
			August 12, 2004 at 6:24 am</a>		</div>

		<p>&quot;I would really like to see some sort of &#8216;forced deprecation&#8217; process, where misbahaving programs aer shamed in one release, and forced to run in some kind of compatibility sandbox in the next (much like DOS apps today) to keep hacked-support out of the OS mainline.&quot; </p>
<p>&quot;Re: ASDF &#8211; as far as I know the Windows API has never changed incompatibly (ie ABI breaks). &quot;</p>
<p>Historically, Microsoft has actually done this (sort of) before. Windows 3.0&#8217;s big innovation was the ability to run Windows applications (those dependant on USER/GDI/KERNEL) in Protected Mode on &gt;=286 chips. Prior to 3.0, Windows applications always ran in real mode, and could do real mode things with segment/offset arithmetic, etc. Of course, for applications that took advantage of the leniency of x86 Real mode, the switch to Protected mode would cause serious problems. As a result, applications had to be tagged with a bit that marked them as safe to run in Windows 3.0 Protected Mode. If you attempted to launch an app that wasn&#8217;t so tagged, the OS would pop up a dialog box explaining the situation. If this was an application you just <em>had</em> to have, Windows 3.0 could be restarted explicitly in real mode, with all of the costs that implies. More intrepid users could actually use a utility/hex-editor to set the protected mode bit in the .EXE and attempt to run their application in protected mode anyway. A year or two later, Windows 3.1 discontinued real mode operation, so you either had to stay with 3.0, tag your old executables, or find replacements/upgrades.</p>
<p>&quot;Wasn&#8217;t there something weird in Windows 3.1 that meant it <em>was</em> faster to have a swap file in a RAM drive than no swap file at all? &quot;</p>
<p>I don&#8217;t know about that, but for a long time it was better to run Windows in Standard mode versus 386 Enhanced Mode. 386 Enhanced mode added to standard mode a V86 DOS multitasker that could run multiple DOS apps on the Windows desktop, preemptively multitasked, and virtual memory. It was also slower. IIRC, the first really compelling use of 32 bit code that benefited Windows (USER/GDI/KERNEL) apps was 32-Bit File Access in Windows for Workgroups 3.11, a reimplementation of the FAT file system that ran in the 32-bit layer of the OS.  32BFA offered significant performance benefits. (It also was the foundation for the Long File Name file system in Windows 95, just as the Win32s infrastructure laid the foundation for Windows 95&#8217;s 32-bit API&#8217;s).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202863">
				<div id="div-comment-202863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202863">
			August 12, 2004 at 6:46 am</a>		</div>

		<p>&quot;Has anyone considered emulation as a solution to these problems? Not a full-blown x86 emulator, just a layer between the OS and the hardware like VMWare. &quot;</p>
<p>Windows XP introduced a compatibility layer:</p>
<p><a target="_new" href="http://support.microsoft.com/default.aspx?scid=kb;en-us;286705&amp;sd=tech" rel="nofollow">http://support.microsoft.com/default.aspx?scid=kb;en-us;286705&#038;sd=tech</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202873">
				<div id="div-comment-202873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202873">
			August 12, 2004 at 6:46 am</a>		</div>

		<p>&quot;Has anyone considered emulation as a solution to these problems? Not a full-blown x86 emulator, just a layer between the OS and the hardware like VMWare. &quot;</p>
<p>Windows XP introduced a compatibility layer:</p>
<p><a target="_new" href="http://support.microsoft.com/default.aspx?scid=kb;en-us;286705&amp;sd=tech" rel="nofollow">http://support.microsoft.com/default.aspx?scid=kb;en-us;286705&#038;sd=tech</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202773">
				<div id="div-comment-202773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202773">
			August 12, 2004 at 12:34 am</a>		</div>

		<p>I think backward compatibility should have a limit&#8230; I think memory manager wasn&#8217;t rewritten just for fun, so make it works as before doesn&#8217;t make much sense. *If* windows can detect such old drivers, it should simply refuse to load them and display proper message&#8230; Otherwise, it is same as check whether user has 16bit applications and said &quot;OK, lets&#8217; work in 16bit mode, since user has old applications&quot;.. </p>
<p>What&#8217;s the point to improve things, if they still keep working as before?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202793">
				<div id="div-comment-202793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202793">
			August 12, 2004 at 3:59 am</a>		</div>

		<p>While I can understand (but do not agree with) the reasoning that leads to the massive accumulation of compatibility hacks that is Windows, a question remains.</p>
<p>If it is true that in the history of Windows, the behaviour of officially published and documented APIs was changed (I don&#8217;t know, it&#8217;s just the impression I get from various posts on this forum), all the efforts that Raymond describes to keep buggy programs working seems hypocritical.</p>
<p>Maybe programmers can trust on Windows bugs they rely on to be emulated in future OS versions *if* their applications are popular enough to appear on the Microsoft compatibility radar. If your application is unimportant, however, Microsoft can change the *public API* so that your properly written application stops working.</p>
<p>As I said, I don&#8217;t know if this is true. If it is, I would like to hear the reasons for a change of the documented Windows API. Security? (Honestly, I wouldn&#8217;t believe it.) Bugs in the previous implementation? (Nah, Raymond describes how these are typically emulated.) Preserving compatibility with other, very popular applications?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202833">
				<div id="div-comment-202833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202833">
			August 12, 2004 at 6:04 am</a>		</div>

		<p>&quot;x86 computers had a similar thing when they moved to the 286 where they put an AND gate on the 20th address line. &quot;</p>
<p>Oh yeah. I had forgotten, but now I remember. *shudder*</p>
<p>At the time, I had an old ALR Powerflex machine that drove the A20 gate with its (marginal) keyboard controller. The net result of this was that any memory manager that rapidly toggled the A20 gate to access the UMA would screw up the keyboard. Apparantly, the ALR&#8217;s poor keyboard controller couldn&#8217;t keep up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202853">
				<div id="div-comment-202853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-202853">
			August 12, 2004 at 6:32 am</a>		</div>

		<p>I guess one of the issues people have with compat work is that they apply not only to the old applications they were meant for, but to newly written ones as well. There needs to be a strategy so that applications compiled after (say) January 1 2005, or linked with &#8211;don&#8217;t-use-pre-Windows-XP-compatibility-hacks get an OS that behaves as if it were rewritten from scratch today. (I know that *actually* rewriting Windows from scratch would be a very bad idea.)</p>
<p>Has anyone considered emulation as a solution to these problems? Not a full-blown x86 emulator, just a layer between the OS and the hardware like VMWare.</p>
<p>That way, we could run old programs on their native OSs with all their bugs. In the new OS, these bugs would be fixed (not emulated).</p>
<p>Maybe the performance hit is too large for applications from the last OS generation. So maybe Longhorn could only emulate software written for up to Windows 98.</p>
<p>The benefits are still apparent. All the compatibility codepaths for these old OSs would be rigorously cut out. In software development in general (at Microsoft in particular, it seems =)), fewer codepaths ==&gt; fewer security related bugs. Not just because compat hacks are potentially buggy, but because a smaller kernel means more security reviews per line of code.</p>
<p>Windows Superdick (release date 2012) would then emulate Win 2000 software and so on. In 2020, we will get Windows/2 Warp, which is virtually hack-free.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203283">
				<div id="div-comment-203283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-203283">
			August 16, 2004 at 5:41 am</a>		</div>

		<p>Users <em>will</em> install old versions of applications on new operating systems. They won&#8217;t necessarily download patches to make the applications work. The vendor may not decide to produce and support such patches (especially if the vendor has gone bankrupt&#8230;) The user expects the same application, installed directly from the original media, to continue working. Corporate users will have in-house applications developed by third parties, and won&#8217;t want to spend anything on getting those applications updated if they&#8217;re still performing their tasks. So we as platform developers have to, as far as possible, be binary compatible.</p>
<p>Once you&#8217;ve developed a binary compatibility layer, the safest thing to do is to leave it there for all time. Why? Because <em>any</em> change to software is risky. Modifying a module to remove backward compatibility has the possibility of introducing new bugs, which could break existing software that <em>doesn&#8217;t</em> use the obsolete APIs. Modifying the module for no other purpose still means performing the whole cycle of regression testing. Larry Osterman wrote an article on Friday &#8211; <a target="_new" href="http://blogs.msdn.com/larryosterman/archive/2004/08/13/214338.aspx" rel="nofollow">http://blogs.msdn.com/larryosterman/archive/2004/08/13/214338.aspx</a> &#8211; about how a piece of code from the Windows 3.1 beta ended up in RTM even though it wasn&#8217;t actually used.</p>
<p>Since we&#8217;re on a virtual memory topic, I&#8217;ll remind you that Windows is demand paged &#8211; it only loads code into memory that&#8217;s referenced. If no code calls the obsolete API, it won&#8217;t be loaded, won&#8217;t affect the process&#8217;s working set and won&#8217;t use &#8211; even temporarily &#8211; any physical memory. The bits take a little disk space, that&#8217;s all. Will the user prefer to pay $0.01 for the disk space, or an extra $10 per copy for the additional testing?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203293">
				<div id="div-comment-203293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mschaef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-203293">
			August 16, 2004 at 7:22 am</a>		</div>

		<p>&quot;If no code calls the obsolete API, it won&#8217;t be loaded, won&#8217;t affect the process&#8217;s working set and won&#8217;t use &#8211; even temporarily &#8211; any physical memory. The bits take a little disk space, that&#8217;s all. Will the user prefer to pay $0.01 for the disk space, or an extra $10 per copy for the additional testing? &quot;</p>
<p>I agree with what you&#8217;re saying, but doesn&#8217;t that sentence ignore testing costs for the compatibility layer? Presumably, it costs Microsoft some amount of money to keep things working and tested.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-206513">
				<div id="div-comment-206513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.savagenomads.net/archives/000203.html' rel='external nofollow' class='url'>Savage Nomads</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-206513">
			August 27, 2004 at 11:50 pm</a>		</div>

		<p>&amp;nbsp; As Evan&amp;nbsp;already mentioned on his blog, Raymond Chen has a great series on /3GB switch on his blog. What is really cool is that Raymond takes on some myths about the /3GB switch and&amp;nbsp; the fact that he&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-229093">
				<div id="div-comment-229093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/exchange/archive/0001/01/01/217772.aspx' rel='external nofollow' class='url'>You Had Me At EHLO...</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040811-00/?p=38193#comment-229093">
			November 23, 2004 at 7:25 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

