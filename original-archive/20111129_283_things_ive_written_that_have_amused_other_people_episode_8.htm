<html>
<head>
<title>Things I've written that have amused other people, Episode 8</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Things I&#8217;ve written that have amused other people, Episode 8</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 29, 2011 / year-entry #284</td></tr>
<tr><td><b>Tags:</b></td><td>non-computer</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>26</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">In a technical discussion, I opened a reply with Bob's paper which I haven't yet read points out that... Some people wrote to me to say that the've added this quote to their file in the hopes of being able to use it themselves someday. For those who are curious, I found the technical discussion...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
In a technical discussion, I opened a reply with
</p>
<blockquote CLASS=q><p>
Bob's paper which I haven't yet read points out that...
</p>
</blockquote>
<p>
Some people wrote to me to say that the've added this quote to their file
in the hopes of being able to use it themselves someday.
</p>
<p>
For those who are curious, I found the technical discussion in question.
It had to do with whether the following code is thread-safe:
</p>
<pre>
// initial conditions
int x = 1, y = 0;
int *p = &amp;x;

// Thread 1 executes this
y = 1;
MemoryBarrier();
p = &amp;y;

// Thread 2 executes this
print *p;
</pre>
<p>
Question: Can this code legitimately print <code>0</code>?
</p>
<p>
Surprisingly,
<a HREF="http://www.cs.umd.edu/~pugh/java/memoryModel/AlphaReordering.html">
the answer is <i>yes</i></a>!</p>
<p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (26)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-950043">
				<div id="div-comment-950043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950043">
			November 29, 2011 at 7:41 am</a>		</div>

		<p>Moral: reasoning about multithreaded code is hard. &nbsp;I hope I never have to write code that will run on the Alpha 21264. &nbsp;x86, x86-64, and PPC is enough for me for now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950063">
				<div id="div-comment-950063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vilx-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950063">
			November 29, 2011 at 7:53 am</a>		</div>

		<p>This just goes to show: Multithreading is the root of all evil! XD</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950073">
				<div id="div-comment-950073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tony r</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950073">
			November 29, 2011 at 7:58 am</a>		</div>

		<p>that hurts just looking at it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950083">
				<div id="div-comment-950083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950083">
			November 29, 2011 at 7:58 am</a>		</div>

		<p>Nah, it just shows our tools (both the theory and software) are insufficient ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950093">
				<div id="div-comment-950093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950093">
			November 29, 2011 at 8:01 am</a>		</div>

		<p>Although I&#39;m a bit annoyed by the fact that everyone points at the same example and then just stops. It would be much more interesting what problems occur on other processors, if any. If it&#39;s just the Alpha which is problematic that&#39;s ok, since you need to know your target architecture anyways when writing lockless code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950103">
				<div id="div-comment-950103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frank Schwab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950103">
			November 29, 2011 at 8:06 am</a>		</div>

		<p>No, it shows that there is broken hardware in the world.</p>
<p>A multi-processor system that &quot;defers&quot; processing of messages to invalidate cache is broken. Plain and simple. &nbsp;The hardware designers may have thought they were making decisions to optimize performance, but they failed in their duty to build usable hardware. &nbsp;At the very least, the compiler for this architecture needs to understand the failure model here and work around it by inserting the appropriate memory barriers automatically (which, of course, greatly slows the rest of the code in the application). &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950113">
				<div id="div-comment-950113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeroen Mostert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950113">
			November 29, 2011 at 8:08 am</a>		</div>

		<p>Memory models are one area where hardware optimization still trumps programmer expectation. The engineers will build what&#39;s fast, not what&#39;s intuitive &#8212; instead of the processor being there to execute your program, it&#39;s patiently sitting there waiting for test cases, of which your program happens to be just one. So now you get to figure out two programs: the one you wrote and the one the processor engineers wrote. If you&#39;re not lucky or smart enough to get one memory model that appropriately covers all processors you&#39;re targeting, Turing help you &#8212; and even if you do, don&#39;t expect that model to be comprehensible to mere mortals.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950123">
				<div id="div-comment-950123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Me</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950123">
			November 29, 2011 at 8:10 am</a>		</div>

		<p>IMO, this doesn&#39;t just show that &quot;reasoning about multithreaded code is hard&quot;. It shows that it is almost impossible for everyone who is not a dedicated expert in the field. Even if you think you know enough about this, chances are pretty high you are wrong.</p>
<p>It&#39;s very similar to crypto in this regard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950133">
				<div id="div-comment-950133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950133">
			November 29, 2011 at 8:13 am</a>		</div>

		<p>I must agree with Frank Schwab. The hardware is broken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950153">
				<div id="div-comment-950153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950153">
			November 29, 2011 at 8:25 am</a>		</div>

		<p>I thought the Alpha was long buried?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950173">
				<div id="div-comment-950173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Torgo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950173">
			November 29, 2011 at 9:11 am</a>		</div>

		<p>I had to re-read that quote a few times to understand it. I&#39;ll add it to my quote file adding couple of commas: &quot;Bob&#39;s paper, which I haven&#39;t yet read, points out that&#8230;&quot;</p>
<p>Of course, that confusion was nothing compared to understanding how the code could print 0 (at least prior to reading the link).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950183">
				<div id="div-comment-950183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zan Lynx</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950183">
			November 29, 2011 at 9:14 am</a>		</div>

		<p>The hardware is not broken. It doesn&#39;t work the way that you would like it to, but there was a reason Alpha CPUs were fast. This was one of the reasons.</p>
<p>I believe Itanium can show the same sort of behavior, depending on what sort of speculative stores and loads are used.</p>
<p>And if you think Alphas are broken, you should try some cell phones where there&#39;s no cache coherency at all. All inter-CPU communication has to be done through queues and cache lines are synchronized only on particular interrupts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950193">
				<div id="div-comment-950193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EMB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950193">
			November 29, 2011 at 9:26 am</a>		</div>

		<p>Foreign language programmer here&#8230; I&#39;m not sure I understood what you mean with that. How can you know what Bob&#39;s paper points out without read it yet?</p>
<p>Did you already built your time machine and talking to yourself from the future? Yes, I&#39;m serious. Can someone explain?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950203">
				<div id="div-comment-950203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950203">
			November 29, 2011 at 9:36 am</a>		</div>

		<p>@EMB</p>
<p>Presumably he read the abstract but not the full paper.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950223">
				<div id="div-comment-950223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950223">
			November 29, 2011 at 10:23 am</a>		</div>

		<p>@Zan Lynx: then that had better not be SMP as no code could survive being motioned from one processor to another.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950233">
				<div id="div-comment-950233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950233">
			November 29, 2011 at 10:34 am</a>		</div>

		<p>EMB: Perhaps Raymond follows the Alpha memory model. If he didn&#39;t put a memory barrier between reading the paper and writing his reply, the two could be reordered to that if Bob changed the paper, Raymond could have written a reply based on the old paper despite having (later) read the new one. Hence the warning.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950253">
				<div id="div-comment-950253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Grier [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950253">
			November 29, 2011 at 11:19 am</a>		</div>

		<p>Several interesting layers here.</p>
<p>First, the hardware wasn&#39;t broken. &nbsp;It was implementing the memory coherency spec for Alpha correctly. &nbsp;The Alpha ARM (Architecture Reference Manual, not the ARM CPU architecture&#8230;) was very detailed in allowing for loose memory coherency models. &nbsp;You may not like the architecture for that reason, you may feel that the design made coding more complex than it needed to be but as was pointed out, the coherency design allowed for a significant reduction in blockages in the pipeline on MP systems.</p>
<p>Second, people do this because locks are considered bad. &nbsp;There are really two problems at hand here:</p>
<p>2a. People hold primitive locks over inappropriate amounts of processing. &nbsp;Holding a lock while performing a compare-and-store operation is just fine. &nbsp;The problem that people usually have is a primitive lock held over a lengthy operation like I/O. &nbsp;It&#39;s a good idea if you&#39;re in a hot path to ensure that the cache lines you will touch in the primitive lock are in the cache and the pages in the TLB. &nbsp;This will avoid any cases where you accidently hold the lock for an excessive amount of time in the first place.</p>
<p>2b. A lot of lock implementations were bad. &nbsp;A great engineer in the Windows team fixed most of the primitive locks in Windows a few years ago which changed the equation dramatically. &nbsp;For a long time it was &quot;common knowledge&quot; to do the double checked locking pattern; after he fixed critical sections, there was very little reason to still do so.</p>
<p>Sometimes you really do need to do something like this. &nbsp;But it&#39;s pretty darned rare; it&#39;s mostly something that people who work on things like the scheduler or page fault handler in the kernel worry about. &nbsp;If you&#39;re working at that layer of the system you had better understand the memory model in detail.</p>
<p>Third, this is exacerbated by the C/C++ language not acknowledging the existence of multithreaded programming for an extended period of time. &nbsp;There was no mandated abstract memory model (which may not expose the same sharp edges implied here) so it is/was extremely difficult to write precise code that behaved the same on all processors. &nbsp;When your mental model is that C is a high level assembly language, you would be surprised if normal reads or writes to shared values implied barriers of any kind. &nbsp;The CLR memory model is very explicit on these points; I assume JVM is also but I haven&#39;t verified.</p>
<p>Finally, x86 and ARM also have similar sharp edges in their memory models which really just gets you back to the original point of &quot;just use locks correctly and you won&#39;t have a problem&quot;. &nbsp;(This of course says that perhaps it wasn&#39;t fruitful for the Alpha ARM to specify such a loose model but the designers were looking for an architecture that would be able to flourish over the coming 20-30 years.) &nbsp;It&#39;s surprising how many similar misunderstandings of the x86 MP cache coherency models existed for such a long time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950283">
				<div id="div-comment-950283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950283">
			November 29, 2011 at 2:44 pm</a>		</div>

		<p>And that&#39;s why a clearly defined memory model such as Javas is such a helpful &#8211; and I&#39;d even say necessary thing &#8211; for writing correct(!) non-blocking multi threaded code. I haven&#39;t looked at the MM of the new c++ standard, but before that you basically had to write your c++ algorithms for one specific architecture and most of the time even one specific compiler if you wanted to be clever.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950293">
				<div id="div-comment-950293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950293">
			November 29, 2011 at 3:00 pm</a>		</div>

		<p>@Michael Grier:</p>
<p>If it doesn&#39;t violate the principle of least surprise, it&#39;s not nearly as good a pit.</p>
<p>Next, you really want to lambast C and C++ for not providing a comprehensive definition for multithreaded/multiprocess behavior? Doesn&#39;t UB cover it all beautifully, especially considering the amount of resources which were since and are especially now poured into just this crack, regularly bending or breaking previous best practice/existing design rules? As far as I know, that&#39;s true for all architectures/programming languages allowing/extensible to multiprocessing.</p>
<p>And do Java/.Net really solve all the hassles and corner-cases? I seem to recall difficulties with timed locks and exceptions.</p>
<p>@voo: Let&#39;s celebrate raising things to the lowest common denominator. Not? Then there&#39;s really expensive machinery faking things for those bad nonconformists. But rest assured: If you don&#39;t want to be more clever in C++ than in C#, nobody forces you to be, even though you drop a bit of the potential extra performance, writing to said lcd.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950303">
				<div id="div-comment-950303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950303">
			November 29, 2011 at 3:53 pm</a>		</div>

		<p>An obscure question that I&#39;m not up to spending the time to figure out, but someone may know: is it possible to &quot;fix&quot; this problem by declaring any or all of the variables &quot;volatile&quot;?</p>
<p>Note that I don&#39;t mean &quot;fix it as a practical matter in the existing implementations of the C/C++ compilers on various platforms&quot; but &quot;make it a violation of the specification to misbehave this way, and therefore answer the question &#39;is this legitimate?&#39;&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950163">
				<div id="div-comment-950163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950163">
			November 29, 2011 at 9:01 am</a>		</div>

		<p>And this is why you should always pair your memory barriers.</p>
<p>For people who want to read more about it, there is a *very* detailed explanation on the Linux kernel &quot;Documentation/memory-barriers.txt&quot; file. It is long, but worth it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950313">
				<div id="div-comment-950313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Grier [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950313">
			November 29, 2011 at 5:02 pm</a>		</div>

		<p>@deduplicator:</p>
<p>I don&#39;t get the reference but looseness of specifications are what allow innovation to occur without excessive costs paid. &nbsp;We&#39;re fortunate that Intel has made a mint or two on the x86 processor and has reduced what would seem to be a poorly designed processor architecture to practice to enough of a degree that really a competitor has to operate on a fundamentally different premise (e.g. the extreme parallelization of GPUs or the extreme low power of ARM SOCs) to compete. &nbsp;It was always designed for automatic compilation rather than hand assembly of codes so some of these tricky things could become the pervue of compiler or code generation writers.</p>
<p>Alpha&#39;s failure wasn&#39;t anything technical (although some specific attributes like lack of byte addressing surprised people); it was Robert Palmer&#39;s disassembly of DEC leading to the assets going to Compaq which was already in bed with H-P and didn&#39;t want to rock the boat for the VLIW/PA-RISC followon, Itanium.</p>
<p>I hardly call pointing out that the problem is exacerbated by the lack of stance &quot;lambasting&quot; the languages. &nbsp;I was trying to be open here about how to have safe portable code but even just within the Microsoft C/C++ toolset, it wasn&#39;t until fairly recently that the whole relationship between volatile and acquire/release memory coherency semantics was worked out. &nbsp;It is certainly possible for any given compiler implementation to take a stance; for all I know, gcc is very concrete on this topic.</p>
<p>Timed locks and exceptions seem to be a higher level problem than the basic memory coherency model. &nbsp;The CLR takes a stance on this topic. &nbsp;Memory coherency doesn&#39;t solve all problems by any means but at least it means that teams which implement higher level synchronization objects like the .net frameworks have a basis on which they can judge the correctness of their implementation. &nbsp;As I mentioned, I have no idea what levels of guarantees the JVM provides or what synchronization primitives in the common class libraries are implemented as native call-outs vs. on top of the JVM. &nbsp;(Note that the runtime providing a guarantee isn&#39;t sufficient &#8211; optimizing compilers must also have rules to follow. &nbsp;Eric Lippert has a great blog and has covered some of these issues with respect to C# in the past. <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/ericlippert/" rel="nofollow">blogs.msdn.com/&#8230;/ericlippert</a>)</p>
<p>As soon as you move up the stack such that you&#39;re going to have timeouts and alternate code paths dealing with those timeouts, it gets much harder to reason about correctness so I won&#39;t try to for the sake of this discussion.</p>
<p>@Ray Trent:</p>
<p>It depends on how the compiler decided to define volatile. &nbsp;This was a topic of much debate some years ago when people realized that the x86 memory model wasn&#39;t as &quot;obvious&quot; as people first thought. &nbsp;Volatile came in to existence to solve the problems of driver writers dealing with memory mapped I/O so the expectations were around forcing reads and writes to occur in the same order that they appear in the source code. &nbsp;The fact that these reads and writes could have side effects on other shared values wasn&#39;t immediately obvious when the feature was implemented.</p>
<p>Worthwhile reads:</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Volatile_variable" rel="nofollow">en.wikipedia.org/&#8230;/Volatile_variable</a></p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Memory_ordering" rel="nofollow">en.wikipedia.org/&#8230;/Memory_ordering</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950323">
				<div id="div-comment-950323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950323">
			November 29, 2011 at 5:25 pm</a>		</div>

		<p>@Deduplicator Well go on and show me all those amazing crossplatform, cross compiler non-blocking data structures in C++. You won&#39;t find many. Getting non-blocking code in C++ right is almost (sure you can do it if you specify which compiler [and which major generation/version there] and architecture you&#39;re using) impossible so it&#39;s more a question about maybe giving up some performance (the guarantees Java wants aren&#39;t that problematic on most modern CPUs it seems to me) vs. getting a probably bugged implementation or just giving up and using locks. In practice most people went with locking in their c++ programs for a good reason.</p>
<p>You can abstract differences between CAS and ll/cs,.. away without losing too much, but it certainly makes live a whole lot easier for the rest of us.</p>
<p>@Michael Grier: For Java volatile basically guarantees a memory barrier, but there are the usual low-level intrinsics available (if you&#39;d be interested, you can look at the &quot;unsafe&quot; class).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-950263">
				<div id="div-comment-950263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950263">
			November 29, 2011 at 2:11 pm</a>		</div>

		<p>A lot of blog commenters use this memory model and post before reading the article, so perhaps Raymond should add a MemoryBarrier somewhere in his posts&#8230; or&#8230; maybe he already did and that&#39;s why we have to &quot;double-post&quot; to get our ignorance in front of the internet!! It&#39;s the cache-invalidate in action!!</p>
<p>Now to answer the question:</p>
<p>&quot;Is this code wrong by sometimes printing 0?&quot;, no, but &quot;Is it an a**hole for doing so?&quot;, yes, definitely!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-950543">
				<div id="div-comment-950543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-950543">
			December 1, 2011 at 4:36 am</a>		</div>

		<p>C+11 now covers multithreaded code, so the legitimacy of an equivalent C++11 fragment can now be judged. Clearly, all the instructions in each thread are fully sequenced. I.e. p = &amp;y; is sequenced after y=1. This might be an issue for Alpha&#39;s, but C++11 is clear: The execution of a program contains a data race if it contains two conflicting actions in *different threads*. Since there&#39;s no conflicting action in the second thread, there&#39;s no data race.</p>
<div class="post">[<i>There is at least one, possibly two conflicting actions in the second thread: First, the read of p <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2429.htm" rel="nofollow">conflicts</a> with the write of p in the first thread. And if the read of p reads &amp;y, then there is a second conflict: The read of y conflicts with the write of y in the first thread. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-951043">
				<div id="div-comment-951043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Kuperstein</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20111129-00/?p=9013#comment-951043">
			December 4, 2011 at 12:17 pm</a>		</div>

		<p>@voo</p>
<p>Java is a really bad example. The original Java memory model was completely broken. The new one is not (too) broken, but is so complicated the number of people who can reasonably claim to understand it can be counted on one hand. I can think of Doug Lea, and possibly a few more. The current consensus* among experts is that Java-like models are broken on a foundational level.</p>
<p>* <a rel="nofollow" target="_new" href="http://cacm.acm.org/magazines/2010/8/96610-memory-models-a-case-for-rethinking-parallel-languages-and-hardware/fulltext" rel="nofollow">cacm.acm.org/&#8230;/fulltext</a> </p>
<p>The authors are Sarita Adve and Hans Boehm. Hans is the principle designer of the C++11 memory model, and Sarita participated on the design of both the C++11 MM and the (fixed) JMM.</p>
<p>The relevant quote is: &quot;While it may be possible to fix the Java model, it seems undesirable that our specification of multithreaded program behavior would rest on such a complex and fragile foundation. Instead, the section entitled &quot;Implications for Languages&quot; advocates a fundamental rethinking of our approach.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

