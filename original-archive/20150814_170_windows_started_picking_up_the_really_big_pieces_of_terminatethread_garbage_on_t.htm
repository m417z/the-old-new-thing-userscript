<html>
<head>
<title>Windows started picking up the really big pieces of TerminateThread garbage on the sidewalk, but it's still garbage on the sidewalk</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Windows started picking up the really big pieces of TerminateThread garbage on the sidewalk, but it&#8217;s still garbage on the sidewalk</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 14, 2015 / year-entry #171</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>45</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Ah, Terminate­Thread. There are still people who think that there are valid scenarios for calling Terminate­Thread.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Ah,
<code>Terminate&shy;Thread</code>.
There are still people who think that there are valid scenarios
for calling
<code>Terminate&shy;Thread</code>.
<span id="more-91811"></span>
</p>
<blockquote CLASS=q>
<p>
Can you explain how <code>Exit&shy;Thread</code> works?
</p>
<p>
We are interested because we have a
class called <code>Thread&shy;Class</code>.
We call the <code>Start()</code> method ,
and then the
<code>Stop()</code> method,
and then the
<code>Wait&shy;Until&shy;Stopped()</code> method,
and then the process hangs with this call stack:
</p>
<pre>
ntdll!ZwWaitForSingleObject
ntdll!RtlpWaitOnCriticalSection
ntdll!RtlEnterCriticalSection
ntdll!LdrShutdownThread
ntdll!RtlExitUserThread
kernel32!BaseThreadInitThunk
ntdll!RtlUserThreadStart
</pre>
<p>
Can you help us figure out what's going on?
</p>
</blockquote>
<p>
From the stack trace, it is clear that the thread is shutting down,
and the loader (<code>Ldr</code>) is waiting on a critical section.
The critical section the loader is most famous for needing is
the so-called
<i>loader lock</i> which is used for various things,
most notably to make sure that all DLL thread notification
are serialized.
</p>
<p>
I guessed that the call to
<code>Wait&shy;Until&shy;Stopped()</code> was happening
inside <code>Dll&shy;Main</code>,
which created a deadlock because the thread cannot exit
until it delivers its <code>Dll&shy;Main</code> notifications,
but it can't do that until the calling thread exits
<code>Dll&shy;Main</code>.
</p>
<p>
The customer did some more debugging:
</p>
<blockquote CLASS=q>
<p>
The debugger reports the critical section as
</p>
<pre>
CritSec ntdll!LdrpLoaderLock+0 at 77724300
WaiterWoken        No
LockCount          3
RecursionCount     1
OwningThread       a80
EntryCount         0
ContentionCount    3
*** Locked
</pre>
<p>
The critical section claims that it is owned by thread
<code>0xa80</code>, but there is no such active thread in the process.
In the kernel debugger, a search for that thread says
</p>
<pre>
Looking for thread Cid = a80 ...
THREAD 8579e1c0  Cid 0b58.0a80  Teb: 00000000 Win32Thread: 00000000 TERMINATED
Not impersonating
DeviceMap                 862f8a98
Owning Process            0       Image:         &lt;Unknown&gt;
Attached Process          84386d90       Image:         Contoso.exe
Wait Start TickCount      12938474       Ticks: 114780 (0:00:29:50.579)
Context Switch Count      8             
UserTime                  00:00:00.000
KernelTime                00:00:00.000
Win32 Start Address 0x011167c0
Stack Init 0 Current bae35be0 Base bae36000 Limit bae33000 Call 0
Priority 10 BasePriority 8 PriorityDecrement 2 IoPriority 2 PagePriority 5
</pre>
<p>
<code>Contoso.exe</code> is our process.
</p>
</blockquote>
<p>
Okay, we're getting somewhere now.
The thread <code>0xa80</code> terminated while it held
the loader lock.
When you run the program under a debugger,
do you see any exceptions that might suggest that the thread
terminated abnormally?
</p>
<blockquote CLASS=q>
<p>
We found the cause of the problem.
We use <code>Terminate&shy;Thread</code> in the other place.
That causes the thread to continue to hold the loader lock
after it has terminated.
</p>
</blockquote>
<p>
It's not clear what the customer meant by
"the other place",
but no matter.
The cause of the problem was found:
They were using
<code>Terminate&shy;Thread</code>.
</p>
<p>
At this point,
Larry Osterman
was inspired to write a poem.
</p>
<blockquote CLASS=m><p>
How many times does<br>
it have to be said: Never<br>
call TerminateThread.
</p>
</blockquote>
<p>
In the ensuing discussion, somebody suggested,
</p>
<blockquote CLASS=q><p>
One case where it is okay to use <code>Terminate&shy;Thread</code>
is if the thread was created suspended and has never been resumed.
I believe it is perfectly legal to terminate it,
at least in Windows Vista and later.
</p>
</blockquote>
<p>
No, it is not "perfectly legal,"
for certain values of "perfectly legal."
</p>
<p>
What happened is that Windows Vista added some code to try to limit
the impact of a bad idea.
Specifically, it added code to free the thread's stack when the
thread was terminated,
so that each terminated thread didn't leak a megabyte of memory.
In the parlance of earlier discussion,
I referred to this as
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2010/03/11/9976571.aspx">
stop throwing garbage on the sidewalk</a>.
</p>
<p>
In this case, it's like saying,
"It's okay to run this red light because the city added a delayed
green to the cross traffic."
The city added a delayed green to the cross traffic because people
were running the light and the city didn't want people to die.
That doesn't mean that it's okay to run the light now.
</p>
<p>
Unfortunately, the guidance that says "Sometimes it's okay to
call <code>Terminate&shy;Thread</code>" has seeped into our
own Best Practices documents.
The <a HREF="http://msdn.microsoft.com/en-us/library/windows/desktop/dn633971(v=vs.85).aspx">
Dynamic-Link Library Best Practices</a>
under
<i>Best Practices for Synchronization</i>
describes a synchronization model which actually involves
calling <code>Terminate&shy;Thread</code>.
</p>
<p>
<i>Do not do this</i>.
</p>
<p>
It's particularly sad because
<a HREF="https://view.officeapps.live.com/op/view.aspx?src=http%3A%2F%2Fdownload.microsoft.com%2Fdownload%2Fa%2Ff%2F7%2Faf7777e5-7dcd-4800-8a0a-b18336565f5b%2FDLL_bestprac.doc">
the downloadable version of the document</a>
references both Larry and me telling people to stop
doing crazy things in <code>Dll&shy;Main</code>,
and terminating threads is definitely a crazy thing.
</p>
<p>
(The solution to the problem described in the whitepaper is not
to use <code>Terminate&shy;Thread</code>.
It's to use
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2013/11/05/10463645.aspx">
the
<code>Free&shy;Library&shy;And&shy;Exit&shy;Thread</code> pattern</a>.)
</p>
<p>
Now the history.
</p>
<p>
Originally, there was no
<code>Terminate&shy;Thread</code> function.
The original designers felt strongly
that no such function should exist because there
was no safe way to terminate a thread,
and there's no point having a function that
cannot be called safely.
But people screamed that they needed the
<code>Terminate&shy;Thread</code> function,
even though it wasn't safe,
so the operating system designers
caved and added the function because
people demanded it.
Of course, those people who insisted that they
needed <code>Terminate&shy;Thread</code> now
regret having been given it.
</p>
<p>
It's one of those "Be careful what you wish for" things.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (45)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1208981">
				<div id="div-comment-1208981" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208981">
			August 14, 2015 at 7:10 am</a>		</div>

		<p>Yeah hmmm. I guess I always knew. I used to say back in the Windows XP days that it&#39;s one of those functions that must exist but must not be used.</p>
<p>I used to think it was safe to call TerminateThread on a thread that had suspended itself (or in a spinlock)&#8211;I hadn&#39;t discovered EnterCriticalSection yet&#8211;but apparently not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208971">
				<div id="div-comment-1208971" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208971">
			August 14, 2015 at 7:17 am</a>		</div>

		<p>Semi-OT: That&#39;s not a poem.</p>
<p>And even if it fits the 5-7-5 pattern if you happen to put line breaks there, the pause in reading is definitely before &quot;Never&quot;, not after.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208961">
				<div id="div-comment-1208961" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andre</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208961">
			August 14, 2015 at 7:21 am</a>		</div>

		<p>I figure it&#39;s not just &quot;those people who insisted that they needed TerminateÂ­Thread now regret having been given it&quot;, it&#39;s also the Windows designers who regret giving in. They new it was horrible, now they have to implement work-arounds for it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208951">
				<div id="div-comment-1208951" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio &amp;#39;Grijan&amp;#39;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208951">
			August 14, 2015 at 7:40 am</a>		</div>

		<p>One more for the collection of functions that must carry a big red warning saying &quot;Only for use by debuggers&quot; in its documentation. Any sane programmer should know s/he should keep away from TerminateThread. Any thread should be designed in a way that you can notify it that you want it to terminate, so it can do its clean up in a controlled fashion. If a thread does not respond to a request for termination, you should assume a worst case scenario (state or memory corruption), and take down the whole process as orderly as you can. Just another application of the &quot;fail fast&quot; principle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208941">
				<div id="div-comment-1208941" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208941">
			August 14, 2015 at 9:21 am</a>		</div>

		<p>@AC: Looks like a poem to me. &quot;Said&quot; and &quot;thread&quot; rhyme, don&#39;t they?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208931">
				<div id="div-comment-1208931" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">McBucket</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208931">
			August 14, 2015 at 9:44 am</a>		</div>

		<p>Larry Osterman&#39;s poem works as a haiku, I guess, but Western minds (like mine) will probably want a regular rhythmic meter scheme. I suggest:</p>
<p>How many times does it have to be said, </p>
<p>&quot;Never, not ever, call TerminateThread.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208921">
				<div id="div-comment-1208921" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208921">
			August 14, 2015 at 9:54 am</a>		</div>

		<p>&gt; because there was no safe way to terminate a thread</p>
<p>I think there is one safe way to terminate a thread (so far I couldn&#39;t think of any other one): TerminateProcess. It can reliably terminate a thread without causing any of these issues, by ensuring that everything that could depend on the thread&#39;s state is cleaned up (by the kernel) at the same time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208911">
				<div id="div-comment-1208911" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208911">
			August 14, 2015 at 10:19 am</a>		</div>

		<p>@McBucket I find it works better if you add dramatic pauses after &quot;Never&quot; and &quot;Call&quot;:</p>
<p>How many times does it have to be said?</p>
<p>&quot;Never[.] Call[.] TerminateThread.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208901">
				<div id="div-comment-1208901" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Douglas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208901">
			August 14, 2015 at 11:09 am</a>		</div>

		<p>@Cesar</p>
<p>&gt;It can reliably terminate a thread [â€¦], by ensuring that everything [â€¦] is cleaned up [â€¦]</p>
<p>Nevermind how DllMain doesn&#39;t get called on the loaded DLLs, what about mutexen (mutexes?). Don&#39;t they generate WAIT_ABANDONED?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208891">
				<div id="div-comment-1208891" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208891">
			August 14, 2015 at 11:25 am</a>		</div>

		<p>TerminateThread should be considered a debugging-only API, like WriteProcessMemory and VirtualProtectEx.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208881">
				<div id="div-comment-1208881" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark VY</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208881">
			August 14, 2015 at 12:17 pm</a>		</div>

		<p>@McBucket: Nice! &nbsp;I like that one way more!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208861">
				<div id="div-comment-1208861" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Niklas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208861">
			August 14, 2015 at 12:31 pm</a>		</div>

		<p>If there were no TerminateThread function, how would Process Explorer implement its Kill Thread button?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208851">
				<div id="div-comment-1208851" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208851">
			August 14, 2015 at 12:35 pm</a>		</div>

		<p>If he used TerminateThread even a little bit,</p>
<p>There is no way you can acquit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208841">
				<div id="div-comment-1208841" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208841">
			August 14, 2015 at 12:37 pm</a>		</div>

		<p>@Niklas: Debug it, set EIP = entry point of ExitThread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jader3rd even thread-even depth-1" id="comment-1208831">
				<div id="div-comment-1208831" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jader3rd' rel='external nofollow' class='url'>jader3rd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208831">
			August 14, 2015 at 1:18 pm</a>		</div>

		<p>&lt;blockquote&gt;The original designers felt strongly that no such function should exist because there was no safe way to terminate a thread, and there&#39;s no point having a function that cannot be called safely. But people screamed that they needed the Terminate&shy;Thread function, even though it wasn&#39;t safe, so the operating system designers caved and added the function because people demanded it. Of course, those people who insisted that they needed Terminate&shy;Thread now regret having been given it.&lt;/blockquote&gt;</p>
<p>Were there really customers who said that they wouldn&#39;t purchase Windows if there wasn&#39;t a TerminateThread function?</p>
<div class="post">[<em>Developers who said that they wouldn&#39;t develop for Windows if there wasn&#39;t a TerminateThread function, so yeah. Developers are customers. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208821">
				<div id="div-comment-1208821" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua Bowman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208821">
			August 14, 2015 at 1:24 pm</a>		</div>

		<p>The one and only good time I ever saw to use TerminateThread was for spyware that injected itself into csrss and other processes. Killing csrss would reboot the system, and I didn&#39;t have tools handy to fix it offline, but it turned out that the thread could be terminated and gave me just enough time to clean the infection before it re-injected itself (after a few false starts).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208811">
				<div id="div-comment-1208811" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Al Go</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208811">
			August 14, 2015 at 2:55 pm</a>		</div>

		<p>&quot;&#8230; call TerminateThread.&quot; &#8211; Larry Osterman in a poem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1208801">
				<div id="div-comment-1208801" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208801">
			August 14, 2015 at 6:13 pm</a>		</div>

		<p>&quot;Never, not ever, call TerminateThread.&quot;</p>
<p>Quoth the Raymond: &quot;Nevermore.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1208791">
				<div id="div-comment-1208791" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208791">
			August 14, 2015 at 6:15 pm</a>		</div>

		<p>[Developers who said that they wouldn&#39;t develop for Windows if there wasn&#39;t a TerminateThread function, so yeah]</p>
<p>Those are like people who would not buy a car if there were no hole in the floor to brake with their feet.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208781">
				<div id="div-comment-1208781" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208781">
			August 15, 2015 at 3:28 am</a>		</div>

		<p>What, never?</p>
<p>No, never!</p>
<p>What, never?</p>
<p>Well, hardly ever.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208771">
				<div id="div-comment-1208771" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208771">
			August 15, 2015 at 6:13 am</a>		</div>

		<p>If TerminateThread() was designed as a kind of debug function &#8211; it should work normally only if target process is debugged by caller. Otherwise calling it should first bring-up fault report, then terminate thread and then &#8211; continue execution.</p>
<p>All this would point that its a really API that has never be used during normal operation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208761">
				<div id="div-comment-1208761" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208761">
			August 15, 2015 at 6:19 am</a>		</div>

		<p>BTW I have &#39;professional&#39; USB sound interface card produced by well-known producers of sound cards that is known for everyone. As a &#39;pro&#39; interface it has so-called &#39;ASIO&#39; interface to work with sound. And everybody on forums complains that this interface ha very good hardware but so buggy drivers&#8230; I took debugger to see.. And you know what? Its user-mode part (dll that implements ASIO interface) uses TerminateThread() to stop its worker threads every time sound stream stopped.</p>
<p>Thats why I use it only with Linux.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208751">
				<div id="div-comment-1208751" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208751">
			August 15, 2015 at 11:08 am</a>		</div>

		<p>@Killer{R}: That *looks* like a legitimate use of TerminateThread, since it knows the thread state (it&#39;s not holding any lock, just doing whatever computations it does), and this way can avoid checking a condition variable or something like that within a tight loop. But it won&#39;t properly release resources (by calling DllMain and so on). The &quot;proper&quot; way would be to suspend the thread, fiddle with its registers so it exits from the loop, and resume the thread; the code after the loop can then exit the thread cleanly.</p>
<p>(Yes, I&#39;m still joking, but slightly less than in the previous comment.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208741">
				<div id="div-comment-1208741" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208741">
			August 15, 2015 at 1:46 pm</a>		</div>

		<p>It definitely knows not everything cuz sometimes (&#39;only&#39; 1..2 times per day) app stuck or crashes. Not sure if this caused by TerminateThread() or some other bug though..</p>
<p>Also its driver likes to BSOD if device disconnected while being used (why not? its USB!) so their Windows drivers pack is really terrible from bottom to top.. i.e. from userland to kernel mode. However they labeled its as &#39;beta&#39; but never had &#39;release&#39; drivers, while device came to market on 2006.</p>
<p>Theoretically its looks possible to terminate suspended thread safely if it declared itself as &#39;terminatable&#39; and then does only pure math without using any uncontrolled dependency like CRT, API, COM/RPC etc.. But that means that you must be 100% sure in your compiler or write that piece of code in assembler by own hands. And even then there&#39;is some theoretical probability that some things like WOW64 will not secretly interfere with your execution.</p>
<p>BTW there is good TerminateThread() and its called TerminateProcess().</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208731">
				<div id="div-comment-1208731" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">T. West</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208731">
			August 15, 2015 at 2:04 pm</a>		</div>

		<p>I&#39;ll take a stab at defending the inclusion of TerminateThread. &nbsp;Very early on in my career, I had a bit of code that needed a TerminateThread. &nbsp;I read the warnings, but I could not find any other way of structuring the program to avoid it. &nbsp;So I used it, and no surprise, all was fine. &nbsp;After all, it *can* cause problems, but the vast majority of the time, you get away with it. &nbsp;(Many years later, I actually looked at the code again, and now realized that the entire way I structured the program was obviously wrong, which is why I needed it in the first place, but heck, it&#39;s how programmers with no experience with multi-threaded programming think.</p>
<p>And given that most of the code in the world is written by programmers at or below the median, a *lot* of programmers are going to require tools that make complicated jobs easier at the expense of not working at all some of the time. &nbsp;It&#39;s not pretty, but sometimes you deliver for the customers you *have*, not the customer you&#39;d like.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208721">
				<div id="div-comment-1208721" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208721">
			August 15, 2015 at 7:20 pm</a>		</div>

		<p>I think ideally there would be a function that aborts a thread by injecting an exception into it, much like sending a signal in Unix. This would allow you to program defensively for it and make clean-up possible via stack unwinding.</p>
<p>I believe this is how Thread.Abort in .NET works.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208711">
				<div id="div-comment-1208711" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208711">
			August 15, 2015 at 9:27 pm</a>		</div>

		<p>@Gabe: If you&#39;ve ever tried throwing through a Win32 callback function or SendMessage() you would know how scary that gets.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208701">
				<div id="div-comment-1208701" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208701">
			August 16, 2015 at 5:25 am</a>		</div>

		<p>2Gabe that would make TerminateThread unreliable (thread then may &#39;cancel&#39; termination). That would break the main idea of TerminateThread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208691">
				<div id="div-comment-1208691" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Cow Herd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208691">
			August 16, 2015 at 4:55 pm</a>		</div>

		<p>TerminateThread is one of those things that seems like a perfectly logical and sensible idea &#8211; and so by deliberately not implementing it, developers feel like you&#39;re forcibly imposing your ideology on them (Thou Shalt Not Terminate Threads). &quot;I know you [the scheduler] have the ability to terminate threads, so if I want to terminate a thread, why shouldn&#39;t I be able to?&quot;</p>
<p>But then when they actually try to use it, then they might find there&#39;s no way to make it work 100% of the time. (If 95% is good enough, then good for them, but obviously some developers want software to be reliable)</p>
<p>I feel like the way to convince developers that no, they really don&#39;t want TerminateThread, is to challenge them to find a way to use it reliably, then explain why it won&#39;t work. Then repeat until they (or you) concede. Of course, that&#39;s impractically time consuming.</p>
<p>By the way, gets and scanf are other functions that are very difficult to use reliably. (Impossible in the case of gets)</p>
<p>Also I like this quote from T. West. above:</p>
<p>&gt; given that most of the code in the world is written by programmers at or below the median, a *lot* of programmers are going to require tools that make complicated jobs easier at the expense of not working at all some of the time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1208681">
				<div id="div-comment-1208681" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208681">
			August 16, 2015 at 6:41 pm</a>		</div>

		<p>It&#39;s like Response.End() on web &#8211; You should never need to use it(Just call &lt;Current ApplicationInstance&gt;.CompleteRequest() to suppress further event and return). If your web application is using it, you&#39;re doing something wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-sean_limingmsn-com even thread-even depth-1" id="comment-1208671">
				<div id="div-comment-1208671" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Sean+Liming' rel='external nofollow' class='url'>Sean Liming</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208671">
			August 16, 2015 at 9:13 pm</a>		</div>

		<p>Aaaahhh a Vista left over. Vista&#8211; good times :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208641">
				<div id="div-comment-1208641" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208641">
			August 17, 2015 at 3:06 am</a>		</div>

		<p>@Anonymous Cow Herd: it *is* possible to use gets reliably. You just have to make sure that the standard input is a pipe only your program can write to, and only write to it less than the size of the buffer passed to gets.</p>
<p>(Yes, it&#39;s a use case that&#39;ll never come up in real life. But it&#39;s a valid way to use gets while guaranteeing no buffer overflows.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208631">
				<div id="div-comment-1208631" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208631">
			August 17, 2015 at 3:08 am</a>		</div>

		<p>There is still a significant number of open source libraries that frequently call TerminateThread.</p>
<p>Do search through the sources of the libraries you use. Notify the authors (and be prepared to hear false claims that &quot;it has to be done that way&quot;).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208621">
				<div id="div-comment-1208621" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henke37</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208621">
			August 17, 2015 at 4:14 am</a>		</div>

		<p>I hate to be the one to point it out, but the download has the same bad advice. Especially the line &quot;* DLL A terminates T, knowing that it is in a consistent state.&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208611">
				<div id="div-comment-1208611" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208611">
			August 17, 2015 at 5:29 am</a>		</div>

		<p>@T.West: &quot;given that most of the code in the world is written by programmers at or below the median&quot;</p>
<p>I&#39;m going to have to contest this. Half of the programmers are at or below the median, by definition. For them to produce more code than the above-median half, the below-median programmers would have to be more productive than the above-median programmers, and I don&#39;t believe that that&#39;s the case.</p>
<p>One could make the argument that below-median programmers produce large amounts of low-quality code, while above-median programmers produce smaller amounts of high-quality code, but I don&#39;t buy that. Certainly, below-median programmers do produce incredibly verbose low-quality code, but I don&#39;t think they produce much of it *per unit time* in the long run. While they manage to spew large quantities of copy-and-pasted mud initially, the bugginess of their secretions combined with their own lack of skill means they spend a long time chasing down corner cases, incorrectly-adapted pasted blocks, and other general bugs. Whereas above median programmers will produce cleaner code at a more steady pace, with shorter test/debug cycles, leading to more code generated overall.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208601">
				<div id="div-comment-1208601" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dirk gently</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208601">
			August 17, 2015 at 5:55 am</a>		</div>

		<p>@Douglas</p>
<p>I would say &quot;mutices&quot; as in vortex-&gt;vortices or index-&gt;indices :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208591">
				<div id="div-comment-1208591" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208591">
			August 17, 2015 at 6:01 am</a>		</div>

		<p>&gt;For them to produce more code than the above-median half, the below-median programmers would have to be more productive than the above-median programmers, and I don&#39;t believe that that&#39;s the case.</p>
<p>You are apparently confusing &#39;productivity&#39; and &#39;lines of code&#39;.</p>
<p>It often seems to be the case that programmers who are less productive (in terms of complete and debugged function points) write more lines of code than I do.</p>
<p>;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1208461">
				<div id="div-comment-1208461" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208461">
			August 17, 2015 at 10:04 am</a>		</div>

		<p>One reason people resort to use of TerminateThread for DLL-created threads is that you cannot easily guarantee the safe thread shutdown for the DLL created thread, if you unload the DLL by FreeLibrary.</p>
<p>One approach to solve that problem is to use a secondary DLL which the first DLL links explicitly (or by LoadLibrary/FreeLibrary). The thread code and all its possible callbacks should reside in the secondary DLL. DLL1 DllMain or some other Init function should call DLL2 function to start the worker thread. The worker thread needs to take a reference on DLL2 (LoadLibrary one more time). When DllMain1 is called with PROCESS_DETACH, it should ask the DLL2 to stop the worker thread (WITHOUT waiting for it). The thread should do FreeLibraryAndExitThread call. This will allow both DLLs to get cleanly unloaded.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208401">
				<div id="div-comment-1208401" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">McBucket</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208401">
			August 17, 2015 at 12:22 pm</a>		</div>

		<p>@dirk gently: &quot;I would say &quot;mutices&quot; as in vortex-&gt;vortices or index-&gt;indices :)&quot;</p>
<p>Nice, but as the &quot;-ex&quot; stem is actually indicative of what the word &quot;mutex&quot; is short for (not the case for vortex, index, or vertex or codex, for that matter), that would be somewhat obfuscatory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208381">
				<div id="div-comment-1208381" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208381">
			August 17, 2015 at 12:53 pm</a>		</div>

		<p>@Karellen: &quot;While they manage to spew large quantities of copy-and-pasted mud initially, the bugginess of their secretions combined with their own lack of skill means they spend a long time chasing down corner cases, incorrectly-adapted pasted blocks, and other general bugs.&quot;</p>
<p>You misunderestimate the tendency of mediocre programmers to solve code problems with more code. &nbsp;Never mind fixing the existing logic, we&#39;ll just slap on another layer to fix up the problems with the previous five layers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1208371">
				<div id="div-comment-1208371" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208371">
			August 17, 2015 at 2:32 pm</a>		</div>

		<p>@Kevin: I don&#39;t think so, as I&#39;ve been exposed to multitudes of unnecessary crufty layers before. I think I&#39;m more likely to be overestimating how long it takes below-median programmers to a) find out approximately where another extra layer needs to be added, b) try adding a new layer in the wrong place, c) figure out why their &quot;fix&quot; isn&#39;t working, d) try adding a new layer in the &quot;right&quot; place (for suitably generous values of &quot;right&quot;), e) figure out what&#39;s wrong with their new layer and fix it so it actually works, and f) go back and fix all the existing users of the old layer that they just broke. Because in my experience, it&#39;s a _really_ long time. If you&#39;ve got below-median programmers that can do all of the above with a quick turnaround time which enables them to put another layer in somewhere else, congratulations, yours must be closer to the median than mine were. ;-)</p>
<p>I&#39;m just glad I don&#39;t work there any more.</p>
<div class="post">[<em>Who says that the below-median programmer bothers with steps (a), (c), or (f)? I also suspect most below-median programmers never think &quot;I can solve this problem by deleting code / making existing code more flexible.&quot; The inner loop is &quot;Add code. See if problem is fixed. If not, add more code. Repeat.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208351">
				<div id="div-comment-1208351" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Cow Herd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208351">
			August 17, 2015 at 5:14 pm</a>		</div>

		<p>@Cesar: And there&#39;s probably a similar case for TerminateThread as well &#8211; a case that almost never actually happens where it&#39;s useful.</p>
<p>Note that even in the self-pipe case, using gets buys you very little (it only saves you from removing the line terminator yourself).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-1208331">
				<div id="div-comment-1208331" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208331">
			August 17, 2015 at 6:56 pm</a>		</div>

		<p>@Karellen: The &quot;above median&quot; programmers got prompted to team lead or management positions and write less code (for the most time, they review others&#39; code, not directly write it).</p>
<p>Therefore I have no problem on that statement.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1208191">
				<div id="div-comment-1208191" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nico</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1208191">
			August 18, 2015 at 12:29 pm</a>		</div>

		<p>Bring out yer dead</p>
<p>The scheduler said</p>
<p>Don&#39;t want to Wait()</p>
<p>For the same fate</p>
<p>Just call TerminateThread</p>
<p>Burma Shave</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1207981">
				<div id="div-comment-1207981" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shinji Yamada</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150814-00/?p=91811#comment-1207981">
			August 20, 2015 at 8:44 am</a>		</div>

		<p>McBucket: Larry Osterman&#39;s poem works as a haiku, I guess</p>
<p>No it doesn&#39;t. The moraic structure is all wrong and the caesura is in the wrong place. And a proper haiku should be a deeply felt seasonal experience.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

