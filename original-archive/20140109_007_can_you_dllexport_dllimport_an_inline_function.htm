<html>
<head>
<title>Can you dllexport/dllimport an inline function?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Can you dllexport/dllimport an inline function?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 9, 2014 / year-entry #8</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>48</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Yes, but it won't actually do much.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
The MSDN documentation on the subject of
<a HREF="http://msdn.microsoft.com/en-us/library/xa0d9ste">
Defining Inline C++ Functions with dllexport and dllimport</a>
was written with
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2011/05/12/10163578.aspx">
compiler-colored glasses</a>.
The statements are perfectly true, but they use terminology
that only compiler-writers understand.
</p>
<p>
The short version is that all modules which share an inline function
are considered to be part of the same program,
so all of the C++ rules regarding inline functions in programs
need to be followed.
</p>
<p>
Let's look at the paragraphs one at a time
and translate them into English.
</p>
<blockquote CLASS=q><p>
You can define as inline a function with the
<b>dllexport</b> attribute.
In this case, the function is always instantiated and exported,
whether or not any module in the program references the function.
The function is presumed to be imported by another program.
</p>
</blockquote>
<p>
Okay, first of all, what is <i>instantiation</i>?
</p>
<p>
In this context, the term <i>instantiation</i> when applied
to an inline function means
"The code is generated (<i>instantiated</i>)
for the function as if it had not been
marked inline."
</p>
<p>
For the purpose of discussion, let's say that you have
a function written as
</p>
<pre>
__declspec(dllexport)
inline int times3(int i) { return i * 3; }
</pre>
<p>
Suppose that you compile this into a DLL,
and that DLL also calls the inline function.
</p>
<pre>
int times9(int i) { return times3(times3(i)); }
</pre>
<p>
What code gets generated?
</p>
<p>
The <code>times9</code> function sees that the
<code>times3</code> function is inline,
so it inlines the function body and there is no
trace of a <code>times3</code> function at all.
The compiler generates the code as if it had
been written
</p>
<pre>
int times9(int i) { return (i * 3) * 3; }
</pre>
<p>
That would normally be the end of it,
except that
the <code>times3</code> function was marked
<code>dllexport</code>.
This means that the compiler also generates
and exports
a plain old function called <code>times3</code>
even though <i>nobody in the DLL actually calls it as such</i>.
The code is generated and exported because you told the
compiler to export the function, so it needs to generate
a function in order to export it.
</p>
<p>
This is not anything special about the <code>dllexport</code>
keyword.
This is just a side-effect of the rule that
"If you generate a pointer to an inline function,
the compiler must generate a non-inline version of the
function and use a pointer to that non-inline version."
In this case, the <code>dllexport</code> causes a pointer
to the function to be placed in the export table.
</p>
<p>
Okay, next paragraph:
</p>
<blockquote CLASS=q><p>
You can also define as inline a function declared
with the <b>dllimport</b> attribute.
In this case,
the function can be expanded (subject to /Ob specifications),
but never instantiated.
In particular,
if the address of an inline imported function is taken,
the address of the function residing in the DLL is returned.
This behavior is the same as taking the address
of a non-inline imported function.
</p>
</blockquote>
<p>
What this is trying to say is that if you declare
an inline function as <b>dllimport</b>,
the compiler treats it just like a plain old inline
function:
it inlines the function based on the usual rules for
inlining.
But if the compiler chooses to generate code for the function
as if it were not inline
(because the compiler decided to ignore the inline qualifier,
or because somebody took the address of the inline function),
it defers to the generated code from the original DLL,
because you said,
"Hey, the non-inline version of this
function is also available from that DLL over there,"
and the compiler says,
"Awesome, you saved me the trouble of having to generate the non-inline
version the function.
I can just use that one!"
</p>
<p>
The "I can just use that one!" is not just an optimization.
It is necessary in order to comply with the language standard,
which says [dcl.fct.spec]
that
"An inline function with external linkage
shall have the same address in all translation units."
This is the compiler-speak way of saying that the address of an
inline function must be the same regardless of who asks.
You can't have a different copy of the inline function in each DLL,
because that would result in them having different addresses.
(The "with external linkage" means that the rule doesn't apply to
static inline functions, which is behavior consistent
with static non-inline functions.)
</p>
<p>
Okay, let's try paragraph three:
</p>
<blockquote CLASS=q><p>
These rules apply to inline functions whose definitions appear
within a class definition.
In addition, static local data and strings in inline functions
maintain the same identities between the DLL and client
as they would in a single program
(that is, an executable file without a DLL interface).
</p>
</blockquote>
<p>
The first part of the paragraph is just saying that
an inline function defined as part of a class definition counts
as an inline function for the purpose of this section.
No big deal; we were expecting that.
</p>
<p>
<b>Update</b>: On the other hand, it is a big deal, because it
results in inline functions being exported when you may not realize it.
Consider:
</p>
<pre>
class __declspec(dllexport) SimpleValue
{
public:
 SimpleValue() : m_value(0) { }
 void setValue(int value);
 int getValue() { return m_value; }
private:
 int m_value;
};
</pre>
<p>
The <code>Simple&shy;Value</code> constructor and the
<code>Simple&shy;Value::<wbr>get&shy;Value</code> method
are exported inline functions!
Consequently, any change to the constructor or to
<code>getValue</code> requires a recompilation of all code
that constructs a <code>Simple&shy;Value</code> or calls
the <code>get&shy;Value</code> method.
<b>End update</b>.</p>
<p>
The second part says that if the inline function uses a static
local variable or a string literal,
it is the same static local variable or string literal everywhere.
This is required by the standard [dcl.fct.spec] and is what you
would naturally expect:
</p>
<pre>
int inline count()
{
 static int c = 0;
 return ++c;
}
</pre>
<p>
You expect there to be only one counter.
</p>
<p>
And the final paragraph:
</p>
<blockquote CLASS=q><p>
Exercise care when providing imported inline functions.
For example, if you update the DLL,
don't assume that the client will use the changed version of the DLL.
To ensure that you are loading the proper version of the DLL,
rebuild the DLL's client as well.
</p>
</blockquote>
<p>
This is just working through the consequences of the language requirement
[dcl.fct.spec] that an inline function "shall have exactly the
same definition" everywhere.
If you change the definition in the exporting DLL
and don't recompile the importing DLL with the new definition,
you have violated a language constraint and the behavior is undefined.
</p>
<p>
So there you have it.
The rules of inline exported functions translated into English.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (48)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1098503">
				<div id="div-comment-1098503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098503">
			January 9, 2014 at 7:12 am</a>		</div>

		<p>I wonder who screwed this up.</p>
<p>From past experience here it&#39;s almost always somebody.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098513">
				<div id="div-comment-1098513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098513">
			January 9, 2014 at 7:29 am</a>		</div>

		<p>The penultimate paragraph leads us to a different conclusion:</p>
<p>Don&#39;t mark inline functions as dllexport.</p>
<p>If you need the definition to change ever, or it does something complicated, make it a non-inline function; that way when you edit it all of your clients will automagically pick up the change. If you /don&#39;t/ ever need it to change, make it as inline and leave it at that. You might end up with two non-inlined versions in your process (one in yours.dll and one in client.dll), but you&#39;ll also not be calling that through a pointer, so it&#39;s all swings and roundabouts.</p>
<p>If a feature makes it impossible to update your code without asking your clients to rebuild, what that really means it makes it impossible for you to update your code PERIOD. Ergo, don&#39;t mark inline functions as dllexport, at which point all of this discussion is moot.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098523">
				<div id="div-comment-1098523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shelby</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098523">
			January 9, 2014 at 7:44 am</a>		</div>

		<p>This is similar to optional parameters in C#, and why you should not use optional parameters in a library. &nbsp;The default value of the optional parameter is placed in the client&#39;s code at compile time, not the library code. &nbsp;To change the default value in the library, you have to recompile all the clients.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098533">
				<div id="div-comment-1098533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098533">
			January 9, 2014 at 7:50 am</a>		</div>

		<p>@Shelby: IIRC, optional parameters work that way in C++ too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098543">
				<div id="div-comment-1098543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098543">
			January 9, 2014 at 8:33 am</a>		</div>

		<p>The &quot;function defined as part of a class definition counts as an inline function&quot; part of C++ standard is evil, unexpected and confusing. Whoever decided that must have had a bad day. Or week. Conclusion: avoid defining functions as part of a class definition.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098553">
				<div id="div-comment-1098553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken in NH</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098553">
			January 9, 2014 at 9:01 am</a>		</div>

		<p>@Shelby</p>
<p>That&#39;s a rather maximalist position to hold. Perhaps instead of banning optional/default parameters from public methods in libraries, you should apply a softer rule that actually solves the problem of default parameter values being compiled in client code: don&#39;t use constants as default values; use sentinel values instead. In other words:</p>
<p>public void Frob(string value = &quot;Bits&quot;) // BAD</p>
<p>{</p>
<p> &nbsp; DoSomething(value);</p>
<p>}</p>
<p>public void Frob(string value = null) // Good</p>
<p>{</p>
<p> &nbsp; DoSomething(value ?? &quot;Bits&quot;);</p>
<p>}</p>
<p>Later version:</p>
<p>public void Frob(string value = &quot;Bytes&quot;) // Fails!</p>
<p>{</p>
<p> &nbsp; DoSomething(value);</p>
<p>}</p>
<p>public void Frob(string value = null) // Success!</p>
<p>{</p>
<p> &nbsp; DoSomething(value ?? &quot;Bytes&quot;);</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098573">
				<div id="div-comment-1098573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098573">
			January 9, 2014 at 9:29 am</a>		</div>

		<p>I come to a very different conclusion:</p>
<p>inline is fine&#8230; DLLs are evil.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098593">
				<div id="div-comment-1098593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098593">
			January 9, 2014 at 9:54 am</a>		</div>

		<p>DLLs were designed as a binary API based on C. &nbsp;They were not designed for C++. &nbsp;Extending them for C++ creates this sort of issue. &nbsp;DLLs should be used for C interfaces, period. &nbsp;If you use them for C++, then you have a lot of subtle issues that have to be considered carefully.</p>
<p>Plus, DLLs lead to DLL hell, so we avoid them. &nbsp;They&#39;re great for hosting resources, but no code.</p>
<p>I have never understood other developer&#39;s adherence to a technology that was designed when memory was scarce, and C binary interfaces were the only well-defined &amp; stable binary-interface available.</p>
<p>Now, compile it all into your EXE and you&#39;re guaranteed to load what you actually use out of a library, instead of the entire library, the OS is good about paging in just what&#39;s needed, your installer is hugely simplified, and your dependency tree is massively simplified (DLL hell just doesn&#39;t exist).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098613">
				<div id="div-comment-1098613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098613">
			January 9, 2014 at 10:36 am</a>		</div>

		<p>@Evan: What happened in old C++ if the compiler had to de-inline you got static.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098623">
				<div id="div-comment-1098623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098623">
			January 9, 2014 at 10:43 am</a>		</div>

		<p>Steve Wolf: If you don&#39;t use DLLs, how do you handle plug-ins? OK, so maybe you make exceptions for plug-in architectures. Even worse then, how do you handle updates?</p>
<p>Let&#39;s say your program can view images, so you use a 3rd-party library to decode them. However, most images are compressed, so the image decoding library uses a 3rd-party compression library. Now let&#39;s say that there&#39;s a bug in the compression library that allows a malformed image to execute code and take over your machine.</p>
<p>If that compression library is loaded as a DLL, your users can search their hard drives for all instances of it, update them to make sure they&#39;re all versions that contain the bug fix, and they&#39;ll be safe.</p>
<p>If that library is statically linked, there&#39;s no way to know what software is vulnerable. The security vulnerability could be embedded within any EXE that is capable of compression, whether it&#39;s viewing images, managing compressed archives, or just using compression in a file format or network protocol.</p>
<p>Instead of being able to get a bug fix directly from the library vendor, users have to go to the app vendors, who may not even exist anymore or (more likely) just don&#39;t care about any software that isn&#39;t the current version. Even if it&#39;s all open source, you have to recompile every single binary affected by the bug, meaning you have to have a build environment for every one of those programs. Good luck with that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1098643">
				<div id="div-comment-1098643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098643">
			January 9, 2014 at 11:34 am</a>		</div>

		<p>Now there is another can of worms called template classes and functions&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098653">
				<div id="div-comment-1098653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098653">
			January 9, 2014 at 11:56 am</a>		</div>

		<p>Anyone who tries to export a template class or function from a DLL is a programmer to be feared.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098663">
				<div id="div-comment-1098663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098663">
			January 9, 2014 at 12:46 pm</a>		</div>

		<p>My standard practice for C++ DLLs is to have dllexported extern &quot;C&quot; functions to create an interface object. &nbsp;This interface object then has nothing but virtual functions exposed externally, with no two functions having the same name. &nbsp;In other words, it&#39;s similar to COM rules.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098683">
				<div id="div-comment-1098683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098683">
			January 9, 2014 at 1:14 pm</a>		</div>

		<p>@Ken &#8211; that&#39;s called &quot;DLL Hell&quot; &#8211; because there&#39;s no such thing as changing code with only positive side-effects in the real world.</p>
<p>@Kantos &#8211; our software doesn&#39;t need to support plug ins. &nbsp;If it did, then I would restrict the plug-ins to a well-understood binary interface in C. &nbsp;And in that case, the DLL is dependent on the app, not the other way around, so not a problem.</p>
<p>It is everyone else who is stuck in 95/9x view thinking that DLLs actually do anything of value for them&#8230; when they mostly cause DLL hell, introduce security vulnerabilities, and increase support headaches.</p>
<p>DLLs have their uses&#8230; but they&#39;re few and far between. &nbsp;Windows developers were taught that DLL = goodness early on, and are still failing to grock why that is untrue and has been untrue since NT.</p>
<p>Beyond plug-ins, I see no place where their value outweighs their negatives. &nbsp;The usual list of &quot;reasons&quot; are well-known to be flat-out untrue &#8211; such as memory footprint, &quot;fixing&quot; bugs across multiple applications, or providing security. &nbsp;They do none of those things reliably or better than linking a monolithic exe, while creating a long and very anti-stability list of problems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098693">
				<div id="div-comment-1098693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098693">
			January 9, 2014 at 1:59 pm</a>		</div>

		<p>@Steve Wolf: DLLs are useful if you have codebases whose namespaces conflict. &nbsp;Each module has its own symbol table, so things won&#39;t conflict. &nbsp;(In UNIX, the run-time symbol table is shared, but you can use -fvisibility=hidden and such to resolve that.)</p>
<p>It would be nice to be able to have link.exe build with separate symbol tables within a single .exe file. &nbsp;Basically, link each module individually, then cross-link the imports to make a single .exe file. &nbsp;Other than with horribly hacky solutions, I haven&#39;t seen such a feature.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098713">
				<div id="div-comment-1098713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098713">
			January 9, 2014 at 3:14 pm</a>		</div>

		<p>@Steve:</p>
<p>Memory footprint isn&#39;t flat out untrue. Windows does keep a DLL loaded only once if there isn&#39;t any rebasing involved. So linking via a DLL does save memory when you use shared code. Also, think of the case of static CRT vs. shared CRT. You have an executable at around 32KB that uses the DLL version and that DLL is loaded as few times as possible, vs. an executable where the same code is loaded multiple times as part of the executable, is that really a case where the DLL doesn&#39;t have a lower footprint?</p>
<p>For fixing bugs across multiple applications. That is more likely to do with how well designed the DLL is. In my own experience, several applications have used the same DLL for some shared code. A couple of times a bug has been found in that DLL and it was the only thing updates. The updated version was distributed and that fixed the problems. However, when I see people bemoaning this, I usually notice that they do not use well designed DLLs.</p>
<p>Also, I don&#39;t see where the DLL hell is involved with modern design, since you would be using private DLLs most of the time. This means that your application would be loading the DLL from its own private set of libraries most of the time, or a well controlled set, so it can be well tested. This is something that can&#39;t be done with people stuck in a 9x view because this is a more modern thing.</p>
<p>In fact, with the things that NT brought with it, especially the changes in the search paths added in KB959462/Windows 7 I would say that DLL = goodness even more now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098723">
				<div id="div-comment-1098723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098723">
			January 9, 2014 at 3:16 pm</a>		</div>

		<p>Made a mistake, the update is KB959426, I managed to transpose the last two digits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098733">
				<div id="div-comment-1098733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GuyWithHeadache</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098733">
			January 9, 2014 at 3:23 pm</a>		</div>

		<p>One of the rare days when I get a mild headache. When I read quoted text, it gets worse. When I read Raymond&#39;s explanation, it goes away. Free medical care. Thank you!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098743">
				<div id="div-comment-1098743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098743">
			January 9, 2014 at 4:04 pm</a>		</div>

		<p>@kantos: Since when does the Windows kernel support ELF files?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098563">
				<div id="div-comment-1098563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098563">
			January 9, 2014 at 9:22 am</a>		</div>

		<p>@Azarien</p>
<p>I was curious if I could figure out why that was, so I took a look at Stroustrup&#39;s &quot;The Design and Evolution of C++&quot;. I got part of the way to an answer, but still unsatisfactory.</p>
<p>Early versions of C++ (&quot;C With Classes&quot;) didn&#39;t have an inline keyword, but *did* support indicating that member functions should be inline by putting them into the class definition. So when later revisions to C++ came along to introduce inline, that behavior &quot;had&quot; to stay.</p>
<p>Unfortunately, I don&#39;t see a description of why *that* was true. I can speculate though. </p>
<p>Until relatively recently in the history of C and C++, the only way to get inline functions most of the time was to have the definition available to the *compiler*. (I&#39;m not sure how popular LTO is even now.) That means that the definitions of the functions must be in the headers, which is the same place the definition of the class itself must be (if you want to share the class across translation units). So if you don&#39;t have &quot;inline&quot; available, how do you indicate whether a function should be inline? Putting the function definitions into the class definition actually *makes sense* &#8212; it means that the compiler has a way of telling inline from non-inline, and is still reasonably natural in the sense that inline defs have to go into the header anyway.</p>
<p>In addition, making def&#39;ns in the class definition *not* inline starts presenting problems, because what compilation unit would the code be generated to? Linkers at that time I don&#39;t think had the ability to collapse repeated definitions across compilation units*. You &quot;can&#39;t&quot; use &quot;the definition still appears in the header but outside of the class definition&quot;, because the compiler just sees one big translation unit and doesn&#39;t know where the boundaries of the header and not-header are**. So the only other option I can think of would be to say that functions that are definined in the class definition are *static*, which seems equally confusing and surprising as making them inline.</p>
<p>Anyway, like so many things in C++ that are awful if you look at them from the standpoint of today, I&#39;d say that aspect actually developed pretty naturally if you accept a pretty dogmatic amount of &quot;must maintain backwards compatibility!&quot; as your goal.</p>
<p>* Though now that I&#39;m thinking this through more, I don&#39;t know what would happen when compilers at that time would refuse to inline a function defined in the class definition, so something has to give in this part of my argument, and maybe it&#39;s not so good. Maybe you&#39;d just get a linker error and have to move that function out of the class.</p>
<p>** Yeah, practically speaking it kind of does, but it never actually *uses* that information except for out-of-band information like error messages and debugging info. Making the meaning of something change depending on whether it appears in a header or source file would probably be the most surprising option out of all of these. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098603">
				<div id="div-comment-1098603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098603">
			January 9, 2014 at 10:29 am</a>		</div>

		<p>@Steve: If you have a common library implemented as a DLL, you can fix bugs in that library for all applications that use it, whether you are aware of the applications or not.</p>
<p>@Evan: a very good point about inline and old linkers. In fact, most of the confusions surrounding inline would have been avoided if the keyword had been named &quot;duplicate&quot; (or &quot;selectany&quot;!). The only *sure* thing about such a function is that you can define it in several translation units and the compiler/linker is allowed to assume that they are all identical. Actual inlining is then merely a permitted optimisation for the code generator.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-odd thread-alt depth-1" id="comment-1098633">
				<div id="div-comment-1098633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098633">
			January 9, 2014 at 11:30 am</a>		</div>

		<p>@Steve: You might want to re-learn how DLLs are loaded on Windows as you seem to be stuck in a 9x/XP era of assumptions. Any DLL marked as being without a Fixed Base Address and With ALSR enabled is considered to basically be Virtually Position Independent Code (vPIC)*. The OS will load that DLL into physical memory once when it is first loaded by a user mode process, and then keep a reference count of how many processes are using it. Because the DLL is vPIC it can load that DLL into the virtual address space of any user mode process where ever it needs to. Thus many processes share a single Page for a dll, the relocation table is the only non-shared data, any global variables are copy on write and will be shared until modified. So unless you&#39;re building your DLLs for an ancient version of windows they are probably not as heavy as you think.</p>
<p>* The PE format doesn&#39;t actually support Position Independent Code in the truest definition. Theoretically the kernel does as it supports ELF binaries, but I&#39;m not sure what&#39;s involved with getting an ELF binary to load on Windows and DLLs are by specification PE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098783">
				<div id="div-comment-1098783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098783">
			January 9, 2014 at 7:42 pm</a>		</div>

		<p>@Steve: you&#39;re not entirely alone; I&#39;m also of the opinion that DLLs Are Bad. &nbsp;Perhaps we should form a club. :-)</p>
<p>@Crescens2k: sure you save a small amount of memory. &nbsp;When was the last time that mattered?</p>
<p>@Gabe: note that newer architectures generally put plug-ins into a separate process anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1098793">
				<div id="div-comment-1098793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098793">
			January 9, 2014 at 8:02 pm</a>		</div>

		<p>&gt;Anyone who tries to export a template class or function from a DLL is a programmer to be feared.</p>
<p>Too late. See MSVCPxx.DLL</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098673">
				<div id="div-comment-1098673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098673">
			January 9, 2014 at 12:53 pm</a>		</div>

		<p>kantos: Programs on Windows can be position-independent if the compiler generates such code. &nbsp;The PE format supports relocation, but there is very little in PE that actually *requires* relocation. &nbsp;The only things I can immediately think of that require the use of a relocation table are __security_cookie and /SAFESEH. &nbsp;That&#39;s only because IMAGE_LOAD_CONFIG_DIRECTORY_2 has pointers instead of RVAs for these fields, and these values are needed by ntdll.dll prior to a single instruction of the DLL executing. &nbsp;No machine code has to be relocated, just an .rdata table.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098803">
				<div id="div-comment-1098803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098803">
			January 9, 2014 at 9:25 pm</a>		</div>

		<p>I&#39;d like to see how all of those people suggesting the death of DLLs interact with Windows APIs if not through some kind of DLL interface. I can only presume they are writing inline assembler to do syscalls directly against the kernel, have never programmed an application for Windows, or spend their time in the lofty heights of JavaScript, VB and C#-sans-pinvoke and have never questioned how their fluffy languages interact with the cold hard metal of the system as a whole.</p>
<p>DLLs might be evil, but I defy you to come up with a better solution to the problem they solve; namely the ability to modularize code and have updates for the modules independent of the application. Even Linux has DLLs; they just call them Shared Objects (.so files).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098823">
				<div id="div-comment-1098823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JRB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098823">
			January 9, 2014 at 10:56 pm</a>		</div>

		<p>With some C++11 Wizardry you can even use DLL&#39;s to share objects easily between Visual C++ Debug/Release and GCC and use std::string, vector, tuple, etc in the interface between the two. This can save you the headache of having to rebuild libraries multiple times when you want to upgrade/change compilers on Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098833">
				<div id="div-comment-1098833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098833">
			January 9, 2014 at 11:31 pm</a>		</div>

		<p>Harry Johnston: Newer architectures may run plug-ins in a separate process, but that doesn&#39;t mean each plug-in is a separate process! The standard pattern is to use a single plug-in container process (like audiodg or splwow64) to load all plug-in DLLs. </p>
<p>Can you imagine if plug-ins were all separate EXEs that had to run in their own process? Photoshop would be 100 processes instead of 1! Each plug-in would have to have the code to communicate with its host.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098843">
				<div id="div-comment-1098843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Engywuck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098843">
			January 10, 2014 at 12:56 am</a>		</div>

		<p>&quot;Each plug-in would have to have the code to communicate with its host.&quot;</p>
<p>Microkernels done in userspace?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098853">
				<div id="div-comment-1098853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098853">
			January 10, 2014 at 1:48 am</a>		</div>

		<p>@JRB</p>
<p>&quot;With some C++11 Wizardry you can even use DLL&#39;s to share objects easily between Visual C++ Debug/Release and GCC and use std::string, vector, tuple, etc in the interface between the two.&quot;</p>
<p>Now that makes me genuinely curious how you would do that?</p>
<p>Release/Debug tend to have different class definitions, violating the ODR across modules, and VC and gcc have a different ABI.</p>
<p>Could you elaborate on that part or link to an explaining article?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098863">
				<div id="div-comment-1098863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098863">
			January 10, 2014 at 5:58 am</a>		</div>

		<p>@Gabe: Well, even 100 processes wouldn&#39;t be that bad if there was a way to reliably bring down the whole tree of child processes. Otherwise, Windows already has a built-in message passing, and shared memory regions. So not entirely unreasonable, but yeah â€” in-proc is still way faster. Mainly because all border-crossing checks&#39;n&#39;security isn&#39;t present.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098873">
				<div id="div-comment-1098873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JDT</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098873">
			January 10, 2014 at 6:24 am</a>		</div>

		<p>Isn&#39;t it the case that if I write &quot;inline&quot; before a normal function definition, then it is still up to the compiler whether or not it inlines that function or not?</p>
<p>The wording of the dllexport documentation you quoted seems to indicate that dllexport-ed functions marked inline are ALWAYS inlined &#8212; is that right?</p>
<p>Also, are function definitions appearing within a class definition &quot;inline&quot; in the sense that it is as if they were marked inline (ie. they might be inlined and might not), or they are guaranteed to be inlined?</p>
<div class="post">[<em>Whether an inline function actually gets inlined is at the discretion of the compiler. This is mentioned in the quoted documentation where it says &quot;subject to /Ob specifications&quot;. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098883">
				<div id="div-comment-1098883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JDT</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098883">
			January 10, 2014 at 6:28 am</a>		</div>

		<p>Just to balance the discussion on using optional parameters in C#: if you use method overloads in C# interfaces, and export these to COM, then this interface is ugly and brittle, because COM doesn&#39;t support overloads so it has to mangle the names; on the other hand, if you use optional parameters, then you can provide a cleaner interface safe to expose via COM.</p>
<p>On the third hand you can just customise the names you export from C# to give them unique names.</p>
<p>On the fourth hand, why are people so down on optional parameters? Surely you just make sure you don&#39;t change the default values, and everything is fine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098893">
				<div id="div-comment-1098893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098893">
			January 10, 2014 at 7:11 am</a>		</div>

		<p>@Matt: We actually have that in Linux. The syscall ABI never gets breaking changes, so anybody who preferred the static link rules could have them. I prefer to keep a static set of &nbsp;tools around. One of my older systems has 3 different sets of libraries to run software from 3 eras.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1098903">
				<div id="div-comment-1098903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098903">
			January 10, 2014 at 7:17 am</a>		</div>

		<p>@JDT: Inline functions are not ALWAYS inlined. For example if you create a pointer to the function (let&#39;s say you want use it as a callback method somewhere): It&#39;s plain impossible to do that.</p>
<p>Same applies to recursive functions: The function might be inlined (helps performance if the recursive part is only rarely called) but any recursive call will not be.</p>
<p>I&#39;m not sure how (or if) this works in C++, but if you want to be able to call the function by RTTI you also need a non-inlined version.</p>
<p>About optional paramters: It&#39;s plain impossible (except for trivial cases) to define a default value that never changes. (The same as it&#39;s impossible to write a detailed specification without actually before starting to develop an application: The user always will find some necessary changes later on)</p>
<p>DLL Hell:</p>
<p>I think may of the defenders of DLL&#39;s don&#39;t realize what exactly a DLL hell is&#8230;</p>
<p>While there are some good reasons for DLL&#39;s (like accessing the system API) there are serious issues if you depend on shared DLL&#39;s (And yes. I&#39;ve seen &quot;Shared by several processes&quot; in almost all comments): Let&#39;s say you have 4 applications that use 4 shared dll&#39;s with 2 versions each (And every developer knows that 2 versions per dll is EXTREMELY low). This makes a total of 16 combinations between DLL&#39;s so you now test each your application with 16 different DLL-configurations.</p>
<p>You might be able to eliminate some combinations by checking the version at startup (Apps will fail fast due to &quot;unsupported&quot; dll version). But you still cannot guarantee that all applications will play by the rules (an one may just install an older DLL version on top of a new one&#8230;)</p>
<p>So the only way to play safe is to use &quot;private&quot; dll&#39;s. But in that case you can also ship a monolithic exe. (If anything changes for the app, you need to send some module(s) anyway. So you could always ship an exe instead).</p>
<p>So finally: As I said there are a few reasons for dll&#39;s:</p>
<p>&#8211; Plugin architectures</p>
<p>&#8211; 3rd party components supplied in different languages (COM interfaces&#8230;)</p>
<p>&#8211; System/OS Libraries (well, still DLL hell, but at least not our responsibility)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098913">
				<div id="div-comment-1098913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JRB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098913">
			January 10, 2014 at 7:17 am</a>		</div>

		<p>@AC</p>
<p>I presented the underlying techniques at C++Now. The link to the presentation is <a rel="nofollow" target="_new" href="https://github.com/boostcon/cppnow_presentations_2013/blob/master/tue/easy_binary_compat.pdf?raw=true">github.com/&#8230;/easy_binary_compat.pdf</a></p>
<p>The cppcomponents project at <a rel="nofollow" target="_new" href="https://github.com/jbandela/cppcomponents">github.com/&#8230;/cppcomponents</a> takes that and builds on it to produce a full component system with factories, Constructors and static functions, delegates, and events. It is basically like C++/CX except it works on Windows 7 as well as Linux, and only uses standard C++ so it works across multiple compilers.</p>
<p>Take a look at plugin under examples. It demonstrates a simple way to write plugins. The build script will make the exe with g++ and the dll with Visual C++ (you need the 2013 version). The unit tests cover the the supported features are tested with g++ exe/ Visual C++ dll and vice versa. I am working on writing better documentation for this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1099023">
				<div id="div-comment-1099023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random User 5937128</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099023">
			January 10, 2014 at 1:48 pm</a>		</div>

		<p>When it comes to DLLs, it helps if you can actually tell what version something is. One product from the vendor my company supports has just shy of 200 binaries (EXE/DLL/OCX/etc). 20% of those do not have a VERSIONINFO resource at all. Another 20% have a resource, but have said &quot;1.0.0.1&quot; since forever. And all of them have had multiple revisions over time without updating the version number. Any more, if I have to know for sure which is the newest, I end up having to dig into the IMAGE_FILE_HEADER to find the TimeDateStamp. @_@</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1098993">
				<div id="div-comment-1098993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1098993">
			January 10, 2014 at 9:35 am</a>		</div>

		<p>@Daniel</p>
<p>RE: DLL Hell</p>
<p>I&#39;m pretty sure most people reading this site do realize what DLL hell is, however the defenders of DLLs are talking about a different use case than you are. DLLs are perfectly good when (for instance):</p>
<p>a) You have multiple applications that rely on the same library that *you* wrote and is under your control. E.g. Office</p>
<p>b) You&#39;re in a more complicated setup, where the user is responsible for the necessary libraries (mostly happens with other developers/dev tools), and the user can update a bunch of components by updating the library. </p>
<p>And yes, we all realize that there can be tons of fun that can be had by everyone when some application comes along and installs its own version of DirectX that is 5 years outdated on your lovely 9x box, but that&#39;s largely been solved by Windows not letting applications do that anymore and making them keep their private DLLs to themselves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1099043">
				<div id="div-comment-1099043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099043">
			January 10, 2014 at 6:24 pm</a>		</div>

		<p>Ok, I&#39;ll bite on the off-topic about DLL benefits.</p>
<p>Here&#39;s a few more to consider:</p>
<p>1) Ability to have different exception handling rules (throw vs non throw)</p>
<p>2) Ability to use different runtimes</p>
<p>3) CoCreateInstance</p>
<p>4) Delay loading and the subsequent ability to have fallback code (Oh you haven&#39;t downloaded &lt;foo&gt;? No worries.)</p>
<p>5) Namespace resolution, as already stated, such as the hInstance parameter in your RegisterClass WNDCLASS struct.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1099063">
				<div id="div-comment-1099063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dimiter 'malkia' Stanev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099063">
			January 10, 2014 at 10:56 pm</a>		</div>

		<p>One more for DLLs &#8211; Better link times.</p>
<p>With DLL one can optimize significant amount of code isolated as one or several libs with LTCG (LTO) &#8211; for example WebKit, Qt, etc. Such libraries are quite big to fit into the daily compile / link (statically) routine. I&#39;d better have small .exe with lots of big dlls, rather than one big exe that I need to recompile everytime.</p>
<p>Another + for DLL&#39;s is FFI (foreign function interface). Luajit, Python, Common Lisp and many other runtime implementations of the said languages deal much better with compiled DLL, rather than going through a lot of hoops to link statically with foreign code (like Go, and some other systems).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1099073">
				<div id="div-comment-1099073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mcmcc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099073">
			January 11, 2014 at 6:08 am</a>		</div>

		<p>Having lived through the bad ol&#39; days of building a multi-million line application on a pre-shared-library AIX platform, I can assure you of one thing: &nbsp;dynamically-loaded libraries are a _very_ good thing. &nbsp;Be careful what you wish for&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1099103">
				<div id="div-comment-1099103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099103">
			January 12, 2014 at 2:33 pm</a>		</div>

		<p>@mcmcc and @Dimitir: that&#39;s all down to how efficient (or not) your build tools are.</p>
<p>@Anil: common wisdom says that having a DLL with a different runtime than the exectuable is bad news, because (for example) you might allocate memory in the DLL and try to free it in the exectuable, hence boom. &nbsp;My opinion is that if the library is properly designed this shouldn&#39;t happen anyway, but it does mean one more thing to worry about. &nbsp;In any case, there&#39;s no fundamental reason why you couldn&#39;t do this at build time if you really wanted to. &nbsp;Same with exception handling. &nbsp;Also, there&#39;s no need for fallback code if all the code you want is already in your executable. &nbsp;And so on.</p>
<p>@Gabe: I don&#39;t see any reason why Photoshop&#39;s built-in &quot;extensions&quot; couldn&#39;t be statically linked. &nbsp;I wonder how many different third-party extensions the typical user has installed? &nbsp;But, yes, in Windows you sometimes have no realistic option other than DLLs. &nbsp;That doesn&#39;t make them a good thing, just a necessary one &#8211; and only because Windows doesn&#39;t provide better alternatives.</p>
<p>@Matt: I don&#39;t know about Steve, but I don&#39;t object much to the Windows API being provided by way of DLLs. &nbsp;They work reasonably well for that particular purpose and in that particular context. &nbsp;(The only annoying thing I can think of at the moment is that they sometimes start up threads, but so long as you&#39;re aware that this may happen it isn&#39;t all that big a deal.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1099123">
				<div id="div-comment-1099123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dimiter 'malkia' Stanev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099123">
			January 12, 2014 at 10:00 pm</a>		</div>

		<p>Photoshop, Autodesk, XSI, etc. based plugins are whole business on it&#39;s own. There are companies (rendering, simulation, asset management, etc) that their main business are these plugins. And often they have to provide for many different versions of the products, and make sure they are compiled with the same compiler the original product was compiled with.</p>
<p>Harry: I don&#39;t really see how static linking would practically work? In our gamedev studio we do plugins for our artists that export model/animation/etc. data for our pipeline. I can&#39;t imagine giving them new compiled version of Photoshop/Maya/MotionBuilder so they could work with. And why would Autodesk allow us to do so?</p>
<p>DLLs (and .so, .dylibs) are really something that enables people to make money, without them, you would&#39;ve been constricted to some form of IPC mechanism, which while it sounds great and maybe the right choice (in very long term), it would be terrible for certain solutions &#8211; for example imagine that you have to ask your host application (say 3D modelling one) for all your bones, weights, constraints, etc. &#8211; to perform some kind of real-time simualation or something like that &#8211; going through IPC would work, but it would complicate the whole thing, and might slow it down to a crawl.</p>
<p>Once you are in RPC land, you also have to openly deal with broken communications (even if it&#39;s on the same computer) &#8211; for example the main application was shut down, or your plugin was killed &#8211; you have to come with plans to restart, re-establish connection, get data again, etc., etc. </p>
<p>And then imagine a Photoshop effect written as DLL that deals with 100 of megabytes of data doing all through the IPC instead of directly touching the data.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1099233">
				<div id="div-comment-1099233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099233">
			January 13, 2014 at 10:03 am</a>		</div>

		<p>@John Doe: Right now, they change in service packs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1099243">
				<div id="div-comment-1099243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099243">
			January 13, 2014 at 10:42 am</a>		</div>

		<p>@Harry Johnston:</p>
<p>In general, I disagree with you about dynamic libraries and executables with different runtimes being bad. I also don&#39;t think much of &quot;common wisdom/sense&quot; because quite often it is not so common sense and wisdom that is more abundant in these circles.</p>
<p>Anyway, the biggest problem is sharing things across the boundary assuming that both sides are using the same runtime. If you are in control of everything, then this isn&#39;t so bad. But if you aren&#39;t then there are simple ways of doing this without too much thought.</p>
<p>Providing a deallocation function, and if you are using C++, then smart pointers would deal with a lot of this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1099273">
				<div id="div-comment-1099273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099273">
			January 13, 2014 at 12:47 pm</a>		</div>

		<p>@Dimitir: I was talking specifically about the plugins that are shipped with Photoshop. &nbsp;Obviously, third-party plugins can&#39;t (usually) be statically linked.</p>
<p>I&#39;m no expert, but doesn&#39;t COM already provide solutions to most of the IPC problems you discuss? &nbsp;You can also use shared memory to avoid having to transfer large amounts of data over IPC.</p>
<p>As a counter-example, consider what happens when a DLL-based plugin is built with a compiler that changes the FPU settings. &nbsp;(Based on a true story!)</p>
<p>All that said, it may well be that, despite the problems, DLLs are still the best currently available solution for these particular scenarios. &nbsp;That doesn&#39;t mean we need to use them for everything. &nbsp;(Note in particular that plugins are unlikely to be trying to import or export inline functions!)</p>
<p>@Crescens2k: no, I agree with you, it shouldn&#39;t be necessary for the DLL and the exectuable to use the same runtime. &nbsp;But a lot of people do get incensed about this, and it does create some risks which need to be managed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1099293">
				<div id="div-comment-1099293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099293">
			January 13, 2014 at 12:59 pm</a>		</div>

		<p>@Crescens2k: the other case, of course, is where the DLL and the executable really do need to use different runtime versions, but can&#39;t because both of the runtime DLLs have the same name.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1099133">
				<div id="div-comment-1099133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140109-00/?p=2123#comment-1099133">
			January 13, 2014 at 6:45 am</a>		</div>

		<p>For the purpose of full static linking, the Windows syscalls would have to be documented. Would it really be such a bad thing? I can see a few more things, other than static linking, where having syscalls documented would be *extremely* useful.</p>
<p>Of Courseâ„¢, Win32, COM, GUI et al would be a no-no in such applications.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

