<html>
<head>
<title>If you want to use GUIDs to identify your files, then nobody's stopping you</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>If you want to use GUIDs to identify your files, then nobody&#8217;s stopping you</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>February 28, 2011 / year-entry #49</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>37</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Igor Levicki proposes solving the problem of file extensions by using a GUID instead of a file name to identify a file. You can do this already. Every file on an NTFS volume has an object identifier which is formally 16-byte buffer, but let's just call it a GUID. By default a file doesn't have...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Igor Levicki proposes solving the problem of file extensions by
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2007/12/17/6785519.aspx#6793266">
using a GUID instead of a file name to identify a file</a>.
</p>
<p>
You can do this already.
Every file on an NTFS volume has an <i>object identifier</i>
which is formally 16-byte buffer, but let's just call it a GUID.
By default a file doesn't have an object identifier,
but you can ask for one to be created with
<code>FSCTL_CREATE_OR_GET_OBJECT_ID</code>,
which will retrieve the existing object identifier associated with
a file, or create one if there isn't one already.
If you are a control freak, you can use
<code>FSCTL_SET_OBJECT_ID</code> to specify the GUID you want to use
as the object identifier.
(The call fails if the file already has an object identifier.)
And of course there is
<code>FSCTL_GET_OBJECT_ID</code> to retrieve the object identifier, if any.
</p>
<pre>
#define UNICODE
#define _UNICODE
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include &lt;ole2.h&gt;
#include &lt;winioctl.h&gt;

int __cdecl _tmain(int argc, PTSTR *argv)
{
 HANDLE h = CreateFile(argv[1], 0,
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                 FILE_SHARE_DELETE, NULL,
                 OPEN_EXISTING, 0, NULL);
 if (h != INVALID_HANDLE_VALUE) {
  FILE_OBJECTID_BUFFER buf;
  DWORD cbOut;
  if (DeviceIoControl(h, FSCTL_CREATE_OR_GET_OBJECT_ID,
                 NULL, 0, &amp;buf, sizeof(buf),
                 &amp;cbOut, NULL)) {
    GUID guid;
    CopyMemory(&amp;guid, &amp;buf.ObjectId, sizeof(GUID));
    WCHAR szGuid[39];
    StringFromGUID2(guid, szGuid, 39);
    _tprintf(_T("GUID is %ws\n"), szGuid);
  }
  CloseHandle(h);
 }
 return 0;
}
</pre>
<p>
This program takes a file or directory name
as its sole parameter and prints the associated object identifier.
</p>
<p>
Big deal, now we have a GUID associated with each file.
</p>
<p>
The other half is, of course, using this GUID to open the file:
</p>
<pre>
#define UNICODE
#define _UNICODE
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include &lt;ole2.h&gt;

int __cdecl _tmain(int argc, PTSTR *argv)
{
 HANDLE hRoot = CreateFile(_T("C:\\"), 0,
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                 FILE_SHARE_DELETE, NULL,
                 OPEN_EXISTING,
                 FILE_FLAG_BACKUP_SEMANTICS, NULL);
 if (hRoot != INVALID_HANDLE_VALUE) {
  FILE_ID_DESCRIPTOR desc;
  desc.dwSize = sizeof(desc);
  desc.Type = ObjectIdType;
  if (SUCCEEDED(CLSIDFromString(argv[1], &amp;desc.ObjectId))) {
   HANDLE h = OpenFileById(hRoot, &amp;desc, GENERIC_READ,
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                 FILE_SHARE_DELETE, NULL, 0);
   if (h != INVALID_HANDLE_VALUE) {
    BYTE b;
    DWORD cb;
    if (ReadFile(h, &amp;b, 1, &amp;cb, NULL)) {
     _tprintf(_T("First byte of file is 0x%02x\n"), b);
    }
    CloseHandle(h);
   }
  }
  CloseHandle(hRoot);
 }
 return 0;
}
</pre>
<p>
To open a file by its GUID, you first need to open
something&mdash;anything&mdash;on the volume the file resides on.
Doesn't matter what you open;
the only reason for having this handle is so that
<code>OpenFileById</code> knows which volume you're talking about.
In our little test program, we use the C: drive,
which means that the file search will take place on the
C: drive.
</p>
<p>
Next, you fill in the <code>FILE_ID_DESCRIPTOR</code>,
saying that you want to open the file by its object identifier,
and then it's off to the races with <code>OpenFileById</code>.
Just as a proof of concept, we read and print the first byte
of the file that was opened as a result.
</p>
<p>
Notice that the file you open by its object identifier does not
have to be in the current directory.
It can be <i>anywhere on the C: drive</i>.
As long as you have the GUID for a file, you can open it
no matter where it is on the drive.
</p>
<p>
You can run these two programs just to enjoy the thrill of
opening a file by its GUID.
Notice that once you get the GUID for a file, you can move
it anywhere on the drive, and <code>OpenFileById</code>
will still open it.
</p>
<p>
(And if you want to get rid of those pesky drive letters,
you can use the volume GUID instead.
Now every file is identified by a pair of GUIDs:
the volume GUID and the object identifier.)
</p>
<p>
So Igor's dream world where all files are referenced by GUID
already exists.
Why isn't everybody switching over to this utopia of GUID-based
file identification?
</p>
<p>
You probably know the answer already:
Because people prefer to name things with something mnemonic
rather than a GUID.
Imagine a file open dialog in this dream world.
"Enter the GUID of the file you wish to open, or click Browse
to see the GUIDs of all the files on this volume so you can pick
from a list."
How long would this dialog survive?
</p>
<p>
For today, you don't have to call me Raymond.
You can call me
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2004/03/15/89753.aspx">
{7ecf65a0-4b78-5f9b-e77c-8770091c0100}</a>,
or "91c" for short.
</p>
<p>
(And I've totally ignored the fact that
using GUIDs to identify files does nothing
to solve the problem of trying to figure out what program should be
used to open a particular file.)
</p>
<p>
<p>
<b>Bonus chatter</b>:
You can also open files by their file identifer, which is a
volume-specific 64-bit value.
But I chose to use the GUID both for the extra challenge,
and just to show that Igor's dream world already exists.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-897633">
				<div id="div-comment-897633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897633">
			February 28, 2011 at 7:21 am</a>		</div>

		<p>&quot;(And I&#39;ve totally ignored the fact that using GUIDs to identify files does nothing to solve the problem of trying to figure out what program should be used to open a particular file.)&quot;</p>
<p>Come on, Raymond &#8211; any intelligent human being knows that this could be solved by using program GUIDs!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897643">
				<div id="div-comment-897643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tergiver</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897643">
			February 28, 2011 at 7:22 am</a>		</div>

		<p>That&#39;s cool. Is there a FindFirstFile/FindNextFile way to search for files by object identifier?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897653">
				<div id="div-comment-897653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897653">
			February 28, 2011 at 7:24 am</a>		</div>

		<p>Or, you could just choose to give all your files filenames that happen to be GUIDs, and store them all in the same directory. :-)</p>
<p>&quot;using GUIDs to identify files does nothing to solve the problem of trying to figure out what program should be used to open a particular file.&quot;</p>
<p>If I understand Igor&#39;s original comment correctly(!), the idea is to store the mime-type or associated program for a file in an alternate datastream, which allows you to strip the file extension from the filename. The GUID-based file naming scheme is merely a &quot;fix&quot;[0] for the bug that without filename extensions you can no longer have two files of different types with the same (base)name in the same directory.</p>
<p>[0] Deciding whether the proposed fix is worse than the original problem[1] is, naturally, an exercise for the reader ;-)</p>
<p>[1] whatever that was&#8230; but it doesn&#39;t seem entirely relevant any more as my brain appears to have crawled out of my ear in an attempt to escape the insanity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897663">
				<div id="div-comment-897663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wladimir Palant</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897663">
			February 28, 2011 at 7:24 am</a>		</div>

		<blockquote><p>
  Because people prefer to name things with something mnemonic
</p></blockquote>
<p>That&#39;s one reason of course. But isn&#39;t there also the issue that a GUID might get lost? There are those pesky programs who save data by writing to a new file and replacing the old one by it instead of simply writing the data into the original file&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897673">
				<div id="div-comment-897673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897673">
			February 28, 2011 at 7:27 am</a>		</div>

		<blockquote><p>
  For today, you don&#39;t have to call me Raymond
</p></blockquote>
<p>I thought it was Mr Chen&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897683">
				<div id="div-comment-897683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897683">
			February 28, 2011 at 7:36 am</a>		</div>

		<p>&quot;And I&#39;ve totally ignored the fact that using GUIDs to identify files does nothing to solve the problem of trying to figure out what program should be used to open a particular file.&quot;</p>
<p>Just use WriteClassStg to put the class GUID in the file. Of course, this doesn&#39;t work terribly well with files that aren&#39;t based on structured storage.</p>
<div class="post">[<i>So opening an Explorer folder requires that every file be opened in order to determine its type. (And what if the file allows only Administrators to read it? Explorer won&#39;t know what program to elevate if you try to open it. And IT administrators will love the network traffic and tape recall.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897703">
				<div id="div-comment-897703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897703">
			February 28, 2011 at 7:41 am</a>		</div>

		<p>@Tergiver No, because unique identifiers are by their very nature, unique. &nbsp;You aren&#39;t supposed to have two files with the same identifier.</p>
<p>Also I see an alternate (or probably not-so-alternate if you read enough TheDailyWTF) universe where someone actually did this but then it utterly failed when their client revealed they had systems that, for some asine reason or another, required them to use FAT32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897713">
				<div id="div-comment-897713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tergiver</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897713">
			February 28, 2011 at 7:43 am</a>		</div>

		<p>Ah.. After checking the MSDN docs I see that the &quot;object identifier&quot; is an identifier unique to each file (that has one). So this will not help as a substitute for file extensions which would have to allow multiple files to have the same identifier.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897733">
				<div id="div-comment-897733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897733">
			February 28, 2011 at 7:48 am</a>		</div>

		<p>Is OpenFileById an O(1) operation? &nbsp;Or does it require some type of searching on the kernel&#39;s part which takes longer on a fuller disk? &nbsp;Or more to the point, is there a performance reason for preferring good ol&#39; CreateFile to OpenFileById?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897743">
				<div id="div-comment-897743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vilx-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897743">
			February 28, 2011 at 7:51 am</a>		</div>

		<p>One way of dealing away with the file-type-by-extension &quot;problem&quot; (it works rather well, actually) that I&#39;ve never seen mentioned before is &#8211; &quot;let&#39;s put a mime-type in the file&#39;s metadata&quot;. That would be the same metadata which contains file name, size, times, etc. So no need to open the actual file to see it. However this would (naturally) not work on FAT32, and would not survive an FTP trip. Would work just fine in emails/web though. :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897753">
				<div id="div-comment-897753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897753">
			February 28, 2011 at 7:52 am</a>		</div>

		<p>Interesting! I agree that this is not a globally universal feature. But it&#39;s a very useful one for programs that have documents that relate to other documents, and want to be able to easily recover them if the user moves the other documents around.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897793">
				<div id="div-comment-897793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897793">
			February 28, 2011 at 8:36 am</a>		</div>

		<p>What I don&#39;t understand is how Igor would expect users to deal with two different files that have the same name. When a user is presented with a dialog box that has two files named &quot;Foo&quot; in it, how is the user to know which one is which? This is often a problem on default Windows configurations where foo.exe and foo.dll both get presented as &quot;foo&quot;, but is easily solved by telling Explorer not to hide extensions.</p>
<p>The easiest solution is to simply not allow multiple files to have the same name, thus preventing the problem from ever happening in the first place.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897813">
				<div id="div-comment-897813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897813">
			February 28, 2011 at 8:59 am</a>		</div>

		<p>Is this a follow-on from last week&#39;s tip about serializing shortcuts? Both techniques could be used as a way to track a file that a user has renamed or moved to a different location.</p>
<p>As far as I can see, the shortcut technique has the advantage that it works on FAT32 volumes as well as NTFS, and doesn&#39;t even require the moved/renamed file to be on the original volume. But are there disadvantages of relying on shortcuts? Presumably OpenFileById() will find the file much more quickly than resolving a wayward shortcut if speed is important and the file is still on the original NTFS volume?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897823">
				<div id="div-comment-897823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897823">
			February 28, 2011 at 9:09 am</a>		</div>

		<p>@Adam: There are no O(1) operations on disk. It&#39;s probably O(log n) with a really small constant.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-897873">
				<div id="div-comment-897873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897873">
			February 28, 2011 at 9:55 am</a>		</div>

		<p>@Adam Rosenfeld, Joshua: NTFS supports generic indexing &#8211; MS can fairly easily create a B+-Tree index of many different properties. Object IDs for a volume are indexed in the metadata file named $O in $Extend$ObjId. Performance should be the same as any directory lookup (for a directory containing the same number of files as on the volume).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897913">
				<div id="div-comment-897913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">chrismcb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897913">
			February 28, 2011 at 11:00 am</a>		</div>

		<p>I don&#39;t understand how sticking a MIME type anywhere will solve the &quot;extension hell&quot; The extension is a piece of metadata to identify the file. The MIME type is a piece of metadata that identifies the file. Any problem you have with the extension you will ALSO have with the MIME type. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897923">
				<div id="div-comment-897923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897923">
			February 28, 2011 at 11:37 am</a>		</div>

		<p>If only that API existed in Windows 2000&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897933">
				<div id="div-comment-897933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">configurator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897933">
			February 28, 2011 at 11:49 am</a>		</div>

		<p>A few questions:</p>
<p>When calling FSCTL_CREATE_OR_GET_OBJECT_ID with no write permission on a file that doesn&#39;t have an object id, is the object id created anyway?</p>
<p>And can two volumes naturally have files with the same object id? This is assuming FSCTL_SET_OBJECT_ID wasn&#39;t used and no disk-cloning tools or some such was used either. (Of course you couldn&#39;t rely on it in actual code, I&#39;m just wondering).</p>
<p>When moving a file between two volumes, would the new file get the old file&#39;s object id? If not, I&#39;d assume moving a file from C: to D: and then back would reset its object id, which stands to reason.</p>
<p>And one warning: if you&#39;re using this, don&#39;t assume that C: and C:SomeFolder are the same volume. I&#39;ve seen this mistake made before. Remember, drives can be mounted in any directory, and junction points are not a myth.</p>
<div class="post">[<i>I don&#39;t know either, but unlike you, I decided to try to find out. Here&#39;s the definition of FSCTL_CREATE_OR_GET_OBJECT:<br /><code>#define FSCTL_CREATE_OR_GET_OBJECT_ID CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, <span style="text-decoration:underline;">FILE_ANY_ACCESS</span>) // FILE_OBJECTID_BUFFER</code><br />You have now used up your lazy question quota. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897943">
				<div id="div-comment-897943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897943">
			February 28, 2011 at 12:13 pm</a>		</div>

		<p>&quot;You can call me {7ecf65a0-4b78-5f9b-e77c-8770091c0100}, or &quot;91c&quot; for short.&quot;</p>
<p>I am not a GUID, I am a free man!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-897953">
				<div id="div-comment-897953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897953">
			February 28, 2011 at 12:37 pm</a>		</div>

		<p>@ChrisMcB: I quite liked the Mac Classic system where you had a &quot;Type&quot; and &quot;Creator&quot; meta-data. Since it was baked-in, all of the network file operations would cache/request/deliver it the way Windows does with the filename now. The Type told the system what type of file it was (for example, &quot;TEXT&quot;) and thee Creator told you which application opened the file by default (for example, &quot;WORD&quot;).</p>
<p>The beauty of this system is that you could have 400 text files on your system, some of which were opened by Netscape, others by MS Word, others by SimpleText&#8230; and you could switch the opening app at will. I wish I had that in Windows&#8211; there are some image files I always want to open with Paint.NET instead of Preview, but no way to tell Windows that.</p>
<p>Of course, the weakness, as with all Mac Classic awesomeness, is when you need to interact with other systems over a network&#8230; it all falls apart when your Windows fileserver has no way of storing the Type and Creator meta-data, and even Mac Classic had to add a opener based on file extension long before they switched to the Unix-based OS X.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-897983">
				<div id="div-comment-897983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lasse V. Karlsen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-897983">
			February 28, 2011 at 2:38 pm</a>		</div>

		<p>Question: If I store many small documents on a disk, divided up into many directories (to avoid one big directory with 100s of thousands of files), is there a performance benefit in opening the file through its &quot;GUID&quot; compared to opening it via its path? If I were to store the ID-s in a database, would there be a noticable speed difference between the two methods?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898033">
				<div id="div-comment-898033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898033">
			February 28, 2011 at 6:10 pm</a>		</div>

		<p>@James Schend:</p>
<p>Alternate streams were designed into NTFS for a reason&#8230;and the original reason was (AFAIK): support Mac OS metadata streams for network fileserver.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-898053">
				<div id="div-comment-898053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nathaniel Mishkin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898053">
			February 28, 2011 at 7:42 pm</a>		</div>

		<p>That&#39;s an interesting bit of NTFS arcana that I wasn&#39;t aware of.</p>
<p>FYI, the same principle&#8211;using unique IDs to identify files&#8211;was implemented in the early 1980s on the OS that ran on the engineering workstations built by Apollo Computer. &nbsp;Apollo wasn&#39;t the originator of the idea of using fixed-length unique IDs that could be readily generated in non-centralized fashion for the purpose of aiding in the development and operation of distributed systems. &nbsp;(I think Barbara Liskov gets credit for that.) &nbsp;But Apollo&#39;s 64-bit UIDs were at the head of a chain of design that led to UUIDs, via the Open Software Foundation&#39;s (OSF) Distributed Computing Environment&#39;s (DCE), parts of which (including UUIDs and DCE&#39;s RPC protocol and API) were adopted by Microsoft.</p>
<p>Anyway, the Apollo file system not only used UIDs as a stable file identifier (in addition to human-sensible names, of course). &nbsp;It also used UIDs to identify the &quot;type&quot; of files. &nbsp;This &quot;type UID&quot; was used to select the code that would interpret the file&#39;s raw content. &nbsp;This mechanism was extensible in that (a) anyone could, of course, generate their own unique type UID, and (b) extend the streaming I/O system with a &quot;type manager&quot; that implemented the streaming I/O operations for that type of file.</p>
<p>One interesting lesson from all this though was how hard it was to evolve the well-known and long-standing model of file I/O with concepts like &quot;file type&quot;. &nbsp;Programs were all too happy to think they could duplicate a file simply by opening it, reading out its bytes, and writing them to a new file without bothering with little details like remembering to preserve the source file&#39;s type.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898063">
				<div id="div-comment-898063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898063">
			February 28, 2011 at 9:57 pm</a>		</div>

		<p>I found Active Directory user objects have both objectSid and objectGUID properties of different value, perheps we should have called you yet another name&#8230; :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-898073">
				<div id="div-comment-898073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898073">
			February 28, 2011 at 11:37 pm</a>		</div>

		<p>Wladimir Palant: &nbsp;That&#39;s one reason of course. But isn&#39;t there also the issue that a GUID might get lost? There are those pesky programs who save data by writing to a new file and replacing the old one by it instead of simply writing the data into the original file&#8230;</p>
<p>Apps do that because an overwrite move is an atomic operation if the files are on the same filesystem. You see, while the program is writing out the new file, the power can go out, the CPU may decide to fry, or well, some piece of hardware may decide to tickle the bus the wrong way and cause a BSOD. If it happened while writing the new file, that file is corrupt, but the user still has the old version. If it happened during the move operation, then it depends how far the OS got &#8211; either it failed to replay and the user gets the old file, or it succeeded and the user gets the new file.</p>
<p>So it&#39;s more to ensure at no point will the user lose all their data. If the app simply overwrote or appended their file, a corruption may cause garbage to occur and freak out the file parser, so the user loses all their data. Or even worse, the file is partially corrupt but opens fine, and the user fails to realize there&#39;s hidden corruption.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898083">
				<div id="div-comment-898083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cheong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898083">
			March 1, 2011 at 1:22 am</a>		</div>

		<p>@Worf: That&#39;s why a transactional file system is essential for system reliability.</p>
<p>In your scenario, when the system reboots, the FS driver will see the file write isn&#39;t complete, and discard the node change transaction. The sequence of nodes in the original file is not updated, so the users will just see the old file untouched.</p>
<p>Btw, in Wladimir&#39;s case, it&#39;d be great to know if &quot;tunneling&quot;[<a target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2005/07/15/439261.aspx" rel="nofollow">blogs.msdn.com/&#8230;/439261.aspx</a>] will work with file object identifier as well.</p>
<div class="post">[<i>From what I can tell (remember, not authoritative) it does. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-898093">
				<div id="div-comment-898093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898093">
			March 1, 2011 at 1:48 am</a>		</div>

		<p>@Joshua: with the appropriate patch ( <a rel="nofollow" target="_new" href="http://www.kernel.org/pub/linux/kernel/people/rml/iopen/open-by-inode-rml-2.6.18-rc1-2.patch" rel="nofollow">http://www.kernel.org/&#8230;/open-by-inode-rml-2.6.18-rc1-2.patch</a> ) Linux&#39;s ext3 supports an O(1) open operation based on a file&#39;s inode number. &nbsp;Inodes are stored in tables with static offsets at known locations on the disk. &nbsp;There is a direct 1-&gt;1 inode number to block number mapping, which you can determine only by reading the filesystem&#39;s superblock (an O(1) operation). &nbsp;Opening a file by inode therefore requires exactly 2 disk reads: superblock + inode block. &nbsp;I don&#39;t know the structure of NTFS, but it&#39;s plausible that depending on how file IDs are allocated a similar approach may be taken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898123">
				<div id="div-comment-898123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898123">
			March 1, 2011 at 4:26 am</a>		</div>

		<p>&quot;If you want to use GUIDs to identify your files, then nobody&#39;s stopping you&quot;</p>
<p>Woohoo!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-898113">
				<div id="div-comment-898113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gechurch</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898113">
			March 1, 2011 at 4:07 am</a>		</div>

		<p>@ChrisMcB</p>
<p>There is one difference between the file extension and true metadata &#8211; the user can&#39;t easily change the other metadata, but wiping out or changing the file extension is easy.</p>
<p>@James Schend</p>
<p>&quot;The beauty of this system is that you could have 400 text files on your system, some of which were opened by Netscape, others by MS Word, others by SimpleText&#8230;&quot;</p>
<p>You have *such* a different defintion of beauty than I do! That&#39;s one of my primary hates of the old Mac OS. I can see how it would be handy occasionally, but if I have a preferred text editor, I want to use that to edit my text documents. I definitely don&#39;t want the file opening in whatever program the person who created the file preferred. It&#39;s also a big part of why I found Mac OS to be such a &quot;messy&quot; OS. I like my OS to be deterministic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898373">
				<div id="div-comment-898373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898373">
			March 1, 2011 at 12:40 pm</a>		</div>

		<p>@Alex Grigoriev: That&#39;s great, but it doesn&#39;t/didn&#39;t help with the hordes of Linux machines that came along with the Internet. All moot now anyway, Apple botched the next-gen Mac OS development and now it&#39;s just yet another Linux.</p>
<p>@Gechurch: Maybe you didn&#39;t know you could change the file Creator at any time, and change which application opens it. Besides, it was completely deterministic: the file Creator didn&#39;t randomly change on its own, and the file&#39;s icon clearly communicated what program would be launched when you double-clicked it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-898433">
				<div id="div-comment-898433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898433">
			March 1, 2011 at 11:37 pm</a>		</div>

		<p>@Jules: one read operation, not two. The superblock read is free as the filesystem reads and caches it during the mount, so open by inode requires just one disk operation to look up the details.</p>
<p>(The superblock is rarely touched &#8211; at best a bit is flipped to indicate the filesystem is dirty and not unmounted cleanly. But it&#39;s also important enough that an in-memory representation is used as it holds all the vital parameters for the filesystem.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898493">
				<div id="div-comment-898493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ashleigh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898493">
			March 2, 2011 at 3:43 am</a>		</div>

		<p>Ahhhhh&#8230;. Takes me back to the days of VAX/VMS and opening files by FID (File ID).</p>
<p>This was a wonderful way in a program of opening a file that was read/write, but buried inside a directory that was not accessible by other users. Viola &#8211; system for updating a file but nobody else could see what the file was, or navigate to it, and dumping the exe did not even yield a path full of text. Of course you could always debug and single step it.</p>
<p>And then (as mentioned above) the Apollo Domain/OS system had a similar idea as well. I even wrote one of the those file system type managers &#8211; it turned file system access and grabbed it to re-route to a device driver for a home made I/O card. All in user space with no need for kernel drivers or mods.</p>
<p>Some of these neat ideas have a very long history behind them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-898503">
				<div id="div-comment-898503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GSerg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898503">
			March 2, 2011 at 5:40 am</a>		</div>

		<blockquote><p>
  &gt; it&#39;d be great to know if &quot;tunneling&quot; will work</p>
<p>  [From what I can tell (remember, not authoritative) it does. -Raymond]
</p></blockquote>
<p>I was going to ask the same question!</p>
<p>On a side note, what wonders me about tunneling is why Windows 7 suddenly stopped respecting it at the visual level.</p>
<p>If you create an Excel file and place it in the middle of your desktop on WinXP, then make changes to this file and save, the file will remain in the middle of the desktop. WinXP knows it&#39;s the same file, despite Excel deleted the old file and created a new one.</p>
<p>If you do the same on Win7, the file will jump to the first free cell of the icons grid on the desktop as soon as you save it. Win7 fails to recognize tunneling (at least at the visual level), so the &quot;newly created&quot; file gets into the first free slot.</p>
<p>Same for file lists in Explorer. Daily I have to deal with folders filled with like forty Word documents each. I open them one by one, making changes and saving. The selected file in Explorer has been my bookmark all the time. I always knew the selection will not get lost when Word deletes the old version and creates a new file to save. With Windows 7, the bookmark won&#39;t work for me anymore. Whenever Word saves the currently selected file by deleting and creating, the selection resets. I now have to figure out where I was on the list.</p>
<p>Is that a hint for us the tunneling gotta go soon?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898523">
				<div id="div-comment-898523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898523">
			March 2, 2011 at 7:10 am</a>		</div>

		<p>@GSerg:</p>
<p>Could it be that tunneling is tied to short name generation, and you disabled short names in your setup?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-898583">
				<div id="div-comment-898583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GSerg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898583">
			March 2, 2011 at 7:36 am</a>		</div>

		<p>@Alex Grigoriev:</p>
<p>No, I didn&#39;t disable anything. I&#39;m having this issue on both Windows 7 Professional 32-bit at my workplace and Windows 7 Home Basic 64-bit at home.</p>
<p>NtfsDisable8dot3NameCreation on both PCs has the value of 2, and I&#39;m fairly sure nobody has ever touched it. I know that allowed values are 0 and 1 (<a rel="nofollow" target="_new" href="http://technet.microsoft.com/en-us/library/cc959352.aspx" rel="nofollow">technet.microsoft.com/&#8230;/cc959352.aspx</a>).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-898603">
				<div id="div-comment-898603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GSerg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-898603">
			March 2, 2011 at 7:50 am</a>		</div>

		<p>Oh.</p>
<p>There&#39;s a newer version of this article (<a rel="nofollow" target="_new" href="http://technet.microsoft.com/en-us/library/cc778996(WS.10).aspx" rel="nofollow">technet.microsoft.com/&#8230;/cc778996(WS.10).aspx</a>).</p>
<p>fsutil 8dot3name query c:</p>
<p>-&gt; Yes, I&#39;ve got 8dot3 names on for volume c:.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-899333">
				<div id="div-comment-899333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110228-00/?p=11363#comment-899333">
			March 5, 2011 at 5:30 pm</a>		</div>

		<p>Having a unique GUID for each file is just one part of the equation. That would allow you to have several files with the same filename from the filesystem&#39;s point of view because filename would turn into a mere human readable _description_ of the file contents, instead of being the unique key by which the file is accessed.</p>
<p>To differentiate between file types, you would need to use GUIDs instead of file extensions. You could specify the type/GUID when you CreateFile(), and if the file is called &quot;blah&quot; the system would still know the correct program to use to open it even if you had two &quot;blah&quot; files in the same folder (For example one AVI and one JPEG).</p>
<div class="post">[<i>At this point, you&#39;re just changing the definition of &quot;name&quot; from &quot;the thing used to identify the file&quot; to &quot;the thing shown to the user.&quot; (And what problem is using GUIDs supposed to solve? I don&#39;t recall file extension conflicts being a serious problem.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

