<html>
<head>
<title>Using the powers of mathematics to simplify multi-level comparisons</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Using the powers of mathematics to simplify multi-level comparisons</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>April 13, 2005 / year-entry #92</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>15</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">What a boring title. Often you'll find yourself needing to perform a multi-level comparison. The most common example of this is performing a version check when there are major and minor version numbers involved. Bad version number checks are one of the most common sources of errors. If you're comparing version numbers, you can use...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
What a boring title.
</p>
<p>
Often you'll find yourself needing to perform a multi-level comparison.
The most common example of this is performing a version check when
there are major and minor version numbers involved.
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2004/02/13/72476.aspx">
Bad version number checks</a> are one of the most common sources
of errors.
</p>
<p>
If you're comparing version numbers, you can use
<a HREF="http://msdn.microsoft.com/library/en-us/sysinfo/base/verifying_the_system_version.asp">
the <code>VerifyVersionInfo</code> function</a>
to do the version check for you,
assuming you don't need to
run on operating systems prior to Windows&nbsp;2000.
</p>
<p>
Instead of writing a multi-level comparison, you can pack the
values into a single comparison.
Consider:
</p>
<pre>
inline unsigned __int64
MakeUINT64(DWORD Low, DWORD High)
{
  ULARGE_INTEGER Value;
  Value.LowPart = Low;
  Value.HighPart = High;
  return Value.QuadPart;
}

BOOL IsVersionAtLeast(DWORD Major, DWORD Minor,
                      DWORD MajorDesired, DWORD MinorDesired)
{
  return MakeUINT64(Minor, Major) &gt;= MakeUINT64(MinorDesired, MajorDesired);
}
</pre>
<p>
What happened here?
</p>
<p>
We took the two 32-bit values and combined them into a large
64-bit value, putting the most significant portion in the high-order
part and the less significant portion in the lower-order part.
</p>
<p>
Then we sit back and let the power of mathematics do our work for us.
If you remember the rules for comparisons from grade school,
you'll realize that they exactly match the rules we want to apply
to our multi-level comparison.  Compare the major values; if different,
then that's the result. Otherwise, compare the minor values.
</p>
<p>
If you still don't believe it, look at the generated code:
</p>
<pre>
  00000 8b 44 24 04      mov     eax, DWORD PTR _Major$[esp-4]
  00004 3b 44 24 0c      cmp     eax, DWORD PTR _MajorDesired$[esp-4]
  00008 8b 4c 24 08      mov     ecx, DWORD PTR _Minor$[esp-4]
  0000c 8b 54 24 10      mov     edx, DWORD PTR _MinorDesired$[esp-4]
  00010 72 0b            jb      SHORT $L48307
  00012 77 04            ja      SHORT $L48317
  00014 3b ca            cmp     ecx, edx
  00016 72 05            jb      SHORT $L48307
$L48317:
  00018 33 c0            xor     eax, eax
  0001a 40               inc     eax
  0001b eb 02            jmp     SHORT $L48308
$L48307:
  0001d 33 c0            xor     eax, eax
$L48308:
  0001f c2 10 00         ret     16                     ; 00000010H
</pre>
<p>
The code generated by the compiler is equivalent to
</p>
<pre>
BOOL IsVersionAtLeastEquiv(DWORD Major, DWORD Minor,
                      DWORD MajorDesired, DWORD MinorDesired)
{
 if (Major &lt; MajorDesired) return FALSE;
 if (Major &gt; MajorDesired) return TRUE;
 if (Minor &lt; MinorDesired) return FALSE;
 return TRUE;
}
</pre>
<p>
In fact, if you had written the code the (error-prone)
old-fashioned way, you would have gotten this:
</p>
<pre>
BOOL IsVersionAtLeast2(DWORD Major, DWORD Minor,
                       DWORD MajorDesired, DWORD MinorDesired)
{
  return Major &gt; MajorDesired ||
   (Major == MajorDesired &amp;&amp; Minor &gt;= MinorDesired);
}

  00000 55               push    ebp
  00001 8b ec            mov     ebp, esp
  00003 8b 45 08         mov     eax, DWORD PTR _Major$[ebp]
  00006 3b 45 10         cmp     eax, DWORD PTR _MajorDesired$[ebp]
  00009 77 0e            ja      SHORT $L48329
  0000b 75 08            jne     SHORT $L48328
  0000d 8b 45 0c         mov     eax, DWORD PTR _Minor$[ebp]
  00010 3b 45 14         cmp     eax, DWORD PTR _MinorDesired$[ebp]
  00013 73 04            jae     SHORT $L48329
$L48328:
  00015 33 c0            xor     eax, eax
  00017 eb 03            jmp     SHORT $L48330
$L48329:
  00019 33 c0            xor     eax, eax
  0001b 40               inc     eax
$L48330:
  0001c 5d               pop     ebp
  0001d c2 10 00         ret     16                     ; 00000010H
</pre>
<p>
which is, as you can see, functionally identical to both previous
versions.
</p>
<p>
You can also pack the values into smaller units, provided
you know that there will be no overflow or truncation.
For example, if you know that the Major and Minor values will
never exceed 65535, you could have used the following:
</p>
<pre>
BOOL SmallIsVersionAtLeast(WORD Major, WORD Minor,
                           WORD MajorDesired, WORD MinorDesired)
{
 return MAKELONG(Minor, Major) &gt;= MAKELONG(MinorDesired, MajorDesired);
}

 00000 0f b7 44 24 0c   movzx   eax, WORD PTR _MajorDesired$[esp-4]
 00005 0f b7 4c 24 10   movzx   ecx, WORD PTR _MinorDesired$[esp-4]
 0000a 0f b7 54 24 08   movzx   edx, WORD PTR _Minor$[esp-4]
 0000f c1 e0 10         shl     eax, 16                        ; 00000010H
 00012 0b c1            or      eax, ecx
 00014 0f b7 4c 24 04   movzx   ecx, WORD PTR _Major$[esp-4]
 00019 c1 e1 10         shl     ecx, 16                        ; 00000010H
 0001c 0b ca            or      ecx, edx
 0001e 33 d2            xor     edx, edx
 00020 3b c8            cmp     ecx, eax
 00022 0f 9d c2         setge   dl
 00025 8b c2            mov     eax, edx
 00027 c2 10 00         ret     16                     ; 00000010H
</pre>
<p>
And if you know that the versions will never exceed 255, then you
can go even smaller:
</p>
<pre>
BOOL TinyIsVersionAtLeast(BYTE Major, BYTE Minor,
                          BYTE MajorDesired, BYTE MinorDesired)
{
 return MAKEWORD(Minor, Major) &gt;= MAKEWORD(MinorDesired, MajorDesired);
}

  00000 33 c0            xor     eax, eax
  00002 8a 64 24 0c      mov     ah, BYTE PTR _MajorDesired$[esp-4]
  00006 33 c9            xor     ecx, ecx
  00008 8a 6c 24 04      mov     ch, BYTE PTR _Major$[esp-4]
  0000c 8a 44 24 10      mov     al, BYTE PTR _MinorDesired$[esp-4]
  00010 8a 4c 24 08      mov     cl, BYTE PTR _Minor$[esp-4]
  00014 66 3b c8         cmp     cx, ax
  00017 1b c0            sbb     eax, eax
  00019 40               inc     eax
  0001a c2 10 00         ret     16                     ; 00000010H
</pre>
<p>
Why would you ever need to go smaller if the original version works
anyway?  Because you might want to make a three-way or four-way
comparison, and packing the values smaller allows you to squeeze
more keys into the comparison.
</p>
<pre>
BOOL IsVersionBuildAtLeast(
    WORD Major, WORD Minor, DWORD Build,
    WORD MajorDesired, WORD MinorDesired, DWORD BuildDesired)
{
 return MakeUINT64(Build, MAKELONG(Minor, Major)) &gt;=
  MakeUINT64(Build, MAKELONG(MinorDesired, MajorDesired));
}
</pre>
<p>
By packing the major version, minor version, and build number
into a single 64-bit value, a single comparison operation will
compare all three at once.  Compare this to the complicated
(and teetering-towards unreadable) chain of comparisons you would normally
have to write:
</p>
<pre>
  return Major &gt; MajorDesired ||
   (Major == MajorDesired &amp;&amp;
    (Minor &gt;= MinorDesired ||
     (Minor == MinorDesired &amp;&amp; Build &gt;= BuildDesired)));
</pre>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (15)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-270313">
				<div id="div-comment-270313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270313">
			April 13, 2005 at 9:38 am</a>		</div>

		<p>I think there&#8217;s a mistake in that last code block (example of the other way to do it).  That block looks like if the major and minor match, the build match is ignored.</p>
<p>This should have the desired result:</p>
<p>  return Major &gt; MajorDesired ||<br />
<br />   (Major == MajorDesired &amp;&amp;<br />
<br />    (Minor &gt; MinorDesired ||<br />
<br />     (Minor == MinorDesired &amp;&amp; Build &gt;= BuildDesired)));</p>
<p>Of course, maybe you just did that to illustrate your point&#8230;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-270343">
				<div id="div-comment-270343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://Ken@Alverson.net' rel='external nofollow' class='url'>Ken</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270343">
			April 13, 2005 at 12:45 pm</a>		</div>

		<p>If you are in C++ land, you can do:</p>
<p>return !std::lexicographical_compare(<br />
<br />          version.begin(),version.end(),<br />
<br />          desired.begin(),desired.end()<br />
<br />          );</p>
<p>or simply:</p>
<p>return !(version &lt; desired);</p>
<p>This assumes the version numbers are packaged up in a standard container, but lexicographical_compare can operate on raw arrays just as well as it can containers, it&#8217;s just a little wordy&#8230;</p>
<p>return !std::lexicographical_compare(<br />
<br />          version,version+VERSION_ELEMENTS,<br />
<br />          desired,desired+VERSION_ELEMENTS<br />
<br />          );</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-270353">
				<div id="div-comment-270353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270353">
			April 13, 2005 at 2:13 pm</a>		</div>

		<p>MAKELONG is signed though, you either need another macro or decrease the range of the minor version to 32767.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-270363">
				<div id="div-comment-270363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270363">
			April 13, 2005 at 2:19 pm</a>		</div>

		<p>Err major version, I&#8217;m really not a fan of the ordering of those parameters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-270423">
				<div id="div-comment-270423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasmusic.com' rel='external nofollow' class='url'>Joshua Schaeffer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270423">
			April 13, 2005 at 3:55 pm</a>		</div>

		<p>It&#8217;s a neat trick, but hailing it as &quot;Using the powers of mathematics!&quot; just sounds waaay too corny.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-270433">
				<div id="div-comment-270433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Diego</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270433">
			April 13, 2005 at 4:55 pm</a>		</div>

		<p>I wanted to ask a question; I don&#8217;t know if you&#8217;ve answered to it already in your huge blog (it&#8217;s not a easy search): Why can&#8217;t a file be read when someone has opened it? (ie: typical buggy video codecs which don&#8217;t allow you to delete the video after you closed all the apps)</p>
<p>I&#8217;m shoked that it doesn&#8217;t works that way, it&#8217;d make updates more easy &#8211; just overwrite the file, and restart the service like other OSes do. I guess there&#8217;s a reason for it but I never have found it, only you could answer such question! ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-270443">
				<div id="div-comment-270443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270443">
			April 13, 2005 at 5:14 pm</a>		</div>

		<p>Please use the suggestion box for off-topic questions. (Look at the dwShareMode parameter to CreateFile for the answer.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-270473">
				<div id="div-comment-270473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.livejournal.com/users/zorbathut' rel='external nofollow' class='url'>Ben Wilhelm</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270473">
			April 13, 2005 at 7:20 pm</a>		</div>

		<p>My technique for doing the last code block:</p>
<p>if( Major &lt; MajorDesired ) return false;<br />
<br />if( Major &gt; MajorDesired ) return true;<br />
<br />if( Minor &lt; MinorDesired ) return false;<br />
<br />if( Minor &gt; MinorDesired ) return true;<br />
<br />if( Build &lt; BuildDesired ) return false;<br />
<br />if( Build &gt; BuildDesired ) return true;<br />
<br />return true;</p>
<p>Simple pattern, easy to see, easy to understand, trivially extendable to as many comparisons as you want.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-270513">
				<div id="div-comment-270513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jasondoucette.com/' rel='external nofollow' class='url'>Jason Doucette</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270513">
			April 13, 2005 at 9:26 pm</a>		</div>

		<p>I believe this is what I suggested in your original post:<br />
<br /><a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2004/02/13/72476.aspx#72543" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2004/02/13/72476.aspx#72543</a></p>
<p>To take this a step further&#8230; I required such a solution a long time ago for a video game.  It required about 10 or 12 levels of such compares.  I decided to use two floating point numbers.  They started with the most significant factor.  I iteratively went through all the remaining factors, from most significant to least.  In the loop, I multiplied the floats by the current factorâ€™s maximum possible value, and then added the value of the factor.  The result was two floats that I could compare.  As long as each factor never overflowed its known maximum value, it worked.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-270523">
				<div id="div-comment-270523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Centaur</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270523">
			April 14, 2005 at 12:29 am</a>		</div>

		<p>With floats, you can also apply some kind of a monotonous function to fit any float into a finite range. For example, (arctan(x)/pi)+0.5 will map (-infinity, infinity) to (0, 1).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-270543">
				<div id="div-comment-270543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270543">
			April 14, 2005 at 4:58 am</a>		</div>

		<p>Oh please dont use floats like that. Theyre lossy. Which means two things: First that two identical version numbers could &#8211; depending on the calculation &#8211; have slightly different, and thus unequal representations. Next, using a lossy datatype like a float means that your least significant components could drop right off the end, and you&#8217;d never know &#8211; until the check failed in some horrible way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-270553">
				<div id="div-comment-270553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas Anderson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270553">
			April 14, 2005 at 5:10 am</a>		</div>

		<p>is there anything special in this code?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-270813">
				<div id="div-comment-270813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2005/04/15/408507.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-270813">
			April 15, 2005 at 9:03 am</a>		</div>

		<p>Combining two tricks into one big trick.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-271083">
				<div id="div-comment-271083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.livejournal.com/users/merle_/' rel='external nofollow' class='url'>Merle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-271083">
			April 15, 2005 at 9:10 pm</a>		</div>

		<p>Ben Wilhelm: while your code doesn&#8217;t use astounding tricks or anything, I much prefer it.  I was trying to decide how to better indent the &quot;complicated<br />(and teetering-towards unreadable) chain of comparisons&quot; (which I think could be fixed with proper indentation), but your way is much simpler.</p>
<p>And I would much rather debug yours.  No integer-size issues, either&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-272723">
				<div id="div-comment-272723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050413-56/?p=35913#comment-272723">
			April 25, 2005 at 10:40 am</a>		</div>

		<p>Similarly, it&#8217;s much easier to compare dates if you represent them as year, month, day. How you encode the exact values is up to you, but most people seem to like the idea of using a string of the form YYYY-MM-DD, or an integer which looks like YYYYMMDD when in base 10. You can also pack the binary values into a 32-bit integer if you like that sort of thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

