<html>
<head>
<title>Is WriteProcessMemory atomic?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Is WriteProcessMemory atomic?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>May 15, 2014 / year-entry #122</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>33</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer asked, "Does Write­Process­Memory write the memory atomically? I mean, if I used Write­Process­Memory to write 10 instructions for a total of 20 bytes, can Write­Process­Memory wrote those 20 bytes atomically?" CPUs typically provide only modest atomic update capabilities. The x86 family of processors, for example, can update up to eight bytes atomically. Twenty...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>A customer asked, "Does <code>Write&shy;Process&shy;Memory</code> write the memory atomically? I mean, if I used <code>Write&shy;Process&shy;Memory</code> to write 10 instructions for a total of 20 bytes, can <code>Write&shy;Process&shy;Memory</code> wrote those 20 bytes atomically?"</p>
<p> CPUs typically provide only modest atomic update capabilities. The x86 family of processors, for example, can update up to eight bytes atomically. Twenty bytes is beyond the capability of the processor. </p>
<p> I was kind of baffled at what sort of mental model of computing the customer had developed. It apparently permits <code>Write&shy;Process&shy;Memory</code> to accomplish something that the CPU is not physically capable of performing. </p>
<p> "Will my aluminum hammer withstand temperatures above 700C?" </p>
<p> Given that aluminum melts at 660C, it doesn't matter whether you make a hammer or a ladder or a scaffold. As long as you make it out of aluminum, it will melt at 660C because that's a fundamental property of aluminum. </p>
<p> The only thing I can think of is that the customer thought that maybe the kernel suspended all of the threads in the process, updated the memory, and then unfroze them all. It wouldn't be an atomic update in an absolute sense (somebody else doing a <code>Read&shy;Process&shy;Memory</code> might read an in-progress write), but it would be atomic from the viewpoint of the process being written to. </p>
<p> But no, the <code>Write&shy;Process&shy;Memory</code> function does no such thing. It merely writes the memory into the process address space. </p>
<p> Another way of thinking about it is using the thought experiment "Imagine if this were true." If it were true that <code>Write&shy;Process&shy;Memory</code> provided atomicity guarantees for 20 bytes, then all sorts of multi-threaded synchronization problems would magically disappear. If you wanted to update a block of memory in your process atomically, you would just call <code>Write&shy;Process&shy;Memory</code> on your own process handle! </p>
<p> I noted that the underlying scenario sounds really fishy. Using <code>Write&shy;Process&shy;Memory</code> to update code in a process sounds an awful lot like the customer is writing a virus. One of my colleagues who studies malware agreed, adding, "On the other hand, some anti-malware products also use that approach, as dubious as it is. For the record, I would like to add, 'yuck'." My colleague asked the customer for further details on what they are doing, and why they think that <code>Write&shy;Process&shy;Memory</code> is what they need, so that a proper solution to their underlying problem could be developed. </p>
<p> We never heard back from the customer. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (33)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1124393">
				<div id="div-comment-1124393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124393">
			May 15, 2014 at 7:13 am</a>		</div>

		<p>You totally psyched that one, no wonder he ran.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124403">
				<div id="div-comment-1124403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124403">
			May 15, 2014 at 7:30 am</a>		</div>

		<p>And the punchline I was expecting was &quot;with respect to other calls to ReadProcessMemory and WriteProcessMemory&quot;. Incidentally atomic means succeeds in whole or fails in whole while the property being talked about is isolated.</p>
<p>It would be interesting if WriteProcessMemory in fact could not succeed in part and fail in part but I&#39;m pretty sure that is not true.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124413">
				<div id="div-comment-1124413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124413">
			May 15, 2014 at 7:32 am</a>		</div>

		<p>The kernel can totally write 20bytes via WriteProcessMemory atomically if it choses to do so:</p>
<p>void AtomicWriteProcessMemory(HPROCESS hProc, size_t lpDst, void* lpSrc, size_t cbSize)</p>
<p>{</p>
<p>&nbsp;SuspendAllThreads(hProc);</p>
<p>&nbsp;WriteProcessMemory(hProc, lpDst, lpSrc, cbSize);</p>
<p>&nbsp;ResumeAllThreadsThatIJustSuspended(hproc);</p>
<p>}</p>
<div class="post">[<em>This was discussed in the article, -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124423">
				<div id="div-comment-1124423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124423">
			May 15, 2014 at 7:36 am</a>		</div>

		<p>Also &quot;updating code sounds like a virus&quot; is also assuming the worst of your customers. AntiVirus companies, AppCompat libraries, debuggers, ProcDump, WerFault, live HeapDebuggers, VMMap, people hooking their games to make them &quot;more cool&quot; (or to bot the game) and a whole ton of other legitimate &#8211; albeit quite low-level debugging &#8211; tools make use of this functionality. </p>
<p>The thing that stops virus writers is not atomicity of the WriteProcessMemory, but the ACL check of OpenProcess. If a virus writer can OpenProcess with VIRTUAL_MEMORY_WRITE permission, you&#39;ve already lost, atomic-writes or not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124433">
				<div id="div-comment-1124433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124433">
			May 15, 2014 at 7:43 am</a>		</div>

		<p>Matt: Yes, I suspect that the customer was asking if that&#39;s how it was implemented.</p>
<p>That makes me wonder, though, how the SuspendThread operation is implemented. If it can generate an interrupt on the CPU executing the thread, it can stop immediately. It it just sets a bit in the thread&#39;s state saying that it&#39;s suspended, it will execute until its quantum runs out or is preempted. If it had to wait until the threads&#39; quanta expired, it would be a very slow call indeed.</p>
<p>However, I don&#39;t know that this question is necessarily nefarious. If I were writing a debugger, isn&#39;t it reasonable for me to have the same question?</p>
<div class="post">[<em>You&#39;ll learn more about this next February. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124443">
				<div id="div-comment-1124443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124443">
			May 15, 2014 at 8:22 am</a>		</div>

		<p>If you were competent enough to write a debugger I doubt you would ask if writing large blocks to memory can be performed atomically. Smells fishy for sure. I wouldn&#39;t even consider AV programs as legitimate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124453">
				<div id="div-comment-1124453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124453">
			May 15, 2014 at 8:32 am</a>		</div>

		<p>Matt, Gabe: I am hard pressed to find a scenario where a debugger might write large blocks of memory while the process is still running. Keep in mind that in this case, it wouldn&#39;t even need the Kernel to suspend the threads: The debugger can (and usually does) suspend them itself.</p>
<p>Yuri: Symantec seems to agree with you: <a rel="nofollow" target="_new" href="http://www.zdnet.com/antivirus-is-dead-long-live-the-antivirus-7000029078/">http://www.zdnet.com/antivirus-is-dead-long-live-the-antivirus-7000029078</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124463">
				<div id="div-comment-1124463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124463">
			May 15, 2014 at 8:44 am</a>		</div>

		<p>@Mike: &quot;The debugger can (and usually does) suspend them itself&quot;.</p>
<p>So? The debugger can (and sometimes does) do VirtualProtectEx under the hood to ensure that the destination has WRITE permissions at the destination, but WriteProcessMemory will do that for you if you forget. Suspending threads is slow, and is complicated by the fact that you need to iterate until all of the threads are suspended to beat race-conditions (in case a new thread is created during your operation), and you need to ensure that you only restart the threads that were suspended (i.e. not accidentally &quot;restart&quot; threads that were suspended before the operation).</p>
<p>That&#39;s work you CAN do yourself, but if the kernel is doing it already, it&#39;s work that&#39;s not necessary.</p>
<p>Which is why the question &quot;Does WriteProcessMemory operate atomically?&quot; is an entirely legitimate question.</p>
<p>@Yuri/Mike: &quot;I am hard pressed to find a scenario where a debugger might write &#8230; while the process is still running&quot;</p>
<p>HotPatching a process to monitor API calls (e.g. calls to HeapAlloc) on another running process is one such example.</p>
<div class="post">[<em>The debugger can just patch HeapAlloc at the initial process breakpoint, at which point has already frozen all threads in the process, so there is no need to patch the function while the process is running. Similarly, if the function is in a dynamically-loaded DLL, it can patch the function at the DLL load notification breakpoint. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124473">
				<div id="div-comment-1124473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124473">
			May 15, 2014 at 8:58 am</a>		</div>

		<p>As to the comment about someone competent enough to write a debugger should already know about atomic writes &#8230;</p>
<p>Lots of not-yet-competent people learn by doing. &nbsp;I&#39;m always astounded by the number of questions of Stack Overflow about DLL injection, detours, hooking, keylogging, and other techniques often used by debuggers and malware and anti-malware and regular old apps written by not-yet-competent people.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124483">
				<div id="div-comment-1124483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124483">
			May 15, 2014 at 9:17 am</a>		</div>

		<p>@Adrian</p>
<p>Yep the kind of questions Dread Pirate Roberts would ask ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124493">
				<div id="div-comment-1124493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andre</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124493">
			May 15, 2014 at 9:21 am</a>		</div>

		<p>I too think that the only fair interpretation of the question is the second one. Is the write atomic to the target process, i.e. does the kernel do suspending. The &quot;Imagine if this were true&quot; experiment isn&#39;t helpful either. The question is very likely not about writing to your own process, and (assuming the kernel did suspend and resume threads) it would just be an awfully inefficient lock mechanism.</p>
<p>About the whole scenario being fishy: Apparently there are reasons for WriteÂ­ProcessÂ­Memory to exists at all. On first glance, the whole function seems fishy, before you think about debuggers and the like.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124503">
				<div id="div-comment-1124503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GrumpyYoungMan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124503">
			May 15, 2014 at 9:42 am</a>		</div>

		<p>Isn&#39;t the underlying mystery how a virus writer could afford a support contract with Microsoft so that they were able to ask the question?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124513">
				<div id="div-comment-1124513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124513">
			May 15, 2014 at 9:44 am</a>		</div>

		<p>@Raymond: &quot;[The debugger can just patch HeapAlloc at the initial process breakpoint, at which point has already frozen all threads in the process, so there is no need to patch the function while the process is running. Similarly, if the function is in a dynamically-loaded DLL, it can patch the function at the DLL load notification breakpoint. -Raymond]&quot;</p>
<p>Starting the process in debug mode changes the behavior of lots of things, including the heap. Perhaps my debugger wants to analyze how the real heap works because of a heisenbug. Or perhaps I want to be able to hook a process that is actively hostile to debuggers (like, say, a game that I need to develop an app-compat shim for, but which has anti-debugging across the process).</p>
<div class="post">[<em>Assuming you don&#39;t want to use -hd to disable the debug-mode heap, your debugger is still going to suspend all the threads as part of the initial attach, so the threads are already suspended at the time you need to do your patching. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124523">
				<div id="div-comment-1124523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124523">
			May 15, 2014 at 9:53 am</a>		</div>

		<p>@GrumpyYoungMan </p>
<p>Aren&#39;t they all intern for the CIA anyway?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124533">
				<div id="div-comment-1124533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124533">
			May 15, 2014 at 10:33 am</a>		</div>

		<p>Might be naÃ¯ve porting of ancient code which uses self modifying code&#8230; (IIRC old version of ZDoom used it) Also it could be for very fringe of non-malware or non-security field like Demoscene.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124543">
				<div id="div-comment-1124543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124543">
			May 15, 2014 at 10:45 am</a>		</div>

		<p>This question doesn&#39;t sound as ridiculous to me as it may have sounded to you.</p>
<p>I know at least one operating system (INTEGRITY) which works like this: invoking a syscall suspends the scheduler. Most syscalls have a bounded runtime. Those that can run for a longer time periodically check for a preemption request, and then save state, return, and ask the application to retry the call.</p>
<p>In that operating system, the equivalent of WriteProcessMemory for 20 bytes would be atomic (I believe the threshold for allowing preemption is somewhere around 128 bytes).</p>
<p>This works perfectly on single-core processors. I don&#39;t know how they do multi-core, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124553">
				<div id="div-comment-1124553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124553">
			May 15, 2014 at 10:51 am</a>		</div>

		<p>@Stefan: Having dealt with a multi-core OS with this property, the answer is multi-core isn&#39;t worth much anymore.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124563">
				<div id="div-comment-1124563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124563">
			May 15, 2014 at 11:14 am</a>		</div>

		<p>The suspend-all-threads approach doesn&#39;t get you memory atomicity. There are non-CPU agents that can access memory. &nbsp;Memory atomicity has to involve the memory controller.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124573">
				<div id="div-comment-1124573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">f0dder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124573">
			May 15, 2014 at 11:18 am</a>		</div>

		<p>Raymond, if somebody were writing a virus, they&#39;d be stupid to file a customer ticked with Microsoft &#8211; even back in the days of dialup, there was a lot of information easily available for people who wanted to do that kind of thing. If you were a normal developer who didn&#39;t have interest in those keywords, a lot of lower-level coding stuff would slip you by.</p>
<p>Hoping that this doesn&#39;t violate the &quot;don&#39;t mention product names&quot; rule :) &#8211; I bugfixed the Windows re-release of &quot;a game about extra-terrestrials invading earth&quot; (the original two, the rest of the series sucked) with memory patching. The original &quot;game platform which name is something you&#39;d find on a pipe&quot; re-re-release of those games used my patch, although I believe they&#39;ve moved to DOSbox now. So there&#39;s definitely non-malicious uses for doing memory patching of code.</p>
<p>Also: &quot;The debugger can just patch HeapAlloc at the initial process breakpoint&quot; &#8211; are all theads automagically suspended when a debugger does &quot;attach to process&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124583">
				<div id="div-comment-1124583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124583">
			May 15, 2014 at 11:47 am</a>		</div>

		<p>&gt;&gt; [Assuming you don&#39;t want to use -hd to disable the debug-mode heap, your debugger is still going to suspend all the threads as part of the initial attach, so the threads are already suspended at the time you need to do your patching. -Raymond]</p>
<p>This is just becoming an example of moving the goalposts. Suppose I&#39;m live-hooking a process that does a query to NtQueryInformationProcess to find if the process is attached, which means that I can&#39;t attach a debugger like WinDbg. Perhaps another example might be someone hotpatching a process, in much the same way that Microsoft (used to) hotpatch binaries as part of an auto-update.</p>
<p>The point is that there are lots of reasons why someone might want to WriteProcess to another process (because otherwise why is that function even there?). If you concede that someone might want to WriteProcess to another process, you have to concede that they might want to do so atomically. Which makes the question not quite as ridiculous as you claim it to be.</p>
<div class="post">[<em>At the end of the day, <span style="text-decoration:underline;">somebody</span> needs to suspend all the threads if you need intra-process atomicity. Intra-process atomicity is an odd requirement and is not the common case use of WriteProcessMemory, so it would make sense to shift the work outside WriteProcessMemory. (And, as I noted before, <a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/08/08/10334563.aspx">WriteProcessMemory exists primarily for debuggers</a>, and debuggers already are suspending threads anyway.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124593">
				<div id="div-comment-1124593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124593">
			May 15, 2014 at 12:00 pm</a>		</div>

		<p>I asked pretty much the same question as this article &#8211; how to implement atomic patching &#8211; on the OSR Online mailing list and got flamed every which way for it. &nbsp;The difference is, I was writing a kernel driver, and was asking from the perspective of how to suspend everything, since obviously the processor can&#39;t do the writes atomically. &nbsp;I.e. I know what I&#39;m doing in terms of patching, though not much in terms of NT kernel development. &nbsp;And no, I&#39;m not writing malware. &gt;.&lt;</p>
<p>WriteProcessMemory is convenient in that it calls NtProtectVirtualMemory for you in addition to NtWriteVirtualMemory &#8211; you don&#39;t have to call VirtualProtectEx yourself unless you&#39;re writing to a few things, such as import tables.</p>
<p>I think programmers are too afraid of self-modifying code now. &nbsp;There are a couple of things that would benefit from it. &nbsp;Selection among code paths based on CPU features is one thing &#8211; you can avoid indirect branches by patching jumps at startup after detecting whether the CPU supports AVX.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124613">
				<div id="div-comment-1124613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124613">
			May 15, 2014 at 12:29 pm</a>		</div>

		<p>I&#39;m now going to be absolutely nitpicky and all, but: x86 actually supports double CAS using CMPXCHG16B so we could actually update 16 byte atomically.</p>
<p>Still not 20 byte though so useless for this question.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124643">
				<div id="div-comment-1124643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124643">
			May 15, 2014 at 3:36 pm</a>		</div>

		<p>&quot;I think programmers are too afraid of self-modifying code now.&quot;</p>
<p>With good reason. It&#39;s murder on the pipelines.</p>
<p>Of course a one-time patch like you describe is OK. But that&#39;s not really what most folks call &quot;self-modifying code&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124653">
				<div id="div-comment-1124653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lwahonen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124653">
			May 15, 2014 at 8:25 pm</a>		</div>

		<p>Or they were patching interop to some horrible, horrible old system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124663">
				<div id="div-comment-1124663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Guest</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124663">
			May 15, 2014 at 9:37 pm</a>		</div>

		<p>Sorry I didn&#39;t get it, what will happen &quot;next Februry&quot; ??</p>
<div class="post">[<em>&quot;That makes me wonder, though, how the SuspendThread operation is implemented.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124623">
				<div id="div-comment-1124623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124623">
			May 15, 2014 at 3:22 pm</a>		</div>

		<p>@Myria: if you are at startup, there&#39;s only one thread &#8211; the one running main() or WinMain() or wWinMain() or whatever it&#39;s called on Windows these days. Or there should be, since Windows programmers love injecting DLLs and threads on unrelated processes and making them crash in unexpected and exciting ways. But even then, these injected threads and DLLs are not running *your* code (I hope), so you can still patch it before doing any real work without fear of race conditions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fleet-command even thread-even depth-1" id="comment-1124673">
				<div id="div-comment-1124673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Fleet+Command' rel='external nofollow' class='url'>Fleet Command</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124673">
			May 15, 2014 at 11:03 pm</a>		</div>

		<p>Assuming bad faith in a customer, aren&#39;t we? This is probably someone who had read a feature of atomic write somewhere and thought &quot;Wow! That&#39;s awesome. Let&#39;s always do it.&quot;</p>
<p>Reminds me of when I was trying to use database transaction to ensure power outage resiliency, whereas I should have used change-log flushing. It was my first time and the documentation was poor. But someone in the know thought it was fishy that I am starting a transaction for only one change and concluded that I was doing something behind the scene. Fortunately the misunderstanding was cleared quickly. (Still, he didn&#39;t know about change-log flushing either. For him, UPS was the God&#39;s answer to all his prayers.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124683">
				<div id="div-comment-1124683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">caf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124683">
			May 15, 2014 at 11:32 pm</a>		</div>

		<p>I think it is quite unlikely that the interrogator was writing a virus, because a virus writer wouldn&#39;t really care about a rare race condition that could crash the target process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124693">
				<div id="div-comment-1124693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andre</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124693">
			May 16, 2014 at 1:43 am</a>		</div>

		<p>[At the end of the day, somebody needs to suspend all the threads if you need intra-process atomicity. Intra-process atomicity is an odd requirement and is not the common case use of WriteProcessMemory, so it would make sense to shift the work outside WriteProcessMemory. (And, as I noted before, WriteProcessMemory exists primarily for debuggers, and debuggers already are suspending threads anyway.) -Raymond]</p>
<p>Yes. You are giving a perfectly reasonable rationale for why WriteProcessMemory was designed not to do that.</p>
<p>That doesn&#39;t mean the question about it is horrible itself.</p>
<div class="post">[<em>Shouldn&#39;t the person have done this thought experiment before asking the question? &quot;What would it mean for WriteProcessMemory to be atomic given that the CPU is not capable of doing so? And why would the OS add this extra complexity?&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124703">
				<div id="div-comment-1124703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RegularReader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124703">
			May 16, 2014 at 4:25 am</a>		</div>

		<p>&gt; Sorry I didn&#39;t get it, what will happen &quot;next Februry&quot; ??</p>
<p>Raymond has a queue of blog entries that he&#39;s written but not yet posted. &nbsp;That way, he doesn&#39;t have to write on a schedule &#8211; he can write whenever he likes, and they get posted on a regular schedule. &nbsp;Last I heard, the queue was a bit over a year long. &nbsp;So I think he has written a blog entry that answers your question, and it&#39;s currently in the queue and will probably be published in Feb 2015. &nbsp;(Stuff sometimes gets moved around in the queue, so that date is subject to change).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124713">
				<div id="div-comment-1124713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124713">
			May 16, 2014 at 4:54 am</a>		</div>

		<p>I&#39;ve used WriteÂ­ProcessÂ­Memory for several little debugging tools, a bunch of compatibility shims and to assist in virtualising some files and devices for the purpose of automation and to allow processes to communicate with each other in novel ways.</p>
<p>As to answer Joshua&#39;s question: ERROR_PARTIAL_COPY</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1124733">
				<div id="div-comment-1124733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wizou</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124733">
			May 16, 2014 at 5:32 am</a>		</div>

		<p>Actually, freezing all thread before WriteÂ­ProcessÂ­Memory wouldn&#39;t achieve atomicity even from the viewpoint of the process.</p>
<p>If one of the thread of the process is in the middle of a memcpy from the target area, it might copy 8 bytes from the previous data of the area, get frozen, then after resume it would copy 12 more bytes from the newly written data.</p>
<p>Because atomicity doesn&#39;t exist on x86 either for read operations beyond 8 bytes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1124773">
				<div id="div-comment-1124773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140515-00/?p=983#comment-1124773">
			May 16, 2014 at 11:20 am</a>		</div>

		<p>Wizou,</p>
<p>The write would still be atomic &#8211; in the scenario you describe read is what is non-atomic. If you read one piece, then go away and do something else, and come back later to read the rest, then AFI, YGI.</p>
<p>Obviously, if you wrap the reads and writes into some monitor or critical region software mechansims, you can make it atomic, as long as you can atomically write a flag associated with the memory areae indicating &quot;Stay off &#8211; I am busy with this area now!&quot;. It takes another byte (at least) of RAM for the flag, and a few cycles of CPU power, but the biggest problem is to force every user of the data to go through the locked gate. Actually, the overhead of a software controlled lock (based on atomic read/write flags &#8211; call them semaphores if you insist, but don&#39;t think that of them as as OS level semaphores with all THAT overhead!) can be made much lower than many people seem to think. The cost is quite reasonable (unless, of course, if you have a thousand threads that insist on refreshing the shared value every millisecond).</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

