<html>
<head>
<title>Now that version 4 of the .NET Framework supports in-process side-by-side runtimes, is it now okay to write shell extensions in managed code?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Now that version 4 of the .NET Framework supports in-process side-by-side runtimes, is it now okay to write shell extensions in managed code?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>February 22, 2013 / year-entry #52</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>36</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Many years ago, I wrote, "Do not write in-process shell extensions in managed code." Since I originally wrote that article, version 4 of the .NET Framework was released, and one of the features of that version is that it supports in-process side-by-side runtimes. Does that mean that it's now okay to write shell extensions in...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>Many years ago, I wrote, "<a href="http://blogs.msdn.com/b/oldnewthing/archive/2006/12/18/1317290.aspx">Do not write in-process shell extensions in managed code</a>." Since I originally wrote that article, version 4 of the .NET Framework was released, and one of the features of that version is that it supports in-process side-by-side runtimes. Does that mean that it's now okay to write shell extensions in managed code?</p>
<p> The answer is still no. </p>
<p> The <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd758089(v=vs.85).aspx"> Guidance for implementing in-process extensions</a> has been revised, and it continues the recommendation against writing shell extensions and Internet Explorer extensions (and other types of in-process extensions) in managed code, even if you're using version 4 or higher. </p>
<p> Although version 4 addresses the side-by-side issue, it is still the case that the .NET Framework is a high-impact runtime, and that there are various part of COM interop in the .NET Framework that are not suitable for use in an extension model designed around native code. </p>
<p> Note that managed code remains acceptable for out-of-process extensions. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (36)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-1040923">
				<div id="div-comment-1040923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1040923">
			February 22, 2013 at 8:01 am</a>		</div>

		<p>[ it is still the case that the .NET Framework is a high-impact runtime ]</p>
<p>That&#39;s the lesson everybody should have learned from the infamous &lt;major 3-letter graphic cards manufacturer&gt; Control Center shell extension (right click on the desktop -&gt; five seconds of hard disk noise -&gt; the menu finally opens; number of times the average user used that shortcut: maybe once).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040943">
				<div id="div-comment-1040943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1040943">
			February 22, 2013 at 8:19 am</a>		</div>

		<p>So C#/.NET is good enough for X-Box games and Exchange Server and SQL Server stored procedures but now it is no good for&#8230; an I/O-driven file browser?</p>
<p>C# is the cat&#39;s whiskers even for people who mastered C/C++, and this whole internal Microsoft religious war against managed code is sending your developers and my peers to iOS in veiled anger (WinRT, anyone? no takers? /sadtrombone). Nobody likes being told what to do against what the technology makes possible, and consequently they won&#39;t be. There&#39;s a reason my favorite software company now has HALF of Apple&#39;s revenues, and it needs tough love&#8230;quick.</p>
<div class="post">[<em>The difference is that your XBox game runs in its own process. Exchange Server and SQL Server run in their own process. In all these cases, the host process is in on the trick. But shell extensions are potentially injected into <span style="text-decoration:underline;">foreign</span> processes. That&#39;s the main difference. One is a controlled environment; the other is not. If you could convince every app developer to say it&#39;s okay to load the CLR into their process, then it would be okay to load the CLR into every process. The XBox, Exchange Server, and SQL Server teams say it&#39;s okay to do that to their process. Contoso Music Designer, haven&#39;t heard back. This is an engineering decision, not a marketing decision. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040963">
				<div id="div-comment-1040963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1040963">
			February 22, 2013 at 8:39 am</a>		</div>

		<p>different tools for different tasks. &nbsp;I understand that it would be convenient to use managed code for in-process shell extensions, but that does not make it the right choice.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1040973">
				<div id="div-comment-1040973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1040973">
			February 22, 2013 at 8:43 am</a>		</div>

		<p>[If you could convince every app developer to say it&#39;s okay to load the CLR into their process, then it would be okay to load the CLR into every process.]</p>
<p>And you&#39;re guaranteed that at least one says no. Loading just about anything into a Cygwin process that wasn&#39;t loaded by Cygwin -&gt; your software makes the BLODA list. COM load on the file dialog works only if COM free works correctly and the DLL is unloaded.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1040983">
				<div id="div-comment-1040983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1040983">
			February 22, 2013 at 9:44 am</a>		</div>

		<p>&quot;that there are various part of COM interop in the .NET Framework that are not suitable for use in an extension model designed around native code&quot;</p>
<p>too bad the Visual Studio SDK team is unaware of that :-) It&#39;s indeed a horrible spaghetti between native and managed code, and it crashes too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041013">
				<div id="div-comment-1041013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041013">
			February 22, 2013 at 12:33 pm</a>		</div>

		<p>For what it&#39;s worth, Android doesn&#39;t use a Java runtime, it has its own bytecode and VM, even though the apps are mostly written in the Java language.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-1040953">
				<div id="div-comment-1040953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1040953">
			February 22, 2013 at 8:32 am</a>		</div>

		<p>[ So C#/.NET is good enough for X-Box games and Exchange Server and SQL Server stored procedures but now it is no good for&#8230; an I/O-driven file browser? ]</p>
<p>The problema is that C#/.NET has great performance *after it starts*, but you have a big runtime to load the first time, and, if the &quot;reasonable expectation&quot; for the action is to have a quick response (like, as before, a right click on the desktop) the delay is not affordable from an UX standpoint.</p>
<p>That&#39;s the same story as Java applications: Android apps run smoothly on my 650 MHz phone (where the JVM is among the first things to start after the kernel), but a Java applet takes ages to load on my 3,2 GHz x 4 PC.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041053">
				<div id="div-comment-1041053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Extendo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041053">
			February 22, 2013 at 5:58 pm</a>		</div>

		<p>Well darn, I was just about to try making an IE extension in C# :(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041063">
				<div id="div-comment-1041063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">EduardoS</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041063">
			February 22, 2013 at 6:12 pm</a>		</div>

		<p>Hum&#8230; It seens the war only will be over when the .Net runtime becomes part of the kernel and already loaded once every apps loads&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041073">
				<div id="div-comment-1041073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041073">
			February 22, 2013 at 9:02 pm</a>		</div>

		<p>@Joshua: fascinating, I&#39;d never heard of BLODA. &nbsp;The first app on the list should, methinks, be Cygwin itself; in most cases, from the looks of it, the problem only occurs because of Cygwin&#39;s use of unsupported native calls and improper memory mapping requirements. &nbsp;Nowadays a VM-based approach would seem far more sensible, but I don&#39;t suppose that was practical back when Cygwin first appeared.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-1041083">
				<div id="div-comment-1041083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041083">
			February 23, 2013 at 7:13 am</a>		</div>

		<p>The sad thing is that there would be no need of all those hacks built over the Win32 API since NT supported the idea of a &quot;POSIX personality&quot; from the beginning; it&#39;s a pity that Interix/SUA/however it&#39;s called now is included only in higher-end SKUs. I doubt Microsoft is actually making much money from it (which is confirmed by the fact that on Windows 8 it&#39;s being deprecated), so giving it away for free on any Windows edition &quot;without warranties of any kind&quot; shouldn&#39;t be such a problem.</p>
<p>Actually, given that it&#39;s not deemed &quot;strategic&quot; anymore (again, it&#39;s deprecated on Windows 8) they could just release the sources and let anyone interested take care of it, but honestly I don&#39;t really see that happening.</p>
<div class="post">[<em>The phrase &quot;without warranties of any kind&quot; <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/06/24/10029321.aspx" rel="nofollow">never stopped a customer from asking for support</a>. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-1041093">
				<div id="div-comment-1041093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041093">
			February 23, 2013 at 8:12 am</a>		</div>

		<p>[The phrase &quot;without warranties of any kind&quot; never stopped a customer from asking for support. -Raymond]</p>
<p>On the other hand, people actually asking for support to Microsoft are those who are likely to have the higher-end SKUs that already provide SUA; we &quot;lower end SKU, OEM edition&quot; peones don&#39;t have any right to bother the official support (unless maybe keeping the credit card ready), so that&#39;s not really a serious concern.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041103">
				<div id="div-comment-1041103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041103">
			February 23, 2013 at 11:25 am</a>		</div>

		<p>@Harry Johnston Here fundamentally is the problem:</p>
<p>There is no way in practice (and perhaps in principle) for Cygwin to accomplish its fundamental goal without the very set of assumptions about memory model it has. These assumptions were in fact TRUE on all versions of Windows in existence in which it was created.</p>
<p>VM is useless here as it is the bridging technology. All other attempts have failed due to lack of maintenance. It would appear as though Cygwin, having beaten all opponents, is now threatened by its own success as Microsoft sees the loss of their implementation without the reason and so thinks there is no market.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041113">
				<div id="div-comment-1041113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Smit-Tay</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041113">
			February 23, 2013 at 6:02 pm</a>		</div>

		<p>L O O K !</p>
<p>&nbsp; &nbsp; You know you&#39;re in trouble as soon as you have to decipher the phrase &quot;in-process side-by-side runtimes&quot;</p>
<p>The whole issue is complete idiocy, and manifests, side-by-side, and what-ever only make it worse. &nbsp;The senior developers at Microsoft must hate this stuff, being from the good old days when one wrote a single executable image, and ran it. &nbsp;</p>
<p>Anyone who has fought with the inane rules Microsoft has contrived in their attempt to mitigate &quot;DLL hell&quot; without actually solving &quot;DLL hell&quot; will know that this stuff just makes life harder for devs, and support people, and usually also the end user.</p>
<p>Heaven forbid MS adopts the *NIX method, but no, pedantry beats simplicity any day at Microsoft.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041133">
				<div id="div-comment-1041133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041133">
			February 24, 2013 at 7:30 am</a>		</div>

		<p>It&#39;s how many years that .NET exists as M$ response to Java? Quite a few. And is Still Under eXpectations. Maybe it&#39;s time to either ditch it or make it right. Because everytime I need to write something fast I have to revert to unmanaged code. The only thing in my C# that is managed is the GUI and petite implementations of &quot;here, let&#39;s press this button to show a message&quot;. All else that requires speed is unmanaged.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041153">
				<div id="div-comment-1041153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041153">
			February 24, 2013 at 9:41 am</a>		</div>

		<p>@Danny &quot;everytime I need to write something fast I have to revert to unmanaged code&quot;</p>
<p>What code are you writing that is slower in C#/Java compared to native? C# and Java can be just as fast or faster because the JIT compiler can make optimizations that a C++ compiled program cannot because it can query the machine. It can determine if the machine is Intel or AMD; Pentium 4, Core Solo, or Core Duo; or if supports SSE4, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041173">
				<div id="div-comment-1041173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Ching</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041173">
			February 24, 2013 at 11:09 am</a>		</div>

		<p>What would it take to rewrite Explorer in C# and support real .NET add-ins? &nbsp;If the Windows team would be forced to eat .NET dogfood, they would do what was necessary to mitigate the negatives. Similar to how the Visual Studio team finally ate WPF dogfood and fixed the fuzzy font problem for VS2010.</p>
<div class="post">[<em>Oh, you mean Windows Longhorn? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-1041183">
				<div id="div-comment-1041183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041183">
			February 24, 2013 at 2:10 pm</a>		</div>

		<p>@Ian Boyd: I&#39;m not saying that managed code is slow (it isn&#39;t), but that&#39;s just the theory&#8230; the reality is that the JIT compiler can exploit machine-specific tricks, but won&#39;t do &quot;expensive&quot; optimizations because the JITter must keep a balance between &quot;clever&quot; optimization techniques and speed of execution (you can find many examples of this fact on StackOverflow, it&#39;s not uncommon to find questions about suboptimal JIT-generated assembly).</p>
<p>A &quot;traditional&quot; compiler has to target &quot;generic&quot; CPUs (unless you explicitly tell differently &#8211; e.g. -march=native on gcc), but can take all the time/memory it wants to analyze the AST and perform complex optimizations; also, the standards for languages like C and C++ often give more opportunities to optimize with wide openings to undefined behavior (not that it&#39;s always a good thing).</p>
<p>By the way, I read somewhere (maybe SO again) that not even ngen (that isn&#39;t time/memory-constrained like the JIT) performs heavy optimization, to avoid different behavior/bugs between running an assembly &quot;normally&quot; and running the NGEN-ed version.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo even thread-even depth-1" id="comment-1041193">
				<div id="div-comment-1041193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041193">
			February 24, 2013 at 2:20 pm</a>		</div>

		<p>@David Ching: I suppose that it would be quite a pain; you&#39;d make .NET add-ins first-class citizens, but I strongly suspect that it would break a lot of native shell extensions (heck, they break even if the current code is changed a tiny bit, go figure what would happened in a total rewrite in a managed language!); I don&#39;t even know if all the COM shell interfaces could be reimplemented in .NET without jumping through hoops. But most importantly, rewriting the shell in .NET would mean injecting the CLR in every process that makes use of the relevant shell facilities (e.g. the open file dialog), which is exactly what Raymond described as a bad idea.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041203">
				<div id="div-comment-1041203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jolyon.smith_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jolyon.smith@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041203">
			February 24, 2013 at 4:31 pm</a>		</div>

		<p>@Ian Boyd: &nbsp;You just quoted the theoretical reasons why managed code is faster. &nbsp;In practice, very few if any of those JIT optimizations are realistically possible and, also in practice, many of the theoretical optimizations defeat superior optimizations that may be obtained from static analysis. &nbsp;Even if all those optimizations were possible and did actually take place, the other problem that you have to take into account is that much of the supposed performance benefit of managed code comes not from less or more efficient code, but simply deferred inefficiency. &nbsp;That is, the process of returning memory to the system is shelved until your process is not busy doing other things.</p>
<p>That&#39;s great, right up to the point that your system (as a whole or just your process) becomes memory constrained, at which point performance in your managed code then tanks as all that housekeeping work HAS to happen RIGHT NOW, and the business of work that your process wants to get on with just has to wait.</p>
<p>So yes, managed code can be faster, but it might also run into a performance wall. &nbsp;If you need RELIABLY FAST then taking ownership of the housekeeping is the only way to ensure that ALL aspects of your code are performed optimally, not just the &quot;fun stuff&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041143">
				<div id="div-comment-1041143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041143">
			February 24, 2013 at 9:32 am</a>		</div>

		<p>There&#39;s a popular archiving program that adds context menu items, and icons, to &quot;All&quot; files and folders. i know that every time i right-click a file, this shell extension is triggering a page-fault to go load the icons, and analyzing the file selection to decide which menu items should appear.</p>
<p>i always reconfigure the *extraordinarily common* shell extension, on any computer or server i use, to &quot;cascade&quot; the menu items to a sub-item, and to disable adding icons to the context menu items.</p>
<p>Explorer is a high-traffic area, that needs more careful thought before applications simply add things in.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041213">
				<div id="div-comment-1041213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041213">
			February 24, 2013 at 9:03 pm</a>		</div>

		<p>@Joshua: I see no reason (either in principle or in practice!) why Cygwin couldn&#39;t solve its problems by running the Unixy processes inside a VM, other than the fact that to do so at this point would involve rewriting the entire thing (and would probably break binary compatibility into the bargain).</p>
<p>If anyone cared enough to build a more reliable solution from scratch, I think that would be the way to go.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041303">
				<div id="div-comment-1041303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Ching</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041303">
			February 25, 2013 at 10:01 am</a>		</div>

		<p>@Raymond: &nbsp;Longhorn did indeed have perf issues, but what of Win Phone 7 and Android, whose app model is based on code running in a VM? &nbsp;Why do they not have perf issues?</p>
<div class="post">[<em>You&#39;re assuming that perf was the only issue. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041323">
				<div id="div-comment-1041323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">LonghornIssues</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041323">
			February 25, 2013 at 10:26 am</a>		</div>

		<p>As David Ching, I thought that the main issue of Longhorn was the perf one. So, what were the other issues? Thanks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041373">
				<div id="div-comment-1041373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041373">
			February 25, 2013 at 2:36 pm</a>		</div>

		<p>As you are probably aware, Raymond does not discuss products that aren&#39;t released in any way in which they can be identified.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-1041223">
				<div id="div-comment-1041223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041223">
			February 25, 2013 at 6:46 am</a>		</div>

		<p>@Harry: if anyone cared enough to build a more reliable solution from scratch I don&#39;t see why there would be a need to add the overhead of a VM and a virtualized kernel &#8211; as said above, the NT kernel already supports the &quot;personalities&quot; concept, and a POSIX subsystem has already been written and is being used (so, it *can* be done), so *that* would be the &quot;clean&quot; solution. On the other hand, I don&#39;t know how many people actually have the knowledge to write an NT POSIX subsystem from scratch&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041443">
				<div id="div-comment-1041443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041443">
			February 26, 2013 at 12:52 am</a>		</div>

		<p>Since Cygwin originally supported Win9x/ME, it couldn&#39;t have relied on the NT kernel subsystems. Any by the time 9x/ME support was dropped, it was way too late to change that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041523">
				<div id="div-comment-1041523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041523">
			February 26, 2013 at 7:55 am</a>		</div>

		<p>Based on the fact that there was a Windows XP embedded and a Windows 7 embedded, but no Vista/longhorn embedded, and vague statements by some developers on the embedded team, I&#39;ve surmised that the internals of Vista were such an intertwined mess that it couldn&#39;t be componentized. I also suspect there were WDDM issues to be ironed out. That said, Vista was much better than it&#39;s reputation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041533">
				<div id="div-comment-1041533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rick C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041533">
			February 26, 2013 at 8:00 am</a>		</div>

		<p>@LonghornIssues, it&#39;s right there in Raymond&#39;s first link.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041643">
				<div id="div-comment-1041643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">LonghornIssues</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041643">
			February 26, 2013 at 10:51 am</a>		</div>

		<p>@Rick C: Please be more specific. Raymond&#39;s first link is about side by side CLRs: that&#39;s now fixed with .NET 4. I was asking about non-perf issues in Longhorn (because David Ching&#39;s point seemed valid to me). Please clarify.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041683">
				<div id="div-comment-1041683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041683">
			February 26, 2013 at 1:15 pm</a>		</div>

		<p>@Matteo: I thought only Microsoft could write NT subsystems? &nbsp;At any rate, I can&#39;t find any documentation on MSDN.</p>
<p>VM software isn&#39;t all that big, and Cygwin isn&#39;t exactly slender, so I don&#39;t think the overhead would be all that much of a problem. &nbsp;Platform fragmentation might be, though, since you&#39;d have to support systems that have Hyper-V running as well as systems that don&#39;t. &nbsp;(Can you install something like VirtualBox side-by-side with Hyper-V, I wonder?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-matteo odd alt thread-odd thread-alt depth-1" id="comment-1041703">
				<div id="div-comment-1041703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Matteo+Italia' rel='external nofollow' class='url'>Matteo Italia</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041703">
			February 26, 2013 at 1:40 pm</a>		</div>

		<p>@Harry: I too thought only Microsoft could write Windows NT, but the ReactOS guys managed to reverse-engineer a good part of it. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041813">
				<div id="div-comment-1041813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041813">
			February 27, 2013 at 12:57 am</a>		</div>

		<p>@Harry: if Hyper-V role is installed, no other virtualization program that relies on hardware virtualization will work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041883">
				<div id="div-comment-1041883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041883">
			February 27, 2013 at 5:13 am</a>		</div>

		<p>Cygwin is proposedly not a subsystem, it&#39;s based on Win32. That&#39;s why its fork() sucks so much, among other things. But hey, if you&#39;re using Cygwin for production, You&#39;re Asking For Itâ„¢.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041943">
				<div id="div-comment-1041943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1041943">
			February 27, 2013 at 8:46 am</a>		</div>

		<p>@John Doe: No choice. It&#39;s the only to get a working sshd on Windows.</p>
<p>Short comment is short.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-1042363">
				<div id="div-comment-1042363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130222-01/?p=5163#comment-1042363">
			February 28, 2013 at 10:33 am</a>		</div>

		<p>LonghornIssues: *Dependencies* were the problem. .NET Framework 2.0 could not stabilize because WinFS and SQLCLR were pulling it in two different directions and WPF was pulling it a third. Each time something changed it broke all the user scenarios built on top of WPF. It pushed out the release schedule for VS 2005, SQL Server 2005, Exchange 2007 (which was supposed to have a SQL Server back end &#8211; still doesn&#39;t in 2013), Windows &#39;Longhorn&#39; (client and server). Eventually Jim Allchin cried &#39;enough&#39; and WPF was pulled from .NET 2.0, WinFS was killed, and Windows Vista rebooted to not use any managed code.</p>
<p>It&#39;s very clear that Windows Runtime is such a minimal API because they have tried to avoid this problem: the runtime&#39;s feature set was locked about three years ago, so that apps could be built on it without the shifting-sands problem. Lack of updates to the in-box Windows Store apps are likely to be because the runtime is now in flux again for the next release, and the app teams are now working toward their next releases on top of that, not on Windows Runtime 1.0. You&#39;ll still notice many areas of Windows 8 where you get booted out of the &#39;modern&#39; environment into the desktop, even for some apparently straightforward configuration tasks. Why? Because there wasn&#39;t enough time to do that on top of Windows Runtime as well as everything else.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

