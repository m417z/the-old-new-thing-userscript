<html>
<head>
<title>What is this rogue version 1.0 of the HTML clipboard format?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>What is this rogue version 1.0 of the HTML clipboard format?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 18, 2013 / year-entry #16</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">At least as of the time this article was originally written, the HTML clipboard format is officially at version 0.9. A customer observed that sometimes they received HTML clipboard data that marked itself as version 1.0 and wanted to know where they could find documentation on that version. As far as I can tell, there...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>At least as of the time this article was originally written, <a href="http://msdn.microsoft.com/library/aa767917"> the HTML clipboard format</a> is officially at version 0.9. A customer observed that sometimes they received  HTML clipboard data that marked itself as version 1.0 and wanted to know where they could find documentation on that version.</p>
<p> As far as I can tell, there is no official version 1.0 of the HTML clipboard format. </p>
<p> I hunted around, and the source of the rogue version 1.0 format appears to be <a href="http://wpf.codeplex.com/releases/view/40535"> the WPF Toolkit</a>. Version 1.0 has been the version used by <code>ClipboardHelper.cs</code> <a href="http://wpf.codeplex.com/SourceControl/changeset/15250"> since its initial commit</a>. </p>
<p> If you read the code, it appears that they are not generating HTML clipboard data that uses any features beyond version 0.9, so the initial impression is that it's just somebody who jumped the gun and set their version number higher than they should have. The preliminary analysis says that you can treat version 1.0 the same as version 0.9. </p>
<p> But that's merely the preliminary analysis. </p>
<p> A closer look at the <code>Get&shy;Clipboard&shy;Content&shy;For&shy;Html</code> function shows that it generated the HTML content incorrectly. The code treats the fragment start and end offsets as character offsets, not byte offsets. But the offsets are explicitly documented as in bytes. </p>
<blockquote class="q"><table border="1" style="border-collapse: collapse; border: solid 1px black" cellpadding="5">
<tr>
<td>StartFragment</td>
<td>Byte count from the beginning of the clipboard         to the start of the fragment.     </td>
</tr>
<tr>
<td>EndFragment</td>
<td>Byte count from the beginning of the clipboard         to the end of the fragment.     </td>
</tr>
</table>
</blockquote>
<p> My guess is that the author of that helper function made two mistakes that partially offset each other. </p>
<ol>
<li>The author failed     to take into account that C# operates in Unicode,     whereas the HTML clipboard format operates in UTF-8.     The byte offset specified in the HTML format header is     the byte count in the UTF-8 encoding, not the byte     count in the UTF-16 encoding used by C#. </li>
<li>The author did all their testing with ASCII strings.     UTF-8 has the property that ASCII encodes to itself,     so one byte equals one character.     If they had tested with a non-ASCII character,     they would have seen the importance of the byte count.     (Or maybe they simply would have gotten <i>more confused</i>.) </li>
</ol>
<p> Now, WPF knows that the <code>Data&shy;Formats.<wbr>HTML</wbr></code> clipboard format is encoded in UTF-8, so when you pass a C# string to be placed on the clipboard as HTML, it knows to convert the string to UTF-8 before putting it on the clipboard. But it doesn't know to convert the offsets you provided in the HTML fragment itself. As a result, the values encoded in the offsets end up too small if the text contains non-ASCII characters. (You can see this by copying text containing non-ASCII characters from the DataGrid control, then pasting into Word. Result: Truncated text, possibly truncated to nothing depending on the nature of the text.) </p>
<p> There are two other errors in the <code>Get&shy;Clipboard&shy;Content&shy;For&shy;Html</code> function: Although the code attempts to follow the recommendation of the specification by placing a <code>&lt;!--EndFragment--&gt;</code> marker after the fragment, they erroneously insert a <code>\r\n</code> in between. Furthermore, the EndHTML value is off by two. (It should be <code>DATA&shy;GRID&shy;VIEW_<wbr>html&shy;End&shy;Fragment.<wbr>Length</wbr></wbr></code>, which is 38, not 36.) </p>
<p> Okay, now that we see the full situation, it becomes clear that at least five things need to happen. </p>
<p> The immediate concern is what an application should do when it sees a rogue version 1.0. One approach is to exactly undo the errors in the WPF Toolkit: Treat the offsets as character offsets (after converting from UTF-8 to UTF-16) rather than byte offsets. This would address the direct problem of the WPF Toolkit, but it is also far too aggressive, because there may be another application which accidentally marked its HTML clipboard data as version 1.0 but which does not contain the exact same bug as the WPF Toolkit. Instead, applications which see a version number of 1.0 should treat the EndHTML, EndFragment, and EndSelection offsets as untrustworthy. The application should verify that the EndFragment lines up with the <code>&lt;!--EndFragment--&gt;</code> marker. If it does not, then ignore the specified value for EndFragment and infer the correct offset to the fragment end by searching for the last occurrence of the <code>&lt;!--EndFragment--&gt;</code> marker in the clipboard data, but trim off the spurious <code>\r\n</code> that the WPF Toolkit erroneously inserted, if present. Similarly, EndHTML should line up with the end of the <code>&lt;/HTML&gt;</code> tag; if not, the specified offset should be ignored and the correct value inferred. Fortunately, the WPF Toolkit does not use EndSelection, so there is no need to attempt to repair that value, and it does not use multiple fragments, so only one fragment repair is necessary. </p>
<p> Welcome to the world of application compatibility, where you have to accommodate the mistakes of others. </p>
<p> Some readers of this Web site would suggest that the correct course of action for your application is to detect version 1.0 and put up an error message saying, "The HTML on the clipboard was placed there by a buggy application. Contact the vendor of that application and tell them to fix their bug. Until then, I will refuse to paste the data you copied. Don't blame me! I did nothing wrong!" Good luck with that. </p>
<p> Second, the authors of the WPF Toolkit should fix their bug so that they encode the offsets correctly in their HTML clipboard format. </p>
<p> Third, at the same time they fix their bug, they should switch their reported version number back to 0.9, so as to say, "Okay, everybody, this is the not-buggy version. No workaround needed any more." If they leave it as 1.0, then applications which took the more aggressive workaround will end up double-correcting. </p>
<p> Fourth, the maintainers of the HTML clipboard format may want to document the rogue version 1.0 clipboard format and provide recommendations to applications (like I just did) as to what they should do when they encounter it. </p>
<p> Fifth, the maintainers of the HTML clipboard format must not use version 1.0 as the version number for any future revision of the HTML clipboard format. If they make another version, they need to call it 0.99 or 1.01 or something different from 1.0. Version 1.0 is now tainted.  It's the version number that proclaims, "I am buggy!" </p>
<p> At first, we thought that all we found was a typo in an open-source helper library, but digging deeper and deeper revealed that it was actually a symptom of a much deeper problem that has now turned into an industry-wide five-pronged plan for remediation. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1033783">
				<div id="div-comment-1033783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033783">
			January 18, 2013 at 7:09 am</a>		</div>

		<p>This is kind of a fortunate situation, right? &nbsp;I mean, what if they hadn&#39;t messed up the version number as well?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033793">
				<div id="div-comment-1033793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eitan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033793">
			January 18, 2013 at 7:15 am</a>		</div>

		<p>What do you mean by &quot;C# operates in Unicode, whereas the HTML clipboard format operates in UTF-8.&quot; vs UTF-8? &nbsp;UTF-8 is an encoding of Unicode code points.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1033803">
				<div id="div-comment-1033803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eitan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033803">
			January 18, 2013 at 7:16 am</a>		</div>

		<p>What do you mean by &quot;C# operates in Unicode, whereas the HTML clipboard format operates in UTF-8.&quot;? &nbsp;UTF-8 is an encoding of Unicode code points.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033813">
				<div id="div-comment-1033813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Eitan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033813">
			January 18, 2013 at 7:22 am</a>		</div>

		<p>&quot;C# operates in UTF-16LE whereas the HTML clipboard format operates in UTF-8.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1033823">
				<div id="div-comment-1033823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033823">
			January 18, 2013 at 7:22 am</a>		</div>

		<p>He means Microsoft&#39;s OS native UNICODE, which is UTF-16, which he also mentions a few times.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033833">
				<div id="div-comment-1033833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033833">
			January 18, 2013 at 7:25 am</a>		</div>

		<p>@Eitan: Generally when Microsoft people are speaking informally, Unicode means UTF-16 (or, historically, UCS-2). Since Raymond works with Win32 almost exclusively, that&#39;s where he&#39;s coming from.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1033843">
				<div id="div-comment-1033843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Barbie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033843">
			January 18, 2013 at 7:27 am</a>		</div>

		<p>@Eitan: welcome to Raymond&#39;s blog. As old timers will tell you, Unicode, within the world of Windows as an encoding, means the encoding that Windows uses internally for Unicode strings. That&#39;s UTF16.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033853">
				<div id="div-comment-1033853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">derpisch</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033853">
			January 18, 2013 at 7:29 am</a>		</div>

		<p>@Eitan: MSDN considers &#39;Unicode&#39; (the character set) to be synonymous with UTF-16 (the character encoding).</p>
<p>Unfortunately UTF-8 came about after the initial Windows Unicode support.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1033863">
				<div id="div-comment-1033863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033863">
			January 18, 2013 at 7:50 am</a>		</div>

		<p>@John then you would simply check for the misaligned ending offsets for ALL HTML 0.9 clipboard data, not just 1.0.</p>
<p>I&#39;m surprised Raymond didn&#39;t point out that simply throwing up an error dialog on HTML 1.0 content would be a bad idea, especially since the user may notice a competitor&#39;s program seems to have no problems with WPF Toolkit HTML clipboard data (and if enough users run into the problem your compentitor may intentionally get WPF Toolkit clipboard data working in their app and tout it as a feature that your app doesn&#39;t have!). &nbsp;Now your app looks buggy and you look incompetent in the eyes of the user.</p>
<p>Then again he did sort of build a strawman there; knock it down and you have a complete strawman argument.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033883">
				<div id="div-comment-1033883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033883">
			January 18, 2013 at 8:27 am</a>		</div>

		<p>Lovely.</p>
<p>You wouldn&#39;t believe how many data formats exist that the writing software is supposed to write its name &amp; version when writing the format data.</p>
<p>This does tend to make fixing somebody else&#39;s bugs somewhat easier.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1033893">
				<div id="div-comment-1033893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken White</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033893">
			January 18, 2013 at 8:35 am</a>		</div>

		<p>@TheMAZZTer: Raymond did point out that you shouldn&#39;t just throw up a dialog. Read the paragraph starting with &quot;Some readers of this Web site&quot;.</p>
<div class="post">[<em>I didn&#39;t say that you should or shouldn&#39;t. I&#39;m just saying that some people would argue that a dialog is the correct behavior, and I wished those people good luck. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033903">
				<div id="div-comment-1033903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033903">
			January 18, 2013 at 9:15 am</a>		</div>

		<p>That&#39;s nice advice an all that, but I&#39;ll just keep doing what I&#39;ve always done when I encountered an unsupported version: just paste plain text.</p>
<p>The alternative seems a lot of cruft to code, vet and maintain, for something that&#39;s going to be fixed anyway. Maybe if I had to deal with conmen competitors like described above I could make a case for it, but at present, I can&#39;t.</p>
<div class="post">[<em>Given that the problem has existed for over four years, I wouldn&#39;t be so sure about the &quot;going to be fixed anyway.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1033913">
				<div id="div-comment-1033913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033913">
			January 18, 2013 at 9:41 am</a>		</div>

		<p>Suggestion for the maintainers of the HTML clipboard format spec.: in addition to a CF_HTML version, allow an implementation to specify its own name and version (e.g., Source:Windows Presentation Foundation/1.0) which allows clients to make implementation-specific hacks instead of standard-version-specific hacks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033933">
				<div id="div-comment-1033933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033933">
			January 18, 2013 at 10:55 am</a>		</div>

		<p>@The MAZZTer: &nbsp;Since 0.9 is (apparently) the initial version, that would require ALWAYS validating the data which is why using a non-existent version is sort of lucky. &nbsp;On the other hand, if it&#39;s so easy to mess up that an official toolkit released by Microsoft is broken for years then I imagine there are many other buggy implementations out there so you should probably always validate it anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1033953">
				<div id="div-comment-1033953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andreas Rejbrand</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033953">
			January 18, 2013 at 2:13 pm</a>		</div>

		<p>Hm&#8230; Like so many things I know and love (in particular, the GDI), this topic is referred to as a &#39;Legacy API&#39; by the MSDN.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033963">
				<div id="div-comment-1033963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033963">
			January 18, 2013 at 4:20 pm</a>		</div>

		<p>[Given that the problem has existed for over four years, I wouldn&#39;t be so sure about the &quot;going to be fixed anyway.&quot; -Raymond]</p>
<p>By which we also know that Raymond has no intention of submitting a patch (not that he has any obligation to). Meh. If I used it I&#39;d submit a patch based on this, but I don&#39;t so I won&#39;t either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-1033973">
				<div id="div-comment-1033973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033973">
			January 18, 2013 at 5:26 pm</a>		</div>

		<p>I think any application that supports HTML clipboard format should support TEXT as well, so the course I&#39;d have chosen would be to request the clipboard data in TEXT instead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1033983">
				<div id="div-comment-1033983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Smitty</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033983">
			January 19, 2013 at 2:43 am</a>		</div>

		<p>&quot;byte count in the UTF-8 encoding, not the byte count in the UTF-16 encoding&quot;</p>
<p>Surely the byte count is independent of which encoding is used. if I have a string in UTF-8 that is 8 bytes long that could be anything from 2 to 8 characters, but it&#39;s still 8 bytes. &nbsp;Similarly a 8 byte UTF-16 character string is between 2 and 4 characters long (if I&#39;ve done my math right), but it&#39;s still 8 bytes.</p>
<p>Still, it&#39;s always refreshing to read more idiocy associated with clipboard formats. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1033993">
				<div id="div-comment-1033993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1033993">
			January 19, 2013 at 3:19 am</a>		</div>

		<p>&quot;byte count in the UTF-16 encoding&quot;</p>
<p>Don&#39;t you mean the code point count in the UTF-16 encoding, which would be the same for ASCII as the byte count in UTF-8 encoding?</p>
<p>Would an alternative be to validate the counts as UTF-16 code points before trying to interpret them as UTF-8 byte counts?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034003">
				<div id="div-comment-1034003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034003">
			January 19, 2013 at 3:22 am</a>		</div>

		<p>Sorry, I mean UTF-16 code units of course.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1034013">
				<div id="div-comment-1034013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Smitty</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034013">
			January 19, 2013 at 9:30 am</a>		</div>

		<p>&quot;Surely the byte count is independent of which encoding is used.&quot; What a strange statements. The byte length of the binary representation (encoding) of a given string for sure depends on the encoding. If the encoding is UTF-32 then &quot;A&quot; will have a byte count of 4, but in UTF-8, &quot;A&quot; will have a byte count of 1.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034043">
				<div id="div-comment-1034043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034043">
			January 20, 2013 at 3:56 pm</a>		</div>

		<p>I only copy/paste latin letters. Unicode support in WPF is generally lacking.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1034063">
				<div id="div-comment-1034063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jolyon.smith_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jolyon.smith@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034063">
			January 20, 2013 at 4:09 pm</a>		</div>

		<p>@@Smitty</p>
<p>What Smitty means is that 8 bytes is 8 bytes, and a byte offset into any number of bytes is still a byte offset into those bytes. &nbsp;What is IN any given 8 bytes doesn&#39;t alter that fact that 8 bytes is what it is. &nbsp;Where the encoding matters is when what you have encoded in those 8 bytes DEcodes to a sequence of data points where the number of data points stored may vary according to the encoding.</p>
<p>8 bytes of UTF8 might be 2 Unicode &quot;characters&quot;, or it might be 3, 4 or as many as 8.</p>
<p>8 bytes of UTF16 might be 4 Unicode &quot;characters&quot;, or it might be 2 or 3.</p>
<p>But 8 bytes of UTF8 is 8 bytes.</p>
<p>And 8 bytes of UTF16 is 8 bytes.</p>
<p>It is akin to the &quot;Which is heavier: &nbsp;A ton of feathers or a ton of bricks ?&quot; type question.</p>
<p>What got you confused was that you started thinking in terms of &quot;8 characters&quot;, for which the length of the encoding in UTF8 vs UTF16 will of course vary, and if an offset is specified in characters then the actual BYTE offset into any given encoding will vary according to that encoding.</p>
<p>But that isn&#39;t what Raymond said &#8211; he wrote (in the sentence that Smitty references) entirely in terms of bytes. &nbsp;That is: grams/kilograms, not numbers of feathers or bricks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034073">
				<div id="div-comment-1034073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel15</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034073">
			January 20, 2013 at 6:51 pm</a>		</div>

		<p>Did you report this to the WPF team?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1034083">
				<div id="div-comment-1034083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034083">
			January 20, 2013 at 7:28 pm</a>		</div>

		<p>Joylon, I&#39;m trying to understand what you wrote, but I can&#39;t. &nbsp;Raymond&#39;s sentence is correct as written, but I can&#39;t tell if you agree or not.</p>
<p>Here is an example of some text that I want to put on the clipboard using offsets:</p>
<p>&quot;I want to copy just *this* text&quot;.</p>
<p>If you are giving the offsets so that you only are copying &quot;*this*&quot;, then the character offset to the start is 20 and the end is 25, which are 40 and 50 bytes in C# Unicode. &nbsp;When that text is converted to UTF-8, the byte offsets of the desired text are 20 and 25. &nbsp;However, since the code specified 40 to 50 bytes, it is now the wrong text (and in this case, off the end of the string).</p>
<p>Therefore: The byte offset specified in the HTML format header is the byte count **to the desired text** in the UTF-8 encoding, not the byte count **to the desired text** in the UTF-16 encoding used by C#.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034103">
				<div id="div-comment-1034103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henderson101</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034103">
			January 21, 2013 at 3:29 am</a>		</div>

		<p>Silly question &#8211; when using this in C# with WPF, what actually happens? I mean &#8211; does it work as intended, or does it fail to yield correct results? I only ask (having never used the functionality) because I have no idea what the WPF CLR side code is doing. Is it possible if uses some kind of shim or other correction to make thing &quot;right&quot;? Is it possible that the issue is &quot;everyone else&quot;, and the WPF code just works? (We obviously assume everything Raymond says is true, and the WPF code is wrong, even if it does work for WPF based apps.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1034123">
				<div id="div-comment-1034123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034123">
			January 21, 2013 at 7:12 am</a>		</div>

		<p>@Andreas Rejbrand: &nbsp;&quot;Hm&#8230; Like so many things I know and love (in particular, the GDI), this topic is referred to as a &#39;Legacy API&#39; by the MSDN.&quot;</p>
<p>Indeed&#8230; and many other APIs too &#8211; core painting desktop APIs and messages for which there is no replacement that I&#39;m aware of. &nbsp;For example: WM_PAINT, UpdateWindow, RedrawWindow, InvalidateRect. &nbsp;These are &quot;Legacy Graphics &#8211; Technologies that are obsolete and should not be used in new applications.&quot; &nbsp;What are the Microsoft-recommended API replacements? &nbsp;Direct2D looks like an option, except that the new Direct2D still has dependencies on these legacy APIs that &quot;should not be used in new applications.&quot; &nbsp;Direct2D example on MSDN uses: <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd370994(v=vs.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/dd370994(v=vs.85).aspx</a> &#8211; this modern example still uses the following legacy APIs: UpdateWindow, WM_DISPLAYCHANGE, WM_PAINT. &nbsp;How should we rewrite our apps to avoid these legacy APIs?</p>
<p>What about OpenGL, which is completely marked as legacy? &nbsp;It&#39;s the only 3D graphics API used for cross-platform development that I know of, and isn&#39;t obsolete outside of Microsoft.</p>
<p>What about multiple monitors? &nbsp;The entirety of the multiple monitor API has been designated as legacy, with no recommended replacement API that I could find. &nbsp;Should I just conclude that multi-tasking with overlapping windows in general is legacy, since WM_PAINT is legacy and multiple monitors is legacy, with no replacements? &nbsp;This worries me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034093">
				<div id="div-comment-1034093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wei</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034093">
			January 20, 2013 at 11:54 pm</a>		</div>

		<p>I think it is the explanation of the two mistake that throws most people off.</p>
<p>Most likely Get­Clipboard­Content­For­Html author treads character as byte count.</p>
<p>so when you go in with the ASCII format testing, byte = character, but when coming from UTF-16, the byte count might be anywhere from 2~4bytes/character.</p>
<p>I have no idea what is the error that Get­Clipboard­Content­For­Html is giving out. My wild guess is that the function can only handles ASCII.</p>
<p>So the code loop try to get a string using StartFragment and EndFragment might look like</p>
<p>for(char count = StartFragment ; count &lt; EndFragment ;count++)</p>
<p>*ptr_result++ = *(ptr_OriginalString + count);</p>
<p>that is simple but can only handle ASCII characters.</p>
<p>however, if each character is in variable length, count increment must be handled on each iteration, some more code which loop through *(ptr_OriginalString + count) must added in to the body of the for loop</p>
<p>for(char count = StartFragment ; count &lt; EndFragment ;)</p>
<p>{</p>
<p> &nbsp; if( (*(ptr_OriginalString + count) &amp; 0x80) != true ) &nbsp;</p>
<p> &nbsp; {</p>
<p> &nbsp; &nbsp; &nbsp;&quot;Some extra work to determing UTF format and get number of remaining bytes for this character&quot;</p>
<p> &nbsp; &nbsp; &nbsp;for(count2 = 0; count2 &lt; &quot;number of remaining bytes&quot;; count2++ , ptr_result++ , count++)</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*ptr_result = *(ptr_OriginalString + count);</p>
<p> &nbsp; }</p>
<p>}</p>
<p>something similar to this. </p>
<p>Not sure if this is the case, but this is my best guess without knowing what kind of error output from the function</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1034113">
				<div id="div-comment-1034113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034113">
			January 21, 2013 at 6:31 am</a>		</div>

		<p>@Henderson101: I don&#39;t think this code could ever work with multi-byte character sequences because it computes the character length *before* encoding (and makes a seriously bad assumption to boot!)</p>
<p>Here are the two lines of code that are responsible for the bad assumption (lines 127-128):</p>
<p>// Marshal.SystemDefaultCharSize is 2 on WinXP Pro &#8211; so the offsets seem to be in character counts instead of bytes.</p>
<p>int bytecountEndOfFragment = 135 + sbContent.Length;</p>
<p>/* &#8230; put the content together &#8230; */</p>
<p>My gut suspicion is that this code was &quot;reverse-engineered&quot; from trial and error; quite possibly the clipboard documentation was never looked at!</p>
<div class="post">[<em>That comment suggests that the original developer though that the HTML clipboard was encoded in UTF-16. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034203">
				<div id="div-comment-1034203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin Eshbach</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034203">
			January 21, 2013 at 2:35 pm</a>		</div>

		<p>@JamesJohnston</p>
<p>In my opinion I would not worry about the api&#39;s being marked as legacy. &nbsp;If Microsoft boots them from Windows and does not provide some sort of emulator to run application that use these api&#39;s then business users will not upgrade.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1034213">
				<div id="div-comment-1034213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jolyon.smith_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jolyon.smith@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034213">
			January 21, 2013 at 3:48 pm</a>		</div>

		<p>@GregM &#8211; exactly. &nbsp;A byte count is a byte count. &nbsp;Not a character count. &nbsp;That was entirely my point which was perfectly plain imho. &nbsp;8 bytes of UTF8 is the same amount of bytes as 8 bytes of UTF16. &nbsp;But it might not be the same amount of characters.</p>
<p>Raymonds wording was a bit woolly, leading to the potential to read it as &quot;the byte count is not the same as the byte count&quot; if you didn&#39;t already know what Raymond was driving at, and Smitty&#39;s (perhaps deliberate) confusion as to how two things that are the same quantity (a number of bytes) can be made different just by the particular composition of the thing involved.</p>
<p>i.e. &quot;8 kilograms of feathers is not the same as 8 kilograms of bricks&quot;</p>
<p>Smitty: &nbsp;Um. &nbsp;Yes it is. &nbsp;8 kg is 8 kg, no matter what you are weighing.</p>
<p>What Raymond meant was that the number of feathers you get in 8kg of feathers is not the same as the number of bricks you get in 8 kg of bricks. &nbsp;If you want a certain numeric quantity of two different things, measuring by WEIGHT is not going to work.</p>
<p>If you already knew this then Smitty&#39;s comment was nonsense, even though it made perfect sense. &nbsp;My mistake was pointing out to others what they already knew by way of explaining how Smitty had become confused. &nbsp;Of course, people not similarly confused wouldn&#39;t understand why or how Smitty was confused himself so my explanation would have appeared equally redundant and &#8211; to their mind &#8211; confusing (because they had already made the translation from kg to bricks/feathers, in their own mind).</p>
<p>A persistent problem in this field of clever/knowledgeable people who assume that other people are just as clever/knowledgeable, is an inability to &quot;put yourself in someone elses&#39; shoes and see things from their p.o.v&quot;, and express oneself accordingly.</p>
<p>Short version: &nbsp;I agree with both Raymond and Smitty. &nbsp;;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034233">
				<div id="div-comment-1034233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034233">
			January 21, 2013 at 7:19 pm</a>		</div>

		<p>@JamesJohnston:</p>
<p>Has reading Raymonds blog taught you NOTHING? If the API works now, and there is no security defect requiring its removal, it will work FOREVER because Microsoft will move mountains to avoid your app breaking on any future version of Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1034413">
				<div id="div-comment-1034413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034413">
			January 22, 2013 at 11:02 am</a>		</div>

		<p>Joylon, thanks for the clarification.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1034453">
				<div id="div-comment-1034453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130118-00/?p=5523#comment-1034453">
			January 22, 2013 at 1:23 pm</a>		</div>

		<p>@Matt: Actually it&#39;s taught me a lot. &nbsp;Now your point &#8211; just because an API is there for legacy/compatibility reasons doesn&#39;t mean you should use it for new development.</p>
<p>Some Win16 examples, all of which still exist but MSDN recommends not to use them:</p>
<p>WinExec replaced with CreateProcess</p>
<p>Get/WritePrivateProfileString replaced with the registry (INI files have Unicode problems, as Raymond noted)</p>
<p>RegSetValue and related replaced with newer registry functions that support multiple values in a key</p>
<p>WNetAddConnection replaced with WNetAddConnection2/WNetAddConnection3</p>
<p>EnumFonts replaced with EnumFontFamiliesEx</p>
<p>Other APIs aren&#39;t explicitly marked as legacy (yet?) &#8211; but exist for legacy reasons. &nbsp;For example, GetParent, which Raymond blogged about a year ago.</p>
<p>A newer example: SHBrowseForFolder replaced with new Vista-style IFileDialog API; the old API gives your app a &quot;legacy&quot; look</p>
<p>All these APIs are still there, but not recommended to use in new development because the original APIs had problems, didn&#39;t fit well with other new features, or were just replaced with a newer/better design. &nbsp;Using them means you might miss out on new stuff, or your app might appear &quot;legacy&quot;. &nbsp;Or it might trap you into having bugs because you didn&#39;t read the esoteric documentation (e.g. GetParent). &nbsp;They might not delete the APIs for compatibility reasons but it&#39;s not ideal to use in new development. &nbsp;Newer APIs might require you to stop using legacy APIs. &nbsp;Legacy APIs could require cumbersome workarounds if they must be used. &nbsp;And someday, the API might really go away.</p>
<p>As far as Microsoft never trying to change the API to break you? &nbsp;There&#39;s only some truth in that; here&#39;s a partial list of APIs that are either gone or going to go away (i.e. MSDN says might not be there in the future):</p>
<p>A whole boatload of shell APIs, either unsupported or on their way out: <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/jj635743(VS.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/jj635743(VS.85).aspx</a></p>
<p>Indexing Service API: <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ee805985(VS.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/ee805985(VS.85).aspx</a></p>
<p>Whatever online help system is not currently in style (WinHelp, HTML Help, and now they seem to have something new every couple years)</p>
<p>Windows Gadgets &amp; Sidebar</p>
<p>Microsoft Agent</p>
<p>Encrypting File System (EFS) APIs</p>
<p>Transactional NTFS (talk about a short life there)</p>
<p>Entire versions of .NET Framework</p>
<p>The APIs seem to be removed because Windows decided to do things differently, or there were features that mostly failed and weren&#39;t widely adopted.</p>
<p>That&#39;s why I&#39;m asking what to replace the APIs I previously mentioned with for these seemingly-essential APIs for desktop development. &nbsp;Or are desktop apps now legacy since some core, essential APIs legacy, and therefore new Windows development should not be desktop development?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

