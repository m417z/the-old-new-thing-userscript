<html>
<head>
<title>The Itanium processor, part 10: Register rotation</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The Itanium processor, part 10: Register rotation</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 7, 2015 / year-entry #165</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>18</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Around and around.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
<!-- backref: The Itanium processor, part 9: Counted loops and loop pipelining -->
Last time</a>,
we looked at counted loops and then improved a simple loop
by explicitly pipelining the loop iterations.
This time, we're going to take the pipelining to the next level.
<span id="more-91151"></span>
</p>
<p>
Let's reorder the columns of the chart we had last time
so the instructions are grouped
not by the register being operated upon but by
the operation being performed.
Since no instructions within an instruction group are
dependent on each other in our example,
I can reorder them without affecting the logic.
</p>
<table BORDER="0" CELLPADDING="0" STYLE="border-collapse: collapse">
<tr>
<td ALIGN="right">1</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black">&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>ld4 r32 = [r29], 4</code></td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td STYLE="width: 8em">&nbsp;</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td>&nbsp;</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td>&nbsp;</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">2</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r33 = [r29], 4</code></td>
<td STYLE="border-top: 1px dotted black">&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">3</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r34 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>adds r32 = r32, 1</code></td>
<td>&nbsp;</td>
<td><code>;;</code></td>
</td>
</tr>
<tr>
<td ALIGN="right">4</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r35 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r33 = r33, 1</code></td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>st4 [r28] = r32, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">5</td>
<td STYLE="padding: 0ex 1ex;border-top"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r33, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">6</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r33 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r35 = r35, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r34, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">7</td>
<td STYLE="padding: 0ex 1ex;border-top"><code>ld4 r34 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r32 = r32, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">8</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r35 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r33 = r33, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r32, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">9</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r33, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">10</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r33 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r35 = r35, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r34, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">11</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black">&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r32 = r32, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">12</td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"></td>
<td STYLE="padding: 0ex 1ex"><code>adds r33 = r33, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r32, 4</code></td>
<td><code>;;</code></td>
</tr>
<tr>
<td ALIGN="right">13</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"></td>
<td STYLE="padding: 0ex 1ex;border-bottom: 1px dotted black"><code>st4 [r28] = r33, 4</code></td>
<td><code>;;</code></td>
</tr>
</table>
<p>
What an interesting pattern.
Each column represents a functional unit,
and at each cycle, the unit operates on a different register in a clear pattern:
<var>r32</var>, <var>r33</var>, <var>r34</var>, <var>r35</var>, then back to
<var>r32</var>.
The units are staggered so that each operates on a register precisely when
its result from the previous unit is ready.
</p>
<p>
Suppose you have to make 2000 sandwiches
and you have four employees.
You could arrange your sandwich factory
with three stations.
At the first station, you have the bread and the toaster.
At the second station, you have the protein.
At the third station, you have the toppings.
Each employee goes through the stations in order:
First they take two pieces of bread and put them in the toaster.
When the toast is finished,
they add the protein,
then they add the toppings,
and then they put the finished sandwich in the box.
Once that's done, they go back to the first station.
You stagger the starts of the four employees so that
at any moment, one is preparing the bread,
one is waiting for the toaster,
one is adding protein,
and one is adding the toppings.
</p>
<p>
That is how the original code was arranged.
Each register is an employee that is at one of the four
stages of sandwich construction.
</p>
<p>
But another way to organize your sandwich factory is
as an assembly line.
You put one employee in charge of the bread,
one in charge of the toaster,
one in charge of the protein,
and one in charge of the toppings.
When a sandwich completes a stage in the process,
it gets handed from one employee to the next.
</p>
<p>
(And since there isn't really anything for the toaster-boy
to do, you can eliminate that position and create the same
number of sandwiches per second with only three employees.
The original version had each employee sitting idle waiting
for the toaster 25% of the time.
Switching to the assembly line model allowed us to squeeze
out that idle time.)
</p>
<p>
Let's apply the assembly line model to our code.
Handing a sandwich from one person to the next is
done by moving the value from one register to the next.
Let's imagine than there is a <var>slide</var> instruction
that you can put at the end of an instruction group
which copies <var>r32</var> to <var>r33</var>,
<var>r33</var> to <var>r34</var>, and so on.
</p>
<table BORDER="0" CELLPADDING="0" STYLE="border-collapse: collapse">
<tr>
<td ALIGN="right">1</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black">&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>ld4 r32 = [r29], 4</code></td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td STYLE="width: 8em">&nbsp;</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td>&nbsp;</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td>&nbsp;</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">2</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td STYLE="border-top: 1px dotted black">&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">3</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>adds r34 = r34, 1</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</td>
</tr>
<tr>
<td ALIGN="right">4</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">5</td>
<td STYLE="padding: 0ex 1ex;border-top"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">6</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">7</td>
<td STYLE="padding: 0ex 1ex;border-top"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">8</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">9</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">10</td>
<td STYLE="padding: 0ex 1ex"><code>ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">11</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black">&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">12</td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"></td>
<td STYLE="padding: 0ex 1ex"><code>adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">13</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"></td>
<td STYLE="padding: 0ex 1ex;border-bottom: 1px dotted black"><code>st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
</table>
<p>
During the execution of the first instruction group,
the first value is loaded into <var>r32</var>,
and the <var>slide</var> instruction slides it
into <var>r33</var>.
</p>
<p>
At the second instruction group,
the second value is loaded into <var>r32</var>,
and the first value sits unchanged in <var>r33</var>.
(Technically, the value is waiting to be loaded into <var>r33</var>.)
The <var>slide</var> instruction slides the second
value into <var>r33</var> and the first value into <var>r34</var>.
</p>
<p>
At the third instruction group,
the third value is loaded into <var>r32</var>,
and the first value (now in <var>r34</var>) is incremented.
Then the <var>slide</var> instruction slides the
third value into <var>r33</var>,
the second value into <var>r34</var>,
and the first value into <var>r35</var>.
</p>
<p>
At the fourth instruction group,
the fourth value is loaded into <var>r32</var>,
the second value (now in <var>r34</var>) is incremented,
and the first value (now in <var>r35</var>) is stored to memory.
Then the <var>slide</var> instruction slides the
fourth value into <var>r33</var>,
the third value into <var>r34</var>,
and the second value into <var>r35</var>.
(The first value slides into <var>r36</var>,
but we don't really care.)
</p>
<p>
And so on.
At each instruction group,
a fresh value is loaded into <var>r32</var>,
a previously-loaded value is incremented in <var>r34</var>,
and the incremented value is stored from <var>r35</var>.
And then the <var>slide</var> instruction moves
everything down one step for the next instruction group.
</p>
<p>
When we reach the 11th instruction group,
we drain out the last value and don't bother
starting up any new ones.
</p>
<p>
Observe that the above code also falls into a
<i>prologue</i>/<i>kernel</i>/<i>epilogue</i> pattern.
In the prologue, the assembly line starts up
and gradually fills the registers with work.
In the kernel, the assembly line is completely busy.
And in the epilogue, the work of the final registers
drains out.
</p>
<p>
You can already see how <var>br.cloop</var> would
come in handy here:
The kernel can be written as a single-instruction loop!
But wait there's more.
</p>
<p>
Let's add some predicate registers to the mix.
Let's suppose that the <code>slide</code> instruction
slides not only integer registers
but also predicate registers.
</p>
<table BORDER="0" CELLPADDING="0" STYLE="border-collapse: collapse">
<tr>
<td ALIGN="right">1</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black">&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td STYLE="width: 8em">&nbsp;</td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td STYLE="padding: 0ex 1ex;color: red"><code>(p18) adds r34 = r34, 1</code></td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td STYLE="padding: 0ex 1ex;color: red"><code>(p19) st4 [r28] = r35, 4</code></td>
<td ROWSPAN="13" STYLE="border-right: 1px solid black"></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">2</td>
<td STYLE="padding: 0ex 1ex"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td STYLE="border-top: 1px dotted black">&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code><font COLOR="red">(p18) adds r34 = r34, 1</font></code></td>
<td STYLE="padding: 0ex 1ex;color: red"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">3</td>
<td STYLE="padding: 0ex 1ex"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex;color: red"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</td>
</tr>
<tr>
<td ALIGN="right">4</td>
<td STYLE="padding: 0ex 1ex"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">5</td>
<td STYLE="padding: 0ex 1ex;border-top"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">6</td>
<td STYLE="padding: 0ex 1ex"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">7</td>
<td STYLE="padding: 0ex 1ex;border-top"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">8</td>
<td STYLE="padding: 0ex 1ex"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">9</td>
<td STYLE="padding: 0ex 1ex"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">10</td>
<td STYLE="padding: 0ex 1ex"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">11</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black;color: red"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">12</td>
<td STYLE="padding: 0ex 1ex;color: red"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black"></td>
<td STYLE="padding: 0ex 1ex"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
<tr>
<td ALIGN="right">13</td>
<td STYLE="padding: 0ex 1ex;color: red"><code>(p16) ld4 r32 = [r29], 4</code></td>
<td>&nbsp;</td>
<td STYLE="padding: 0ex 1ex;border-top: 1px dotted black;color: red"><code>(p18) adds r34 = r34, 1</code></td>
<td STYLE="padding: 0ex 1ex;border-bottom: 1px dotted black"><code>(p19) st4 [r28] = r35, 4</code></td>
<td STYLE="padding: 0ex 1ex"><code>slide ;;</code></td>
</tr>
</table>
<p>
We can initally set <var>p16 = true</var>,
<var>p17 = p18 = p19 = false</var>.
That way, only the load executes from the first instruction group.
And then the <var>slide</var> instruction slides both the integer
registers and the predicate registers,
which causes <var>p17</var> to become <var>true</var>.
</p>
<p>
In the second instruction group, again,
only the load executes.
And then the <var>slide</var> instruction slides <var>p17</var>
into <var>p18</var>,
so now <var>p18 = true</var> also.
</p>
<p>
Since <var>p18 = true</var>,
the third instruction group both loads and increments.
And then the <var>slide</var> instruction slides <var>p18</var>
into <var>p19</var>,
so now all of the predicates are true.
</p>
<p>
With all the predicates true, every step in instruction groups three
through 10 execute.
</p>
<p>
Now, with instruction group 11,
we want to slide the predicates,
but also set <var>p16</var> to <var>false</var>.
That turns off the <var>ld4</var> instruction.
</p>
<p>
The <var>p16 = false</var> then slides into <var>p17</var> for
instruction group 12,
then
into <var>p18</var> for instruction group 13,
which turns off the increment instruction.
</p>
<p>
If we can get the <var>slide</var> instruction to slide
the predicates and set <var>p16</var> to <var>true</var>
for the first 10 instructions,
and set it to <var>false</var> for the last three,
then we can simply execute the same instruction 13 times!
</p>
<p>
Okay, now I can reveal the true identity of the <var>slide</var>
instruction:
It's called <var>br.ctop</var>.
</p>
<p>
The <var>br.ctop</var> instruction works like this:
</p>
<pre>
 if (ar.lc != 0) { slide; p16 = true; ar.lc = ar.lc - 1; goto branch; }
 if (ar.ec != 0) { slide; p16 = false; ar.ec = ar.ec - 1;
                  if (ar.ec != 0) goto branch; }
 else { /* unimportant */ }
</pre>
<p>
In words, the <var>br.ctop</var> instruction first
checks the <var>ar.lc</var> register (<i>loop counter</i>).
If it is nonzero, then the registers slide over,
the <var>p16</var> register is set to <var>true</var>,
the loop counter is decremented,
and the jump is taken.
</p>
<p>
If <var>ar.lc</var> is zero, then the <var>br.ctop</var>
instruction checks the
<var>ar.ec</var> register (<i>epilogue counter</i>).
If it is nonzero, then the register slide over,
the <var>p16</var> register is set to <var>false</var>,
and.the epilogue counter is decremented.
If the decremented value of the epilogue counter is nonzero,
then the jump is taken;
otherwise we fall through and the loop ends.
</p>
<p>
(If both <var>ar.lc</var> and <var>ar.ec</var> are zero,
then the loop is finished before it even started.
Some weird edge-case handing happens here which is not
important to the discussion.)
</p>
<p>
Code that takes advantage of the <var>br.ctop</var>
instruction goes like this:
</p>
<pre>
      alloc r36 = ar.pfs, 0, 8, 0, 4 // four rotating registers!
      mov r37 = ar.lc         // preserve lc
      mov r38 = ar.ec         // preserve ec
      mov r39 = preds         // preserve predicates

      addl r31 = r0, 1999 ;;  // r31 = 1999
      mov ar.lc = r31         // ar.lc = 1999
      mov ar.ec = 4
      mov pr.rot = 1 &lt;&lt; 16 // p16 = true, all others false
      addl r29 = gp, -205584  // calculate start of array
      addl r28 = r29, 0 ;;     // put it in both r28 and r29

again:
(p16) ld4 r32 = [r29], 4      // execute an entire loop with
(p18) adds r34 = r34, 1       // a single instruction group
(p19) st4 [r28] = r35, 4      // using this one weird trick
      br.ctop again ;;

      mov ar.lc = r37         // restore registers we preserved
      mov ar.ec = r38
      mov preds = r39
      mov ar.pfs = r36
      br.ret.sptk.many rp     // return
</pre>
<p>
We are now using the last parameter to the
<var>alloc</var> instruction.
The <var>4</var> says that we want four rotating registers.
The <var>ar.lc</var> and <var>ar.ec</var> register must be
preserved across calls, so we save them here for restoration
at the end.
Predicate registers <var>p16</var> through <var>p63</var>
must also be preserved, so we save all the predicate registers
by using the <var>preds</var> pseudo-register which grabs all
64 predicates into a single 64-bit value.
</p>
<p>
Next, we set up the loop by setting the loop counter to the
number of additional times we want to execute the loop
(not counting the one execution we get via fall-through),
the epilogue counter to the number of steps we need in order
to drain the final iterations,
and set the predicates so that <var>p16 = true</var>
and everything else is <var>false</var>.
We also set up <var>r28</var> and <var>r29</var> to step through
the array.
</p>
<p>
Once that is done, we can execute the entire loop in a single
instruction group.
</p>
<p>
And then we clean up after the loop by restoring all the
registers to how we found them, then return.
</p>
<p>
And there you have register rotation.
It lets you compress the prologue,
kernel,
and epilogue of a pipelined loop
into a single instruction group.
</p>
<p>
I pulled a fast one here:
The Itanium requires that the number of rotating registers be
a multiple of eight.
So our code really should look like this:
</p>
<pre>
      alloc r40 = ar.pfs, 0, <font COLOR="blue">12</font>, 0, <font COLOR="blue">8</font>
      mov <font COLOR="blue">r41</font> = ar.lc         // preserve lc
      mov <font COLOR="blue">r42</font> = ar.ec         // preserve ec
      mov <font COLOR="blue">r43</font> = preds         // preserve predicates

      addl r31 = r0, 1999 ;;  // r31 = 1999
      mov ar.lc = r31         // ar.lc = 1999
      mov ar.ec = 4
      mov pr.rot = 1 &lt;&lt; 16 // p16 = true, all others false
      addl r29 = gp, -205584  // calculate start of array
      addl r28 = r29, 0 ;;     // put it in both r28 and r29

again:
(p16) ld4 r32 = [r29], 4      // execute an entire loop with
(p18) adds r34 = r34, 1       // a single instruction group
(p19) st4 [r28] = r35, 4      // using this one weird trick
      br.ctop again ;;

      mov ar.lc = <font COLOR="blue">r41</font>         // restore registers we preserved
      mov ar.ec = <font COLOR="blue">r42</font>
      mov preds = <font COLOR="blue">r43</font>
      mov ar.pfs = <font COLOR="blue">r40</font>
      br.ret.sptk.many rp     // return
</pre>
<p>
Instead of four rotating registers, we use eight.
The underlying analysis remains the same.
We are just throwing more registers into the pot.
</p>
<p>
Now, the loop we were studying happens to be very simple,
with only one load and one store.
For more complex loops, you may need to use things like
<!-- backref: The Itanium processor, part 6: Calculating conditionals -->
the unconditional comparison</a>,
or pipelining the iterations with a stagger of more than one
cycle.
</p>
<p>
There are other types of instructions for managing loops
with register rotation.
For example, <var>br.cexit</var> is like <var>br.ctop</var>
except that it jumps when <var>br.ctop</var> falls through
and vice versa.
This is handy to put at the start of your pipelined loop
to handle the case where the number of iterations is zero.
There are also <var>br.wtop</var> and <var>br.wexit</var>
instructions
to handle <code>while</code> loops instead of counted loops.
The basic idea is the same, so I won't go into the details.
You can read the Itanium manual to learn more.
</p>
<p>
That's the end of the whirlwind tour of the Itanium architecture.
There are still parts left unexplored,
but I tried to hit the most interesting sights.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (18)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1196491">
				<div id="div-comment-1196491" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196491">
			August 7, 2015 at 7:08 am</a>		</div>

		<p>Thanks Raymond, for an interesting tour of a rather weird architecture.</p>
<p>I&#39;ve been impressed with the clarity of your explanations, and I&#39;d love to see you do this again with another architecture that Windows has supported.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196481">
				<div id="div-comment-1196481" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196481">
			August 7, 2015 at 7:08 am</a>		</div>

		<p>Very interesting fortnight. I&#39;d definitely be voting for doing this with another architecture some time!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196471">
				<div id="div-comment-1196471" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BDCrazy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196471">
			August 7, 2015 at 7:11 am</a>		</div>

		<p>Fascinating adventure. &nbsp;Thanks for the work involved.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196461">
				<div id="div-comment-1196461" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196461">
			August 7, 2015 at 7:23 am</a>		</div>

		<p>Let me add my thanks as well. As you said at the beginning, it&#39;s very much like learning a foreign language. Not directly practical if you&#39;re not going to be in a place where you need it, but really interesting to see another way of looking at the world.</p>
<p>Is the br.ctop instruction something special that lets you get 4 instructions in an instruction group instead of 3? Or am I completely misunderstanding the prior parts of the series?</p>
<div class="post">[<em>You&#39;re confusing instruction groups (which can be arbitrarily large) and bundles (which are groups of three instructions). -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196451">
				<div id="div-comment-1196451" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196451">
			August 7, 2015 at 7:39 am</a>		</div>

		<p>(p16) ld4 r32 = [r29], 4 &nbsp; &nbsp; &nbsp;// execute an entire loop with</p>
<p>(p18) adds r34 = r34, 1 &nbsp; &nbsp; &nbsp; // a single instruction group</p>
<p>(p19) st4 [r28] = r35, 4 &nbsp; &nbsp; &nbsp;// using this one weird trick</p>
<p>Echoes of certain dumb internet advertisements. &nbsp; Funny!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196441">
				<div id="div-comment-1196441" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196441">
			August 7, 2015 at 7:43 am</a>		</div>

		<p>Question: &nbsp;This processor is great at pipelining and parallel execution. &nbsp;</p>
<p>But, the first illustration shows the job taking 13 steps. &nbsp;After rearrangement, the illustration takes &#8230; 13 steps. &nbsp;What have we gained? &nbsp;</p>
<p>Is the answer that when we are in the Kernel or &quot;cruise&quot; phase, everything runs faster without pipeline stalls?</p>
<div class="post">[<em>It&#39;s the same number of cycles, but expressed in far fewer instructions. If the kernel has <var>N</var> phases, then the old way needs <var>N</var>(<var>N</var>&minus;1) prologue instructions, <var>N</var>&sup2; kernel instructions, and <var>N</var>(<var>N</var>&minus;1) epilogue instructions. And that&#39;s assuming the number of iterations is an exact multiple of <var>N</var>. The new way, it&#39;s 3 set-up instructions and <var>N</var>+1 kernel instructions. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196431">
				<div id="div-comment-1196431" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196431">
			August 7, 2015 at 8:18 am</a>		</div>

		<p>@DWalker <a rel="nofollow" target="_new" href="http://www.youtube.com/watch?v=xECUrlnXCqk">http://www.youtube.com/watch</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196421">
				<div id="div-comment-1196421" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196421">
			August 7, 2015 at 9:25 am</a>		</div>

		<p>Came to the comments to thank you for the series and express LOLs at the &quot;one weird trick&quot; reference (And the &quot;but wait: there&#39;s more!&quot;).</p>
<p>This made for some heavy but enjoyable reading, thank you, Raymond, for writing it all up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196411">
				<div id="div-comment-1196411" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carl D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196411">
			August 7, 2015 at 10:13 am</a>		</div>

		<p>I must echo other comments here &#8211; well done on this series, Raymond! &nbsp;Itanium is a fascinating beast indeed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196401">
				<div id="div-comment-1196401" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196401">
			August 7, 2015 at 1:26 pm</a>		</div>

		<p>I see how I misinterpreted Part 1 now. I had read it that each &quot;bundle&quot; consisted of &quot;instruction groups&quot; separated by double-semicolons, but now I see that they&#39;re actually separate concepts, and an instruction group can span bundles, and due to all the pipelining and multiple-computation-areas and such in a processor, it can work on more than one bundle at once.</p>
<p>Yes, &quot;foreign language&quot; is a very apt analogy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196391">
				<div id="div-comment-1196391" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio &amp;#39;Grijan&amp;#39;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196391">
			August 7, 2015 at 3:02 pm</a>		</div>

		<p>@pc: if I have understood correctly, most Itanium processors have enough units to allow them execute up to six instructions (two bundles) in the same cycle. The exception is the last generation, which can execute up to twelve instructions (four bundles) per cycle. Knowing that, the kernel of four instructions written by Raymond would be executed in just one cycle, and there would be two spare execution units (the kernel could have two more instructions and still be executed in one cycle). There is a nice diagram explaining it in page 8 of <a rel="nofollow" target="_new" href="http://www.rw.cdl.uni-saarland.de/~kaestner/es0203/lectdk11.pdf">http://www.rw.cdl.uni-saarland.de/&#8230;/lectdk11.pdf</a> .</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196371">
				<div id="div-comment-1196371" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DoomMuffins</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196371">
			August 8, 2015 at 7:36 am</a>		</div>

		<p>Thanks for the read, Raymond &#8211; it was a fascinating series, and I hope to see one about the Alpha AXP.</p>
<p>I was wondering whether debuggers for this platform performed step-through in units of bundles rather than instructions (did each F10 in windbg print the entire current bundle?), and if not &#8211; what did they do to break each bundle up?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196361">
				<div id="div-comment-1196361" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196361">
			August 8, 2015 at 9:01 am</a>		</div>

		<p>DoomMuffins: Any interruption (like an exception, single-stepping in the debugger, or a hardware interrupt) sets not only the IIP (interruption instruction pointer) but also the bits in a status register that tell which instruction in the bundle is being executed.</p>
<p>Upon resuming from that interruption, the CPU knows which instruction in the bundle to execute next.</p>
<p>So even though you can&#39;t specify a branch to the middle of a bundle, the processor still handles it the way you would want in all other circumstances.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196351">
				<div id="div-comment-1196351" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">A regular viewer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196351">
			August 8, 2015 at 10:14 am</a>		</div>

		<p>I too thank you, Raymond. This was fascinating.</p>
<p>I have no actual low-level CPU programming experience and I did follow this series at a passable level. I &quot;got&quot; it &#8211; so to speak.</p>
<p>I want to highlight something here. This series explained the functioning of the Itanium processor in such a manner that a dyed-in-the-wool Visual Basic programmer can understand. And has understood. The credit for that goes to you, far more than, to Intel.</p>
<p>Again. Thank you.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196341">
				<div id="div-comment-1196341" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Falcon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196341">
			August 8, 2015 at 8:50 pm</a>		</div>

		<p>@DoomMuffins:</p>
<p>Look up the handling of Bus Error and Address Error exceptions on 68k processors (68010 and later) &#8211; they saved their internal state in the exception stack frame, allowing them to resume execution of the faulting instruction!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196331">
				<div id="div-comment-1196331" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196331">
			August 9, 2015 at 11:27 am</a>		</div>

		<p>I&#39;m kind of relieved that we&#39;ve been saved from this insanity&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1196321">
				<div id="div-comment-1196321" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">user</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196321">
			August 9, 2015 at 5:43 pm</a>		</div>

		<p>Another vote for the Alpha AXP next.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196311">
				<div id="div-comment-1196311" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150807-00/?p=91151#comment-1196311">
			August 10, 2015 at 5:47 am</a>		</div>

		<p>@Azarien</p>
<p>It&#39;s not that insane &#8211; the gap between Itanium and Xeon is simply that Itanium exposes this level of detail to the ISA for a compiler or assembly programmer to exploit, whereas Xeon extracts this sort of insanity (and more) from the &quot;more traditional&quot; x86 ISA.</p>
<p>Effectively, the Itanium bet was that we&#39;d be quicker to write compilers that could fully exploit the features that Raymond has outlined than the hardware guys would be to detect cases where they can be exploited in an existing instruction stream.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

