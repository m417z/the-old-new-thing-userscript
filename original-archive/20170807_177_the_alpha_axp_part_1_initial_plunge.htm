<html>
<head>
<title>The Alpha AXP, part 1: Initial plunge</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The Alpha AXP, part 1: Initial plunge</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 7, 2017 / year-entry #178</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>40</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Pretty registers, all in a row.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Since the Itanium series was such a smash hit
(two whole people read it!),
here's another series for a now-defunct processor architecture
which Windows once supported.
The next who-knows-how-many days will be devoted
to an introduction to the Alpha AXP processor,
as employed by Win32.
</p>
<p>
The Alpha AXP
follows in the traditional RISC philosophy of having a relatively
small and uniform instruction set.
The first Alpha AXP chip was dual-issue,
and it eventually reached quad-issue.
(<a HREF="https://en.wikipedia.org/wiki/Alpha_21464"
>There was an eight-issue processor under development</a>
when the Alpha AXP project was cancelled.)
This series will focus on the original Alpha AXP architecture
because that's what Windows NT for Alpha AXP ran on,
and it will largely ignore features added later.
</p>
<p>
The Alpha AXP is a 64-bit processor.
It does not have "32-bit mode";
the processor is always running in 64-bit mode.
If the destination of a 32-bit operation is a register,
the answer is always sign-extended to a 64-bit value.
(This is known as the "canonical form" for a 32-bit value
in a 64-bit register.)
This one weird trick lets you close one eye and
sort of pretend that it's a 32-bit processor.
An Alpha AXP program running on
32-bit Windows NT still has full access to the
64-bit registers and can use them to perform 64-bit
computations.
It could even use the full 64-bit address space,
if you were willing to
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20070801-00/?p=25763">
jump through some hoops</a>.
</p>
<p>
Each instruction is a 32-bit word,
aligned on a 4-byte boundary.
Unlike other RISC processors of its era,
the Alpha AXP does not have branch delay slots.
If you don't know what branch delay slots are,
then consider yourself lucky.
</p>
<p>
Memory size terms in the Alpha AXP instruction set
are <var>byte</var>, <var>word</var> (two bytes),
<var>longword</var> (four bytes),
and
<var>quadword</var> (eight bytes).&sup1;
In casual conversation,
<var>longword</var> and <var>quadword</var>
are usually shortened <var>long</var> and <var>quad</var>.
</p>
<p>
The Alpha AXP defines certain groups of instructions
which are optional, such as floating point.
If you perform an instruction which is not implemented by
the processor, the instruction will trap into the kernel,
and the kernel is expected to emulate the missing instruction,
and then resume execution.
</p>
<p>
<b>Registers</b>
</p>
<p>
There are 32 integer registers, all 64 bits wide.
Formally, they are known by the names
<var>r0</var> through <var>r31</var>,
but Win32 assigns them the following mnemonics which correspond
to their use in the Win32 calling convention.
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border: solid 1px black; border-collapse: collapse">
<tr>
<th>Register</th>
<th>Mnemonic</th>
<th>Meaning</th>
<th>Preserved?</th>
<th>Notes</th>
</tr>
<tr>
<td><var>r0</var></td>
<td><var>v0</var></td>
<td>value</td>
<td>No</td>
<td>On function exit, contains the return value.</td>
</tr>
<tr>
<td><var>r1</var>&hellip;<var>r8</var></td>
<td><var>t0</var>&hellip;<var>t7</var></td>
<td>temporary</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><var>r9</var>&hellip;<var>r14</var></td>
<td><var>s0</var>&hellip;<var>s5</var></td>
<td>saved</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><var>r15</var></td>
<td><var>fp</var></td>
<td>frame pointer</td>
<td>Yes</td>
<td>For functions with variable-sized stacks.</td>
</tr>
<tr>
<td><var>r16</var>&hellip;<var>r21</var></td>
<td><var>a0</var>&hellip;<var>a5</var></td>
<td>argument</td>
<td>No</td>
<td>On function entry, contains function parameters.</td>
</tr>
<tr>
<td><var>r22</var>&hellip;<var>r25</var></td>
<td><var>t8</var>&hellip;<var>t11</var></td>
<td>temporary</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><var>r26</var></td>
<td><var>ra</var></td>
<td>return address</td>
<td>Not normally</td>
<td></td>
</tr>
<tr>
<td><var>r27</var></td>
<td><var>t12</var></td>
<td>temporary</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><var>r28</var></td>
<td><var>at</var></td>
<td>assembler temporary</td>
<td>Volatile</td>
<td>Long jump assist.</td>
</tr>
<tr>
<td><var>r29</var></td>
<td><var>gp</var></td>
<td>global pointer</td>
<td>Special</td>
<td>Not used by 32-bit code.</td>
</tr>
<tr>
<td><var>r30</var></td>
<td><var>sp</var></td>
<td>stack pointer</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><var>r31</var></td>
<td><var>zero</var></td>
<td>reads as zero</td>
<td>N/A</td>
<td>Writes are ignored.</td>
</tr>
</table>
<p>
The <var>zero</var> register reads as zero, and writes to it are ignored.
But it goes further than that: If you specify <var>zero</var> as the
destination register for an instruction, the entire instruction may
be optimized out by the processor!
This means that any side effects <i>may or may not occur</i>.
There are a few exceptions to this rule:
</p>
<ul>
<li>Branch instructions are never optimized out.
    If a branch instructions specifies <var>zero</var> as the register
    to receive the return address,
    the branch is still taken,
    but the return address is thrown away.</p>
<li>Load instructions are always optimized out.
    If a load instruction specifies <var>zero</var> as the destination
    register,
    the processor will never raise an exception.
    Instead, these "phantom loads"
    are used as prefetch hints to the processor.
</ul>
<p>
Whereas the behavior of the <var>zero</var> register is architectural,
the behavior of the other registers are established by convention.
</p>
<p>
Win32 requires that
the <var>gp</var>, <var>sp</var>, and <var>fp</var> registers
be used for their stated purpose throughout the entire function.
(If a function does not have a variable-sized stack frame,
then it can use <var>fp</var> for any purpose.)
Some registers have stated purposes only at entry to a function or
exit from a function.
When not at the function boundary, those registers may be used for
any purpose.
</p>
<p>
Register marked with "Yes" in the "Preserved" column must be
preserved across the call;
those marked "No" do not.
</p>
<p>
The <var>ra</var> register is marked "Not normally" because you
don't normally need to preserve it.
However, if you are a leaf function that uses no stack space
and modifies no preserved registers,
then you can skip the generation of unwind codes for the leaf
function, but you must keep the return address in <var>ra</var>
for the duration of your function so that the operating system
can unwind out of the function should an exception occur.
(Special rules for lightweight leaf functions
also exist for
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20150730-00/?p=90791">
Itanium</a>
and x64.)
</p>
<p>
What does it mean when I say that the <var>at</var> register is volatile?
</p>
<p>
Direct branch instructions can reach destinations up to
4<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/11/9725386.aspx">MB</a>
from the current instruction.
When the compiler generates a <var>bsr</var> instruction
(branch to subroutine),
it typically doesn't know
how far away the destination is.
The compiler just generates a <var>bsr</var> instruction with a fixup
and hopes for the best.
It is the linker who knows how far away the destination actually is,
and if it turns out the destination is too far away,
the linker changes
</p>
<pre>
        ....
        BSR     toofaraway
        ....
</pre>
<p>to
</p>
<pre>
        ....
        BSR     trampoline
        ....

trampoline:
        ... set the "at" register equal to the
        ... address of "toofaraway."
        JMP     (at)            ; register indirect jump
</pre>
<p>
The linker inserts the generated trampoline code
between functions,
which also has as a consequence that a single function
cannot be larger than 8MB.
</p>
<p>
Anyway, this secret rewriting means that any branch instruction can
potentially modify the <var>at</var> register.
In between branches, you can use <var>at</var>,
but you cannot rely on its value remaining the same once
a branch is taken.
In practice, the compiler just avoids using the <var>at</var>
register altogether.
</p>
<p>
The <var>gp</var> register is not used by 32-bit code.
I don't know for sure,
but I'm guessing that in 64-bit code, it serves the same purpose as
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2015/07/31/10631975.aspx">
the Itanium <var>gp</var> register</a>.
</p>
<p>
Note that some register names, like <var>a0</var> look like hex digits.
The Windows debugger resolves them in favor of hex values,
so if you do <code>? a0</code> thinking that you're getting the value
of the <var>a0</var> register, you're going to be disappointed.
To force a symbol to be interpreted as a register name, put an at-sign
in front:
<code>? @a0</code>.
</p>
<p>
Even more confusing is that the Windows debugger's disassembler does not
put the <code>0x</code> prefix in front of numbers, so when you see an
<code>a0</code>, you have to use the context to determine whether it is
a number or a register. For example,
</p>
<pre>
    LDA     a0, a0(a0)
            ^^  ^^ ^^
      register  |  register
              number
</pre>
<p>
The first parameter to <code>LDA</code> and the parameter inside
the parentheses must be a register, so the outer <code>a0</code>'s
refer to the register. The thing just outside the parentheses
must be a constant, so the middle <code>a0</code> is the number 160.
Yes, it's confusing at first, but the uniform instruction set
means that these rules are quickly learned,
and you don't really notice it once you get used to it.
</p>
<p>
Another point of confusion is that the conventional placeholder
names for registers in instructions are <code>Ra</code>,
<code>Rb</code> and <code>Rc</code>.
This should not be confused with the <var>ra</var> register.</p>
<p>
There are
thirty-two floating point registers.
Formally, they are known as <var>f0</var> through <var>f31</var>,
but Win32 assigns the following mnemonics:
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border: solid 1px black; border-collapse: collapse">
<tr>
<th>Register</th>
<th>Mnemonic</th>
<th>Preserved?</th>
<th>Meaning</th>
</tr>
<tr>
<td><var>f0</var></td>
<td></td>
<td>No</td>
<td>Return value</td>
</tr>
<tr>
<td><var>f1</var></td>
<td></td>
<td>No</td>
<td>Second return value (for complex numbers)</td>
</tr>
<tr>
<td><var>f2</var>&hellip;<var>f9</var></td>
<td></td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><var>f10</var>&hellip;<var>f15</var></td>
<td></td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><var>f16</var>&hellip;<var>f21</var></td>
<td></td>
<td>No</td>
<td>First six parameters</td>
</tr>
<tr>
<td><var>f22</var>&hellip;<var>f30</var></td>
<td></td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><var>f31</var></td>
<td><var>fzero</var></td>
<td>N/A</td>
<td>Reads as zero.  Writes are ignored.</td>
</tr>
</table>
<p>
There are four floating point formats supported.
Two are the usual IEEE single and double precision formats.
Two are special formats for backward compatibility with
the DEC VAX.
That's about all I'm going to say about floating point.
</p>
<p>
Finally, there are some special registers.
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border: solid 1px black; border-collapse: collapse">
<tr>
<th>Register</th>
<th>Mnemonic</th>
<th>Meaning</th>
</tr>
<tr>
<td><var>pc</var></td>
<td><var>fir</var></td>
<td>program counter</td>
</tr>
<tr>
<td><var>lock_flag</var></td>
<td></td>
<td>For interlocked memory access</td>
</tr>
<tr>
<td><var>phys_locked</var></td>
<td></td>
<td>For interlocked memory access</td>
</tr>
<tr>
<td><var>fpcr</var></td>
<td></td>
<td>Floating point control register</td>
</tr>
</table>
<p>
Why is the program counter called <var>fir</var>?
Because that stands for
"faulting instruction register".
</p>
<p>
Clearly named by somebody wearing kernel-colored glasses.
</p>
<p>
These special registers are not directly accessible.
To retrieve the program counter,
you can to issue a branch instruction and
save the "return address" into the desired destination register.
We'll learn more about the <var>lock_flag</var>
and <var>phys_locked</var>
when we study interlocked memory access.
</p>
<p>
Note that there is no flags register.
</p>
<p>
I repeat: There is no flags register.
</p>
<p>
Here's what a register dump looks like in the Windows debugger:
</p>
<pre>
  v0=00000000 00000016   t0=00000000 00000000   t1=00000000 00000000
  t2=00000000 00000000   t3=00000000 00000009   t4=00000000 00000001
  t5=00000000 0006f9d0   t6=00000000 00000008   t7=00000000 00000000
  s0=00000000 00000001   s1=00000000 00000000   s2=00000000 00081eb0
  s3=00000000 77fc0000   s4=00000000 00081dec   s5=00000000 77fc0000
  fp=00000000 7ffde000   a0=00000000 750900c8   a1=00000000 00000001
  a2=00000000 00000009   a3=00000000 0006f9d0   a4=00000000 00000001
  a5=00000000 00000001   t8=00000000 0000004c   t9=00000000 00000001
 t10=00000000 0000004c  t11=ffffffff c00ea124   ra=00000000 77f4df08
 t12=00000000 00000001   at=00000000 77f548f0   gp=00000000 00000000
  sp=00000000 0006f9e0 zero=00000000 00000000 fpcr=08000000 00000000
softfpcr=00000000 00000000  fir=77f63bf4
 psr=00000003
mode=1 ie=1 irql=0
</pre>
<p>
I never needed to know what <code>softfpcr</code> is.
The <code>psr</code> is the processor status register,
the <code>mode</code> is 1 for user mode and 0 for kernel mode,
<code>ie</code> is the interrupt enable flag,
and <code>irql</code> is the interrupt request level.
</p>
<p>
The calling convention is simple.
As noted in the tables above, parameters are passed in registers,
with excess parameters spilled onto the stack.
There is no
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20130830-00/?p=3363">
home space</a>.
The return address is passed in the <var>ra</var> register,
and the stack must be kept aligned on a 16-byte boundary.
Exception dispatch is done by unwind tables stored in a separate
section of the image.
</p>
<p>
Okay, that's the register set and calling convention.
Next time, we'll look at integer operations.
</p>
<p>
<b>Exercise</b>:
The x64 calling convention reserves home space so that the register-based
parameters can be spilled onto the stack and remain contiguous with
the other stack-based parameters,
so that the entire parameter pack can be enumerated with the
<code>va_start</code> family of macros.
Why doesn't this requirement apply to the Alpha AXP?
</p>
<p>
&sup1;
The term <var>octaword</var> was introduced later,
but we are focusing on the Alpha AXP classic architecture.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (40)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1305476">
				<div id="div-comment-1305476" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305476">
			August 7, 2017 at 7:35 am</a>		</div>

		<p>Both of us who enjoyed the Itanium writeup will be enjoying this series as well. Thank you.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1305665">
				<div id="div-comment-1305665" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Martin Bonner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305665">
			August 7, 2017 at 1:24 pm</a>		</div>

		<p>Ah-ha!  I was wondering who the other guy was.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1305676">
				<div id="div-comment-1305676" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jnm2</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305676">
			August 7, 2017 at 2:53 pm</a>		</div>

		<p>He&#8217;s gotta be joking. I read it and I&#8217;m sure many others did as well.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong odd alt depth-4" id="comment-1305695">
				<div id="div-comment-1305695" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305695">
			August 8, 2017 at 1:12 am</a>		</div>

		<p>Yup. Not replying it does not necessarily means not enjoy reading it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4" id="comment-1305875">
				<div id="div-comment-1305875" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305875">
			August 9, 2017 at 9:32 am</a>		</div>

		<p>He was certainly joking &#8211; look at the comments to the Itanium articles.  They were quite active.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-4" id="comment-1306447">
				<div id="div-comment-1306447" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Grey Hodge</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1306447">
			August 14, 2017 at 10:54 pm</a>		</div>

		<p>There are literally dozens of us!</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1305725">
				<div id="div-comment-1305725" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.farnz.org.uk/' rel='external nofollow' class='url'>Simon Farnsworth</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305725">
			August 8, 2017 at 4:25 am</a>		</div>

		<p>I&#8217;d love to see Raymond do one of these for each architecture he&#8217;s worked with. The Itanium one was deeply interesting, and I expect this one to be good, too.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1305876">
				<div id="div-comment-1305876" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305876">
			August 9, 2017 at 9:35 am</a>		</div>

		<p>I&#8217;d love to see a series on ARM even if he hasn&#8217;t worked on it.  I&#8217;d bet he would still teach me some interesting stuff.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-4 parent" id="comment-1305915">
				<div id="div-comment-1305915" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305915">
			August 9, 2017 at 12:06 pm</a>		</div>

		<p>I already <a href="https://blogs.msdn.microsoft.com/oldnewthing/20150811-01/?p=91121">wrote an article about that</a>.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1305977">
				<div id="div-comment-1305977" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305977">
			August 10, 2017 at 9:02 am</a>		</div>

		<p>Raymond comes through &#8211; courtesy of Marion Cole.  Thanks!  (I&#8217;m surprised I don&#8217;t remember that at all)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1305947">
				<div id="div-comment-1305947" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ZLB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305947">
			August 10, 2017 at 5:34 am</a>		</div>

		<p>Well, I enjoyed the Itanium series too. What a beast of an architecture!</p>
<p>On the other hand, batch week. Err&#8230;yeah that OK I guess!</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1305485">
				<div id="div-comment-1305485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305485">
			August 7, 2017 at 7:39 am</a>		</div>

		<p>It&#8217;s interesting to follow the development of different processor architectures.  I&#8217;ll bet at least THREE people read the Itanium articles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1305495">
				<div id="div-comment-1305495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305495">
			August 7, 2017 at 7:53 am</a>		</div>

		<p>Hooray! I&#8217;ve been waiting for this for a while! I loved your Itanium series; I must be the third out of two!</p>
<p>As for the exercise, I&#8217;m a little stumped, but would it make sense for the first six arguments to be added to registers left-to-right, then the remaining arguments pushed onto the stack right-to-left, such that arguments can be taken out of registers and added to the &#8220;correct&#8221; end of the stack without issue as if they were local variables?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-odd thread-alt depth-1" id="comment-1305497">
				<div id="div-comment-1305497" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305497">
			August 7, 2017 at 7:55 am</a>		</div>

		<p>Alpha AXP was always the great &#8220;What could have been.&#8221; I&#8217;d have been very curious to see benchmarks between early x64 and AXP using windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mngoldeneagle even thread-even depth-1" id="comment-1305506">
				<div id="div-comment-1305506" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305506">
			August 7, 2017 at 8:06 am</a>		</div>

		<p>Not as crazy as the Itanium architecture to be sure, but a fun read regardless.  Reminds me a lot of the MIPS V architecture, except I know MIPS did have a flags register along with some other internal registers that are still an enigma to me.  MIPS did have a 32-bit operating mode, but all it basically meant was that it ignored the top 32 bits when it came to branch, jump, and load/store operations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1305515">
				<div id="div-comment-1305515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CarlD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305515">
			August 7, 2017 at 8:09 am</a>		</div>

		<p>&#8220;If you don&#8217;t know what branch delay slots are, then consider yourself lucky. &#8221;  Amen to that, brother.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1305517">
				<div id="div-comment-1305517" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305517">
			August 7, 2017 at 8:20 am</a>		</div>

		<p>In class the instructor kept placing work instructions in the delay load slot for the hypothetical processor; neglecting the one real processor we dealt with said in the manual you couldn&#8217;t do that because interrupt save/restore wouldn&#8217;t restore the state to actually run the delay load instruction if an interrupt happened at the right time.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1305805">
				<div id="div-comment-1305805" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305805">
			August 8, 2017 at 5:01 pm</a>		</div>

		<p>@Josuha I love branch delay slots &amp; load delay slots. Having that level of implementation visible to the programmer appeals to my hacker instinct. Yeah you have to be careful, but you can pull some tricks with it. Putting a branch in a branch delay slot for fun and profit.</p>
<p>&#8220;In class the instructor kept placing work instructions in the delay load slot for the hypothetical processor; neglecting the one real processor we dealt with said in the manual you couldn’t do that because interrupt save/restore wouldn’t restore the state to actually run the delay load instruction if an interrupt happened at the right time.&#8221;</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1306326">
				<div id="div-comment-1306326" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Elsayed</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1306326">
			August 12, 2017 at 1:49 pm</a>		</div>

		<p>The problem arises when &#8220;that level of implementation&#8221; &#8211; which may have made sense for the original silicon &#8211; is made obsolete by subsequent advances.</p>
<p>The branch delay slot in MIPS is a wart these days, <em>hindering</em> microarchitectural optimizations that could result in faster/lower-power cores. There&#8217;s a good reason RISC-V left it out :P.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1305535">
				<div id="div-comment-1305535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ted Spence</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305535">
			August 7, 2017 at 8:32 am</a>		</div>

		<p>I was fond of &#8220;skip-if-test&#8221; instructions.  Those were the ones where each test instruction would skip the next instruction if the test was successful, and not skip it if the test failed.  So each &#8220;If x = y then z&#8221; code would compile to a load, a compare, and an unconditional branch that was skipped if the test caused it.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1306335">
				<div id="div-comment-1306335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Elsayed</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1306335">
			August 12, 2017 at 1:54 pm</a>		</div>

		<p>Yeah, predication has some nice uses. It&#8217;s fallen out of favor for modern application CPUs in favor if branch prediction, but it&#8217;s seeing use in new vector stuff, such as the Hwacha project (and the RISC-V ISA&#8217;s vector extension, V).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd odd alt thread-even depth-1 parent" id="comment-1305525">
				<div id="div-comment-1305525" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305525">
			August 7, 2017 at 8:22 am</a>		</div>

		<p>Hey, I loved the Itanium series. I&#8217;ve gone back to re-read it a couple times, and I&#8217;ve shared links to it. </p>
<p>Its made me wonder what Intel could do today with everything they&#8217;ve learned about CPU design. With all the cache, speculative execution, and out of order execution: 95% of the CPU die is dedicated to to the concept of rewriting your program to make it run faster.  Which gave rise to the premise of Itanium: let the compiler do the rewriting of the code; rather than dedicating precious transistors on the CPU die. And it eventually worked &#8211; although regular Xeon eventually caught up. </p>
<p>I wonder if we&#8217;re at the point where RAM is the fundamental limitation, and any further advancements in compilers or silicon gives only tiny marginal improvements, and there&#8217;s no other CPU design that can fundamentally help execution.</p>
<p>But the Itanium series was great.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1305545">
				<div id="div-comment-1305545" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ted Spence</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305545">
			August 7, 2017 at 8:33 am</a>		</div>

		<p>Problem is that even if the compiler understands everything perfectly, the next processor in the series will come out and the optimizations will have to be redone.  So putting a limited amount of rewriting logic in the chip is the best way to do it because you can re-optimize for each generation of the architecture.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-wndsks odd alt thread-odd thread-alt depth-1" id="comment-1305555">
				<div id="div-comment-1305555" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/skSdnW' rel='external nofollow' class='url'>skSdnW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305555">
			August 7, 2017 at 8:51 am</a>		</div>

		<p>I must be the fourth out of two. (Did you check the view stats Raymond?) It might not be that relevant and people might not make that many comments but I think most people still enjoy these posts!</p>
<p>I&#8217;ll take a stab at the exercise; I don&#8217;t know about the win32 ABI but in C the va_* functions are free to do whatever they want and the underlying platform might not store them in a contiguous array which is why va_copy was added later on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zlynx even thread-even depth-1" id="comment-1305566">
				<div id="div-comment-1305566" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zan+Lynx%27' rel='external nofollow' class='url'>Zan Lynx'</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305566">
			August 7, 2017 at 9:03 am</a>		</div>

		<p>I am a big fan of the Itanium design and I read your series on it too. I am sad that it didn&#8217;t take off.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-s-m-joshi-02 odd alt thread-odd thread-alt depth-1 parent" id="comment-1305576">
				<div id="div-comment-1305576" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/camhusmj38' rel='external nofollow' class='url'>camhusmj38</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305576">
			August 7, 2017 at 9:06 am</a>		</div>

		<p>Attempt at the exercise: Is it because the return address is not stored on the stack?<br />
Therefore you can spill the register parameters and still access the whole thing [as in also the stack parameters] as an array.<br />
In x64, you would have the return address in the middle.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1305605">
				<div id="div-comment-1305605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305605">
			August 7, 2017 at 9:48 am</a>		</div>

		<p>Yup, that&#8217;s the answer I came up with.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1305835">
				<div id="div-comment-1305835" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuri Khan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305835">
			August 9, 2017 at 5:21 am</a>		</div>

		<p>int printf(const char *format, &#8230;);<br />
printf(&#8220;%d %f %d %f&#8221;, 42, 3.14, 17, 2.72);</p>
<p>If integer arguments are passed in a0 and a1, and floating arguments in f16 and f17, how does the callee know beforehand which registers to spill, and in which order?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-4" id="comment-1305895">
				<div id="div-comment-1305895" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305895">
			August 9, 2017 at 10:03 am</a>		</div>

		<p>It spills all of them! I&#8217;ll make a note to discuss this in a future installment.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1305595">
				<div id="div-comment-1305595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305595">
			August 7, 2017 at 9:24 am</a>		</div>

		<blockquote><p>Memory size terms in the [64-bit] Alpha AXP instruction set are byte, word (two bytes), longword (four bytes), and quadword (eight bytes).</p></blockquote>
<p>That seemed weird. Wikipedia both agrees (&#8220;In the Alpha architecture, a byte was defined as an 8-bit datum (octet), a word as a 16-bit datum, a longword as a 32-bit datum, a quadword as a 64-bit datum, and an octaword as a 128-bit datum.&#8221;[0]) and disagrees (Under &#8220;Word size w&#8221; for entry &#8220;Alpha&#8221;, the value is &#8220;64b&#8221;[1])</p>
<p>However, looking back at DEC&#8217;s history, the Alpha is the successor to the 32-bit VAX, which is in turn the successor to the 16-bit PDP. By analogy with Windows, where WORD and DWORD have fixed meanings irrespective of the natural word size of the CPU, inherited from Win16 through Win32 to Win64, it would appear that the &#8220;word&#8221; of Alpha chips has been similarly immutable.</p>
<p>So much for technical terms with precise meanings, when backwards-compatibility rears its ugly (but oh so pragmatic) head!</p>
<p>[0] <a href="https://en.wikipedia.org/wiki/Alpha_AXP#Data_types" rel="nofollow">https://en.wikipedia.org/wiki/Alpha_AXP#Data_types</a><br />
[1] <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)#Table_of_word_sizes" rel="nofollow">https://en.wikipedia.org/wiki/Word_(computer_architecture)#Table_of_word_sizes</a></p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1305615">
				<div id="div-comment-1305615" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305615">
			August 7, 2017 at 9:51 am</a>		</div>

		<p>The term &#8220;word&#8221; is being used in two different senses, which is why you see an apparent contradiction. One is as an architecture-defined terminology. The other is as a general computer industry term, where it means the natural operand size. For the Alpha AXP, the architecture-defined terminology for &#8220;word&#8221; is 16-bit, and the natural operand size is 64-bit.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1305625">
				<div id="div-comment-1305625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JoeD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305625">
			August 7, 2017 at 9:56 am</a>		</div>

		<p>Not only did I enjoy reading it, I actually have both an Alpha (DEC Multia UDB) system and an Itanium system in my basement at home. I haven&#8217;t fired them up in a while though.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1305686">
				<div id="div-comment-1305686" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DonH</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305686">
			August 7, 2017 at 3:36 pm</a>		</div>

		<p>Of course not, it&#8217;s summer.  You shouldn&#8217;t need them until about November.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1305935">
				<div id="div-comment-1305935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305935">
			August 9, 2017 at 4:38 pm</a>		</div>

		<p>They also double as counter-surveillance units: nobody can hear what you&#8217;re yelling at them outside of 5 feet! ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1305635">
				<div id="div-comment-1305635" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matteo Italia</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305635">
			August 7, 2017 at 10:27 am</a>		</div>

		<p>Feels like a remarkably clear, well designed architecture, especially compared to the weird memories I have of the Itanium series. I can&#8217;t wait to see if it will live up to these premises.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1306445">
				<div id="div-comment-1306445" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thiago Macieira</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1306445">
			August 14, 2017 at 10:45 pm</a>		</div>

		<p>Famous last words&#8230;</p>
<p>There&#8217;s a reason there&#8217;s a section of multiprocessor documentation of the Linux kernel that starts with &#8220;And then there was Alpha&#8221;</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1305645">
				<div id="div-comment-1305645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Clarkstone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305645">
			August 7, 2017 at 10:54 am</a>		</div>

		<p>In answer to the exercise, I can make and educated guess:</p>
<p>The top-of-stack at time of function entry is the parameters N to 6. This means that the callee is free to push parameters 5 to 0 onto the stack and they will be contiguous with the parameters N to 6. This doesn&#8217;t work in (e.g.) x64 because on the stack the return address and frame pointer(?) would be sandwiched between parameter 6 and parameter 5, but it&#8217;s fine in AXP where those things are kept in registers and only spilled onto the stack if+where the callee wants them to be.</p>
<p>More advanced: In functions like foo(FILE f, int i, char* fmt, &#8230;) you can spill parameters 3-5 onto the stack and needn&#8217;t spill parameters 0-2.</p>
<p>I liked the Itanium series too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1305655">
				<div id="div-comment-1305655" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://adamrosenfield.com' rel='external nofollow' class='url'>Adam Rosenfield</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305655">
			August 7, 2017 at 10:56 am</a>		</div>

		<p>Count me as another that thoroughly enjoyed the arcana of the IA64 series.  Looking forward to the rest of the Alpha AXP series!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1305685">
				<div id="div-comment-1305685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305685">
			August 7, 2017 at 3:16 pm</a>		</div>

		<p>Heh&#8230; Alpha was the model architecture we studied back in university. Never as popular as x86, but far cleaner, and so much better suited for teaching the concepts. I think I still have my old textbook around somewhere&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1305925">
				<div id="div-comment-1305925" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170807-00/?p=96766#comment-1305925">
			August 9, 2017 at 3:32 pm</a>		</div>

		<p>Exercise:   no need for home space because return address is saved in a register rather than pushed to the stack.   If parameters are pushed from right to left, the function is free to spill the first 6 by pushing them on the stack.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

