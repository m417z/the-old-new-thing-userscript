<html>
<head>
<title>Was there a problem with Windows 95-era programs relying on undocumented information disclosure stuff?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Was there a problem with Windows 95-era programs relying on undocumented information disclosure stuff?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 7, 2017 / year-entry #246</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>50</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Surprisingly not.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20100720-01/?p=13383#comment-848523">
Tihiy</a>
noted that back in the Windows 95 days,
there was a lot of undocumented stuff lying around
in places that are formally undefined.
For example, the return value of <code>Is&shy;Window</code>
is formally zero or nonzero, but it turns out that on Windows 95,
the nonzero value actually was a pointer to an internal data structure.
I remember another case where a function returned a value
in <code>EAX</code>,
but it so happened that the <code>ECX</code> register contained
a pointer to some interesting data structure.
</p>
<p>
These bonus undocumented values were not intentional.
In the case of <code>Is&shy;Window</code>,
it was an optimization: Since the only meaningful values
are zero and nonzero, and a null pointer is zero and
a non-null pointer is nonzero,
it was a clever trick to just return the pointer cast to an integer.
In the case of the function that returned a value in <code>ECX</code>,
that was completely unintentional:
It was just a value that the compiler left in the <code>ECX</code> register
by happenstance.
</p>
<p>
Did these undocumented but potentially useful values cause trouble?
</p>
<p>
Surprisingly not.
</p>
<p>
I'm not sure why this was not generally a problem.
My guess is that software developers kept one eye on that
other version of Windows, Windows NT.
Relying on undocumented values wouldn't work on Windows NT,
so the developers had to come up with something that would
work on both.
</p>
<p>
I'm sure there were plenty of software developers who simply
never tested on Windows NT or didn't consider Windows NT to be
part of their customer base.
But the number of those who exploited undocumented return values
was small enough that I barely remember them.
</p>
<p>
<b>Bonus chatter</b>:
I do remember one customer some time around Windows 8
who asked why the contents of the <code>EBX</code> register
no longer contained a copy of the executable's instance handle when
the executable entry point as called.
We were kind of baffled by this question,
because the contents of the <code>EBX</code> register
at the executable entry point are formally undefined.
Indeed, the code never explicitly sets <code>EBX</code> to anything.
The value in <code>EBX</code> is whatever the compiler happened
to be using the <code>EBX</code> register for.
There was no intentional effort to put a particular value
into the <code>EBX</code> register.
It just so happened that the instance handle was something the
compiler decided to put into the <code>EBX</code> register
for 19 years,
and then in year 20, it decided to put something else there.
</p>
<p>
<b>Bonus bonus chatter</b>:
You also shouldn't
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20170906-00/?p=96955#comment-1308415">
sniff the return address to determine how your module was loaded</a>.
That's not part of the API contract either.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (50)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-koldude even thread-even depth-1 parent" id="comment-1314945">
				<div id="div-comment-1314945" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314945">
			November 7, 2017 at 7:48 am</a>		</div>

		<p>These days I would imagine that SDL or security review would stop anything like these sorts of shortcuts from happening (or so I&#8217;d hope) if only to prevent potential unintended information disclosure. Obviously you can&#8217;t depend on what the compiler is going to do; but at least as far as reasonably defined behavior (from a C or C++ language standpoint) you can prevent quite a bit.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2 parent" id="comment-1314965">
				<div id="div-comment-1314965" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314965">
			November 7, 2017 at 10:18 am</a>		</div>

		<p>Not sure what you can do to stop the compiler from leaving an interesting value in the ecx or ebx register. If it&#8217;s all in-process, then you haven&#8217;t crossed a security boundary, so technically you didn&#8217;t make anything any less secure than it already was. (Though you did make it easier.) If the value crosses a security boundary, then we already have steps in place to stop registers not part of the calling convention from leaking out. (Though sometimes we mess up and they leak out anyway, and then we have to fix them.)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong even depth-3 parent" id="comment-1315125">
				<div id="div-comment-1315125" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315125">
			November 7, 2017 at 5:49 pm</a>		</div>

		<p>If the contract just say &#8220;zero or non-zero&#8221;, why don&#8217;t they choose some constant value such as &#8220;1&#8221;? I suppose it&#8217;s efficient to zero the register by default, then increment the register when it should be non-zero.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-fjeldse odd alt depth-4" id="comment-1315145">
				<div id="div-comment-1315145" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Erik+F' rel='external nofollow' class='url'>Erik F</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315145">
			November 7, 2017 at 10:46 pm</a>		</div>

		<p>If you&#8217;re trying to cut as many corners as you can to reduce code (and hopefully by extension, execution time), treating the results of calculations as a Boolean value is quite attractive, because you can just return the exit value of a loop without needing to sanitize it. As long as the caller doesn&#8217;t try to do anything creative with the result, there are no issues with the API contract. Obviously, as Raymond notes, if the calculation discloses sensitive information than it has to be fixed, but as Windows 95 was designed with issues other than security as primary goals, it seems like it was an acceptable tradeoff.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4 parent" id="comment-1315236">
				<div id="div-comment-1315236" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315236">
			November 8, 2017 at 3:28 pm</a>		</div>

		<p>&gt;If the contract just say “zero or non-zero”, why don’t they choose some constant value such as “1”? I suppose it’s efficient to zero the<br />
&gt; register by default, then increment the register when it should be non-zero.</p>
<p>He explained already that it was because it was faster to execute the code that returns 0 or the pointer value.<br />
Your question is therefore: Why didn&#8217;t Microsoft write slower code.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong odd alt depth-5" id="comment-1315285">
				<div id="div-comment-1315285" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315285">
			November 8, 2017 at 7:11 pm</a>		</div>

		<p>Yup. My question is therefore: Why didn’t Microsoft write slower code.</p>
<p>I think both [&#8220;xor&#8221;-ing EAX by itself, and incrementing EAX] and [copy a random register value to EAX] have the similar speed (I remember all these instructions can complete within 3 CPU cycles, will easily got neglected on call-return of function calls), and I think the resulting code will only be 1 byte longer (ref: 64-ia-32-architectures-software-developer-manual-325462.pdf from Intel website, cannot find older versions now).</p>
<p>Not bad for the trade off.</p>
<p>Not bad for preventing people from using the return value in creative way.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-5" id="comment-1315295">
				<div id="div-comment-1315295" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315295">
			November 8, 2017 at 9:30 pm</a>		</div>

		<p>But the code wouldn&#8217;t just be &#8220;returning a zero&#8221; or &#8220;returning a one&#8221;, it would also have to check the existing pointer value to see whether it was zero or non-zero.  I think you could avoid doing a conditional jump using SUB and ADC to conditionally increment the return value, but that would still be more than one byte longer.</p>
<p>(On the other hand, I suspect that the main reason was that at that point it wasn&#8217;t yet obvious that people would be likely to abuse this sort of implementation detail &#8211; or perhaps it wasn&#8217;t obvious that it would be Microsoft&#8217;s problem when they did.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-5" id="comment-1315395">
				<div id="div-comment-1315395" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315395">
			November 10, 2017 at 1:04 am</a>		</div>

		<p>&gt;Yup. My question is therefore: Why didn’t Microsoft write slower code.</p>
<p>&#8220;Stupid Microsoft writing software too slow for my 33mhz 386, forcing me to buy a new computer&#8221; etc etc.</p>
<p>Every byte counted when trying to get it to fit in 4mb ram and ship it on floppy disks.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1314946">
				<div id="div-comment-1314946" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314946">
			November 7, 2017 at 8:13 am</a>		</div>

		<p>I don&#8217;t think there were many serious developers out there using Windows 9x for their IDE. Compilers were big beasts back then, needing fast processors and big amounts of RAM and disk, even for moderately big projects. With those requirements, Windows 9x started to struggle and was less stable than with smaller workloads, while Windows NT was rock-solid (and you already had a powerful enough machine to run it, anyway). Maybe they tried to rely on Windows NT&#8217;s undocumented features, but had to rewrite that out when the code didn&#8217;t work in Windows 9x.</p>
<p>Also, back then, with several platforms offering the Win32 API (Windows 9x, Windows NT, Win32s, Windows CE&#8230;) and a single official documentation, I guess developers were more concerned with complying with the contract. Nowadays, with a &#8220;canonical&#8221; implementation of Win32 and access to many undocumented details on the Internet, things are very different.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1314957">
				<div id="div-comment-1314957" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314957">
			November 7, 2017 at 10:18 am</a>		</div>

		<p>From 1996 to 2000 I did all my development on a Windows 95 computer with 16 megs of RAM and Borland C++. I also discovered that 16 bit was king in Windows 95 and so made all my programs 16 bit. (Also, the 32 bit debugger didn&#8217;t work&#8230;). The only undocumented stuff I ended up depending on was which system menu IDs weren&#8217;t in use, and that only because I read the documentation backwards.</p>
<p>Of course one stupid little mistake in WinProc and the whole machine would hang. You learn to save before run really fast that way.</p>
<p>I did eventually figure out how to get a DLL loaded with no process (can&#8217;t do that except in 16 bit) but try as I might I could get no code in it to run.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1315105">
				<div id="div-comment-1315105" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315105">
			November 7, 2017 at 4:07 pm</a>		</div>

		<p>With 16 MB of RAM, NT 4 Workstation ran quite decently &#8211; Microsoft did a pretty good job optimizing it. Sure, it booted more slowly than Windows 95, but once all services were started, it wasn&#8217;t slower than Windows 95 for most tasks, and the stability meant you didn&#8217;t risk losing an afternoon worth of work if you made a silly mistake. Specially if developing 16 bit software, as you say: 16 bit tasks ran inside an isolated process (the NTVDM, NT virtual DOS machine) in Windows NT, so there was no way they could harm the 32-bit IDE. For me, and for most developers I know, the decision was clear, even when developing DOS applications in Clipper!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1315135">
				<div id="div-comment-1315135" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fabian Giesen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315135">
			November 7, 2017 at 7:25 pm</a>		</div>

		<p>One reason to stick with Win9x as a developer during those years were DirectDraw/Direct3D/DirectSound. If you used any of those, you were out of luck on the NT side before Windows 2000. (You did get OpenGL on NT, and a lot of 3D modelling/CAD apps, which already needed fairly beefy workstations, were NT-centric as a result.)</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1315185">
				<div id="div-comment-1315185" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315185">
			November 8, 2017 at 7:36 am</a>		</div>

		<p>Direct3D was available in Windows NT, too, even if it was restricted to version 3 (a near-final DirectX 5 beta was available as an add-on for the Windows 2000 beta, and it happened to install and run fine in Windows NT 4 SP3, but it was a beta, which removed the stability benefit of NT).</p>
<p>Anyway, if you were developing a game in the 1998-1999 timeframe and relied on DirectX 5, yes, you had no option but to develop on Windows 98 (or have a complicated setup of two networked development and test machines). But that was a pretty narrow spectrum: for most multimedia/casual game developers, DirectX 3 support was more than enough; and productivity applications didn&#8217;t need DirectX at all.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1315245">
				<div id="div-comment-1315245" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315245">
			November 8, 2017 at 3:31 pm</a>		</div>

		<p>I ran windows 95 until I got a dell with an onboard network card that caused it to bluescreen, I tried windows 98 beta but settled on windows nt instead. Which was great until you wanted device drivers and games.</p>
<p>I ran the hacked direct x 5, but windows 2000 beta just wouldn&#8217;t install and run. So I had to wait for the release, but then XP was right around the corner.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even depth-2 parent" id="comment-1315326">
				<div id="div-comment-1315326" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315326">
			November 9, 2017 at 9:45 am</a>		</div>

		<p>Windows 98 on 64M was running Visual C 98 just fine.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1315396">
				<div id="div-comment-1315396" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315396">
			November 10, 2017 at 1:09 am</a>		</div>

		<p>&gt;Windows 98 on 64M was running Visual C 98 just fine.</p>
<p>I didn&#8217;t make it to Windows 98 release before switching to NT. The beta that was out at the time had a file corruption bug when you had 192mb of ram (maybe less but this is what I had). I copied some files onto a network share, then copied them back and each had random corruption.</p>
<p>It seemed the cache was being corrupted over time, but the entries stayed valid for a very long time due to the amount of ram I had. I replaced the ram and had a new motherboard fitted before deciding it was a software issue &amp; NT4 didn&#8217;t suffer from the problem.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1314956">
				<div id="div-comment-1314956" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314956">
			November 7, 2017 at 10:02 am</a>		</div>

		<p>There were several books with names like &#8220;Undocumented Windows&#8221;, and &#8220;Windows Secrets&#8221;.  I don&#8217;t know if these books trumpeted things like this as terrific finds, or not&#8230;..  I didn&#8217;t program in Windows at that level back then.</p>
<p>The EBX register thing was surely a case of &#8220;programming by observation&#8221; instead of programming to a contract.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1315016">
				<div id="div-comment-1315016" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Richard Wells</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315016">
			November 7, 2017 at 11:42 am</a>		</div>

		<p>Undocumented Windows and most of the related works were done for Windows 3. Resulted in lots of unnecessary calls to functions that either were obsoleted or were alternate entry points to standard functions. Windows 95 lucked out as some of the books covering internal data structures were done with the betas in mind and those structures changed by release. No one steals clever tricks that don&#8217;t work on production OSes.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-yuhong-bao even depth-3" id="comment-1315025">
				<div id="div-comment-1315025" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315025">
			November 7, 2017 at 11:46 am</a>		</div>

		<p>They even went so far to obfuscate some pointers using XOR.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kirbyfcf2 odd alt depth-3 parent" id="comment-1315065">
				<div id="div-comment-1315065" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Kirby+FC' rel='external nofollow' class='url'>Kirby FC</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315065">
			November 7, 2017 at 1:44 pm</a>		</div>

		<p>I bought a copy of &#8220;Unauthorized Windows 95&#8221; by Andrew Schulman, right around the same time as Windows 95 (the book was apparently based on a beta version of Win 95).  The author did some dis-assembling of various functions and it was quite interesting to get a glimpse into the inner workings of Windows.  There was one section I still remember because it struck me as pretty weird.</p>
<p>The author was stepping thru some code and came to a place where the code jumped to a weird address &#8212; the address was located in his computers BIOS, specifically the copyright string.  This particular address contained the value 43h, the ASCII code for the letter &#8220;c&#8221;.  It turns out that 43h is also the opcode for an obscure x86 instruction called ARPL.  What ARPL does is irrelevant; what was important was that ARPL is an illegal instruction in protected mode.</p>
<p>Apparently, whenever Windows 95 needed to switch from protected mode to real mode, which apparently happened a lot, it would jump to that address, which is an illegal instruction, which caused an exception, which invoked an error handler and eventually you ended up in real mode (technically &#8220;Virtual x86 mode&#8221;, some sort of real mode-protected mode hybrid)</p>
<p>(I&#8217;m doing this from memory so you&#8217;ll have to read the book for a better explanation. )</p>
<p>I also seem to remember that Mr. Schulman was briefly kicked out of Microsoft&#8217;s forum on CompuServe when the book first came out.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-yuhong-bao even depth-4" id="comment-1315085">
				<div id="div-comment-1315085" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315085">
			November 7, 2017 at 2:53 pm</a>		</div>

		<p>ARPL is an illegal instruction in virtual 8086 mode, but is legal and useful in protected mode. NTVDM uses illegal operands of LDS/LES instructions instead which was used for VEX prefixes. AVX had to be disabled in real and virtual 8086 mode.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-4 parent" id="comment-1315095">
				<div id="div-comment-1315095" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://adamrosenfield.com' rel='external nofollow' class='url'>Adam Rosenfield</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315095">
			November 7, 2017 at 4:01 pm</a>		</div>

		<p>Is this the same story as <a href="https://blogs.msdn.microsoft.com/oldnewthing/20041215-00/?p=37003" rel="nofollow">https://blogs.msdn.microsoft.com/oldnewthing/20041215-00/?p=37003</a> ?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1315166">
				<div id="div-comment-1315166" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Crowther</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315166">
			November 8, 2017 at 2:28 am</a>		</div>

		<p>It is; someone even mentioned the book in the discussion thread.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-4" id="comment-1315466">
				<div id="div-comment-1315466" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315466">
			November 10, 2017 at 10:17 am</a>		</div>

		<p>Schulman loves to build dramatic good vs evil narratives out of ordinary boring engineering. Like Steve Gibson, though admittedly much smarter.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3 parent" id="comment-1315175">
				<div id="div-comment-1315175" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315175">
			November 8, 2017 at 3:23 am</a>		</div>

		<p>Back in the 3.x era you could acquire USER&#8217;s DS and create a far pointer from that and an HWND and start poking&#8230;</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-yuhong-bao odd alt depth-4 parent" id="comment-1315265">
				<div id="div-comment-1315265" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315265">
			November 8, 2017 at 5:20 pm</a>		</div>

		<p>Which also reminds me of the problem of programs assuming that HWNDs are even, including the first version of Publisher using the low bit to do windowless controls in the days just before Windows 3.0 was released. PowerPoint decided to require protected-mode Windows 3.0 from the beginning instead. In retrospect, Windows 3.0 should have been delayed anyway because of DOS 5.0.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-yuhong-bao even depth-5" id="comment-1315275">
				<div id="div-comment-1315275" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315275">
			November 8, 2017 at 5:21 pm</a>		</div>

		<p>Project, not Publisher.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1314975">
				<div id="div-comment-1314975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314975">
			November 7, 2017 at 10:51 am</a>		</div>

		<p>Is the executable entry point actually formally documented?  All I&#8217;ve ever been able to find on MSDN is the entry point the C runtime library calls.  (I&#8217;ve always vaguely assumed that there&#8217;s some sort of documentation somewhere for, e.g., people writing compilers, but I&#8217;ve never been able to find it.)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-koldude even depth-2 parent" id="comment-1315006">
				<div id="div-comment-1315006" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315006">
			November 7, 2017 at 11:21 am</a>		</div>

		<p>Technically yes <a href="https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol" rel="nofollow">https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol</a> has the entry documentation. It&#8217;s a <code>__stdcall</code> method that takes three paramters, <code>(LPVOID var1, DWORD var2, LPVOID var3)</code> what those actually mean is dependent on if it&#8217;s DLL or an Executable.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1315036">
				<div id="div-comment-1315036" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315036">
			November 7, 2017 at 12:49 pm</a>		</div>

		<p>I believe that&#8217;s only for managed images, aka .NET applications.  Pretty sure the entry point for ordinary executables is different.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-koldude even depth-4 parent" id="comment-1315055">
				<div id="div-comment-1315055" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315055">
			November 7, 2017 at 1:25 pm</a>		</div>

		<p>Read the link, that&#8217;s not for managed code. It&#8217;s very explicitly for ld.exe</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1315075">
				<div id="div-comment-1315075" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315075">
			November 7, 2017 at 2:36 pm</a>		</div>

		<p>I *did* read the link.  It says &#8220;When creating a managed image, the function specified to /ENTRY must have a signature of (LPVOID var1, DWORD var2, LPVOID var3).&#8221;</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-4 parent" id="comment-1315195">
				<div id="div-comment-1315195" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315195">
			November 8, 2017 at 8:06 am</a>		</div>

		<p>For DLLs, <a href="https://msdn.microsoft.com/en-us/library/ms682596.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/ms682596.aspx</a> as well as <a href="https://msdn.microsoft.com/en-us/library/ms682583.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/ms682583.aspx</a> give you all the information you need.<br />
In their indefinite wisdom, M$FT decided NOT to document the prototype of the entry point function for applications.<br />
He who but never (well, almost never) writes about undocumented interfaces provides it for you: see <a href="https://blogs.msdn.microsoft.com/oldnewthing/20110525-00/?p=10573" rel="nofollow">https://blogs.msdn.microsoft.com/oldnewthing/20110525-00/?p=10573</a><br />
&#8230;<br />
I wonder whether all these ISVs^Wcompetitors who dared to develop their own compilers and runtimes sued this 2 bit company which can&#8217;t stand 1 bit of competition about that missing piece of documentation.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-5" id="comment-1315226">
				<div id="div-comment-1315226" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315226">
			November 8, 2017 at 12:29 pm</a>		</div>

		<p>Please can you limit yourself to one insult per comment?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even depth-5" id="comment-1315335">
				<div id="div-comment-1315335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315335">
			November 9, 2017 at 9:53 am</a>		</div>

		<p>You need to get that stick out of your rear.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-wndsks odd alt depth-3 parent" id="comment-1315045">
				<div id="div-comment-1315045" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/skSdnW' rel='external nofollow' class='url'>skSdnW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315045">
			November 7, 2017 at 1:01 pm</a>		</div>

		<p>DllMainCRTStartup has the same signature as a normal DllMain but a .exe is void WINAPI (). You can get away with returning int in simple console applications but it is rather risky since Windows will just call ExitThread and not ExitProcess and you don&#8217;t know which APIs create worker threads.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1315086">
				<div id="div-comment-1315086" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315086">
			November 7, 2017 at 3:42 pm</a>		</div>

		<p>In modern versions of Windows, you&#8217;ll always have worker threads (at least for a while after startup) because the loader uses them.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1315115">
				<div id="div-comment-1315115" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315115">
			November 7, 2017 at 5:13 pm</a>		</div>

		<p>I got broke by that change. :(</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-archangelpip even depth-2 parent" id="comment-1315116">
				<div id="div-comment-1315116" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315116">
			November 7, 2017 at 5:17 pm</a>		</div>

		<p>I remember it being formally defined, but as more and more things started to rely on compiler features and systems had enough resources to make just linking with the CRT a simple choice, the documentation for that vanished.<br />
You can still find the information in the MSVCRT/VCRuntime source that comes along with Visual Studio though.<br />
Basically, these are very unlikely to change because of backwards compatibility.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1315367">
				<div id="div-comment-1315367" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315367">
			November 9, 2017 at 12:50 pm</a>		</div>

		<p>Ah.  Yes, that makes sense.</p>
<p>It still pretty much steps on Raymond&#8217;s point IMO, if there&#8217;s no written contract and you have to rely on reverse engineering, it isn&#8217;t obviously all that much less sensible to reverse engineer the loader code that calls the entry point than to reverse engineer the C runtime&#8217;s entry point.</p>
<p>See, for example, <a href="https://stackoverflow.com/a/35108128/886887" rel="nofollow">https://stackoverflow.com/a/35108128/886887</a> &#8211; though admittedly the particular section of code the answer refers to doesn&#8217;t obviously set EBX to any particular value.  :-)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1315306">
				<div id="div-comment-1315306" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stuart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315306">
			November 9, 2017 at 7:37 am</a>		</div>

		<p>For the scenario being discussed in the older post, couldn&#8217;t you achieve much the same thing by having exe1.exe&#8217;s main() method call MyMain(), and then exe2.exe&#8217;s main() would LoadLibrary(&#8220;exe1.exe&#8221;) and call MyMain() as well? Unless I&#8217;m missing something really obvious, that&#8217;d achieve exactly the same thing without needing to screw around with complicated and undocumented entry point stuff.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1315365">
				<div id="div-comment-1315365" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315365">
			November 9, 2017 at 12:45 pm</a>		</div>

		<p>The problem is that when exe1.exe gets loaded via LoadLibrary its entry point will be called, and that call has to return promptly or the process gets borked.  So the entry point has to call main() if it is being run as an executable, or return promptly if it is being loaded as a DLL.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1314985">
				<div id="div-comment-1314985" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314985">
			November 7, 2017 at 11:17 am</a>		</div>

		<p>In reply to the bonus bonus chatter: As handling of asynchronous code becomes more sophisticated, the ability to use a &#8220;call stack&#8221; to form of causality chain becomes weaker.  Even if has worked for years, it would not surprise me at all for code reliant on return addresses to fail in the future.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1314995">
				<div id="div-comment-1314995" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1314995">
			November 7, 2017 at 11:18 am</a>		</div>

		<p>Something else like this: GetTickCount in NT 5.2 (Win2003, XP x64) actually happens to return a valid value in EDX (or high half of RAX) that makes the result 64-bit, so you could effectively use it as GetTickCount64, if you did something like:</p>
<p>reinterpret_cast&lt;ULONGLONG (WINAPI *)()&gt;(GetTickCount)()</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1315026">
				<div id="div-comment-1315026" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BZ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315026">
			November 7, 2017 at 12:38 pm</a>		</div>

		<p>I think dev guidelines for Windows 95 stated that your program must run on NT 3.51. Of course I admit to never testing any of my code on any version of Windows NT. Until 2000 which is when I switched. Then again, my only references back then were MSDN and &#8220;Programming Windows&#8221;, so I didn&#8217;t do anything undocumented.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1315066">
				<div id="div-comment-1315066" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315066">
			November 7, 2017 at 2:27 pm</a>		</div>

		<p>There were many cases in early Windows versions where &#8220;handles&#8221; were actually just pointers to internal memory structures, or slightly disguised pointers.  This was very useful when CryptoAPI came out because the &#8220;handle&#8221; it gave you could be turned into a pointer to internal data structures, which included a flag controlling whether strong crypto was enabled for non-US users.  So you could grab the handle and change the flag that enabled strong crypto, turning it on for global users.<br />
Of course you could also extract the victim^H^H^Huser&#8217;s private keys that way, and all sorts of other things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1315165">
				<div id="div-comment-1315165" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Søren Mors</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315165">
			November 8, 2017 at 2:22 am</a>		</div>

		<p>I believe that a lot of use of undocumented/undefined functionality is by accident. You write some code that seems right, run it and it works. Hey, were done. But you don&#8217;t end up relying on the value in a register being usefull by accident (unless you are writing assembler). Sure, you can get c to tell you what the contents of the register is, but then you are far of from something that happens by accident.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1315215">
				<div id="div-comment-1315215" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315215">
			November 8, 2017 at 10:55 am</a>		</div>

		<p>I loved those &#8220;Undocumented Whatever&#8221; books back in the day.  They were a great way to learn about the architecture of systems even if you didn&#8217;t use any of the undocumented stuff directly.  And you also learned a lot of useful debugging techniques.</p>
<p>And I believe that there there were occasions when using undocumented APIs/data structures/etc was really the only reasonable way to perform certain (also reasonable) functions.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1315296">
				<div id="div-comment-1315296" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">OldBoyCoder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315296">
			November 9, 2017 at 12:14 am</a>		</div>

		<p>Agreed, back in the early nineties we were developing for Windows for the first time and there just wasn&#8217;t a lot of documentation full stop,  no stack overflow and no web to search for someone with the same problems as you were having.  While I don&#8217;t think we ever used any of the undocumented stuff in our production apps having the books really helped me understand and debug Windows issues back then.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt depth-2" id="comment-1315387">
				<div id="div-comment-1315387" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20171107-00/?p=97356#comment-1315387">
			November 9, 2017 at 6:03 pm</a>		</div>

		<p>Not only Windows. Back when I was in secondary school, the school library have subscription to some programming magazine that have a column that explores different undocumented aspects of VC++ and BorlandC++ compilers.</p>
<p>Yeah, we did think people who can write those &#8220;undocumented&#8221; stuffs is cool.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

