<html>
<head>
<title>Some parts of an interface can change but others can't</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Some parts of an interface can change but others can&#8217;t</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 10, 2014 / year-entry #242</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>25</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">When I wrote about asking the compiler to answer calling convention questions, some people were concerned about whether this was a reliable mechanism or whether it was relying on something that can change in the future. This is a special case of the question, "What parts of an interface can change, and what can't?" And...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
When I wrote about
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2013/02/20/10395379.aspx">
asking the compiler to answer calling convention questions</a>,
some people were concerned about whether this was a reliable mechanism
or whether it was relying on something that can change in the future.
</p>
<p>
This is a special case of the question,
"What parts of an interface can change, and what can't?"
And it all boils down to compile-time versus run-time.
</p>
<p>
Assuming you are interested in binary compatibility
(as opposed to merely source compatibility),
then
a decision made at compile-time can never be changed
because the decision is already hard-coded into the application.
For example, if you have a function that takes a parameter that is
an enumeration, say,
</p>
<pre>
enum FOO_OPTIONS
{
    FOO_HOP = 0,
    FOO_SKIP = 1,
    FOO_JUMP = 2,
};
</pre>
<p>
then the values of
<code>FOO_<wbr>HOP</code>,
<code>FOO_<wbr>SKIP</code>,
and
<code>FOO_<wbr>JUMP</code>
are hard-coded into any program that uses them.
The compiler will generate code like this:
</p>
<pre>
; foo(FOO_JUMP);

    push 2
    call foo
</pre>
<p>
Suppose you later change the header file to
</p>
<pre>
enum FOO_OPTIONS
{
    FOO_HOP = 2,
    FOO_SKIP = 3,
    FOO_JUMP = 4,
};
</pre>
<p>
Making a change in the new version of a header file
has no effect on any existing programs which were
compiled with the old version of the header file.
There is no way for the <code>foo</code> function to tell
whether the <code>2</code> it received as a parameter is a
<code>FOO_<wbr>JUMP</code> from the old header file or
a <code>FOO_<wbr>HOP</code> from the new one.
</p>
<p>
Therefore, you cannot reuse values in any
existing enumerations
or <code>#define</code>'s because the values are already compiled
into existing programs.
If you had given the value <code>2</code> different meanings in different
versions of the header file,
you would have in principle
no way of knowing which header file the caller used.
Of course, you can invent external cues to let you figure it out;
for example, there may be a separate <code>set_<wbr>foo_<wbr>version</code>
function
that callers use in order to specify whether they are using the
old or new header file.
Of course, that also means that if there are multiple components that
disagree on what version of <code>foo</code> they want,
you have another problem.
</p>
<p>
Note that this is not the same as saying that the value of a symbol
cannot change.
We've seen this happen in the past
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2009/04/23/9564015.aspx">
with the <code>PSH_<wbr>WIZARD&shy;97</code> flag</a>,
but these sorts of redirections are rare in practice.
</p>
<p>
Another thing that is hard-coded into an application is the calling
convention.
Once code is generated by the compiler to call a function,
that's that.
You can't change the calling convention without breaking existing code.
That's why you can ask the compiler,
"How would you call this function?"
and trust the answer:
If the compiler generates code to call the function using technique&nbsp;X
(register set-up, what gets pushed on the stack first, <i>etc</i>.),
then
the function had better accept technique&nbsp;X in perpetuity.
Of course, you need to be sure that what you observe is in fact all
there is.
There may be parts of the calling convention that are not obvious to you,
such as
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/02/47184.aspx">
the presence of a red zone</a>
or
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx">
maintaining a particular stack alignment</a>.
Or it could be that the function is called only from within
the module, and the compiler's whole-program optimization decided
to use a custom nonstandard calling convention.
</p>
<p>
On the other hand, things determined at run-time can be changed,
provided they are changed in a manner consistent with their original
documentation.
For example, the message numbers returned by
<code>Register&shy;Window&shy;Message</code> can change
because the documentation specifically requires you to call
<code>Register&shy;Window&shy;Message</code> to obtain the
message number for a particular named message.
</p>
<p>
If you want to know how to call a function,
it's perfectly valid to ask the compiler,
because at the end of the day,
that's how the function gets called.
It's all machine code.
Whether that machine code was generated by a compiler
or by an assembler is irrelevant.
</p>
<p>
<b>Caveat</b>: I'm ignoring whole-program optimization
and link-time code generation,
which allow the toolchain to rewrite calling conventions
if all callers can be identified.
We'll see more about this in a future article.
The technique described in this article works best with
exported/imported functions,
because it is not possible to identify all callers of
such functions,
and the compiler is forced to use the official calling convention.
(You can also use it when inspecting .COD files for
functions defined in a separate translation unit,
for the same reason.
That's the technique I used in the linked article.)</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (25)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1155023">
				<div id="div-comment-1155023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155023">
			October 10, 2014 at 7:22 am</a>		</div>

		<p>Which is why you can export a variable from a DLL. The fixup is the same as for take address of function so the loader always handled it just fine.</p>
<p>I keep on having trouble explaining to coworkers about binary comparability. Somehow &quot;don&#39;t change enum values for enums written to the database&quot; doesn&#39;t sink in. One guy thought he could get out of it by using implicit enums. Figures he tried to insert one in the middle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155033">
				<div id="div-comment-1155033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155033">
			October 10, 2014 at 10:16 am</a>		</div>

		<p>Or, &quot;If you think your compiler is going to generate working code _at all_, then you can trust it.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155043">
				<div id="div-comment-1155043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155043">
			October 10, 2014 at 10:20 am</a>		</div>

		<p>@Joshua Perhaps everyone should have to take assembler at some point. &nbsp;If you don&#39;t grock what an enum really is, things like your coworker are going to repeat themselves ad naseum. &nbsp;Other &quot;magical&quot; things would appear far less magical as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155073">
				<div id="div-comment-1155073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155073">
			October 10, 2014 at 1:58 pm</a>		</div>

		<p>@Steve Wolf: &quot;Perhaps everyone should have to take assembler at some point.&quot;</p>
<p>Assuming you&#39;re talking about a CS degree, I&#39;m under the impression that that&#39;s pretty much already true most places if not all. It was definitely part of the CS bachelor&#39;s requirement at both my undergrad and grad schools, and my undergrad in particular isn&#39;t exactly a stand-out university.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155093">
				<div id="div-comment-1155093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155093">
			October 10, 2014 at 3:21 pm</a>		</div>

		<p>Unfortunately Evan is right. They teach assembler at undergrad level but it&#39;s really easy to get a passing grade without understanding any of how assembly language corresponds to compiler output at all, so they still think its magical. Maybe if the compiler design class actually had to compile a primitive language all the way down to assembly they would get it but that&#39;s a grad-student level course.</p>
<p>Maybe there&#39;s a better way to chase away magical thinking but I don&#39;t know of one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155103">
				<div id="div-comment-1155103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155103">
			October 10, 2014 at 3:24 pm</a>		</div>

		<p>@Evan:</p>
<p>These days they seem to like Java more than anything.</p>
<p>While I was doing mine, there was mostly Delphi/C with a few other things mixed in. But it has been transitioning more and more away from the lower level machine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155113">
				<div id="div-comment-1155113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155113">
			October 10, 2014 at 3:26 pm</a>		</div>

		<p>@Joshua:</p>
<p>The compiler design code that I know don&#39;t actually output working code of any sort. They went to three address code at most.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155123">
				<div id="div-comment-1155123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155123">
			October 10, 2014 at 4:00 pm</a>		</div>

		<p>&gt; Of course, you can invent external cues to let you figure it out</p>
<p>And one of the worst and actually implemented way to do that was the invention of Common Controls manifest.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155133">
				<div id="div-comment-1155133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155133">
			October 10, 2014 at 4:24 pm</a>		</div>

		<p>We did a little ARM assembly at Southampton in first year. It was great. There was a lab where you had to write a load of ARM Thumb assembly that was loaded using a small C wrapper that they provided the compiler&#39;s assembly output of only. An extension task, which I performed, was to decompile the assembly output for the wrapper program back to C. That was fun.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155153">
				<div id="div-comment-1155153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155153">
			October 10, 2014 at 4:31 pm</a>		</div>

		<p>@Muzer: &quot;An extension task, which I performed, was to decompile the assembly output for the wrapper program back to C. That was fun.&quot;</p>
<p>IIRC, our final ASM project in undergrad was to write a partial disassembler in assembly. (MIPS.) That was kind of a fun project, though I perhaps broke the spirit slightly by coding it first in a strange way in C and then &quot;manually compiling&quot; it to MIPS after I ran into a couple annoying bugs.</p>
<p>One thing I was really proud of was that the program didn&#39;t even come close to following the usual calling conventions &#8212; except for a couple functions, I was able to partition the registers between the different functions so that you could just call back and forth without doing any saving or restoring of registers, because you knew what all of the transitive callees would use and that they wouldn&#39;t clobber your data. I figured if you&#39;re going to program in ASM, might as well try to eke some extra performance out of it and do something the compiler would be very unlikely to do. Despite explicit instructions at the start of the course that we didn&#39;t _have_ to follow calling conventions, we got docked for that; one of the few times I&#39;ve actually argued for points lost on a project.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155163">
				<div id="div-comment-1155163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155163">
			October 10, 2014 at 4:33 pm</a>		</div>

		<p>&quot;we got docked for that&quot;</p>
<p>I even submitted the text file that had the call graph of the programs and which registers were used where so that you could see at a glance the program was correct. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155173">
				<div id="div-comment-1155173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155173">
			October 10, 2014 at 5:26 pm</a>		</div>

		<p>Worth remembering that calling-conventions are, of course, architecture specific.</p>
<p>So if your compiler says &quot;Oh, the way you call functions in KERNEL32 is your push all the parameters on the stack and call it&quot; that assumption holds for your current architecture &#8211; x86 &#8211; but not for other architectures like ARM or x64.</p>
<p>Or if you say, &quot;Oh, I know that parameter is eight bytes above the address of this local variable I just got via the &amp; operator&quot;, that assumption is extremely fragile and liable to break on other compilers and architectures.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155183">
				<div id="div-comment-1155183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155183">
			October 10, 2014 at 5:51 pm</a>		</div>

		<p>@Evan &quot;I figured if you&#39;re going to program in ASM, might as well try to eke some extra performance out of it and do something the compiler would be very unlikely to do&quot;</p>
<p>Compilers routinely do that. It&#39;s called &quot;Whole Program Optimization&quot;. You were just doing that by hand.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155193">
				<div id="div-comment-1155193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155193">
			October 10, 2014 at 8:03 pm</a>		</div>

		<p>My feeling is that if you can&#39;t grok that you can&#39;t change an enum that&#39;s already been saved in a database, taking an assembly class isn&#39;t going to help you.</p>
<p>I once had an argument with somebody who thought it was possible that Microsoft might someday increase MAXIMUM_WAIT_OBJECTS to be more than 64. He didn&#39;t seem to understand that the number 64 is now hard-coded into countless different DLLs that aren&#39;t going to be recompiled.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155143">
				<div id="div-comment-1155143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155143">
			October 10, 2014 at 4:25 pm</a>		</div>

		<p>@Crescens2k: &quot;These days they seem to like Java more than anything.&quot;</p>
<p>It&#39;s been a little while since undergrad (&lt;10 yrs, but not a lot less), but not since I was in grad school. Sure, the curriculum still starts out in Java, and some higher-level classes use it. (I, um, may have taught a compiler class a couple times that targeted JVM bytecode. That was an undergrad class, BTW, which *also* seems to be available quite standardly &#8212; though as an elective and not required.) But what I say still applies: I think a class that involves assembly (often combined with processor design and some VHDL work) is still _very_ typical.</p>
<p>I think Joshua&#39;s diagnosis is probably closer to the mark: the connection between the C and asm isn&#39;t there. Although I&#39;d argue it&#39;s also not really the place of University classes to hit something like the enum thing: that&#39;s a fairly C-specific artifact I&#39;d say.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155223">
				<div id="div-comment-1155223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155223">
			October 11, 2014 at 9:34 am</a>		</div>

		<p>@Gabe: Well it could be increased to (WAIT_ABANDONED_0 &#8211; WAIT_OBJECT_0). I&#39;m too lazy to see if that really is 64 or not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn even thread-even depth-1" id="comment-1155233">
				<div id="div-comment-1155233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155233">
			October 11, 2014 at 9:39 am</a>		</div>

		<p>Gabe, the value may be increased probably. It cannot be changed to less than 64 without causing innumerable problems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jan-ringos odd alt thread-odd thread-alt depth-1" id="comment-1155253">
				<div id="div-comment-1155253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Jan+Ringo%C5%A1' rel='external nofollow' class='url'>Jan Ringoš</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155253">
			October 11, 2014 at 11:05 am</a>		</div>

		<p>@Joshua: It can&#39;t be increased because: WAIT_IO_COMPLETION &#8211; WAIT_ABANDONED_0 = 64. You would need a completely new API, which would be great by the way, but it would simultaneously needed to be seriously backported for it to be useful sooner than in 20 years &#8230;and that rarely ever happens.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155313">
				<div id="div-comment-1155313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155313">
			October 12, 2014 at 6:41 am</a>		</div>

		<p>@Evan: Were they docking you for violating standard calling conventions, or for not following *any* convention standard or otherwise? &nbsp;Because the latter seems a little more defensible to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155383">
				<div id="div-comment-1155383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155383">
			October 13, 2014 at 10:47 am</a>		</div>

		<p>@Jan Ringoš: no need to backport, just create a helper library which calls the new API using GetProcAddress, and if it&#39;s not found, emulates it. You lose some performance due to the impedance mismatch on older systems, and lose a very small amount of performance on new systems due to the indirect call, but gain in programming effort and cleaner code. After a few decades, the code can be changed to call the new API directly (removing the helper library) to force your users to upgrade.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155403">
				<div id="div-comment-1155403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marc K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155403">
			October 13, 2014 at 11:52 am</a>		</div>

		<p>@Azarien: &quot;&#8230;was the invention of Common Controls manifest.&quot;</p>
<p>Indeed&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155413">
				<div id="div-comment-1155413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155413">
			October 13, 2014 at 1:21 pm</a>		</div>

		<p>@Cesar: Indeed a form of said emulation already exists in Cygwin, where they can wait for up to 1024 sockets.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155493">
				<div id="div-comment-1155493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155493">
			October 13, 2014 at 4:23 pm</a>		</div>

		<p>The rumor has been that link-time code generation on the original Xbox was the biggest reason that the Xbox 360 had so little backward compatibility: with link-time code generation, it was impossible in general to do high-level emulation of the DirectX API.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1155553">
				<div id="div-comment-1155553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155553">
			October 14, 2014 at 6:05 am</a>		</div>

		<p>@Myria: Wait, but LTCG doesn&#39;t affect functions linked from DLLs? And if you link against static libraries built without /LTCG it too won&#39;t do dirty tricks, so&#8230; the rumor is the original XBox games were linked against static DirectX library binaries built with /LTCG flag on?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1155663">
				<div id="div-comment-1155663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141010-00/?p=43873#comment-1155663">
			October 14, 2014 at 4:50 pm</a>		</div>

		<p>@Joker_VD: I know that they were. &nbsp;The kernel had very little to do with the graphics system, and the original Xbox had no DLLs. &nbsp;(Well, it had them in debug mode, but release titles weren&#39;t allowed to use them. &nbsp;The retail kernel had the ability to load DLLs compiled out.)</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

