<html>
<head>
<title>Why are the module timestamps in Windows 10 so nonsensical?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why are the module timestamps in Windows 10 so nonsensical?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 3, 2018 / year-entry #2</td></tr>
<tr><td><b>Tags:</b></td><td>other;tipssupport</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>24</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">They're really a uniqueness identifier.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
One of the fields in the Portable Executable (PE) header is called
<code>TimeDateStamp</code>.
It's a 32-bit value representing the time the file was created,
in the form of seconds since January 1, 1970 UTC.
But starting in Windows 10, those timestamps are all nonsense.
If you look at the timestamps of various files, you'll see that
they appear to be random numbers, completely unrelated to any
timestamp.
What's going on?
</p>
<p>
One of the changes to the Windows engineering system begun in Windows 10
is the move toward <i>reproducible builds</i>.
This means that if you start with the exact same source code,
then you should finish with the exact same binary code.
</p>
<p>
There are lots of things that hamper reproducibility.
One source is the language itself.
For example,
anonymous namespaces may not have a programmatically-accessible name,
but since the objects within it have external linkage, they need to have
a name nonetheless,
and the name must be different for different source files.
How does it ensure the names are unique?
Does the compiler use a random number generator to generate these names?
Is it a hash of the file name?
</p>
<p>
Another source is the compiler's internal code generation algorithms.
For example, if a compiler chooses between two optimizations depending
how much RAM is available, or how powerful the processor is,
then that prevents the result from being reproducible because two
systems with different hardware configurations may end up producing
different outputs.
Or if the optimizer has a failsafe switch that abandons an operation
if the algorithm is still running after 500ms.
Or if the optimizer uses a
<a HREF="https://www.researchgate.net/publication/256446775_New_Non-deterministic_Approaches_for_Register_Allocation">
non-deterministic register allocation strategy</a>.
Or if the compiler uses a deterministic algorithm
("sort all local variables") but uses a non-determinstic
criterion ("... by the heap address of the data structure we use
to keep track of each variable.").
</p>
<p>
There are also inputs to the system outside the compiler that
hamper reproducibility.
For example, the full path to the file being compiled will show
up in <code>__FILE__</code> preprocessor directives,
which will cause problems when built from different machines
with different names for the root directory that holds the source code.
(Or even from the same machine with two copies of the source code.)
There may be files auto-generated by the build process that go into
the compiler (for example, the output of compiler-compilers);
those need to be deterministic too.
</p>
<p>
Timestamps are another source of non-determinism.
Even if all the inputs are identical,
the outputs will still be different because of the timestamps.
</p>
<p>
Okay, at least we can fix the issue with the file format.
Setting the timestamp to be a hash of the resulting binary
preserves reproducibility.
</p>
<p>
"Okay, but why not set the file timestamp to the
the timestamp of the source code
the binary was created from?
That way, it's still a timestamp at least."
That still breaks reproducibility, because that means that touching a file
without making any changes will result in a change in binary output.
</p>
<p>
Remember what the timestamp is used for:
It's used by the module loader to determine
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20100318-00/?p=14563">
whether bound imports should be trusted</a>.
We've already seen cases where the timestamp is inaccurate.
For example, if you rebind a DLL, then the rebound DLL has the same
timestamp as the original,
rather than the timestamp of the rebind,
because you don't want to break the bindings of other DLLs that bound to
your DLL.
</p>
<p>
So the timestamp is already unreliable.
</p>
<p>
The timestamp is really a unique ID that tells the loader,
"The exports of this DLL have not changed since the last time
anybody bound to it."
And a hash is a reproducible unique ID.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (25)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1319585">
				<div id="div-comment-1319585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319585">
			January 3, 2018 at 7:08 am</a>		</div>

		<p>And, as many folks know, &#8221; a 32-bit value representing &#8230; seconds since January 1, 1970 UTC&#8221; is the traditional &#8220;Unix time&#8221; that has been abandoned by everyone who remembers &#8220;Y2K&#8221;.  It will be rolling back to 1970 in about 20 years.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-jeremytais odd alt depth-2" id="comment-1319595">
				<div id="div-comment-1319595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/SimonRev' rel='external nofollow' class='url'>SimonRev</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319595">
			January 3, 2018 at 7:13 am</a>		</div>

		<p>Actually, as it is a signed 32 bit integer, it will be rolling back to 1902 or somewhere thereabouts.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude even thread-odd thread-alt depth-1 parent" id="comment-1319596">
				<div id="div-comment-1319596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319596">
			January 3, 2018 at 7:29 am</a>		</div>

		<p>at least as of n4659 6.5.3.3 says: <i>An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage. All other namespaces have external linkage.</i> I know that MSVC didn&#8217;t use to respect this but as far as I&#8217;m aware as of VS 2013 this was being respected IIRC.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1319616">
				<div id="div-comment-1319616" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319616">
			January 3, 2018 at 8:14 am</a>		</div>

		<p>And I am quite sure that Windows is not built using MSVC. It might be something based on MSVC, but the compiler would be different for internal consumption only.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1319645">
				<div id="div-comment-1319645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319645">
			January 3, 2018 at 9:14 am</a>		</div>

		<p>As far as I am aware, the NT kernel (and I could list the other important bits of Windows, but I won&#8217;t) are indeed built by the compiler that sits underneath MSVC.  And tested against that compiler.  And indeed debugged against that compiler (I have done this on occasion).</p>
<p>I&#8217;m not entirely sure why anybody would think otherwise.  The timelines might be different: my group was stuck on VS10 for quite a lot of years, mostly because the tool-set for builds hadn&#8217;t caught up and/or been signed off, and the actual build tools are based on the command line rather than on a GUI (this is hardly a surprise), but &#8212; nope, the compiler is the compiler.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-koldude odd alt depth-4" id="comment-1319675">
				<div id="div-comment-1319675" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319675">
			January 3, 2018 at 9:33 am</a>		</div>

		<p>Peeking at the headers for ntdll and gdi32 it shows the linker version as 14.10 which would be a VS2013 update, as far as I know the external linkage for unnamed namespaces was fixed prior that version (I removed a lot of <code>static</code> function prefixes when I migrated and verified this wasn&#8217;t happening any more). I would not be surprised if insider builds are testing against newer compiler versons. Even windows devs want new C++ features. Given that parts of the vNext release SDK depends on compiler version 15.3 or later (c++ coroutines in the CppWINRT sdk components) this may be changing.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1319667">
				<div id="div-comment-1319667" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319667">
			January 3, 2018 at 9:29 am</a>		</div>

		<p>Okay, then lambdas. Or template functions which take as type parameters types in unnamed namespaces.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1319605">
				<div id="div-comment-1319605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319605">
			January 3, 2018 at 7:39 am</a>		</div>

		<p>I&#8217;m curious about the reason behind needing reproducible builds, given all the challenges involved. Is it a trust thing, where somebody has audited a particular version of the source code, and needs to make sure that they can create the same compiled bits that are deployed somewhere? If so, I think you&#8217;d need a compiler that was also made from a reproducible build, preferably at least two from different vendors so that you can check their work with each other to ensure that there isn&#8217;t anything nefarious hidden inside the compiler.</p>
<p>Seems like quite the challenge, though I know some fields (gambling machines, cryptocurrency back-ends, and so forth) find it worth the hassle.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1319615">
				<div id="div-comment-1319615" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319615">
			January 3, 2018 at 8:12 am</a>		</div>

		<p>One example is the gaming (gambling) industry.  Gaming machines (slot machines, etc.) get their software certified by a commission who tests that the software is &#8220;fair&#8221;.  Any change to that software must be recertified (which is an expensive process).  As a result, you need a way to rebuild the same source into a PE file with the same hash as the original build.  I assume there are other industries with similar rules</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1319625">
				<div id="div-comment-1319625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319625">
			January 3, 2018 at 8:16 am</a>		</div>

		<p>Reproducible outputs also have the side effect of ensuring compiler always hits the same bug, in case it has any.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1319665">
				<div id="div-comment-1319665" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319665">
			January 3, 2018 at 9:18 am</a>		</div>

		<p>Which makes it massively easier to debug the problem, reason about the bug, and fix it.</p>
<p>Sans a provably bug-free release of any program whatsoever, I can&#8217;t see why you feel this is a worrying feature.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1319975">
				<div id="div-comment-1319975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tanveer Badar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319975">
			January 5, 2018 at 9:59 pm</a>		</div>

		<p>How did you arrive at the conclusion that I think it is a worrying feature? It is a very good feature.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1319627">
				<div id="div-comment-1319627" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319627">
			January 3, 2018 at 8:30 am</a>		</div>

		<p>Right. I guess what I was asking was whether they needed to do this because there are, for example, some slot machine manufacturers that want their product to run on Windows 10, though I suppose that&#8217;s not a question that I&#8217;m going to actually get an answer to here.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1319636">
				<div id="div-comment-1319636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.differentpla.net/' rel='external nofollow' class='url'>Roger Lipscombe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319636">
			January 3, 2018 at 9:11 am</a>		</div>

		<p><a href="https://reproducible-builds.org/" rel="nofollow">https://reproducible-builds.org/</a> has a pretty good explanation of the motivation behind reproducible builds: primarily that you can be sure that a given set of binaries comes from a given set of source files (and toolchain). If the binary changes each time you rebuild the source (even if it&#8217;s unchanged), you lose the ability to make that determination.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1319655">
				<div id="div-comment-1319655" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319655">
			January 3, 2018 at 9:17 am</a>		</div>

		<p><a href="https://www.chromium.org/developers/testing/isolated-testing/deterministic-builds" rel="nofollow">Reproducible builds are essential for build caches</a> and <a href="http://blog.paranoidcoding.com/2016/04/05/deterministic-builds-in-roslyn.html" rel="nofollow">reducing testing time</a>. Hash all the inputs to a build tool, see if you&#8217;ve built that thing already, if so, then grab the precompiled result. Consider: You added a #define to windows.h, so every C file needs to recompile, but almost nobody uses that #define, so the OBJ files are nearly all the same, and therefore you still get tons of cache hits on the linker. And nearly all of the resulting EXEs are byte-for-byte identical, so you don&#8217;t need to re-test them. If the output of the compiler were not reproducible, then you wouldn&#8217;t get a cache hit on the OBJ files, and you end up having to rebuild and re-test the entire system, for a #define that almost nobody uses!</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1319685">
				<div id="div-comment-1319685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319685">
			January 3, 2018 at 9:46 am</a>		</div>

		<p>Wow, that&#8217;s interesting.  I hadn&#8217;t thought of those aspects &#8212; not having to re-test binaries that are byte-identical with a tested binary.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1319705">
				<div id="div-comment-1319705" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319705">
			January 3, 2018 at 12:54 pm</a>		</div>

		<p>Thank you very much for the reply. I was trying to figure out if there was any motivation beyond just the legal/trust ones, and those links show me that there&#8217;s a lot with the build process of large systems that can benefit.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1319715">
				<div id="div-comment-1319715" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319715">
			January 3, 2018 at 5:52 pm</a>		</div>

		<p>Same here.  In the security field we specifically want non-reproducible builds, or at least builds that are as different to each other as possible, because having everything laid out exactly identically in each build of a binary makes things much easier for attackers.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1319765">
				<div id="div-comment-1319765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319765">
			January 4, 2018 at 8:59 am</a>		</div>

		<p>You also want that when building DirectX for the xbox, to prevent someone from patching the games to use desktop windows dll&#8217;s</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1320245">
				<div id="div-comment-1320245" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://ted.mielczarek.org/' rel='external nofollow' class='url'>Ted Mielczarek</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1320245">
			January 9, 2018 at 10:41 am</a>		</div>

		<p>On top of what everyone else has said, we&#8217;ve found that for our work on Firefox having a reproducible build makes reasoning about changes to the build much easier. If you can generate the same exact binaries from the same source, then you can diff the build outputs when you make changes to the build and you don&#8217;t get lost in a sea of noise.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1319725">
				<div id="div-comment-1319725" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319725">
			January 4, 2018 at 2:44 am</a>		</div>

		<p>This seems like it&#8217;s throwing out a number of fairly useful things for &#8220;reproducable builds&#8221; which are of little or no interest to most people.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd odd alt thread-even depth-1" id="comment-1319926">
				<div id="div-comment-1319926" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319926">
			January 5, 2018 at 11:53 am</a>		</div>

		<p>For people who have been trying to reverse engineer the PDB format, this little tidbit finally explains a problem: why module timestamps were so non-sensical in Windows 10.</p>
<p>For a while i wondered if it was changed so that 1 tick is 2 seconds, and the high-bit is set to indicate this custom behavior.</p>
<p>This is nice to have.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-odd thread-alt depth-1" id="comment-1319965">
				<div id="div-comment-1319965" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1319965">
			January 5, 2018 at 6:19 pm</a>		</div>

		<p>The timestamp was once used to identify the PDB file and to store it on a symbol server. These days it&#8217;s a GUID combined with generation (&#8220;age&#8221;) count. The &#8220;age&#8221; counter increments every time the binary gets built. The GUID persists until you delete the whole build directory. When you build a binary from scratch, the PDB gets a new GUID.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1320005">
				<div id="div-comment-1320005" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1320005">
			January 7, 2018 at 5:29 pm</a>		</div>

		<p>When was it ever a good decision to include this much random noise into a compiled binary? What were you thinking? If you would have been a bit more careful before implementing these noise generators in your tool chain, you wouldn&#8217;t have needed to refactor your whole tool chain from scratch. Of course, even with a tool chain claiming to generate reproducible results, there&#8217;s no guarantees, noone can count on it, you have the assume worst-case anyway, i.e. random noise in every other byte.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1320555">
				<div id="div-comment-1320555" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://randomascii.wordpress.com/' rel='external nofollow' class='url'>Bruce Dawson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705#comment-1320555">
			January 11, 2018 at 3:20 pm</a>		</div>

		<p>What about the GUID/age that are embedded in the binary? Are these also reproducible, or are they exempted from the reproducibility checking?</p>
<p>&gt; The timestamp is really a unique ID that tells the loader</p>
<p>Well, that is *one* use of the timestamp. Another use is as part of the unique ID used when inserting PE files into a symbol server, as described here:<br />
<a href="https://randomascii.wordpress.com/2013/03/09/symbols-the-microsoft-way/" rel="nofollow">https://randomascii.wordpress.com/2013/03/09/symbols-the-microsoft-way/</a></p>
<p>In particular note that the path for a PE file on a symbol server is generated like this:</p>
<p>    “%s\%s\%s%s\%s” % (serverName, peName, timeStamp, imageSize, peName)</p>
<p>Since the peName stays the same for a particular binary, and the imageSize frequently stays the same, the timeStamp *must* be different for every build to avoid collisions. And, 32 bits isn&#8217;t really enough &#8211; if you hit about 60,000 builds of the same binary on the same symbol server you have to start worrying about collisions, or hope that the file size is growing.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

