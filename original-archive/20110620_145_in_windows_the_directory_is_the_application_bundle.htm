<html>
<head>
<title>In Windows, the directory is the application bundle</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>In Windows, the directory is the application bundle</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 20, 2011 / year-entry #146</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>70</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Aaargh! wonders why Windows doesn't just steal the concept of bundles from Apple and package up each application with all its libraries and everything else it needs into a single directory. This is such a great idea, it's been around since the early 1990's. It's just that Windows didn't give it a cute named like...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>Aaargh! wonders why <a href="http://blogs.msdn.com/oldnewthing/archive/2006/03/21/556505.aspx#557664"> Windows doesn't just steal the concept of bundles from Apple</a> and package up each application with all its libraries and everything else it needs into a single directory.</p>
<p> This is such a great idea, it's been around since the early 1990's. It's just that Windows didn't give it a cute named like <i>bundle</i>. It just gave it the boring name <i>directory</i>. In other words, it's a victim of bad marketing. Maybe we should have given it a cute name like... <a href="http://www.lardlad.com/assets/quotes/season2/7F08.shtml"> <i>elfgrass</i></a>. </p>
<p> The first directory searched by the <code>LoadLibrary</code> function is the directory containing the application. If you put all your supporting libraries in the same directory as your EXE, and if you access non-library data via paths relative to your application directory, then then you have successfully packaged up your application with all its libraries and everything else it needs into a single directory. Congratulations, you pre-invented the bundle. </p>
<p> Indeed, Microsoft's guidance for over a decade has been to discourage copying files into the System32 directory. </p>
<p> If this facility has been around for nearly twenty years, why do people still copy files into the System32 directory? </p>
<p> Probably inertia. "We've always installed that way, and we're not changing it because we don't know what would stop working." </p>
<p> There may be some people <a href="http://blogs.msdn.com/oldnewthing/archive/2004/06/15/156022.aspx#156243"> concerned about disk space</a>. "We have a bunch of applications which share some common libraries, and by putting the common libraries in a shared location (instead of in the application directory), we avoid wasting the user's disk space." Which raises the troublesome question: Is disk space still an issue nowadays? </p>
<p> Some people would say that no, disk space is no longer an issue. Hard drives are hundreds of gigabytes in size. Increasing the size of each application by a few dozen megabytes is just noise. </p>
<p> Other people would say that yes, disk space is still an issue. (Note how many people got excited when Snow Leopard took up less disk space.) Solid-state hard drives are still limited in size, and even for people with large hard drives, you see them freaking out about the disk space used by things like Windows Update, volume snapshot services, and System Restore. (Nevermind that at least for volume snapshots and System Restore, the disk space is automatically released when disk space starts to run low. It's like getting upset that the disk cache uses so much of your memory even though the computer is not under any memory pressure.) </p>
<p> <b>Bonus reading</b>: <a href="http://blogs.msdn.com/e7/archive/2008/11/19/disk-space.aspx"> Disk space and Windows 7</a>. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (70)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-919583">
				<div id="div-comment-919583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919583">
			June 20, 2011 at 7:21 am</a>		</div>

		<p>One thing that Mac OS X does with bundles is that the Finder presents them as opaque files instead of the directories that they really are. &nbsp;If you double-click Application.app in the Finder, it launches the application (instead of forcing you to browse to Application.app/Resources/MacOS/application and double-click that); similarly, double-clicking a bundle like Project.xcodeproj opens up the project in Xcode.</p>
<p>I don&#39;t really like the behavior &#8212; I like it better when the interface is transparent and shows me things for what they really are. &nbsp;At least I can always open up the terminal to look through the bundle directories.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919593">
				<div id="div-comment-919593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Maher</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919593">
			June 20, 2011 at 7:31 am</a>		</div>

		<p>Adam &#8211; You could also right click on the item in Finder and choose &quot;Show contents&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919603">
				<div id="div-comment-919603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919603">
			June 20, 2011 at 7:33 am</a>		</div>

		<p>Raymond, I would like to respectfully disagree with your assessment. &nbsp;In fact over the past ten years or so it has become MORE difficult to put everything your app needs in a single directory, not less.</p>
<p>You are absolutely correct that LoadLibrary etc makes it easy to dump all your DLLs into your application directory. &nbsp;But there are a fair number of other bits that need to get scattered in various places around the system, such as registry settings (e.g. file associations) and shortcuts. Disclaimer: &nbsp;I have no idea how this is handled on the Mac, so I don&#39;t know if the situation is better or worse there.</p>
<p>For me, in particular, the worst offender is that if my app needs to write out files for any reason, it cannot really write them to the application directory (which is presumably in Program Files), I have to dump them off in one of the app data folders. &nbsp;</p>
<p>Now, I have followed the evolution of windows for quite a while and I am not sure I would have done things much differently than Microsoft did. &nbsp;But as an app developer, I would really have loved the ability to dump absolutely everything in my application folder, so that an uninstall would consist of merely nuking that directory. &nbsp;I suspect from a practical standpoint there would still need to be some sort of registration with Windows saying: &quot;Hey there is an app in directory zzz&quot; and a corresponding unregister. but at least aside from that registration I would not need to scatter my files and data over half the system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919613">
				<div id="div-comment-919613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">R. Bemrose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919613">
			June 20, 2011 at 7:49 am</a>		</div>

		<p>&quot;For me, in particular, the worst offender is that if my app needs to write out files for any reason, it cannot really write them to the application directory (which is presumably in Program Files), I have to dump them off in one of the app data folders.&quot;</p>
<p>And this exact same &quot;problem&quot; has existed on UNIX (and clones) for the last 40 years, and OSX for the last 11. &nbsp;Essentially, an application isn&#39;t supposed to be allowed to modify its own files during everyday use. &nbsp;Administrator/root access is required to make changes to the app itself or any data that applies to all users.</p>
<p>The opposite end of this is the Portable Apps trend. &nbsp;In that one, the application is essentially a single-user application, carried by the user from computer to computer. &nbsp;This type of application is expected to have its configuration stored with the application, because it&#39;s never intended to have multiple users.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919623">
				<div id="div-comment-919623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Av</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919623">
			June 20, 2011 at 7:54 am</a>		</div>

		<p>A huge problem is registered DLL&#39;s and controls and such, like Active-X COM DLLs and OCX&#39;s. &nbsp;If Application A uses &quot;Widget X&quot; and places the control in it&#39;s own application directory and registers it, it will work fine.</p>
<p>Now along comes Application B, which also uses Widget X. &nbsp;It also registers it. &nbsp;Now Application A is using Application B&#39;s copy of Widget X. &nbsp;Now if you uninstall Application B, it will remove Widget X (or it will fail since Widget X is still in use). &nbsp;But assume it succeeds &#8212; Application A will now fail, since it can no longer find Widget X, since it isn&#39;t registered anymore.</p>
<p>That is why I copy the common files to System32, that way all apps that need them can find them and never uninstall them. &nbsp;It&#39;s messy but in the long run it is the cleanest.</p>
<div class="post">[<i>Applications A and B should be using registration-free COM, so that each one gets its own version of Widget X. The problem you describe is the result of using a global solution to a local problem. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919633">
				<div id="div-comment-919633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Caron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919633">
			June 20, 2011 at 7:54 am</a>		</div>

		<p>SimonRev, that&#39;s how it was in XP (assuming Administrator, which was nigh universal) and earlier.</p>
<p>The problem with this is with roaming profiles. If all my settings are in Program Files (which is tied to a given PC), then when I log in on another PC, my settings are gone!</p>
<p>So, I reconfigure everything, and in the process discover a new option that I didn&#39;t know existed, so I turn it on.</p>
<p>Once I&#39;m done working on this other PC, I go back to my desk and log in here again, and my awesome new feature is turned off.</p>
<p>&quot;Stupid Windows, forgetting my settings even though my administrator set it up so that everything should go over the network!&quot;</p>
<p>Whether or not this is a valid argument is up for debate, but that&#39;s one important rationale.</p>
<p>(Incidentally, reading the comments on the Bonus link made my brain hurt.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919643">
				<div id="div-comment-919643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919643">
			June 20, 2011 at 7:55 am</a>		</div>

		<p>In a similar vein, I&#39;ve never understood Microsoft, and general Windows developers, love of DLLs. &nbsp;Just link the whole kit &amp; caboodle into your exe. &nbsp;It has several benefits: single file, no DLL hell, smaller footprint, faster load times, less &quot;things to go wrong&quot;. &nbsp;DLLs made sense in Windows 3.11, and perhaps as late as Windows 98. &nbsp;But by the time we&#39;re talking fully 32 bit OSes with an NT core, DLLs were more lose than win. &nbsp;The reasons against DLLs are legion, the advantages are only in the minds of exactly the sort of people who worry about imaginary problems of being able to save a few bytes of hard-drive (by wasting even more because DLLs are more likely to have a larger overall footprint, so even that concern is generally bogus).</p>
<p>However, it would be nice if Windows supported the ability to mark a folder as &quot;treat this as an opaque unit&quot; just as application bundles do (and of course offer a context menu to be able to see the contents of the folder).</p>
<p>Similarly, as SimonRev points out, Windows has made it very difficult to have a strong &quot;just drop this here and your software will work&quot; mentality: the Registry was a logical idea at the time, but has ended up being a nightmare for application developers. &nbsp;Far better would have been to make the registry a Windows-OS only thing, and force developers to use their own mini-registries in their own app data folders, where there is no chance of leaving garbage in the OS (bloating it) with every install and eventual uninstall-that-doesn&#39;t-really-get-everything.</p>
<p>Yes, yes, this requires a time-machine. &nbsp;Can&#39;t go back. &nbsp;But x64 or Vista would have been really good &quot;transition-points&quot; to make a break with the registry. &nbsp;It could still be done in a future version of the OS, all it takes is some backwards compatibility shim and the will to admit that the registry is more headache than value.</p>
<p>And similarly, registering file types (and other similar install-registration record-keeping tasks) should have dedicated APIs rather than having to fiddle with the registry at the system level (potentially breaking things for the end-user, and giving no clean way to universally institute a smart policy for &quot;what to revert an association to when a given package is uninstalled&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919663">
				<div id="div-comment-919663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919663">
			June 20, 2011 at 8:02 am</a>		</div>

		<p>Did someone mention SxS? Why yes, yes I did.</p>
<p>And DLLs provide a great advantage to applications or systems which require more than one executable. What&#39;s inexplicable is Microsoft&#39;s obsession with COM, especially when a straight API would make far more sense and be much less cumbersome.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919673">
				<div id="div-comment-919673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919673">
			June 20, 2011 at 8:07 am</a>		</div>

		<p>Of course, if you bring your own copies of a DLL, and then that DLL has a security update, how would you track down all the copies of it scattered around the disk? That&#39;s exactly what happened with GDIPlus, and Microsoft Update had to write a special hacky &quot;update&quot; that scans the drive for it. And if it&#39;s statically linked, you&#39;re even more screwed.</p>
<p>I understand package management in Linux has a better solution: Dependencies are explicitly listed, the package manager can download (and update) them if it needs to, and it keeps track of which app depends on which package so uninstall works correctly (this is second-hand info, so I&#39;m not sure if it&#39;s accurate).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919683">
				<div id="div-comment-919683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Leo Davidson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919683">
			June 20, 2011 at 8:09 am</a>		</div>

		<p>@Steve Wolf:</p>
<p>There are situations where you have no choice but to use a DLL. e.g. If you to install a window hook or (certain types of) shell extensions as part of your program.</p>
<p>There are other situations where a DLL makes things much easier. e.g. If you want to use UAC to elevate certain calls/objects. (You could also do it by starting another copy of your exe elevated, but then all you&#39;ve really done there is take your DLL and put it inside your EXE, and if you need the two instances to communicate you&#39;ve got to re-invent a lot of IPC/permissions stuff that was already done for you.)</p>
<p>There are other situations where it just makes sense from a development point of view. The DLL may be written by a completely different team (or even company) on a different schedule without access to your build-chain. You might want to be able to replace it with other versions, or even remove it entirely at a later date.</p>
<p>Plugins that users can write/install themselves fall into most of the categories above.</p>
<p>BTW, there are APIs for registering filetypes. I think they were added in Vista.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919693">
				<div id="div-comment-919693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">B. Beck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919693">
			June 20, 2011 at 8:11 am</a>		</div>

		<p>@Steve Wolf:</p>
<p>DLLs aren&#39;t just about saving space on the hard drive &#8211; it&#39;s also about security (any time a DLL is patched, any programs that were statically linked against it would have to be patched/updated separately (and we all know how much users love updates), and the memory saving applies to RAM as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919703">
				<div id="div-comment-919703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919703">
			June 20, 2011 at 8:29 am</a>		</div>

		<p>Application size is still very much an issue for application that are downloaded, not sold in boxes. I believe, this is the vast majority of applications. Were .NET apps required to link the whole BCL into the exe, none would have used it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919723">
				<div id="div-comment-919723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Absotively</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919723">
			June 20, 2011 at 8:37 am</a>		</div>

		<p>@Jonathan: Your description of Linux package management is basically correct. &nbsp;It works very smoothly, so long as everything you want to install is available through your package manager. &nbsp;For Linux, most of the available software is open source, so the distributions can repackage and redistribute it and all is well. &nbsp;I think that doing the same with commercial software would be considerably trickier.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919733">
				<div id="div-comment-919733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fidel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919733">
			June 20, 2011 at 8:45 am</a>		</div>

		<p>&quot;so long as everything you want to install is available through your package manager&quot;</p>
<p>Ah yes. If it is not, you may be screwed. Because App A needs library L in version 13.3.7, but only version 13.3.6 is available in the package manager (bonus points if it doesn&#39;t work with 13.3.8 either). Hilarity ensues.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919753">
				<div id="div-comment-919753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter da Silva</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919753">
			June 20, 2011 at 9:09 am</a>		</div>

		<p>The Application Bundle concept that Apple uses was invented by NeXT in the late &#39;80s and released in NextStep in 1989. It is far more than &quot;putting resources in the same directory as the application&quot;, it&#39;s a specific layout of components that exposes information via specific property list files in the bundle contents. It provides a template for helper application registration, file type registration, preferences, and shared libraries and other frameworks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919763">
				<div id="div-comment-919763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919763">
			June 20, 2011 at 9:16 am</a>		</div>

		<p>&quot;The first directory searched by the LoadLibrary function is the directory containing the application.&quot;</p>
<p>The inability to do something like this on *nix is a huge PITA and has been a continual source of annoyance. (You could do it if you manually dlopen the .so then hook up all the symbols, but if I wanted to write a linker I&#39;d write a linker.)</p>
<p>@SimonRev: &quot;But there are a fair number of other bits that need to get scattered in various places around the system, such as registry settings (e.g. file associations) and shortcuts.&quot;</p>
<p>If you really wanted to write a &quot;zero install&quot; app, most of those things you could do the first time the program starts.</p>
<p>@Alexey: &quot;Application size is still very much an issue for application that are downloaded, not sold in boxes.&quot;</p>
<p>Eh, it&#39;s an issue, but I don&#39;t think it&#39;s &quot;very much&quot; of an issue a lot of the time. (It would be for sort of &quot;impulse downloads.&quot;) I mean I have just about the worst DSL or cable connection you can get (I&#39;m cheap), and I don&#39;t really think twice about getting a 5 or 10 GB game off Steam. The number of times that I&#39;ve failed to download something because it&#39;s too big is close to zero. (The main thing I do do to save bandwidth is to turn the quality down on YouTube.)</p>
<p>@SimonRev: &quot;as someone who has never used roaming, my inclination would have been to save per-user settings somewhere like &lt;app folder&gt;/&lt;username&gt;/usersettings.xml. &nbsp;I suspect that might not be roaming friendly though.&quot;</p>
<p>There is a roaming folder like that. For me, it&#39;s at c:UsersEvanAppDataRoaming, but I&#39;m not sure the correct way to find that folder.</p>
<p>@Absotively: &quot;@Your description of Linux package management is basically correct. &nbsp;It works very smoothly, so long as everything you want to install is available through your package manager.&quot;</p>
<p>And as long as you&#39;re root. For whatever reason, virtually no package managers allow use as non-root despite the fact that it&#39;s entirely possible to install almost anything as a private install if you do &#39;./configure &#8211;prefix=&#8230;&#39;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919773">
				<div id="div-comment-919773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919773">
			June 20, 2011 at 9:32 am</a>		</div>

		<p>Oh man, I lied a bit: &quot;The inability to do something like this on *nix is a huge PITA and has been a continual source of annoyance.&quot;</p>
<p>So apparently you CAN do this by using an RPATH relative to ${ORIGIN}. My manpages are too old to document this, but supposedly it&#39;s in newer versions of them, and it works with my ld.so anyway.</p>
<p>That solves half the problem&#8230; now if only it would be come standard practice to use them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919783">
				<div id="div-comment-919783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919783">
			June 20, 2011 at 9:35 am</a>		</div>

		<p>@Evan: Being root temporarily isn&#39;t a problem. Using sudo via the command line, or letting the system ask you for your password to elevate a GUI app. I think the general consideration is that in most end-user scenarios, a program is installed for a machine, not for a user. Additionally, in a work environment you don&#39;t want your users installing random things whenever they feel like it, and in a home environment you know your password anyway. Imagine how much people would freak out about disk space on a machine with multiple users who all had to install their own copies of each program&#8230; (yes, symlinks and so on, but that would start to become a very complex solution to a simple issue &#8211; type your password).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919793">
				<div id="div-comment-919793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MWF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919793">
			June 20, 2011 at 9:38 am</a>		</div>

		<p>@Steve Wolf</p>
<p>To say that we would be better off without DLLs is just plain crazy. DLLs provide a necessary ability to create modular, extensible applications. Dynamic/shared libraries are also very useful to streamline development of large projects whose team may be geographically separated.</p>
<p>Without dynamic libraries, you can&#39;t efficiently develop portions of a larger solution in parallel, since you have to re-link to the new static libraries whenever there is an update available. With DLLs, you would only need to take action if the interface changed. (And depending on some specifics, you may only need to take action if there were a change to an interface method you were already using, not needing any action if the interface was only expanded with new functionality.)</p>
<p>Without dynamic libraries, sharing code between multiple projects becomes more of a pain &#8211; again, you have to re-link your entire application to the static libraries instead of just dropping the new version of the DLL in.</p>
<p>Without dynamic libraries, creating modular applications is nigh-impossible. Any plugin functionality you would like to have must be developed from scratch, using whatever constructs you decide on &#8211; instead of just allowing a dynamic library to load with a specific interface requirement. And keep in mind that plugins can mean more than just optional extensions to an application &#8211; they might feature essential functionality as well. For example, you might have an application that interfaces with some specialized piece of hardware. Say that a competitor hardware vendor creates a new device that serves the same purpose, but interfaces differently. Without dynamic libraries, you would have to update your entire application if you wanted to support both. If you had instead architected your application to load a dynamic library for the implementation of the necessary interface, you could just deploy an additional DLL that supports the new device. (In addition to the existing DLL to support the original device that shipped with your application in the first place.)</p>
<p>The only &quot;problems&quot; with DLLs are the people who use them (or try to use them) without understanding what they are doing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919803">
				<div id="div-comment-919803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Colin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919803">
			June 20, 2011 at 9:45 am</a>		</div>

		<p>@Kemp: so instead of users being able to install packages to their account from a repository the admin trusts, the user is forced to download the source to the package and build and install it locally (assuming their sysadmin gives them access to the system compiler), where it&#39;s completely invisible to the package management system.</p>
<p>&quot;cutting off your nose to spite your face&quot; about covers it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919813">
				<div id="div-comment-919813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Grier [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919813">
			June 20, 2011 at 9:46 am</a>		</div>

		<p>@James Bray:</p>
<p>You should read the linked article on Windows 7 disk space usage. &nbsp;The WinSXS directory really doesn&#39;t use significantly more space than was present in prior versions (XP, Windows 2000), it&#39;s just that it&#39;s all in one place so you can see it. &nbsp;It used to be that the same files were kept in a myriad of different places, never shared. &nbsp;Starting with Vista, files superceded by newer updates, links to the current files, copies of files applicable only when you move to the LDR branch (QFEs) and staged updates for future installation are all present in one place.</p>
<p>It&#39;s true that there are a ton of new single file directories present and each one uses an MFT entry but really all this stuff was there before.</p>
<p>The use of hard links is also problematic for older tools which had never grown up to deal with them before.</p>
<p>There are higher level policy decisions which somewhat exacerbate the issue (e.g. nobody wanted to do the new work to connect to WU and download different files when installing or uninstalling an LDR) but actually this was the policy / behavior since Windows 2000 in any case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919823">
				<div id="div-comment-919823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919823">
			June 20, 2011 at 9:54 am</a>		</div>

		<p>@Steve Wolfe: Why would your exe that includes every dll be smaller and load faster? If at all it&#39;d generally be slower because it always has to load the extra code which may not be necessary for a dll. Smaller also won&#39;t work everything else considered equal.</p>
<p>But really all that stuff is unimportant (saving a few mb of RAM? ah well, not that important) with the fact that if you statically link your program with any kind of security relevant library you&#39;ll have to release a new version of your program each and every time a flaw is found &#8211; that&#39;s not only inconvenient for the programmer but also the users (not many users appreciate having to update a program every other week).</p>
<p>@Evan: &quot;There is a roaming folder like that. For me, it&#39;s at c:UsersEvanAppDataRoaming, but I&#39;m not sure the correct way to find that folder.&quot;</p>
<p>SHGet(Known)FolderPath to the rescue. A quick glance at <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/dd378457%28v=VS.85%29.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/dd378457%28v=VS.85%29.aspx</a> shows FOLDERID_RoamingAppData for Vista+ or CSIDL_APPDATA for the XP guys.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919833">
				<div id="div-comment-919833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919833">
			June 20, 2011 at 10:08 am</a>		</div>

		<p>SimonRev 20 Jun 2011 8:33 AM:</p>
<p>&quot;My files fell into the category of temporary files as well as files generated as part of normal operation of the hardware that my software was emulating (and had no purpose existing after an uninstall).&quot;</p>
<p>If tempoary then put them into Temp folder. There is API for creating temp filenames (from pattern) and getting path to temp directory.</p>
<p>If generated during operation and to be persistent until uninstall then ProgramData (aka old AllUsers AFAIK) is place for them or if user specific then AppData inside User profile.</p>
<p>Writing into Application directory during normal operation(by non-admin) should not be done at all as that is hole in security.</p>
<p>APIs:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/aa364991(VS.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa364991(VS.85).aspx</a> //GetTempFileName Function</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/aa364992(VS.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa364992(VS.85).aspx</a> //GetTempPath Function</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919843">
				<div id="div-comment-919843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">moi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919843">
			June 20, 2011 at 10:15 am</a>		</div>

		<p>What about the 2008 CRT DLLs that won&#39;t load from your own library. &nbsp;That was a huge mess that a lot of us are still stuck with. &nbsp;If you want to use 3rd party DLLs, you can&#39;t unless you buy the source code and recompile everything. &nbsp;If I use 2008 SP1 but one vendor used 2008 vanilla, things go south.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919853">
				<div id="div-comment-919853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris L</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919853">
			June 20, 2011 at 10:15 am</a>		</div>

		<p>As silva points out, the Mac app bundle contains all sorts of metadata indicating what file types and URL schemes the application can open, so you never need to manage this. Copying the app to your hard drive is enough to register it, deleting it will unregister it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919863">
				<div id="div-comment-919863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919863">
			June 20, 2011 at 10:18 am</a>		</div>

		<p>@Kemp: &quot;Being root temporarily isn&#39;t a problem.&quot;</p>
<p>It is if you don&#39;t have root privileges.</p>
<p>&quot;Additionally, in a work environment you don&#39;t want your users installing random things whenever they feel like it,&quot;</p>
<p>Then why can I just run configure &amp; make? Why isn&#39;t it standard practice to mount everything but /usr noexec?</p>
<p>&quot;Imagine how much people would freak out about disk space on a machine with multiple users who all had to install their own copies of each program&#8230;&quot;</p>
<p>If only there was some way to keep track of how much space a user was user and limit it. Oh well, I guess that&#39;s a pipe dream.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919873">
				<div id="div-comment-919873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Absotively</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919873">
			June 20, 2011 at 10:56 am</a>		</div>

		<p>@Evan: Package managers generally install binaries, and of course using &#39;./configure &#8211;prefix=&#8230;&#39; would require compiling everything on install. &nbsp;Plus, most package managers are meant for system administration; it&#39;s not that they want to prevent users installing software, it&#39;s just that making it easy for users to install software is not why they exist.</p>
<p>There also exists Zero Install (<a rel="nofollow" target="_new" href="http://0install.net/" rel="nofollow">http://0install.net/</a>), which is a system specifically designed for making it easier for users to install software. &nbsp;So it&#39;s not that no one cares about this problem, it&#39;s just that the people making system administration tools don&#39;t care about it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919893">
				<div id="div-comment-919893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jory</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919893">
			June 20, 2011 at 11:22 am</a>		</div>

		<p>Adam &#8211; that&#39;s the correct level of abstraction though. For most people, an app &quot;folder&quot; is an app. They don&#39;t want to know how an app is put together. Here&#39;s what people want to do with apps: Install them, launch them, remove them from their systems. For those operations, the opaque bundle is the correct metaphor.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919923">
				<div id="div-comment-919923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919923">
			June 20, 2011 at 12:56 pm</a>		</div>

		<p>Things people forget about static-linking vs. DLLs:</p>
<ol>
<li>static-linking only includes the part of the library you actually use, not all of it, resulting in smaller disk &amp; memory footprint.</li>
<li>
<p>DLLs are an additional security liability: hack the DLL (or replace it)</p>
</li>
<li>
<p>&quot;Instead of releasing a whole new app, you can just drop in the replacement DLL&quot; &#8211; what hogwash! &nbsp;How is that one whit different than releasing a patch for your application? &nbsp;In what way does that require any less testing, security issues, transport &amp; install issues? &nbsp;This is just vacuous.</p>
</li>
<li>
<p>Because my app is correct, I can patch it, and only it. &nbsp;Because your app depends on some specific version of some specific DLL, Windows has to track every version of every DLL ever written in order to pair them up correctly. &nbsp;You&#39;re wasting vast chunks of the user&#39;s hard drive to SxS while I waste zero.</p>
</li>
<li>
<p>Many different exe&#39;s use the same DLL so there is a memory footprint (and hard disk) savings. &nbsp;Bogus! &nbsp;Every exe typically uses a very specific version of a DLL or it crashes (or otherwise behaves in ways not conductive to the user&#39;s happy experience). &nbsp;Along with the fact that the DLL is installed 10 different places consumes 10x as much space. &nbsp;And the fact that SxS keeps track of them all for all versions uses up yet more space.</p>
</li>
</ol>
<p>To those who worry that I&#39;m eschewing DLLs en masse, I am not suggesting that they have no place (e.g. the OS kernel is a fabulous place for them, as is localized resource-only DLLs). &nbsp;I&#39;m sure there are other good examples of when to use DLLs, but most people resort to the above 5 bassackward justifications (which are all verifiable falsehoods).</p>
<p>I&#39;m not suggesting that dynamic linking is specific to Windows. &nbsp;However, Microsoft &amp; most Windows developers over-reliance on DLLs is to what I&#39;m referring (their near religious affinity for them despite the excruciatingly well documented DLL-Hell of which most of us who&#39;ve done any business in developing and supporting Windows software are well aware is bordering on insane).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919953">
				<div id="div-comment-919953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919953">
			June 20, 2011 at 1:22 pm</a>		</div>

		<p>@Steve Wolf: &quot;It&#39;s just there to counter the idea that static is less secure than dynamic, which is goofy.&quot;</p>
<p>Fair enough.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919963">
				<div id="div-comment-919963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">grumpy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919963">
			June 20, 2011 at 1:49 pm</a>		</div>

		<p>huh, bundles in Windows? I guess that&#39;s why installers and uninstallers frequently take a good 20 minutes to scatter as many bits and pieces over as many difference places as possible, yes?</p>
<p>Or perhaps it&#39;s just that Apple is wrong, and wasting the user&#39;s time and diskspace, and turning defective installers and uninstallers into rocket science is a better solution? There must be a reason why Microsoft does so much to encourage that model for Windows applicatinos.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919653">
				<div id="div-comment-919653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fidel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919653">
			June 20, 2011 at 7:59 am</a>		</div>

		<p>@SimonRev:</p>
<p>But the stuff the application writes in the user-specific directories is *not* part of the app itself and should not be automatically removed. As for the registry keys, yeah, that&#39;s definitely a problem. A somewhat cooler solution would have been to add an application-specific hive in its directory that automatically gets unloaded when the directory is removed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919973">
				<div id="div-comment-919973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Haha</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919973">
			June 20, 2011 at 3:06 pm</a>		</div>

		<p>Wow that&#39;s great. &nbsp;I can move Office from /Program Files to /Apps and it will just work! &nbsp; Just like OSX! &nbsp; Yay Windows!</p>
<p>/s</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919713">
				<div id="div-comment-919713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919713">
			June 20, 2011 at 8:33 am</a>		</div>

		<p>Ironically I think this discussion has drilled into me more than perhaps anything else how diverse the use cases of Windows are.</p>
<p>In my app, I am specifically thinking of files that are generated by the app as part of its execution that are neither documents/typical output as Fidel immediately thought (which go through a normal save-as process and default do My Documents), nor are they application settings as Steven thought (which I save to the HKCU/Software/&#8230;)**. To me, the fact that everyone jumped to a different conclusion speaks volumes to how difficult a one-size-fits-all solution would be. &nbsp; My files fell into the category of temporary files as well as files generated as part of normal operation of the hardware that my software was emulating (and had no purpose existing after an uninstall).</p>
<p>** However, as someone who has never used roaming, my inclination would have been to save per-user settings somewhere like &lt;app folder&gt;/&lt;username&gt;/usersettings.xml. &nbsp;I suspect that might not be roaming friendly though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919983">
				<div id="div-comment-919983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919983">
			June 20, 2011 at 3:48 pm</a>		</div>

		<p>@Steve Wolf: &quot;5. Many different exe&#39;s use the same DLL so there is a memory footprint (and hard disk) savings. &nbsp;Bogus!&#8230;&quot;</p>
<p>I think you&#39;re misunderstanding people&#39;s argument here. While you may be correct when considering disparate apps (Which may get out of sync and each require their own dll version), this is a good reason to use dlls if you are making something that could be considered a &quot;suite&quot;, like Microsoft Office, where all of your binaries are shipped at once. You&#39;ll get a memory and disk footprint saving from consolidating into a dll all of your UI controls, for example, or file formats.</p>
<p>Or, the logic of your program can live in a dll, while your GUI and command line versions can be different executables(Again, considering a program in which both are installed a s a single package). An extra benefit of this is that you can&#39;t half apply a patch anymore. (Say you find a bug in your logic, and issue a patch. If you are only patching one dll, instead of 2 executables, you are guaranteed that for a given machine, the logic won&#39;t be different between the different interfaces.)</p>
<p>Along those lines, it could be argued that dlls with well defined interfaces can be used to provide an extra layer of encapsulation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919743">
				<div id="div-comment-919743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Bray</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919743">
			June 20, 2011 at 8:49 am</a>		</div>

		<p>Regarding the disk space usage; I&#39;d say WinSxS (side-by-side DLL storage) uses *by far* the most disk space on Vista and Windows 7.</p>
<p>I understand the problem it solves, but its at a huge expense of disk space (at least for us SSD folks)</p>
<p>James</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919993">
				<div id="div-comment-919993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919993">
			June 20, 2011 at 4:12 pm</a>		</div>

		<p>True story: I&#39;ve had to write &quot;patches&quot; that copied the whole install directory and changed one file so the patch was different between two instances so that the logic change required the least amount of testing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920013">
				<div id="div-comment-920013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reg-free COM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920013">
			June 20, 2011 at 5:55 pm</a>		</div>

		<p>[Applications A and B should be using registration-free COM, so that each one gets its own version of Widget X. The problem you describe is the result of using a global solution to a local problem. -Raymond]</p>
<p>And if application A and B are Sidebar (Desktop) Gadgets?</p>
<p>Glad to hear it works SO well there.</p>
<div class="post">[<i>Sorry, didn&#39;t realize that Av was talking about gadgets. Sadly, gadgets don&#39;t support manifests. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919883">
				<div id="div-comment-919883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919883">
			June 20, 2011 at 11:18 am</a>		</div>

		<p>@Steve Wolfe </p>
<p>&gt;In a similar vein, I&#39;ve never understood Microsoft, and general Windows developers, love of DLLs.</p>
<p>This implicitly indicates that shared libraries are some sort of Windows thing. &nbsp;And yet shared executable code modules have existed in practically every general-purpose operating system I&#39;ve used since 1975 (and they weren&#39;t new then). </p>
<p>There *is* a discussion to be made about modularization tradeoffs, to be sure, but let&#39;s not pretend it&#39;s somehow specific to Windows.</p>
<p>FWIW, app isolation (&quot;if someone changes the code, I&#39;ve still got the old stuff&quot;) is a blessing if you don&#39;t want the change and a curse if you do want that change. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919913">
				<div id="div-comment-919913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919913">
			June 20, 2011 at 12:08 pm</a>		</div>

		<p>@Raymond: Increasing the size of each application by a few dozen megabytes is just noise.</p>
<p>Yes, a few dozen megabytes is just noise, WinSXS on the other hand is insane.</p>
<p>@R. Bemrose: And this exact same &quot;problem&quot; has existed on UNIX (and clones) for the last 40 years.</p>
<p>Those who don&#39;t understand UNIX are condemned to reinvent it, poorly.</p>
<p>@Joe: What&#39;s inexplicable is Microsoft&#39;s obsession with COM, especially when a straight API would make far more sense and be much less cumbersome.</p>
<p>Yes, yes, a thousand times yes.</p>
<p>@James Bray: Regarding the disk space usage; I&#39;d say WinSxS (side-by-side DLL storage) uses *by far* the most disk space on Vista and Windows 7.</p>
<p>No, pagefile + hiberfile does.</p>
<p>@Evan: If you really wanted to write a &quot;zero install&quot; app, most of those things you could do the first time the program starts.</p>
<p>Easy to forget that apps must be able to run as non-admin, isn&#39;t it? I know that file associations can be a user setting, but in a large enterprise every user should not have to setup every app, it should be done by admins. And there&#39;s lots of other system settings which requires admin privileges to set up.</p>
<p>@Michael Grier: The WinSXS directory really doesn&#39;t use significantly more space than was present in prior versions (XP, Windows 2000),</p>
<p>This is simply not true. WinSXS keeps every dll ever installed, both 32-bit and 64-bit. Good luck finding gigs of 64-bit dlls in Windows 2000.</p>
<div class="post">[<i>Meaningless comparison because there was no 64-bit version of Windows 2000. (And the 64-bit version of Windows XP was never in wide distribution. I&#39;m not sure if it&#39;s even serviced.) I think Michael&#39;s point is that the disk space usage hasn&#39;t changed; the files just moved from the various scattered locations they used to be (so you never noticed them before) to a single place where you can complain about them en masse. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-919933">
				<div id="div-comment-919933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919933">
			June 20, 2011 at 1:04 pm</a>		</div>

		<p>@Absotively: &quot;Package managers generally install binaries, and of course using &#39;./configure &#8211;prefix=&#8230;&#39; would require compiling everything on install.&quot;</p>
<p>That shouldn&#39;t make a difference if the *nix method was sane. (But then we come back to the fact that ${ORIGIN} was apparently long-undocumented, largely unknown, and almost entirely unused.) But even still, last I checked even something like Gentoo&#39;s Portage requires root.</p>
<p>&gt; &quot;There also exists Zero Install (<a rel="nofollow" target="_new" href="http://0install.net/" rel="nofollow">http://0install.net/</a>), which is a system specifically designed for making it easier for users to install software. &nbsp;So it&#39;s not that no one cares about this problem, it&#39;s just that the people making system administration tools don&#39;t care about it.&quot;</p>
<p>That *is* basically what I&#39;m lamenting. :-)</p>
<p>@640k: &quot;Those who don&#39;t understand UNIX are condemned to reinvent it, poorly.&quot;</p>
<p>My corollary to that is &quot;Those who understand Unix are condemned to invent it, well.&quot; (Read that in a somewhat disparaging tone. Unix does a lot of things well, but a lot of things&#8230; let&#39;s say &quot;not so well&quot;, especially given that it&#39;s no longer the 1970s.)</p>
<p>&gt; &quot;Easy to forget that apps must be able to run as non-admin, isn&#39;t it? I know that file associations can be a user setting, but in a large enterprise every user should not have to setup every app, it should be done by admins. And there&#39;s lots of other system settings which requires admin privileges to set up.&quot;</p>
<p>So we have settings in three categories. (1) are those which need admin rights, in which case you&#39;re right. But, say, OS X .app bundles don&#39;t support such setup either, and for a variety of factors it&#39;s reasonable that if something needs admin rights something like a simple bundle won&#39;t work. (2) Settings which are the same from user-to-user, but do not need admin-privileges. Here the first-time startup code can just display a progress bar for a couple seconds. The user is hardly inconvenienced at all. (3) Settings which differ from user-to-user. Here you need to display a dialog to the user&#8230; but that&#39;s sort of fundamentally true anyway. Otherwise how are those settings going to differ?</p>
<p>The main objection you can take to the Windows way perhaps is the quantity of settings that require admin rights. I can&#39;t speak to that too much.</p>
<p>@Steve Wolf: &quot;DLLs are an additional security liability: hack the DLL (or replace it) &#8230; How is that one whit different than releasing a patch for your application?&quot;</p>
<p>I like how you juxtapose these two things. What are you going to hack about the DLL that you couldn&#39;t hack about the original program? How are you going to be able to replace the DLL and not the original program?</p>
<p>With a reasonable setup, I know of basically one additional vulnerability that DLLs introduce, and that&#39;s import table patching. And if your program is to the point where an attacker is patching your import table&#8230; you don&#39;t have much hope. I might be missing something, but I don&#39;t view your (2) as being very convincing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-919943">
				<div id="div-comment-919943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-919943">
			June 20, 2011 at 1:17 pm</a>		</div>

		<p>@Evan &#8211; Mainly I&#39;m countering the notion that having the code statically linked somehow makes it less secure than the DLL, which is silly.</p>
<p>The additional vulnerability that DLLs introduce is that your software, unless it fully specifies the path, relies upon the OS loader&#39;s search algorithm, which can be taken advantage of to load a bogus DLL instead of the real one. &nbsp;It is *potentially* more vulnerable, because the behavior is more complex, there are more points of attack (every folder in the loader&#39;s search algorithm).</p>
<p>However, I could care less about this angle of argument. &nbsp;It&#39;s just there to counter the idea that static is less secure than dynamic, which is goofy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920023">
				<div id="div-comment-920023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920023">
			June 20, 2011 at 8:45 pm</a>		</div>

		<p>If app bundles are so great, why are there still apps with installers for OS X? What do they do that&#39;s so special that the all-powerful app bundle system can&#39;t handle it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920043">
				<div id="div-comment-920043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920043">
			June 20, 2011 at 9:07 pm</a>		</div>

		<p>@Myria: Microsoft listened and fixed it for VS2010. Sadly, I can&#39;t find a MSDN-documented solution for VS 2005 although there are a couple of third-party methods.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920053">
				<div id="div-comment-920053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Will</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920053">
			June 20, 2011 at 9:30 pm</a>		</div>

		<p>@Evan: &quot;There is a roaming folder like that. For me, it&#39;s at c:UsersEvanAppDataRoaming, but I&#39;m not sure the correct way to find that folder.&quot;</p>
<p>%appdata%</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920063">
				<div id="div-comment-920063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920063">
			June 20, 2011 at 10:03 pm</a>		</div>

		<p>@Joshua: Sure, except that 2010 is four times the price of 2008&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920073">
				<div id="div-comment-920073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zedware</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920073">
			June 20, 2011 at 10:37 pm</a>		</div>

		<p>If most of the system files are read-only</p>
<p>then</p>
<p>&nbsp; why not let the Windows OS de-dup it in background to save disk space?</p>
<p>fi</p>
<p>Anyone know if Windows Desktop support this feature?</p>
<div class="post">[<i>Even better: The de-dup&#39;ing was performed at setup time! The files in WinSxS are hard linked to other copies in the system where applicable. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920003">
				<div id="div-comment-920003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave G</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920003">
			June 20, 2011 at 4:18 pm</a>		</div>

		<p>The difference between a directory in Program Files and a bundle is **organisation**. Bundles have an organised directory structure that the shell/Finder (or I suppose anything else) can utilise. For example, because a bundle contains localised resources, Finder is able to show localised information, including a localised application name in the Finder window if available. The organisation of a bundle makes it better than a directory in Program Files. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920083">
				<div id="div-comment-920083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920083">
			June 20, 2011 at 11:37 pm</a>		</div>

		<p>@Gabe: because there are still instances where bundling doesn&#39;t work. E.g., utilities that hook into the system, device drivers, etc. And there are componentized installs where a common install media may install more than you&#39;re licensed for, so they&#39;ll just create the app with the parts you bought, rather than a big giant package.</p>
<p>But Apple has encouraged bundling &#8211; iOS apps must be self-contained save for the system library &#8211; they run as a non-root user in a sandbox where they can only see themselves and a few system-created directories one level up, but not other apps and their data, or user global data like contacts and content (they can use APIs to get at them though).</p>
<p>The Mac App Store has similar requirements &#8211; apps must be standalone. They download and are ready to use. Which is one reason a bunch of app types are banned (e.g. drivers)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920093">
				<div id="div-comment-920093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave G</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920093">
			June 20, 2011 at 11:37 pm</a>		</div>

		<p>@Gabe: Bundles might not eradicate the need for an installer, but it greatly reduces the need. Many of the apps that use installers probably don&#39;t even need them [citation needed]. Also, it&#39;s not just about installation and uninstallation; the consistent organised structure makes bundles far more utilisable than a plain directory with an EXE and some DLLs in it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920103">
				<div id="div-comment-920103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Buchan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920103">
			June 21, 2011 at 12:07 am</a>		</div>

		<p>Local deployment is possible with MSVCRT 70-80, although it can be complicated to set up: <a rel="nofollow" target="_new" href="http://blog.kalmbach-software.de/2008/05/03/howto-deploy-vc2008-apps-without-installing-vcredist_x86exe/" rel="nofollow">blog.kalmbach-software.de/&#8230;/howto-deploy-vc2008-apps-without-installing-vcredist_x86exe</a></p>
<p>I wonder why MSVCRT&#39;s default manifest setup didn&#39;t allow satisfying a load request with a security patched version &#8211; as @Myria noted, the existing behaviour seems more likely to break applications (not to mention increases the amount of code with known security exploits on people&#39;s machines!).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920133">
				<div id="div-comment-920133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Troll</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920133">
			June 21, 2011 at 1:01 am</a>		</div>

		<p>In XP, back up of files superceded by newer updates could be skipped so only current files remain on the system, in Vista/7, it cannot. In XP, Update.exe could be told to install the QFE branch using the /b /SPxqfe switch, in Vista, there is no such switch. In XP, there was no concept of staging, sure the user had to insert the XP CD when adding/removing components and possibly reinstall a few updates but this saved space. In Vista, the decision is not left to the user, they are all compulsorily staged so even components that aren&#39;t &quot;on&quot; and their serviced copies of copies of copies take space on the system. Office 2007/2010 also gives no option like Office 2003&#39;s Local Installation Source did whether or not to stage all MSI and CAB setup files on the system. Windows Installer also by default caches files for all apps modified by delta updates which is why when installing for example, SP1 for Visual Studio your %windir%InstallerPatchCache folder gets completely bloated up even if the users prefers it not to be cached and rather be prompted for the original install media.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920143">
				<div id="div-comment-920143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Troll</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920143">
			June 21, 2011 at 1:03 am</a>		</div>

		<p>In XP, back up of files superceded by newer updates could be skipped so only current files remain on the system, in Vista/7, it cannot. In XP, Update.exe could be told to install the QFE branch using the /b /SPxqfe switch, in Vista, there is no such switch. In XP, there was no concept of staging, sure the user had to insert the XP CD when adding/removing components and possibly reinstall a few updates but this saved space. In Vista, the decision is not left to the user, they are all compulsorily staged so even components that aren&#39;t &quot;on&quot; and their serviced copies of copies of copies take space on the system. Office 2007/2010 also gives no option like Office 2003&#39;s Local Installation Source did whether or not to stage all MSI and CAB setup files on the system. Windows Installer also by default caches files for all apps modified by delta updates which is why when installing for example, SP1 for Visual Studio your %windir%InstallerPatchCache folder gets completely bloated up even if the users prefers it not to be cached and rather be prompted for the original install media. Some users would like it if there are no &quot;staging&quot; done for system files or drivers (driverstore) which is another bloated store.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920153">
				<div id="div-comment-920153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920153">
			June 21, 2011 at 2:02 am</a>		</div>

		<p>well.well.well. welcome to Visual Studio 2010 where you will learn that deployment means simply dumping msvcr100.dll into your system32 directory. Back to the old days, huh? makes servicing easy, huh?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920033">
				<div id="div-comment-920033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920033">
			June 20, 2011 at 8:51 pm</a>		</div>

		<p>@moi: It gets even worse with security updates. &nbsp;Twice this year, Microsoft has released new versions of msvcr90.dll. &nbsp;Let&#39;s say you have a third-party DLL to which you do not have the source code. &nbsp;This third-party DLL is dynamically linked against msvcr90.dll, as is your application.</p>
<p>When a second Tuesday rolls around, your company&#39;s security team pushes out the new security updates to your company&#39;s computers. &nbsp;You then make a build of your application and send it to customers.</p>
<p>The new version doesn&#39;t run on your customers&#39; computers! &nbsp;They have to install *two* versions of the redistributable packages in order to fix it. &nbsp;Worse still, your application ends up loading two copies of msvcr90.dll, one of the old version and one of the new version. &nbsp;If you pass CRT objects like FILE *&#39;s between your application and the third-party DLL, your application will probably crash, because the other msvcr90.dll won&#39;t recognize the object. &nbsp;And this all broke because of a security update on a developer&#39;s machine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920173">
				<div id="div-comment-920173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random User 288534</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920173">
			June 21, 2011 at 6:57 am</a>		</div>

		<p>So, I think we have determined the &quot;bundle&quot; is not a suitable form for every kind of software. I begin to wonder how difficult it would actually be to create the pieces needed (shell extensions, etc.) to enable &quot;bundle support&quot; in the shell for most or all types of software for which a bundle makes sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920183">
				<div id="div-comment-920183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random User 288534</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920183">
			June 21, 2011 at 7:02 am</a>		</div>

		<p>And just to clarify, I am referring to &quot;bundle support&quot; in the sense most of the commenters are using, since so many seem to disagree with Raymond&#39;s interpretation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920113">
				<div id="div-comment-920113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Troll</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920113">
			June 21, 2011 at 12:12 am</a>		</div>

		<p>Wasn&#39;t the ability to load DLLs locally (not to be confused with WinSxS and Reg-free COM) introduced in Windows 2000 or something? I recall it was called Fusion or something.</p>
<p>&quot;Is disk space still an issue nowadays?&quot; Disk space oh don&#39;t get my started on that please. Seems like a typical shameless Microsoft stance since the days of Vista. All products are engineered without disk space in mind (compulsory caching of Office/Windows Live Setup files, all language files, entire components in case of Windows Vista/7&#39;s disastrous Component Servicing Store). In case anyone dunno, ****WinSxS is not just used for side-by-side DLLs in Vista/7 like XP****. Beginning with Vista, it is also used to store the OS itself, the CBS store and copies of copies of backups of backups of files. Steven Sinofsky even blatantly lies in that blog post Raymond linked to saying the size of WinSxS is close to 400 MB. Probably he meant 4 GB which is excluding hard links. Yeah I know SOME of the files are hard linked, not ALL. The servicing mechanism in the abomination called Vista took away the /nobackup switch from users. You can measure the true size of WinSxS exluding hard links using a utility called cttruesize (ctts.exe). WinSxS is enough reason to stay away from the bloated by design Windows 7 and Vista systems. The Servicing stack backs up files before they are serviced by updates and then never deletes or what MS calls scavenging. Only service pack files can be scavenged and although Microsoft claims that adding and removing Windows components will scavenge backed up files, I see my free disk space only decreasing as I remove and add back the same component again. Their ridiculous recommendation is to install fewer updates to keep the size of WinSxS under control. Of course, one can&#39;t deny installing security updates so the cost of fixing bugs by installing hotfixes comes at the price of enormous amounts of disk space. The servicing mechanism was redesigned with the aim of more reliable servicing, offline servicing and fast first install, but what turned out to be is more of a downgrade to XP&#39;s update.exe method. The servicing stack causes all sorts of other issues as well like slow boot (Please wait while Windows configures updates crap which we didn&#39;t have in XP), heavy I/O upon logon and logoff when updates are installed and systems being unable to boot because of failed updates (reliable really?). Not to forget the inability it introduced to do a true slipstream of service packs and hotfixes. Windows 7 and SSDs are a huge problem because of WinSxS and sadly I don&#39;t see the servicing mechanism being reworked completely in Windows 8.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920123">
				<div id="div-comment-920123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Troll</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920123">
			June 21, 2011 at 12:35 am</a>		</div>

		<p>&quot;WinSXS directory really doesn&#39;t use significantly more space than was present in prior versions (XP, Windows 2000), it&#39;s just that it&#39;s all in one place so you can see it. It used to be that the same files were kept in a myriad of different places, never shared. Starting with Vista, files superceded by newer updates, links to the current files, copies of files applicable only when you move to the LDR branch (QFEs) and staged updates for future installation are all present in one place. It&#39;s true that there are a ton of new single file directories present and each one uses an MFT entry but really all this stuff was there before. The use of hard links is also problematic for older tools which had never grown up to deal with them before. There are higher level policy decisions which somewhat exacerbate the issue (e.g. nobody wanted to do the new work to connect to WU and download different files when installing or uninstalling an LDR) but actually this was the policy / behavior since Windows 2000 in any case.&quot;</p>
<p>That&#39;s so not true. Looks like people believe what they read if its published by Microsoft without actually verifying how much space WinSxS actually takes. Sure XP stored them scattered in %windir%dllcache, $Uninstall_KBxxx folders and $hf_mig$. But the WinSxS directory takes far far more space in Vista/7 than these folders in XP/2000 combined because in XP/2000, you could specify the /nobackup switch when installing updates so previous versions of files are never backed up. This ability/feature is completely absent in Vista/7 so copies of copies of copies of files accumulate. You can&#39;t delete files like you could delete $Uninstall_KBxxxx$ folders in XP/2000. Deleting those was *harmless* in XP/2000 IF you have no intention to uninstall the hotfixes, the only side effect was they became permanent. You also cannot delete the equivalent of %windir%$hf_mig$ files in XP (now these shouldn&#39;t be deleted) because when doing SFC /scannow, the latest correct version can be obtained from $hf_mig$) but these could be compressed in XP using NTFS compression without sacrificing performance of the OS. In contrast, in Vista/7, compressing WinSxS leads to direct reduction in performance of the OS. Just give users back the damn equivalent to the /nobackup switch for the new servicing mechanism so updates will become permanent and can&#39;t be removed but tons of space is saved. Secondly, all Microsoft tools and especially the Explorer shell needs to be updated to correctly calculate and report the ACTUAL space used instead of just saying &quot;hey those are just hard links, it&#39;s not our problem Explorer miscalculates them&quot;. Vista/7 give no choice to the user whether or not to reserve space for files from various brances (QFE, LDR, GDR) backed up during servicing. That is the main problem. It&#39;s there in Features removed from Vista article on WP: &quot;Windows Vista uses Package Manager (Pkgmgr.exe) and Windows Update Standalone Installer (Wusa.exe) to install software updates and hotfixes. However, these do not support the various command-line switches like Windows XP&#39;s Package Installer (Update.exe) did. Much of the functionality from Update.exe is missing. For example, there is no way to skip backing up uninstall information for hotfixes using the /nobackup or /n switch. Windows Vista backs up files before installing hotfixes to the %Windir%WinSxS folder. Since the backing up of files cannot be skipped, this folder&#39;s disk usage can increase considerably over time.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920213">
				<div id="div-comment-920213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lolski</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920213">
			June 21, 2011 at 7:36 am</a>		</div>

		<p>yeah, and because directories == bundles there&#39;s no need for a registry or a installer on windows. &#8230; oh wait</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920243">
				<div id="div-comment-920243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920243">
			June 21, 2011 at 7:42 am</a>		</div>

		<p>Microsoft has an incredibly difficult job, in that everyone has different designs on how the system should work, and pointedly, to what purpose they&#39;re using Windows. &nbsp;Hence, different needs pulling Microsoft&#39;s design &amp; development teams in many directions at once.</p>
<p>That said, I think it&#39;s fair, giving that I&#39;ve been a professional programmer for DOS/Windows since DOS 2 or 3, that we can say in all fairness that Microsoft has never been very good at organization. &nbsp;Creating standards on the filesystem has, it seems to me, always been an afterthought. &nbsp;</p>
<p>Bundles are a very conscientious forward-thinking approach. &nbsp;They&#39;re imperfect, and don&#39;t cover every usage scenario, but they cover the 80/20 rule, and for the remaining 20% of cases, a custom installer can be written which means that for 80% of the software out there, the user&#39;s experience is much more standardized and under their control.</p>
<p>It&#39;s a difference in philosophy: Apple over-designs and perhaps over-constrains their developers. &nbsp;Microsoft errors on the side of giving very little help by way of standardizing things and leaves it wide open to developers to invent 100 different solutions to the same problem (everyone writes their own installer / uninstaller, e.g.).</p>
<p>Perhaps there is a better balance, that looks towards the 80/20 rule: make it easy for the common cases to &quot;get it right&quot; and &quot;be consistent&quot;, while allowing for the uncommon to have an escape hatch that allows for completely custom scenarios.</p>
<p>In conclusion: Bundles (as the full-meaning from NeXT and now OSX) would be a welcome addition to Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920273">
				<div id="div-comment-920273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skyborne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920273">
			June 21, 2011 at 8:12 am</a>		</div>

		<p>Re Linux package management: it depends on your package manager. &nbsp;I quit using Gentoo when I accidentally broke coreutils (ls, cp, mv, install, etc.) by removing something they actually depended on. &nbsp;Because in the 5 years I was running Gentoo, they never got around to implementing reverse-dependencies, which would have told me, &quot;n00b! ur b0x0rz r 70457 if u d0 th47.&quot;</p>
<p>Regarding security, there are some problems with &quot;just working&quot; without root permissions. &nbsp;Aside from losing some abilities (e.g. on Linux, exposing your gconf schema properly and having a canonical name on DBus), it is also the ideal situation for malware. &nbsp;If there is a hole that allows for running something automatically, then you just lost the game. &nbsp;I assume this is why Windows keeps track of whether files came from the Internet and gives you a chance to reconsider running them.</p>
<p>Also, I wish people would write their installable web apps to support secure configurations instead of requiring code directories to be writable by the webserver, complete with the &quot;You can do this by issuing CHMOD 777 in your FTP client&quot; directions. &gt;X-(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920283">
				<div id="div-comment-920283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/benyaboy_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>benyaboy@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920283">
			June 21, 2011 at 8:33 am</a>		</div>

		<p>In vein with getting stubborn vendors to not put DLLs in system32, or worse c:&lt;theirProduct&gt;, it&#39;s also hard to get them to put non-program files into user profiles appdata and program data. &nbsp; Even when they start putting some data into user/appdata program files are still littered with hundreds of non-program related files. &nbsp;This problem also exists with ini files and the registry.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920163">
				<div id="div-comment-920163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Medinoc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920163">
			June 21, 2011 at 4:54 am</a>		</div>

		<p>I think the main problem with uninstallation nowadays is that there is no convenient way for other users to choose if they want to remove their settings or not. Especially as applications hardly document which registry keys they use (and lets not talk about sharewares, which *purposely* leave something behind when you uninstall them).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920473">
				<div id="div-comment-920473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel Colascione</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920473">
			June 21, 2011 at 3:12 pm</a>		</div>

		<p>@Evan You can use LD_LIBRARY_PATH=/opt/yourapp to get equivalent</p>
<p>behavior, but you&#39;re better off using the package manager if it&#39;s</p>
<p>available. rpath is evil because it doesn&#39;t allow the search path to</p>
<p>be modified at runtime; LD_LIBRARY_PATH is safer and more flexible.</p>
<p>Also, Windows also has a very dangerous policy of loading DLLs by</p>
<p>default from %PATH% and from the <em>current</em> directory in addition to</p>
<p>the executable image directory. You can use SetDllDirectory(&quot;&quot;) to at</p>
<p>least prevent the current directory being searched; every program</p>
<p>written or modified today should have a call to SetDllDirectory(&quot;&quot;) at</p>
<p>the beginning of main or winmain.</p>
<p>@SteveWolf</p>
<p>What do you mean by &quot;hack the DLL&quot;? If you can modify or replace a DLL</p>
<p>used by an image, you can either modify the image directly, or you are</p>
<p>the user running the program in the first place. The attacker is</p>
<p>already on the &quot;other side of the airtight hatchway&quot;, as Raymond likes</p>
<p>to say. Granted, DLL-planting attacks do exist (see my reply to Evan</p>
<p>above) &#8212; but this issue is orthogonal to the security implications</p>
<p>of dynamic loading itself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920493">
				<div id="div-comment-920493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920493">
			June 21, 2011 at 4:23 pm</a>		</div>

		<p>@Raymond: [Meaningless comparison because there was no 64-bit version of Windows 2000. (And the 64-bit version of Windows XP was never in wide distribution. I&#39;m not sure if it&#39;s even serviced.) I think Michael&#39;s point is that the disk space usage hasn&#39;t changed; the files just moved from the various scattered locations they used to be (so you never noticed them before) to a single place where you can complain about them en masse. -Raymond]</p>
<p>xp64 was a commercial available product, w2k64 was available on msdn. You know this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-920503">
				<div id="div-comment-920503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920503">
			June 21, 2011 at 4:35 pm</a>		</div>

		<p>FYI, XP IA64 no longer gets security updates.</p>
<p>&quot;(e.g. nobody wanted to do the new work to connect to WU and download different files when installing or uninstalling an LDR)&quot;</p>
<p>Remember the MS04-xxx IE security updates where the GDR and QFE versions of updates were in different files for everything except Server 2003 and XP SP@?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920623">
				<div id="div-comment-920623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">aaawww</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920623">
			June 22, 2011 at 2:04 am</a>		</div>

		<p>&quot;Increasing the size of each application by a few dozen megabytes is just noise&quot;</p>
<p>I&#39;ve invested in 30G raptors, and those are always full just by windows looking at them.</p>
<p>and yes, it&#39;s more a problem of my pc configuration than a windows problem, I&#39;m not blaming windows here.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-920583">
				<div id="div-comment-920583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Engywuck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920583">
			June 21, 2011 at 11:10 pm</a>		</div>

		<p>*my* &quot;ideal&quot;[1] solution would be to have each program in just three files:</p>
<p>&#8211; myawesomeprogramname.prog which would be a zipped version of all the files needed to run the program plus some support structure for exporting dependencies, file associations provided, available sub-exes, icons etc. So essentially something like an extended .jar but non-java :) or packaged programs for streamed apps (like in XenApp or so). This file could/should be read-only for everyone except the Installer service and maybe &quot;Administrator&quot;</p>
<p>&#8211; myawesomeprogramname.sysconf containing all system-wide settings in a zipped file, editable via some configuration program or otherwise. Can contain a hive structure which is added to registry under HKLMSoftwareMyAwesomeProgramName (not in the previous file because it&#39;s changeable, but that one could contain a static pre-installation version). Writable only for Administrators, can be moved between systems for easy deployment of always-the-same setting in absence of trusted AD relationships (different forests, test machines, &#8230;)</p>
<p>&#8211; myawesomeprogramename.userconf containing all user configurations, located in the users (roaming) app folder. Can contain some (copy of a) hive structure which is mounted in HKCUSoftwareMyAwesomeProgramName . Obviously writable for the user only :D</p>
<p>The latter two may be created upon installation/first run of the program. All neatly packaged, which is what we all want, right :D </p>
<p>For shared librarys I could perhaps be convinced to accept some form of .sharedlibs file :)</p>
<p>[1] i.e. correct for most use cases except drivers etc</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-920863">
				<div id="div-comment-920863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110620-00/?p=10393#comment-920863">
			June 22, 2011 at 11:36 am</a>		</div>

		<p>@Daniel Colascione: &quot;You can use LD_LIBRARY_PATH=/opt/yourapp to get equivalent behavior&quot;</p>
<p>Believe me, I&#39;m well aware of LD_LIBRARY_PATH. I have several scripts sitting around whose purpose is to basically set LD_LIBRARY_PATH so I can use some program. That &quot;solution&quot; sucks. (I think I can replace at least many of those with rpath and ${ORIGIN} now that I know about that.)</p>
<blockquote><p>
  &quot;but you&#39;re better off using the package manager if it&#39;s available&quot;
</p></blockquote>
<p>Which it basically isn&#39;t in my situations, for a number of reasons.</p>
<blockquote><p>
  &quot;Also, Windows also has a very dangerous policy of loading DLLs by default from %PATH% and from the <em>current</em> directory in addition to the executable image directory.&quot;
</p></blockquote>
<p>Yes, this is a dangerous policy.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

