<html>
<head>
<title>What one Windows XP feature am I most proud of?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>What one Windows XP feature am I most proud of?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 1, 2005 / year-entry #369</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>56</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Of all the things I did for Windows XP, if I had to choose the one feature that I'm most proud of, it's fixing Pinball so it doesn't consume 100% CPU. The program was originally written for Windows 95 and had a render loop that simply painted frames as fast as possible. In the checked build, you...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>Of all the things I did for Windows&nbsp;XP, if I had to choose the one feature that I'm most proud of, it's fixing Pinball so it doesn't consume 100% CPU.</p>
<p> The program was originally written for Windows&nbsp;95 and had a render loop that simply painted frames as fast as possible. In the checked build, you could tell the program to display the number of frames per second. They reserved room for two digits of FPS. </p>
<p> When I got to looking at Pinball's CPU usage, I built the checked version and took a peek at the frame rate. Imagine my surprise when I saw that Pinball's frame rate on contemporary hardware was over one million frames per second. </p>
<p> I added a limiter that capped the frame rate to 120 frames per second. This was enough to drop the CPU usage from 100% to 1%. Now you can play Pinball while waiting for your document to print without noticeably impacting printing speed. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (56)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-326353">
				<div id="div-comment-326353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Typhoon121</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326353">
			December 1, 2005 at 10:16 am</a>		</div>

		<p>Yay pinball works </p>
<p>now if only making driver installs/updates/uninstalls were as simple.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326363">
				<div id="div-comment-326363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326363">
			December 1, 2005 at 10:27 am</a>		</div>

		<p>For your next trick, could you make the full screen option on pinball truly full screen?  :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326373">
				<div id="div-comment-326373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326373">
			December 1, 2005 at 10:34 am</a>		</div>

		<p>Do you think someone could issue a patch for Age of Mythology so it doesn&#8217;t gobble up CPU time even when the user has switched away on XP using fast user switching?</p>
<p>It drives me mad when my son leaves it running on his account on a slowish machine around here.</p>
<p>I&#8217;m sure a word from Raymond could get the games group to &quot;pay their taxes&quot; ;-)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326383">
				<div id="div-comment-326383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326383">
			December 1, 2005 at 10:35 am</a>		</div>

		<p>Printing is CPU-bound?  I would have thought that sending data out the parallel port (or USB port, or network, depending on the printer type) wouldn&#8217;t cause much of a burden on the CPU &#8212; certainly not enough to bind it to the CPU&#8217;s speed, to the point where Pinball would slow it down.</p>
<p>(Of course, for the parallel port, it would depend on the port type.  ECP would have almost no CPU burden at all, since it uses DMA.  EPP/SPP might, but only because each byte has to be sent out using a separate I/O port write, so the inter-byte timings need to be just right.)</p>
<p>Oh, wait, maybe you&#8217;re talking about all the print driver/spooler/whatever code that has to run to get the document in a format that the printer can understand?  If the printer supported GDI somehow, directly (similar to a PostScript capable printer under Unix), then most of the translation code wouldn&#8217;t need to run anymore.</p>
<p>But AFAIK there&#8217;s no &quot;wire protocol&quot; for GDI, like there is for PostScript (just write the ASCII-encoded PS characters to the device, and let it interpret it), so that would make it hard.  Hmm&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326393">
				<div id="div-comment-326393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nobody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326393">
			December 1, 2005 at 10:38 am</a>		</div>

		<p>That is nice. However, one thing work looking into is reducing the damage that a 100%-CPU-using application causes to the system. A method that works and is used by almost every OS except Windows is penalizing the priority of the offending thread.</p>
<p>NT uses a weird &quot;randomly boost priorities&quot; method, which is not nearly as good, for obvious reasons.</p>
<p>Of course you have to balance this, as the application may actually need the CPU (for example, games), and the current method gives it more smoothness. That said, I like more the &quot;penalizing&quot; method. And it&#8217;d be awesome if you could limit the percentage of CPU time a process can use, regardless of whether the CPU would be idle otherwise (forceful suspension). I know you can use external applications to do this, but&#8230;</p>
<p>By the way, why do games using VSync (with capped framerate to the one of the monitor) use 100% CPU always? And it&#8217;s kernel time, seems like the driver spinlocks waiting to update.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326403">
				<div id="div-comment-326403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326403">
			December 1, 2005 at 10:50 am</a>		</div>

		<p>Nobody &#8212; probably because there&#8217;s no such thing as an interrupt to tell the OS when the vblank is happening.  (Or at least, if it is there for certain video cards, it isn&#8217;t being used by the video driver for whatever reason.)  So there&#8217;s no way for the kernel driver to say &quot;wake me up when a vblank is about to happen&quot;, so there&#8217;s nothing it can do except spin while monitoring the card or monitor.</p>
<p>(And even if an interrupt did happen, it may be preempted by other interrupts in the system, or the Windows equivalent of Linux&#8217;s &quot;bottom half&quot;/&quot;tasklet&quot; (piece of code that runs outside interrupt context, but is triggered by the interrupt handler code) might get delayed, so there&#8217;s no guarantee that the driver could reliably wait until the next vblank even with the interrupt capability.)</p>
<p>Yes, this is crappy, but I don&#8217;t know of any really reliable way of waiting for an event whose duration is as short as the vblank&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326413">
				<div id="div-comment-326413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326413">
			December 1, 2005 at 10:53 am</a>		</div>

		<p>Nobody, games use 100% CPU because an infinite rendering loop is the simplest way to achieve a high framerate.  Typically, a new game will be designed to stress the hardware, which means it needs maximum performance.  If you know you need max performance, there&#8217;s no point in introducing an artificial limit that won&#8217;t be hit for two or three years (when sufficiently fast hardware is available), because 1) game companies don&#8217;t care about two or three years away; old games aren&#8217;t their money maker, and 2) If you&#8217;re in full-screen mode, why do you really care if it uses 100% CPU or not?  In theory, you&#8217;re not doing anything else anyway.</p>
<p>Tony, just turn off fast user switching.  Then he&#8217;ll either log off properly (and it&#8217;ll close his game), or he won&#8217;t log off at all, and you can easily close it for him.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326423">
				<div id="div-comment-326423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326423">
			December 1, 2005 at 11:00 am</a>		</div>

		<p>Hmm, apparently I should have thought about VSYNC a little more before I replied.  Then I wouldn&#8217;t have referred to the max framerate as an &quot;artificial limit&quot;.  No matter.  I think my previous comment still applies.  If you don&#8217;t expect to get enough frames per second on the newest hardware to max out the vsync, there&#8217;s no point in trying to limit CPU to when you can update.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326433">
				<div id="div-comment-326433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.TheSpoke.net/blogs/TravisOwens/' rel='external nofollow' class='url'>Travis Owens</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326433">
			December 1, 2005 at 11:00 am</a>		</div>

		<p>So why would you limit the frames to 120 instead of the unofficial frame rate standard of 60fps?</p>
<p>I know I&#8217;m splitting hairs but aren&#8217;t you technically doubling the used CPU (ok less than half a percent, I&#8217;m talking principals here).</p>
<p>Does the ball move so fast that it&#8217;s possible to see a minor difference between 60 and 120?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-patriotb odd alt thread-odd thread-alt depth-1" id="comment-326443">
				<div id="div-comment-326443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">PatriotB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326443">
			December 1, 2005 at 11:11 am</a>		</div>

		<p>BryanK &#8212; Raymond likely just used printing as an example of something that pinball could interfere with.</p>
<p>&quot;If the printer supported GDI somehow&#8230;&quot; &quot;But AFAIK there&#8217;s no &quot;wire protocol&quot; for GDI, like there is for PostScript&#8230;&quot;</p>
<p>As far as I know, XPS (XML Paper Specification) is quite like this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-patriotb even thread-even depth-1" id="comment-326453">
				<div id="div-comment-326453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">PatriotB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326453">
			December 1, 2005 at 11:15 am</a>		</div>

		<p>Raymond,</p>
<p>Pinball hasn&#8217;t been included in beta 1 and later builds of Windows Vista.  Since it was originally developed by Maxis, there was speculation that Microsoft&#8217;s license to redistribute it had expired.  Any official word on this?</p>
<p>I expect that you probably either a) don&#8217;t know or b) aren&#8217;t allowed to say, but on the chance that you do know and can say, that would be great. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326463">
				<div id="div-comment-326463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326463">
			December 1, 2005 at 11:22 am</a>		</div>

		<p>IIRC, back in EGA/VGA days there used to be an IRQ wired to the vertical blanking signal&#8230;</p>
<p>And WMF is somewhat like a GDI protocol, although it doesn&#8217;t support all operations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326473">
				<div id="div-comment-326473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.mastropaolo.com' rel='external nofollow' class='url'>Purplet [italy]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326473">
			December 1, 2005 at 11:28 am</a>		</div>

		<blockquote><p>
  &gt; So why would you limit the frames to 120 instead of the unofficial frame rate standard of 60fps? </p>
<p>120fps is high enough to give a new frame per refresh on almost all refresh rates. Still it would have been better to sync with the vertical retrace [which is a relatively long period on current machines] but as some other posts noticed there is no real good way to wait for the vsync without spinlocking (and thus taking 100% of a processing unit).
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326483">
				<div id="div-comment-326483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.starfishgames.co.uk' rel='external nofollow' class='url'>Starfish</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326483">
			December 1, 2005 at 11:31 am</a>		</div>

		<p>Correct me if I&#8217;m wrong, but I believe tearing is more pronounced when FPS is less than your monitor&#8217;s refresh rate due to more movement between frames. In the absence of vsync, higher FPS is better for those of us with CRTs (70Hz+).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326493">
				<div id="div-comment-326493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nobody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326493">
			December 1, 2005 at 11:48 am</a>		</div>

		<p>I think most points are invalid :)</p>
<p>Reasons:<br />
<br />1. Yielding CPU guarantees you NOTHING. Any other thread may start execution at any given time. You are just wasting time.<br />
<br />2. Example of something that has to be synched to the hardware, and is done correctly with a high priority system thread: audio.<br />
<br />3. Some modern games (DooM 3 and derivatives for example) which are capped at 60 fps will release CPU if they don&#8217;t need it &#8211; and they run just fine. Unless you use vsync, which will lock them at 100% CPU usage.</p>
<p>This is a problem with the driver model. If the card is busy (either waiting for vsync or waiting for the render to complete (GPU bound, not CPU bound)), the driver will ate 100% CPU. Read:</p>
<p><a rel="nofollow" target="_new" href="http://www.virtualdub.org/blog/pivot/entry.php?id=74#body" rel="nofollow">http://www.virtualdub.org/blog/pivot/entry.php?id=74#body</a></p>
<p>It could do sleep(1)s, for example. At 60 fps, that wouldn&#8217;t cause more than an 8% performance hit, but benchmarks are more important than real world usage.</p>
<p>That said, Travis Owens, given the right screen, I can easily tell the difference between 60 and 100 fps, so I&#8217;m glad it&#8217;s capped at 120, which is quite reasonable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326503">
				<div id="div-comment-326503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326503">
			December 1, 2005 at 12:11 pm</a>		</div>

		<p>Pinball was even more fun when using Terminal Server.  If you ran it over an RDP connection, then display updates stopped.  That made it impossible to resolve the situation.  IIRC even doing anything on the console was really hard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326523">
				<div id="div-comment-326523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.bobcongdon.com/blog' rel='external nofollow' class='url'>Bob</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326523">
			December 1, 2005 at 12:14 pm</a>		</div>

		<p>A bit off topic but you did mention Pinball ;-)</p>
<p>Anyone know why the old Windows NT driver for HPFS (OS/2 partitions) was called pinball.sys?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326553">
				<div id="div-comment-326553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">unexpected explorer feature</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326553">
			December 1, 2005 at 12:38 pm</a>		</div>

		<p>Can&#8217;t you make Explorer not to consume 100% cpu when clicking on an avi-file?<br />
<br /><a rel="nofollow" target="_new" href="http://miataru.computing.net/windowsxp/wwwboard/forum/14632.html" rel="nofollow">http://miataru.computing.net/windowsxp/wwwboard/forum/14632.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326563">
				<div id="div-comment-326563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Maas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326563">
			December 1, 2005 at 1:07 pm</a>		</div>

		<p>Regarding printing being CPU-bound &#8211; remember that cheap printers are really popular these days, and they are cheap precisely because they offload the heavy-duty work like rasterization to the software driver. Like WinModems, only they&#8217;re WinPrinters. (personally I only buy &quot;real&quot; printers that can interpret PostScript on-board, but I think I&#8217;m in the minority on this :)</p>
<p>Regarding games still eating 100% CPU even when GPU-bound &#8211; this is probably a graphics driver issue. I see no reason why an OpenGL implementation couldn&#8217;t sleep waiting for the buffer swap. Perhaps video driver companies have just been careless because typical users don&#8217;t complain about this. (another possibility might be audio mixing; a lot of games spin off a separate thread for handling audio).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326603">
				<div id="div-comment-326603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326603">
			December 1, 2005 at 1:44 pm</a>		</div>

		<p>I&#8217;m interested to know what method you used to successfully yield CPU time but guarantee you received another timeslice in under 10ms.</p>
<p>All the methods I&#8217;ve tried for yielding in games work most of the time, but a couple of times a second or so the system will sleep for much longer, say 10ms, and not give enough time for a game loop to complete at the required 60fps. Only Sleep(0) has proved reliable in terms of time, but you&#8217;ve pointed out the fallacy of believing Sleep(0) is much use in the past, and it certainly doesn&#8217;t help reduce power consumption on mobile or other downclocking CPU&#8217;s.</p>
<p>I&#8217;ve tried to use a timer object after you suggested this method, and while it was very stable it was unable to wait for the amounts of time I specified &#8211; I concluded that the timer resolution was too low to be useful. Of course, I could just be doing it completely wrong&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ricom even thread-even depth-1" id="comment-326623">
				<div id="div-comment-326623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ricom' rel='external nofollow' class='url'>ricom</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326623">
			December 1, 2005 at 1:50 pm</a>		</div>

		<p>Pinball was the code name for HPFS &#8212; I suppose the name stuck long enough to make it into driver history as pinball.sys</p>
<p>HPFS of course was the high performance file system we wrote for OS/2</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326633">
				<div id="div-comment-326633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bruno</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326633">
			December 1, 2005 at 1:54 pm</a>		</div>

		<p>Maybe you can fix that one too:</p>
<p>&#8211; You hold up a flipper to stop the ball<br />
<br />&#8211; when the ball is in flipper-range you decide not to stop it<br />
<br />&#8211; let go and immediately flip again<br />
<br />&#8211;&gt; ball goes right through the flipper.</p>
<p>This bug has been annoying me for years (was already there in Win95).<br />
<br />Otherwise I really like pinball, it almost acts like the real thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326653">
				<div id="div-comment-326653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326653">
			December 1, 2005 at 2:55 pm</a>		</div>

		<p>Nobody:<br />
<br />1. I&#8217;m assuming that&#8217;s supposed to say &quot;Not yielding guarantees you nothing.&quot;  True, but if you&#8217;re holding onto the CPU, you&#8217;re more likely to be there when you need to be.  Standing in front of a store doesn&#8217;t guarantee you&#8217;ll be the first customer in when it opens, but it increases your chances.</p>
<p>2. Audio&#8217;s not really the same.  Not at all.  An audio play queues up audio in advance and hands it off to the OS.  A game cannot queue frames in advance because 1) it needs to write into a buffer that&#8217;s already locked, 2) it can&#8217;t render fast enough for that (newer games, anyway), and 3) it doesn&#8217;t typically know what the frame will look like until it gets there.  Audio uses a buffer.  Video cannot.  Slight delays in game feedback are unacceptable.</p>
<p>3. A cap of 60 Hz seems ridiculous to me.  My old monitor ran at 85 Hz, and I imagine the game would look better if it matched the refresh rate.  As for why it wastes cycles trying to lock onto the buffer?  If there&#8217;s no reliable way to get notified when it becomes available, a spin lock is the appropriate way to do it.</p>
<p>Capping 3d games in general seems silly to me.  I expect one to use 100% CPU usage.  I&#8217;m in a full screen game, and if it&#8217;s new, it&#8217;s taxing the hardware anyway.  I don&#8217;t really see the need to bother capping it at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326663">
				<div id="div-comment-326663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326663">
			December 1, 2005 at 3:03 pm</a>		</div>

		<p>PatriotB &#8212; I&#8217;ll have to start looking into XPS; it sounds like it could be a fairly decent spec.  Thanks!</p>
<p>josh &#8212; Yeah, I didn&#8217;t think of WMF.  You&#8217;re right, that might be an option for some operations at least.  (But without support for everything, it starts to get a bit unsavory&#8230;)</p>
<p>Nobody: &quot;This is a problem with the driver model.&quot; &#8212; That would not surprise me in the least.  When you make writing a driver as complicated as possible (COM, interfaces, etc.), you make it harder for people to write &quot;obviously-correct&quot; drivers.  And then bad stuff happens.</p>
<p>Dan Maas &#8212; agreed, el-cheapo printers are a problem.  (This isn&#8217;t the only one by any stretch, but when Lexmark makes a Z15 model that costs about $20, what should I expect?  Yikes.)  I would love to be able to use PS capable printers at home (mostly because I use Linux at home, and everything prints to PS format &#8212; then I could just pipe it directly to the printer).  My one printer, however, is a LaserJet 1100 that speaks PCL4 or 5, not PS.</p>
<p>But at least PCL is documented somewhere, and people have written PCL backends for Ghostscript.  (But note that when I&#8217;m writing directly from GS to the printer, my CPU is still down in the 1% range.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326673">
				<div id="div-comment-326673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://hoogervorst.dyndns.org/~alfons/wordpress' rel='external nofollow' class='url'>alfons</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326673">
			December 1, 2005 at 3:15 pm</a>		</div>

		<p>IIRC only a certain IBM manufactured EGA/VGA card had an interrupt dedicated to VBLANK.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326683">
				<div id="div-comment-326683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">eruprahgp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326683">
			December 1, 2005 at 4:26 pm</a>		</div>

		<p>If there was room for only 2 digits of FPS how could you tell whether it was rendering million frames per second or even 120 for that matter.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326693">
				<div id="div-comment-326693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326693">
			December 1, 2005 at 5:05 pm</a>		</div>

		<p>eruprahgp,</p>
<p>&quot;When I got to looking at Pinball&#8217;s CPU usage, I built the checked version and took a peek at the frame rate. Imagine my surprise when I saw that Pinball&#8217;s frame rate on contemporary hardware was over one million frames per second.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326703">
				<div id="div-comment-326703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">eruprahgp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326703">
			December 1, 2005 at 5:21 pm</a>		</div>

		<p>Steve<br />
<br />&quot;The program was originally written for Windows 95 and had a render loop that simply painted frames as fast as possible. In the checked build, you could tell the program to display the number of frames per second. They reserved room for two digits of FPS. &quot;<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-326713">
				<div id="div-comment-326713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326713">
			December 1, 2005 at 5:40 pm</a>		</div>

		<p>Perhaps Raymond noticed that the two-digit framerate counter was &#8216;reporting&#8217; a framerate of &quot;00&quot; and decided to increase the number of characters reserved for it? After all, if he can modify it to yield CPU, he could surely have modified it to display more characters :)</p>
<p>Also, on the vsync issue. The amount of time for a monitor to do a vsync is in the order of micro seconds. That means you have a VERY short amount of time to actually swap your back/front buffers in order to get it done before the vsync finishes. If you used an interrupt to notify the application that the vsync was happening, it would hardly have enough time to context-switch to the process let alone actually do the buffer swap. That&#8217;s why you need to use a spin loop &#8211; to ensure the right process is already when the vsync happens.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-326723">
				<div id="div-comment-326723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326723">
			December 1, 2005 at 5:42 pm</a>		</div>

		<p>eruprahgp, I leave it to you as a puzzle how I was able to figure out the actual frame rate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326743">
				<div id="div-comment-326743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.foxyshadis.com' rel='external nofollow' class='url'>foxyshadis</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326743">
			December 1, 2005 at 6:44 pm</a>		</div>

		<p>A little interesting info on using vsync with directx I read a while back.</p>
<p><a rel="nofollow" target="_new" href="http://www.virtualdub.org/blog/pivot/entry.php?id=74" rel="nofollow">http://www.virtualdub.org/blog/pivot/entry.php?id=74</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326753">
				<div id="div-comment-326753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.geekswithblogs.net/dtotzke' rel='external nofollow' class='url'>David Totzke</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326753">
			December 1, 2005 at 7:10 pm</a>		</div>

		<p>Yeah Raymond.  I&#8217;ve loved that game since day one.  So smooth.</p>
<p>thanks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326763">
				<div id="div-comment-326763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sean.cyberwang.net' rel='external nofollow' class='url'>Sean Bryant</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326763">
			December 1, 2005 at 7:17 pm</a>		</div>

		<p>So does that mean the Pinball game uses frame based animation?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326783">
				<div id="div-comment-326783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Maas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326783">
			December 1, 2005 at 8:04 pm</a>		</div>

		<p>I don&#8217;t think sleep(N) is relevant to reducing CPU usage in GPU-bound programs. The graphics driver just needs to put the thread to sleep waiting for an interrupt that signals fresh space in the graphics command buffer. From the application&#8217;s point of view, it would just block in glSwapBuffers().</p>
<p>NVIDIA cards definitely send an interrupt for each refresh; I&#8217;ve seen them on interrupt profiles of a Linux system (just idling in X). </p>
<p>Since the graphics command transfer is DMA based I also expect there are interrupts to signal completion of command buffers (just like ethernet and SCSI cards that use bus-master DMA).</p>
<p>NVIDIA recently added an OpenGL extension that allows fine-grained synchronization within the command stream. There are functions that insert markers into the command buffer and sleep until execution reaches a specific marker.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326793">
				<div id="div-comment-326793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.borland.com/chewy' rel='external nofollow' class='url'>Chee Wee Chua</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326793">
			December 1, 2005 at 8:58 pm</a>		</div>

		<p>Fact nugget :o)</p>
<p>In his homepage, <a rel="nofollow" target="_new" href="http://homepages.borland.com/dthorpe/products.html" rel="nofollow">http://homepages.borland.com/dthorpe/products.html</a> , Danny Thorpe wrote that he was the original author of Pinball, having written it in Delphi sometime before 1995.</p>
<p>And when he got wind of it that Microsoft was purchasing the game, he converted the game from Delphi to C++.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ricom odd alt thread-odd thread-alt depth-1" id="comment-326613">
				<div id="div-comment-326613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ricom' rel='external nofollow' class='url'>ricom</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326613">
			December 1, 2005 at 1:45 pm</a>		</div>

		<p>I&#8217;d like to point out that Raymond is most proud of his PERFORMANCE work :)</p>
<p>*laugh*</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326643">
				<div id="div-comment-326643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AVI hell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326643">
			December 1, 2005 at 2:00 pm</a>		</div>

		<p>&gt;&gt; Can&#8217;t you make Explorer not to consume 100%<br />
<br />&gt;&gt; cpu when clicking on an avi-file?</p>
<p>Oh yeah. But the REALLY pathetic thing is:</p>
<p>You select an .AVI file. It builds preview, even if there is no need for it (just to show duration or video dimensions on the status line). A small spike of CPU, but bearable. (Depends on file length, it might me one second or more)</p>
<p>Now, another application starts to write to ANOTHER FILE on the same folder. For example, a download. EVERY WRITE on ANY FILE of that folder will re-trigger the preview.</p>
<p>So, welcome to 100% CPU usage for no apparent reason, even if the window is not even visible. Heck, when focusing it again it will regenerate preview, so just hitting ALT+TAB again and again will keep it at 100% CPU.</p>
<p>That is if you are lucky. If the file is incomplete, see quoted post. If it is corrupt, cross your fingers, chances of a segfault are very high.</p>
<p>And if you try to move/delete the file while the preview is generating, the F**KIN&#8217; shell will LIE to you and tell you that ANOTHER app is locking the file. Perfect, just perfect.</p>
<p>No wonder the thing that makes R.C. most proud it this: it might very well be the only thing that is not insanely, hopelessly broken in XP.</p>
<p>I guess this doesn&#8217;t happen with .WMV files. Somebody should sue Microsoft for that. :D</p>
<p>And the limiter is 120 fps? Then why the game runs at 100 fps? Ah yes! Windows XP still uses a 100Hz clock interrupt frequency, right? What about changing that to 1KHz, like linux did some time ago? Oh, can somebody with an SMP machine check if itâs 66 fps for them? I think the HAL used 15 ms for the interrupt on SMP machines; but as always with Windows, the constant is buried deep on some binary file, to give the user zero options.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-larryosterman odd alt thread-odd thread-alt depth-1" id="comment-326813">
				<div id="div-comment-326813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Larry+Osterman+%5BMSFT%5D' rel='external nofollow' class='url'>Larry Osterman [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326813">
			December 1, 2005 at 11:24 pm</a>		</div>

		<p>hpfs was called pinball.sys because pinball was the code name of the project that resulted in the filesystem known as pinball (more-or-less).</p>
<p>There were a number of &quot;-ball&quot; code names in Lan Manager, pinball, football, winball, etc.</p>
<p>HPFS was IBM&#8217;s name for the filesystem that was implemented in the pinball project.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326823">
				<div id="div-comment-326823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.virtualdub.org/' rel='external nofollow' class='url'>Phaeron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326823">
			December 2, 2005 at 12:04 am</a>		</div>

		<p>Sleep()&#8217;s precision can be improved by calling timeBeginPeriod(1), but that globally taxes the system with interrupt overhead. Also, in a 3D program, it&#8217;s hard to gauge whether you&#8217;re going to block due to the command buffer becoming full, and there&#8217;s no way to tell the driver not to spin. The good news is that I think Vista is going to force a resolution on this issue, given the much broader use of the GPU.</p>
<p>Programs unnecessarily using 100% of the CPU is a pet peeve of mine, since a program written for a Pentium doesn&#8217;t need the full power of a Pentium 4, and it causes my laptop to heat up and turn all its fans on. I usually force the CPU to low speed, and then patch the import for PeekMessage() and insert a Sleep(). :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326773">
				<div id="div-comment-326773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nobody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326773">
			December 1, 2005 at 7:28 pm</a>		</div>

		<p>Derek:<br />
<br />Yeah, that&#8217;s what I meant.</p>
<p>You don&#8217;t need &quot;to be there&quot; for VSYNC to work. If the HW doesn&#8217;t have an interrupt, it has an special register to change the screen buffer on vertical blank. This is the only correct way to do this. If you didn&#8217;t to it this way, you could see tearing of you came too late, or have to wait again (and that would have the potential to repeat itself forever).</p>
<p>The spinlock is to start rendering the next frame. The front buffer is displayed. The back buffer is waiting to be displayed, switched with the front buffer. And the application is waiting until the swap happens, so it has a buffer to draw to.</p>
<p>Version &quot;B&quot; is GPU-bound games, not vsynched. If an app is CPU bound, kernel (driver) CPU time is about 10%. If GPU bound, kernel CPU time becomes 50%. The application issues a request, the GPU is busy and the command queue full, so the driver spinlocks until the request can go through, instead of releasing the CPU gracefully.</p>
<p>VSync is a special case of &quot;GPU bound&quot;: GPU causes delay while waiting for vblank.</p>
<p>On GPU-bound games, you can&#8217;t really release the CPU unless the command buffer is hugue, because it has the potential to fill several times in a single frame, and doing sleep(1)s would cause great harm.</p>
<p>But consider vsync at 60 hz: doing sleep(1)s, you would lose at most 1 ms per frame. At a maximum of 60fps, that&#8217;s 60 ms per second. I think that is very reasonable, 6% max performance impact, much nicer multitasking.</p>
<p>60 fps caps are crap, but it&#8217;d appear that &quot;id software&quot; felt lazy and didn&#8217;t want to do things the good, parametric way. Fixed ticrates solve a lot of problems, but they inherently cap the framerate *AND* waste processing power if the framerate falls bellow that, because multiple tics have to be calculated per frame. But if you can sustain 60fps, it&#8217;s very nice the CPU usage falls bellow 100%. It it took 4 ms to render a frame, the game does a sleep(12) and everybody is very happy.</p>
<p>The &quot;consume 100% CPU to run a bit faster&quot; is a very bad policy. Even in fullscreen mode, if you leave CPU time, you could do things like encoding in the background. Dual core CPUs are a crappy &quot;patch&quot; to this: if the game used two threads which never sleep or lock, you&#8217;d be in the same situation again.</p>
<p>Finally, the only reasonable reason to go beyond the monitor&#8217;s refresh rate is to reduce controller latency. If you DON&#8217;T sleep between capturing the input and drawing the image (like a lot of games do, and like vsync forces you inherently to), you wouldn&#8217;t have to do that. 125 fps is a reasonable &quot;true&quot; ceiling: that&#8217;s the USB HID capture rate, you&#8217;d render frames that had no input between them, and most people would lose perception at around 90 fps anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326843">
				<div id="div-comment-326843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan Wilson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326843">
			December 2, 2005 at 9:22 am</a>		</div>

		<p>A lot of cheap printers basicly implement a propriatory control protocol and a propriatory compression algorithim and have the software drivers rasterize everything into a raster image, compress it with the propriatory compression algorithim and send it (in bits so it can fit into the memory of the printer) to be printed.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326853">
				<div id="div-comment-326853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andy C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326853">
			December 2, 2005 at 9:26 am</a>		</div>

		<p>Derek: &quot;<a rel="nofollow" target="_new" href="http://xp.c2.com/DoTheSimplestThingThatCouldPossiblyWork.html&quot;" rel="nofollow"></a><a href="http://xp.c2.com/DoTheSimplestThingThatCouldPossiblyWork.html&#038;quot" rel="nofollow">http://xp.c2.com/DoTheSimplestThingThatCouldPossiblyWork.html&#038;quot</a>;</p>
<p>That&#8217;s a pretty flawed argument. Following that the best way to wait for anything is just to spin-lock.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326863">
				<div id="div-comment-326863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326863">
			December 2, 2005 at 9:39 am</a>		</div>

		<p>Being someone who writes tools for games as a living, there is nothing worse than a rendering engine running full tilt.  After 2 1/2 years, I am still fighting that flawed mentality.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326913">
				<div id="div-comment-326913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.TheSpoke.net/Blogs/TravisOwens/' rel='external nofollow' class='url'>Travis Owens</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326913">
			December 2, 2005 at 11:30 am</a>		</div>

		<p>Derek said:<br />
<br />&quot;Capping 3d games in general seems silly to me. I expect one to use 100% CPU usage. I&#8217;m in a full screen game, and if it&#8217;s new, it&#8217;s taxing the hardware anyway. I don&#8217;t really see the need to bother capping it at all.&quot;</p>
<p>This is a HORRIBLE mindset because you&#8217;re now wasting power.  Intel and Microsoft have both proven power conservation is important (for both your wallet, the enviroment and the noise of your system) and both companies upcoming products take this seriously.</p>
<p>This issue isn&#8217;t limited to just laptops (where&#8217;s it&#8217;s obvious what happens if you burn 100% cpu) and don&#8217;t fall into the mindset of &quot;laptops shouldn&#8217;t play games&quot; either, this applies to desktops just as much as laptops.  Just because my desktop has access to an unlimited supply of power doesn&#8217;t mean I want it to use (waste) it.  Unless you like the idea of owning a 600watt PSU, which is where desktops are going now-a-days, and it&#8217;s not a good thing.</p>
<p>Computers need to use less power, not more, watts are the lazy man&#8217;s answer to faster.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326923">
				<div id="div-comment-326923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.TheSpoke.net/Blogs/TravisOwens/' rel='external nofollow' class='url'>Travis Owens</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326923">
			December 2, 2005 at 11:34 am</a>		</div>

		<p>Jonathan Wilson said:<br />
<br />&quot;A lot of cheap printers &#8230; rasterize everything &#8230; and send it to the printer&quot;</p>
<p>Aren&#8217;t a lot of mid level printers doing this too?  It sure seems like it on the &lt;insert a popular office printer company&gt; color laser printers I&#8217;ve used (both mid level and high level models I&#8217;ve used).</p>
<p>I&#8217;ve noticed when I flatten an image, images with lots of blank data (lots of white) send significantly faster than an image with withs of colors as iirc image compress is favorable to lots of blank/repeatable areas.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326933">
				<div id="div-comment-326933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326933">
			December 2, 2005 at 11:35 am</a>		</div>

		<p>Andy, that&#8217;s not at all what I&#8217;m saying.  While waiting in a spin lock is pretty much the simplest thing, it doesn&#8217;t always work.  It doesn&#8217;t work for Mozilla to spin lock while waiting for a connection to this blog.  It would drive the user insane.  A game, on the other hand, can spin lock waiting to update with VSYNC, because 1) the typical user isn&#8217;t doing anything else with their computer then anyway, and 2) there&#8217;s a definite (small) maximum amount of time before the next VSYNC event occurs.</p>
<p>The Simplest Thing That Could Possibly Work is a great rule, but you have to look at the spirit of the rule, not the most literal interpretation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-326943">
				<div id="div-comment-326943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326943">
			December 2, 2005 at 11:40 am</a>		</div>

		<p>Travis, I&#8217;m advocating it because modern games typically push the hardware to its max anyway.  I see little reason to bother with a cap that may not be hit for at least a year (or more).  It&#8217;s more code that now must be tested, now must be supported, etc.  It&#8217;s not economical to bother with it, especially since most customers don&#8217;t seem to be asking for it.</p>
<p>If you&#8217;re writing a game that you expect to hit 150 fps on typical hardware, sure, put in a cap.  But who&#8217;s writing games like that?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-326833">
				<div id="div-comment-326833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-326833">
			December 2, 2005 at 8:15 am</a>		</div>

		<p>Nobody, if you&#8217;re not constantly waiting, how are you going to know when that register changes?  Yeah, you can look when your thread wakes up, but it&#8217;s potentially faster to just spin.  (If there&#8217;s an interrupt, though, the driver should probably use it instead of spinning.)</p>
<p>`But consider vsync at 60 hz: doing sleep(1)s, you would lose at most 1 ms per frame.`  No.  You lose, an *minimum* 1 ms per frame, and probably much more.  You can&#8217;t expect the CPU to wake you up in exactly 1 ms.  It&#8217;s extremely unlikely to happen.</p>
<p>`The &quot;consume 100% CPU to run a bit faster&quot; is a very bad policy.`  It&#8217;s the simplest thing.  There&#8217;s little compelling reason for a full-screen game to bother trying to share the CPU.  (I don&#8217;t personally see the need to encode while playing a game.)</p>
<p><a rel="nofollow" target="_new" href="http://xp.c2.com/DoTheSimplestThingThatCouldPossiblyWork.html" rel="nofollow">http://xp.c2.com/DoTheSimplestThingThatCouldPossiblyWork.html</a></p>
<p>`Dual core CPUs are a crappy &quot;patch&quot; to this: if the game used two threads which never sleep or lock, you&#8217;d be in the same situation again.`<br />
<br />I can&#8217;t imagine why a typical rendering engine would use both threads, unless it was CPU bound, and somehow resulted in a better framerate if it split processing.  Audio, file i/o, etc. have no need to be infinite loops.</p>
<p>Phaeron, will that actually go through?  Or will it return ERROR_NOCANDO?  And of course, how bad is the penalty on that?</p>
<p>Also, why doesn&#8217;t this thing ever freaking remember me, even when I check the box?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-327113">
				<div id="div-comment-327113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.virtualdub.org/' rel='external nofollow' class='url'>Phaeron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-327113">
			December 3, 2005 at 1:55 am</a>		</div>

		<p>Derek: timeBeginPeriod(1) works for me on XP, although in practice you would want to call timeGetDevCaps() to retrieve the actual supported minimum. As for the overhead, I don&#8217;t have numbers, but I suspect it&#8217;s fairly minimal now. It used to be noticeable in the days of Windows 95 â I could see a significant difference in WinTop that went away when I reset the timer rate from a DOS prompt.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-327123">
				<div id="div-comment-327123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nobody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-327123">
			December 3, 2005 at 8:17 am</a>		</div>

		<p>Derek: No, no, no :)</p>
<p>Ok, so the game might be &quot;hardware pushing&quot; right now. Will it be in 2 year&#8217;s time? Heck, on most occasions you *HAVE* to put a cap, otherwise once the game will behave incorrectly in future hardware. The boxed version of Quake 2 runs at over 1000fps here, and it DOES NOT WORK. You can&#8217;t move, it&#8217;s hitting some numeric precision limit.</p>
<p>Newer games usually come with a reasonable cap. For example, in Half-Life 2 it&#8217;s 300fps. In HL1/CS it was 72 fps (you can increase it to 100), and most machines now will run solid at that framerate. A lot of people play it still, and they are suffering your mentality.</p>
<p>Moreover:</p>
<p>1. If you release the CPU on a &quot;right&quot; moment, when you have nothing to do, background apps/services that have to do very little work will do it when they don&#8217;t &quot;annoy&quot;, instead of when you were doing useful work.</p>
<p>2. Again, in the general case, not much point in going over the monitor&#8217;s refresh rate. With top-of-the-line hardware, even the latest games can run at ~70fps most of the time, so it&#8217;s necessary even today.</p>
<p>3. It&#8217;s better if the game runs consistently than at varying speeds. Think about console games: all of them are VSynched; some at 60 and some at 30 Hz. Obviously not all scenes require the same amount of work, so just thing how many processing power they are wasting most of the time. Except they aren&#8217;t wasting it: that&#8217;s the best option for the work at hand.</p>
<p>100% CPU usage makes sense for data processing (such as video encoding, offline rendering, compiling if you aren&#8217;t IO-bound, that kind of thing). For real time stuff (audio, video, videogames) what you want is a picture every 16 or 33 ms, so to speak. Not all will take the same time, and obviously the CPU will be bellow 100%. That&#8217;s the right way. Donât think âooh, itâs cool it uses the hardware to its fullestâ. It doesnât. Either the graphics card or the CPU is waiting for the other. And of you get 500fps, youâll just get tearing, and cause other problems (too high C-&gt;S traffic in some games, this is why Quake3 and UT2004 are capped at around 90fps)</p>
<p>Just think HDTV video clips: my media player uses 80% CPU and it still runs &quot;just fine&quot;. Likewise, 60fps clips: they play smooth, and the player doesn&#8217;t have to hog the CPU. Decoding a huge video frame can take as many CPU time as the CPU processing a game does. With your mentality, it&#8217;d be OK for video players to use 100% CPU, since &quot;most people don&#8217;t do other things when they&#8217;re watching movies&quot;.</p>
<p>I donât know if Iâm ânormalâ, but not only I whish games left CPU power to do âoffline stuffâ (as mentioned above), but a lot of games (in particular multiplayer ones) are prone to be run windowed and left unattended. Quake 4 does that right: if you leave it in the background, it caps itself to 8fps, and only needs 3% CPU time.</p>
<p>Think about it :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-327193">
				<div id="div-comment-327193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-327193">
			December 4, 2005 at 10:52 am</a>		</div>

		<p>Game companies aren&#8217;t making their money selling two year old games.  It&#8217;s hard to see a good reason for them to bother with something expected to be needed in two years.  But, I guess if they are putting the cap in, it must be more requested than I would expect.</p>
<p>However, I don&#8217;t think that you *have* to put a cap in older games.  Pinball was running at over a million fps just fine.  I don&#8217;t know what&#8217;s wrong with Quake, but that sounds like a bug.</p>
<p>1. Eh.  I&#8217;m not sure that&#8217;s necessarily the case.  If the background stuff has little enough to do, it shouldn&#8217;t matter much if it grabs the processor during rendering.  On the other hand, if it&#8217;s not a small amount of processing, it might be problematic even if it takes over between rendering frames.</p>
<p>2. I don&#8217;t know anyone currently running top-of-the-line hardware.  Most people aren&#8217;t.  And most people&#8217;s hardware is getting quite stressed by new games, I&#8217;m pretty sure.</p>
<p>3. You make it sound like VSYNC guarantees a new frame every time it refreshes.  That&#8217;s just not the case.  If the framerate drops to 10 fps, that&#8217;s just all you&#8217;re going to get.</p>
<p>I do think it would probably be okay for full-screen video players to use 100% CPU.  But there&#8217;s no point in it.  Again, you&#8217;re comparing a buffered program to one which doesn&#8217;t buffer.  It&#8217;s not a fair comparison.  It would be more complex for a video player to use 100% CPU (what&#8217;s it doing when it finishes filling the buffer?), whereas a game using 100% CPU is simpler than one which is capped.</p>
<p>As for capping when not the front window, I&#8217;ll agree that&#8217;s useful.  (It&#8217;s also nice that most games started handling alt-tabbing without crashing, finally.)</p>
<p>I&#8217;m not saying there it&#8217;s bad to put a cap on full screen games.  I just don&#8217;t think it&#8217;s necessary, or can always be considered a good expenditure of resources.  (Putting the game in the background is a really good example of a time when it&#8217;s appropriate to cap the framerate, though.)</p>
<p>I do agree that drivers probably shouldn&#8217;t spinlock waiting for vsync if they can catch an interrupt notification instead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-327263">
				<div id="div-comment-327263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gamer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-327263">
			December 4, 2005 at 9:08 pm</a>		</div>

		<p>Noninteractive video playback isn&#8217;t comparable with interactive rendering. Video playback cab buffer several frames in advance, but with interactive rendering it&#8217;s worth striving for the least latency from input to output. With tripple buffering that&#8217;s possible without tearing, it&#8217;s also better to always render frames than give timeslices away to other apps. When I play games I want the minimum latency possible between input &amp; ouput, other running tasks should not be prioritized.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-327313">
				<div id="div-comment-327313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://runesbike.com/' rel='external nofollow' class='url'>Rune</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-327313">
			December 5, 2005 at 4:08 am</a>		</div>

		<p>But guys, most games today are GPU bound. (atleast at resolutions like 1920&#215;1200 and higher) There should be &quot;plenty&quot; (20% or more in most cases) CPU left&#8230;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-327323">
				<div id="div-comment-327323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andy C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-327323">
			December 5, 2005 at 6:53 am</a>		</div>

		<p>Derek, the problem with the &quot;The CPU isn&#8217;t doing anything else&quot; mentality is that it doesn&#8217;t play well with systems like laptops that could be using that time to conserve power and so on. Playing nice with the rest of the system is one of Raymond&#8217;s taxes and games developers really ought to be as aware of them as anyone else is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-329253">
				<div id="div-comment-329253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Strange, strange...</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-329253">
			December 10, 2005 at 12:13 pm</a>		</div>

		<p>I just built an app to measure sleep() accuracy, doing sleep(1)s and averaging large sets of measurements; also running in real-time (or high, same results) priority and only outputing every 1000 measurements or so to avoid the printing affect the results.</p>
<p>On a Pentium-M, on any frequency, sleep(1) takes 10 milliseconds; that&#8217;s the interrupt running at 100 Hz. When you open some application that uses timeBeginPeriod(1) (such as a media player), it raises to 1000 Hz. This is what I expected.</p>
<p>On a (desktop) Pentium 4, things are different. I tested this on a non-HT 2.53 Ghz and an HT 3 Ghz machine, and surprisingly got the same results. About 64 Hz normally, 512 Hz when media player is open. Very strange.</p>
<p>Also, Sysinternal&#8217;s Process Explorer shows &quot;context switches&quot; statistics. For my test process, they matched what I said. For the fake &quot;Interrupts&quot; process, on the P-M it hovers around 100-200 normally and 1050-1150 when media player open, which matches what I expected.</p>
<p>On the P-4s, the machines were more interrupt-busy, but they were at about 250 normally and rose over 1200 when the media player was open, which doesn&#8217;t make sense since I expected them to grow only 512-64=448.</p>
<p>Interesting stuff:</p>
<p>* Most media players set timeBeginPeriod(1) when starting to play, and won&#8217;t release it until they are closed.</p>
<p>* VirtualDub doesn&#8217;t set it at all.</p>
<p>* Flash player browser plugin (at least on Firefox) sets it when a flash object is used on a page, and releases it when you change to another page or close that tab/window. Very good :)</p>
<p>* Quicktime plugin sets it when it&#8217;s first loaded and never releases it, until you close the browser :( (somehow this doesn&#8217;t surprise me)</p>
<p>* Viewing animated GIF files doesnât activate it (I think they only had 10ms delay accuracy, so thatâs OK)</p>
<p>There&#8217;s no significant performance degradation for using 1000 Hz timer, I measured this with an app that just counts the time it takes to loop a few million times. The services that are loaded at startup affect much more the result than the 1000 Hz timer. Of course, if there&#8217;s a stupid application using sleep(1)s as a sync primitive, that&#8217;d increase its CPU usage 10-fold :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-404663">
				<div id="div-comment-404663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://letskilldave.com/archive/2006/07/31/The-Old-New-Thing.aspx' rel='external nofollow' class='url'>Let's Kill Dave!</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051201-09/?p=33133#comment-404663">
			July 31, 2006 at 8:52 am</a>		</div>

		<p>If you ever hope to be a great Windows programmer, take the time to read/subscribe toRaymond Chen&#8217;s blog,</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

