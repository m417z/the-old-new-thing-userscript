<html>
<head>
<title>Why can't you thunk between 32-bit and 64-bit Windows?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why can&#8217;t you thunk between 32-bit and 64-bit Windows?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 20, 2008 / year-entry #344</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>36</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">It was possible to use generic thunks in 16-bit code to allow it to call into 32-bit code. Why can't we do the same thing to allow 32-bit code to call 64-bit code? It's the address space. Both 16-bit and 32-bit Windows lived in a 32-bit linear address space. The terms 16 and 32 refer...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>It was possible to use generic thunks in 16-bit code to allow it to call into 32-bit code. <a href="http://blogs.msdn.com/oldnewthing/archive/2005/07/20/440918.aspx#441290"> Why can't we do the same thing to  allow 32-bit code to call 64-bit code</a>?</p>
<p> It's the address space. </p>
<p> Both 16-bit and 32-bit Windows lived in a 32-bit linear address space. The terms 16 and 32 refer to the size of the offset relative to the selector. </p>
<p> Okay, I suspect most people haven't had to deal with selectors (and that's probably a good thing). In 16-bit Windows, addresses were specified in the form of a selector (often mistakenly called a "segment") and an offset. For example, a typical address might be <code>0x0123:0x4567</code>. This means "The byte at offset 0x4567 relative to the selector 0x0123." Each selector had a corresponding entry in one of the descriptor tables which describes things like what type of selector it is (can it be used to read data? write data? execute code?), but what's important here is that it also contained a base address and a limit. For example, the entry for selector <code>0x0123</code> might say "0x0123 is a read-only data selector which begins at linear address 0x00524200 and has a limit of 0x7FFF." This means that the address <code>0x0123:n</code> refers to the byte whose linear address is <nobr><code>0x00524200</code> + n</nobr>, provided that <nobr>n &le; <code>0x7FFF</code></nobr>. </p>
<p> With the introduction of the 80386, the maximum limit for a selector was raised from <code>0xFFFF</code> to <code>0xFFFFFFFF</code>. (Accessing the bytes past <code>0xFFFF</code> required a 32-bit offset, of course.) Now, if you were clever, you could say "Well, let me create a selector and set its base to <code>0x00000000</code> and its limit to <code>0xFFFFFFFF</code>. With this selector, I can access the entire 32-bit linear address space. There's no need to chop it up into 64KB chunks like I had to back in the 16-bit days. And then I can just declare that <i>all addresses will be in this form</i> and nobody would have to bother specifying which selector to use since it is implied." </p>
<p> And if you said this, then you invented the Win32 addressing scheme. It's not that there are no selectors; it's just that there is effectively only one selector, so there's no need to say it all the time. </p>
<p> Now let's look at the consequences of this for thunking. </p>
<p> First, notice that a full-sized 16-bit pointer and a 32-bit flat pointer are the same size. The value <code>0x0123:0x467</code> requires 32 bits, and wow, so too does a 32-bit pointer. This means that data structures containing pointers do not change size between their 16-bit and 32-bit counterparts. A very handy coincidence. </p>
<p> Next, notice that the 16-bit address space is still fully capable of referring to every byte in the 32-bit address space, since they are both windows into the same underlying linear address space. It's just that the 16-bit address space can only see the underlying linear address space in windows of 64KB, whereas the 32-bit address space can see it all at once. This means that any memory that 32-bit code can access 16-bit code can also access. It's just more cumbersome from the 16-bit side since you have to build a temporary address window. </p>
<p> Neither of these two observations holds true for 32-bit to 64-bit thunking. The size of the pointer has changed, which means that converting a 32-bit structure to a 64-bit structure and vice versa changes the size of the structure. And the 64-bit address space is four billion times larger than the 32-bit address space. If there is some memory in the 64-bit address space at offset <code>0x000006fb`01234567</code>, 32-bit code will be unable to access it. It's not like you can build a temporary address window, because 32-bit flat code doesn't know about these temporary address windows; they abandoned selectors, remember? </p>
<p> It's one thing when two people have two different words to describe the same thing. But if one party doesn't even have the capability of talking about that thing, translating between the two will be quite difficult indeed. </p>
<p> P.S., like most things I state as "fact", this is just <a href="http://blogs.msdn.com/oldnewthing/archive/2007/08/10/4315707.aspx"> informed speculation</a>. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (36)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-676033">
				<div id="div-comment-676033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676033">
			October 20, 2008 at 10:17 am</a>		</div>

		<p>I, for one, will continue to consider this information to be fact.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676073">
				<div id="div-comment-676073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676073">
			October 20, 2008 at 10:58 am</a>		</div>

		<p>&quot;In 16-bit Windows, addresses were specified in the form of a selector (often mistakenly called a &quot;segment&quot;) and an offset.&quot;</p>
<p>Interesting stuff Raymond every book or article I&#8217;ve ever seen on assembly language programming has referred to what you call selector&#8217;s as segments. Including this entry from Wikipedia.</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/X86_assembly_language" rel="nofollow">http://en.wikipedia.org/wiki/X86_assembly_language</a></p>
<p>Could you explain more about why the term &quot;segment&quot; is mistaken and shouldn&#8217;t be used?</p>
<p>Also, if</p>
<p>&quot;And if you said this, then you invented the Win32 addressing scheme. It&#8217;s not that there are no selectors; it&#8217;s just that there is effectively only one selector, so there&#8217;s no need to say it all the time.&quot;</p>
<p>is true then how are read, execute, and write only properties tracked in Win 32 addressing?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676083">
				<div id="div-comment-676083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676083">
			October 20, 2008 at 11:10 am</a>		</div>

		<p>It&#8217;s a long time since I&#8217;ve done any thunking, but IIRC:</p>
<p>1. 16-bit pointers (i.e. 32-bit wide selector+offset pairs) were unintelligible to 32-bit code, and</p>
<p>2. Despite having same-width pointers, 32-bit structures often differed from their 16-bit counterparts, so</p>
<p>3. To call 32-bit code from 16-bit code you had to declare a 32-bit version of the structure and pass any pointers in the structure through GetVDMPointer32W().</p>
<p>As long as the 32-bit API returns data in a caller supplied buffer (which APIs usually do) this technique works fine.</p>
<p>Note that this never converts an arbitrary 32-bit pointer to 16-bit, so it would also work for 32-bit to 64-bit. &nbsp;So there must be some other reason for the lack of 32-bit to 64-bit thunks.</p>
<div class=post>[<i>Yes, you had to do all this work, but at least it was <u>possible</u> because 32-bit pointers and 16:16 pointers all pointed into the same underlying address space. (&#8220;&#8230;notice that the 16-bit address space is still fully capable of referring to every byte in the 32-bit address space&#8230;&#8221;) Not true for 32-bit pointers and 64-bit pointers. (&#8220;Neither of these two observations holds true for 32-bit to 64-bit thunking.&#8221;) That&#8217;s the point of the article, which I apparently failed to make. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676103">
				<div id="div-comment-676103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676103">
			October 20, 2008 at 11:35 am</a>		</div>

		<p>&quot;notice that the 16-bit address space is still fully capable of referring to every byte in the 32-bit address space&quot;</p>
<p>I completely understand your point. &nbsp;My point is that it is not a necessary condition for thunking. &nbsp;The condition for the old thunking API is &quot;every 16-bit address can be converted to a 32-bit address&quot;. &nbsp;And since every 32-bit address can be converted to a 64-bit address, there&#8217;s no reason we can&#8217;t have a 32-bit to 64-bit thunking API.</p>
<p>The old thunking API also supported calling 16-bit code from 32-bit code but this is not possible from 64-bit to 32-bit for the reasons you state. &nbsp;However, neither of us were talking about this case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676113">
				<div id="div-comment-676113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Roastbeef</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676113">
			October 20, 2008 at 12:06 pm</a>		</div>

		<p>&quot;Interesting stuff Raymond every book or article I&#8217;ve ever seen on assembly language programming has referred to what you call selector&#8217;s as segments. Including this entry from Wikipedia.&quot;</p>
<p>The x86 processors when in &quot;real mode&quot; (the mode without memory protection where the CPU can only access 1 megabyte of memory) the processor uses SEGMENT registers to move a 64k window of memory over the underlying hardware&#8217;s 1 megabyte of address space.</p>
<p>When in protected mode the CPU needs to store a lot of information about each potential memory region. &nbsp;The information about each memory region is called a &quot;DESCRIPTOR&quot; and they are all stored in one of two tables&#8230; either the &quot;LOCAL DESCRIPTOR TABLE&quot; for per-process regions, or the &quot;GLOBAL DESCRIPTOR TABLE&quot; for system-wide regions.</p>
<p>The CPU needs a register to indicate which entries of the &quot;DESCRIPTOR TABLE&quot; are active at any one time, and so it stores a SELECTOR which is an offset into the DESCRIPTOR TABLEs.</p>
<p>So did Intel create new registers to store these SELECTORs? &nbsp;Nope&#8230; In protected memory modes the old style SEGMENTs will never be used, so the SEGMENT registers can be overloaded to also store SELECTORs.</p>
<p>The distinction of which they contain is based on CPU memory model at the instant you&#8217;re referring to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676133">
				<div id="div-comment-676133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676133">
			October 20, 2008 at 12:11 pm</a>		</div>

		<p>ton:</p>
<p>&quot;segment&quot; of memory is described with &quot;selector&quot; (16-bit tag). That&#8217;s the difference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676143">
				<div id="div-comment-676143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676143">
			October 20, 2008 at 12:15 pm</a>		</div>

		<p>@Laonianren</p>
<p>The following statement from Raymond is the key reason why there isn&#8217;t a 32 bit to 64 bit thunking api:</p>
<p>&quot;It&#8217;s not that there are no selectors; it&#8217;s just that there is effectively only one selector, so there&#8217;s no need to say it all the time.&quot; and also</p>
<p>&quot;Well, let me create a selector and set its base to 0x00000000 and its limit to 0xFFFFFFFF. With this selector, I can access the entire 32-bit linear address space.&quot;</p>
<p>Because of this scheme it is impossible for a 32 bit address to be converted to a 64 bit address with only a single selector and a base address starting at 0x00000000. There just aren&#8217;t enough digits.</p>
<p>So your statement:</p>
<p>&quot;And since every 32-bit address can be converted to a 64-bit address, there&#8217;s no reason we can&#8217;t have a 32-bit to 64-bit thunking API.&quot;</p>
<p>could only be true if memory was segmented into 4GB chunks &nbsp;and there was a selector for each chunk but there isn&#8217;t&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676153">
				<div id="div-comment-676153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676153">
			October 20, 2008 at 12:23 pm</a>		</div>

		<p>@Roastbeef, @Alexandre thanks for the info I&#8217;m admittedly pretty green when it comes to memory models and assembly but I&#8217;m always seeking enlightenment&#8230;:-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676163">
				<div id="div-comment-676163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676163">
			October 20, 2008 at 12:23 pm</a>		</div>

		<p>Laonianren, it&#8217;s not just 64-bit code calling 32-bit code that requires the reverse trick, it&#8217;s anywhere (and Raymond did say <em>generic</em> thunking, obviously some specific APIs can be thunked) that needs the reverse trick.</p>
<p>For example, suppose you try to thunk my reallocator, a function which takes a pointer and returns either the same pointer (but now re-allocated to point to a larger or smaller portion of memory) or else a different pointer (larger or smaller, and with the data from the previous allocation copied over)</p>
<p>The input side is fine, you add some zeroes to make the 32-bit address into a 64-bit address, and the same with the 32-bit size parameter to turn it into a 64-bit size parameter.</p>
<p>But on the output side you have trouble, the 64-bit code you&#8217;re calling can return any arbitrary 64-bit pointer. In reality it will currently return a pointer from somewhere in canonical 48-bit address space, because CPUs don&#8217;t have a 64-bit address bus, but even with that restriction there&#8217;s no reliable way to translate that into a 32-bit value to return to the 32-bit code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676183">
				<div id="div-comment-676183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676183">
			October 20, 2008 at 12:40 pm</a>		</div>

		<p>I think WOW64 is implemented internally by thunking otherwise the 64-bit version of WinDbg would not be able to debug 32-bit code and .effmach would not exist, but the interface needed are not exposed to external code, why?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676203">
				<div id="div-comment-676203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dog</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676203">
			October 20, 2008 at 1:17 pm</a>		</div>

		<p>&quot;Well, let me create a selector and set its base to 0x00000000 and its limit to 0xFFFFFFFF. With this selector, I can access the entire 32-bit linear address space.&quot;</p>
<p>What interests me is what happens if you create a &quot;selector&quot; with base 0xFFFFFFFF and limit 0xFFFFFFFF? Do you get access to the 4GB-8GB area?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676213">
				<div id="div-comment-676213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676213">
			October 20, 2008 at 1:18 pm</a>		</div>

		<p>Where&#8217;s Skywing when you need him?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676223">
				<div id="div-comment-676223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676223">
			October 20, 2008 at 1:22 pm</a>		</div>

		<p>&quot;What interests me is what happens if you create a &quot;selector&quot; with base 0xFFFFFFFF and limit 0xFFFFFFFF? Do you get access to the 4GB-8GB area?&quot;</p>
<p>No. You would probably just get a segmentation fault.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676233">
				<div id="div-comment-676233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676233">
			October 20, 2008 at 1:56 pm</a>		</div>

		<p>BTW, the same restriction exists in Mac OS X. You cannot thunk between Rosetta emulated code and native code, nor you can thunk between 32-bit and 64-bit code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676243">
				<div id="div-comment-676243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676243">
			October 20, 2008 at 2:07 pm</a>		</div>

		<p>A &quot;selector&quot; can be thought of as the name of a &quot;segment&quot;, so it&#8217;s not really a mistake to use the term &quot;segment&quot;.</p>
<p>Saying that a selector is mistakenly called a segment reminds me of this discussion between the Knight and Alice in &quot;Through the Looking Glass&quot; by Lewis Carroll:</p>
<p>&nbsp; &nbsp;&quot;&#8230; The name of the song is called &#8216;Haddocks&#8217; Eyes.&#8217;&quot;</p>
<p>&nbsp; &nbsp;&quot;Oh, that&#8217;s the name of the song, is it? &quot;Alice said, trying to feel interested.</p>
<p>&nbsp; &nbsp;&quot;No, you don&#8217;t understand,&quot; the Knight said, looking a little vexed. &quot;That&#8217;s what the name is called. The name really is &#8216;The Aged Aged Man.&#8221;&#8217;</p>
<p>&nbsp; &nbsp;&quot;Then I ought to have said, &#8216;That&#8217;s what the song is called?&#8217;&quot; Alice corrected herself.</p>
<p>&nbsp; &nbsp;&quot;No, you oughtn&#8217;t: that&#8217;s quite another thing! The song is called &#8216;Ways and Means&#8217;: but that&#8217;s only what it&#8217;s called, you know!&quot;</p>
<p>&nbsp; &nbsp;&quot;Well, what is the song, then?&quot; said Alice, who was by this time completely bewildered.</p>
<p>&nbsp; &nbsp;&quot;I was coming to that,&quot; the Knight said. &quot;The song really is &#8216;A-Sitting on a Gate&#8217;: and the tune&#8217;s my own invention.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676253">
				<div id="div-comment-676253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexandre Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676253">
			October 20, 2008 at 2:32 pm</a>		</div>

		<p>My explanation why there&#8217;s no thunking is that there is no real demand for that. It&#8217;s so easy to make sure your 32-bit code compiles cleanly for 64 bits, much easier than for 16-&gt;32 transition. Any supposed benefits of thunking would not be worth the trouble.</p>
<p>There are drawbacks, though, of lack of thunking. You cannot open a 64-bit process from 32-bit process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676263">
				<div id="div-comment-676263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676263">
			October 20, 2008 at 3:02 pm</a>		</div>

		<p>I thought that real mode x86 address translation worked by multiplying the selector by 16 then adding that to the 16 bit pointer. &nbsp;So the highest address you could get was 0xffff * 16 + 0xffff or just over a megabyte.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676303">
				<div id="div-comment-676303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kaenneth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676303">
			October 20, 2008 at 5:31 pm</a>		</div>

		<p>I think the main issue between 32/64 bit programs on the same system is dynamic linking. A 32 bit process could ask the system to start a 64 bit process for it, and processes can exchange data, as the Clipboard works, and files are interchangeable.</p>
<p>But DLLs, ActiveX, etc. are all toast, since they run in the same Process, and and individual process can only have one memory model.</p>
<p>That causes fun with Shell extensions, Windows Media Player plugins (I think WMP11 is 32 bit only? browser plugins&#8230; I don&#8217;t know what effects it has on drag-and-drop, and object embedding, or if .NET helps any.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676313">
				<div id="div-comment-676313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.koroirc.com/' rel='external nofollow' class='url'>Koro</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676313">
			October 20, 2008 at 6:12 pm</a>		</div>

		<p>@Kaenneth: Even if .NET produces 32-bit PE files, the CLR has the ability to generate 64-bit code even then I think. So for .NET it matters a lot less except for the native code that loads it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676323">
				<div id="div-comment-676323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676323">
			October 20, 2008 at 7:45 pm</a>		</div>

		<p>The mainframe world is still dealing with this. It was only recently that the last of the 24-bit code was removed from ISPF under z/OS. &nbsp;Now it&#8217;s all 32-bit code running on a 64-bit OS.</p>
<p>There are special memory allocation flags in GETMAIN to indicate whether you want memory addressable by 24-bit code (under the line), 32-bit code (under the bar) or 64-bit code (whole address space).</p>
<p>Accessing all 32-bit addresses from 64-bit code is possible so you should be able to thunk &#8216;upwards&#8217;. &nbsp;It&#8217;s downward thunking that requires special handling like this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676193">
				<div id="div-comment-676193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676193">
			October 20, 2008 at 1:11 pm</a>		</div>

		<p>@ton: Every 32-bit address can be converted into a *64-bit wide* 64-bit address. &nbsp;Which is what is required for thunking.</p>
<p>@Nick Lamb: Yes, you can&#8217;t convert a returned 64-bit pointer to 32-bit. &nbsp;But you can use the 64-bit pointer as a handle, and you can pass it to (say) RtlCopyMemory using thunking. &nbsp;And anyway, most Windows APIs don&#8217;t return pointers so this is generally a non-issue.</p>
<p>The point is that the old API had these same restrictions and they were a nuisance but they could be worked around. &nbsp;As I said before, there&#8217;s no reason we couldn&#8217;t have a new API with the same restrictions. &nbsp;I know it wouldn&#8217;t work in every possible case, but that&#8217;s not to say it wouldn&#8217;t be useful.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676293">
				<div id="div-comment-676293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.koroirc.com/' rel='external nofollow' class='url'>Koro</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676293">
			October 20, 2008 at 4:54 pm</a>		</div>

		<p>Interesting.</p>
<p>Although it *could* be possible to get a 64-bit memory region visible from 32-bit, akin to how mapped file views or shared sections operate, with a little help from the kernel in the form of two APIs:</p>
<p>void32* Map64bitMemory(void64* ptr64);</p>
<p>void Unmap64bitMemory(void32* ptr32);</p>
<p>The kernel would just have to map what&#8217;s from the higher address to one that&#8217;s guaranteed to be below 0xffffffff. No big problem there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676353">
				<div id="div-comment-676353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676353">
			October 21, 2008 at 1:48 am</a>		</div>

		<p>A selector and a segment are two different things.</p>
<p>A segment, only valid in x86 real mode, is a 16-bit value describing a 64k region of memory. A segment:offset address is then mapped as segment*16+offset. This is hardcoded and fixed in hardware. (the CS, DS, ES, SS registors hold the segment part). And yes, you can make the same memory address different ways as there are 12 overlapping bits.</p>
<p>A selector is valid in protected mode (and possibly unreal mode). In this, the segment registers now hold a selector value. The selectors can be arbitrary (and described I believe in the global descriptor table), and the entries are arbitrary. Only kernel code can update the selector. But here, there is no fixed mapping between selector and the underlying memory address &#8211; it is what the OS programs it to be.</p>
<p>Windows, Linux and most other OSes out there define one selector that maps the entire 32-bit range (and thus forget about the selector period). This is because the x86 acts sane for once and gives you the flat memory model, which practically all other CPU architectures feature, and makes programming far less complex.</p>
<p>You use a selector to select which segment descriptor you want (that describes a region of memory). A segment is just a region of memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676373">
				<div id="div-comment-676373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Unreal!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676373">
			October 21, 2008 at 7:54 am</a>		</div>

		<blockquote><p>
  &gt; I thought that real mode x86 address translation worked by multiplying the selector by 16 then adding that to the 16 bit pointer. &nbsp;So the highest address you could get was 0xffff * 16 + 0xffff or just over a megabyte.
</p></blockquote>
<p>In real mode all 386+ (and probably 286 but the thing is less interesting) still use predefined selectors to simplify address translation logic. It&#8217;s just that selectors are defined with all permissions and the 4 bit offset rule.</p>
<p>This leads to the ability to enter &quot;Unreal mode&quot; that is real mode with modified selectors which was used by old games and is still used by some BIOS functions.</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Unreal_mode" rel="nofollow">http://en.wikipedia.org/wiki/Unreal_mode</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676473">
				<div id="div-comment-676473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676473">
			October 21, 2008 at 12:45 pm</a>		</div>

		<p>Out-of-process COM lets you do some of the things you might want thunking for. It allows 32-bit and 64-bit processes to call each other&#8217;s interfaces without you needing to write any extra code.</p>
<p>It isn&#8217;t perfect for everything, and you may have to write your own proxy process if you need to host in-process DLLs, but I found it let me do things very quickly and easily once I had worked out what to do and how to do it.</p>
<p>This even lets you run 32-bit ActiveX GUI controls as child windows of 64-bit apps. For example, there isn&#8217;t a 64-bit Flash control but I was able to write a proxy process which hosts the 32-bit Flash ActiveX control and forwards the interfaces that the control and host need to talk to each other, giving the 64-bit host program the ability to display Flash within its windows.</p>
<p>I think Explorer on Vista uses the same technique to display things like Word documents in the preview pane. (There are additional reasons for using out-of-process COM there but they&#8217;re off-topic.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676513">
				<div id="div-comment-676513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Magnus Hiie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676513">
			October 21, 2008 at 2:03 pm</a>		</div>

		<p>Note that there still is use for selectors that don&#8217;t have base of 0x00000000 and limit 0xFFFFFFFF &#8211; the fs holds a selector value that describes the range for TEB. Try looking at the selector register values and selector contents in WinDbg (e.g. &quot;dg ds&quot; vs &quot;dg fs&quot;). &quot;!teb&quot; should give the same address as base in &quot;dg fs&quot;.</p>
<p>By the way, does anybody know if the gs is used on Win32? If so, what is it used for? For me the value of gs seems to be always 0.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676533">
				<div id="div-comment-676533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676533">
			October 21, 2008 at 3:09 pm</a>		</div>

		<p>Magnus: &nbsp;GS may very well be used in kernel mode and be a privileged kernel-mode descriptor. It&#8217;s just that by the time you see it, the privilege transition code has zeroed out the segment register.</p>
<p>dumpbin /disasm ntoskrnl.exe | grep gs anyone?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676543">
				<div id="div-comment-676543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Diack</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676543">
			October 21, 2008 at 3:14 pm</a>		</div>

		<p>As a (D)COM programmer, I&#8217;m totally aware of the issues that Leo mentions, but using (D)COM is hardly desirable these days&#8230;.</p>
<p>A work project of mine is actually <em>removing</em> DCOM from a legacy project, precisely because it&#8217;s such a god forsaken mess wrt security issues and reliability (the infamous 40 odd second hang if a DCOM connection can&#8217;t be made which you have to work around by doing your DCOM on background threads etc UGH!&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676603">
				<div id="div-comment-676603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Duke of New York</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676603">
			October 21, 2008 at 6:20 pm</a>		</div>

		<p>If it&#8217;s in Wikipedia, it must be the truth!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676713">
				<div id="div-comment-676713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul de Vrieze</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676713">
			October 22, 2008 at 4:27 am</a>		</div>

		<p>Just take a look at how a function call works as implemented in the i386 system (roughly, some parts are left out).</p>
<ol>
<li>The function parameters are pushed on the stack</li>
<li>
<p>The instruction pointer is pushed on the stack (64 bits or 32 bits)</p>
</li>
<li>
<p>The system calls into the address of the function (32bits or 64 bits)</p>
</li>
<li>
<p>The called function uses it&#8217;s parameters relative to the current base pointer (and as such is dependent on pointer length of the calling code) (this means a 32 bit function can not have parameters when called by 64 bit code)</p>
</li>
<li>
<p>The called function does its job</p>
</li>
<li>
<p>The called function returns by getting the old instruction pointer from the stack and going to that address.</p>
</li>
</ol>
<p>ps. There is a lot of stuff with calling conventions that I ignore here, but you can already see that (besides the impossibility of a mode switch in a function call), even just calling a function has issues (as well as 64bit code being called by 32bit code, (the address of the code could very well be unadressable in 32 bit))</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676733">
				<div id="div-comment-676733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codingthewheel.com' rel='external nofollow' class='url'>www.codingthewheel.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676733">
			October 22, 2008 at 5:22 am</a>		</div>

		<p>The one thing everybody here is forgetting is that by calibrating the kernel-mode succubus driver you can 32/64 thunk using force-based heuristics in a non-Euclidean addressing system whereby two 32-bit pointers are extrapolated using a numeric variant of Markov chains whose extrapolated segment register then matches the Rutger axiom for run-time logarithmic precalculation of directed acyclic graphs &#8212; an approach that&#8217;s been used (successfully) to address register latency issues in L2 cache.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-676783">
				<div id="div-comment-676783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676783">
			October 22, 2008 at 10:26 am</a>		</div>

		<p>codingthewheel: the alarming thing is that, apart from the succubus bit, that made sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-676923">
				<div id="div-comment-676923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-676923">
			October 22, 2008 at 2:18 pm</a>		</div>

		<p>I must say that for the most part codingthewheel&#8217;s comment was pure gibberish. I mean nobody here is dumb but dude english please.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-677123">
				<div id="div-comment-677123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mps</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-677123">
			October 23, 2008 at 1:40 pm</a>		</div>

		<p>By default, .net executables will run either 32 or 64 bit. At compile time, you can specify that an app has to be 32 or 64 bit. This is useful for apps like XNA games which have to be 32 bit, since they bind to the 32 bit DirectX libraries.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-677283">
				<div id="div-comment-677283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://eleccham.valleyhold.org' rel='external nofollow' class='url'>Gordon Schumacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-677283">
			October 24, 2008 at 2:53 am</a>		</div>

		<p>@codingthewheel: There can only be one response to this&#8230;</p>
<p><a rel="nofollow" target="_new" href="http://joeschwartz.net/Illusions/parastatic.htm" rel="nofollow">http://joeschwartz.net/Illusions/parastatic.htm</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-677513">
				<div id="div-comment-677513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081020-00/?p=20523#comment-677513">
			October 25, 2008 at 11:43 am</a>		</div>

		<p>&quot;&#8230;notice that the 16-bit address space is still fully capable of referring to every byte in the 32-bit address space&#8230;&quot;</p>
<p>But not all at once, as there are only 4096 local and 4096 global descriptors, which limits you to half a gigabyte of 16-bit address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

