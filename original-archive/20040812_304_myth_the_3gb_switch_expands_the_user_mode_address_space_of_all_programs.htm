<html>
<head>
<title>Myth: The /3GB switch expands the user-mode address space of all programs</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Myth: The /3GB switch expands the user-mode address space of all programs</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 12, 2004 / year-entry #305</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>46</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Only programs marked as /LARGEADDRESSAWARE are affected. For compatibility reasons, only programs that explicitly indicate that they are prepared to handle a virtual address space larger than 2GB will get the larger virtual address space. Unmarked programs get the normal 2GB virtual address space, and the address space between 2GB and 3GB goes unused. Why?...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Only programs marked as /LARGEADDRESSAWARE are affected.
</p>
<p>
For compatibility reasons, only programs that explicitly
indicate that they are prepared to handle a virtual address space
larger than 2GB will get the larger virtual address space.
Unmarked programs get the normal 2GB virtual address space,
and the address space between 2GB and 3GB goes unused.
</p>
<p>
Why?
</p>
<p>
Because far too many programs assume that the high bit of user-mode
virtual addresses is always clear, often unwittingly.
<a HREF="http://msdn.microsoft.com/library/en-us/memory/base/4gt_ram_tuning.asp">
MSDN has a page listing some of the ways programs make this
assumption</a>.
One such assumption you may be making is taking
the midpoint between two pointers by using the formula
(a+b)/2.
<a HREF="/oldnewthing/archive/2003/09/17/54945.aspx">
As I noted in a previous exercise</a>,
this is subject to integer overflow and consequently can result
in an erroneous pointer computation.
Consequently, you can't just take an existing program that you didn't
write, mark it /LARGEADDRESSAWARE, and declare your job done.
You have to check with the authors of that program that they verified
that their code does not make any 2GB assumptions.
(And the fact that the authors
didn't mark their program as 3GB-compatible
strongly suggests that no such verification has occurred.
If it had, they would have marked the program /LARGEADDRESSAWARE!)
</p>
<p>
Marking your program /LARGEADDRESSAWARE indicates to the operating
system, "Go ahead and give this program access to that extra
gigabyte of user-mode address space,"
and as a result, addresses in the third gigabyte
become possible return values from memory allocation functions.
If you set
<a HREF="http://go.microsoft.com/fwlink/?LinkId=28166">
the "Top down" flag in the
memory manager allocation preferences mask</a>
(search for "top down"),
you can instruct the memory manager to allocate high-address memory
first, thereby forcing your program to deal with those addresses
sooner than it normally would.
This is very handy when testing your program in a /3GB configuration
since it forces the troublesome memory addresses to be used sooner
than normal.
</p>
<p>
<b>Exercise</b>: Find the bug in the following function.
Hint: What's today's topic?
</p>
<pre>
#define BUFFER_SIZE 32768
BOOL  IsPointerInsideBuffer(const BYTE *p, const BYTE *buffer)
{
  return p &gt;= buffer && p - buffer &lt; BUFFER_SIZE;
}
</pre>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (46)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-202883">
				<div id="div-comment-202883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">2GB should be enough for anyone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202883">
			August 12, 2004 at 7:12 am</a>		</div>

		<p>enough with the /3GB already!<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202893">
				<div id="div-comment-202893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Qwerty</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202893">
			August 12, 2004 at 7:13 am</a>		</div>

		<p>I am shooting in the dark here.  But I think the #define is wrong and should be:<br />
<br />#define BUFFER_SIZE ((size_t)32768)</p>
<p>Anyway, if the compiler uses a signed int for the less-than, then it fails when the difference between p and buffer is greater than max int.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202903">
				<div id="div-comment-202903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202903">
			August 12, 2004 at 7:30 am</a>		</div>

		<p>If I was being picky I&#8217;d say this was a compiler bug.</p>
<p>Suppose you allocate a 2.5GB array of chars and you subtract a pointer to the start from a pointer to the end.  The correct answer is +2.5GB and the compiler should define ptrdiff_t (the type of pointer differences) large enough to hold this.  In fact, the compiler defines ptrdiff_t as an int, so it gives you the wrong answer.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202913">
				<div id="div-comment-202913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202913">
			August 12, 2004 at 7:38 am</a>		</div>

		<p>Well, this is undefined behavior in the first place using an arbitrary p according to the C standard. But anyway, the cannonical way to do this test is:</p>
<p>p &gt;= buffer &amp;&amp; p &lt; buffer + BUFFER_SIZE.</p>
<p>Also, (a+b)/2 doesn&#8217;t work if a and b are both pointers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202923">
				<div id="div-comment-202923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miles Archer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202923">
			August 12, 2004 at 8:19 am</a>		</div>

		<p>Thanks for pointing this out. This one got me. You might point out there is a util called imagecfg that you can use to set the flag on existing exes. Now whether or not it works properly is a differnt question altogether.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202933">
				<div id="div-comment-202933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202933">
			August 12, 2004 at 8:24 am</a>		</div>

		<p>I&#8217;m going to elaborate what I said just incase nobody has read that part of the C and C++ standards. Doing range testing or subtraction on pointers is only defined if the 2 pointers belong to the same &quot;allocation block&quot;, either taking the sub-addresses of some type allocated on the stack or some chunk of memory returned by an allocation function.</p>
<p>So this function will either return true if p is in this range or result in undefined behavior (which may include, but not limited to: evaluating to true, evaluating to false, evaluating to a bool that is neither true nor false [yes, the C++ standard talks about that so be careful when reinterpret_cast-ing to bools], a crash, or initiating a sequence for hot lava to flow out of the programmer&#8217;s ass). So this function is completely useless in the first place.</p>
<p>But being practical instead of anal, Qwerty nailed it and it could either be a compiler bug or an implemtation bug if an allocation function allocates more than numeric_limits&lt;ptrdiff_t&gt;::max().</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202943">
				<div id="div-comment-202943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202943">
			August 12, 2004 at 8:34 am</a>		</div>

		<p>asdf is correct, pointer subtraction is technically legal only if the pointers both reside within the same allocation block. Consequently, there is no compiler bug here as long as you can&#8217;t allocate blocks larger than the maximum positive value of ptrdiff_t. Which you can&#8217;t.</p>
<p>In practice, nearly all compilers allow subtraction of pointers from different allocation blocks, but this shifts the burden to the programmer to understand the consequences of this new power.</p>
<p>The signed integer underflow is the bug. If the two pointers are more than 2GB apart, then the result of the subtraction is a negative number. This type of bug is rather common in programs that are not 3GB-certified.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202953">
				<div id="div-comment-202953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202953">
			August 12, 2004 at 8:55 am</a>		</div>

		<p>Thanks for doing these posts and exercises Raymond! I can almost feel myself become a better programmer by watching and learning what&#8217;s posted here. Oh and thanks to the other people who post the answers :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202963">
				<div id="div-comment-202963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Qwerty</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202963">
			August 12, 2004 at 9:03 am</a>		</div>

		<p>Agreed, asdf, IsPointerInsideBuffer is of questionable value.  I can&#8217;t remember why anyone would want it, but do remember talking about this with a coworker within 1 month of leaving college.</p>
<p>I don&#8217;t see this as either a compiler or specification bug.  It just shows that boundary conditions are hard.  Allocating a single buffer greater than 2 gigs should be allowed (even though it definately will fail on a 32 bit machine).  Also negative pointer differences should be allowed (even though it is more stable to always keep it positive).</p>
<p>The sad thing is that I bet these same things will be disscussed again in 50 years when they start hitting the limits of a signed 64 bit integer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202973">
				<div id="div-comment-202973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Centaur</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202973">
			August 12, 2004 at 9:09 am</a>		</div>

		<p>Shouldnâ€™t BUFFER_SIZE above be a const size_t instead of a macro, just to be type-safe?</p>
<p>And then, yes, there seems no legal way to determine if two pointers are from the same array.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-202983">
				<div id="div-comment-202983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202983">
			August 12, 2004 at 9:30 am</a>		</div>

		<p>Sorry, my mistake.  I&#8217;d checked malloc.h (in VC6) which says:<br />
<br />#define _HEAP_MAXREQ 0xFFFFFFE0<br />
<br />but I didn&#8217;t realise (until I tried it) that HeapAlloc has a limit (of 0x7FFDEFFF on XP).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-202993">
				<div id="div-comment-202993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-202993">
			August 12, 2004 at 9:34 am</a>		</div>

		<p>Legal, yes.  Practical, no.  Compare for equality with every element in the array.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203023">
				<div id="div-comment-203023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203023">
			August 12, 2004 at 10:01 am</a>		</div>

		<p>Really? std::less is defined like this:</p>
<p>template &lt;class _Tp&gt;<br />
<br />struct less : public binary_function&lt;_Tp, _Tp, bool&gt;<br />
<br />{<br />
<br />bool operator()(const _Tp&amp; __x, const _Tp&amp; __y) const { return __x &lt; __y; }<br />
<br />};</p>
<p>Notice that it just uses the boring &lt; operator so you&#8217;re back to where you started.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203033">
				<div id="div-comment-203033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203033">
			August 12, 2004 at 10:14 am</a>		</div>

		<p>On most implementations, that&#8217;s how it is defined but there are some environments where that isn&#8217;t the definition.</p>
<p>20.3.3/8 For templates greater, less, greater_equal, and less_equal, the specializations for any pointer type yield a total order, even if the built-in operators &lt;, &gt;, &lt;=, &gt;= do not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203043">
				<div id="div-comment-203043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203043">
			August 12, 2004 at 10:24 am</a>		</div>

		<p>Ah, I see.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203053">
				<div id="div-comment-203053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox [MS]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203053">
			August 12, 2004 at 11:43 am</a>		</div>

		<p>I think all this pedantry is missing the point somewhat.</p>
<p>The point is that code like Raymond&#8217;s example, which looks semi-reasonable at first glance, almost certainly exists out in the wild, and is buggy when pointers can be beyond 2GB. In particular, notice that it&#8217;s possible to have code which fails even when you didn&#8217;t explicitly do anything egregiously hacky like storing data in the top bit of a pointer.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203063">
				<div id="div-comment-203063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203063">
			August 12, 2004 at 12:00 pm</a>		</div>

		<p>What&#8217;s going on here is pretty subtle for me.  My explanation is that the two comparisons happen in different domains, and it&#8217;s the mixing of the domains that makes it fail.</p>
<p>The first comparison is between pointers; this is in the unsigned &quot;pointer-compare&quot; domain, and a very large P and small Buffer give a result with the high bit on and it&#8217;s interpreted as unsigned, so it&#8217;s a big number.</p>
<p>The second comparison is done in the integer domain (technically, the ptrdiff_t domain) which is signed.  The p-buffer becomes a very negative number, not a very large positive number, and the comparison returns the &quot;wrong&quot; result.</p>
<p>This is why the earlier comment (by asdf) that the canonical way to do this is important.  By making the second comparison p&lt;buffer+BUFFER_SIZE it stays in the ptrdiff_t domain.  By staying in the same domain the results are compatible.</p>
<p>The code could also be rewritten so the first comparison is in the ptrdiff_t domain: p-buffer &gt; 0.  This keeps both compares in the same domain, and so they stay compatible.</p>
<p>This is also why the STL solution works: it&#8217;s not that STL is being so very magical, but that the problem is being rewritten so that the compares are both done in the same domain.  The exact nature of the lt is then unimportant: it doesn&#8217;t matter whether it&#8217;s signed or unsigned just so that it&#8217;s consitent.</p>
<p>I had to vet an old program (RS/1) once for Win32s.  That version of Windows had the unique issue that all mallocs() resulted in memory with the high bit on (unlike the dozens of other systems RS/1 had been ported to).  I had to check a bunch of pointer arithmetic to make sure that all the mods and divs and everything was nice and compatible.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203003">
				<div id="div-comment-203003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203003">
			August 12, 2004 at 9:48 am</a>		</div>

		<p>In C++, the template functor std::less provides an ordering between pointers even if they don&#8217;t point into the same array. So I think this should work:</p>
<p>BOOL  IsPointerInsideBuffer(const BYTE *p, const BYTE *buffer)<br />
<br />{<br />
<br />    std::less&lt;const BYTE *&gt; lt;<br />
<br />    return !lt(p, buffer) &amp;&amp; lt(p, buffer + BUFFER_SIZE);<br />
<br />}<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203083">
				<div id="div-comment-203083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203083">
			August 12, 2004 at 6:00 pm</a>		</div>

		<p>What about /LARGEADDRESSAWARE applications loading non-aware DLLs?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203113">
				<div id="div-comment-203113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203113">
			August 13, 2004 at 3:35 am</a>		</div>

		<p>&quot;2GB should be enough for anyone&quot; got this topic right, I think.. nowadays, who cares about the intricacies of the /3GB switch, when you can get yourself a 64-bit CPU and OS. (well, almost, but that&#8217;s good enough for stuff I&#8217;d be writing today for release in the near future)</p>
<p>Although, I appreciate this blog immensely, I&#8217;d be much more interested in issues with getting my code going on 64-bit windows, or running other people&#8217;s code on 64-bit windows than I would with some memory &#8216;hack&#8217; that is soon to go the way of the large memory model.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203123">
				<div id="div-comment-203123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AndyB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203123">
			August 13, 2004 at 4:05 am</a>		</div>

		<p>&quot;2GB should be enough for anyone&quot; got this topic right, I think.. nowadays, who cares about the intricacies of the /3GB switch, when you can get yourself a 64-bit CPU and OS. (well, almost, but that&#8217;s good enough for stuff I&#8217;d be writing today for release in the near future)</p>
<p>Although, I appreciate this blog immensely, I&#8217;d be much more interested in issues with getting my code going on 64-bit windows, or running other people&#8217;s code on 64-bit windows than I would with some memory &#8216;hack&#8217; that is soon to go the way of the large memory model.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203093">
				<div id="div-comment-203093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203093">
			August 12, 2004 at 9:15 pm</a>		</div>

		<p>The problem is that subtracting two pointers results in a *signed* operand, and if the buffer is really large then the signed operand could be negative and overflow.</p>
<p>typedef _W64 int ptrdiff_t;</p>
<p>To fix the problem you need to do ((ULONG_PTR)(p &#8211; buffer))</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203133">
				<div id="div-comment-203133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203133">
			August 13, 2004 at 6:09 am</a>		</div>

		<p>&quot;Consequently, there is no compiler bug here as long as you can&#8217;t allocate blocks larger than the maximum positive value of ptrdiff_t. Which you can&#8217;t. &quot;</p>
<p>Why not?</p>
<p>Do ntdll.dll et al. still sit at just under 0x80000000 even with a 3 GiB app?</p>
<p>That would be sad if true.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203213">
				<div id="div-comment-203213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203213">
			August 15, 2004 at 7:48 am</a>		</div>

		<p>Of course they are at the same base address.  Moving them would require them to be rebased, and it would break all the bound imports that other images use to call them.  You would be throwing away performance for no good reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203333">
				<div id="div-comment-203333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203333">
			August 16, 2004 at 8:31 am</a>		</div>

		<p>All programs that come with the OS are 3GB-compatible, so it means that every single OS process would have to rebase all the system DLLs. So much for &quot;infrequently&quot;.</p>
<p>And since memory for rebased DLLs is not shared, this would balloon the memory requirements for a system in /3GB mode. Notepad&#8217;s memory requirements would go from less than 1MB to over 27MB.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203343">
				<div id="div-comment-203343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203343">
			August 16, 2004 at 9:40 am</a>		</div>

		<p>There are other technical reasons why this isn&#8217;t possible without modifying the kernel anyway.  Not that it would probably be very difficult for Microsoft to do, but there are number of performance optimizations taken that rely on things like ntdll or user32 being at the same base address in every process (like looking up the address of exported functions called by the kernel using one of the kernel mode to user mode call facilities only once, and using those addresses for every process in the system).  I suspect the major reason is the massive waste of memory and processor time that rebasing would incur, though.</p>
<p>Then again, I don&#8217;t see any compelling gains to moving the system dlls from their normal spot when you use /3GB.  What&#8217;s wrong with keeping them where they are, anyway?  You aren&#8217;t likely to get 1+GB of contiguous address space even if you moved all the system dlls around because of explicit virtual memory allocations and section view mappings happening in various places throughout the address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203383">
				<div id="div-comment-203383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203383">
			August 16, 2004 at 10:07 am</a>		</div>

		<p>&quot;Only those programs that can benefit from [3GB].&quot;</p>
<p>Who says that Notepad wouldn&#8217;t benefit from 3GB? Maybe somebody has a global hook DLL that takes advantage of 3GB?</p>
<p>&quot;Why can&#8217;t the OS share identically-rebased DLLs?&quot; Because there&#8217;s no point in optimizing a scenario that developers are supposed to be avoiding anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203393">
				<div id="div-comment-203393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203393">
			August 16, 2004 at 10:08 am</a>		</div>

		<p>&quot;Then again, I don&#8217;t see any compelling gains to moving the system dlls from their normal spot when you use /3GB. What&#8217;s wrong with keeping them where they are, anyway? You aren&#8217;t likely to get 1+GB of contiguous address space even if you moved all the system dlls around because of explicit virtual memory allocations and section view mappings happening in various places throughout the address space. &quot;<br />
<br />What&#8217;s wrong is that they punch a fucking great hole in the address space.</p>
<p>If you don&#8217;t have &gt; 1 GiB of contiguous address space, for example, the CLR won&#8217;t load, so it can&#8217;t be that infrequent&#8211;but in some situations (<a target="_new" href="http://support.microsoft.com/default.aspx?scid=kb;en-us;821157" rel="nofollow">http://support.microsoft.com/default.aspx?scid=kb;en-us;821157</a>) that&#8217;s exactly what happens.</p>
<p>If, on the other hand, system libraries were loaded at just below 3 GiB for 3 GiB-aware programs then you&#8217;d have a clear run all the way from about 2.5 GiB all the way down to about 0.5 GiB, which would make such situations extremely infrequent.</p>
<p>It&#8217;d also be simply more convenient for applications working with large datasets, as it&#8217;d reduce their need to use their own custom &quot;paging&quot; mechanism.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203423">
				<div id="div-comment-203423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203423">
			August 16, 2004 at 10:21 am</a>		</div>

		<p>It is avoidable if you stay away from the upper end of the address space, which is where system DLLs hang out.</p>
<p>Even if it&#8217;s unavoidable, it occurs rarely.</p>
<p>What you&#8217;re suggesting is taking the rare case and making it the 100% case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203433">
				<div id="div-comment-203433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203433">
			August 16, 2004 at 10:23 am</a>		</div>

		<p>Developers can avoid it in &gt;95% of all cases.</p>
<p>The vast majority of all dlls loaded in an average app are either system dlls or dlls written to work with the app.</p>
<p>Sure, once and awhile a hook dll or somesuch might conflict on somebody&#8217;s system causing a rebase, but in the overwhelming majority of cases you can avoid having your dlls rebased as long as you change the default base address from 10000000 (probably the most commonly forgotten step of writing a dll &#8211; the first thing I do when starting one, actually.  Maybe it would be good to have the linker warn about using the default base address in future versions of VC&#8230;.) and make sure each dll&#8217;s base address is unique within the project.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203303">
				<div id="div-comment-203303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203303">
			August 16, 2004 at 7:43 am</a>		</div>

		<p>&quot;Of course they are at the same base address. Moving them would require them to be rebased,&quot;<br />
<br />Which is a one-off cost when starting an application.</p>
<p>I get the feeling that 3 GiB apps are the kind which start infrequently and run for long periods.  As such the cost of rebasing is utterly insignificant.</p>
<p>On the other hand, more contiguous address space is *always* good.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203363">
				<div id="div-comment-203363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203363">
			August 16, 2004 at 10:03 am</a>		</div>

		<p>&quot;All programs that come with the OS are 3GB-compatible, so it means that every single OS process would have to rebase all the system DLLs. So much for &quot;infrequently&quot;. &quot;<br />
<br />So someone would have to be judicious in marking only those programs that can benefit from it as 3 GiB compatible.  That&#8217;ll take, what, an afternoon&#8217;s work?</p>
<p>&quot;And since memory for rebased DLLs is not shared, this would balloon the memory requirements for a system in /3GB mode. Notepad&#8217;s memory requirements would go from less than 1MB to over 27MB.&quot;<br />
<br />Notepad would be a program which doesn&#8217;t benefit from 3 GiB, as it doesn&#8217;t appear to make a blind bit of difference to the largest file Notepad can open.</p>
<p>Of course, if the libraries *were* loaded at just under 3 GiB, perhaps it *could* open larger files.  Catch-22?</p>
<p>And why *can&#8217;t* the OS share identically-rebased DLLs?  I mean, there are obvious difficulties if the same library is rebased to different locations, but if it&#8217;s rebased to the same location (which it presumably would be&#8211;somewhere just under 3 GiB) there doesn&#8217;t seem any obvious reason why it can&#8217;t be shared.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203403">
				<div id="div-comment-203403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203403">
			August 16, 2004 at 10:10 am</a>		</div>

		<p>&quot;Who says that Notepad wouldn&#8217;t benefit from 3GB?&quot;<br />
<br />The edit control, it seems.</p>
<p>&quot;Because there&#8217;s no point in optimizing a scenario that developers are supposed to be avoiding anyway.<br />
<br />But developers cannot avoid it, because developers do not know at link-time what libraries a user may have loaded.  Rebasing is *inevitable* and *unavoidable*.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203483">
				<div id="div-comment-203483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203483">
			August 16, 2004 at 6:38 pm</a>		</div>

		<p>8/16/2004 10:08 AM DrPizza</p>
<p>&gt; If you don&#8217;t have &gt; 1 GiB of contiguous<br />
<br />&gt; address space, for example, the CLR won&#8217;t<br />
<br />&gt; load, so it can&#8217;t be that infrequent</p>
<p>I think you mean &quot;so it can&#8217;t be that frequent&quot;.  If that is what you mean, then I agree and wish to add:  One in a million is next Tuesday.</p>
<p>By the way, I forgot whose blog commented on &quot;one in a million is next Tuesday&quot; but these days surely one in a million is maybe next minute?  Around 20 years ago in one embedded system I added a test, requiring some unwanted consumption of CPU time, because:  with the number of customers and the relative infrequency of that operation, if we didn&#8217;t check for it, one in a million was still going to crash some victim about once every two weeks.  CPUs are a bit faster now.  Surely now one in a trillion is next Tuesday.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203533">
				<div id="div-comment-203533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.blacksun.org.uk/' rel='external nofollow' class='url'>Paul Walker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203533">
			August 17, 2004 at 4:41 am</a>		</div>

		<p>Silly question, but why on earth are you specifying base addresses for DLLs anyway? That&#8217;s what load-time is for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203543">
				<div id="div-comment-203543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AlisdairM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203543">
			August 17, 2004 at 6:08 am</a>		</div>

		<p>At a frequency of 1Hz, &quot;1 in a million&quot; is every 11.6 days, or roughly 3 times per month.</p>
<p>Next Tuesday is sounding closer all the time&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203553">
				<div id="div-comment-203553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203553">
			August 17, 2004 at 6:36 am</a>		</div>

		<p>&quot;Silly question, but why on earth are you specifying base addresses for DLLs anyway? That&#8217;s what load-time is for.&quot;<br />
<br />Because people are vainly trying to avoid their DLLs being rebased, which is bad because Windows doesn&#8217;t bother sharing the memory of rebased DLLs.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203603">
				<div id="div-comment-203603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203603">
			August 17, 2004 at 7:53 am</a>		</div>

		<p>DrPizza: Well, in every single program on every Windows system I&#8217;ve debugged (and that&#8217;s a lot, probably in the hundreds), what I&#8217;ve said has held true.</p>
<p>That&#8217;s a good enough reason for me.  Feel free to do your own research if you don&#8217;t agree, of course, but my own experience tells me that you&#8217;re making a big deal out of nothing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203523">
				<div id="div-comment-203523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203523">
			August 17, 2004 at 2:47 am</a>		</div>

		<p>&quot;Developers can avoid it in &gt;95% of all cases.&quot;<br />
<br />No, that&#8217;s rather the point.  They can&#8217;t.  They can make sure that none of their libraries collide with /each other/.  But the problem is, the developer has no control over the end-user&#8217;s computer.</p>
<p>&quot;The vast majority of all dlls loaded in an average app are either system dlls or dlls written to work with the app. &quot;<br />
<br />Except for the instant messenger idle detection hook at 0x60000000, sundry shell extensions at between 0x10000000 and 0x40000000 (e.g. Office at 0x379b0000), countless OCXs all at 0x10000000 (e.g. Flash), always-rebased libraries like msi.dll or wireless zeroconfiguration (check out those base addresses&#8230;).  It all adds up to a lot of holes in the address space that aren&#8217;t usable.</p>
<p>This all adds up to make it very easy for a process to have no more than about 500 MB of free contiguous address space.</p>
<p>&quot;Sure, once and awhile a hook dll or somesuch might conflict on somebody&#8217;s system causing a rebase, but in the overwhelming majority of cases you can avoid having your dlls rebased as long as you change the default base address from 10000000 (probably the most commonly forgotten step of writing a dll &#8211; the first thing I do when starting one, actually. Maybe it would be good to have the linker warn about using the default base address in future versions of VC&#8230;.) and make sure each dll&#8217;s base address is unique within the project. &quot;<br />
<br />Rebased DLLs are *inevitable* and occur even as part of the default configuration.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203863">
				<div id="div-comment-203863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203863">
			August 17, 2004 at 11:56 am</a>		</div>

		<p>&quot;I&#8217;ve got office installed. Here&#8217;s an example of an app (Notepad) that has the open file common dialog up:&quot;<br />
<br />Office 2000?  That&#8217;s the one that&#8217;s currently plonking a library in the middle of my address space.</p>
<p>&quot;I really don&#8217;t see where you are getting this idea that virtually process has lots and lots of rebased dlls. &quot;<br />
<br />I didn&#8217;t say it did.  I said that every system has some rebased DLLs.  Windows 2000&#8217;s msi.dll seems to be consistently rebased, for example.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-203623">
				<div id="div-comment-203623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203623">
			August 17, 2004 at 8:47 am</a>		</div>

		<p>&quot;That&#8217;s a good enough reason for me. Feel free to do your own research if you don&#8217;t agree, of course, but my own experience tells me that you&#8217;re making a big deal out of nothing. &quot;<br />
<br />Every (modern, at least) Windows version has rebased DLLs *out of the box*.</p>
<p>Your experience is *wrong* if it says that rebasing is at all rare.</p>
<p>The top 500-odd MB are off-limits due to system .dlls.  The bottom 250 off-limits due to the application and its .dlls.  Then we have things like Explorer&#8217;s Shell/namespace extensions which load in a scattergun approach; Office, for example, loading at about 750 MB.  &quot;But why would they load into your application?&quot; You ask.  Simple, really&#8211;they get dragged into any process that uses a common file dialogue.</p>
<p>And now you&#8217;ve got less than 1 GiB contiguous address space available.  It&#8217;s not like Office is a niche application to have; it&#8217;s *quite* widely used&#8230;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-203833">
				<div id="div-comment-203833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-203833">
			August 17, 2004 at 11:33 am</a>		</div>

		<p>I&#8217;ve got office installed.  Here&#8217;s an example of an app (Notepad) that has the open file common dialog up:</p>
<p>0:004&gt; lm t<br />
<br />start    end        module name<br />
<br />009d0000 009df000   Vxdif        Timestamp: Tue Nov 19 08:34:44 2002 (3DDA3DF4)                                  Checksum: 00000000<br />
<br />01000000 01014000   notepad      Timestamp: Tue Mar 25 02:10:14 2003 (3E8000D6)                                  Checksum: 000123BB<br />
<br />10000000 10112000   Apoint       Timestamp: Thu Nov 28 01:05:09 2002 (3DE5B215)                                  Checksum: 00000000<br />
<br />60970000 60979000   mslbui       Timestamp: Tue Mar 25 04:46:43 2003 (3E802583)                                  Checksum: 000112FE<br />
<br />70ad0000 70bb6000   COMCTL32     Timestamp: Tue Mar 25 04:43:33 2003 (3E8024C5)                                  Checksum: 000E7161<br />
<br />71b70000 71ba3000   UxTheme      Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 000340A1<br />
<br />71bf0000 71bf8000   WS2HELP      Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 0000B6AB<br />
<br />71c00000 71c18000   WS2_32       Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 00022613<br />
<br />71c40000 71c93000   NETAPI32     Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 00058483<br />
<br />73070000 73096000   WINSPOOL     Timestamp: Tue Mar 25 04:43:17 2003 (3E8024B5)                                  Checksum: 0002C96E<br />
<br />744f0000 7453b000   MSCTF        Timestamp: Tue Mar 25 04:43:07 2003 (3E8024AB)                                  Checksum: 00053F50<br />
<br />75970000 75a2a000   USERENV      Timestamp: Tue Mar 25 04:42:58 2003 (3E8024A2)                                  Checksum: 000C15AA<br />
<br />75e60000 75e82000   appHelp      Timestamp: Tue Mar 25 04:42:57 2003 (3E8024A1)                                  Checksum: 0002A1FE<br />
<br />75eb0000 75fb6000   browseui     Timestamp: Thu Jul 08 19:25:07 2004 (40EDE5E3)                                  Checksum: 00106684<br />
<br />762b0000 762f7000   comdlg32     Timestamp: Tue Mar 25 04:42:55 2003 (3E80249F)                                  Checksum: 0004C19F<br />
<br />76300000 76514000   msi          Timestamp: Tue Mar 25 04:42:54 2003 (3E80249E)                                  Checksum: 002140A0<br />
<br />765a0000 766a0000   SETUPAPI     Timestamp: Tue Mar 25 04:42:54 2003 (3E80249E)                                  Checksum: 000FE0F9<br />
<br />768f0000 76914000   ntshrui      Timestamp: Tue Mar 25 04:42:52 2003 (3E80249C)                                  Checksum: 0002A48F<br />
<br />76920000 76a77000   shdocvw      Timestamp: Thu Jul 08 19:25:08 2004 (40EDE5E4)                                  Checksum: 0015E185<br />
<br />76f90000 7700e000   CLBCatQ      Timestamp: Mon Mar 15 22:08:57 2004 (40566FC9)                                  Checksum: 000837A0<br />
<br />77010000 770d6000   COMRes       Timestamp: Tue Mar 25 04:42:49 2003 (3E802499)                                  Checksum: 000C4402<br />
<br />770e0000 7715d000   OLEAUT32     Timestamp: Tue Mar 25 04:42:48 2003 (3E802498)                                  Checksum: 0007D084<br />
<br />77160000 77285000   ole32        Timestamp: Mon Mar 15 22:08:56 2004 (40566FC8)                                  Checksum: 00129304<br />
<br />77290000 772d9000   SHLWAPI      Timestamp: Thu Jul 08 19:25:08 2004 (40EDE5E4)                                  Checksum: 000521B7<br />
<br />77380000 77b5e000   SHELL32      Timestamp: Wed May 12 19:07:37 2004 (40A2BC49)                                  Checksum: 007CC594<br />
<br />77b90000 77b98000   VERSION      Timestamp: Tue Mar 25 04:42:46 2003 (3E802496)                                  Checksum: 0000CD51<br />
<br />77ba0000 77bf4000   msvcrt       Timestamp: Tue Mar 25 04:42:46 2003 (3E802496)                                  Checksum: 0005D4DB<br />
<br />77c00000 77c44000   GDI32        Timestamp: Tue Mar 25 04:42:46 2003 (3E802496)                                  Checksum: 00042EEA<br />
<br />77c50000 77cf5000   RPCRT4       Timestamp: Mon Mar 15 22:08:57 2004 (40566FC9)                                  Checksum: 000A240C<br />
<br />77d00000 77d8f000   USER32       Timestamp: Wed Aug 06 16:43:59 2003 (3F31769F)                                  Checksum: 0008FBF9<br />
<br />77da0000 77e30000   ADVAPI32     Timestamp: Tue Mar 25 04:42:45 2003 (3E802495)                                  Checksum: 00097775<br />
<br />77e40000 77f34000   kernel32     Timestamp: Tue Mar 25 04:42:44 2003 (3E802494)                                  Checksum: 000F488C<br />
<br />77f40000 77ffa000   ntdll        Timestamp: Tue Mar 25 04:42:44 2003 (3E802494)                                  Checksum: 000B6DBA</p>
<p>Of all these dlls, there is exactly *one* that got rebased &#8211; Vxdif.dll, a third party hook dll that nobody bothered to move from 10000000.</p>
<p>We can also take a look at the example you suggested, Word itself:</p>
<p>0:007&gt; lm t<br />
<br />start    end        module name<br />
<br />01830000 0183f000   Vxdif        Timestamp: Tue Nov 19 08:34:44 2002 (3DDA3DF4)                                  Checksum: 00000000<br />
<br />06470000 06582000   Apoint       Timestamp: Thu Nov 28 01:05:09 2002 (3DE5B215)                                  Checksum: 00000000<br />
<br />10000000 1005b000   SKCHUI       Timestamp: Wed Feb 07 04:09:58 2001 (3A8110E6)                                  Checksum: 00064FB0<br />
<br />30000000 30a4b000   WINWORD      Timestamp: Thu Jan 15 19:11:23 2004 (40072C2B)                                  Checksum: 00A2652E<br />
<br />30b00000 3145e000   mso          Timestamp: Thu Jan 29 18:35:38 2004 (401998CA)                                  Checksum: 0096240E<br />
<br />32520000 32532000   msohev       Timestamp: Mon Feb 12 20:42:31 2001 (3A889107)                                  Checksum: 00019384<br />
<br />34eb0000 34ec9000   ENVELOPE     Timestamp: Mon Oct 13 13:27:06 2003 (3F8AEE7A)                                  Checksum: 00022B91<br />
<br />35190000 351a1000   SENDTO       Timestamp: Sat Feb 17 18:07:46 2001 (3A8F0442)                                  Checksum: 00017F65<br />
<br />35230000 35236000   envelopr     Timestamp: Mon Feb 26 20:14:11 2001 (3A9AFF63)                                  Checksum: 0000D65D<br />
<br />3c640000 3c666000   FNAME        Timestamp: Mon Oct 13 13:37:06 2003 (3F8AF0D2)                                  Checksum: 0002A014<br />
<br />3c740000 3c77d000   MOFL         Timestamp: Mon Oct 13 13:38:00 2003 (3F8AF108)                                  Checksum: 000452FB<br />
<br />3e000000 3e0f1000   srintl       Timestamp: Mon Dec 18 19:01:54 2000 (3A3EA572)                                  Checksum: 00000000<br />
<br />3f000000 3f015000   MSSPELL3     Timestamp: Fri Feb 15 19:26:07 2002 (3C6DA71F)                                  Checksum: 0001FBD2<br />
<br />3f100000 3f431000   MSGR3EN      Timestamp: Fri Nov 03 23:39:13 2000 (3A0392F1)                                  Checksum: 003311A0<br />
<br />48000000 4807d000   riched20     Timestamp: Mon Sep 15 14:32:10 2003 (3F6613BA)                                  Checksum: 00085FD7<br />
<br />5bc50000 5bc88000   sptip        Timestamp: Tue Mar 25 04:46:57 2003 (3E802591)                                  Checksum: 00039F23<br />
<br />5cc10000 5ccbe000   sapi         Timestamp: Tue Mar 25 04:46:02 2003 (3E80255A)                                  Checksum: 000B7437<br />
<br />60970000 60979000   mslbui       Timestamp: Tue Mar 25 04:46:43 2003 (3E802583)                                  Checksum: 000112FE<br />
<br />64e30000 64e6d000   icm32        Timestamp: Tue Mar 25 04:45:11 2003 (3E802527)                                  Checksum: 0004571F<br />
<br />6e210000 6e254000   CNBJUI2      Timestamp: Tue Mar 25 04:45:56 2003 (3E802554)                                  Checksum: 0004AF41<br />
<br />6e2c0000 6e2dd000   CNBJDRV2     Timestamp: Tue Mar 25 04:45:53 2003 (3E802551)                                  Checksum: 0002A634<br />
<br />70ad0000 70bb6000   comctl32     Timestamp: Tue Mar 25 04:43:33 2003 (3E8024C5)                                  Checksum: 000E7161<br />
<br />70bc0000 70c50000   COMCTL32_70bc0000     Timestamp: Tue Mar 25 04:43:33 2003 (3E8024C5)                                  Checksum: 00096B96<br />
<br />71640000 71805000   AcGenral     Timestamp: Tue Mar 25 04:43:30 2003 (3E8024C2)                                  Checksum: 001CA751<br />
<br />71af0000 71b1a000   ShimEng      Timestamp: Tue Mar 25 04:43:27 2003 (3E8024BF)                                  Checksum: 0001C598<br />
<br />71b70000 71ba3000   UxTheme      Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 000340A1<br />
<br />71bf0000 71bf8000   WS2HELP      Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 0000B6AB<br />
<br />71c00000 71c18000   WS2_32       Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 00022613<br />
<br />71c20000 71c31000   tsappcmp     Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 0001A640<br />
<br />71c40000 71c93000   NETAPI32     Timestamp: Tue Mar 25 04:43:26 2003 (3E8024BE)                                  Checksum: 00058483<br />
<br />72e50000 72f9a000   msxml3       Timestamp: Tue Mar 25 04:43:17 2003 (3E8024B5)                                  Checksum: 0015153E<br />
<br />73070000 73096000   winspool     Timestamp: Tue Mar 25 04:43:17 2003 (3E8024B5)                                  Checksum: 0002C96E<br />
<br />73aa0000 73ab4000   mscms        Timestamp: Tue Mar 25 04:43:12 2003 (3E8024B0)                                  Checksum: 0001D328<br />
<br />73b30000 73b36000   dciman32     Timestamp: Tue Mar 25 04:43:12 2003 (3E8024B0)                                  Checksum: 0000E248<br />
<br />744c0000 744e8000   msimtf       Timestamp: Tue Mar 25 04:43:08 2003 (3E8024AC)                                  Checksum: 000290E4<br />
<br />744f0000 7453b000   MSCTF        Timestamp: Tue Mar 25 04:43:07 2003 (3E8024AB)                                  Checksum: 00053F50<br />
<br />74540000 745d2000   mlang        Timestamp: Tue Mar 25 04:43:06 2003 (3E8024AA)                                  Checksum: 00091197<br />
<br />74a80000 74aaf000   OLEACC       Timestamp: Tue Mar 25 04:43:05 2003 (3E8024A9)                                  Checksum: 00036548<br />
<br />75970000 75a2a000   USERENV      Timestamp: Tue Mar 25 04:42:58 2003 (3E8024A2)                                  Checksum: 000C15AA<br />
<br />75da0000 75e5a000   SXS          Timestamp: Tue Mar 25 04:42:57 2003 (3E8024A1)                                  Checksum: 000C0304<br />
<br />75e60000 75e82000   appHelp      Timestamp: Tue Mar 25 04:42:57 2003 (3E8024A1)                                  Checksum: 0002A1FE<br />
<br />75eb0000 75fb6000   browseui     Timestamp: Thu Jul 08 19:25:07 2004 (40EDE5E3)                                  Checksum: 00106684<br />
<br />75fc0000 76048000   urlmon       Timestamp: Thu Jul 08 19:25:08 2004 (40EDE5E4)                                  Checksum: 000881F2<br />
<br />76260000 76270000   WINSTA       Timestamp: Tue Mar 25 04:42:55 2003 (3E80249F)                                  Checksum: 00016513<br />
<br />76290000 762ad000   imm32        Timestamp: Tue Mar 25 04:42:55 2003 (3E80249F)                                  Checksum: 0002809C<br />
<br />762b0000 762f7000   comdlg32     Timestamp: Tue Mar 25 04:42:55 2003 (3E80249F)                                  Checksum: 0004C19F<br />
<br />76300000 76514000   msi          Timestamp: Tue Mar 25 04:42:54 2003 (3E80249E)                                  Checksum: 002140A0<br />
<br />76520000 7653d000   CSCDLL       Timestamp: Tue Mar 25 04:42:54 2003 (3E80249E)                                  Checksum: 0001D865<br />
<br />76540000 76590000   cscui        Timestamp: Tue Mar 25 04:42:54 2003 (3E80249E)                                  Checksum: 00051C4C<br />
<br />765a0000 766a0000   SETUPAPI     Timestamp: Tue Mar 25 04:42:54 2003 (3E80249E)                                  Checksum: 000FE0F9<br />
<br />766d0000 766d9000   SHFOLDER     Timestamp: Tue Mar 25 04:42:53 2003 (3E80249D)                                  Checksum: 0000FE87<br />
<br />767a0000 767d5000   UNIDRVUI     Timestamp: Tue Mar 25 04:42:53 2003 (3E80249D)                                  Checksum: 000338C4<br />
<br />767e0000 76823000   UNIDRV       Timestamp: Tue Mar 25 04:42:53 2003 (3E80249D)                                  Checksum: 00048FF4<br />
<br />768e0000 768e8000   LINKINFO     Timestamp: Tue Mar 25 04:42:52 2003 (3E80249C)                                  Checksum: 0000C1C0<br />
<br />768f0000 76914000   ntshrui      Timestamp: Tue Mar 25 04:42:52 2003 (3E80249C)                                  Checksum: 0002A48F<br />
<br />76920000 76a77000   shdocvw      Timestamp: Thu Jul 08 19:25:08 2004 (40EDE5E4)                                  Checksum: 0015E185<br />
<br />76aa0000 76acc000   WINMM        Timestamp: Tue Mar 25 04:42:52 2003 (3E80249C)                                  Checksum: 000384CD<br />
<br />76f00000 76f08000   wtsapi32     Timestamp: Tue Mar 25 04:42:49 2003 (3E802499)                                  Checksum: 000053F6<br />
<br />76f50000 76f63000   Secur32      Timestamp: Tue Mar 25 04:42:49 2003 (3E802499)                                  Checksum: 0001508D<br />
<br />76f90000 7700e000   CLBCatQ      Timestamp: Mon Mar 15 22:08:57 2004 (40566FC9)                                  Checksum: 000837A0<br />
<br />77010000 770d6000   COMRes       Timestamp: Tue Mar 25 04:42:49 2003 (3E802499)                                  Checksum: 000C4402<br />
<br />770e0000 7715d000   OLEAUT32     Timestamp: Tue Mar 25 04:42:48 2003 (3E802498)                                  Checksum: 0007D084<br />
<br />77160000 77285000   OLE32        Timestamp: Mon Mar 15 22:08:56 2004 (40566FC8)                                  Checksum: 00129304<br />
<br />77290000 772d9000   SHLWAPI      Timestamp: Thu Jul 08 19:25:08 2004 (40EDE5E4)                                  Checksum: 000521B7<br />
<br />77380000 77b5e000   SHELL32      Timestamp: Wed May 12 19:07:37 2004 (40A2BC49)                                  Checksum: 007CC594<br />
<br />77b70000 77b84000   MSACM32      Timestamp: Tue Mar 25 04:42:46 2003 (3E802496)                                  Checksum: 00013E94<br />
<br />77b90000 77b98000   VERSION      Timestamp: Tue Mar 25 04:42:46 2003 (3E802496)                                  Checksum: 0000CD51<br />
<br />77ba0000 77bf4000   msvcrt       Timestamp: Tue Mar 25 04:42:46 2003 (3E802496)                                  Checksum: 0005D4DB<br />
<br />77c00000 77c44000   GDI32        Timestamp: Tue Mar 25 04:42:46 2003 (3E802496)                                  Checksum: 00042EEA<br />
<br />77c50000 77cf5000   RPCRT4       Timestamp: Mon Mar 15 22:08:57 2004 (40566FC9)                                  Checksum: 000A240C<br />
<br />77d00000 77d8f000   USER32       Timestamp: Wed Aug 06 16:43:59 2003 (3F31769F)                                  Checksum: 0008FBF9<br />
<br />77da0000 77e30000   ADVAPI32     Timestamp: Tue Mar 25 04:42:45 2003 (3E802495)                                  Checksum: 00097775<br />
<br />77e40000 77f34000   kernel32     Timestamp: Tue Mar 25 04:42:44 2003 (3E802494)                                  Checksum: 000F488C<br />
<br />77f40000 77ffa000   ntdll        Timestamp: Tue Mar 25 04:42:44 2003 (3E802494)                                  Checksum: 000B6DBA<br />
<br />780c0000 78121000   MSVCP60      Timestamp: Wed May 29 16:00:05 2002 (3CF54155)                                  Checksum: 0006243E</p>
<p>Two dlls got rebased here, Apoint.dll and Vxdif.dll.  Coincidentally, both were left at the 10000000 base address.</p>
<p>I really don&#8217;t see where you are getting this idea that virtually process has lots and lots of rebased dlls.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-204873">
				<div id="div-comment-204873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.savagenomads.net/archives/000203.html' rel='external nofollow' class='url'>Savage Nomads</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-204873">
			August 20, 2004 at 1:45 pm</a>		</div>

		<p>&amp;nbsp; As Evan&amp;nbsp;already mentioned on his blog, Raymond Chen has a great series on /3GB switch on his blog. What is really cool is that Raymond takes on some myths about the /3GB switch and&amp;nbsp; the fact that he&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-280193">
				<div id="div-comment-280193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/larryosterman/archive/2005/06/06/425701.aspx' rel='external nofollow' class='url'>Larry Osterman's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-280193">
			June 6, 2005 at 11:36 am</a>		</div>

		<p>Not quite &amp;quot;Riffing on Raymond&amp;quot; but he just wrote about this, and it reminded me of a story that was related&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-353953">
				<div id="div-comment-353953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/slavao/archive/2006/03/12/550096.aspx' rel='external nofollow' class='url'>Slava Oks's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-353953">
			March 12, 2006 at 8:18 pm</a>		</div>

		<p>By now you have heard a lot about the fact that under WOW a 32 bit process can get 4GB of VAS.&amp;amp;nbsp;&amp;amp;nbsp;&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-479873">
				<div id="div-comment-479873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.not-a-kernel-guy.com/2007/03/06/156' rel='external nofollow' class='url'>Not a kernel guy &raquo; /LARGEADDRESSAWARE ?????????? ?????????????????? ?????? ???????? ????????.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040812-00/?p=38183#comment-479873">
			March 6, 2007 at 2:39 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://blog.not-a-kernel-guy.com/2007/03/06/156" rel="nofollow">http://blog.not-a-kernel-guy.com/2007/03/06/156</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

