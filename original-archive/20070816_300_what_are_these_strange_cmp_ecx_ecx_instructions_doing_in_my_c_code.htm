<html>
<head>
<title>What are these strange cmp [ecx], ecx instructions doing in my C# code?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>What are these strange cmp [ecx], ecx instructions doing in my C# code?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 16, 2007 / year-entry #301</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>41</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">When you debug through some managed code at the assembly level, you'll find a whole lot of seemingly pointless instructions that perform a comparison but ignore the result. What's the point of comparing two values if you don't care what the result is? In C++, invoking an instance method on a NULL pointer results in...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>When you debug through some managed code at the assembly level, you'll find a whole lot of seemingly pointless instructions that perform a comparison but ignore the result. What's the point of comparing two values if you don't care what the result is?</p>
<p> In C++, invoking an instance method on a <code>NULL</code> pointer results in undefined behavior. In other words, if you do it, the compiler is allowed to do anything it wants. And what most compilers do is, um, nothing. They don't take any special steps if the <code>this</code> pointer is <code>NULL</code>; they just generate code on the assumption that it isn't. In practice, this often means that everything seems to run just fine until you access a member variables or call a virtual functions, and then you crash. </p>
<p> The C# language, by comparison, is <a href="http://msdn.microsoft.com/library/en-us/csspec/html/vclrfcsharpspec_7_4_3.asp"> quite explicit about what happens if you invoke an instance method on a <code>null</code> object reference</a>: </p>
<blockquote class="q"><p> The value of <code>E</code> is checked to be valid. If the value of <code>E</code> is null, a <code>System.NullReferenceException</code> is thrown and no further steps are executed.  </p>
</blockquote>
<p> The null reference exception must be thrown before the method can be called. That's what the strange <code>cmp [ecx], ecx</code> comparison is for.&sup1; The compiler doesn't actually care what the result of the comparison is; it just wants to raise an exception if <code>ecx</code> is null. If <code>ecx</code> is null, the attempt to dereference it (in order to perform the comparison) will raise an access violation, which the runtime inspects and turns into a <code>NullReferenceException</code>. </p>
<p> The test is usually against the <code>ecx</code> register since the CLR happens to use&sup2; the <code>fastcall</code> calling convention, which for instance methods passes the <code>this</code> pointer in the <code>ecx</code> register. The pointer the compiler wants to test is going to wind up in the <code>ecx</code> register sooner or later,&sup3; so it's not surprising that the test, when it happens, is made against the <code>ecx</code> register. </p>
<p> <b>Nitpicker's Corner</b> </p>
<p> &sup1;Although this statement is written as if it were a fact, it is actually my interpretation based on observation and thinking about how language features are implemented. It is <a href="http://blogs.msdn.com/oldnewthing/archive/2007/08/10/4315707.aspx#4327521"> not an official position</a> of the CLR team nor Microsoft Corporation, and that interpretation may ultimately prove incorrect. </p>
<p> &sup2;"Happens to use" means that this is an implementation detail, not a contractual guarantee.&sup1; </p>
<p> &sup3;Unless the call is optimized. For example, the function might be inlined. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (41)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-537783">
				<div id="div-comment-537783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537783">
			August 16, 2007 at 10:56 am</a>		</div>

		<p>You say &#8220;if ecx is null&#8221;&#8230; But the assembly-language registers<br />
don&#8217;t actually contain &#8220;null&#8221; in this case, do they? &nbsp;Do they<br />
contain zero? &nbsp;I suppose that cmp ecx, ecx will raise an access<br />
violation if ecx is zero.</p>
<p>Since I&#8217;m not an assembly language progammer, maybe there is some<br />
special value in a register that means the corresponding C# object is<br />
null. &nbsp;(I&#8217;m not really trying to nitpick, honest.) &nbsp;I<br />
couldn&#8217;t figure this out with a Google search.</p>
<div class="post">[<i>&#8220;If ecx contains a value corresponding to a null<br />
reference&#8221;. I thought it was obvious that knowledge of assembly<br />
language was a prerequisite for this article, seeing as if you don&#8217;t<br />
know assembly language, then you&#8217;ll never see &#8220;cmp [ecx], ecx&#8221; in the<br />
first place, so you will never ask the question in the title. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-537803">
				<div id="div-comment-537803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff Stong</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537803">
			August 16, 2007 at 11:19 am</a>		</div>

		<p>It&#8217;s comical (in a sad way) to see that even your footnotes require footnotes. &nbsp;I find the blog enlightening and entertaining. &nbsp;Please don&#8217;t let the need for the footnotes discourage you from continuing the blog &#8212; it would be sorely missed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537883">
				<div id="div-comment-537883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537883">
			August 16, 2007 at 12:29 pm</a>		</div>

		<p>strcmp&#8217;s post just kicked started my brain, it didn&#8217;t process the de-referencing brackets when I first read this earlier. (Is this truly the cheapest way to do this?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-537913">
				<div id="div-comment-537913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537913">
			August 16, 2007 at 12:53 pm</a>		</div>

		<p>Ah, I see, deliberate access violation &#8211; the (virtual) address range between 0 and 64KB (0x0000&#8217;0000 to 0x0001&#8217;0000) is reserved in Windows and always causes access violations when you do it. The CLR looks at the address that the offending instruction was trying to read from/write to and if it&#8217;s 0 (possibly up to 64KB) it&#8217;ll interpret that as a NullReferenceException, otherwise it&#8217;s an AccessViolationException.</p>
<p>Getting the hardware to generate an access violation isn&#8217;t particularly quick, but it&#8217;s supposed to be the exceptional case. We&#8217;re worried about the performance of the regular case of the pointer not being null. Presumably this instruction was selected as being one that pipelines well on Intel and AMD processors without introducing too many other dependencies, while still being pretty small, only two bytes. As a side-effect it catches any other bad pointers, as well as just null ones. The value of [ecx] is likely to be needed anyway if making a virtual call &#8211; C++ compilers usually put the vtable pointer as the first member of the object, and I think this was carried over into the CLR.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537953">
				<div id="div-comment-537953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.dancingbunnies.com' rel='external nofollow' class='url'>Sjoerd Verweij</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537953">
			August 16, 2007 at 1:44 pm</a>		</div>

		<p>&quot;Raymond&#8217;s current temper tantrum&quot;</p>
<p>I would call it &quot;justifyable and increasing irritation with commenters being demanding, whiny, pedantic, clueless or argumentative&quot;. It is a PERSONAL blog, which he does for PERSONAL enjoyment. Thank you for lessening the latter another notch by using this term.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ericlippert odd alt thread-odd thread-alt depth-1" id="comment-537973">
				<div id="div-comment-537973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Eric+Lippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537973">
			August 16, 2007 at 2:03 pm</a>		</div>

		<p>An additional data point:</p>
<p>As Raymond correctly conjectures, the jitter turns a callvirt into machine code which ensures that the &quot;this&quot; reference is good before the call. This is why the C# compiler sometimes generates callvirt instructions even when we are making a call to a non-virtual instance method &#8212; we want to get the null check &quot;for free&quot;.</p>
<p>If the C# compiler detects that it is doing a call on a non-virtual instance method and we can deduce at compile time that the object of the call cannot possibly be null, then we sometimes do just an ordinary call without forcing the check. This allows the jitter to generate slightly more efficient code.</p>
<p>For example, if you have</p>
<p>GiveMeAFoo().FooNonVirtMethod()</p>
<p>we will generate a virtual call to FooNonVirtMethod so that we get the null check. &nbsp;But if you have</p>
<p>(new Foo()).FooNonVirtMethod()</p>
<p>then we know that the &quot;new&quot; has already thrown an exception if the allocation failed, so this cannot be null, therefore we just generate a call so that we skip the null check.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538033">
				<div id="div-comment-538033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Drew Hoskins</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538033">
			August 16, 2007 at 4:38 pm</a>		</div>

		<p>The effect of this is interesting&#8230; aggregating fields by value is in general no faster on .NET than aggregating by reference. &nbsp;In the former case, it will check *this, and in the latter case, it won&#8217;t bother since it&#8217;s already dereferencing the field reference, and will get an exception there. &nbsp;In each case you have one memory load. &nbsp;At least, that&#8217;s what I found to be true with C++/CLI on VS 2005.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538043">
				<div id="div-comment-538043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.virtualdub.org/' rel='external nofollow' class='url'>Phaeron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538043">
			August 16, 2007 at 5:21 pm</a>		</div>

		<p>I wonder why cmp [ecx], ecx was used instead of mov eax, [ecx]. Was it due to register pressure? The cmp form is slightly more expensive as it takes two uops (load + alu).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537823">
				<div id="div-comment-537823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537823">
			August 16, 2007 at 11:30 am</a>		</div>

		<p>David: think of it this way&#8230; assembly language registers are effectively untyped[*]. &nbsp;In the instruction &#8216;cmp [ecx], ecx&#8217;, ecx is being used as a pointer, therefore it does make sense to say that it could contain null.</p>
<p>* Obviously, I mean &quot;untyped in as far as that&#8217;s possible with a very limited data storage capacity&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538063">
				<div id="div-comment-538063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.ultrafractal.com/' rel='external nofollow' class='url'>Frederik Slijkerman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538063">
			August 16, 2007 at 6:32 pm</a>		</div>

		<p>@Phaeron: Yes of course. Your code requires the jitter to find (or make) a free register.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-537843">
				<div id="div-comment-537843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">strcmp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-537843">
			August 16, 2007 at 11:44 am</a>		</div>

		<p>David, don&#8217;t let Raymond&#8217;s current temper tantrum get you down. &nbsp;Hopefully it&#8217;ll pass soon. &nbsp;You can think of cmp [ecx],ecx as equivalent* to:</p>
<p>if( *p == p );</p>
<p>So naturally if p == 0 (NULL is just 0 **), you&#8217;ll throw an exception on *p ([ecx]) because p (ecx) is NULL. &nbsp;If p is a valid memory reference, the instruction is essentially a no-op.</p>
<p>* If you nitpick this statement, you live a sad, sad life.</p>
<p>** Same with this statement. &nbsp;The majority of people really honestly don&#8217;t care about the more precise answer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538123">
				<div id="div-comment-538123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xiaoguo ge</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538123">
			August 16, 2007 at 9:53 pm</a>		</div>

		<p>Does this check and use has to be thread safe. If it does, then the cost would be huge. And how does the compiler ensure it is thread safe</p>
<div class="post">[<i>What could render a null pointer test thread-unsafe? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538193">
				<div id="div-comment-538193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538193">
			August 17, 2007 at 2:40 am</a>		</div>

		<p>Phaeron said:</p>
<p>=====</p>
<p>I wonder why cmp [ecx], ecx was used instead of mov eax, [ecx]. Was it due to register pressure? The cmp form is slightly more expensive as it takes two uops (load + alu).</p>
<p>=====</p>
<p>Only if you define expense in terms of time :-). &nbsp;What&#8217;s the expense of having your eax register shredded from underneath you (or having to push/pop around the call)?</p>
<p>Why use an instruction that&#8217;s arguably more side-effective than the cmp? &nbsp;Cmp changes the flags, mov changes a register which may be in use by the calling code. &nbsp;Given that most instructions would affect the flags, it&#8217;s likely that a given sequence of code is more likely to have &#8216;changes flags&#8217; than &#8216;changes a register&#8217; as a side-effect. &nbsp;My question was along the lines of &quot;why use cmp instead of test?&quot;. &nbsp;I don&#8217;t have the energy to go and analyse instruction cycles for them so I&#8217;ll defer to others.</p>
<p>Xiaoguo Ge stated:</p>
<p>=====</p>
<p>Does this check and use has to be thread safe. If it does, then the cost would be huge. And how does the compiler ensure it is thread safe?</p>
<p>=====</p>
<p>Does Intel still only allow interrupts between instructions (the &#8216;186 was the last chip I coded in ASM so I&#8217;m unsure)? &nbsp;If so, there&#8217;s no problem with thread-safety. &nbsp;The check-and-use of cmp is irrelevant since we don&#8217;t care what the result of the comparison would be &#8211; we&#8217;re just using the memory-access part of that instruction to raise an exception if it&#8217;s NULL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538203">
				<div id="div-comment-538203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Burble</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538203">
			August 17, 2007 at 4:27 am</a>		</div>

		<p>I like the footnote in the footnote. &nbsp;In the future, you could add footnote 2 to footnote 1, and vice versa. &nbsp;Then all the nitpickers would end up stuck in an infinite loop and have no further impact on your writing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538243">
				<div id="div-comment-538243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alpha Male</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538243">
			August 17, 2007 at 6:09 am</a>		</div>

		<p>&gt; [What could render a null pointer test thread-unsafe? -Raymond]</p>
<p>Are you assuming x86?</p>
<div class="post">[<i>Assume any processor that is supported by the CLR. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538253">
				<div id="div-comment-538253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xavi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538253">
			August 17, 2007 at 7:02 am</a>		</div>

		<p>&#8220;so you will never ask the question in the title&#8221;</p>
<p>Ok&#8230; this is it.</p>
<p>Sorry to spoil your weekend Raymond, but you can delete me from your readers list.No, begging won&#8217;t help.</p>
<p>The way I see it, your knowledge doesn&#8217;t make up your attitude anymore. Your cynic and arrogance response in return to a polite (though in your view stupid question) just kicked me. Reading your blog turns me down. Seeing how you post to a broad audience and seeing how you can&#8217;t politely deal with the echo is a sad thing.</p>
<p>To make a long story short, this is your blog and you can do what you want, now without me.</p>
<div class="post">[<i>I don&#8217;t post to a broad audience, but a broad audience reads me. I&#8217;m trying to target advanced programmers. If I write an article about assembly language, then I&#8217;m going to assume you know assembly language. If you don&#8217;t, then you can skip that article. I&#8217;m not going to write an assembly language tutorial to &#8220;get everybody up to speed&#8221;; I assume that you&#8217;re already up to speed. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538263">
				<div id="div-comment-538263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.nickfitz.co.uk/' rel='external nofollow' class='url'>Nick Fitzsimons</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538263">
			August 17, 2007 at 7:13 am</a>		</div>

		<p>@AlphaMale: given that the article is about the disassembly of an x86 machine code instruction, I think you can probably take it as a given that Raymond is assuming an x86 architecture.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538273">
				<div id="div-comment-538273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">poochner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538273">
			August 17, 2007 at 8:12 am</a>		</div>

		<p>I&#8217;m not seeing how this could be thread unsafe, anymore than any other use. &nbsp;It&#8217;s testing the </p>
<pre class="brush: plain; title: ; notranslate" title="">this</pre>
<p> pointer for an object during the call to one of that object&#8217;s methods. &nbsp;Say we&#8217;re calling a method on an object for which we have member reference. &nbsp;The thread that&#8217;s making the call has a working reference to the object. &nbsp;If some other thread nulls out the member, that&#8217;s not going to change that the caller still has its reference.</p>
<p>If the thread calling the referred object somehow gets a ref to itself back from the owner (via a getter, say), it could get a NullReferenceException, but that&#8217;s a normal thread-safety issue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538293">
				<div id="div-comment-538293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jeffstong.blogspot.com/' rel='external nofollow' class='url'>Jeff Stong</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538293">
			August 17, 2007 at 8:59 am</a>		</div>

		<p>&quot;In the future, you could add footnote 2 to footnote 1, and vice versa.&quot;</p>
<p>This reminds me of a couple of entries in the glossary of a reference book I received (many years ago) with an Apple IIe.</p>
<p>Infinite loop : See loop, infinite.</p>
<p>and</p>
<p>Loop, infinite : See infinite loop.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538343">
				<div id="div-comment-538343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jasonhaley.com/blog/archive/2007/08/17/140231.aspx' rel='external nofollow' class='url'>Jason Haley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538343">
			August 17, 2007 at 10:46 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538483">
				<div id="div-comment-538483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/ericlippert/archive/2007/08/17/subtleties-of-c-il-codegen.aspx' rel='external nofollow' class='url'>Fabulous Adventures In Coding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538483">
			August 17, 2007 at 12:36 pm</a>		</div>

		<p>It must be CLR week over at The Old New Thing because it&#8217;s been non-stop posts about C# lately. Raymond&#8217;s</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-538533">
				<div id="div-comment-538533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538533">
			August 17, 2007 at 1:01 pm</a>		</div>

		<p>@Pax: why not use test? If you simply test the value of ecx against 0, you then need to add a branch to generate the exception (best case, JZ &lt;exception-generator-code&gt;, probably 6 bytes if you&#8217;re not going to keep a NullReferenceException generator somewhere near every single block of code that performs the check). If you&#8217;re going to use test [ecx], reg, that still requires a two-byte opcode and still incurs both a load and alu cycle.</p>
<p>Adding the branch causes the branch predictor to do more work, and the processor to have to load more code, with the JIT having to allocate more memory for the code giving potentially more swapping. Remember, this is an operation we&#8217;re doing all the time!</p>
<p>In terms of dependencies on other instructions, this only has a dependency on a previous write to ecx, and only generates downstream dependencies on the flags, and the code generated by the JIT shouldn&#8217;t be relying on the values of those anyway (since it will assume that either the pointer is good, or the code after it will not be reached because a hardware exception was raised). x86 doesn&#8217;t actually have that many conditional instructions &#8211; CMOV and the Jcc family are the main ones. Other architectures &#8211; ARM, Itanium, for example &#8211; have predicated instructions, but then ARM only sets the condition flags if asked to, the default is to leave the condition flags alone.</p>
<p>This is another problem with the mov eax, [ecx] alternative &#8211; you make future instructions that use eax dependent on this one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538663">
				<div id="div-comment-538663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538663">
			August 17, 2007 at 2:07 pm</a>		</div>

		<p>strcmp said : &#8220;If p is a valid memory reference, the instruction is essentially a no-op.&#8221;</p>
<p>It isn&#8217;t.</p>
<p>Actually if p is a valid memory reference, then CMP [ECX], ECX has a side effect of TLB priming and a prefetch.</p>
<p>If there are two threads accessing the same object where one often writes to some member variable (say at [ECX + 8]), and another does this check each time before calling a method in a loop you will have false cache line sharing issue which is I believe more serious performance hit than the TEST ECX, ECX / JZ RaiseException.</p>
<p>On second thought, perhaps you don&#8217;t need two threads at all. It would be enough for one thread to write the variable at [ECX + 8] and to perform CMP [ECX], ECX before a method call in a loop. That way the write to variable at [ECX + 8] would most likely always have to be written back to memory creating a lot of unneccessary bus traffic.</p>
<div class=post>[<i>It seems awful strange that a single processor would be forced to flush writes just because a read occurred on the same cache line. I&#8217;d think that was a very common coding pattern. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538673">
				<div id="div-comment-538673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538673">
			August 17, 2007 at 2:11 pm</a>		</div>

		<p>Let me just clarify that I am talking about x86 here and that RaiseException label should be at the end of the executable because static predictor predicts forward conditional jumps as not taken and it would be right 99% of the time. For that 1% when you get an exception it wouldn&#8217;t matter anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538753">
				<div id="div-comment-538753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538753">
			August 17, 2007 at 3:50 pm</a>		</div>

		<p>&#8220;It seems awful strange that a single processor would be forced to flush writes just because a read occurred on the same cache line. I&#8217;d think that was a very common coding pattern. -Raymond&#8221;</p>
<p>You are right, I got confused about that, but the problem stays with the threads and it seems that it can&#8217;t be avoided.</p>
<div class=post>[<i>The question is, then, whether the JIT should optimize on the assumption that most objects are hot on multiple processors simultaneously, or whether it should optimize on the assumption that most objects are used by only one processor at a time. You appear to believe that the JIT should optimize for the former. I would guess that the latter is more reflective of the real world. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ericlippert odd alt thread-odd thread-alt depth-1" id="comment-538763">
				<div id="div-comment-538763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Eric+Lippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538763">
			August 17, 2007 at 3:52 pm</a>		</div>

		<blockquote><p>
  does judicious use of &quot;sealed&quot; prevent the generation of unnecessary callvirt calls?
</p></blockquote>
<p>Sorry, I am not following your train of thought here. How would knowing that a class is sealed enable us to know that the object of a call to a non-virtual method is not null?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538773">
				<div id="div-comment-538773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.virtualdub.org/' rel='external nofollow' class='url'>Phaeron</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538773">
			August 17, 2007 at 4:02 pm</a>		</div>

		<p>@KJK::Hyperion:</p>
<p>It&#8217;s been a while, but I think the 16-bit DOS emulator might commit memory at 0. I guess writing managed NTVDM plugins isn&#8217;t a good idea. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538863">
				<div id="div-comment-538863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538863">
			August 17, 2007 at 9:26 pm</a>		</div>

		<p>&#8220;The question is, then, whether the JIT should optimize on the assumption that most objects are hot on multiple processors simultaneously, or whether it should optimize on the assumption that most objects are used by only one processor at a time.&#8221;</p>
<p>How about going forward in step with the hardware for once? Multicore is almost a standard nowadays. Shouldn&#8217;t software follow and adapt?</p>
<p>&#8220;I would guess that the latter is more reflective of the real world.&#8221;</p>
<p>I am not into C# so correct me if I assume too much, but if someone for example writes a Queue class, wouldn&#8217;t it be neccessary for multiple, not just two threads to access it? How would this CMP [ECX], ECX which is effectively hidden from a developer work to his advantage in that and any other similar case?</p>
<div class=post>[<i>Most programs are not written with the design that all objects are highly multithreaded with lock-free algorithms. I bet yours aren&#8217;t. You can have all the multicore in the world it won&#8217;t make a difference. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538873">
				<div id="div-comment-538873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538873">
			August 17, 2007 at 9:46 pm</a>		</div>

		<p>And regarding this:</p>
<p>&#8220;It seems awful strange that a single processor would be forced to flush writes just because a read occurred on the same cache line. I&#8217;d think that was a very common coding pattern.&#8221;</p>
<p>After rethinking it I believe that there is a possibility for performance loss even with single-threaded code.</p>
<p>If you have for example (in pseudo code):</p>
<p>class Crap</p>
<p>{</p>
<p>public:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Crap()</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;~Crap()</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;double Calc()</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// does something smarter</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// than this of course</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return rand() * 0.01 + m_Var;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;SetCrap(double Var)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_Var = Var;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;double m_Var;</p>
<p>};</p>
<p>And then:</p>
<p>double &nbsp;a = 3.14, b;</p>
<p>Crap &nbsp; &nbsp;c;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; 1000; i++) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.SetCrap(a);</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a += c.Calc();</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>If we assume that m_Var is at [ECX + 0] and if you perform CMP [ECX], ECX before Calc() method call you are probably blocking store to load forwarding because of a large store (double is 8 bytes) followed by a small load (CMP [ECX], ECX loads 4 bytes) thus effectively forcing the write to go through memory.</p>
<p>But perhaps I am wrong and perhaps I don&#8217;t know nothing about code optimization. It is 3:46am here you know.</p>
<div class=post>[<i>Step through some CLR assembly language to see what really happens. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538743">
				<div id="div-comment-538743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538743">
			August 17, 2007 at 3:41 pm</a>		</div>

		<p>Bonus disruption: you *can* allocate memory at virtual address 0 with VirtualAlloc and MapViewOfFile. Don&#8217;t do it even if you figure out how, though :-)</p>
<p>EricLippert: does judicious use of &quot;sealed&quot; prevent the generation of unnecessary callvirt calls?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-538963">
				<div id="div-comment-538963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538963">
			August 18, 2007 at 11:07 am</a>		</div>

		<p>&#8220;Most programs are not written with the design that all objects are highly multithreaded with lock-free algorithms. I bet yours aren&#8217;t. You can have all the multicore in the world it won&#8217;t make a difference. -Raymond&#8221;</p>
<p>But I wasn&#8217;t implying that queue should/must be lock-free. I just said that this invisible pointer test will hurt performance for any object which is accessed by multiple threads in a loop.</p>
<p>&#8220;Step through some CLR assembly language to see what really happens. -Raymond&#8221;</p>
<p>Great, now I have to install C#&#8230;</p>
<div class="post">[<i>?? If there&#8217;s a lock then you&#8217;re going to have cache line contention anyway! I assume people are willing to do some basic research before asking questions. If you are not willing to do that, then I am equally unwilling to bother answering. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-538973">
				<div id="div-comment-538973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538973">
			August 18, 2007 at 11:24 am</a>		</div>

		<p>EricLippert: sorry, got confused. But &quot;sealed&quot; does turn virtual calls into normal calls, right? since you know the methods couldn&#8217;t possibly be overriden?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-538993">
				<div id="div-comment-538993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-538993">
			August 18, 2007 at 4:44 pm</a>		</div>

		<p>@KJK::Hyperion: use of &#8216;sealed&#8217; would indeed allow the compiler to generate call rather than callvirt for a virtual function call, if the static type of the variable is a sealed class. Eric&#8217;s discussion is about using callvirt to force a null check, as required by the language, even where a non-virtual call would have been possible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-539003">
				<div id="div-comment-539003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-539003">
			August 18, 2007 at 7:19 pm</a>		</div>

		<p>&#8220;If there&#8217;s a lock then you&#8217;re going to have cache line contention anyway!&#8221;</p>
<p>Of course but you can at least keep other often accessed data out of the cache line which holds the lock. I am talking about false sharing here which is may not be obvious to the developer.</p>
<div class="post">[<i>What percentage of programs would benefit from this hyper-micro-optimization? Compare it to the cost to programs that don&#8217;t care. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-539013">
				<div id="div-comment-539013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-539013">
			August 19, 2007 at 2:24 am</a>		</div>

		<p>&quot;What percentage of programs would benefit from this hyper-micro-optimization?&quot;</p>
<p>Perhaps people from your SQL server team could tell you more about it. I remember them having performance issues with false sharing and blaiming it all on the HyperThreading capable CPUs.</p>
<p>&quot;Compare it to the cost to programs that don&#8217;t care.&quot;</p>
<p>Are you seriously implying that the cost of:</p>
<p>TEST ECX, ECX</p>
<p>JZ &nbsp; NullPointerExceptionHandler</p>
<p>Is higher than the cost of:</p>
<p>CMP [ECX], ECX</p>
<p>???</p>
<p>As far as I know from theory it goes like this:</p>
<ol>
<li>Cost of TEST/JZ is non-existent because forward conditional jump is predicted as not taken.</li>
<li>
<p>Cost of CMP is much higher because it is a load from memory which can prime TLB, trigger a page fault, and it generates unneccessary bus traffic.</p>
</li>
</ol>
<p>Granted I haven&#8217;t constructed a test case because I have a busy schedule at the moment so I can&#8217;t claim the above is true for the real world code.</p>
<p>I&#8217;ll see if I can find some time to check it out. Or I should perhaps trust Microsoft on this one because they have already compared the two methods on a variety of application types including threaded ones?!?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ericlippert odd alt thread-odd thread-alt depth-1" id="comment-539113">
				<div id="div-comment-539113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Eric+Lippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-539113">
			August 20, 2007 at 12:58 am</a>		</div>

		<p>Re: using &quot;call&quot; on a sealed virtual method.</p>
<p>Ah, I think I understand. I think your question is &quot;if we are guaranteed that the object is not null AND we know the exact method that will be in the vtable because the class is sealed, then can we generate a call rather than a callvirt?&quot;</p>
<p>Yes, we could do that. We don&#8217;t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-539193">
				<div id="div-comment-539193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-539193">
			August 20, 2007 at 9:01 am</a>		</div>

		<blockquote>
<ol>
<li>Cost of CMP is much higher because it is a load from memory which can prime TLB, trigger a page fault,</li>
</ol>
<p>  and it generates unneccessary bus traffic.
</p></blockquote>
<p>I&#8217;m no assembly expert, but surely since [ECX] is your &quot;this&quot; pointer, and you&#8217;re only testing because you&#8217;re about to call a method on it anyway, then loading the value at [ECX] is offset by the fact that you&#8217;re about to use it anyway&#8230;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-539593">
				<div id="div-comment-539593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-539593">
			August 21, 2007 at 2:51 am</a>		</div>

		<p>&quot;I&#8217;m no assembly expert, but surely since [ECX] is your &quot;this&quot; pointer, and you&#8217;re only testing because you&#8217;re about to call a method on it anyway, then loading the value at [ECX] is offset by the fact that you&#8217;re about to use it anyway&#8230;?&quot;</p>
<p>Yes but as I understand it (perhaps incorrectly?), you are always loading from [this + 0], not the actual pointer of the method you are going to call.</p>
<p>I just gave my .02 when it comes to potential performance impact on the future code (especially threaded), perhaps I am wrong, time will tell.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-539623">
				<div id="div-comment-539623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-539623">
			August 21, 2007 at 3:46 am</a>		</div>

		<p>@Igor stated: Are you seriously implying that the cost of:</p>
<p>TEST ECX, ECX</p>
<p>JZ &nbsp; NullPointerExceptionHandler</p>
<p>Is higher than the cost of:</p>
<p>CMP [ECX], ECX</p>
<p>???</p>
<p>As far as I know from theory it goes like this:</p>
<ol>
<li>Cost of TEST/JZ is non-existent because forward conditional jump is predicted as not taken.</li>
<li>
<p>Cost of CMP is much higher because it is a load from memory which can prime TLB, trigger a page fault, and it generates unneccessary bus traffic.</p>
</li>
</ol>
<p>=====</p>
<p>We&#8217;re still assuming cost is based on elapsed time? &nbsp;Cost is a generic term which may be time, memory size, etc. &nbsp;The &#8216;cmp ecx,0;jz offset&#8217; method takes (I think) more bytes (3+2, best case assuming nullpointer label within short jump range) than &#8216;cmp [ecx],ecx&#8217; (2), does it not?</p>
<p>This increase in memory may not have much of an impact unless there&#8217;s LOTS of these tests compared to the rest of the code.</p>
<p>But you also need to take into account that most &#8216;cmp [ecx],ecx&#8217; instructions WON&#8217;T result in page faults as I would assume the code is debugged in production to the point where there&#8217;s no null pointers (TLB priming is beyond my expertise, thank $DEITY I code in high-level languages nowadays.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-539903">
				<div id="div-comment-539903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-539903">
			August 21, 2007 at 11:45 am</a>		</div>

		<p>&quot;I thought it was obvious that knowledge of assembly language was a prerequisite for this article&#8230;&quot;</p>
<p>Well, I have actually written lots and lots of assembly language, but not on x86&#8217;s or compatible &#8212; it was on IBM and compatible mainframes. &nbsp;And I have read my share of x86-compatible assembler code.</p>
<p>I was truly confused by the concept of putting a null value into a register!</p>
<p>Now I understand. &nbsp;And Xavi, don&#8217;t leave because of Raymond&#8217;s response to me. &nbsp;It wasn&#8217;t that bad.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561563">
				<div id="div-comment-561563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://breadthfirst.wordpress.com/2007/10/21/mysterious-windows-prefixes-and-opcodes/' rel='external nofollow' class='url'>Mysterious Windows Prefixes and Opcodes &laquo; A broader view</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070816-00/?p=25553#comment-561563">
			October 21, 2007 at 12:50 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://breadthfirst.wordpress.com/2007/10/21/mysterious-windows-prefixes-and-opcodes/" rel="nofollow">http://breadthfirst.wordpress.com/2007/10/21/mysterious-windows-prefixes-and-opcodes/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

