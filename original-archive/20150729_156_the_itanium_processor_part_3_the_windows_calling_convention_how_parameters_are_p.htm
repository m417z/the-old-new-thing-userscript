<html>
<head>
<title>The Itanium processor, part 3: The Windows calling convention, how parameters are passed</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The Itanium processor, part 3: The Windows calling convention, how parameters are passed</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 29, 2015 / year-entry #157</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>20</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Slide on over.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
The calling convention on Itanium uses a variable-sized register window.
The mechanism by which this is done is rather complicated,
so I'm first going to present a conceptual version,
and then I'll come back and fix up some of the implementation details.
For today, I'm just going to talk about how parameters are passed.
There are other aspects of the calling convention that I will cover
in separate articles.
</p>
<p>
Recall that the first 32 registers <var>r0</var> through <var>r31</var>
are static (do not change), and the remaining registers
<var>r32</var> through <var>r127</var> are stacked.
These stacked registers fall into three categories:
<i>input registers</i>,
<i>local registers</i>,
and <i>output registers</i>.
</p>
<p>
The input registers receive the function parameters.
On entry to a function, the function's parameters are received in registers
starting at <var>r32</var> and increasing.
For example, a function that takes two parameters receives the first
parameter in <var>r32</var> and
the second parameter in <var>r33</var>.
</p>
<p>
Immediately after the input registers are the registers for
the function's private use.
These are known as <i>local registers</i>.
For example, if that function with two parameters also wants
four registers for private use,
those private registers would be <var>r34</var> through <var>r37</var>.
</p>
<p>
After the input registers are the registers used to call
other functions,
known as <i>output registers</i>.&sup1;
For example, if the function with two parameters and four local registers
wants to call a function that has three parameters,
it would put those parameters in registers <var>r38</var>
through <var>r40</var>.
Therefore,
a function needs as many output registers as the maximum number of
parameters of any function it calls.
</p>
<p>
The input registers and local registers are collectively known as the
<i>local region</i>.
The input registers, local registers, and output registers are
collectively known as the <i>register frame</i>.
</p>
<p>
Any registers higher than the last output register
are off-limits to the function,
and we shall henceforth pretend they do not exist.
Since the registers go up to <var>r127</var>,
and in practice register frames are around one or two dozen registers,
there end up being a lot of registers that go unused.
</p>
<p>
The first thing a function does is notify the processor of its intended
register usage.
It uses the <code>alloc</code> instruction to say
how many input registers,
local registers,
and output registers it needs.
</p>
<pre>
alloc r35 = ar.pfs, 2, 4, 3, 0
</pre>
<p>
This means,
"Set up my register frame as follows:
Two input registers,
four local registers,
three output registers,
and no rotating registers.
Put the previous register frame state (<var>pfs</var>)
in register <var>r35</var>."
</p>
<p>
The second thing a function does is save the return address,
typically in one of the local registers it just created.
For example, the above <code>alloc</code> might be followed by
</p>
<pre>
mov r34 = rp
</pre>
<p>
On entry to a function, the <var>rp</var> register contains
the caller's return address,
and most of the time, the compiler will save the return address
in a register.
Note that this means that on the Itanium, a stack buffer
overrun will never overwrite a return address, since
return addresses are not kept on the stack.
(Let that sink in.
On Itanium, return addresses <i>are not kept on the stack</i>.
This means that tricks like
<a HREF="http://msdn.microsoft.com/library/s975zw7k">
<code>_Address&shy;Of&shy;Return&shy;Address</code></a> will not work!)
</p>
<p>
By convention, the <var>rp</var> and
<var>ar.pfs</var> are saved in consecutive registers
(here, <var>r34</var> and <var>r35</var>).
This convention makes exception unwinding slightly easier.
</p>
<p>
Let's see what happens when somebody calls this function.
Suppose the caller's register frame looks like this:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=3 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=5>local region</td>
<td COLSPAN=5 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=3>input</td>
<td COLSPAN=2>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
<td STYLE="width: 2em"><var>r41</var></td>
</tr>
</table>
<p>
The caller places the parameters to our function in its output
registers, in this case <var>r37</var> and <var>r38</var>.
(Our function takes only two parameters, so
<var>r39</var> and beyond are not used.)
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=4 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=5>local region</td>
<td COLSPAN=5 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=3>input</td>
<td COLSPAN=2>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
<td STYLE="width: 2em"><var>r41</var></td>
</tr>
<tr>
<td>0</td>
<td>A</td>
<td>&hellip;</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</table>
<p>
The caller then invokes our function.
</p>
<p>
Our function opens by performing this <code>alloc</code>,
declaring two input registers, four local registers,
and three output registers.
</p>
<pre>
alloc r35 = ar.pfs, 2, 4, 3, 0
</pre>
<p>
That
<code>alloc</code> instruction
shuffles the registers like this:
</p>
<ul>
<li>The static registers don't change.</li>
<li>The registers in the caller's local region are saved in a magic place.</li>
<li>The specified number of output registers from the caller become
    the new function's input registers.</li>
<li>New local and output registers are created but left uninitialized.</li>
<li>The previous function state is placed in the specified register
    (for restoration at function exit).
    There are many parts of the function state, but the part we care
    about is the frame state, which describes how registers are assigned.</li>
</ul>
<p>
Here's what the register frame looks like after all but the last
steps above:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=5 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=6>local region</td>
<td COLSPAN=3 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=2>input</td>
<td COLSPAN=4>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
</tr>
<tr>
<td>0</td>
<td>A</td>
<td>&hellip;</td>
<td>F</td>
<td>G</td>
<td>M</td>
<td>N</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td COLSPAN=5>unchanged</td>
<td COLSPAN=2>moved</td>
<td COLSPAN=7>uninitialized</td>
</tr>
</table>
<p>
The last step (storing the previous function state in the specified register)
updates the <var>r35</var> register:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=4 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=6>local region</td>
<td COLSPAN=3 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=2>input</td>
<td COLSPAN=4>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
</tr>
<tr>
<td>0</td>
<td>A</td>
<td>&hellip;</td>
<td>F</td>
<td>G</td>
<td>M</td>
<td>N</td>
<td>?</td>
<td>pfs</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</table>
<p>
The next instruction is typically one to save the return address.
</p>
<pre>
mov r34 = rp
</pre>
<p>
After that <code>mov</code> instruction, the function prologue
is complete, and the register state looks like this:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=4 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=6>local region</td>
<td COLSPAN=3 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=2>input</td>
<td COLSPAN=4>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
</tr>
<tr>
<td>0</td>
<td>A</td>
<td>&hellip;</td>
<td>F</td>
<td>G</td>
<td>M</td>
<td>N</td>
<td>ra</td>
<td>pfs</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</table>
<p>
where <code>ra</code> is the function's return address.
</p>
<p>
At this point the function runs and does actual work.
Once it's done,
its register state might look like this:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=4 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=6>local region</td>
<td COLSPAN=3 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=2>input</td>
<td COLSPAN=4>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
</tr>
<tr>
<td>0</td>
<td>A&prime;</td>
<td>&hellip;</td>
<td>F&prime;</td>
<td>G&prime;</td>
<td>T</td>
<td>U</td>
<td>ra</td>
<td>pfs</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
</tr>
</table>
<p>
The function epilogue typically consists of three instructions:
</p>
<pre>
mov rp = r34     // prepare to return to caller
mov ar.pfs = r35 // restore previous function state
br.ret rp        // return!
</pre>
<p>
This sequence begins by copying the saved return address into
the <var>rp</var> register so that we can jump back to it.
(We could have copied <var>r34</var> into any scratch branch
register, but by convention we use the <var>rp</var>
register because it makes exception unwinding easier.)
</p>
<p>
Next, it restores
the register
state from the <var>pfs</var> it saved at function entry.
Finally, it transfers control back to the caller by jumping
through the <var>rp</var> register.
(We cannot do a <code>br.ret r34</code>
because <code>r34</code> is not a branch register;
the parameter to <code>br.ret</code> must be a branch register.)
</p>
<p>
Restoring the previous function state causes the caller's
register frame layout to be restored, and the values of the registers
in the caller's local region are restored from that magic place.
</p>
<p>
The register state upon return back to the caller looks like this:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=5 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=5>local region</td>
<td COLSPAN=5 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=3>input</td>
<td COLSPAN=2>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
<td STYLE="width: 2em"><var>r41</var></td>
</tr>
<tr>
<td>0</td>
<td>A&prime;</td>
<td>&hellip;</td>
<td>F&prime;</td>
<td>G&prime;</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td COLSPAN=5>unchanged</td>
<td COLSPAN=5>restored</td>
<td COLSPAN=5>uninitialized</td>
</tr>
</table>
<p>
From the point of view of the calling function,
calling another function has the following effect:
</p>
<ul>
<li>Static registers are shared with the called function.
    (Any changes to static registers are visible to the caller.)</li>
<li>The local region is preserved across the call.</li>
<li>The output registers are trashed by the call.</li>
</ul>
<p>
At most eight parameters are passed in registers.
Any additional parameters are passed on the stack,
and it is the caller's responsibility to clean them up.
(The stack-based parameters begin
<i>after the red zone</i>.
We'll talk more about the red zone later.)
</p>
<p>
Thank goodness for the parameter cap,
because a variadic function doesn't know how many
parameters were passed, so it would otherwise not know how many
input parameters to declare in its <code>alloc</code> instruction.
The parameter cap means that variadic functions <code>alloc</code>
eight input registers,
and typically the first thing they do is spill them onto the stack
so that they are contiguous with any parameters beyond 8 (if any).
Note that this spilling must be done very carefully to avoid
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/19/60162.aspx">
crashing if the corresponding register does not correspond
to an actual parameter but happens to be a NaT left
over from a failed speculative execution</a>.
(There is a special instruction for spilling without
taking a NaT consumption exception.)
</p>
<p>
If any parameter is smaller than 64 bits,
then the unused bits of the corresponding
register are garbage and should be ignored.
I didn't discuss floating point parameters
or aggregates.
You can
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/13/58199.aspx#62212">
read Thiago's comment</a> for a quick version,
or dig into the
<a HREF="http://www.intel.com/content/dam/www/public/us/en/documents/guides/itanium-software-runtime-architecture-guide.pdf">
<i>Itanium Software Conventions and
Runtime Architecture Guide</i></a> (Section 8.5: Parameter Passing) for gory details.
</p>
<p>
Okay, that's the conceptual model.
The actual implementation is not quite as I described it,
but the conceptual model is good enough for most debugging purposes.
Here are some of the implementation details which will come in handy
if you need to roll up your sleeves.
</p>
<p>
First of all, the processor does not actually distinguish between
input registers and local registers.
It only cares about the local region.
In other words, the parameters to the <code>alloc</code> instruction
are
</p>
<ul>
<li>Size of local region.</li>
<li>Number of output registers.</li>
<li>Number of rotating registers.</li>
<li>Register to receive previous function state.</li>
</ul>
<p>
When the called function established its register frame, the processor
just takes all the caller's output registers (even the ones that aren't
actually relevant to the function call) and slides them down
to <var>r32</var>.
It is the compiler's responsibility to ensure that the code
passes the correct number of parameters.
Therefore, our diagram of the function call process would more accurately
go like this:
The caller's register frame looks like this before the call:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=4 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=5>local region</td>
<td COLSPAN=5 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=3>input</td>
<td COLSPAN=2>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
<td STYLE="width: 2em"><var>r41</var></td>
</tr>
<tr>
<td>0</td>
<td>A</td>
<td>&hellip;</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>X&#x2081;</td>
<td>X&#x2082;</td>
<td>X&#x2083;</td>
</tr>
</table>
<p>
where the X values are whatever garbage values happen to be left
over from previous computations, possibly even NaT.
</p>
<p>
When the called function sets up its register frame
(before storing the previous register frame),
it gets this:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=5 ROWSPAN=2>static</td>
<td ROWSPAN=5 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=6>local region</td>
<td COLSPAN=3 ROWSPAN=2>output</td>
</tr>
<tr>
<td COLSPAN=2>input</td>
<td COLSPAN=4>local</td>
</tr>
<tr>
<td STYLE="width: 2em"><var>r0</var></td>
<td STYLE="width: 2em"><var>r1</var></td>
<td STYLE="width: 2em">&hellip;</td>
<td STYLE="width: 2em"><var>r30</var></td>
<td STYLE="width: 2em"><var>r31</var></td>
<td STYLE="width: 2em"><var>r32</var></td>
<td STYLE="width: 2em"><var>r33</var></td>
<td STYLE="width: 2em"><var>r34</var></td>
<td STYLE="width: 2em"><var>r35</var></td>
<td STYLE="width: 2em"><var>r36</var></td>
<td STYLE="width: 2em"><var>r37</var></td>
<td STYLE="width: 2em"><var>r38</var></td>
<td STYLE="width: 2em"><var>r39</var></td>
<td STYLE="width: 2em"><var>r40</var></td>
</tr>
<tr>
<td>0</td>
<td>A</td>
<td>&hellip;</td>
<td>F</td>
<td>G</td>
<td>M</td>
<td>N</td>
<td>X&#x2081;</td>
<td>X&#x2082;</td>
<td>X&#x2083;</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td COLSPAN=5>unchanged</td>
<td COLSPAN=2>moved</td>
<td COLSPAN=7>uninitialized</td>
</tr>
</table>
<p>
The processor took all the output registers from the caller
and slid them down to <var>r32</var> through <var>r36</var>.
</p>
<p>
Of course, the called function shouldn't try to read from
any registers beyond
<var>r33</var>,
if it knows what's good for it,
because those registers contain nothing of value and may indeed be
poisoned by a NaT.
</p>
<p>
This little implementation detail has no practical consequences
because those registers were uninitialized in the conceptual model anyway.
But it does mean that when you disassemble the <code>alloc</code>
instruction,
you'll see that the distinction between input registers and local
registers has been lost, and that both sets of registers are reported
as input registers.
In other words, an instruction written as
</p>
<pre>
alloc r34 = ar.pfs, 2, 4, 3, 0
</pre>
<p>
disassembles as
</p>
<pre>
alloc r34 = ar.pfs, 6, 0, 3, 0
</pre>
<p>
The disassembler doesn't know how many of the six registers in the input
region are input registers and how many are local,
so it just treats them all as input registers.
</p>
<p>
That explains some of the undefined registers,
but what about those question marks?
To solve this riddle, we need to answer a different question first:
"Where is this magic place that the caller's
local region gets saved to and restored from?"
</p>
<p>
This is where the infamous Itanium
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2005/04/21/410397.aspx">
second stack</a>
comes into play.
</p>
<p>
There are two stacks on Itanium.
One is indexed by the <var>sp</var> register and is what
one generally means when one says <i>the stack</i>.
The other stack is indexed by the <var>bsp</var> register
(<i>backing store pointer</i>),
and it is the magic place where these "registers from long ago"
are saved.
The <var>bsp</var> register grows <i>upward</i> in memory
(toward higher addresses),
opposite from the <var>sp</var> which grows downward (toward
lower addresses).
Windows allocates the two stacks right next to each other,
Here's
<a HREF="http://blogs.msdn.com/b/slavao/archive/2005/03/19/399117.aspx">
an artistic impression by Slava Oks</a>.
Bear in mind that Slava drew the diagram upside-down
(low addresses at the top, high addresses at the bottom).
The <var>bsp</var> grows toward toward higher addresses,
but in Slava's diagram, that direction is downward.
</p>
<p>
One curious implementation detail is that the two stacks
abut each other without a gap.
I'm told that the kernel team considered putting a no-access
page between the two stacks,
so that a runaway memory copy into the stack
would encounter an access violation before it reached the backing store.
For whatever reason, they didn't bother.
</p>
<p>
Now, the processor is sneaky and doesn't actually push the values
onto the backing store immediately.
Instead, the processor rotates them into high-numbered unused registers
(all the registers beyond the last output register),
and only when it runs out of space there does it spill them
into the backing store.
When the function returns, the rotation is undone, and the values
squirreled away into the high-numbered unused registers magically
reappear in the caller's local region.
</p>
<p>
Each time a function is called, the registers rotate to the left,
and when a function returns, the registers rotate to the right.
As a result, the local regions of functions in the call stack
can be found among the off-limits registers, up until we reach
the last spill point.
</p>
<p>
Suppose the call stack looks like this (most recent function at the top):
</p>
<pre>
a() -- current function
b()
c()
d()
e()
f()
g()
</pre>
<p>
If we zoom out, we can see all those local regions.
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td VALIGN=bottom ROWSPAN=2>static</td>
<td ROWSPAN=3 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=2>a</td>
<td ROWSPAN=2>open</td>
<td>g</td>
<td>f</td>
<td>e</td>
<td>d</td>
<td>c</td>
<td>b</td>
</tr>
<tr>
<td>LR</td>
<td>O</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
</tr>
<tr>
<td BGCOLOR=#ffbbff>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;&bull;</td>
<td>&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#FFBBBB>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#FFFF99>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#ACF3FD>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#DEB19E>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#A8A8FF>&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#A5D3CA>&bull;&bull;&bull;&bull;&bull;&bull;</td>
</tr>
</table>
<p>
Why don't we see any output registers for any functions other than the current
one?
You know why: Because at each function call, the caller's output registers
become the called function's input registers.
If you really wanted to draw the output registers, you could do it like this,
where each function's input registers is shared with the caller's
output registers.
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td VALIGN=bottom ROWSPAN=2>static</td>
<td ROWSPAN=5 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=3>a</td>
<td ROWSPAN=2>open</td>
<td COLSPAN=3>g</td>
<td STYLE="border-bottom: solid transparent 1px"></td>
<td COLSPAN=3>e</td>
<td STYLE="border-bottom: solid transparent 1px"></td>
<td COLSPAN=3>c</td>
<td STYLE="border-bottom: solid transparent 1px"></td>
</tr>
<tr>
<td>I</td>
<td>L</td>
<td>O</td>
<p>    <!-- open -->
<td>I</td>
<td>L</td>
<td>O</td>
<td STYLE="border-top: solid transparent 1px"></td>
<td>I</td>
<td>L</td>
<td>O</td>
<td STYLE="border-top: solid transparent 1px"></td>
<td>I</td>
<td>L</td>
<td>O</td>
<td STYLE="border-top: solid transparent 1px"></td>
</tr>
<tr>
<td BGCOLOR=#ffbbff>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;&bull;</td>
<td>&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#FFBBBB>&bull;&bull;</td>
<td BGCOLOR=#FFBBBB>&bull;&bull;&bull;</td>
<td BGCOLOR=#FFFF99>&bull;&bull;</td>
<td BGCOLOR=#FFFF99>&bull;&bull;&bull;</td>
<td BGCOLOR=#ACF3FD>&bull;&bull;&bull;</td>
<td BGCOLOR=#ACF3FD>&bull;&bull;&bull;</td>
<td BGCOLOR=#DEB19E>&bull;&bull;&bull;</td>
<td BGCOLOR=#DEB19E>&bull;&bull;&bull;</td>
<td BGCOLOR=#A8A8FF>&bull;&bull;</td>
<td BGCOLOR=#A8A8FF>&bull;&bull;</td>
<td BGCOLOR=#A5D3CA>&bull;&bull;&bull;</td>
<td BGCOLOR=#A5D3CA>&bull;&bull;&bull;</td>
</tr>
<tr>
<td ROWSPAN=2></td>
<td>O</td>
<td ROWSPAN=2 COLSPAN=5></td>
<td>I</td>
<td>L</td>
<td>O</td>
<td STYLE="border-bottom: solid transparent 1px"></td>
<td>I</td>
<td>L</td>
<td>O</td>
<td STYLE="border-bottom: solid transparent 1px"></td>
<td>I</td>
<td>L</td>
</tr>
<tr>
<td>b</td>
<td COLSPAN=3>f</td>
<td STYLE="border-top: solid transparent 1px"></td>
<td COLSPAN=3>d</td>
<td STYLE="border-top: solid transparent 1px"></td>
<td COLSPAN=2>b</td>
</table>
<p>
But we won't bother drawing this exploded view any more.
</p>
<p>
Now,
if the function <code>a</code> calls another function <code>x</code>,
then all the registers rotate left, with <code>a</code>'s local
region wrapping around to the end of the list:
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td VALIGN=bottom ROWSPAN=2>static</td>
<td ROWSPAN=3 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=2>x</td>
<td ROWSPAN=2>open</td>
<td>g</td>
<td>f</td>
<td>e</td>
<td>d</td>
<td>c</td>
<td>b</td>
<td>a</td>
</tr>
<tr>
<td>LR</td>
<td>O</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
</tr>
<tr>
<td BGCOLOR=#ffbbff>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#E6DBFF>&bull;&bull;&bull;</td>
<td BGCOLOR=#E6DBFF>&bull;&bull;&bull;&bull;</td>
<td>&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#FFBBBB>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#FFFF99>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#ACF3FD>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#DEB19E>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#A8A8FF>&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#A5D3CA>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;&bull;&bull;&bull;</td>
</tr>
</table>
<p>
And when <code>x</code> returns, the registers rotate right,
bringing us back to
</p>
<table BORDER=1 BORDERCOLOR=black
       STYLE="border: solid 1px black;
              border-collapse: collapse; text-align: center">
<tr>
<td VALIGN=bottom ROWSPAN=2>static</td>
<td ROWSPAN=3 WIDTH=0 BGCOLOR=black></td>
<td COLSPAN=2>a</td>
<td ROWSPAN=2>open</td>
<td>g</td>
<td>f</td>
<td>e</td>
<td>d</td>
<td>c</td>
<td>b</td>
</tr>
<tr>
<td>LR</td>
<td>O</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
<td>LR</td>
</tr>
<tr>
<td BGCOLOR=#ffbbff>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#C0FF97>&bull;&bull;&bull;</td>
<td>&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#FFBBBB>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#FFFF99>&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#ACF3FD>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#DEB19E>&bull;&bull;&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#A8A8FF>&bull;&bull;&bull;&bull;</td>
<td BGCOLOR=#A5D3CA>&bull;&bull;&bull;&bull;&bull;&bull;</td>
</tr>
</table>
<p>
Note that the conceptual model doesn't care about this implementation
detail.
In theory, future versions of the
Itanium processor might have additional
"bonus registers" after <var>r127</var> which are programmatically
inaccessible
but which are used to expand the number of register frames that can be
held before needing to spill.
</p>
<p>
With this additional information, you now can see the contents of
those undefined registers on entry to a function:
They contain whatever garbage happened to be left over in the open
registers.
Similarly,
the contents of those undefined output registers
after the function returns to its caller are the
leftover values in the called function's local region.
</p>
<p>
You can also see the contents of the uninitialized output registers on return
from a function:
They contain whatever garbage happened to be left over in the
called function's input registers.
This behavior is actually documented by the processor,
so in theory somebody could invent a calling convention where
information is passed from a function back to its caller through
the input registers, say, for a language that supports functions
with multiple return values.
(In other words, the input registers are actually in/out registers.)
The Windows calling convention doesn't use this feature, however.
</p>
<p>
It so happens that
the debugger forces a full spill into the backing store when it gains
control.
This is useful, because groveling into the backing store
gives you a way to see the local regions of
any function on the stack.
</p>
<pre>
kd&gt; r
...
      r32 =      6fbffd21130 0        r33 =          1170065 0
      r34 =      6fbffd23700 0        r35 =                8 0
      r36 =      6fbffd21338 0        r37 =            20000 0
      r38 =             8000 0        r39 =             2000 0
      r40 =              800 0        r41 =              400 0
      r42 =              100 0        r43 =               80 0
      r44 =              200 0        r45 =            10000 0
      r46 =         7546fdf0 0        r47 = c000000000000693 0
      r48 =             5041 0        r49 =         75ab0000 0
      r50 =      6fbffd21130 0        r51 =          1170065 0
      r52 =      6fbfc79f770 0        r53 =         7546cbe0 0
kd> dq @bsp
000006fb`fc7a02e0  000006fb`ffd21130 00000000`01170065 // r32 and r33
000006fb`fc7a02f0  000006fb`ffd23700 00000000`00000008 // r34 and r35
000006fb`fc7a0300  000006fb`ffd21338 00000000`00020000 // r36 and r37
000006fb`fc7a0310  00000000`00008000 00000000`00002000 // r38 and r39
000006fb`fc7a0320  00000000`00000800 00000000`00000400 // r40 and r41
000006fb`fc7a0330  00000000`00000100 00000000`00000080 // r42 and r43
000006fb`fc7a0340  00000000`00000200 00000000`00010000 // r44 and r45
000006fb`fc7a0350  00000000`7546fdf0 c0000000`00000693 // r46 and r47
</pre>
<p>
But wait, ia64 integer registers are 65 bits wide, not 64.
The extra bit is the NaT bit.
Where did that go?
</p>
<p>
Whenever the <var>bsp</var> hits a 512-byte boundary
(<var>bsp</var> &amp; 0x1F8 == 0x1F8, or after 63 registers have been spilled),
the value spilled into the backing store is not a 64-bit register
but rather the accumulated NaT bits.
You are not normally interested in the NaT bits,
so the only practical consequence of this is that you have to remember to
skip an entry whenever you hit a 512-byte boundary.
</p>
<p>
Suppose we wanted to look at our caller's local region.
Here's the start of a sample function.
Don't worry about most of the instructions, just pay attention
to the <code>alloc</code> and the <code>mov ... = rp</code>.
</p>
<pre>
SAMPLE!.Sample:
       <b>alloc    r47 = ar.pfs, 013h, 00h, 04h, 00h</b>
       mov      r48 = pr
       addl     r31 = -2004312, gp
       adds     sp = -1072, sp ;;
       ld8.nta  r3 = [sp]
       <b>mov      r46 = rp</b>
       adds     r36 = 0208h, r32
       or       r49 = gp, r0 ;;
</pre>
<p>
Suppose you hit a breakpoint partway through this function,
and you want to know why the caller passed a strange value
for the first input parameter <var>r32</var>.
</p>
<p>
From reading the function prologue, you see that the return
address is kept in <var>r46</var>,
so you can disassemble there to see how your caller set up
its output parameters:
</p>
<pre>
kd> u @r46-20
SAMPLE!.Caller+2bd0:
       ld8      r47 = [r32]
       ld4      r46 = [r33]
       or       r45 = r35, r0
       nop.b    00h
       nop.b    00h
       br.call.sptk.many  rp = SAMPLE!.Sample
</pre>
<p>
(Notice the <code>nop</code> instructions which suggest that this is
unoptimized code.)
</p>
<p>
But we don't know which of those registers are the output registers
of the caller.
For that, we need to know the register frame of the caller.
We see from the <code>alloc</code> instruction that the
previous function state (<code>pfs</code>)
was saved in the <var>r47</var> register.
</p>
<pre>
kd> ?@r47
Evaluate expression: -4611686018427386221 = c0000000`00000693
</pre>
<p>
This value is not easy to parse.
The bottom seven bits record the total size of the caller's
register frame, which includes both the local region and the output
registers.
The size of the local region is kept in bits 7 through 13, which
is a bit tricky to extract by eye.
You take the third and fourth digits from the right,
double the value, and add one more if the second digit from the right
is 8 or higher.
This is easier to do than to explain:
</p>
<ul>
<li>The third- and fourth-to-last digits are <code>06</code> hex.</li>
<li>Double that, and you get 12 (decimal).</li>
<li>Since the second-to-last digit is 9, add one more.</li>
<li>Result: 13.</li>
</ul>
<p>
The previous function's local region has 13 registers.
Therefore, the previous function's output registers begin at
32 + 13 = 45.
(You can also see that the previous function had 0x13 = 19 registers
in its register frame,
and you can therefore infer that
it had 19 &minus; 13 = 6 output registers.)
</p>
<p>
Applying this information to the disassembly of the caller,
we see that the caller passed
</p>
<ul>
<li>first output register <var>r45</var> = <var>r35</var>.
    (Recall that the <var>r0</var> register is always zero,
    so or'ing it with another value just copies that other value.)</li>
<li>second output register <var>r46</var> = 4-byte value stored at [<var>r33</var>]</li>
<li>third output register <var>r47</var> = 8-byte value stored at [<var>r32</var>]</li>
</ul>
<p>
That first output register was a copy of the <var>r35</var> register.
We can grovel through the backing store to see what that value is.
</p>
<pre>
0:000&gt; dq @bsp-0n13*8 l4
000006fb`ffe906d8  00000000`4b1e9720 00000000`4b1ea2e8     // r32 and r33
000006fb`ffe906e8  00000000`0114a7c0 000006fb`fe728cac     // r34 and r35
</pre>
<p>
And now we have extracted the registers from our caller's local region.
Specifically, we see that the caller's
<var>r35</var> is
<code>000006fb`fe728cac</code>.
</p>
<p>
We can extend this technique to grovel even further back in the stack.
To do that, we need to obtain the <var>pfs</var> chain so we can see
the structure of the register frame for each function in the call stack.
</p>
<p>
From the disassembly above, we saw that the caller was kept in
<var>r46</var>.
To go back another level, we need to find that caller's caller.
We merely repeat the exercise, but with the caller.
Sometimes it can be hard to find the start of a function
(especially if you don't have symbols);
it can be easier to look for the <i>end</i> of the function instead!
Instead of looking for the <code>alloc</code> and
<code>mov ... = rp</code> instructions which save the previous function
state and return address,
we look for the
<code>mov ar.pfs = ...</code> and <code>mov rp = ...</code>
instructions which restore them.
</p>
<p>
Here's an example of a stack trace I had to reconstruct:
</p>
<pre>
0:000&gt; u
00000000`4b17e9d4       mov      <b>rp = r37</b>              // return address
00000000`4b17e9e4       mov.i    <b>ar.pfs = r38</b>          // restore pfs
00000000`4b17e9e8       br.ret.sptk.many  rp ;;        // return to caller
0:000&gt; dq @bsp
000006fb`ffe90758  000006fb`fe761cc0 000006fb`ffe8f860 // r32 and r33
000006fb`ffe90768  000006fb`ffe8fa70 00000000`00000104 // r34 and r35
000006fb`ffe90778  00000000`0114a7c0 <b>00000000`4b1b6890</b> // r36 and r37
000006fb`ffe90788  <b>c0000000`0000<u>05</u>0e</b> 00000000`00005001 // r38 and r39
</pre>
<p>
Double the <code>05</code> to get 10 (decimal),
and don't add one since the next digit (<code>0</code>) is less than 8.
The previous function therefore has 10 registers in its local region.
</p>
<p>
The current function's return address is kept in <var>r37</var>
and the <var>pfs</var> in <var>r38</var>.
I've highlighted them in the <var>bsp</var> dump.
</p>
<p>
Let's
disassemble at the return address and
dump that function's local variables,
thereby walking back one level in the call stack.
</p>
<pre>
0:000&gt; u 00000000`4b1b6890
...
00000000`4b1b6bd4       mov      <b>rp = r38</b> ;;           // return address
00000000`4b1b6be4       mov.i    <b>ar.pfs = r39</b>          // restore pfs
00000000`4b1b6be8       br.ret.sptk.many  rp ;;
// we calculated that the local region of the previous function is size 0xA
0:000&gt; dq @bsp-a*8 la
000006fb`ffe90708  000006fb`fe73bfc0 000006fb`fe73ff10     // r32 and r33
000006fb`ffe90718  00000000`00000000 000006fb`ffe8f850     // r34 and r35
000006fb`ffe90728  000006fb`ffe8f858 00000000`00000000     // r36 and r37
000006fb`ffe90738  <b>00000000`4b1e9350 c0000000`00000308</b>     // r38 and r39
000006fb`ffe90748  00000000`00009001 00000000`4b57e000     // r40 and r41
</pre>
<p>
By studying the value in the caller's <var>r39</var>,
we see that the caller's caller has 3 &times; 2 + 0 = 6 registers
in its local region.
And the caller's <var>r38</var> gives us the return address.
Let's walk back another frame in the call stack.
</p>
<pre>
0:000&gt; u 4b1e9350
...
00000000`4b1e9354       mov      <b>rp = r34</b>              // return address
00000000`4b1e9368       mov.i    <b>ar.pfs = r35</b>          // restore pfs
00000000`4b1e9378       br.ret.sptk.many  rp ;;
0:000&gt; dq @bsp-a*8-6*8 l6
000006fb`ffe906d8  00000000`0114a7c0 000006fb`fe728cac     // r32 and r33
000006fb`ffe906e8  <b>00000000`4b1e9720 c0000000`00000389</b>     // r34 and r35
000006fb`ffe906f8  00000000`00009001 00000000`4b57e000     // r36 and r37
</pre>
<p>
This time, the return address is in <var>r34</var> and the
previous <var>pfs</var> is in <var>r35</var>.
This time, the caller's caller's caller has 3 &times; 2 + 1 = 7
registers in its local region.
</p>
<pre>
0:000&gt; u 4b1e9720
...
00000000`4b1e9784       mov      <b>rp = r35</b>             // return address
00000000`4b1e9788       adds     sp = 010h, sp ;;
00000000`4b1e9790       nop.m    00h
00000000`4b1e9794       mov      pr = r37, -2 ;;
00000000`4b1e9798       mov.i    <b>ar.pfs = r36</b>         // restore pfs
00000000`4b1e97a0       nop.m    00h
00000000`4b1e97a4       nop.f    00h
00000000`4b1e97a8       br.ret.sptk.many  rp ;;
0:000&gt; dq @bsp-a*8-6*8-7*8 l7
000006fb`ffe906a0  00000000`0114a7c0 00000000`00000000    // r32 and r33
000006fb`ffe906b0  00000000`0114a900 <b>00000000`4b19ba00</b>    // r34 and r35
000006fb`ffe906c0  <b>c0000000`0000058f</b> 00000000`00009001    // r36 and r37
000006fb`ffe906d0  00000000`4b57e000                      // r38
</pre>
<p>
This function also allocates 0x10 bytes from the stack,
so if you want to see its stack variables, you can dump the
values at <var>sp + 0x10</var> for length 0x10.
The <code>+ 0x10</code> is to skip over the red zone.
</p>
<p>
Anyway, that's the way to reconstruct the call stack on an Itanium.
Repeat until bored.
</p>
<p>
Maybe you can spot the fast one I pulled when discussing how
the <code>alloc</code> instruction and <var>pfs</var> register work.
More details
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20150730-00/?p=90791">
next time</a>, when we discuss leaf functions and the red zone.
</p>
<p>
<b>Bonus chapter</b>:
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20150730-01/?p=90781">
How does spilling actually work</a>?
</p>
<p>
&sup1;
When not preparing to call another function,
the output registers can be used for any purpose,
with the understanding that the values will not
be preserved across a function call.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (20)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1234666">
				<div id="div-comment-1234666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234666">
			July 29, 2015 at 7:51 am</a>		</div>

		<p>&gt;I&#39;m told that the kernel team considered putting a no-access page between the two stacks, so that a runaway memory copy into the stack would encounter an access violation before it reached the backing store. For whatever reason, they didn&#39;t bother. </p>
<p>Hum&#8230; Is it possible to declare, at the processor (or memory hardware) level, a memory range to be only accessible through register spilling and not user code? Something like register spilling being made at another ring level, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234656">
				<div id="div-comment-1234656" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234656">
			July 29, 2015 at 7:55 am</a>		</div>

		<p>Long post is loooong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234646">
				<div id="div-comment-1234646" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234646">
			July 29, 2015 at 8:04 am</a>		</div>

		<p>Medinoc&#39;s comment prompted a question of my own, actually:</p>
<p>Is the spilling to the stack done by the hardware, or does it trap into the OS? (I thought the SPARC did it by a trap, but after a quick search I don&#39;t see a definitive answer but it sounds like I may be wrong.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234636">
				<div id="div-comment-1234636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234636">
			July 29, 2015 at 9:53 am</a>		</div>

		<p>What happens if you have both integer and floating point arguments? Or if you do:</p>
<p>union mixed_t {</p>
<p>double d;</p>
<p>int64_t i;</p>
<p>};</p>
<p>extern mixed_t foo(mixed_t m);</p>
<p>mixed_t mixed = { .d = 1.0 };</p>
<p>foo(mixed);</p>
<div class="post">[<em>I already provided links that answer this question. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234626">
				<div id="div-comment-1234626" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234626">
			July 29, 2015 at 10:05 am</a>		</div>

		<p>Did having so many registers make context switching expensive?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kirbyfcf2 odd alt thread-odd thread-alt depth-1" id="comment-1234616">
				<div id="div-comment-1234616" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Kirby+FC' rel='external nofollow' class='url'>Kirby FC</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234616">
			July 29, 2015 at 10:08 am</a>		</div>

		<p>Since I know absolutely nothing the Itanium I find this series very interesting.</p>
<p>But, is it just me or does the Itanium seem way overly complicated?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234606">
				<div id="div-comment-1234606" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234606">
			July 29, 2015 at 10:12 am</a>		</div>

		<p>@Kirby</p>
<p>I suspect the complexity gains significant benefits elsewhere, which I hope we get to see as this series evolves.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234596">
				<div id="div-comment-1234596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234596">
			July 29, 2015 at 10:25 am</a>		</div>

		<p>@Evan: I don&#39;t really know anything about it, but doing register spilling by an OS trap sounds like it would be very expensive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234586">
				<div id="div-comment-1234586" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234586">
			July 29, 2015 at 11:16 am</a>		</div>

		<p>[the compiler may find that it needs to spill the parameter, thereby raising the STATUS_REG_NAT_CONSUMPTION exception. ]</p>
<p>That would have resulted in me filing a bug against the compiler because the undefined value clearly wasn&#39;t accessed. (For all the compiler knows it was passed a NaT rather than the caller passing two args, and the function clearly won&#39;t be using the 3rd arg).</p>
<p>It&#39;s a pretty simple fix &#8212; always use the NaT-clobbering write instruction to spill arguments.</p>
<div class="post">[<em>But that also masks a bug &#8211; what if the caller accidentally passed a NaT to you? You are silently clearing the NaT bit instead of raising an exception to say &quot;Whoa, I&#39;m operating with uninitialized data!&quot; Also, the special instructions for ignoring NaT are not as flexible as the normal memory instructions. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234576">
				<div id="div-comment-1234576" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234576">
			July 29, 2015 at 11:35 am</a>		</div>

		<p>@Bob: What do you think happens? For case 1, presumably the compiler stores the arguments as expected by the function. For the other case, if the union fits in a register, then it presumably is passed in the register and the receiving function accesses it as desired. Of course, having a bare union without the information required to know what&#39;s actually stored it is inherently dangerous, but how would that be different than how it&#39;s handled in other architectures?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234556">
				<div id="div-comment-1234556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234556">
			July 29, 2015 at 12:11 pm</a>		</div>

		<p>@Kirby It&#39;s mostly complicated for compiler writers, but actually a really simple ISA for hardware designers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234546">
				<div id="div-comment-1234546" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234546">
			July 29, 2015 at 2:09 pm</a>		</div>

		<p>You can now get 2 stacks on x86 with LLVM&#39;s SafeStack (enable with -fsanitize=safe-stack), coming soon to a compiler near you, with a buffer-stack stored behind a thread-local complementing the now register-backing-store at %esp/%rsp.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234536">
				<div id="div-comment-1234536" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234536">
			July 29, 2015 at 2:17 pm</a>		</div>

		<p>@Raymond: I mean what happens to the floating point registers with the alloc instruction i.e. how are they rotated or accounted for in the local variable counts?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234526">
				<div id="div-comment-1234526" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234526">
			July 29, 2015 at 2:44 pm</a>		</div>

		<p>@Jeffrey Bosboom</p>
<p>I&#39;m beginning to suspect, that only alloc&#39;ed registers are context switched.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234496">
				<div id="div-comment-1234496" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234496">
			July 29, 2015 at 4:14 pm</a>		</div>

		<p>@waleri That is correct. &nbsp;The floating-point registers are not part of the register window system; you (the compiler) have to manually save and restore them as necessary, just like you would integer registers on a more &quot;normal&quot; architecture. &nbsp;Most of the FP registers are call-clobbered, too (if I&#39;m reading this architecture manual correctly, only f2-f5 and f16-f31 are call-saved). &nbsp;However, you can move directly between floating-point and integer registers, so you can spill your FP registers into your &quot;local region&quot; of the integer regs and then the backing-store magic will do the rest.</p>
<p>The FP registers do have some magic of their own: Raymond will probably be getting to _rotating_ registers eventually.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234486">
				<div id="div-comment-1234486" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234486">
			July 29, 2015 at 5:20 pm</a>		</div>

		<p>@Evan:</p>
<p>SPARC handles register window overflow/underflow using a trap.</p>
<p>Even worse, on Sparc V7 (sun4, sun4c) the MMU did not enforce memory protections in kernel mode, so the register window overflow/underflow handler had to validate the spill/reload virtual addresses &quot;manually&quot;. This made window handling super expensive and negated any advantage it had. It also required a trap (&quot;ta 3&quot;) in order to do any kind of context-switch, including what would otherwise be 100% user-space thread switching on other architectures.</p>
<p>Sparc V9 cleans this up a little. &nbsp;The MMU is operational during the trap, and there is a little more hardware assist, so the handler can be really tight.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1234476">
				<div id="div-comment-1234476" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234476">
			July 29, 2015 at 5:41 pm</a>		</div>

		<p>@Evan &#8211; SPARC has register window overflow and underflow traps which need to be handled by the operating system</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1234456">
				<div id="div-comment-1234456" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1234456">
			July 30, 2015 at 7:45 am</a>		</div>

		<p>Wow, what a detailed, information-packed, and professionally-done post with great visuals. &nbsp;Like a college class, but free.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1222212">
				<div id="div-comment-1222212" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1222212">
			July 30, 2015 at 8:49 am</a>		</div>

		<p>Thanks saveddijon and david; I&#39;m happy to know that my memory isn&#39;t completely faulty at least. (Unlike Sparc v7&#39;s memory spilling! *ba bum ksshhh*!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1196981">
				<div id="div-comment-1196981" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Denis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150729-00/?p=90801#comment-1196981">
			August 3, 2015 at 6:39 am</a>		</div>

		<p>Wow, that calling mechanism looks just about right for a continuation-passing style compiler! Is there a very efficient implementation of Scheme on Itanium?</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

