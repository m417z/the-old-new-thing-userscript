<html>
<head>
<title>Stupid command-line trick: Counting the number of lines in stdin</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Stupid command-line trick: Counting the number of lines in stdin</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 25, 2011 / year-entry #205</td></tr>
<tr><td><b>Tags:</b></td><td>code;tipssupport</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>42</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">On unix, you can use wc -l to count the number of lines in stdin. Windows doesn't come with wc, but there's a sneaky way to count the number of lines anyway: some-command-that-generates-output | find /c /v "" It is a special quirk of the find command that the null string is treated as never...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
On unix, you can use <code>wc -l</code> to count the number of lines
in stdin.
Windows doesn't come with <code>wc</code>,
but there's a sneaky way to count the number of lines anyway:
</p>
<pre>
some-command-that-generates-output | find /c /v ""
</pre>
<p>
It is a special quirk of the <code>find</code> command
that the null string is treated as never matching.
The <code>/v</code> flag reverses the sense of the test,
so now it matches everything.
And the <code>/c</code> flag returns the count.
</p>
<p>
It's pretty convoluted, but it does work.
</p>
<p>
(Remember, I provide the occasional tip on
batch file programming as a public service to those forced to endure it,
not as an endorsement of batch file programming.)
</p>
<p>
Now come da history:
Why does the <code>find</code> command say that a null string matches
nothing?
Mathematically, the null string is a substring of every string,
so it should be that if you search for the null string, it matches
everything.
The reason dates back to the original MS-DOS
version of <code>find.exe</code>,
which according to the comments appears to have been written
in 1982.
And back then, pretty much all of MS-DOS was written in assembly
language.
(If you look at your old MS-DOS floppies, you'll find that
<code>find.exe</code> is under 7KB in size.)
Here is the relevant code, though I've done some editing to get rid of
distractions like DBCS support.
</p>
<pre>
        mov     dx,st_length            ;length of the string arg.
        dec     dx                      ;adjust for later use
        mov     di, line_buffer
lop:
        inc     dx
        mov     si,offset st_buffer     ;pointer to beg. of string argument

comp_next_char:
        lodsb
        cmp     al,byte ptr [di]
        jnz     no_match

        dec     dx
        jz      a_matchk                ; no chars left: a match!
        call    next_char               ; updates di
        jc      no_match                ; end of line reached
        jmp     comp_next_char          ; loop if chars left in arg.
</pre>
<p>
If you're rusty on your 8086 assembly language,
here's how it goes in pseudocode:
</p>
<pre>
 int dx = st_length - 1;
 char *di = line_buffer;
lop:
 dx++;
 char *si = st_buffer;
comp_next_char:
 char al = *si++;
 if (al != *di) goto no_match;
 if (--dx == 0) goto a_matchk;
 if (!next_char(&amp;di)) goto no_match;
 goto comp_next_char;
</pre>
<p>
In sort-of-C, the code looks like this:
</p>
<pre>
 int l = st_length - 1;
 char *line = line_buffer;

 l++;
 char *string = st_buffer;
 while (*string++ == *line &amp;&amp; --l &amp;&amp; next_char(&amp;line)) {} 
</pre>
<p>
The weird <code>-&nbsp;1</code> followed by <code>l++</code> is an artifact
of code that I deleted, which needed the decremented value.
If you prefer, you can look at the code this way:
</p>
<pre>
 int l = st_length;
 char *line = line_buffer;
 char *string = st_buffer;
 while (*string++ == *line &amp;&amp; --l &amp;&amp; next_char(&amp;line)) {} 
</pre>
<p>
Notice that if the string length is zero, there is an integer
underflow, and we end up reading off the end of the buffers.
The comparison loop does stop, because we eventually
hit bytes that don't match.
(No virtual memory here, so there is no page fault when you
run off the end of a buffer; you just keep going and reading
from other parts of your data segment.)
</p>
<p>
In other words, due to an integer underflow bug, a string of length zero
was treated as if it were a string of length 65536, which doesn't
match anywhere in the file.
</p>
<p>
This bug couldn't be fixed,
because by the time you got around to
trying, there were already people who discovered this behavior
and wrote batch files that relied on it.
The bug became a feature.
</p>
<p>
The integer underflow was fixed, but the code is careful 
to treat null strings as never matching, in order to preserve
existing behavior.</p>
<p>
<b>Exercise</b>: Why is the loop label called <code>lop</code>
instead of <code>loop</code>?</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-931943">
				<div id="div-comment-931943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Martin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-931943">
			August 25, 2011 at 7:05 am</a>		</div>

		<p>I believe the loop label has to be called &quot;lop&quot; because &quot;loop&quot; is an x86 assembly instruction (it decrements ecx and jumps to a label if ecx is not zero).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-931973">
				<div id="div-comment-931973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-931973">
			August 25, 2011 at 7:22 am</a>		</div>

		<p>Martin beat me to it. &nbsp;Not knowing x86 asm my first impulse is to say &quot;loop&quot; is a keyword reserved by the assembler and thus unusable as a label.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-931983">
				<div id="div-comment-931983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-931983">
			August 25, 2011 at 7:23 am</a>		</div>

		<p>(So if batch files are to be avoided, what&#39;s the better option? PowerShell maybe?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-931993">
				<div id="div-comment-931993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-931993">
			August 25, 2011 at 7:32 am</a>		</div>

		<p>Just about anything is a better option. PowerShell is a great option.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932003">
				<div id="div-comment-932003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932003">
			August 25, 2011 at 7:34 am</a>		</div>

		<p>Looking at the ChangeLog for GNU Textutils, it looks like the original wc program dates back to September 1991.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932013">
				<div id="div-comment-932013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henning Makholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932013">
			August 25, 2011 at 7:53 am</a>		</div>

		<p>But of course the wc in GNU Textutils is not the original one. The original was from (AT&amp;T) Unix somewhen back in the 1970s. The GNU project decided they needed to rewrite it all from scratch, to excape copyright restrictions that they found onerous.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932033">
				<div id="div-comment-932033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JustSomeGuy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932033">
			August 25, 2011 at 8:04 am</a>		</div>

		<p>And, yes, you should avoid batch files totally and instead use CMD files :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932043">
				<div id="div-comment-932043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932043">
			August 25, 2011 at 8:06 am</a>		</div>

		<p>@Henning: Ah, you&#39;re right. &nbsp;Looking at the manual pages for the first edition of Unix (<a rel="nofollow" target="_new" href="http://cm.bell-labs.com/cm/cs/who/dmr/1stEdman.html" rel="nofollow">cm.bell-labs.com/&#8230;/1stEdman.html</a>), the original AT&amp;T wc was written no later than November 1971.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932063">
				<div id="div-comment-932063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932063">
			August 25, 2011 at 9:15 am</a>		</div>

		<p>Now that was fascinating. Useless, but fascinating.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932073">
				<div id="div-comment-932073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932073">
			August 25, 2011 at 9:40 am</a>		</div>

		<p>It&#39;s not useless.</p>
<p>I wanted to write (or download) an app to count my code lines.</p>
<p>:-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932083">
				<div id="div-comment-932083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932083">
			August 25, 2011 at 9:57 am</a>		</div>

		<p>Yes, but why are there find and findstr, with exclusively-excluded features? find supports UTF-16, while findstr doesn&#39;t, but does support RegExps.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932093">
				<div id="div-comment-932093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JJJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932093">
			August 25, 2011 at 10:30 am</a>		</div>

		<p>I&#39;m not immediately convinced that it&#39;s &quot;lop&quot; because &quot;loop&quot; is an instruction. &nbsp;The whole point of the trailing colon is to identify a label, so if you have &quot;loop:&quot;, then it&#39;s clearly a label and not an instruction. &nbsp;You&#39;d have to make all reserved words a special case in your parser instead of just picking up a token, seeing that there was a colon, and adding it to your list of labels.</p>
<p>In 1982 when memory was precious, I&#39;d think that a programmer wouldn&#39;t bother.</p>
<p>Even when you used it, like &quot;jmp loop&quot;, the 2nd token to jmp is a label or offset or whatever and I don&#39;t see why the parser would try to interpret it as an instruction. &nbsp;If the label exists, great. &nbsp;If not, an instruction certainly doesn&#39;t make sense there so stop parsing and return an error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932103">
				<div id="div-comment-932103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">kzinti</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932103">
			August 25, 2011 at 10:47 am</a>		</div>

		<p>Interpreting &quot;loop:&quot; as a label makes your parser more complex as you need to special case for it. Go write a parser and you will be convinced.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932183">
				<div id="div-comment-932183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JT</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932183">
			August 25, 2011 at 2:54 pm</a>		</div>

		<p>Thanks a million times over Raymond! &nbsp;For years, I&#39;ve used:</p>
<p>my-output-generating-command | find /c /v &quot;{wiggle fingers around on keyboard for good 20 chars or so}&quot; &nbsp;</p>
<p>Much the same effect, however now I know I don&#39;t have to come up with garbage text either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932023">
				<div id="div-comment-932023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JustSomeGuy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932023">
			August 25, 2011 at 8:02 am</a>		</div>

		<p>&quot;here&#39;s how it goes in pseudocode&quot;? &#8211; mate, when *I* went to school, pseudo-code was a little more English-looking than that. This looks like pseudo-code from the guys who wrote code first then built the design from that using their favourite text editor global search and replace commands :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932193">
				<div id="div-comment-932193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Feroze</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932193">
			August 25, 2011 at 3:02 pm</a>		</div>

		<p>loop is an MASM macro. That is why it cannot be used as a label target.</p>
<p>If you want to create a loop that executes some number of times within your program, use the loop instruction. Although the following two code sequences produce the same result, they are not the same:</p>
<p>; Code sequence using a run-time loop:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx, 10</p>
<p>AddLp: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; ax, [bx]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; bx, 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;AddLp</p>
<p>; Code sequence using an assembly-time loop:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;repeat &nbsp;10</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; ax, [bx]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; bx, 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;endm</p>
<p>From: <a rel="nofollow" target="_new" href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-9.html" rel="nofollow">http://www.arl.wustl.edu/&#8230;/CH08-9.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932213">
				<div id="div-comment-932213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932213">
			August 25, 2011 at 4:33 pm</a>		</div>

		<p>Feroze:</p>
<p>Actually, loop is an x86 instruction, not (necessarily) an assembler macro.</p>
<p>Though it&#39;s honestly a good idea never to use loop for actually looping, because it has compatibility baggage that requires it to be very slow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932223">
				<div id="div-comment-932223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932223">
			August 25, 2011 at 4:46 pm</a>		</div>

		<p>Great tip and very handy to have if you&#39;re working on someone else&#39;s computer.</p>
<p>I always find myself going to find the GNU coreutils for Windows not long after installing a new system. &nbsp;Tossing wc, du, tr, head, tail, and friends in my PATH always seems to make interacting with the command line on Windows more enjoyable :)</p>
<p><a rel="nofollow" target="_new" href="http://gnuwin32.sourceforge.net/packages/coreutils.htm" rel="nofollow">gnuwin32.sourceforge.net/&#8230;/coreutils.htm</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932113">
				<div id="div-comment-932113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932113">
			August 25, 2011 at 11:20 am</a>		</div>

		<p>@kzinti: That&#39;s probably true for a hand-coded parser (which I bet would be most/all parsers written pre-1982), but for a parser generated from a grammar-based parser generator like yacc or GNU bison, it&#39;s simpler to write the grammar without the special case. &nbsp;Something like this, maybe:</p>
<p>program := line*</p>
<p>line := [ t]* (intrinsic | label | instruction) &quot;n&quot;</p>
<p>intrinsic := &quot;.&quot; intrinsic_keyword intrinsic_operands?</p>
<p>label := label_name &quot;:&quot;</p>
<p>label_name := [A-Za-z0-9_]*</p>
<p>instruction := opcode instruction_operands?</p>
<p>opcode := &quot;loop&quot; | &quot;mov&quot; | &quot;add&quot; | (etc.)</p>
<p>This is a straightforward, unambiguous grammar (like JJJ suggested), but the resulting generated parser is more complex than the equivalent hand-coded parser would be.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-932233">
				<div id="div-comment-932233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932233">
			August 25, 2011 at 6:22 pm</a>		</div>

		<p>Regarding &quot;lop&quot;, I think it might also carry to meaning &quot;to lop one character from buffer at a time&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932133">
				<div id="div-comment-932133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932133">
			August 25, 2011 at 12:07 pm</a>		</div>

		<p>@Adam</p>
<p>I&#39;m mostly neutral on the larger issue, but you&#39;re forgetting that most parser generators (in particular, those that follow the Yacc lineage) have dedicated lexers. (This is even sort of true for some like ANTLR.) This means that that the assembler must commit *at lexing time* to what token &quot;loop&quot; becomes. If you have a dedicated token for each keyword and your keywords include instruction mnemonics (like LOOP), then your &#39;label&#39; production has to be &#39;label := IDENT COLON | LOOP COLON | MOV COLON | ADD COLON | &#8230;&#39;. (More likely you&#39;d split that up, but the point is you need an explicit list of keywords that you can use as a label somewhere.) That grammar is a bit more annoying, since that&#39;s a list you probably don&#39;t need otherwise. (I&#39;m assuming that the list of opcodes doesn&#39;t exactly correspond to the list of opcodes that you give.)</p>
<p>You could also lex &quot;loop&quot; and &quot;mov&quot; and other keywords like &quot;eax&quot; into an IDENT. This solves this problem, but makes it so that the grammar can&#39;t distinguish between tokens which are keywords and which aren&#39;t, so it can&#39;t enforce that the first token in, say, an &#39;instruction&#39; is in fact an OPCODE: you&#39;d need to do this separately. It&#39;s even possible that you could have two productions that you can only distinguish between in the action, and that is always quite obnoxious to deal with in a Yacc-like parser generator.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-932243">
				<div id="div-comment-932243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932243">
			August 25, 2011 at 8:03 pm</a>		</div>

		<p>&quot;Though it&#39;s honestly a good idea never to use loop for actually looping, because it has compatibility baggage that requires it to be very slow.&quot;</p>
<p>In particular, Windows 95 had a timing loop that used this instruction that overflowed on faster processors:</p>
<p><a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/192841" rel="nofollow">support.microsoft.com/&#8230;/192841</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932163">
				<div id="div-comment-932163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Greg D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932163">
			August 25, 2011 at 1:59 pm</a>		</div>

		<p>@AsmGuru62</p>
<p>If you want to count the lines in a file from the command prompt, you can search a certain popular Q&amp;A site named after a programming error condition to discover a powershell one-liner that will do it for you. &nbsp;:)</p>
<p>Duplicated here for ease of copying:</p>
<p>PS C:Path&gt; (dir -include *.cs,*.xaml -recurse | select-string .).Count</p>
<p>8396</p>
<p>PS C:Path&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932253">
				<div id="div-comment-932253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">caf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932253">
			August 25, 2011 at 9:33 pm</a>		</div>

		<p>The source code for <code>wc</code> from Unix V5:</p>
<p><a rel="nofollow" target="_new" href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V5/usr/source/s2/wc.c" rel="nofollow">minnie.tuhs.org/&#8230;/utree.pl</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932173">
				<div id="div-comment-932173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jachymko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932173">
			August 25, 2011 at 2:50 pm</a>		</div>

		<p>Greg D: </p>
<p>(ls -rec -inc *.cs,*.xaml | cat).count</p>
<p>or just</p>
<p>(cat *.cs).count</p>
<p>if no recursion needed</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932263">
				<div id="div-comment-932263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932263">
			August 25, 2011 at 10:46 pm</a>		</div>

		<p>caf: Ah, the good ol&#39; days: back when men were men, Unix utilities did one thing and did it well, ints were 16 bits, and it was safe to use gets!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932283">
				<div id="div-comment-932283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932283">
			August 25, 2011 at 11:31 pm</a>		</div>

		<p>It doesn&#39;t matter if loop is a macro, instruction, or whatever. And an assembly parser is trivial to write.</p>
<p>Every line consists of up to 4 things (all optional). A label, an instruction/pseudo-instruction, operands (requires instruction to precede it), and comments. The label begins a line. If there is no label, then the line must start with whitespace. Operands cannot exist without instructions, and there&#39;s a delimiter to indicate comments.</p>
<p>Some assemblers are fussy enough that a comment cannot start on the first column (symbol/label). And most assemblers ignore &quot;:&quot; ending a label since whitespace must separate the label from the next thing (instruction or comment).</p>
<p>Quite simple, really.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932293">
				<div id="div-comment-932293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ThomasX</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932293">
			August 26, 2011 at 1:34 am</a>		</div>

		<p>Nitpickers corner: &quot;&quot; is not the null string. It&#39;s called the empty string.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-932303">
				<div id="div-comment-932303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932303">
			August 26, 2011 at 3:17 am</a>		</div>

		<p>@ThomasX: Except when talking about null terminated string, &quot; &quot; is not different to &quot;&quot; . (Remember, you just pass the pointer to start of string.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932313">
				<div id="div-comment-932313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932313">
			August 26, 2011 at 3:18 am</a>		</div>

		<p>Instead of the useless slow loop instruction (/macro?), use:</p>
<p>dec cx</p>
<p>jnz lop</p>
<p>@ThomasX: NULL != Null string</p>
<div class="post">[<i>Not sure what you mean by &quot;useless slow&quot;. The loop instruction was faster on an 8086 (by five clocks) than the dec/jnz equivalent. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1" id="comment-932323">
				<div id="div-comment-932323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932323">
			August 26, 2011 at 3:19 am</a>		</div>

		<p>Oops, mixed a few things up. Null string is pointer to 0.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932333">
				<div id="div-comment-932333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932333">
			August 26, 2011 at 5:47 am</a>		</div>

		<p>The reason the Loop instruction performs so badly on modern processors is because one of the operations required is not like any other&#8230; any form of decrement on a general purpose register other than the one generated by loop will update the flags register.</p>
<p>So regular decrementing is prioritized such that there is a specific micro-operation dedicated to it, while the loop instruction generates many micro-operations.. save the flags.. decrement.. restore the flags..</p>
<p>Such is life in a world where most of the instruction set is just something to be emulated by the instruction decoder, rather than something the execution units speaks natively.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932363">
				<div id="div-comment-932363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mmmh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932363">
			August 26, 2011 at 7:26 am</a>		</div>

		<p>@Joseph Koss</p>
<p>True, but strangely loop was already slower than a dec cx/jnz pair (or whatever is faster) on the 486.. which was still a very &quot;CISCy&quot; cpu.</p>
<p>I think it&#39;s also a vicious cycle of compilers not using loop, leading to the cpu having a slower loop, leading to even less compilers using it etc. etc.</p>
<p>This also applies to ENTER, LEAVE and other instruction meant more for human usage than compiler usage.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932413">
				<div id="div-comment-932413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932413">
			August 26, 2011 at 8:03 am</a>		</div>

		<p>@cheong00: If you&#39;re going to be nit-picking, then &quot; &quot; <em>is</em> different from &quot;&quot; (assuming that the empty string is what you meant by &quot;&quot; ). &nbsp;&quot; &quot; is a two-character array (const char[2]) consisting of two NUL bytes, while &quot;&quot; is a one-character array (const char[1]) consisting of one NUL byte. &nbsp;They both decay into pointers that would both be interpreted as the empty string, but sizeof(&quot; &quot;) != sizeof(&quot;&quot;).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932503">
				<div id="div-comment-932503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932503">
			August 26, 2011 at 9:43 am</a>		</div>

		<p>I measured the LOOP vs. SUB R32,1/JNZ &#8211; LOOP slower about 15% on average on modern CPUs.</p>
<p>So, IMO, it is not VERY SLOW &#8211; just a tad slower.</p>
<p>:-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932523">
				<div id="div-comment-932523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932523">
			August 26, 2011 at 11:23 am</a>		</div>

		<p>@AsmGuru:</p>
<p>Do a real test that measures the pairing opportunities. We are talking about 3 cycles of latency for dec/sub on core2/phenom which is enough to sneak in 6+ micro-ops (max of 6 on phenom because of limits on instruction retirement), and thats just between just the dec/sub and the jnz.</p>
<p>Never time instructions in isolation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932543">
				<div id="div-comment-932543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932543">
			August 26, 2011 at 11:55 am</a>		</div>

		<p>I&#39;m glad somebody has finally given me a use for FIND! Ever since I discovered FINDSTR, I have always wondered why FIND was still around. Now I know.</p>
<p>For optimization purposes, I&#39;ve discovered that the spaces before and after the switches are unnecessary and I can save a couple keystrokes by typing:</p>
<p>command | find/c /v&quot;&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-932583">
				<div id="div-comment-932583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932583">
			August 26, 2011 at 7:30 pm</a>		</div>

		<p>@Adam: if your string variable is being passed as char*, can you tell the difference from an empty string if the only content is &quot; &quot;? Remember, for null terminated strings the length is &quot;position of first null character encountered&quot; &#8211; 1.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932593">
				<div id="div-comment-932593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932593">
			August 26, 2011 at 10:37 pm</a>		</div>

		<p>Hmm, I didn&#39;t know about &quot;findstr&quot;. &nbsp;Windows now just needs xargs and sed. &nbsp;One of the first things I do with a fresh Windows installation is install UnxUtils.</p>
<p>loop is slower because it&#39;s not a RISC-like instruction, and is thus typically implemented in microcode instead of being hardwired. &nbsp;Same with instructions like xlat, enter, aad&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932613">
				<div id="div-comment-932613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932613">
			August 27, 2011 at 4:34 am</a>		</div>

		<p>char* isn&#39;t a string. It&#39;s a char pointer, which often happens to be used as a string because the c/c++ languages lack a native string type.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-932653">
				<div id="div-comment-932653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Justin G.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932653">
			August 28, 2011 at 4:04 am</a>		</div>

		<p>Another quirk of find is that it treats   as a line break. Here is an example of using find to count characters in a variable:</p>
<p>set str=can you count me [32 characters]</p>
<p>for /f %%a in (&#39;cmd /u /c set /p &quot;=%str:&quot;= %&quot;^&lt;nul^|find /v /c &quot;&quot;&#39;) do echo %%a</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-932683">
				<div id="div-comment-932683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110825-00/?p=9803#comment-932683">
			August 29, 2011 at 7:40 am</a>		</div>

		<p>@cheong00: Of course you can&#39;t tell the difference between &quot; &quot; and &quot;&quot; if all you have is a pointer, but as 640k said, char* isn&#39;t a string. &nbsp;There&#39;s no such thing as strings in C, just character arrays and character pointers. &nbsp;String literals are character arrays which happen to conveniently decay into pointers to their first characters.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

