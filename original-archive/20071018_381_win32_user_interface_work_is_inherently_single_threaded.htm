<html>
<head>
<title>Win32 user interface work is inherently single-threaded</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Win32 user interface work is inherently single-threaded</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 18, 2007 / year-entry #382</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>53</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">At the end of the day, there's a window handle in there. As we saw a few years ago, windows have thread affinity. You can push work to a background thread all you want, but once you send a message to the window (or do something that results in a message being sent to the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>At the end of the day, there's a window handle in there.</p>
<p> As we saw a few years ago, <a href="http://blogs.msdn.com/oldnewthing/archive/2005/10/13/480569.aspx"> windows have thread affinity</a>. You can push work to a background thread all you want, but once you send a message to the window (or do something that results in a message being sent to the window), you've given control to the UI thread. </p>
<p> Since the shell is all about user interfaces, <a href="http://support.microsoft.com/kb/287087"> the shell naturally expects that all threads that use it are single-threaded apartments</a>. Historically, however, you sort of got away with violating this rule <a href="http://blogs.msdn.com/oldnewthing/archive/2004/07/05/173226.aspx"> because older versions of the shell used their own custom fake version of COM</a> rather than using the official one in <code>OLE32.DLL</code>. As a result, programs that broke the rule on apartment threading often managed to get away with it because the shell assumed everybody was doing the right thing. (The Internet Explorer team <a href="http://blogs.msdn.com/tonyschr/archive/2006/12/11/interface-smuggling.aspx"> faced a similar problem with browser plug-ins</a>.) If you tried to use an object on the wrong thread, nobody would step in and try to stop you. Mind you, you might corrupt memory or crash, but that was your own fault. <a href="http://blogs.msdn.com/oldnewthing/archive/2005/10/21/483438.aspx"> Nobody said this was going to be easy</a>. </p>
<p> As the shell gradually switched to using real COM instead of fake COM, and as new features were added to the shell which relied more and more heavily on callers following the rules for apartment threading, programs that had skirted the rules started running into problems. If you got away with it on earlier versions of Windows and the problem was severe, there was a good chance the shell would have to do some re-architecting to allow your dodgy code to keep working. </p>
<p> A member of the COM team explained that COM assumes fundamentally that multi-threaded apartments are UI-free. No UI means no need to pump messages. If you initialize COM in MTA mode on a thread, you'd better not do any UI or your thread will stop responding to messages whenever COM needs to talk to another thread. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (53)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-560673">
				<div id="div-comment-560673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560673">
			October 18, 2007 at 12:03 pm</a>		</div>

		<p>Any chance of disrupting the blog post queue and telling us whose fault is this?</p>
<p><a href="http://blogs.zdnet.com/hardware/?p=829" target="_new" rel="nofollow">http://blogs.zdnet.com/hardware/?p=829</a></p>
<p>It looks like it has to do with shell&#8230;</p>
<div class="post">[<i>Suggestions for future topics go into the suggestion box when it reopens. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560683">
				<div id="div-comment-560683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.starkeith.net/coredump/' rel='external nofollow' class='url'>Keithius</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560683">
			October 18, 2007 at 12:04 pm</a>		</div>

		<p>Fascinating&#8230; I love this sort of insight. Thanks, Raymond!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560693">
				<div id="div-comment-560693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pink Duck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560693">
			October 18, 2007 at 12:13 pm</a>		</div>

		<p>Oh how I wish that conventions and standards were adhered to, forcing poor quality third-party code to improve instead of festering through OS rearchitecture.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560703">
				<div id="div-comment-560703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bahbar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560703">
			October 18, 2007 at 12:26 pm</a>		</div>

		<p>@Igor</p>
<p>I am not sure what you want more than what is already known: There is a memory leak in ole32.dll when handling files with Extended attributes, and it happens that this AV software puts EAs on every single file it traces&#8230; So you end up with your memory exhausted. That plus there already is a hotfix for it! what more do you need ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560713">
				<div id="div-comment-560713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bahbar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560713">
			October 18, 2007 at 12:30 pm</a>		</div>

		<p>Never mind, even though it is an OLE issue, it is in shell32.dll</p>
<p>Here is the link for the hotfix:</p>
<p><a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/942435/en-us" rel="nofollow">http://support.microsoft.com/kb/942435/en-us</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560723">
				<div id="div-comment-560723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sergey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560723">
			October 18, 2007 at 12:34 pm</a>		</div>

		<p>It&#8217;s good that such vital information is located in small KB article instead of MSDN chapter dedicated to COM.</p>
<p>Also it&#8217;s good that MSDN location referenced from this KB is &#8216;Location Cannot Be Found&#8217;.</p>
<p>Even better sounds &#8216;own custom fake version of COM&#8217;!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560733">
				<div id="div-comment-560733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560733">
			October 18, 2007 at 1:05 pm</a>		</div>

		<p>I agree with Pink Duck. &nbsp;You can only hack your way around so many compatibility issues before it starts to get unmanageable.</p>
<p>On the other hand, I guess we can&#8217;t leave those Lotus Notes 1.0 users out in the dark on Windows 2045.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560743">
				<div id="div-comment-560743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560743">
			October 18, 2007 at 1:15 pm</a>		</div>

		<p>@Bahbar:</p>
<p>What more do I want? I want to know how this kind of error got into the OS which &quot;was written from the ground up for stability, security and performance&quot;?</p>
<p>I would expect that in 2007 file operations are 100% reliable.</p>
<p>Sorry for the offtopic (which perhaps has something to do with Raymond&#8217;s post after all, who knows).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560763">
				<div id="div-comment-560763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560763">
			October 18, 2007 at 1:52 pm</a>		</div>

		<p>&quot;What more do I want? I want to know how this kind of error got into the OS which &quot;was written from the ground up for stability, security and performance&quot;?&quot;</p>
<p>If you think about it for a moment you&#8217;ll notice that a ground-up rewriting would in fact imply the creation of more bugs initially as it is new code.</p>
<p>Ignoring that fact, the coders are human and they make mistakes (just like a certain post bashing an MS product off-topic for no reason).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560813">
				<div id="div-comment-560813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560813">
			October 18, 2007 at 2:33 pm</a>		</div>

		<p>@Kemp:</p>
<p>Then don&#8217;t say you did it from the ground up if you didn&#8217;t. That could be considered false advertisement.</p>
<p>About coders are human, I know because I am a developer myself, but this kind of error should&#8217;ve never got past beta testing.</p>
<p>By the way I wasn&#8217;t bashing any product.</p>
<p>Raymond said: &#8220;Suggestions for future topics go into the suggestion box when it reopens.&#8221;</p>
<p>I know Raymnod, but I am afraid I won&#8217;t live long enough to submit it, much less read the response knowing how much suggestions you were getting :)</p>
<p>If your email worked I would have emailed the link to you instead of asking here. Sorry again for the offtopic.</p>
<div class="post">[<i>If you emailed me the link, I would&#8217;ve told you to post it to the suggestion box when it reopens. Please stop trying to find workarounds for the suggestion box. Wait your turn like everybody else. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560823">
				<div id="div-comment-560823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560823">
			October 18, 2007 at 2:44 pm</a>		</div>

		<p>&quot;Then don&#8217;t say you did it from the ground up if you didn&#8217;t. That could be considered false advertisement.&quot;</p>
<p>I didn&#8217;t say it was a lie. I said that if the claim was true then it should follow that there would be new and exciting bugs. As you pointed out, there are in fact new and exciting bugs =P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560843">
				<div id="div-comment-560843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bad design</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560843">
			October 18, 2007 at 3:17 pm</a>		</div>

		<p>If a system has critical flaws the design is to blame. A single bug should not be able to cause a critical flaw.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560853">
				<div id="div-comment-560853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Suggester</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560853">
			October 18, 2007 at 3:20 pm</a>		</div>

		<p>I suggest the suggestion box should open soon.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560863">
				<div id="div-comment-560863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560863">
			October 18, 2007 at 3:32 pm</a>		</div>

		<p>&quot;I suggest the suggestion box should open soon.&quot;</p>
<p>Your suggestion will be added to the back of the queue =P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560873">
				<div id="div-comment-560873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560873">
			October 18, 2007 at 3:42 pm</a>		</div>

		<p>Thursday, October 18, 2007 1:15 PM by Igor</p>
<p>I want to know how this kind of error got into the OS which &quot;was written from the ground up for stability, security and performance&quot;</p>
<p>We all know that&#8217;s a lie. Look at the very topic of this blog entry: Even the UI is singlethreaded.</p>
<p>Thursday, October 18, 2007 3:20 PM by Suggester</p>
<p>I suggest the suggestion box should open soon.</p>
<p>I second this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560883">
				<div id="div-comment-560883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560883">
			October 18, 2007 at 4:00 pm</a>		</div>

		<p>poochner: the freezing you&#8217;re seeing is unlikely to be a result of single-threaded UI work.</p>
<p>Raymond is only saying that each window is single-threaded, as it is in every other windowing environment. Every process obviously has its own thread(s), so every process&#8217; UI is independent of every other process.</p>
<p>Do not confuse this with Win16 where every task ran on the same thread, making the whole system single-threaded.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560893">
				<div id="div-comment-560893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.chaosinmotion.com/blog/' rel='external nofollow' class='url'>Bill Woody</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560893">
			October 18, 2007 at 4:06 pm</a>		</div>

		<p>I have yet to meet a UI framework where the UI components were not inherently single-threaded. The Java Swing library explicitly creates interfaces to handle passing messages to the UI thread or for executing code within the UI thread. Bad things happen on the Macintosh when you attempt to use multiple threads to manage components within the same application. And X Lib, as I recall (though it has been many years) is also intrinsically single-threaded as well. Hell, even Mac System 7&#8217;s cooperative threading model could still get you into trouble in the UI if you weren&#8217;t careful.</p>
<p>I think it stems from the model we use for UI programming, of an event pump which handles incoming messages and dispatches them accordingly. If you have multiple message pumps it&#8217;s just too easy to &quot;cross the streams&quot;.</p>
<p>Far easier to adopt the model that a single thread is responsible for all UI operations in a standard application, and use some system of message passing from background task threads to the UI thread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560903">
				<div id="div-comment-560903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560903">
			October 18, 2007 at 4:41 pm</a>		</div>

		<p>I think BeOS had a threaded UI. If they could do it, why not others?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560913">
				<div id="div-comment-560913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560913">
			October 18, 2007 at 4:45 pm</a>		</div>

		<p>Thursday, October 18, 2007 4:06 PM by Bill Woody</p>
<p>I have yet to meet a UI framework where the UI components were not inherently single-threaded.</p>
<p>I think that in 2007, and in the age of multicore and multicpu, this should finally change. As such I&#8217;m personally working on a multithreaded UI model. The gist of it is that each component can either be in one of two states, &quot;active&quot; or &quot;idle&quot;, and changes states when user input is received. A thread is created when the component goes active, and it&#8217;s destroyed once it goes idle again.</p>
<p>Sorry for going off topic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560923">
				<div id="div-comment-560923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">meh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560923">
			October 18, 2007 at 4:59 pm</a>		</div>

		<p>@Igor</p>
<p>If you&#8217;re a regular reader here you&#8217;ll know that this is the wrong place to discuss this stuff. At this point you&#8217;re just trolling.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560933">
				<div id="div-comment-560933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560933">
			October 18, 2007 at 5:51 pm</a>		</div>

		<p>I can think of many examples where allowing multi-threaded changes to the UI would result in race conditions and other nasty problems.</p>
<p>I can only think of a handful of cases where it would be both useful and sensible to allow it, and in all of those cases it still doesn&#8217;t seem worth it since it is not difficult to route all your messages to the UI thread.</p>
<p>When I first started UI programming I used to think it sucked that I couldn&#8217;t change/update UI elements from any thread but now that I&#8217;m more experienced I think that would&#8217;ve resulted in a big mess and I don&#8217;t see a lot of benefit from being able to do it. Seems like a solution looking for a problem, to me.</p>
<p>I do wish that COM and message queues in general were not so tied together, and also that they were completely separate from the windowing system, and also that COM only had one threading model &#8212; free threading, and let each component serialise calls or add usage restrictions as appropriate to it &#8212; but there&#8217;s nothing we can do about any of that now without a time machine (or an abstraction layer that hides it all from us) (or a completely new OS, but I quite like running all my existing apps).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560943">
				<div id="div-comment-560943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560943">
			October 18, 2007 at 5:52 pm</a>		</div>

		<p>UI frameworks have one UI thread because (drumroll&#8230;) they have to draw one image on one screen. Sure, you could let several threads draw, but have fun when your window frame repaints itself out of order and your buttons disappear.</p>
<p>You could add synchronization calls (which people forget to use) and have threads peek at each other&#8217;s data to find out what their draw order is, but it would just be a roundabout way of getting the same result that a single thread provides relatively cheap.</p>
<p>There&#8217;s a well-known paper by Lauer &amp; Needham on this subject, that everyone ought to read.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560953">
				<div id="div-comment-560953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560953">
			October 18, 2007 at 6:14 pm</a>		</div>

		<p>Leo Davidson: It&#8217;s your decision, race conditions or a hung UI. I personally would prefer the latter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560973">
				<div id="div-comment-560973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://alan@java.net' rel='external nofollow' class='url'>Alan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560973">
			October 18, 2007 at 6:23 pm</a>		</div>

		<p>With regard to the poster who commented about &quot;Java Swing library explicitly creates interfaces to handle passing messages to the UI thread or for executing code within the UI thread&quot;, the issue is all to do with locks. GUI events &quot;bubble down&quot; (for example, a keydown event is fired, followed by a keypress, followed by an input event, followed by any user actions) and each stage needs it&#8217;s own locks and moniters. It turned out (at least for Swing) that having proper thread safety in a GUI environment is an almost impossible task; unless you confine all GUI activities to one thread (as Swing has done)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560803">
				<div id="div-comment-560803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">poochner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560803">
			October 18, 2007 at 2:09 pm</a>		</div>

		<p>Perhaps this explains why my 2K* system gets &quot;stunned&quot; for a second or so at random intervals. &nbsp;It&#8217;s irritating because I notice it most when I&#8217;m playing StarCraft** but it happens at other times, as well.</p>
<p>*never got around to upgrading the OS. &nbsp;It has 2GB of mem, though.</p>
<p>**Ok, I&#8217;m just old-school.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560833">
				<div id="div-comment-560833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wolf Logan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560833">
			October 18, 2007 at 2:44 pm</a>		</div>

		<p>&quot;I would expect that in 2007 file operations are 100% reliable.&quot;</p>
<p>That sounds like a great idea. Any suggestions on how to achieve that lofty goal? Despite what you might believe, it&#8217;s not a &quot;solved problem&quot;. There are some *very good* theoretical solutions, *some* of which have been implemented, to varying degrees of accuracy and bug-free-ness. </p>
<p>Offhand, I can&#8217;t think of *any* operations in computation that are 100% reliable. Software is hard, people (and systems) are imperfect, bugs are (apparently) inevitable. We all do our best and get over it.</p>
<p>Well, most of us get over it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561023">
				<div id="div-comment-561023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561023">
			October 18, 2007 at 10:23 pm</a>		</div>

		<p>@meh:</p>
<p>And if you are regular here, then you know I don&#8217;t give a damn about anonymous poster&#8217;s opinions. If you have a name use it to support what you say with it. Otherwise either quit complaining or get lost.</p>
<p>&#8220;they have to draw one image on one screen. Sure, you could let several threads draw, but have fun when your window frame repaints itself out of order and your buttons disappear.&#8221;</p>
<p>Argh&#8230;.</p>
<p>Why not let them draw each into their own screen and then use compositing to merge only parts that have changed based on UI element Z order?</p>
<p>I can&#8217;t believe I had to write that!</p>
<div class="post">[<i>If they are in different controls then z-order and clipping takes care of it. The problems you see are when multiple threads draw into the same object simultaneously. One thread draws a black line, and another draws a green rectangle, and the two overlap and the results are random. If you hunt around you can find Windows programs that already have this problem when they try to update UI from a background thread. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561043">
				<div id="div-comment-561043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561043">
			October 19, 2007 at 12:11 am</a>		</div>

		<p>Raymond, I know. I was saying that it would be possible to solve that and still have threaded UI.</p>
<div class="post">[<i>And people complain that Windows programming is too hard. I know, let&#8217;s fix that by making it even harder still! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561053">
				<div id="div-comment-561053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561053">
			October 19, 2007 at 12:52 am</a>		</div>

		<p>[ .. One thread draws a black line, and another draws a green rectangle, and the two overlap and the results are random. .. ]</p>
<p>You divide the screen area into rectangles that can&#8217;t overlap, and each a thread is created whenever a rectangle receives user input, that thread updates the visible state of the rectangle, processes the input, and then quits. Multithreaded UI minus the races.</p>
<div class="post">[<i>If it&#8217;s that easy, why do so many people mess it up? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561063">
				<div id="div-comment-561063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561063">
			October 19, 2007 at 1:17 am</a>		</div>

		<p>[If it&#8217;s that easy, why do so many people mess it up? -Raymond]</p>
<p>It &quot;isn&#8217;t that easy&quot;. Win32 user interface work is inherently singlethreaded. It would require implementing some impossible function that sorts out all the hundreds of window messages that win32 uses, and asynchronously dispatching them to the right hwnd.</p>
<p>[And people complain that Windows programming is too hard. I know, let&#8217;s fix that by making it even harder still! -Raymond]</p>
<p>The current USER32 implementation is not only hard to use, but susceptible to hung UIs. The multithreaded UI would be still decently hard to use, but would always be responsive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560963">
				<div id="div-comment-560963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560963">
			October 18, 2007 at 6:17 pm</a>		</div>

		<p>I personally would prefer the former **. I should learn to proof-read my posts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-560983">
				<div id="div-comment-560983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kemp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560983">
			October 18, 2007 at 6:24 pm</a>		</div>

		<p>&quot;It&#8217;s your decision, race conditions or a hung UI. I personally would prefer the former.&quot;</p>
<p>(Edit streamlined in)</p>
<p>You don&#8217;t *have* to hang your UI, you just need to follow basic principles of doing it right&#8230;</p>
<p>Additionally, a programming error causing a hung GUI is much easier to debug than one causing race conditions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-560993">
				<div id="div-comment-560993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-560993">
			October 18, 2007 at 6:34 pm</a>		</div>

		<p>&quot;You don&#8217;t *have* to hang your UI, you just need to follow basic principles of doing it right&#8230;&quot;</p>
<p>If you do it right, of course everything will work perfectly. Doing it right is doing it asynchronously, which (For synchronous APIs) usually requires firing up another thread anyway. Which is what I&#8217;m suggesting the UI do automatically. I&#8217;m trying to make it easier to do it correctly, which is the entire point of having an abtraction in the first place. To make it easy to avoid things like this: <a rel="nofollow" target="_new" href="http://blogs.technet.com/markrussinovich/archive/2005/08/28/the-case-of-the-intermittent-and-annoying-explorer-hangs.aspx" rel="nofollow">http://blogs.technet.com/markrussinovich/archive/2005/08/28/the-case-of-the-intermittent-and-annoying-explorer-hangs.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561073">
				<div id="div-comment-561073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Jones</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561073">
			October 19, 2007 at 1:55 am</a>		</div>

		<p>As a user what I like about multi-core processors is that even if one program is maxing out a core at 100% I still have another core available for other programs.</p>
<p>All the multiple thread UI people here seemdetermined to nix that, despite many viewing it as the single most important hardware innovation in the last five years.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-561083">
				<div id="div-comment-561083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561083">
			October 19, 2007 at 3:13 am</a>		</div>

		<p>&quot;Why not let them draw each into their own screen and then use compositing to merge only parts that have changed based on UI element Z order?&quot;</p>
<p>Erm, that&#8217;s such a great idea, that&#8217;s exactly how it already works! Simply replace the word &quot;screen&quot; with the phrase &quot;top-level window&quot; and you&#8217;re done.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561093">
				<div id="div-comment-561093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">The_Assimilator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561093">
			October 19, 2007 at 3:39 am</a>		</div>

		<p>@Igor &#8211; The BeOS UI may have been multithreaded, but it was also horribly ugly and un-customizable.</p>
<p>[If it&#8217;s that easy, why do so many people mess it up? -Raymond]</p>
<p>@Triangle &#8211; that was sarcasm.</p>
<p>For everyone complaining about single-threaded UIs &#8211; if multi-threaded UI design worked as well as you seem to think it would, most operating systems and programming languages would be using it. They aren&#8217;t, and I&#8217;m sure you can figure out why.</p>
<p>Back On Topic, I believe that the point that Raymond is making &#8211; once again &#8211; is that if you put in the time and effort to follow the rules, instead of using hacks and workarounds to get the job done quickly, you won&#8217;t have problems further down the line. The rules are there for a reason&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561103">
				<div id="div-comment-561103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gazpacho</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561103">
			October 19, 2007 at 4:42 am</a>		</div>

		<p>Great idea Triangle, except&#8230; nobody said the effect of an input event was limited to one screen tile.</p>
<p>Although compositing may yet be parallelized, I don&#8217;t see the same happening in the way events are handled.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561113">
				<div id="div-comment-561113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561113">
			October 19, 2007 at 9:40 am</a>		</div>

		<blockquote><p>
  &quot;I suggest the suggestion box should open soon.&quot;</p>
<p>  Your suggestion will be added to the back of the queue =P
</p></blockquote>
<p>The suggestion box will probably be closed again when it gets to the front of the queue!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561123">
				<div id="div-comment-561123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561123">
			October 19, 2007 at 10:32 am</a>		</div>

		<p>@The_Assimilator:</p>
<p>Those are the things that are fixed easily once you have more important things (like threading in this case) working.</p>
<p>Raymond, I know that people complain it is hard, but you shouldn&#8217;t make it easier by ruling out better and more efficient ways to do something just because some simpleton can&#8217;t get it quickly or at all.</p>
<p>I remember when I first faced Windows programming, numerous other programmers tried to scare me with messages, pumps, etc saying how hard Windows UI programming is.</p>
<p>I was already familiar with the messaging concept back from the good old Amiga days so I asked them &quot;What exactly is hard here?&quot; and started coding.</p>
<p>Truth is that you have a bunch of programmers with no previous experience in UI programming. They will <em>always</em> complain that it is hard, regardless of what you throw at them.</p>
<p>MFC and WTL were attempts at simplifying UI programming for the masses. If say WTL was at the OS UI core, and if the only way to write UI applications was through deriving from WTL classes, things would be vastly different now.</p>
<p>If you have some spare time, I recommend you to skim through a book &quot;Programming the Be Operating System&quot; by Dan Parks Sydow (ISBN 1-56592-467-3) if you manage to find a copy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561153">
				<div id="div-comment-561153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Good Point</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561153">
			October 19, 2007 at 11:14 am</a>		</div>

		<p>&quot;As a user what I like about multi-core processors is that even if one program is maxing out a core at 100% I still have another core available for other programs.</p>
<p>All the multiple thread UI people here seemdetermined to nix that, despite many viewing it as the single most important hardware innovation in the last five years.&quot;</p>
<p>Just smile and nod your head.</p>
<p>&quot;Oh Stephen you&#8217;re SO smart&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561173">
				<div id="div-comment-561173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Jones</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561173">
			October 19, 2007 at 11:35 am</a>		</div>

		<p>So you don&#8217;t mind Adobe announcing &quot;All your Cores are us&quot;.</p>
<p>Now when &nbsp;Acrobat Reader takes up 100% processor time I still play minesweeper. It&#8217;s a question of priorities.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561183">
				<div id="div-comment-561183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.echobit.net' rel='external nofollow' class='url'>Soren Dreijer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561183">
			October 19, 2007 at 11:44 am</a>		</div>

		<p>I wish you had written this post a month ago, Raymond.</p>
<p>I think using COM places a lot of responsibility on the developer and it&#8217;s really easy to mess up:</p>
<p><a rel="nofollow" target="_new" href="http://inside.echobit.net/archives/2007/09/27/mfc-and-com/" rel="nofollow">http://inside.echobit.net/archives/2007/09/27/mfc-and-com/</a></p>
<p>Granted, if you make an honest effort to understand how COM works under the hood, many mistakes could be avoided. I just keep finding my knowledge of COM lacking&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561253">
				<div id="div-comment-561253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">poochner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561253">
			October 19, 2007 at 2:29 pm</a>		</div>

		<p>I&#8217;ve never found UI programming all that difficult. &nbsp;That&#8217;s probably because I&#8217;ve been doing multi-threaded event-driven programming for more than 20 years. &nbsp;That wasn&#8217;t GUI programming, but it was data comm. &nbsp;The more things change, the more they stay the same. People get excited about 64-bit programming, but that&#8217;s nothing new at all. I worked on those in the mid-1980s. &nbsp;What&#8217;s new is availability. &nbsp;Does it take up an entire house, or sit beside your desk? &nbsp;Personally, I like the new environments.</p>
<p>I checked and StarCraft runs under Windows 95 or 98. &nbsp;It&#8217;s likely 16-bit. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561433">
				<div id="div-comment-561433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561433">
			October 20, 2007 at 2:47 pm</a>		</div>

		<p>So the answer is simple for a COM server, if you are going to have UI on that thread, initialize it as a STA, otherwise initialize it as a MTA, otherwise calls to that thread will hang because that thread is not pumping messages because it has no UI.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561603">
				<div id="div-comment-561603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561603">
			October 21, 2007 at 5:44 pm</a>		</div>

		<p>The people arguing for multi-threaded UI IMHO are trying to find solutions for problems that aren&#8217;t there.</p>
<p>When you draw UI, the commands are batched and put in a queue, and then drawn by the graphic cards, for example with OpenGL, in a different thread. &nbsp;There is only one graphic card, and it can only do &nbsp;one thing at a time.</p>
<p>Splitting the screen in quaters and updating each part in different thread is riduculous because</p>
<p>1) there is only one graphic card. &nbsp;remember?</p>
<p>2) who says the entire screen needs to be redrawn?</p>
<p>3) who says the bottleneck is the actual drawing, and that splitting it up on processors is the best thing to do?</p>
<p>4) who says the work required to draw each part of the screen is equal?</p>
<p>Having single threaded UI is a good thing that makes sense. &nbsp;It&#8217;s up to the apps to decide how to split the work on multiple-CPUs to make the best part of it. &nbsp;For example, photoshop can split all the image rendering onto multiple CPUs and then at the end make a single &#8216;bitblt&#8217; on screen. &nbsp;That &#8216;bitblt&#8217; isn&#8217;t the bottleneck! &nbsp;It may not even be using the CPU.</p>
<p>btw, about BeOS: IMHO this OS lives in the real of fantasy. &nbsp;We&#8217;re told the UI was &#8216;fully threaded&#8217;. &nbsp;Which everyone&#8217;s said that about their product. &nbsp;It doesn&#8217;t mean that it&#8217;s what you think it means. &nbsp;You&#8217;re fantasizing about what that means! &nbsp;Easy to do when no one knows for sure and it&#8217;s not around to disprove!</p>
<p>The drawing could have been all serialized in one thread, while each window could have have lived in its own thread. &nbsp;That&#8217;s the same thing as running multiple apps in any operating system. &nbsp;Saying the Windows UI is single-threaded means that the input events and the drawing is &nbsp;serialized for each process, it doesn&#8217;t mean that there are no thread in the OS!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561613">
				<div id="div-comment-561613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561613">
			October 21, 2007 at 6:55 pm</a>		</div>

		<p>ulric: I think you misunderstood something here; a multithreaded UI wouldn&#8217;t releave bottleneck, and yes it might actually exacerbate a few, but having a singlethreaded UI means that one unresponsive button can lock the entire system. And, if you&#8217;ve ever used Windows, you&#8217;ve experienced explorer randomly locking up for a few minutes, and I bet you&#8217;ve been pissed off by it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561633">
				<div id="div-comment-561633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561633">
			October 21, 2007 at 11:46 pm</a>		</div>

		<blockquote><p>
  singlethreaded UI means that one unresponsive button can lock the entire system.
</p></blockquote>
<p>In Win32 you can create windows in different threads, in fact each processes run in different threads already, and do not &quot;hang the entier system&quot;. This blog entry doesn&#8217;t say that Windows doesn&#8217;t support creating and managing windows in different threads, because it does, it describes explorer.exe how it interacts with COM.</p>
<p>I&#8217;ve responded to your suggestion of &#8216;dividing the screen in tiles&#8217;, it doesn&#8217;t prevent your &quot;hung button&quot; because it&#8217;s not waiting for the redraw code anyway.</p>
<p>From your other suggestion, I don&#8217;t think you want the OS to create threads on all messages just &#8216;in case&#8217; the app may do something that takes time, it&#8217;s expensive to create threads, and unnecessary for 99% of the cases. &nbsp;If you need this in your app, you can do it, only you know what&#8217;s appropriate and safe, what data structures are synchronized properly. &nbsp;Creating a thread on user action like mouse down at the toolkit level isn&#8217;t good because, beside being expensive, the input message returns before the work is done so you get synchronization issues that make programming even more complex. You&#8217;d easily end up with multiple threads running concurrently, stepping over each other, and race conditions. UI out of synch with what&#8217;s going on Only your own app can know what it needs.</p>
<blockquote><p>
  And, if you&#8217;ve ever used Windows, you&#8217;ve experienced explorer randomly locking up for a few minutes, and I bet you&#8217;ve been pissed off by it.
</p></blockquote>
<p>Absolutely, Windows Explorer sometimes partially locks up on network timeout on WAN &nbsp;&#8212; for example I&#8217;ve seen the task bar wait for a Run command (but in my experience other Explorer windows were not locking up in my case). &nbsp;This is entirely fixable in Explorer, it&#8217;s not a flaw inherent to the input UI messages and drawing being treated in one thread. &nbsp;For network access they should start a second thread and have a progress bar to tell us what the heck the system is doing when it&#8217;s taking long, and have a damn cancel button. &nbsp;Conversely notice as well the cases where in doesn&#8217;t happen. &nbsp;It&#8217;s definitely not totally single-thread. &nbsp;Try Finder on OS X to see how more multi-threaded Explorer is :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-561893">
				<div id="div-comment-561893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561893">
			October 22, 2007 at 5:34 pm</a>		</div>

		<blockquote><p>
  &gt; As a user what I like about multi-core processors is that even if one program is maxing out a core at 100% I still have another core available for other programs.
</p></blockquote>
<p>A lot of people have this view. However, they are completely wrong.</p>
<p>Your problem is that the OS thread scheduler is not doing what you want. It&#8217;s particularly bad in Windows, which uses a terrible scheme (boosting thread&#8217;s priority, both based on user input and pseudo-randomly, IIRC) &#8211; what you want is a decrease of the priority of CPU-eating threads, as implemented in basically every other OS, where 100% CPU usage is usually not noticeable from the UI (until you request something that does need lots of CPU cycles).</p>
<p>You can sort of get around this by manually decreasing the priority of the offending process (or thread, if you have the right tools). Ideally applications would automatically do this (IE did with the address autocompletion IIRC) but then you&#8217;d be at a disadvantage against the bad mannered guys, so it&#8217;d be better if it was a thread scheduler policy.</p>
<p>A nice feature would be throttling so even a thread which wants CPU continuously would run less than 100% of the time. There are some third party apps that fake this by pausing and unpausing threads at a fast rate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561963">
				<div id="div-comment-561963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561963">
			October 23, 2007 at 1:24 am</a>		</div>

		<p>Sunday, October 21, 2007 11:46 PM by ulric</p>
<p>I&#8217;ve responded to your suggestion of &#8216;dividing the screen in tiles&#8217;, it doesn&#8217;t prevent your &quot;hung button&quot; because it&#8217;s not waiting for the redraw code anyway.</p>
<p>You responded with four statements that don&#8217;t actually discredit my suggestion:</p>
<p>1) there is only one graphic card. &nbsp;remember?</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Scalable_Link_Interface" rel="nofollow">http://en.wikipedia.org/wiki/Scalable_Link_Interface</a></p>
<p>and, even your cheapest graphics card nowadays has at least 4-8 pixel fill pipelines</p>
<p>2) who says the entire screen needs to be redrawn?</p>
<p>Nobody.</p>
<p>3) who says the bottleneck is the actual drawing, and that splitting it up on processors is the best thing to do?</p>
<p>It probably isn&#8217;t.</p>
<p>4) who says the work required to draw each part of the screen is equal?</p>
<p>Nobody.</p>
<p>Of course a control that does alot of processing or a blocking operation will become unresponsive. And its busyness would be apparent in that it wasn&#8217;t responding. But the rest of the interface shouldn&#8217;t become unresponsive. As it stands, with Windows, it does.</p>
<p>&quot;In Win32 you can create windows in different threads, in fact each processes run in different threads already, and do not &#8216;hang the entier system&#8217;&quot;</p>
<p>If Explorer hangs, then the taskbar hangs, and, effectively, the system has hung.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-561973">
				<div id="div-comment-561973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561973">
			October 23, 2007 at 1:46 am</a>		</div>

		<blockquote><p>
  If Explorer hangs, then the taskbar hangs, and, effectively, the system has hung.
</p></blockquote>
<p>That&#8217;s a bug with explorer specifically, not with single-threaded user interfaces in general.</p>
<p>Here&#8217;s a question for you: in a multi-threaded UI, how would you handle key-up events being processed before key-down events?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-561983">
				<div id="div-comment-561983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Triangle</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-561983">
			October 23, 2007 at 1:55 am</a>		</div>

		<p>&#8220;Here&#8217;s a question for you: in a multi-threaded UI, how would you handle key-up events being processed before key-down events?&#8221;</p>
<p>The key down event is held pending until the control is ready to process it. I think this is the part most people here are misunderstanding: The multithreaded UI I&#8217;m suggesting is exactly like how Windows works now, except that a seperate message loop is maintained for each control instead of just for each window, and that the GetMessage(&amp;msg, &#8230;) ; TranslateMessage(&amp;msg, &#8230;); DispatchMessage(&amp;msg); in the message loop is done by the window manager instead of the thread that created the window.</p>
<div class=post>[<i>Not sure what the difference between a &#8220;control&#8221; and a &#8220;window&#8221; is here, or why you think every window has its own message loop. But I&#8217;m not interested in the answer either. If you want to argue about designing a multithreaded UI framework, please do it on your own blog. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-562273">
				<div id="div-comment-562273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-562273">
			October 23, 2007 at 4:07 pm</a>		</div>

		<p>Ulric said: &#8220;There is only one graphic card, and it can only do &nbsp;one thing at a time.&#8221;</p>
<p>That is a lame assumption on your part. There are systems with as much as 3 video cards. In DirectX 10.1 video cards will support context switching meaning they will be able to interact with more than one thread at once.</p>
<p>Ulric said: &#8220;btw, about BeOS: IMHO this OS lives in the real of fantasy&#8221;</p>
<p>I won&#8217;t comment this. I just suggest you to download a copy (it is free) and try it.</p>
<p>Ulric said: &#8220;Saying the Windows UI is single-threaded&#8221;</p>
<p>But it <em>is</em> single-threaded!</p>
<p>Insert a DVD and immediately double-click on My Computer icon and you will see it for yourself. First you will get Explorer window with an empty gray pane. Then the whole window goes white failing to repaint itself for several seconds. Even if your intent was to navigate to the DVD content it is annoying, not to mention if you needed to check something else on your HDD.</p>
<p>With a hardware this powerfull, non-responsive UI which fails to repaint is unforgiveable regardless of what you believe to be the cause.</p>
<p>In my opinion, current UI is flawed at least in the sense that it is polling applications for changes. We all know that polling is not efficient.</p>
<div class=post>[<i>But Notepad still works during that time. I think you&#8217;re confusing Windows with one specific Windows program. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-562353">
				<div id="div-comment-562353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071018-00/?p=24743#comment-562353">
			October 24, 2007 at 12:32 am</a>		</div>

		<p>Raymond said: &#8220;I think you&#8217;re confusing Windows with one specific Windows program.&#8221;</p>
<p>For roughly 90% of the users out there (for whom I was speaking because I personally know better) Explorer _is_ Windows.</p>
<p>That is why they are pissed with it so much. They don&#8217;t view it as a separate application, but rather as an integral part of the OS.</p>
<p>My point was that even if you replace Explorer completely (and frankly I haven&#8217;t seen such a replacement yet &#8212; note that in my book it would have to do without leaning on shell32.dll to be considered a replacement), you will most likely end up having same issues with UI as Exlporer does. My bet is that the problem is with window manager.</p>
<p>To me it is totally stupid to do it like this:</p>
<p>WM: do you have something to paint?</p>
<p>AP: no</p>
<p>WM: do you have something to paint?</p>
<p>AP: nope</p>
<p>WM: do you have something to paint?</p>
<p>AP: sigh, I already told you I don&#8217;t</p>
<p>WM: this window overlapped you, repaint</p>
<p>AP: but why, I haven&#8217;t changed anything?</p>
<p>Messaging and event driven programming is one thing, it is ok to get messages when something happens like when user presses a key &#8212; this is polling and it is bad. It just creates or at least increases the chances for hanging the UI redraw if the application isn&#8217;t written correctly.</p>
<div class="post">[<i>I think you&#8217;re basing your conclusions on an incorrect understanding of the Windows painting model. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

