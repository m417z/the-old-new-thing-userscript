<html>
<head>
<title>Why does the assignment operator in C# evaluate left to right instead of right to left?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why does the assignment operator in C# evaluate left to right instead of right to left?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 18, 2017 / year-entry #163</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>30</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Because that's what people expect, for certain values of "people".</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
When I noted some time ago that
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2014/08/14/10549885.aspx">
the compound assignment operator is guaranteed to evaluate its
left hand side before the right hand side</a>,
there was much commenting about why the language chose that model
instead of the more "obvious" evaluation order of right-then-left.
</p>
<p>
In other words,
instead of rewriting
<code>E1 += E2</code> as <code>E1 = E1 + E2</code>,
rewrite it as
</p>
<pre>
    temp = E2;
    E1 = E1 + temp;
</pre>
<p>
(Or as</p>
<pre>
    ((System.Func&lt;T2, T1&gt;)((e2) =&gt; E1 = E1 + e2))(E2)
</pre>
</p>
<p>if you want to keep it as a single statement.)
</p>
<p>
Thank goodness you can't overload the
<code>+=</code> operator,
because it would require that the
operator overload for <code>+=</code> <i>be declared backward</i>:
</p>
<pre>
operator+=(T1 y, T2 x)
{
 return x = x + y;
}
</pre>
<p>
in order to ensure that the right hand side is evaluated first.
(Because function parameters are evaluated left to right.)
</p>
<p>(We'll come back to the rewrite rules later.)
</p>
<p>
One reason for the existing rule is that it keeps the rules simple.
In C#, all expressions are evaluated left to right,
and they are combined according to associativity.
Changing the rules for assignment operators complicates
the rules, and complicated rules create confusion.
(See, for example,
pretty much every article I've written about Win32 programming
titled "<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2005/06/23/431876.aspx">Why does</a>...?")
</p>
<p>
In particular, for compound assignment, it means that
<code>E1 += E2</code> and <code>E1 = E1 + E2</code> are
<i>no longer equivalent</i> if <code>E1</code> and <code>E2</code>
have interacting side effects.
Collapsing <code>x = x + y</code> into <code>x += y</code> would
no longer be something you could do without having to think really
hard first.
Like hoisting closed-over variables,
this would create another case where something that at first appears
to be purely an issue of style turns into a correctness issue.
</p>
<p>
One argument for making a special rule is that
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20140814-00/?p=243#comment-1144583">
any code which relied on <code>E1</code> being evaluated before <code>E2</cODE>
is probably broken already and at best is working by sheer luck</a>.
After all, this is the rationale behind changing the variable lifetime
rules for
<a HREF="https://blogs.msdn.microsoft.com/ericlippert/2009/11/12/closing-over-the-loop-variable-considered-harmful/">
closures that involve the loop variable</a>.
</p>
<p>
But it's not as cut-and-dried that anybody who relied
on order of evaluation was "already broken".
</p>
<p>
Consider a byte code interpreter for a virtual
machine.
Let's say that the <code>Poke</code> opcode
is followed by a 16-bit unsigned integer
(the address to poke) and an 8-bit unsigned
integer (the value to poke).
</p>
<pre>
  // switch on opcode
  switch (NextUnsigned8())
  {
  ...
  case Opcode.PokeByte:
    memory[NextUnsigned16()] = NextUnsigned8();
    break;
  ...
  }
</pre>
<p>
The C# order of evaluation guarantees that the left
hand side is evaluated before the right hand side.
Therefore, the 16-bit unsigned integer is read
first,
and that value is used to determine which element
of the <code>memory</code> array is being assigned.
Then the 8-bit unsigned integer is read next,
and that value is stored into the array element.
</p>
<p>
Therefore, this code is perfectly well defined
and does what the author intended.
Changing the order of evaluation for the assignment
operator (and compound assignment operators)
would break this code.
</p>
<p>
You can't say that this code is "already broken"
because it's not.
It does exactly what it intended,
and it does it correctly,
and what it gets is guaranteed by the language standard.
</p>
<p>
Okay, you could have come up with something similar
for capturing the loop variable:
Some code which captures the loop variable and wants
to capture the shared variable.
So maybe it's not fair showing code which relies
on the feature correctly,
because one could argue that any such code is
contrived,
or at least too subtle for its own good.
</p>
<p>
But as it happens, most people
implicitly expect that everything is evaluated
left to right.
You can see
<a HREF="http://stackoverflow.com/questions/linked/949433">
many instances of this</a>
<a HREF="http://stackoverflow.com/questions/23990968/please-explain-the-output-of-following-c-code">
on StackOverflow</a>.
They don't actually verbalize this assumption,
but it is implicit in their attempt to explain
the situation.
</p>
<p>
The C# language tries to avoid undefined behavior,
so given that it must define a particular order of evaluation,
and given that everywhere else in the language,
left-to-right evaluation is used,
and given that
na&iuml;ve programmers expect left-to-right evaluation here too,
it makes sense that the evaluation order here also be left-to-right.
It may not be the best style, but it at least offers no surprises.
</p>
<p>
With the right-to-left rule, you get a different surprise:
</p>
<pre>
 x.value += Calculate();
 x[index] += Calculate();
</pre>
<p>
If <code>x</code> is <code>null</code>,
or if <code>index</code> is out of bounds,
the corresponding exception is not raised until after the
<code>Calculate</code> has occurred.
Some people may find this surprising.
</p>
<p>
Okay, so maybe can still salvage this by changing the rewrite rule
so that <code>E1</code> is still evaluated before <code>E2</code>,
but only to the extent where the value to be modified is identified
(an lvalue, in C terminology).
Then we evaluate <code>E2</code>, and only then do we combine it with
the value of <code>E1</code>.
In other words, the rewrite rule is
that <code>E1 += E2</code> becomes
</p>
<pre>
    System.CompoundAssignment.AddInPlace(ref T1 E1, T2 E2)
</pre>
<p>
where
</p>
<pre>
T1 AddInPlace&lt;T1, T2&gt;(ref T1 x, T2 y)
{
  return x = x + y;
}
</pre>
<p>
This still preserves most of the left-to-right evaluation,
but delays the fetch of the initial value until as late as possible.
I can see some sense to this rule,
but it does come at a relatively high cost to language complexity.
It's going to be one of those things that "nobody really understands".
</p>
<p>
<b>Bonus chatter</b>:
Java also follows that "always evaluate left to right" rule.
Dunno if that makes you more or less angry.
See, for example,
<b>Example 15.26-2-2:
<a HREF="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#d5e30252">
Value of Left-Hand Side Of Compound Assignment
Is Saved Before Evaluation Of Right-Hand Side</a></b>.
However, for some reason,
Java has a special exception for
direct (non-compound) assignment to an array element.
In the case of <code>x[index] = y</code>,
<a HREF="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2-400-E">
the range check on the index occurs after the right-hand side is
evaluated</a>.
Again, this may make you more or less angry. You decide.
</p>
<p>
I have a second bonus chatter,
but writing it up got rather long,
so I'll turn it into a separate post.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (30)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1302307">
				<div id="div-comment-1302307" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302307">
			July 18, 2017 at 7:31 am</a>		</div>

		<p>&#8220;The C# language tries to avoid undefined behavior, so given that it must define a particular order of evaluation,&#8221;</p>
<p>I think &#8220;undefined behavior&#8221; is an unfortunate choice of words here, talking about a member of the &#8220;C&#8221;-derived family of languages, given that in that context it&#8217;s a well-defined term with a very specific meaning.</p>
<p>(After all, C doesn&#8217;t define the order of evaluation, but statements with multiple subexpressions to be evaluated results in either &#8220;unspecified&#8221; or &#8220;implementation-defined&#8221; behaviour rather than &#8220;undefined behaviour&#8221;.)</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1302335">
				<div id="div-comment-1302335" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://nbtparse.org' rel='external nofollow' class='url'>Kevin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302335">
			July 18, 2017 at 9:36 am</a>		</div>

		<p>&gt; but statements with multiple subexpressions to be evaluated results in either &#8220;unspecified&#8221; or &#8220;implementation-defined&#8221; behaviour rather than &#8220;undefined behaviour&#8221;.</p>
<p>No, unsequenced side-effects are undefined, not just unspecified.  The full set of nasal demon machinery is in play if you do something horrible like foo[i++] = ++i;</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1302365">
				<div id="div-comment-1302365" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302365">
			July 18, 2017 at 2:22 pm</a>		</div>

		<p>That&#8217;s still only unspecified. It will write to an index of foo within 2 steps of the original i a value within 2 steps of the original i.</p>
<p>Now if foo only had one more index left in the array the unspecified becomes undefined.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1302375">
				<div id="div-comment-1302375" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302375">
			July 18, 2017 at 3:46 pm</a>		</div>

		<p>No, that&#8217;s undefined behaviour. See <a href="http://c-faq.com/expr/evalorder1.html" rel="nofollow">http://c-faq.com/expr/evalorder1.html</a> and questions 3.2, 3.3, 3.8 to 3.12b and 11.33.</p>
<p>I was sloppy in my wording though; I meant to imply the order of evaluation of subexpressions in a statement like:<br />
  foo[i++] = ++j;</p>
<p>Which is well defined, but where the order of evaluation of &#8220;i++&#8221; and &#8220;++j&#8221; is either unspecified or implementation-defined (can&#8217;t remember which offhand, but probably the first)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1302315">
				<div id="div-comment-1302315" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302315">
			July 18, 2017 at 7:59 am</a>		</div>

		<p>IMHO, it would have been better to preserve the right-to-left order. Veteran programmers are used to take into account the unusual order of the assignment operator, while writing, optimizing and debugging. Changing the order makes it hard to your primary target (the very developers you are trying to sell your new language to), and for what benefit? Making life a bit easier to novice programmers, and those that after two decades in the field still aren&#8217;t worth their salaries. In other words: upset your current customers for trying to lure would-bes.</p>
<p>I just don&#8217;t mind very much about Java, but Microsoft, IMHO, has made a few key strategical mistakes in the 2000s. In an era when, for the first time in almost 20 years, Microsoft was getting some real alternatives (Palm OS, iOS, Android, web apps&#8230;).</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1302316">
				<div id="div-comment-1302316" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302316">
			July 18, 2017 at 8:25 am</a>		</div>

		<p>If you have the chance to remove an unusual order, why not get rid of it ?</p>
<p>Enabling programmers to focus on their core task (ie. making software for themselves or clients) instead of having to remember annoying details is good.</p>
<p>It&#8217;s why real programmers document their code, write unit tests, etc&#8230; instead of trying to preserve unusual orders of assignment for the sake of tradition.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1302327">
				<div id="div-comment-1302327" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302327">
			July 18, 2017 at 9:32 am</a>		</div>

		<p>If we want to eliminate the quirks of programming languages, then why do we keep semicolon sentence termination, three-expression for loops, and curly braces block delimiters in most modern languages? They all cause a lot of confusion to beginners, and even for expert programmers it is a pain to get an error at the last line of the file just because you forgot brace in a for loop some fifty lines above (now go and find it &#8211; it sometimes takes a lot of time of carefully reading the code).</p>
<p>Pascal and Basic may be outdated, but by using different block closing sentences matched to the opening ones (and forcing you write them even for one-sentence blocks), you get the error in the next block closing, usually not more than a handful of lines bellow the mistake. This, also, makes it easier to keep indentation right, which is a plus when teaching beginners.</p>
<p>We keep using curly braces and C-like syntax in most modern languages (C#, Java, PHP, Rust, Swift&#8230;) out of tradition. There are so many veteran programmers used to them (and convinced that non-curly-languages are script-like, or, even worse, Basic-like) that you have no opportunity promoting a serious language that doesn&#8217;t use them. Even with all the problems they carry on. Of Javascript and Python, which one is seen as more professional? And which one gets the most bashing?</p>
<p>On the other hand, take into account that it is a lot more difficult to write a parser that takes into account the right precedence of the assignment operator. Yet most procedural, non-stack-based languages from the 60s, 70s and 80s (when computing power was far more limited than now) implemented that. Because it is, in fact, more intuitive once you hear about the concept. Anyone with some background in Mathematics will agree. StackOverflow copypasters may disagree, but I&#8217;m talking about professional programmers here.</p>
<p>In other words: we keep using curly braces (and C syntax) out of tradition. Why not do the same for the assignment operator?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1302396">
				<div id="div-comment-1302396" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302396">
			July 19, 2017 at 12:24 am</a>		</div>

		<p>&#8220;Pascal and Basic may be outdated&#8221;</p>
<p>Why? In this paragraph, you just have named perfect reasons to mistrust languages which seams only to be defined with a &#8220;hey, cool&#8221; mindset, but without considering the usefulness. (C++ is just unreadable for anyone not very deeply intimate with its strange constructs, plus the nonsense of Undefined Behavior.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4" id="comment-1302406">
				<div id="div-comment-1302406" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302406">
			July 19, 2017 at 1:00 am</a>		</div>

		<p>&gt; If we want to eliminate the quirks of programming languages, then why do we keep semicolon sentence termination, three-expression for loops, and curly braces block delimiters in most modern languages?</p>
<p>You might have heard of Python, which already does a lot of what you say.</p>
<p>Despite that, it&#8217;s quite popular.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-4" id="comment-1302407">
				<div id="div-comment-1302407" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302407">
			July 19, 2017 at 1:05 am</a>		</div>

		<p>&gt;  Because it is, in fact, more intuitive once you hear about the concept. Anyone with some background in Mathematics will agree.</p>
<p>You are confused. We are talking about order of evaluation, NOT associativity.</p>
<p>Also, you might want to add arguments to your story, because arguments of authority won&#8217;t cut it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4" id="comment-1302466">
				<div id="div-comment-1302466" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302466">
			July 19, 2017 at 8:23 am</a>		</div>

		<p>I disagree that modern VB.Net is outdated.  I believe it has all, or almost all, of the constructs and semantics of C#.  Just different syntax without curly braces.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-4" id="comment-1302605">
				<div id="div-comment-1302605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua Schaeffer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302605">
			July 19, 2017 at 3:14 pm</a>		</div>

		<p>C-style for-loops aren&#8217;t hard for beginners. No loop is hard for beginners because loops are when their programs start actually doing something interesting. If you didn&#8217;t write dumb newline text in an infinite loop, you&#8217;re lying. Nobody told you to do that. You were having early fun with loops, not struggling.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4" id="comment-1303006">
				<div id="div-comment-1303006" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1303006">
			July 21, 2017 at 7:59 am</a>		</div>

		<p>&#8220;Because it is, in fact, more intuitive once you hear about the concept. Anyone with some background in Mathematics will agree. StackOverflow copypasters may disagree, but I&#8217;m talking about professional programmers here.&#8221;<br />
So why would a mathematician have an opinion about the order of assignments? If anything the mathematician would expect a side-effect free language where such a distinction would be meaningless.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1302325">
				<div id="div-comment-1302325" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Caron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302325">
			July 18, 2017 at 8:50 am</a>		</div>

		<p>Hi, Target Audience here! I&#8217;ve been coding for 20 years, since I was very young, over a handful of languages (QBasic, Visual Basic, dabbling in C/C++, PHP, and now C#), and this is the first time I&#8217;ve ever heard, or even considered, the order of evaluation of right-side vs left-side. </p>
<p>I already knew that everything else in C# was strictly left-to-right, so I guess if you had asked me, I would have given that answer. Honestly though, I can&#8217;t think of very many cases where you would want to rely on this behaviour. The sample that Raymond posted above is a decent example, though I would probably prefer to make the variables explicit, and the let the compiler/jitter do the work of optimising them away (or not, if that&#8217;s what it feels is best).</p>
<p>Definitely, when optimizing a piece of code, I would never, ever decide to introduce a dependency on order of operations. Surely code that finely hand-tuned is written in IL directly, if not removed from C# altogether.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1302336">
				<div id="div-comment-1302336" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302336">
			July 18, 2017 at 9:46 am</a>		</div>

		<p>You are right: in most cases, you should not be relying on this behavior. Most times the precedence of the assignment operator matters, it is because of side effects between the expressions at the right and at the left. Which borders on undocumented features.</p>
<p>The only reasonable case I can think of is, precisely, optimization. Nowadays, processors are powerful and compilers are good at optimization, so it rarely makes no sense writing assembler or IL by hand. It is a cost/benefit trade: your code may have to be read and maintained by other programmers, which may not know assembler or IL. Because of that, it is best to write the most efficient possible code in the same high-level language as the rest of the project. That way, with the help of detailed comments, any programmer can understand what is going on without having to do a course on x86 assembler.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-alexcohn odd alt depth-4 parent" id="comment-1302555">
				<div id="div-comment-1302555" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302555">
			July 19, 2017 at 12:49 pm</a>		</div>

		<p>&gt; it is best to write the most efficient possible code in the same high-level language as the rest of the project.</p>
<p>Better, write simple and clean code in high-level language, and let the optimizing compiler care about it.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1302975">
				<div id="div-comment-1302975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302975">
			July 21, 2017 at 6:39 am</a>		</div>

		<p>Or write a code generator in a high level language (Python, for example), that generates the efficient code in the compiled language (C++, for example). That way, when the compilers improve, you can simplify your code generator.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1302346">
				<div id="div-comment-1302346" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302346">
			July 18, 2017 at 11:18 am</a>		</div>

		<p>There&#8217;s no &#8220;preserve the right-to-left order&#8221;, because there is no existing order (C, C++), or the pre-existing order was left-to-right (Java).</p>
<p>Methinks you&#8217;re talking about associativity (which IS right-to-left) rather than order of evaluation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1302355">
				<div id="div-comment-1302355" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zboot</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302355">
			July 18, 2017 at 12:40 pm</a>		</div>

		<p>There was no &#8220;right to left&#8221; order to preserve. So you&#8217;re complaining today, that &#8220;veteran programmers&#8221; would shy away from C#, because it works differently from what they&#8217;re used to? I think at this point, if there are veteran programmers who can&#8217;t adapt to C#, they are clearly *not* the target market for this language. They&#8217;re too old. C# has been out so long, there are younger and more numerous &#8220;veterans&#8221; who won&#8217;t have that issue.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1302326">
				<div id="div-comment-1302326" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">littlealex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302326">
			July 18, 2017 at 9:28 am</a>		</div>

		<p>I have to very strongly disagree on this one:<br />
<i>&#8220;You can&#8217;t say that this code is &#8220;already broken&#8221; because it&#8217;s not. &#8220;</i><br />
I very much can, and will call this code &#8220;broken&#8221;. &#8220;It works&#8221; is absolutely not a synonym for &#8220;it is not broken&#8221;. Code that even at first glance scream &#8220;I am going to cause problems&#8221; is broken. Even it is working.</p>
<p>All code is either &#8220;easy to maintain (as much as possible, of course)&#8221;, or it is &#8220;broken&#8221;. It can be broken in different ways and most importantly in different cost-categories, where &#8220;absolutely does not work at all&#8221; is rather cheap, while &#8220;does work (at least right now)&#8221; tends to be broken in very costly ways. At the time this already broken code finally stops working, probably no one will even remember the name of the one who wrote this code. No one will know which side-effects of the code are required, which are accepted because the one resposible asserted (ar thought he asserted) the side effects will not hurt, and which of the side effects actually do hurt and since when have these sideeffect been part of the code, making it work in subtly wrong ways, and so on.</p>
<p>Every code which relies on the order of evaluation is broken. It is absolutely worth the effort to do:<br />
  case Opcode.PokeByte:<br />
    ushort index = NextUnsigned16();<br />
    byte value = NextUnsigned8();<br />
    memory[index] = value;<br />
    break;</p>
<p>To be broken in a slightly less expensive way, the code must at the very least be heavily commented, with CAPITALS and exc!amat!on marks, to ensure everybody will be extremely careful when poking their head into the sheer horror of this language specific side-effect based &#8216;code&#8217;. And writing the appropriate comments will be much more work than just fixing the whole thing.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1302385">
				<div id="div-comment-1302385" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.silverbacknetworks.tech' rel='external nofollow' class='url'>Joshua Bowman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302385">
			July 18, 2017 at 4:25 pm</a>		</div>

		<p>That&#8217;s like saying any code that uses STL or lambdas is verboten, because only language experts really know what they&#8217;re doing under the hood, and they&#8217;ll work differently in other languages. The C# spec says that &#8220;memory[NextUnsigned16()] = NextUnsigned8();&#8221; and &#8220;n16 = NextUnsigned16(); n8 = NextUnsigned8(); memory[n16] = n8;&#8221; mean exactly the same thing, therefore it isn&#8217;t broken in any way. It will never change, it will never break.</p>
<p>If you port any code to another language without knowing the differences in languages, or wrongly assuming similar expressions will always act the same, then of course your code will be broken.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1302397">
				<div id="div-comment-1302397" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302397">
			July 19, 2017 at 12:26 am</a>		</div>

		<p>&#8220;that uses STL or lambdas is verboten,&#8230;&#8221;</p>
<p>I agree with that.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1302425">
				<div id="div-comment-1302425" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302425">
			July 19, 2017 at 4:12 am</a>		</div>

		<p>&#8220;Every code which relies on the order of evaluation is broken&#8221;</p>
<p>This, but with one exception: Constructs with &#8220;&amp;&amp;&#8221; and &#8220;||&#8221;. Short-cutting of such constructs is a very, very useful feature, and hopefully, every programming language on earth will perform this left-to-right.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1302426">
				<div id="div-comment-1302426" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302426">
			July 19, 2017 at 7:11 am</a>		</div>

		<p>Except the equivalent operator (AND/OR) in BASIC of course.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1302455">
				<div id="div-comment-1302455" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302455">
			July 19, 2017 at 8:17 am</a>		</div>

		<p>VB.NET has AndAlso and OrElse, which short-circuit.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302415">
				<div id="div-comment-1302415" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302415">
			July 19, 2017 at 3:27 am</a>		</div>

		<p>While in C++ you evaluate x[index] = y; as auto &amp;t = x[index]; t = y; you don&#8217;t have that luxury in Java, which explains that behaviour, while in JavaScript you can write nonsense such as a = [0]; a += ++a[0]; which results in a&#8217;s value becoming &#8220;11&#8221;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd even thread-even depth-1" id="comment-1302585">
				<div id="div-comment-1302585" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302585">
			July 19, 2017 at 2:06 pm</a>		</div>

		<p>Chalk up one more for the &#8220;left-to-right&#8221; camp.</p>
<p>C, C++, Java, C#, Delphi.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302705">
				<div id="div-comment-1302705" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryce Wagner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302705">
			July 20, 2017 at 5:37 am</a>		</div>

		<p>&#8220;In particular, for compound assignment, it means that E1 += E2 and E1 = E1 + E2 are no longer equivalent if E1 and E2 have interacting side effects.&#8221;</p>
<p>It wasn&#8217;t completely clear whether this statement was referring to how things currently exist, or what would be different if the order of operations were different.  In C#:    <b>x[i++] += 1;</b> has different behavior from <b>x[i++] = x[i++] + 1;</b>.  The first version only evaluates i++ once, even if you&#8217;re dealing with a this[] operator and not an array [].</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1302756">
				<div id="div-comment-1302756" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Doubleday</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302756">
			July 20, 2017 at 9:09 am</a>		</div>

		<p>I wonder if LTR associativity for the assignment operator is &#8220;natural&#8221; for someone whose first written language is RTL?</p>
<p>Aaaand &#8230; no, boustrophedonics are best left to one side for now.</p>
<p>I think this is one of those cases where clarity trumps purity (assuming that purity is the rationale for RTL associativity).  Me, I find the invisible fix for lambda capture of a foreach variable to be obvious, natural, and valuable &#8212; even though it is the Impure Work Of The Devil.</p>
<p>A part of me, however, still wants <b>lvalues</b> to be <b>lvalues</b>, and I see RTL evaluation as enforcing this meaning.  But, as I say &#8212; rules is rules, and somebody has to make the choice when the compiler team starts with -100 points for either feature.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302985">
				<div id="div-comment-1302985" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MarcK4096</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170718-00/?p=96635#comment-1302985">
			July 21, 2017 at 6:48 am</a>		</div>

		<p>I followed the loop closure link without realizing it isn&#8217;t an article written by Raymond and was shocked when I found the article was soliciting opinions on purposefully making a breaking change to C#.  After reading all the articles about the questionable bugs that have been left in Windows for the sake of &#8220;backwards compatibility&#8221;, I could never see Raymond writing something like this.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

