<html>
<head>
<title>It's the address space, stupid</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>It&#8217;s the address space, stupid</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 28, 2013 / year-entry #172</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>78</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Nowadays, computers have so much memory that running out of RAM is rarely the cause for an "out of memory" error. Actually, let's try that again. For over a decade, hard drive have been so large (and cheap) that running out of swap space is rarely the cause for an "out of memory" error. In...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>Nowadays, computers have so much memory that running out of RAM is rarely the cause for an "out of memory" error.</p>
<p> Actually, let's try that again. For over a decade, <a href="http://ns1758.ca/winch/winchest.html"> hard drive have been so large</a> (and <a href="http://www.mkomo.com/cost-per-gigabyte">cheap</a>) that running out of swap space is rarely the cause for an "out of memory" error. </p>
<p> In user-mode, the term <i>memory</i> <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx"> refers to virtual memory, not physical RAM chips</a>. The amount of physical RAM doesn't affect how much memory a user-mode application can allocate; it's all about commit and swap space.&sup1; But swap space is disk space, and that is in the hundreds of gigabytes for hard drives. (Significantly less for SSDs, but even in that case, it's far more than 4<a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/11/9725386.aspx">GB</a>.) </p>
<p> The limiting factor these days is address space. </p>
<p> Each thread's stack takes a megabyte, and if you're creating a lot of threads, that can add up to a lot of address space consumed just for stacks. And then you have to include the address space for the DLLs you've loaded (which quickly adds up). And then there's the address space for all the memory you allocated. (Even if you don't end up using it, it still occupies address space until you free it.) </p>
<p> Typically, when you get an <code>ERROR_<wbr>OUT_<wbr>OF_<wbr>MEMORY</wbr></wbr></wbr></code> error, the problem isn't physical memory or virtual memory. It's address space. </p>
<p> This is one of the main benefits of moving to 64-bit computing. It's not that you actually are going to use or need all that memory. But it relieves pressure on the address space: The user-mode address space in 64-bit Windows is eight <i>terabytes</i>. </p>
<p> When the day comes that eight terabytes is not enough, we at least won't have to redesign the application model to expand the address space. The current x86-64 hardware has support for address spaces of up to 256TB, and the theoretical address space for a 64-bit processor is sixteen exabytes. </p>
<p> &sup1; Of course, physical RAM is a factor if the application is explicitly allocating physical memory, but that's the exception rather than the rule. </p>
<p> <b>Exercise</b>: Help this customer clear up their confusion: They reported that processes were failing to start with <code>STATUS_<wbr>DLL_<wbr>INIT_FAILED</wbr></wbr></code> (0xC0000142), and our diagnosis was that the <a href="http://blogs.msdn.com/b/ntdebugging/archive/2007/01/04/desktop-heap-overview.aspx"> desktop heap</a> was exhausted. "The system has 8GB of RAM installed, and Task Manager reports that only 2GB of it is being used, so it is unlikely that I am running out of any kind of heap/memory." </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (78)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1063583">
				<div id="div-comment-1063583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063583">
			June 28, 2013 at 7:15 am</a>		</div>

		<p><!-- p>"The current x86-64 hareware"


<p>Is it Easter again already? Boy, the year goes by so fast!</p>




<p>Your customer sounds like they need to read the desktop heap article you linked to&#8230;you gave away the answer right there!</p>


</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063593">
				<div id="div-comment-1063593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063593">
			June 28, 2013 at 7:16 am</a>		</div>

		<p>I regularly see out of memory errors in IE8 when I have had its developer tools open even once&#8230; it just leaks the memory of every page as I navigate to the next one until it hits 1.5 or 1.6gb then it starts to die.</p>
<p>Exercise: 2GB is the address space for a 32-bit process. &nbsp;Customer will need a 64-bit version if they wish to use up the entire 8GB+ (including paging file) and crash their PC. &nbsp;Or they can try and fix the actual problem, if that&#39;s how they roll.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1063603">
				<div id="div-comment-1063603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063603">
			June 28, 2013 at 7:22 am</a>		</div>

		<p>And still, with the giant physical memory, Microsoft gets all obscessed about &lt;10 MB they can save by using paged code in the kernel drivers. &quot;It reduces memory pressure&quot; they say. While not caring a bit about preventing the file cache from pushing executable pages and data pages out. Try to copy a bunch of large files, and see your applications churning like crazy. I guess the tests they run in their ivory towers don&#39;t show that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063613">
				<div id="div-comment-1063613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Barbie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063613">
			June 28, 2013 at 7:22 am</a>		</div>

		<p>@The MAZZTer, they&#39;re still at process startup&#8230; That&#39;s a hell of a process they&#39;re starting up, to already use 2GB!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063623">
				<div id="div-comment-1063623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063623">
			June 28, 2013 at 7:40 am</a>		</div>

		<p>In real life, for historical reasons to do with the specification of &quot;malloc()&quot;, the most common cause of &quot;out of memory&quot; is a null pointer being returned from a function which normally returns a block of memory. This is in many cases interpreted as &quot;out of memory&quot; even if that is not the actual cause.</p>
<p>For example GDI+ will throw an out of memory exception if you attempt to load certain malformed image files.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1063633">
				<div id="div-comment-1063633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063633">
			June 28, 2013 at 7:41 am</a>		</div>

		<p>The desktop heap is an legacy of &quot;everybody can screw everybody&quot; USER orgy. Windows needs to change that to &quot;only top level windows have desktop scope&quot; (with a CreateProcess flag to override that).</p>
<div class="post">[<em>We already did that and more. Windows Store applications cannot access each others&#39; windows at all. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063653">
				<div id="div-comment-1063653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gizen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063653">
			June 28, 2013 at 7:45 am</a>		</div>

		<p>When will a windows version come out that can actually use the current hardware?</p>
<p>Using virtual software limits is evil.</p>
<p>Like limiting a car capable of speeds above 200 mph to barely only 30 mph.</p>
<p>If a car manufacturer would try to pull that stunt people would get pissed.</p>
<p>Why isn&#39;t windows users getting angry?</p>
<p>Have microsoft already sheepified the majority of them?</p>
<p>Customer question: Why can&#39;t i use all my sixteen exabytes address space? Since i cannot turn off metro ui i really need more address space. I have so little address space that the start menu isn&#39;t even working or showing up.</p>
<p>In windows 8.1 the start menu shows up but is still broken and unusable.</p>
<p>It boggles me that windows xp could be run on a 512 megabyte ram computer. Where did things go so wrong? Have microsoft a secret deal with hardware manufacturers other than those i know about?</p>
<p>Perhaps NSA knows&#8230;</p>
<p>I joke, satire but i really do wonder why windows isn&#39;t taking advantage of the hardware. People did really get upset when they heard of the 3.5 gigabyte ram issue on windows 32-bit. It went so far as computer manufacturers ordering microsoft to make windows lie about the used ram. Apparently educating the users was out of the question.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063693">
				<div id="div-comment-1063693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063693">
			June 28, 2013 at 8:07 am</a>		</div>

		<p>@Gizen: Mark Russinovich (yes, the Microsoft genius) explains once and for all why x86 (32-bit) versions of Windows cap memory at 3.5GB even though, mathematically, the addressable space should be 4GB. I read this article a few years ago, and I must have referred others to it a dozen times by now. One of the best reads for any IT pro or developer, aside from Raymond&#39;s blog, of course. :)</p>
<p><a rel="nofollow" target="_new" href="http://blogs.technet.com/b/markrussinovich/archive/2008/07/21/3092070.aspx">blogs.technet.com/&#8230;/3092070.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063703">
				<div id="div-comment-1063703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bruce</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063703">
			June 28, 2013 at 8:14 am</a>		</div>

		<p>@Gizen: complain to AMD, not Microsoft &#8211; current CPUs only support a 48-bit address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063713">
				<div id="div-comment-1063713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">floyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063713">
			June 28, 2013 at 8:17 am</a>		</div>

		<p>@The MAZZTer: Suggested heading for the Exercise: &quot;It&#39;s the desktop heap, stupid&quot;.</p>
<p>.f</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dwalker-wk even thread-even depth-1" id="comment-1063723">
				<div id="div-comment-1063723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063723">
			June 28, 2013 at 8:40 am</a>		</div>

		<p>&quot;Each thread&#39;s stack takes a megabyte&quot;. &nbsp;Reminds me of when I wondered about the size of page tables back when I worked on mainframe computers running VM. &nbsp;It is an interesting area of operating system design. &nbsp;</p>
<p>In Wintel-land, each thread&#39;s stack should be dynamically allocated out of virtual memory! :-) &nbsp;Everything should be dynamically allocated out of the total address space, even the address space tables.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063733">
				<div id="div-comment-1063733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063733">
			June 28, 2013 at 8:55 am</a>		</div>

		<p>Incidentally I&#39;ve reached real out of memory before. Exhausted RAM + Page. Down it goes. Win XP Kernel doesn&#39;t like not being able to allocate RAM very much.</p>
<p>&gt; I joke, satire but i really do wonder why windows isn&#39;t taking advantage of the hardware. People did really get upset when they heard of the 3.5 gigabyte ram issue on windows 32-bit. It went so far as computer manufacturers ordering microsoft to make windows lie about the used ram. Apparently educating the users was out of the question.</p>
<p>What&#39;s funny is Windows Server 2003 Enterprise Edition x86 doesn&#39;t have the limit. Microsoft could have released XP built from the 5.2 branch completely uncapped and did not. Which is why for Vista and up there are patches floating around that patch only a few bytes of kernel that remove the 4GB limit. Education of users was bankrupt when anybody looking at the specs for Windows Server 2003 could see they were lying.</p>
<div class="post">[<em>And then your sound card driver corrupts memory due to a truncated DMA address and you blame Windows. (This problem doesn&#39;t exist on Server because servers don&#39;t have sound cards.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063763">
				<div id="div-comment-1063763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AsmGuru62</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063763">
			June 28, 2013 at 9:26 am</a>		</div>

		<p>Fragmentation is also an issue.</p>
<p>The app in Task Manager shows about 140Mb, but can&#39;t allocate continuous block of ~50Mb.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1063783">
				<div id="div-comment-1063783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063783">
			June 28, 2013 at 10:21 am</a>		</div>

		<p>Joshua,</p>
<p>Beating a dead horse is a thankless job, but I need to remind you again and again that consumer grade drivers were never tested in those times to verify they support 64 bit physical address.</p>
<p>These days it&#39;s a non-issue anymore. Everybody just runs x64.</p>
<p>@DW:</p>
<p>&gt;In Wintel-land, each thread&#39;s stack should be dynamically allocated out of virtual memory!</p>
<p>You remember that the virtual space for it has to be reserved for the life of the thread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063803">
				<div id="div-comment-1063803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Circle of support (life)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063803">
			June 28, 2013 at 10:32 am</a>		</div>

		<p>@Bruce:</p>
<p>Here is how it goes:</p>
<p>You complain to microsoft. Microsoft blames the hardware. Tells you to go complain to them.</p>
<p>Hardware makers blames microsoft for not providing the support and the market (economic incentive). Tells you to go complain to microsoft.</p>
<p>They blame each other up the wazoo while you stand there with your unsolved problem and watch them fight and blame each other like a kid watching its parents fight.</p>
<p>The result: You get scarred for life. Stops trusting companies and their &quot;support&quot;. You become a bitter old man while your problems still exist and new ones are created.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063813">
				<div id="div-comment-1063813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fred</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063813">
			June 28, 2013 at 10:40 am</a>		</div>

		<p>&gt; [And then your sound card driver corrupts memory due to a truncated DMA address and you blame Windows. (This problem doesn&#39;t exist on Server because servers don&#39;t have sound cards.) -Raymond]</p>
<p>Isn&#39;t that technically a bug?</p>
<p>The memory allocator should know its hardwares limits. Like how programs have different paths for if SSE is supported and checks at start.</p>
<p>Servers might not have sound cards but isnt other areas affected by this &#39;truncated DMA address&#39; bug instead?</p>
<div class="post">[<em>The only interesting drivers that servers run are storage and networking. (They don&#39;t have a sound card, and they use the Plain VGA video driver.) And the person setting up the server is darn well going to ask the driver vendor, &quot;So this driver is certified to run on servers, right?&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063823">
				<div id="div-comment-1063823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alois Kraus</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063823">
			June 28, 2013 at 10:48 am</a>		</div>

		<p>The more interesing question about Desktop heap is how to debug it? How can I find out which objecs are allocated on the desktop heap so I can check which process did deplete it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063833">
				<div id="div-comment-1063833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063833">
			June 28, 2013 at 10:59 am</a>		</div>

		<p>[And then your sound card driver corrupts memory due to a truncated DMA address and you blame Windows. (This problem doesn&#39;t exist on Server because servers don&#39;t have sound cards.) -Raymond]</p>
<p>That&#39;s what the switch in boot.ini to not use the first 4GB of RAM is FOR. So this can be trivially tested for and know full well which driver screwed up. Oh wait. This was meant for a different target audience that can&#39;t understand.</p>
<p>@Fred: The bug is in the driver. It thought that physical addresses could fit in pointer types (they can&#39;t) and the cast sheared off the top bits.</p>
<div class="post">[<em>&quot;I put 4GB of memory in my computer, and I get massive data corruption. Obviously, this is a driver bug, and the clear course of action is to edit some file called &quot;shoes.innie&quot; and type some magic beans, and now my computer has only 0.5GB of memory, so I can&#39;t actually use it for anything, but gosh darn it I&#39;m isolating a driver bug people! On second though, I&#39;ll just buy a Mac.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063853">
				<div id="div-comment-1063853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063853">
			June 28, 2013 at 12:29 pm</a>		</div>

		<p>@AsmGuru62: 32-bit builds of our product often go down trying to allocate 3 MB with 200 MB left. &nbsp;&gt;.&lt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063863">
				<div id="div-comment-1063863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Silly</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063863">
			June 28, 2013 at 12:30 pm</a>		</div>

		<p>Heh. Unrelated but I remember in ye olde days (&lt;2003) when a mate used DWORD timestamps (millisecond resolution) as his time type. Addition of months to that realised the limitations pretty quick.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063873">
				<div id="div-comment-1063873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063873">
			June 28, 2013 at 1:38 pm</a>		</div>

		<p>I rarely (read: never) see anyone pointing out that the 32-bit x86 architecture provides _12_, not 4, gibigytes of virtual address space. Stack space, code space and data space are distinct address spaces, unless deliberately set up to overlap each other (fully or partially).</p>
<p>It is not that a factor of three makes an ocean of differece (in particular when the OS does not support it&#8230;), but if you want a thorough understanding of the addressing mechanisms, you should understand that the theoretical limit is 12 rather than 4.</p>
<div class="post">[<em>The linear address space is still 32 bits. Selector base addresses are 32-bit linear values. (See Figure 3-8 in the Intel 64 and IA-32 Architectures Software Developer&#39;s Manual Volume 3A.) In other words, selectors just select a subset of the existing 32-bit linear address space. You don&#39;t get three page tables (one each for ss, cs, and ds). -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063903">
				<div id="div-comment-1063903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063903">
			June 28, 2013 at 2:15 pm</a>		</div>

		<p>Has Windows x64 gotten past the 8-TB address space limit? &nbsp;I know that previously, the address space was limited to 44 bits because the extra bits were used to avoid the ABA problem with [Ex]InterlockedPopEntrySList when only cmpxchg8b was available on early AMD64s. &nbsp;Now that Windows 8.1 x64 requires your CPU to support cmpxchg16b, does that mean Windows 8.1 will support more than 8 TB of address space?</p>
<p>(44 bits = 8 TB for kernel, 8 TB for user)</p>
<div class="post">[<em>Do you have an app that is bumping into the 8TB limit? Or is this a purely theoretical problem with no practical impact? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063913">
				<div id="div-comment-1063913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063913">
			June 28, 2013 at 2:21 pm</a>		</div>

		<p>[The only interesting drivers that servers run are storage and networking. (They don&#39;t have a sound card, and they use the Plain VGA video driver.) And the person setting up the server is darn well going to ask the driver vendor, &quot;So this driver is certified to run on servers, right?&quot; -Raymond]</p>
<p>Did you /see/ the number of people installing Windows Server 2003 on their gaming PCs because it was benchmarking 20% higher framerate than XP on the same hardware?</p>
<p>OK I&#39;ll shut up now. (And no I wasn&#39;t trying to get the last word or I&#39;d reply to something more vital.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063923">
				<div id="div-comment-1063923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063923">
			June 28, 2013 at 2:25 pm</a>		</div>

		<p>[Do you have an app that is bumping into the 8TB limit? Or is this a purely theoretical problem with no practical impact? -Raymond]</p>
<p>Nope, not at all! =) &nbsp;I think most systems would run out of memory just trying to store the page table for 8 TB. =^_^= &nbsp;This is just a theoretical question; reading Windows 8.1&#39;s system requirements this week reminded me of the significance of cmpxchg16b to Windows x64.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063953">
				<div id="div-comment-1063953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Raphael</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063953">
			June 28, 2013 at 3:23 pm</a>		</div>

		<p>&gt; Did you /see/ the number of people installing Windows Server 2003 on their gaming PCs because it was benchmarking 20% higher framerate than XP on the same hardware?</p>
<p>Really? People paid about a thousand dollar for a (dubious, I presume) 20% increase in frame rate?</p>
<div class="post">[<em>I bet these people also buy a Formula 1 race car and then complain about the audio system. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063973">
				<div id="div-comment-1063973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063973">
			June 28, 2013 at 4:20 pm</a>		</div>

		<p>&gt; Really? People paid about a thousand dollar for a (dubious, I presume) 20% increase in frame rate?</p>
<p>It&#39;s about $300 (remember there&#39;s no terminal server and no CALs needed).</p>
<p>Assuming of course they didn&#39;t pirate it or use a spare MSDN license from work (we&#39;ve got 80 (yes 80!) licenses for 2003 and about 4 in use).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1063983">
				<div id="div-comment-1063983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/ajgelado_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>ajgelado@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063983">
			June 28, 2013 at 4:58 pm</a>		</div>

		<p>&gt; It&#39;s about $300 (remember there&#39;s no terminal server and no CALs needed).</p>
<p>The whole argument is an empty rant. $300 will buy you a lot of performance (for example, in a fas SSD or a liquid refrigeration system for overclocking) if you do your homework.</p>
<p>Anyway, any user capable of configuring NT 5.2 for gaming (and sorting around the incompatibilities) should have little trouble troubleshooting driver issues. On the other hand, most Word-and-Facebook users running the vanilla flavor of NT 5.1 do not have a clue at all about what to do when a blue screen shows. Windows already gets enough bad press from buggy drivers &#8211; no need for Microsoft to worsen that!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063993">
				<div id="div-comment-1063993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran Mitrovic</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063993">
			June 28, 2013 at 5:31 pm</a>		</div>

		<p>Don&#39;t forget that every thread takes another 256kb when running on WOW64.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064013">
				<div id="div-comment-1064013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/arcangelpip_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>arcangelpip@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064013">
			June 28, 2013 at 7:23 pm</a>		</div>

		<p>@Myria:</p>
<p>The preview version of 8.1 requires a processor with cmpxchg16b instruction. So if it isn&#39;t supported in 8.1, they are paving the way for future releases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1063883">
				<div id="div-comment-1063883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pippin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1063883">
			June 28, 2013 at 1:40 pm</a>		</div>

		<p>&gt;&gt;&gt;On second though, I&#39;ll just buy a Mac.&quot; -Raymond</p>
<p>Plenty of people express that sentiment, somehow people don&#39;t express it the other way round. Perhaps embracing broken drivers, apps and such has contributed to the perception that Windows is such a clusterf****. OTOH, microsoft could improve the i/o design too like adding a scheduler that works at the DPC level to prevent errant driver code from locking up a CPU core. I&#39;ve seen drivers (couugh.. StarForce.. &nbsp;Microsoft Certified) do the DPC re-queue trick and screw up the user experience. Microsofts argument seems to be that the user needs to be shielded from a bad code ruining their windows experience, except in the case of DRM.. then everything is allowed.</p>
<div class="post">[<em>I&#39;m trying and failing to find a point to this rant. I hope you feel better for having written it. (I also hope that this satisfies your rant quota. Then we can go back to talking about address space exhaustion.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064033">
				<div id="div-comment-1064033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064033">
			June 28, 2013 at 10:19 pm</a>		</div>

		<p>@Goran: True, but you probably ought to be using /LARGEADDRESSAWARE in your application already. &nbsp;The 256K WOW64 stack cost is far outweighed by the extra 2 GB available from running under Win64 as a 32-bit program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064043">
				<div id="div-comment-1064043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pippin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064043">
			June 29, 2013 at 12:18 am</a>		</div>

		<p>&gt;I&#39;m trying and failing to find a point to this rant. &#8211; Raymond</p>
<p>I&#39;ve been reading and enjoying your blog over the years and I&#39;ve seen you make the point that X needed to be done or Y would disrupt the users experience and the user would blame Microsoft because when anything goes wrong they blame the OS. My point was this is argument is applied selectively by other people inside MS as several &#39;microsoft approved&#39; products clearly disrupt the users experience (the example I gave was a widely despised buggy DRM product). Ok.. back to address space exhaustion ! Whats up with ipv6?? :P</p>
<p>&gt;Really? People paid about a thousand dollar for a (dubious, I presume) 20% increase in frame rate?</p>
<p>That happened a lot during the release of Vista. People thought hey.. Vista sucks so let me install the same OS with a different name and use the same drivers and see what happens. You saw some UI improvements because desktop rendering via &#39;classic&#39; shell interface was faster than offloading things on the GPU. But AFAIK there was no documented difference worth mentioning in framerates in games.</p>
<div class="post">[<em><a href="http://blogs.msdn.com/b/oldnewthing/archive/2006/07/13/664448.aspx">Glass houses are great places to throw stones</a>. You&#39;re ranting to the wrong person. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064063">
				<div id="div-comment-1064063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064063">
			June 29, 2013 at 5:28 am</a>		</div>

		<p>Because Novell couldn&#39;t even trust disk drivers for ISA cards, Netware would limit you to 16MB unless you had an EISA or PCI machine or used some arcane steps to get your disk driver to recognise all of your memory.</p>
<p>@Gizen Not to 30mph, but they do get limited to 159mph for some reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064053">
				<div id="div-comment-1064053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064053">
			June 29, 2013 at 2:09 am</a>		</div>

		<p>Raymond&gt; The linear address space is still 32 bits. Selector base addresses are 32-bit linear values.</p>
<p>At least &nbsp;some (although I am not in a position to claim &#39;all&#39;) processors in the x85 family, provide externally available signals telling whether the memory access is a code, stack or data reference. In principle, you could set up a machine with three different physical 4GB spaces. I guess that you would have to turn of all paging, though: Even though both the virtual address level and the physical level is aware of the stack/data/code distinction, the paging hardware wouldn&#39;t know that (code) page X and (data) page X are different pages.</p>
<p>Anyhow: The linear address is completely invisible to the software; it is part of the translation process down to a physical address. Whether those 12 GB is hashed down to your 512 Mbyte of RAM in a single tranlation step or it first goes to a 4 GB &quot;linear space&quot; and then further on to 512 MB makes no difference at all to the software. Besides, just like an OS may map physical pages in and out of RAM space, it can map virtual segments in and out of the linear address space; access to a non-present segment causes an exception very similar to a page fault. So even on standard PC hardware, with no phyiscal address bank trickery, an OS could provide 12 GB of adressable *virtual* space to a process.</p>
<p>There would be some minor limitations, like all segments being present (in linear space) *simultaneously* could not exceed a combined size greater than 4 GB; the OS would have to &quot;page out&quot; (&quot;seg out&quot;??) some segments from linear space to make room for others, and might have to do compaction (which would be a fast operation &#8211; the number of segment descriptors is small). I would have to work hard to create a real-world application example where this would be any sort of limitation. Besides, you see lots of such limitations (e.g. you can&#39;t set up a 4GB DMA buffer) of similar non-importance.</p>
<p>I am not claiming that segment swapping in an out of linear space would be any sort of ideal situation. I am mostly using this argument to make sure that people fully understand the x86 segmenting mechanism, before I go on to object oriented systems and hardware handles. 386 memory management was to a large degree a spinoff of the 432 project, implementing object oriented concepts fully in hardware. Going from x86 to a 432-imspired generalizationn (i.e. to arbitrarily small objects, not large segments, a gate-like mechanism to control method activation etc.) turns out to be a very fruitful path to make people understand how handle-based systems such as JVM and .net can be imlemented. If you are still programming in flatland: Sure, going to 64 bits is a far simpler and cleaner solution.</p>
<div class="post">[<em>You can&#39;t provide 12GB (4GB each for CS, DS, SS) because for example a &quot;push ds:[eax]&quot; instruction requires all three segments to be present at the same time. (Actually, even if the instruction doesn&#39;t access the selector, it still needs to be present as long as it is loaded into a selector register.) There&#39;s really no point going on about these dark corners of the x86 because they are not practical in any way. And selectors are hardly intended for hardware object orientation, since you would be limited to at most 16382 objects! -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1064073">
				<div id="div-comment-1064073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064073">
			June 29, 2013 at 9:18 am</a>		</div>

		<p>@j b:</p>
<p>I&#39;ll tell you even more. You can access many many gigabytes in a 32 bit process. There are at least two existing mechanisms in Win32 API to do that. I&#39;ll leave it up to you to find out.</p>
<p>It will also be more efficient than the hypothetical segment shuffling behing your back. By the way, FS: is reserved in Win32; you must not modify it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064083">
				<div id="div-comment-1064083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064083">
			June 29, 2013 at 9:37 am</a>		</div>

		<p>@alegr1:</p>
<p>Sure, you&#39;ve got various kinds of windowing mechanisms under application control. When you say &quot;API&quot;, you most likely imply explicit actions to make &gt;12 GB stack+data+code.</p>
<p>Re. &quot;more efficient that the hypthetical segment shuffling&quot;: It was never my intention to suggest a &quot;more efficient&quot; method, but to understand how the x86 segment mechanisms relate to OO addressing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-1064103">
				<div id="div-comment-1064103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064103">
			June 29, 2013 at 11:13 am</a>		</div>

		<p>&quot;Microsoft could have released XP built from the 5.2 branch completely uncapped and did not.&quot;</p>
<p>Or even better, backport the fixes from the 5.2 branch related to PAE to the 5.1 branch.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-1064113">
				<div id="div-comment-1064113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064113">
			June 29, 2013 at 11:17 am</a>		</div>

		<p>&quot;It&#39;s about $300 (remember there&#39;s no terminal server and no CALs needed).&quot;</p>
<p>I think only the Enterprise Edition is licensed to support &gt;4GB. Standard Edition is pretty much the same as client Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-1064123">
				<div id="div-comment-1064123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064123">
			June 29, 2013 at 11:24 am</a>		</div>

		<p>[&quot;I put 4GB of memory in my computer, and I get massive data corruption. Obviously, this is a driver bug, and the clear course of action is to edit some file called &quot;shoes.innie&quot; and type some magic beans, and now my computer has only 0.5GB of memory, so I can&#39;t actually use it for anything, but gosh darn it I&#39;m isolating a driver bug people! On second though, I&#39;ll just buy a Mac.&quot; -Raymond]</p>
<p>Agreed, the right thing would have been to set /MAXMEM:4096 by default and allow /MAXMEM:NONE to be inserted in boot.ini to lift the limit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-1064133">
				<div id="div-comment-1064133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064133">
			June 29, 2013 at 11:43 am</a>		</div>

		<p>BTW, on the matter of XP based on the 5.2 branch, why does &quot;Windows XP Professional x64 Edition&quot; follow the normal XP not Server 2003 support lifecycle?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064143">
				<div id="div-comment-1064143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran Mitrovic</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064143">
			June 29, 2013 at 12:11 pm</a>		</div>

		<p>@Myria: Depends. In my specific case, a third party crashed when LAA was used. :(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-1064153">
				<div id="div-comment-1064153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064153">
			June 29, 2013 at 12:14 pm</a>		</div>

		<p>BTW, what is also frustrating is that there is no 32-bit server version of Win7 or later so the only way to enable &gt;4GB PAE is to binary patch the kernel, especially as Win8 pretty much require the PAE kernel.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1064173">
				<div id="div-comment-1064173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064173">
			June 29, 2013 at 9:24 pm</a>		</div>

		<p>@jb:</p>
<p>Now, how it would work if you need different physical addresses for the same offset in CS: and the other segment? Assuming you say FS and GS can cover all 4GB of separate space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1064183">
				<div id="div-comment-1064183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064183">
			June 29, 2013 at 9:24 pm</a>		</div>

		<p>Also, how about different threads requiring conflicting mapping to emulate 12GB stuff?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064193">
				<div id="div-comment-1064193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064193">
			June 29, 2013 at 9:54 pm</a>		</div>

		<p>[Do you have an app that is bumping into the 8TB limit? Or is this a purely theoretical problem with no practical impact? -Raymond]</p>
<p>8TB is enough for everyone.™</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-andycadley2 odd alt thread-odd thread-alt depth-1" id="comment-1064203">
				<div id="div-comment-1064203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/AndyCadley' rel='external nofollow' class='url'>AndyCadley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064203">
			June 30, 2013 at 3:14 am</a>		</div>

		<p>@Gizen: Many modern cars do have speed limiters that kick in at around 155MPH, regardless of how fast they could theoretically go. Customers don&#39;t tend to complain, since the equally artificial speed limits applied on roads are usually lower still.</p>
<p>@Yuhong Bao: They can&#39;t &quot;backport the fixes from 5.2&quot;, because there weren&#39;t any fixes there. It&#39;s merely an assumption that customers running a Server OS would be doing so on certified hardware with certified drivers, thus avoiding the issue of drivers with truncation bugs, something which rarely applied to home users.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-1064213">
				<div id="div-comment-1064213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064213">
			June 30, 2013 at 3:28 am</a>		</div>

		<p>@AndyCadley: I am sure there probably are at least some fixes from the 5.2 branch related to PAE that were not applied to the 5.1 branch since it doesn&#39;t use PAE for anything other than NX, but you are right that is not the main problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064223">
				<div id="div-comment-1064223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064223">
			June 30, 2013 at 7:09 am</a>		</div>

		<p>Raymond&gt; You can&#39;t provide 12GB (4GB each for CS, DS, SS) [&#8230;]</p>
<p>Sure, if you limit yourself to flatland programming, setting up the segment registers once and for all, with one (or three) 4GB homogenous segment(s), and after that forgetting all about selectors. You identify objects by their (starting) _location_ given by the offset value, used by the application code, the object extends to somewhere out in the fog, and you must go to a different place to tell what access code has to each object. Sure, that is the way we use x86 MMS today.</p>
<p>I happened to grow up with a machine with a not too different MMS. However, established software design style was to use as many segments as you had protection domains. Say, a memory mapped read-only file was a RO _segment_, not a set of flatland RO pages. E.g. a DBMS would offer to the application, as one or more segments, those buffers and tables the application successfully had opened. Once the database was closed, the segments disappeared from the application address space. In those days, 4GB of physical RAM was a future dream, but having a set of data segments that combined fit into and filled 4GB of virtual space (and similar for code and stack) was fully possible. (And it is on the 386 MMS as well.)</p>
<p>This was not an OO machine, but used (as 386 OSes could have) segment descriptors as &quot;capabilities&quot; (a.k.a. handles, object indexes,&#8230;) to actively &nbsp;provide access control through adressability: If you cannot identify a data structure because you do not have the capability for it, there is no way you can corrupt it. You don&#39;t NEED protect bits on page level for data you have no way of addressing. In true capability-style OO addressing, the application carries the capability (/segment, object index, &#8230;) to represent the _object_ itself, not its location. The offset part is (/may be) used in specific methods/functions to address within the object; it in no way identifies the object, the way the offset does in flatland. In flatland adressing, the compiler generates code to enter an object&#39;s location (i.e. offset) into an address register before access, in OO adressing, the compiler generates code to enter an object&#39;s index into a segment register before access. Both are fully available on the x86.</p>
<div class="post">[<em>You&#39;re just restating the x86 selector model. You claim this allows you to create 12GB of simultaneously addressable memory, which is the part I don&#39;t understand. (Selectors specify their location and extent as 32-bit values inside a 32-bit linear address space.) But at this point I don&#39;t care either. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064233">
				<div id="div-comment-1064233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064233">
			June 30, 2013 at 7:10 am</a>		</div>

		<p>Raymond&gt; you would be limited to at most 16382 objects!</p>
<p>(That is of course 48 Ki objects, for data, stack and code.) In the days of capability based architectures, like the 432, several studies of the size of the &quot;object working set&quot; was made, and none of them got even close to 16 Ki as typical, or even maximum. The results were surprisingly _low_: In very few contexts did a given software module actually address more than a few dozen nameable objects, the number of actually visible nameable objects (regardless of whether code addressed them or not) rarely exeeded a few hundred.</p>
<p>This obviously depends a lot on how application data is structured: FORTRAN oriented programmers will declare two dozen single variables with a common name prefix to represent one object; Java and C# people do it differently. A compiler may treat an entire stack frame as one struct object, or it may declare each local variable a distinct objects. Also: The 16 Ki(*3) limit applies to _each process_, both in x86 and any other capability machine I have ever seen; it is certainly not a limit on the system as a whole. If process handling can be made so lightweight that it can be compared to thread handling, the risk of filling up the capability table is not very high. Obviously, if you were to create an OO machine today, you would design for more, but used properly, the 386 limit of 48Ki per process would probably be about as sufficient today as 32 bit flatland address space: Most, although not all, problems can be fit in.</p>
<p>On good days, I am itching to suggest to some master student a thesis work of either making an adaptation of the mono software or the JVM to a standalone (no Windows or other OS support/limitiation) x86 processor, mapping object handles to segment selectors the way the hardware actually permits you to. Certainly: This is a task for a way-above-the-middle student, but I have been impressed earlier. And I would certainly like to see it demonstrated, that it can be done. I know it can, I just don¨t have the time to do it myself :-(</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064253">
				<div id="div-comment-1064253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064253">
			June 30, 2013 at 4:48 pm</a>		</div>

		<p>@Yuhong Bao: I suspect that Windows Server 2003 got an extra year-and-a-bit of support because Windows Server 2003 R2 is based on it. &nbsp;You&#39;ll notice the end-of-life is the same for 2003 and for 2003 R2.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064263">
				<div id="div-comment-1064263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064263">
			June 30, 2013 at 5:51 pm</a>		</div>

		<p>Patching the XP32 kernel to support more than 4 GB of RAM is also legally a bad idea. &nbsp;Enforcement of the 4 GB limit is actually controlled by the licensing code. &nbsp;Thanks to bad laws, that&#39;s illegal, since you&#39;re disabling a copy protection feature by their definition.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1064273">
				<div id="div-comment-1064273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064273">
			June 30, 2013 at 6:55 pm</a>		</div>

		<p>@j b:</p>
<p>Trying to jump through the hoops to simulate separate segment spaces doesn&#39;t make any sense. Because there are simpler means to use more memory. Use memory mapped files, or (God forbid) Address WIndowing Extensions, or split your process to separate processes. Ultimately, nobody cares now, because we all have x64.</p>
<p>Maybe, as a professor, you like to come with impractical assignments. Unfortunately, such assignments don&#39;t make better programmers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064283">
				<div id="div-comment-1064283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064283">
			June 30, 2013 at 7:02 pm</a>		</div>

		<p>@jb: You seem to forget that memory can be protected at the page level with PTEs, and most operating systems nowadays implement the NX bit at least in software. Other than making coding more difficult by having to ensure that you have the right segment (overlay) loaded, I don&#39;t see any advantage to segmentation in modern computers that have caching and paging available; I remember overlays quite well and have no wish to go back to that time. Besides, swapping huge segments in and out has to be a performance hit!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1064293">
				<div id="div-comment-1064293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064293">
			June 30, 2013 at 7:04 pm</a>		</div>

		<p>@j b:</p>
<p>Raymond&gt; you would be limited to at most 16382 objects!</p>
<p>&gt;(That is of course 48 Ki objects, for data, stack and code.)</p>
<p>Nope. 8192 in a single Local Segment Table, and 8191 in a single Global Segment Table. Still 16383 objects.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064243">
				<div id="div-comment-1064243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064243">
			June 30, 2013 at 3:56 pm</a>		</div>

		<p>Raymond&gt; You claim this allows you to create 12GB of simultaneously addressable memory,</p>
<p>Is there any doubt that a process can specify addresses in three logically distinct spaces: Stack, data, code? Yes.</p>
<p>Is there any doubt that each of these three spaces are of size 4 Gi, using 32 bit addresses? Yes.</p>
<p>Does three distinct 4 Gi address spaces add up to 12 Gi virtual addresses, at the application level? Yes.</p>
<p>Can selected ranges of these 3*4Gi addresses be mapped down to a linear address space of 4 Gi? Yes; that is what we got the segment descriptiors for. If the &quot;presnet&quot; bit is set, then that entire segment is mapped to linear space, if reset, the segment is (currently) not in linear space.</p>
<p>The summed sizes of mapped segment at any moment in time cannot exceed 4 Gi, just like the summed sizes of virtual pages mapped to physical RAM cannot exceed the size of physical RAM.</p>
<p>No, you cannot set up three 4 Gi segments and have them all mapped simultaneously to linear space. But you can have a dozen segments of, say, 50 MiB, 200 MiB, 100 MiB mapped to linear space. A little later, the selection of segments mapped to linear space may be a different one. The sum of segments currently present may neever exceed 4 Gi (just like the sum of pages present cannot exceed the RAM size), but they may be taken from a virtual address space of 3*4 Gi.</p>
<p>In a paged system, when a process addresses a non-present page, the interrupt will activate an OS routine to identfy the desired page and map it into phyiscal RAM, possibly after having selected a victim to be removed, to make space. In the segment system, when a process address a non-present segment (in its 3*4 Gi virtual address space), the iterrupt will active an OS routine to identify the desired segment and map it into linerar space, possibly after having selected a victim to be reomoved, possibly after compacting memory. ALL the segments, mapped and unmapped, are just as simultanously addressable as all the virtual pages in a paged memory. Assuming, of course, that the OS provides mechanisms for handling segment not present interrupts from x86 hardware.</p>
<p>In the 70s and 80s, several segment-based mainframes with no paging hardware did their memory administration this way, except that &quot;linear space&quot; was &quot;physical memory space&quot;. THe summed size of the segments of a process most definitely could exceed the size of physical linear meomry space, but one single segment (or sum of segments) could not (just like the sum of active stack, data and code segments cannot exeed linear space).</p>
<p>Oh well. Most programmers seem not to care about the segmenting hardware; they don&#39;t _want_ to understand it. Flatland programming is the PC approach (eeeh&#8230; not &#39;personal computer&#39;&#8230;). A stray C pointer sort of has the right to corrupt any memory structure anywhere in (flat) virtual space. It is a tradeoff: Maybe we save a millisecond execution time &#8211; at the expense of a week of bug hunting time. Hooray!</p>
<div class="post">{<em>But your description does not explain how you can have CS, DS, and SS all refer to different 4GB segments and avoid mapping conflicts. For each of the 4GB segments, the base address must be 0 and the segment size must be 4GB. (There is no other way to fit a 4GB segment into a 4GB address space.) Suppose ESP=0xFFFFF000 and EAX=0xFFFFF000, and somebody performs a &quot;push dword ptr [eax]&quot; that happens to be at address EIP=0xFFFFF000. You have to decide which memory is mapped into linear address 0xFFFFF000, and you can have only one at a time. Just tell me what the base address and size is for each of the selectors, and which pages are mapped. (The only thing I can think of is you are pulling some sneaky base address wraparound trick.) That said, this memory model is what 16-bit Windows used, and everybody hated it. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064303">
				<div id="div-comment-1064303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064303">
			July 1, 2013 at 12:29 am</a>		</div>

		<p>&lt;overly_pedantic&gt; @alegr1: The null selector is reserved, and one of the GDT selectors needs to point to the LDT. &nbsp;8190 + 8191 = 16381. &lt;/overly_pedantic&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064313">
				<div id="div-comment-1064313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064313">
			July 1, 2013 at 1:48 am</a>		</div>

		<p>&gt; [And then your sound card driver corrupts memory due to a truncated DMA address and you blame Windows. (This problem doesn&#39;t exist on Server because servers don&#39;t have sound cards.) -Raymond]</p>
<p>I&#39;ve had problems with a certain very popular (at the time) sound card on XP x64 when I enabled memory remapping in BIOS, so I could use all of my 4GB RAM (sound would only come from the front speakers, and IIRC it was at low volume). Disable remapping (and thus only &quot;see&quot; 3200MB RAM), and the card worked fine.</p>
<p>&gt; I think only the Enterprise Edition is licensed to support &gt;4GB. Standard Edition is pretty much the same as client Windows.</p>
<p>32-bit Server 2003 Standard (and 2008 Standard) allow you to address the full 4GB RAM (and IIRC, XP did as well with /PAE until SP1). However, even that is enough to bring out bugs in drivers (I tried to use a spare 2003 license from work in /PAE mode when I upgraded my home machine to 4GB at first &#8211; the weirdest effect was that the screen would only update approximately once per minute. At first I thought the system was frozen since it was showing the starting up dialog but neither the swirl nor mouse pointer were moving, then the screen went black and after a few seconds the logon dialog appeared; I pressed Ctrl+Alt+Del, and typed my username and password &#8211; and noticed that the C+A+D dialog was still shown &#8211; then the screen went black again, and after a few seconds frozen desktop appeared).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064323">
				<div id="div-comment-1064323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064323">
			July 1, 2013 at 4:27 am</a>		</div>

		<p>@alegr1,</p>
<p>My goal is NOT a Win32 providing 12 Gi virtual space to an application, but to make people understand address mapping without restricting their mind to how aspecific OS uses the mechanisms. I want to point out the direct correspondence between an OO handle, a Win16 handle, an x86 segment selector &#8211; that essentially, the same operationss are done in all cases. </p>
<p>In JVM, everything is software. Could overheadbe reduced by performing some operations in hardware? Which operations? In Win16, the application manually called GlobalLock data handles, to map the object into linear RAN space before use, GlobalUnlock afterwards, maintainig the mapped address in a separate variable. If you forgot to Unlock, linear space would fill up. (For code objects, the runtime system trapped function calls/returns, doing similar Lock/Unlock mapping implicitly.) If you now add 386 segmenting hardware, GlobalLock calls are superflous; saving code, avoiding programming errors. With hardware managing the translated address, the application is freed of the management task, the address is protected against corruption. Hardware IS useful for this kind of mapping.</p>
<p>In 8086 Win16, every application had dozens of data objects / handles, GlobalLocking and Unlocking all the time. 386 segmenting, could have made GlobalLock an empty call &#8211; but it wasn&#39;t carried through fully. Rather, with Win32 the whole world was made one huge object, which, of course made the C pointer arithmetic fans jump with joy. We abandoned segments altogether. (A single 4 Gi segment is segmented addressing the way an election with a single party on ballot is free.) </p>
<p>386 segmenting is a spin-off of an OO machine architecture, most definitely providing a high number of objects. It appeared when (Windows) applications handled numerous handles/objects, mapping them in and out of linear address space. Around 1990, students easily saw the parallells between handles/selectors and objects/segnebts, GlobalLock and hardware segment mapping. Java was on the rise with its handles. Explaining the mechanisms to students was trivial. When Windows abandoned segmenting, returning to flatland, people seemed to abandon all understandig of how object mapping works. One consequence: It is difficult explain to students how a Java or .net program can fit into a 32 bit address space, yet handle far more than 4Gi objects: The program manages handles only. The &quot;managed&quot; data object itself is only visible through the handle, never directly. So the mapping from handle to object must be understood. 386 MMS shows one way of doing it &#8211; once we manage to fence off those arguing &quot;But the segment S 4 Gi large, so it won&#39;t work!&quot; etc. In the end, it turns out as easier to make _students_ understand than to make seasoned C pointer arithmetic fans understand&#8230; :-)</p>
<p>(Oh, by the way: Thanks for pointing out that code, data and stack share GDT/LDT. I was a little too fast on that one!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064333">
				<div id="div-comment-1064333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064333">
			July 1, 2013 at 4:56 am</a>		</div>

		<p>ErikF&gt; Other than making coding more difficult by having to ensure that you have the right segment (overlay) loaded,</p>
<p>Are you having similar problems in ensuring that the right page is loaded into RAM? That is exactly the same problem. And, surprise, surprise: The solution is the same for both problems!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064343">
				<div id="div-comment-1064343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064343">
			July 1, 2013 at 5:13 am</a>		</div>

		<p>Raymond&gt; Suppose ESP=0xFFFFF000 and EAX=0xFFFFF000, and somebody performs a &quot;push dword ptr [eax]&quot; that happens to be at address EIP=0xFFFFF000.</p>
<p>It is sort of difficult to relate to a single, out-of-context machine instruction with no information about what is the desired effect of the instruction. If the compiler chooses to use selctors to identify objects, rather than offsets to identify locations, the generated code would obviously be very different. You can imagine lots of instructions that would be meanigless in that model. That is not specific to using selectors &#8211; even in flatland code you can create semantically meaningless instructions.</p>
<p>If you tell me what you want to do, at a semantic level, I could try to act as a human compiler and suggest a possible instruction sequece to to it. I haven&#39;t been assembler coding for years, so I would probably generate a lot of syntactical errors; I would do much better with informal pseudocode indicating how segment registers and offsets would be used. But my explanation would NOT be assuming that there is a single 4 Gi data segment; but &#8211; as I have stressed several times &#8211; assume a number of smaller segments &#8211; as many segments as the problem solution has objects.</p>
<div class="post">[<em>You claimed to be be able to address 4GB code, 4GB data and 4GB stack simultaneously, so I put it to the test. I created a 4GB stack, 4GB of data, and have 4GB of code. The stack pointer is 0xFFFFF000 (we&#39;ve pushed around 4KB of data so far). The data is a giant array of 32-bit integers, and I&#39;m about to pass the 0x3FFFFC00&#39;th one to a helper function. The code that is doing this happens to be near the end of the 4GB code block, because the first 3.99GB of code consists of a tight loop that has been unrolled a billion times. (But now you&#39;re denying that this is a possibility. &quot;Assume a number of small segments.&quot; Well, okay, but if I assume a number of small segments, then I am not actually addressing 12GB of data simultaneously, which was your original claim.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman even thread-even depth-1" id="comment-1064353">
				<div id="div-comment-1064353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064353">
			July 1, 2013 at 6:35 am</a>		</div>

		<p>@jb:</p>
<p>The x86 family of CPUs are not Harvard Architecture processors. That&#39;s where your whole assertion of separate memory spaces for DS, CS, and SS falls apart. If you reference the original Pentium datasheet (<a rel="nofollow" target="_new" href="http://download.intel.com/support/processors/pentium/sb/24199710.pdf">download.intel.com/&#8230;/24199710.pdf</a>) you do notice a D/C# control signal but it was not always available, notably in dual-CPU systems.</p>
<p>In addition, I am not aware of any north-bridge that supported multiple 4-GB memory spaces. Even if it did, the only distinction it could make is data vs code. So immediately your 4GB stack can never be separated.</p>
<p>Just because you can dream up a method of extending the 32-bit limit does not make it real, nor that Windows should support that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1064373">
				<div id="div-comment-1064373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064373">
			July 1, 2013 at 7:16 am</a>		</div>

		<p>@Myria:</p>
<p>[&lt;overly_pedantic&gt; @alegr1: The null selector is reserved, and one of the GDT selectors needs to point to the LDT. &nbsp;8190 + 8191 = 16381. &lt;/overly_pedantic&gt;]</p>
<p>&lt;extra_pedantic&gt; The null selector is valid in LDT&lt;/extra_pedantic&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064383">
				<div id="div-comment-1064383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064383">
			July 1, 2013 at 7:26 am</a>		</div>

		<p>@Brian EE,</p>
<p>I&#39;ll more or less repeat the same answer that I have given a few times already:</p>
<p>The goal is NOT to build a 32-bit machine to realize 12 Gi of virtual space, but to understand the MMS architecture so well that you understand how it could have been possible. Whether there was an 80386 with external signals to distinguish code, stack, data is certainly not an architectural property, but a pure implementation choice. If the signal most likely wouldn&#39;t be used, it would be a waste assigning it to a pin, even if it could have been.</p>
<p>No, I am NOT asking for Windows support for 12 Gi virtual space. I am just aaying that it IS there, at the virtual level, in the architecture. As I have argued in length above, it could be realized by segmenting and an interrupt handler for &#39;segment not present&#39;. Again: I am NOT asking Windows-developers to implement that. But if you have difficulties understanding how it COULD be done, given the segment mapping hardware, then I am quite sure that you have similar problems undertstanding how an OO runtime environment, addressing object by handles (such as the JVM) could make use of hardware to aid the memory management task. There may be details of 386 MMS that are not perfect for JVM or some similar machine, but if you don&#39;t understand the 386 mechanisms fully, you are not in a position to tell what should be done differently. After all, 386 MMS came out as a &quot;poor man&#39;s OO management&quot;, a small subset (with some extensions) of the 432 OO CPU.</p>
<p>I must admit that I am surprised how readily architectural concepts are pushed aside as of no interest just because some signal line was omitted from an implementation, or some intermediate step in the mapping process imposes some max size on active segments, or whatever. As if people will be using any excuse, no matter how small, to turn down the segment mechanisms, and therefore refuse to relate it to OO concepts. I&#39;ll just have to accept it&#8230;</p>
<div class="post">[<em>If you can&#39;t create 12 GB of virtual space, then don&#39;t open by saying &quot;You can create 12 GB of virtual space.&quot; Because everybody will start poking holes in your claim that you can create 12 GB of virtual space, and then when you come out and say &quot;I&#39;m not saying you can do it&quot; then everybody will just give up and walk away. I don&#39;t see why you&#39;re bothering explaining the segmented memory model to everybody here. You can assume we know how it works. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1064393">
				<div id="div-comment-1064393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064393">
			July 1, 2013 at 7:27 am</a>		</div>

		<p>Let&#39;s sum it up. Windows used to use selectors/segments. It was extremely awkward. Even though the segments were required not to overlap in the linear addresses, there was a big overhead to manage them.</p>
<p>Trying to implement a model where the different segments occupy overlapping linear addresses (while expecting their contents different), thus allowing 12 GB of effective address space is an exercise un futility, especially in multithreaded environment.</p>
<p>We&#39;re engineers. We need to apply our best judgement to decide what can be done, and what should be done, and what should not be done, for that way lies madness.</p>
<p>If you&#39;re not an engineer, it&#39;s understandable that you want to explore this path you think is possible. There are many other considerations that make it unfeasible, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064423">
				<div id="div-comment-1064423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064423">
			July 1, 2013 at 8:04 am</a>		</div>

		<p>@alegr1,</p>
<p>It seems quite obvious that you judge segmented address apace as it appears WITHOUT supporting hardware.</p>
<p>I judge segmented address apace as it appears WITH supporting hardware (the MMS that came with the 386).</p>
<p>On that backgorund, it is no big surprise that we come to different conclusions about the usability of segmenting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064453">
				<div id="div-comment-1064453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dave</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064453">
			July 1, 2013 at 9:45 am</a>		</div>

		<p>&gt;(And again, you aren&#39;t really inventing anything new. Segmented memory has been around since the 80286.)</p>
<p>And a good deal prior to that, too.</p>
<p>Apart from all of the wrangling about whether or not 12GB is or is not simultaneously accessible (and the stack might well be the clincher on that argument), I assume &quot;j b&quot;&#39;s real subject is the current lack of interest in capability systems, and the relative stasis of general-purpose OS design.</p>
<p>Still, I&#39;d blame Unix for all that, not Windows &nbsp;;-)</p>
<p>Part of the design issue here seems to be the aspirations of the average modern OS to run on a wide range of hardware. Two modes, flat address space seems to be the limit of the consensus.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064463">
				<div id="div-comment-1064463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064463">
			July 1, 2013 at 10:07 am</a>		</div>

		<p>Raymond&gt; If the segments are not 4GB each, then how do you get to 12 GB with three selectors?</p>
<p>Eeeeh&#8230; Where should I start?</p>
<p>To compile for a flat architecture, you assign locations to objects. The location is baked into the code. To access the object, instructions load the (flatland) address (baked into the code) into some address register, presented on the address bus. When another object is later accessed, the location of this object is loaded into an address register. Every access could potentially cause a page fault, causing other pages to be thrown out of RAM. If an object member is referenced, user level instructions may have to calculate the sum of the object address and the offset.</p>
<p>To compile for a segment architecture, you assign selectors to objects (one to each object). The selector is baked into the code. To accss the object at runtime, instructions load the selector into a segment register. User code is not concerned about the (base) address of the object; that is managed by the OS segment administration. If a member is addressed, offset within the object is specified in the instruction. If another object is later addressed, its selector is loaded into a segment register. Either access may cause a segment not present fault, and could cause other segments to be thrown out of linear space.</p>
<p>If I make an array of objects,</p>
<p>HalfGiObj[] BigArray = new HalfGiObjt[7]; &nbsp;// each array element fills 500 Mi</p>
<p>foreach (HalfGiObj elt in BigArray) { elt.membervalue = 42; }</p>
<p>the loop addresses 3.5 Gi data apace (other values need the last half Gi!).</p>
<p>The program contains many huge functions, adding up to 4 Gi code, in forty segments of average size 100 Mi. The CALL instruction specifies selector and offset; this could cause a Segment not present interrupt. The handler may have to remove (un-Present) one one or more of the seven HafGiObject segments to make room fo the code segment. If the program calls</p>
<p>&nbsp; FnInCodeSeg01();</p>
<p>&nbsp; FnInCodeSeg02():</p>
<p>&nbsp; &#8230;</p>
<p>&nbsp; FnInCOdeSeg40();</p>
<p>it may have caused all the 4 Gi of code to be mapped into linear space, and mostly unmapped (in competition with other data and code segments.</p>
<p>Each thread requires a stack segment. The thred switching function sets SS to the stack segment associated with the thread. Once the thread starts executing, it may cause a Segment not present, and the handler will map the requested stack segment into linear space &#8211; again: un-Present&#39;ing segments that must yield to make room. Just like in paging. If you have sufficiently mamy threads, the sum of the stack sizes could approach 4 Gi.</p>
<p>Are you saying that this example does NOT show that 12 Gi can be addressed directly by the application? What is missing? How would it appear differently if you really had 12 Gi adressable?</p>
<p>I never said anything about &quot;three selectors&quot; &#8211; I said the exact opposite several times. But you are right: If you insist on three selectors only, three 4 Gi segments, then you cannot map 12 Gi to 32bit linear space. In my example you can.</p>
<div class="post">[<em>(Please stop using strange abbreviations like Gi and Mi and Objt. It makes your writing hard to read.) Yes, this is how segmented addressing works. But notice that you are not accessing 12GB of data <span style="text-decoration:underline;">simultaneously</span>. You are accessing at most three objects simultaneously (code, data, stack). Each one is a half gigabyte in size, so you have only 1.5GB addressable at any particular moment in time. I don&#39;t know why you are denying that you ever mentioned &quot;three selectors&quot;; the number 3 is how you arrived at the meaningless 12 GB value in the first place. Without that magic number 3, your precious number 12 disappears. But the number 12 is also arbitrary. I can create 200 objects, each 500MB in size, and have a loop that goes through all 100 of them, and ta da, by your argument, I have accessed 100 GB of data. All you did was describe segment swapping, which we already know is a way to extend address space (by putting additional address information in the selector). At the end of the day, we&#39;re all saying the same thing. It&#39;s just that you claim to be making 12GB of address space available &quot;simultaneously&quot; when in fact it&#39;s happening sequentially. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1064503">
				<div id="div-comment-1064503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064503">
			July 1, 2013 at 1:00 pm</a>		</div>

		<p>@j b:</p>
<p>OK, another nail (or stake) into this monster of a design. This selector-shuffling approach (which only allows 4 GB of code+data accessible at any given moment, anyway) is no better than using MapViewOfFile without bothering with segments. Because you have to do that anyway (or the runtime will).</p>
<p>When you finally step your foot in the real world outside of your ivory tower, and write your first real complex application, not a student assignment, you&#39;ll see that &quot;doable&quot; and &quot;making sense&quot; are not always the same thing. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064413">
				<div id="div-comment-1064413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064413">
			July 1, 2013 at 7:59 am</a>		</div>

		<p>Raymond&gt; You claimed to be be able to address 4GB code, 4GB data and 4GB stack simultaneously, so I put it to the test.</p>
<p>Hey, do you STILL insist on 4 Gi segment? OK, I once more give you right: If you insist on 4 Gi segments, then you can&#39;t make it work.</p>
<p>Of course you never issue twelve billion memory addresses to the mapping mechanism at the same moment. If you could issue even four billon page addresses to the paging system at exactly the same moment, that would give you some problems, too. (especcially if your machine has less than 4 Gi of RAM).</p>
<p>Obviously: Having a 12 Gi virtual address space means that you can reference *an arbitrary adress* in this address space and the mapping mechanisms will ensure that the proper location is referenced, if necessary after bringing the object into the space where it is addressed.</p>
<p>Sure, you have managed to create one highly artificial situation where you don&#39;t use segmentation for the purposes of segmentation in a productive way, but only as a tool for rejecting the use of the segmentation mechanisms. You&#39;re welcome.</p>
<p>I could set up some REALISTIC example with a couple dozen segments of a total size up to 12 Gi, all directly addressable by the application, and describe how the accesses makes the segments be swapped in and out of linear space just like virtual pages, just to show that it IS possible. Even if you have a hypothetical, unrealistic setup that won&#39;t work, mine would (obviously assuming that there was a handler for the Segment not present interruupt, doing the neecessary administration, which as far as I know Windows does not provide.) No, I am NOT requsting it from Windows &#8211; I am talking about 386 segmenting hardware, not about any specific OS.</p>
<p>Special cases that won&#39;t work within an architecture is nothing new. Another example: The VAX 780 had an instruction for calulating a polynomial up to degree 256. Each of the 256 coefficients could be located another memory page, in addition to the instruction itself which might cross page borders. The VAX could not handle page faults mid-instruction; the prefetch would have to page in all operands and the entire instruction before the execution unit started up. The worst case for this innstruction required 260 pages to be in memory at the same time. At the time of the VAX, not every installation had enough RAM to leave 260 physical RAM pages to a user process, so the worst case instruction would not be executable.</p>
<p>You could deliberately construct code to prove that with a given size RAM, you cannot run an arbitrary polynomial instruction. Similarly, you can define giant segments to prove that some artificial setups will fail with a 32 bit linear address space. It gives you sort of a victory, but a rather insignificant one.</p>
<div class="post">[<em>If the segments are not 4GB each, then how do you get to 12 GB with three selectors? It sounds like you&#39;re really saying, &quot;I can get 12 GB of virtual address space, provided you don&#39;t accidentally place two things at the same location.&quot; That &quot;provided that&quot; prevents the design from being useful, because because when you write code, you don&#39;t don&#39;t really know where your stack pointer is, so you have no way of preventing your stack pointer from accidentally being equal to your code pointer. &quot;Everything works great, and then sometimes it just hangs unpredictable.&quot; Nobody would use a system like that. (And again, you aren&#39;t really inventing anything new. Segmented memory has been around since the 80286.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1064483">
				<div id="div-comment-1064483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064483">
			July 1, 2013 at 11:16 am</a>		</div>

		<p>&gt; strange abbreviations like Gi and Mi</p>
<p>IEEE 1541 &#8211; 11 year old standard</p>
<p>IEC 60027-2 &#8211; 14 year old standard</p>
<p>&gt; you are not accessing 12GB of data simultaneously.</p>
<p>Correct, I am not. I am addressing a few bytes at a time. Whether those bytes are located in a 4Gi segment, a 100 Ki segment or a 4 Ki page makes little difference: Each instruction addresses a few bytes.</p>
<p>Virtual address space does not have to do with referencing at the very same moment. If you have 4 Gi of virtual address space in a paged system, but only 512 Mi of RAM, then you still have 4 Gi of virtual address space. You cannot access all of those 4 Gi simultaneously, either.</p>
<p>Virtual address space has to do with *addressability*, not addressing in one specific operation.</p>
<p>Sure I mentioned three address spaces. Not three selectors, three virtual, non-overlapping (in the virtual space) address spaces, each 4 Gi. By your logic, in a purely paged system (no segments at all) with 4 Ki pages, you can only address 12 Ki, because each of the three pices of information that one instruction references is only 4 Ki, and the rest of the virtual address space or physical RAM is irrelevant, as the instruction doesn&#39;t reference them. Well, this is not the common way of referring to adressability and virtual address spaces.</p>
<p>&gt; I can create 200 objects, each 500MB in size, and have a loop that goes through all 100 of them, and ta da, by your argument, I have accessed 100 GB of data.</p>
<p>If you have a virtual space that will hold those 200 half-gig objects, then you DO have virutal space of 100 Gi. But you can&#39;t fit that into the data segment of a 386. You can fit at most 4 Gi in there, as in my example. &nbsp;And you can fit 4 Gi of code. And stack.</p>
<p>I understand that you have no desire whatsoever to make use of the segment facilities; you set up your 4 Gi segment and then prentend there are no segments, only flatland. OK, do! I program in terms of objects, not in terms of offsets and linear space. I know how mechanisms similar to 386 segmenting could be used to efficiently realize object concepts; you refuse to relate to that. OK, then don&#39;t!</p>
<p>When I initiated this part of the discussion, it was to air a little frustration that NOONE seems to care about hardware support of the 386 segmenting kind. I can easily understand that OS people working from the linear space level, down to the physical RAM chips don&#39;t care, But after all, lots of people claim to program &quot;object oriented&quot;, Java or .net style (here in the sense: With no &quot;pointer&quot; variables holding physical addresses). I sort of hope to make then care about what goes on at runtime, and how close 386 segmenting is to that.</p>
<p>My frustration over the missing interest is old and goes far beyond this blogg; it is certainly not a frustration over your blog, which is one of the better ones on the net. I hope my attempt to bring some light to the 386 segmenting mechanisms have not frustrated your other readers. Keep up the good work.</p>
<div class="post">[<em>Okay, then we agree that there is nothing new here and we&#39;re just quibbling over terminology. (I don&#39;t see why all 200 half-gig objects need to live inside the same data segment. The are by definition not in the same data segment because you put each one in its own segment.) I think I&#39;ve spent more time working with segments than you. I know how they work. I even wrote a system that uses 48-bit pointers for pretty much this exact purpose. But I also know that changing selectors is very expensive on the CPU, so code that changes selectors a lot will pay a significant performance penalty. Also, this entire thread is completely off-topic, and I&#39;m going to delete it in a few days. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064573">
				<div id="div-comment-1064573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064573">
			July 1, 2013 at 8:04 pm</a>		</div>

		<p>I don&#39;t get it? Why does 0x1234:FFFFF000 have to be found anywhere in 0x1235:XXXXXXXX in 32 bit segmentation?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-1064603">
				<div id="div-comment-1064603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064603">
			July 2, 2013 at 12:22 am</a>		</div>

		<p>@Harry Johnston: No it is because Server 2008 was also delayed. They generally set the end of mainstream support to 2 years after the next version release in these cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1064613">
				<div id="div-comment-1064613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">OMG</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064613">
			July 2, 2013 at 12:35 am</a>		</div>

		<p>&gt;&gt;&gt; strange abbreviations like Gi and Mi</p>
<p>IEEE 1541 &#8211; 11 year old standard</p>
<p>IEC 60027-2 &#8211; 14 year old standard</p>
<p>&lt;&lt;</p>
<p>To be a &quot;real&quot; standard, it has to be (widely) accepted. For example, in Gemany, the national standard DIN5008 mandates that in letters and other formal writings a pure numerical date should use the ISO8601 date format (yyyy-mm-dd). By Wikipedia (<a rel="nofollow" target="_new" href="http://de.wikipedia.org/wiki/Datumsformat">de.wikipedia.org/&#8230;/Datumsformat</a>), this is also regulated by a standard of the European Union since 1992.</p>
<p>Nobody cares. So you better stay with the real standard, which (in Germany) is dd.mm.yyyy.</p>
<p>The Wikipedia article puts it this way: &quot;Ähnlich wie in den meisten anderen europäischen Ländern wurde die Norm auch in Deutschland und Österreich weitgehend ignoriert, wo allgemein weiterhin das gewohnte Format TT.MM.[JJ]JJ in Gebrauch blieb. In der Ausgabe von 2001 der DIN 5008 wurde daraufhin eine Anmerkung eingefügt, wonach das gewohnte Format wieder zulässig sein sollte, „sofern keine Missverständnisse entstehen“.&quot;</p>
<p>Which means in English, this regulation was changed in 2001 to re-allow the old format. I think this is a good example for an irrelevant standard, the same way as this &quot;Gi&quot; and &quot;Mi&quot; thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-1064873">
				<div id="div-comment-1064873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1064873">
			July 2, 2013 at 11:23 am</a>		</div>

		<p>@j b: Selectors, in x86 protected mode with paging enabled, point to *virtual* addresses as mapped through the page table. They do not point to *physical* addresses. The translation from segment-relative to virtual addresses happens *first*. Then the virtual address is translated to a physical address via the page tables. The segments can only point to addresses within the 4GB virtual address range; they do not allow access to more than this.</p>
<p>The only possible value for segmentation in 32-bit x86 is to provide a degree of access protection: but the access bits on pages are far more fine-grained, and don&#39;t require you to reserve chunks of the address space for code or data. Windows only sets the FS register to a per-thread selector, whose base address is the start of the Thread Information Block for that thread. All other selectors have a base of 0 and limit of 4GB.</p>
<p>AMD crippled the segmentation support in x86 long mode: only FS and GS really work any more.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1065253">
				<div id="div-comment-1065253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1065253">
			July 3, 2013 at 11:19 am</a>		</div>

		<p>&quot;Do you have an app that is bumping into the 8TB limit? Or is this a purely theoretical problem with no practical impact? -Raymond&quot;</p>
<p>While I don&#39;t have an app that is bumping into the 8TB limit, it&#39;s not purely theoretical. Consider applications that compose a finished movie by taking all the clips that have been recorded and combining them according to some processing instructions (e.g. &quot;take frames A to B of clip X, fade to frames C to D of clip Y&quot; or &quot;compose clip X onto clip Y using chroma key K with filter F starting at frame A&quot;) into a final output file.</p>
<p>Such programs deal with uncompressed images (because compressed images aren&#39;t all the same size, so you couldn&#39;t access frames in random order) in a linear colorspace (16 bits per channel &#8212; what your digital camera might call RAW). The file compression and conversion to log colorspace (8 or 10 bits per channel) is done at the same time in another step.</p>
<p>One way to write such a program is to map all the source files and output file into memory simultaneously so that each frame could be referenced by simple pointer arithmetic. Then you could perform all the processing without having to worry about managing I/O, caches, or buffering. Spend your time optimizing your image processing algorithms instead of I/O. Assign different threads to different ranges of output frames, and you don&#39;t have to ever worry about locking.</p>
<p>This all seems like a reasonable way to write a simple video post-processing system, right? It would certainly work well for a typical home movie maker. It could also work for professional movie studios, if not for the address space limit.</p>
<p>A &quot;4k&quot; camera (like a Canon EOS C500) records at 4096&#215;2160 resolution, yielding 50MB per uncompressed 16bpc frame. A movie is filmed at 24fps (with some being 48 or 60fps), yielding about 1.2GB per second. A good feature length movie averages over 2 hours, so a file containing a raw, uncompressed movie would be at least 8TB in size.</p>
<p>Just to have the complete output file memory mapped, it would need to have over 8TB of address space. To have all of the source files and output file mapped into memory simultaneously, it could require hundreds of TB of address space.</p>
<p>This might not be the best way to write such an application, but it&#39;s certainly not far-fetched in a world where 8TB of disks fit in my pants pockets.</p>
<div class="post">[<em>&quot;I know of an app that could run into the 8TB limit&quot; is an acceptable equivalent, since the question wasn&#39;t whether anybody personally had such an app but rather whether this is a practical or theoretical issue. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1065333">
				<div id="div-comment-1065333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1065333">
			July 3, 2013 at 2:18 pm</a>		</div>

		<p>@Gabe:</p>
<p>Having the files mapped would be big waste of the OS resources, and unnecessary, too. Just the page tables would take 16 GB (actually more than that)</p>
<p>Remember that access to memory mapped files usually results in small (page-sized) in-page I/O. There is no guarantee that the OS will do read-ahead.</p>
<p>It&#39;s much more efficient to read the files as necessary into the frame-sized buffers in big I/O requests. Buffers would serve as frame cache and be discarded according to LRU.</p>
<p>It totally doesn&#39;t make sense to memory map the output file. For best throughput you&#39;re better off with writing the file out with no OS buffering in big chunks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-1065363">
				<div id="div-comment-1065363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1065363">
			July 3, 2013 at 11:30 pm</a>		</div>

		<p>@alegr1: I wonder if memory mapped files based on 2MB pages are possible, especially given the speed of today&#39;s disks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1065453">
				<div id="div-comment-1065453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130628-00/?p=3963#comment-1065453">
			July 4, 2013 at 9:45 am</a>		</div>

		<p>@Youhong Bao:</p>
<p>2MB pages are non-pageable, because finding a suitable free contiguous 2MB page for page-in in a system with 4KB pages is an exercise in futility.</p>
<p>This is why you need SeLockMemoryPrivilige to allocate them.</p>
<p>I think Raymond covered this issue once.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

