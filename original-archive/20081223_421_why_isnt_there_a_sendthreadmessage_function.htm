<html>
<head>
<title>Why isn't there a SendThreadMessage function?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why isn&#8217;t there a SendThreadMessage function?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 23, 2008 / year-entry #422</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>42</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Here's an interesting customer question: Windows has PostMessage and SendMessage. It also has PostThreadMessage but no SendThreadMessage. Why isn't there a SendThreadMessage function? Am I forced to simulate it with an event? What would this imaginary SendThreadMessage function do? Recall that SendMessage delivers the message directly to the window procedure; the message pump never sees...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>Here's an interesting customer question:</p>
<blockquote class="m"><p> Windows has <code>PostMessage</code> and <code>SendMessage</code>. It also has <code>PostThreadMessage</code> but no <code>SendThreadMessage</code>. Why isn't there a <code>SendThreadMessage</code> function? Am I forced to simulate it with an event? </p>
</blockquote>
<p> What would this imaginary <code>SendThreadMessage</code> function do? Recall that <code>SendMessage</code> delivers the message directly to the window procedure; the message pump never sees it. The imaginary <code>SendThreadMessage</code> function would have to deliver the message directly to.... what? There is no "thread window procedure" to deliver it to. </p>
<p> Okay, maybe you still intend to process the thread message in your message pump, but you want the caller of the imaginary <code>SendThreadMessage</code> function to wait until you've finished processing the message. But how does it know when you're finished? It can't wait for <code>DispatchMessage</code> to return, since <code>DispatchMessage</code> can't dispatch thread messages. (Where would it dispatch them <i>to</i>?) The processing of the thread message is completely under the control of the message pump. The window manager gives it a thread message, and as far as the window manager is concerned, that's the end of the story. </p>
<p> You might say that the processing of the thread message is complete when somebody next calls <code>GetMessage</code> or <code>PeekMessage</code>, but there's no guarantee that the next call to a message-retrieval function will come from the message pump. Handling the thread message may result in a call to <code>MessageBox</code>, and as a modal function, it will have its own message loop, which will call <code>GetMessage</code>, resulting in your imaginary <code>SendThreadMessage</code> function deciding that message processing is complete when in fact it's still going on. </p>
<p> What should you do instead? Just create a window and send it a message. The scenarios where you would want to use the <code>PostThreadMessage</code> function are very limited and specialized. Under normal circumstances, you should just send a regular window message. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-694603">
				<div id="div-comment-694603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694603">
			December 23, 2008 at 2:44 pm</a>		</div>

		<p>This makes me think, you can probably create a deadlock by having thread A not call DispatchMessage() in its message pump and having thread B call SendMessage() on an HWND created by thread A.</p>
<p>That is&#8230; &nbsp;SendMessage() sends something &quot;directly to a window procedure&quot; which works fine if you send a message to your own thread, but if you do so to another thread&#8217;s window it requires synchronization and my guess is it relies on the message pump to get it done.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694643">
				<div id="div-comment-694643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Knoeller</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694643">
			December 23, 2008 at 5:07 pm</a>		</div>

		<p>Actually, there is a good reason to have a SendThreadMessage function, or rather a SendNotifyThreadMessage function. &nbsp;because the message queue that cross-thread SendMessage uses is of higher priority than the PostMessage queue. </p>
<p>Because you can SendNotifyMessage() to other threads&#8217; windows, but only PostMessage() to the thread that owns the windows, its impossible to preserve message order between the messages to the thread and messages to threads&#8217; windows.</p>
<div class=post>[<i>But where would you put this imaginary &#8220;notify thread message&#8221;? Are you just treating it as &#8220;post to front of queue&#8221;? That&#8217;s not what SendNotifyMessage does. SendNotifyMessage <u>bypasses</u> the queue. it is not a &#8220;PostMessage with high priority.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694673">
				<div id="div-comment-694673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://rcl@mail.ru' rel='external nofollow' class='url'>RCL</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694673">
			December 23, 2008 at 6:45 pm</a>		</div>

		<p>It&#8217;s unbelieveable how Win32 API mixes two completely separate things: threads and window events. Why the very thing called &#8220;thread message loop&#8221; exist, despite the fact that most of threads (at least in games) have nothing to do with UI windows whatsoever? A rhetoric question&#8230;</p>
<div class=post>[<i>Of course they mix &#8211; how would you keep them completely separate? How can you expect to run an event without a thread? (Maybe they run in magical fairy land.) If your thread has nothing to do with UI, then don&#8217;t give it a message loop. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-694683">
				<div id="div-comment-694683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694683">
			December 23, 2008 at 7:29 pm</a>		</div>

		<p>RCL: you can&#8217;t have a message loop without a thread.</p>
<p>Just because you can have a thread without a message loop doesn&#8217;t mean the two are unrelated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694713">
				<div id="div-comment-694713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694713">
			December 23, 2008 at 8:00 pm</a>		</div>

		<p>Raymond &amp; Dean Harding: I was actually complaining about the fact that every thread has its own message queue. I can&#8217;t see the necessity of this, neither can I see how threads and window messages are related. Why not relate threads and file handles or sockets then?</p>
<p>&quot;Message queues&quot; could have been separate kernel objects not directly related to threads, but rather to windows (HWNDs). Any thread could have peek/get/handle the messages from the queue(s).</p>
<p>Sure, it&#8217;s just pure theory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-694733">
				<div id="div-comment-694733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694733">
			December 23, 2008 at 10:22 pm</a>		</div>

		<p>It&#8217;s easy to say that, but I think you&#8217;d end up with all sorts of issues if you actually tried to do it that way. For example, what if the WM_KEYDOWN event is processed by one thread, and WM_KEYUP by another? It&#8217;d be a synchronisation nightmare &#8211; far simpler to just limit the UI to a single thread.</p>
<p>I&#8217;m guessing it&#8217;s also a historical thing &#8211; in 16-bit Windows, there was only one thread anyway.</p>
<p>Besides, it&#8217;s my understanding that the message queue data structures are not actually allocated until it&#8217;s actually used. So if you have a thread which does no UI stuff, no queue is created.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694753">
				<div id="div-comment-694753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694753">
			December 23, 2008 at 10:44 pm</a>		</div>

		<p>Dean Harding: processing events from a single HWND in two different threads would have made no more sense than, say, opening a file handle and reading it in two different threads at once. If one really needed that, he/she could have used usual means of synchronization provided by kernel.</p>
<p>About message queue not being created when not used: I&#8217;d like Raymond confirm this. This &#8211; &nbsp;<a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms644928" rel="nofollow">http://msdn.microsoft.com/en-us/library/ms644928</a>(VS.85).aspx &nbsp;says explicitly</p>
<p>&quot;The system automatically creates a message queue for each thread.&quot;</p>
<p>In my opinion, backward compatibility seems to be the only reason to have such a &#8230; khm&#8230; weird design.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694763">
				<div id="div-comment-694763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694763">
			December 23, 2008 at 11:03 pm</a>		</div>

		<p>Ok, I found the part of documentation, where it is said, that message queue is not created until first GDI call.</p>
<p>Still, that does not excuse the design and does not fully cure its ineffeciences. What if I just want to paint an image in memory using GdiPlus primitive drawing functions?</p>
<p>Having threads and UI messages linked to each other (and even worse, making a single queue for all the windows that thread could open) should not be considered normal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694773">
				<div id="div-comment-694773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694773">
			December 23, 2008 at 11:38 pm</a>		</div>

		<p>RC,</p>
<p>Drawing and message processing are two unrelated things. The message queue is created NOT on the first GDI call (GDI is unrelated to the messages), but on a first of GetMessage, PeekMessage, and a few other calls.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694783">
				<div id="div-comment-694783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694783">
			December 23, 2008 at 11:56 pm</a>		</div>

		<p>Alexander,</p>
<p>what are your sources? Mine is <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms644927" rel="nofollow">http://msdn.microsoft.com/en-us/library/ms644927</a>(VS.85).aspx</p>
<p>&quot;To avoid the overhead of creating a message queue for nonâ€“GUI threads, all threads are created initially without a message queue. The system creates a thread-specific message queue only when the thread makes its first call to one of the User or Windows Graphics Device Interface (GDI) functions.&quot;</p>
<p>They don&#8217;t mention Get/PeekMessage specifically, quite the contrary, they state that any GDI call will get the queue created.</p>
<p>Your words of course sound reasonable, but let&#8217;s not assume that the people who implemented UI message handling that way have enough common sense. Cite your sources, if you please.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694793">
				<div id="div-comment-694793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Knoeller</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694793">
			December 24, 2008 at 1:37 am</a>		</div>

		<p>Raymond. &nbsp;Granted that you have access to the source code and I don&#8217;t. &nbsp;But from my experimentation, it appears that when SendMessage is used to send a message to another thread&#8217;s window, it doesn&#8217;t bypass the queue so much as use a special high priority queue. &nbsp;The thread owning the window doesn&#8217;t get the &#8216;sent&#8217; message until it calls GetMessage or PeekMessage. &nbsp;Then while it&#8217;s &lt;b&gt;inside&lt;/b&gt; GetMessage, it gets hijacked to handle the sent message.</p>
<p>If you have multiple threads sending messages to a single thread&#8217;s window, how would you handle contention between them if not with a queue?</p>
<div class=post>[<i>This isn&#8217;t a source code thing &#8211; the behavior of message queues (and non-queued messages) has been documented since Petzold. Sent messages do not go into the message queue; they go into a different place (I don&#8217;t know if it has a name) that is checked by GetMessage and friends. If you don&#8217;t have access to Petzold or MSDN, as a last resort you can read my book for a description of how message processing works. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694803">
				<div id="div-comment-694803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694803">
			December 24, 2008 at 1:44 am</a>		</div>

		<p>I can see how if message queues were created now, they might just be separate objects one could create at will, and associate with every window, timer, power state broadcast, etc. Since I can&#8217;t imagine how or why I would write a Windows app where a message queue was services by multiple threads, I don&#8217;t see where it would do any good.</p>
<p>In theory you could have Thread A grab a message from the queue, then have Thread B grab another message while Thread A was processing the first message. But then you would have to do all kinds of locking and Thread B would end up having to wait for Thread A anyway, so why bother?</p>
<p>By having message queues associated with threads, no locking or waiting is necessary. If you need to have a message processed in the background, use a worker thread for it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694813">
				<div id="div-comment-694813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694813">
			December 24, 2008 at 1:54 am</a>		</div>

		<p>John Knoeller: Since each sender has to wait until their message is processed, no thread can have more than a single message pending at a time. This means that each message queue could have a mutex, and everybody that wants to SendMessage the thread can wait on the mutex.</p>
<p>In this implementation it&#8217;s actually the kernel doing the queueing (on the mutex wait), and there&#8217;s no guarantee that it&#8217;s actually a queue (as opposed to threads just being randomly chosen).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694823">
				<div id="div-comment-694823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">IMil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694823">
			December 24, 2008 at 2:11 am</a>		</div>

		<p>RCL: The MSDN article says &quot;User or GDI functions&quot;.</p>
<p>As you may learn from MSDN (if not from common sense), GetMessage is a function from user32.dll.</p>
<p>After all, if Windows behaved as you imagine, it would be quite hard to write a working program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694833">
				<div id="div-comment-694833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Newbie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694833">
			December 24, 2008 at 3:14 am</a>		</div>

		<p>Raymond says: &#8220;If your thread has nothing to do with UI, then don&#8217;t give it a message loop&#8221;.</p>
<p>If I have a non-UI worker thread and I want to tell it (asynchronously) to do something, what would be a good technique/API to use?</p>
<div class=post>[<i>You have sooooo many options available. For example, a linked list and a semaphore is a popular technique. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694853">
				<div id="div-comment-694853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabest</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694853">
			December 24, 2008 at 6:09 am</a>		</div>

		<p>PeekMessage will surely create that message loop, I know it from experience. Sometimes the thread may miss a message if it cannot reach the first peek or get function fast enough, therefore I create those threads this way:</p>
<ul>
<li>
<p>CreateThread, wait event, post messages</p>
</li>
<li>
<p>PeekMessage (no remove), set event</p>
</li>
</ul>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694913">
				<div id="div-comment-694913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694913">
			December 24, 2008 at 11:24 am</a>		</div>

		<p>RCL,</p>
<p>To analyze this and other design choices, consider:</p>
<ol>
<li>How much synchronization do you want to access your windows</li>
<li>
<p>Do you want your messages ordered or not.</p>
</li>
<li>
<p>And other.</p>
</li>
</ol>
<p>You don&#8217;t like that messages for a given window can only be fetched by the creator thread. You also want a message queue per window, not per thread. Let&#8217;s see what consequences you&#8217;ll get.</p>
<p>Suppose, you got a message queue per window. Now, how would you implement GetMessage(). Should it go through a list of windows to find out which window has a message.</p>
<p>Suppose, you allow multiple threads (thread pool) to handle messages for a group of windows. How would you provide a synchronization? You would need to acquire mutexes/crtical sections every here and there, and in the result, you&#8217;d really allow to one thread to proceed at any given time. How would you make sure that a sequence of messages for a given window is only handled by a single thread? And on, and on.</p>
<p>BE careful what you wish for. You may be opening a big can of worms. You know, even with the current window threading model, if you mix threads associated with different threads in a single window hierarchy, you get deadlock hazard here and there, unless you&#8217;re EXTREMELY careful and you know EXACTLY what you&#8217;re doing. If you allow free thread-window association, it only becomes worse.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694963">
				<div id="div-comment-694963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">fschwiet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694963">
			December 24, 2008 at 1:36 pm</a>		</div>

		<p>The tight coupling between threads and message queues is a historical artifact. &nbsp;Its not worth criticizing as its obvious been effective in supporting a lot of software. &nbsp;If you had the freedom to do it over though (which you don&#8217;t) you could do better.</p>
<p>You don&#8217;t see this type of coupling in MSMQ.</p>
<p>My gripe is the existence of SendMessage(). &nbsp;It forces the wndproc to have to handle re-entrancy. &nbsp;You don&#8217;t see that sort of behavior is MSMQ either.</p>
<p>There&#8217;s probably good reasons for this (ie, people wanted to camp the stack until they get their result, rather than go asynchronous) but it really did muddle the model imo.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-694973">
				<div id="div-comment-694973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694973">
			December 24, 2008 at 2:01 pm</a>		</div>

		<p>fschwiet,</p>
<p>MSMQ is overkill for window messages.</p>
<p>SendMessage doesn&#8217;t give you arbitrary reentrancy. Your WndProc can only be called in certain code points. And yes, its synchronous return simplifies your code design.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-694873">
				<div id="div-comment-694873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-694873">
			December 24, 2008 at 6:35 am</a>		</div>

		<p>Gabe: are you comfortable with current Windows implementation, where</p>
<p>a) message queue is not associated with HWND, but a thread, so messages from multiple windows are pumped through single loop</p>
<p>b) thread can receive messages only from the windows it created and you cannot change window-to-thread mapping (correct me if I&#8217;m wrong)?</p>
<p>But even if you&#8217;re fine with this, that does not mean that this implementation is a) logical b) efficient</p>
<p>IMil: Ok, I understand, that message queue gets created when I call GetMessage(). But is it created when I call any GDIPlus (which may wrap around GDI) function? My understanding of MSDN is that it *is* also created then. </p>
<p>I don&#8217;t have Windows right now to test that, but I&#8217;d like to spawn ~1k threads (to get statistically meaningful results) and then make them all call some innocent GdiFunc to see how memory consumption changes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695113">
				<div id="div-comment-695113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695113">
			December 25, 2008 at 12:10 am</a>		</div>

		<p>RCL,</p>
<p>I don&#8217;t quite understand what threading model you propose. Can you describe it with more details? We only saw what you don&#8217;t like in window-thread affinity model. Which model you would like?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695063">
				<div id="div-comment-695063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695063">
			December 24, 2008 at 6:22 pm</a>		</div>

		<p>Alexander,</p>
<p>I don&#8217;t think that serializing/ordering events from multiple windows is a common case. If one really wanted that, he/she would go through the pains you described, but I think it&#8217;d be rare. Unless someone has weird dependency problems between his/her windows, but that constitutes bad engineering anyway (AFAIK windows does not guarantee any ordering of messages from multiple windows even now, so it&#8217;s not safe to rely on).</p>
<div class=post>[<i>I dunno, if I click on an object in one window, then click on an object in another window, I want those clicks to be processed in order. You apparently don&#8217;t mind if the events are processed out of order. I guess I&#8217;m a weirdo. -Raymond</i>]</div>
<p>Tying such different concepts as threads and window messages makes Win32 API *really ugly*. Look at this side effect: you *HAVE* to differentiate, whether thread creates any windows or not &#8211; even if this creation is hidden in some obscure API function:</p>
<p><a href="http://msdn.microsoft.com/en-us/library/ms687025" target=_new rel=nofollow rel="nofollow">http://msdn.microsoft.com/en-us/library/ms687025</a>(VS.85).aspx</p>
<p>&#8220;Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the CoInitialize function. Therefore, if you have a thread that creates windows, use MsgWaitForMultipleObjects or MsgWaitForMultipleObjectsEx, rather than WaitForMultipleObjects.&#8221;</p>
<p>heh, the Windows way&#8230; </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695213">
				<div id="div-comment-695213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695213">
			December 25, 2008 at 11:23 am</a>		</div>

		<p>I &#8220;propose&#8221; normal threading model, as it is implemented in other OSes (before and after 1985), which do not stem from amateurish graphical &#8220;shell&#8221; on top of &#8220;disk operating system&#8221;.</p>
<p>Threads (and processes of course) should not be tied to GUI. Moreover, window management shouldn&#8217;t be inside the kernel at all. Kernel should (and does) offer various mechanisms for inter-process communication (and synchronization), which could be used for implementing UI with messaging model of your choice.</p>
<p>I&#8217;m not elaborating further on this, because it&#8217;s all pure theory. Windows is built upon backward compatibility and that&#8217;s its &#8220;killer feature&#8221;. When Windows started to give up some backward compatibility (vide Vista) it immediately lost its attractiveness as a platform (people remain with XP and some even start looking for alternatives).</p>
<p>Because of this, you (we) are doomed to live with design decisions of some unknown 2nd grade student who worked part-time at Microsoft in early 1980s.</p>
<div class="post">[<i>I always wonder about people who think that insulting someone is a good way to have a conversation. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695243">
				<div id="div-comment-695243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Heffernan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695243">
			December 25, 2008 at 2:32 pm</a>		</div>

		<p>[I dunno, if I click on an object in one window, then click on an object in another window, I want those clicks to be processed in order. You apparently don&#8217;t mind if the events are processed out of order. I guess I&#8217;m a weirdo. -Raymond]</p>
<p>Oh how I laughed as the house of cards came crashing down. &nbsp;Nice one Raymond and please keep up the great work in spite of the occasional rude and abusive client&#232;le!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695313">
				<div id="div-comment-695313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695313">
			December 25, 2008 at 3:14 pm</a>		</div>

		<p>As for language, I beg the pardon for being rude. I&#8217;m trying to be rude to technical things, not the people :) and only if I see some objective flaws which I can prove. However, using &#8220;2nd grade student&#8221; as an insult is what I&#8217;m very sorry for.</p>
<div class=post>[<i>Here&#8217;s an idea. Instead of only being rude to technical things, try not being rude at all. Just an idea. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695323">
				<div id="div-comment-695323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Heffernan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695323">
			December 25, 2008 at 3:28 pm</a>		</div>

		<p>&quot;I can think of a scenario, where painting to a window may be costly (even without some kind of buffering), so processing of WM_PAINT message will affect responsiveness of an unrelated window.&quot;</p>
<p>Paint to a bitmap in a different thread and then blt it to the window in the UI thread. &nbsp;That way you keep the UI responsive. &nbsp;Synchronising between the two threads in this hypothetical example is not difficult due to Win32&#8217;s exceedingly rich threading and synchronisation API.</p>
<p>As a point of information, you say &quot;Moreover, window management shouldn&#8217;t be inside the kernel at all.&quot; &nbsp;Well, it isn&#8217;t, it&#8217;s in userland in DLLs like user32, comctl32, shell32 etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695333">
				<div id="div-comment-695333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695333">
			December 25, 2008 at 3:42 pm</a>		</div>

		<p>David,</p>
<p>I realize that such problem has a &quot;real-life&quot; solution like the one you described :)</p>
<p>However, my point is: by using a different (orthogonal to threading) messaging scheme, you could</p>
<p>a) have more choice about in which thread and in which order you&#8217;re going to process messages</p>
<p>b) avoid allocation of any UI-related resources when you don&#8217;t really need it in thread (and without &quot;User or GDI function called&quot; hackery).</p>
<p>Current Win32 forces you to:</p>
<p>1) track whether your thread has ever created any window, directly or indirectly, and use different set of thread synchronization functions if it has (e.g. WaitForMultipleObjects vs MsgWaitForMultipleObjects)</p>
<p>2) create windows which messages need to be processed in order in a single thread, possibly complicating your app and/or inflicting performance hit</p>
<p>3) be careful about calling &quot;User or GDI functions&quot; in purely worker threads, because they may allocate additional resources (e.g. message queue) for your thread, which may also affect memory footprint and/or performance (with certain number of threads).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695223">
				<div id="div-comment-695223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695223">
			December 25, 2008 at 11:49 am</a>		</div>

		<p>[I dunno, if I click on an object in one window, then click on an object in another window, I want those clicks to be processed in order. You apparently don&#8217;t mind if the events are processed out of order. I guess I&#8217;m a weirdo. -Raymond]</p>
<p>Raymond,</p>
<p>First of all, is it guaranteed *now*? What if those two windows were created by different threads with different message loops?</p>
<p>Aside from the fact that there would be probably no less than 100ms delay between your clicks (unless you are really quick :) ), such synchronization can be achieved by other, more &#8220;clean&#8221; ways than pumping &nbsp;messages from *all* the windows through a single loop.</p>
<p>Of course, it&#8217;s all pure theory, but threading model could have provided the means to wait for a message on a set of HWNDs (just like select() waits on a set of sockets for incoming data) and this way you could order/serialize messages in any possible way.</p>
<p>Conceptually, sending and receiving window messages is similar to communication through the network, so you may borrow ready paradigms and solutions from that area.</p>
<p>Now, how would you solve that problem with *current* Win32 implementation?</p>
<p>Suppose that you have two windows created by two different threads, and you have two events happening simultaneously (let&#8217;s suppose you&#8217;re able to click quickly :)) in them. How do you guarantee that those clicks will be processed in order?</p>
<div class="post">[<i>The problem with the &#8220;pass a list of HWNDs&#8221; is keeping track of that list of HWNDs. This can get complicated when a window you create in turn creates child windows or hidden worker windows that you don&#8217;t know about. I&#8217;m wondering whether you&#8217;re just designing a system on the fly or whether you are referring to some unnamed working window system. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695383">
				<div id="div-comment-695383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695383">
			December 25, 2008 at 8:41 pm</a>		</div>

		<p>[The problem with the &#8220;pass a list of HWNDs&#8221; is keeping track of that list of HWNDs. This can get complicated when a window you create in turn creates child windows or hidden worker windows that you don&#8217;t know about. I&#8217;m wondering whether you&#8217;re just designing a system on the fly or whether you are referring to some unnamed working window system. -Raymond]</p>
<p>Once again you pointed to some potential problem I overlooked. However, I still believe that this may be solved without resorting to single queue per thread.</p>
<p>Solution 1 (obvious, but not convenient for applications and not possible with current API which may create hidden parentless windows):</p>
<p>&nbsp;manually keep track of all HWNDs created when dispatching messages. Signal by a special message about creation of child HWND.</p>
<p>Solution 2 (convenient, but somewhat &#8220;blurs&#8221; my proposition, making analogy with sockets less clear):</p>
<p>&nbsp;route messages from children windows through parent&#8217;s message queue by default. That way we will have a single queue for the whole window hierarchy, but it&#8217;s still better than having a single queue rigidly associated with thread.</p>
<p>Yes, I&#8217;m &#8220;designing&#8221; it on the fly, however, I remember that OS/2 had somewhat similar approach &#8211; e.g. <a href="http://www.edm2.com/os2api/Win/WinCreateMsgQueue.html" target=_new rel=nofollow rel="nofollow">http://www.edm2.com/os2api/Win/WinCreateMsgQueue.html</a></p>
<div class=post>[<i>I think you will find, upon closer investigation, that OS/2 message queues are per-thread, not per-window. They are, in fact, pretty much identical to Win32 message queues. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695393">
				<div id="div-comment-695393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695393">
			December 25, 2008 at 10:13 pm</a>		</div>

		<p>RCL: &quot;Current Win32 forces you to:&quot; &lt;3 items&gt;</p>
<p>All of those are non-problems. 1) If you create a non-GUI thread, you don&#8217;t care if any non-GUI API created a window. If it did, it&#8217;s not well-designed. Better designed API creates its own thread; I&#8217;m pretty sure GDI+ does exactly that.</p>
<p>2) Yyour I code operates on certain set of your data; menu command and window messages can modify that data and change some global state. If you want to do that multithreaded, OK, but the pain that you inflict on yourself by having to syncronize access to the shared state exceeds any hypotetical gain. Typical design implies all GUI state managed by a single thread, and any possible long-running operations performed by worker threads. EVen with that simple scheme many people fail to implement necessar synchronization.</p>
<p>3) the issue is not resources. You don&#8217;t have to care whether you accidentally created a message queue. In fact, if you called a function that creates a message queue implicitly, you most likely want the queue.</p>
<p>I still fail to see what you&#8217;d gain from your proposed changes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695233">
				<div id="div-comment-695233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695233">
			December 25, 2008 at 2:26 pm</a>		</div>

		<p>[I always wonder about people who think that insulting someone is a good way to have a conversation. -Raymond]</p>
<p>I&#8217;m not a native English speaker and I have no idea how do my words *feel*, but neither &quot;2nd grade student&quot; for an early 1980s Microsoft employee nor &quot;amateurish graphic shell&quot; for Windows in 1985 are insults. I think I&#8217;m close to truth in former case and fair in the latter. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695263">
				<div id="div-comment-695263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695263">
			December 25, 2008 at 2:42 pm</a>		</div>

		<p>David,</p>
<p>if you laughed, I suppose that you take for granted, that Windows guarantees some kind of ordering *now*. So please tell, whether it is actually possible to have Raymond&#8217;s clicks processed in order, if those windows were created by different threads? Let&#8217;s see if this is really a &#8220;common case&#8221;.</p>
<div class="post">[<i>This topic is covered in my 2005 PDC talk, &#8220;Five things every Win32 programmer should know.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695273">
				<div id="div-comment-695273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Heffernan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695273">
			December 25, 2008 at 2:49 pm</a>		</div>

		<p>&quot;Now, how would you solve that problem with *current* Win32 implementation?</p>
<p>Suppose that you have two windows created by two different threads, and you have two events happening simultaneously (let&#8217;s suppose you&#8217;re able to click quickly :)) in them. How do you guarantee that those clicks will be processed in order?&quot;</p>
<p>Why would you want to solve this problem? &nbsp;That is why would you create UI windows in different threads within the same app? &nbsp;If you just follow the rules and do all GUI in a single thread then everything is peachy. &nbsp;Do you actually have a credible scenario in which you need to create UI windows in different threads within the same app?</p>
<p>It&#8217;s a bit bizarre for someone who professes to know nothing about Windows starts a fight with Raymond on the topic of Windows messages!</p>
<p>And as for your language, as a native English speaker I can assure you that &quot;amateurish graphic shell&quot;, &quot;heh, the Windows way&#8230; &quot; and &quot;doomed to live with design decisions of some unknown 2nd grade student&quot; are offensive and rude.</p>
<p>Raymond is spot on, if you framed your questions in a polite and respectful manner the knowledgeable people here would have been more inclined to engage. &nbsp;That&#8217;s just basic human nature. &nbsp;A good rule of thumb is only ever to write something that you would be prepared to say face to face to a colleague or friend.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695283">
				<div id="div-comment-695283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Heffernan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695283">
			December 25, 2008 at 2:51 pm</a>		</div>

		<p>RCL:</p>
<p>&quot;I suppose that you take for granted, that Windows guarantees some kind of ordering *now*. So please tell, whether it is actually possible to have Raymond&#8217;s clicks processed in order, if those windows were created by different threads?&quot;</p>
<p>No, but the point is that you run the UI out of a single thread and then the ordering is guaranteed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695303">
				<div id="div-comment-695303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695303">
			December 25, 2008 at 3:08 pm</a>		</div>

		<p>&gt; Why would you want to solve this problem? &nbsp;That is </p>
<p>&gt; why would you create UI windows in different threads </p>
<p>&gt; within the same app? &nbsp;If you just follow the rules </p>
<p>&gt; and do all GUI in a single thread then everything is </p>
<p>&gt; peachy. &nbsp;Do you actually have a credible scenario in </p>
<p>&gt; which you need to create UI windows in different </p>
<p>&gt; threads within the same app?</p>
<p>Let me tell why we&#8217;re talking about that problem</p>
<p>1) I complained about current implementation of threads, where every thread has a messages queue (even in cases where it doesn&#8217;t actually want it, e.g. if it only calls GDI functions).</p>
<p>2) Asked to propose something better I described a possible scheme, where message queues are bound to HWNDs and messages are received more or less the same way as datagrams are received by sockets.</p>
<p>3) Alexander Grigoriev (and Raymond) told me, that this scheme would introduce synchronization problems and out-of-order message handling. Raymond offered an example, where in order message handling would be preferable.</p>
<p>4) I proposed using the mechanism similar to select() on the set of sockets to wait for a message on set of HWNDs and thus process them in order.</p>
<p>5) Fighting back, I asked, how would they implement in order processing with current rigid binding message queues to threads to show, that current implementation *has* synchronization problems, which cannot be addresed as easily as in my imaginary scheme.</p>
<p>My example is not purely theoretical, although its primary role is to show that flaw already exists. Doing all the GUI in single thread is not a generic solution. I can think of a scenario, where painting to a window may be costly (even without some kind of buffering), so processing of WM_PAINT message will affect responsiveness of an unrelated window.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695403">
				<div id="div-comment-695403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RCL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695403">
			December 25, 2008 at 11:47 pm</a>		</div>

		<p>Alexander,</p>
<p>1) Imagine that you are writing a crossplatform application, where you have to abstract system-specific functions like synchronization (yes, I know about pthreads-win32). Now, how do you know if thread that calls that function will ever create windows (in Windows sense)? Do you have to contaminate your API with parameters like bWillCreateWindows passed to synchronization functions?</p>
<p>2) This is indeed less of a problem. Still, current implementation ties your windows to thread that created them, which I perceive as a limitation.</p>
<p>3) Won&#8217;t such an implicitly created queue cause problems for a thread without message loop? And I have no idea about overhead caused by worker thread having its own message queue, but no matter how small it is, it&#8217;s conceptually wrong to assume that threads are somehow related to GUI subsystem. It&#8217;s more or less the same as allocating a per-thread buffer for receiving network messages no matter whether this thread will ever create a socket (and later &quot;improving&quot; it by allocating the said buffer after any winsockets function is called)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-695433">
				<div id="div-comment-695433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MadQ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695433">
			December 26, 2008 at 4:30 am</a>		</div>

		<p>Creating a multi-threaded GUI application in Windows is actually not very difficult. The AttachThreadInput function has been around since Windows 95. One of the first multi-threading demonstrations I saw on Win95 was an MDI application that ran each MDI-child in a separate thread. The document windows just did something similar to the Beziers or Mystify screen savers, but all of the windows remained responsive, and even played nice with each other.</p>
<p>Also, let&#8217;s not forget about AmigaOS (still the only OS with full-blown preemptive multitasking, and able to run useful applications with 512KB of RAM and a single 880K floppy disk.) AmigaOS handles all keyboard/mouse window focusing, etc. in one single dedicated process. GUIs remain responsive even if the application is deadlocked.â€  How do you like THEM apples?</p>
<p>â€  Well, at least that was true until the various Magic* GUI libraries became popular.</p>
<p>Sigh! I&#8217;m waxing nostalgic again. I want my A4000 back. I kinda miss those late night session with all those meditating gurus. I think I&#8217;ve been dreaming of blinking red boxes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695473">
				<div id="div-comment-695473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695473">
			December 26, 2008 at 10:30 am</a>		</div>

		<p>RCL,</p>
<p>1) You don&#8217;t need to care. If you create worker thread, just use plain WaitForSingleObject/MultipleObjects.</p>
<p>2) It&#8217;s not a limitation. If you think you need to move your window to a different thread, think again about problems it will create.</p>
<p>3)won&#8217;t be a problem.</p>
<p>Again, with any windowing system you have to understand how it works and what are implications of using it in multiple threads. With your hypothetical system you&#8217;ll have more pain without much (if any) gain.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-695783">
				<div id="div-comment-695783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695783">
			December 27, 2008 at 6:40 am</a>		</div>

		<p>RCL: I think you&#8217;re seriously overestimating the &quot;seriousness&quot; of these &quot;limitations&quot;. Windows applications have been written for over 15 years with these &quot;limitations&quot; and you&#8217;re the first person I&#8217;ve heard of who&#8217;s complained about this.</p>
<p>Of course, this in itself shouldn&#8217;t invalidate your claim, but I can&#8217;t see a coherent alternative which is actually simpler than the way Windows currently works. You&#8217;re making comon things harder in order to simplify things which have little practical value.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695833">
				<div id="div-comment-695833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-695833">
			December 29, 2008 at 9:22 am</a>		</div>

		<p>@RCL:</p>
<p>If you&#8217;re really writing some kind of game then you should take industry experience to heart and avoid the over-use of threads. &nbsp;In addition to that, your threads shouldn&#8217;t care about whether there&#8217;s a Window or not unless they created said window. &nbsp;I can guarantee that in 99% of situations you will destroy performance by trying to have random threads updating your UI. &nbsp;Your game&#8217;s abstract Window Manager should probably handle that if you&#8217;re doing something cross-platform.</p>
<p>Then the only thing you need to do is make the Window Manager thread-safe and compliant with how it might get called by Win32 and you&#8217;re good to go.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-696003">
				<div id="div-comment-696003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kaenneth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-696003">
			December 29, 2008 at 8:41 pm</a>		</div>

		<p>How big is an empty Window message queue anyway?</p>
<p>I recall a figure of around 1mb of memory per thread, which would make thousands of threads a very bad design choice (that might have been .net specific or something&#8230;), so what&#8217;s the amount added by a queue of zero items? (hmmm, plus broadcast messages I suppose&#8230;)</p>
<p>What happens if the queue isn&#8217;t being emptied?, I suppose other threads blocked while awaiting a response (like UIA) would hang, but does an asynchronous message ever timeout? (or are WMs inherently synchronous?)</p>
<p>I&#8217;m currently working on software for Microsoft Surface (using the WPF based sdk)where multiple, simultainous, syncronized inputs are happening, and the application must always be responsive even if 10 different users or fingers of the same user, or even 10 fingers of each of 10 users are interacting with different UI controls. Having all the UI events occur on a single thread is much easier than if they were on different threads, since they interact with each other (such as when using multiple fingers to resize/rotate an object).</p>
<p>You just have to follow one simple rule, never, ever, EVER block the UI thread. You don&#8217;t need a thousand worker threads, I just handle any interesting UI events with as little code as possible to create a workitem, enqueue it, and set the &#8216;hasWork&#8217; semaphore for the single worker thread. A single queued item may get expanded to mutliple sub-items in the queue, so that the worker dosn&#8217;t block as well, and multiple database queries can be pending.</p>
<p>I suppose what would be the hard part (displaying the results when the queue item has been processed) is taken care of by WPF, I just enqueue a delegate on the Dispatcher for the UI thread, and it&#8217;ll run on the correct thread, undating the contents of the element in question. That&#8217;s probably done with Window Messages internally.</p>
<p>I havn&#8217;t had to deal with WM_s since Win 3.11, and I don&#8217;t miss them one bit. It&#8217;s not like I don&#8217;t enjoy low-level coding, I still do some assembly, and greatly enjoy reading about the details Raymond describes, but it&#8217;s like having a little backyard garden with a few plants compared to having to till 200 acres. The little bit I&#8217;ve done myself makes me appreciate what the professionals have done for me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-696023">
				<div id="div-comment-696023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alexander Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081223-00/?p=19743#comment-696023">
			December 29, 2008 at 9:51 pm</a>		</div>

		<p>Kaenneth,</p>
<p>A message queue is limited to 10000 messages by default. And not every thread gets it. BUT prety much every thread gets 1 MB of stack space reserved.</p>
<p>Asynchronous message will never cause the posting thread to block. This is why it&#8217;s called asynchronous.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

