<html>
<head>
<title>Command line redirection is performed by the command line interpreter</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Command line redirection is performed by the command line interpreter</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>May 16, 2006 / year-entry #167</td></tr>
<tr><td><b>Tags:</b></td><td>tipssupport</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>31</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The magic characters like <, >, and | in command lines like myprogram.exe | sort > output.txt are interpreted by the command interpreter CMD.EXE; they aren't built into the CreateProcess function. (This is obvious if you think about it. That command line created two processes; which one should CreateProcess return a handle to?) If you...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
The magic characters like
<tt>&lt;</tt>,
<tt>&gt;</tt>, and
<tt>|</tt>
in command lines like
</p>
<pre>
myprogram.exe | sort &gt; output.txt
</pre>
<p>
are interpreted by the command interpreter <code>CMD.EXE</code>;
they aren't built into the <code>CreateProcess</code> function.
(This is obvious if you think about it.
That command line created two processes; which one should
<code>CreateProcess</code> return a handle to?)
</p>
<p>
If you pass a command line like this to <code>CreateProcess</code>,
it will merely run the
<code>myprogram.exe</code> program with the command line arguments
"<tt>| sort &gt; output.txt</tt>".
(The <code>ShellExecute</code> function behaves similarly.)
If you want these characters to be interpreted as redirection
operators, you need to give them to someone who will interpret
those characters in the manner you intend:
</p>
<pre>
cmd.exe /C myprogram.exe | sort &gt; output.txt
</pre>
<p>
Since different command line interpreters use different syntax,
you have to specify which command line interpreter you want to use.
</p>
<p>
If the command line came from the user, you probably want to use
the <code>COMSPEC</code> variable in order to give the command
to the user's command line interpreter of choice.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (31)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-381123">
				<div id="div-comment-381123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381123">
			May 16, 2006 at 10:16 am</a>		</div>

		<p>Or you could implement the pipe and redirection yourself &#8212; this is not necessarily easy (in fact I have no idea how to do it; I assume CreateProcess takes some info that determines where a process&#8217;s stdin comes from and where its stdout/stderr go to, but I don&#8217;t know for sure), and you&#8217;ll be duplicating code that&#8217;s already in cmd.exe. &nbsp;But it is (probably) another way to do it. &nbsp;;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381143">
				<div id="div-comment-381143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381143">
			May 16, 2006 at 10:34 am</a>		</div>

		<p>If you want shell interpretation performed, I think the proper thing to do is simply to call the system() function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381163">
				<div id="div-comment-381163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">duggie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381163">
			May 16, 2006 at 11:13 am</a>		</div>

		<p>Did old versions of DOS have redirection defined by the myprogram.exe? I recall simplistic redirection being explained in terms of parameters when you typed &quot;EDIT /?&quot; &lt;shudder&gt;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381193">
				<div id="div-comment-381193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381193">
			May 16, 2006 at 12:03 pm</a>		</div>

		<p>When I first started using PCDOS, it seemed bizarre to me that Command.com would interpret some special characters, like &lt; and &gt;, but not others, like * and ?. On Unix they were all done by the shell.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381223">
				<div id="div-comment-381223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">I.P. Overscsi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381223">
			May 16, 2006 at 2:17 pm</a>		</div>

		<p>Dave Harris: I believe the wildcard characters (* and ?) were not expanded by the shell in DOS due to the limited RAM available for the process block (the location where the command line parameters were stored). &nbsp;Wildcards can expand out to hundreds if not thousands of files, overflowing the PCB. &nbsp;This means that expanding wildcards was always left up to the application. &nbsp;It persists in this manner simply for backward compatibility.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381153">
				<div id="div-comment-381153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381153">
			May 16, 2006 at 11:08 am</a>		</div>

		<p>Doesn&#8217;t system() just run Raymond&#8217;s command line for you on Win systems? &nbsp;(I.e., %COMSPEC% /C &quot;whatever string you pass to system()&quot;.)</p>
<p>That&#8217;s what it does on Linux, at least &#8212; it forks, then runs /bin/sh -c &quot;whatever string you pass to system()&quot;, and then waits for that child process to exit. &nbsp;(Note that the quotes &#8212; or something emulating them &#8212; are *required*; the -c option requires *one* slot in the argv array for its argument. &nbsp;I believe cmd.exe&#8217;s /C option is the same, but I don&#8217;t know for sure. &nbsp;OTOH, WinMain receives a single string, not an argv array, so maybe it doesn&#8217;t matter.)</p>
<p>On Windows I doubt it can wait for the process to exit, because of Raymond&#8217;s post a couple weeks ago about &quot;what can you do with the HINSTANCE returned by ShellExecute?&quot;. &nbsp;Unless it uses CreateProcess instead of ShellExecute; I&#8217;m not sure if that makes a difference in this case or not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381343">
				<div id="div-comment-381343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Candy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381343">
			May 16, 2006 at 8:41 pm</a>		</div>

		<p>Search msdn for sample code using the phrase<br />
<br />&quot;Creating a Child Process with Redirected Input and Output&quot; (I have a CD) and it will tell you how to shell woth redirection without cmd.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381233">
				<div id="div-comment-381233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381233">
			May 16, 2006 at 2:20 pm</a>		</div>

		<p>BryanK, the system() function probably just calls CreateProcess(), so it waits until the command exits. ShellExecute is a relatively new function that analyzes its input to determine how to handle it, whereas system() is defined to always use the system shell to execute the given command &#8212; they are not interchangeable.</p>
<p>duggie, old versions of DOS did redirection the same way UNIX does (i.e. via changing the location of file descriptors 0, 1, and 2). However DOS could not multitask, so piping was handled by redirecting the output of the first program to a temp file, then redirecting that file to stdin on the next program once the first had exited.</p>
<p>Dave Harris, it only seems bizarre because DOS (and Windows) have different ideas of which characters are special. On Unix, the * and ? characters are special and must be interpreted by the shell. On Windows those characters aren&#8217;t special and are interpreted by the individual program. This allows programs to process wildcards in ways that make sense. If a wildcard refers to a files in a directory, the standard file enumeration functions will handle it the same for every program. Only very naive programs (those that take an unordered list of filenames) can really be helped by shell-processed wildcards. For example &quot;ren *.bat *.cmd&quot; doesn&#8217;t make sense when interpreted by the shell. It also is nice to have &quot;dir /s *.exe&quot; work just as easily as &quot;dir *.exe&quot;.</p>
<p>On UNIX, the command &quot;rm *.txt&quot; will fail on a directory with a million text files because the shell will spend lots of time and memory reading in the whole directory to find the text files, sorting it, and then trying to pass it to &quot;rm&quot;, only to have it fail on exec() because you can&#8217;t pass a million parameters to a process. To do this properly you either need to write a custom program or do something like &quot;find . -name &#8216;*.txt&#8217; -print0 | xargs -N rm&quot;. On Windows, &quot;del *.txt&quot; will work no matter what.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381373">
				<div id="div-comment-381373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381373">
			May 16, 2006 at 10:07 pm</a>		</div>

		<p>On sufficiently old Unix systems, although the shell interpreted wildcards, memory space was too cramped to put them all in the command line. &nbsp;Of course there was no such thing as a million filenames, but even with one filename the result wouldn&#8217;t be put in the command line. &nbsp;The shell created a temporary file and told the executable program to read that file to get the list of filenames.</p>
<p>On the other hand, on Windows, &quot;del *.txt&quot; also sometimes doesn&#8217;t work, though of course the reasons are different.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381383">
				<div id="div-comment-381383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381383">
			May 16, 2006 at 11:10 pm</a>		</div>

		<p>Dave Harris and I.P. Overscsi:</p>
<p>I think that not expanding those characters is also a marginal safety feature. It allows commands like DEL to check for total erasure (and perhaps, to optimize).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381393">
				<div id="div-comment-381393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381393">
			May 16, 2006 at 11:10 pm</a>		</div>

		<p>Dave Harris and I.P. Overscsi:</p>
<p>I think that not expanding those characters is also a marginal safety feature. It allows commands like DEL to check for total erasure (and perhaps, to optimize).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381423">
				<div id="div-comment-381423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://64bitter.blogspot.com' rel='external nofollow' class='url'>64bitter</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381423">
			May 17, 2006 at 2:07 am</a>		</div>

		<p>gabe, oh and by the way:</p>
<p>1. dir /s is innappropriate as an example because the recursion is implemented by cmd.exe not &quot;standard file enumeration functions&quot;. Otherwise, I should be able to do ren /s, right ?</p>
<p>2. I seriously doubt that &nbsp;NTFS implements the wildcards, which means FindFirstFile is handling the del &quot;*.txt&quot; in your example. Which in turn says to me that Windows will have the same problem that you claim unix has handling a 1-million file directory (running out of memory and what not).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381363">
				<div id="div-comment-381363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://64bitter.blogspot.com' rel='external nofollow' class='url'>64bitter</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381363">
			May 16, 2006 at 10:04 pm</a>		</div>

		<p>Gabe: Actually Unix does not treat * and ? as special. They are interpreted by the user&#8217;s shell. &nbsp;That is why shells like zsh can extend wildcards beyond the basic * and ?.</p>
<p>While the Windows behavior may be nice for certain things (like your ren example), it makes extending the wildcard set almost impossible, because you have to worry about backward compatibility.</p>
<p>Leaving wildcard expansions to the shell allows them to implement whatever new shorthand they want (** in zsh for subdirectory recursion, for example).</p>
<p>We can debate endlessly as to which is better, but I find that the model of keeping the OS simple more attractive.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381473">
				<div id="div-comment-381473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381473">
			May 17, 2006 at 7:41 am</a>		</div>

		<p>Huh, it is very interesting to read these comments. I&#8217;ve often wondered why the Windows cmd shell works the way it does.</p>
<p>In fact, at my first job as a tester, one of the bugs we encountered was &quot;wildcards work on Unix but not Windows.&quot; ;)</p>
<p>Personally, I much prefer the Unix way of wildcard processing. It&#8217;s predictable within the shell, and I always use the same shell. Even if I&#8217;m on a Solaris machine, I can still use bash. I know what &quot;find&quot; will do, I know what &quot;grep&quot; will do, and I know what &quot;ls&quot; and &quot;rm&quot; will do. With respect to running out of memory expanding filenames, there is nothing wrong with dumping the names to a file, processing the file, etc. Plus, at a past job we split up directories with that many files anyway because of the performance hit we took (on Windows Server).</p>
<p>But that&#8217;s my personal preference.</p>
<p>The performance difference between the native Windows shell cmds and Cygwin implementations of their Unix counterparts is very different, as Gabe points out. I find it best to use a mix of &quot;dir /s&quot;, &quot;findstr&quot; and &quot;grep.&quot; :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381483">
				<div id="div-comment-381483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.brick-labs.com/' rel='external nofollow' class='url'>Eric D. Burdo</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381483">
			May 17, 2006 at 7:57 am</a>		</div>

		<p>For running the cmd line&#8230;</p>
<p>/c leaves the window open when the process is done.</p>
<p>/k closes the window when the process is done.</p>
<p>Useful sometimes when launching a dos basesd process from your application.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381433">
				<div id="div-comment-381433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Driver Dude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381433">
			May 17, 2006 at 3:04 am</a>		</div>

		<p>Having the shell expand command line args means expansion is done by one program &#8211; the shell &#8211; rather than by every command the user may want to use. The user learns one syntax and it works for most programs that take filename args.</p>
<p>If wildcards needs to be given explicitly, there are well-defined ways to escape those chars &#8211; namely, the backslash.</p>
<p> &nbsp; &nbsp;find / -name *bak &nbsp;&#8230;</p>
<p>Of course there are drawbacks. &quot;ren *.bat *.cmd&quot; is one simple operation that requires a script in UNIX.</p>
<p>What if you have a web server that produced daily logs and you want to move 2005 Q1 logs to another directory?</p>
<p> &nbsp; &nbsp; mv all/logs.20050[123]* &nbsp;Q1</p>
<p>Needs three commands in Windows &#8211; one for each month.</p>
<p>What I don&#8217;t understand is why Windows demands every program parse their command line. When I invoke a program, the args I will pass are distinct pieces of data. A filename is ONE ARG even if it has spaces. Forcing the args into one string loses the distinctiveness of each arg and requires the callee to re-parse and seperate the pieces.</p>
<p>Apparently, NOT EVEYONE KNOWS HOW TO PARSE A COMMAND LINE!</p>
<p>The whole business of quoting %1 could have been avoided if the unix style argv[] is used. After all, Explorer knows that the filename the user clicked on is an indivisible datum.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381453">
				<div id="div-comment-381453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381453">
			May 17, 2006 at 5:56 am</a>		</div>

		<p>I should point out that my Unix version of &quot;del *.txt&quot; was actually &quot;del /s *.txt&quot; because I forgot to pass &quot;-maxdepth 1&quot; to find.</p>
<p>Norman, if old shells put filename lists into files for the commands to read, every single command would have to know how to get its parameters from a file and xargs would never need to have been written.</p>
<p>64bitter, my point was not that recursion should be handled by the shell, but that it should be handled along with wildcards by the application. Since the shell doesn&#8217;t know about the recursion, it doesn&#8217;t make sense for it to handle wildcard expansion. That means that &quot;dir /s *.txt&quot; works just as well as &quot;dir *.txt&quot;, but &quot;ls -lR *.txt&quot; doesn&#8217;t work nearly as well as &quot;ls -l *.txt&quot;, and &quot;ls -l **/*.txt&quot; probably doesn&#8217;t do what you want either. And if for some reason your directory has a file called &quot;-rf&quot; in it, &quot;rm *&quot; almost certainly doesn&#8217;t do what you want, while &quot;del *&quot; almost certainly does. Likewise, rm doesn&#8217;t need wildcard processing because the shell already does it, but that means that &quot;rm *.txt&quot; works and &quot;rm -r&quot; works, but &quot;rm -r *.txt&quot; doesn&#8217;t work (and neither does &quot;rm -r *.txt&quot; as it would with ls).</p>
<p>As for &quot;keeping the OS simple&quot;, it&#8217;s hard to tell which standpoint is better. In Unix, every shell has to have its own (possibly incompatible) wildcard implementation and since that wildcard handling is fairly naive, each program that wants to handle wildcards or recursion has to have its own (possibly incompatible) implementation. Whenever you run into a situation with too many files to fit on a command line, you&#8217;re stuck running find or find|xargs, so you don&#8217;t even get your shell&#8217;s wildcards anymore. In Windows, only the filesystem layer has to implement wildcards. This makes Windows simpler, right?</p>
<p>NTFS implements wildcards, but the processing is done by an OS library routine (FsRtlIsNameInExpression). Just to try it out, I wrote a Perl script to make a directory with 100,000 .exe files and 100,000 .txt files. It took about 2.5 minutes to run on an NTFS volume. I ran &quot;dir /o &gt; nul&quot; (to sort the directory) and it took about 12 seconds and used 30MB of memory. Then I ran &quot;del *.txt&quot;, and the command processor took about 1 minute and never used more than 1500kB of memory.</p>
<p>If you ran that test on Unix you wouldn&#8217;t run out of memory (who doesn&#8217;t have 32MB laying around?), but you would hit ARG_MAX (128k in Linux) and execve() would return E2BIG.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381763">
				<div id="div-comment-381763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/myocom/archive/2006/05/17/600110.aspx' rel='external nofollow' class='url'>Mark Yocom's Script Tips</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381763">
			May 17, 2006 at 1:45 pm</a>		</div>

		<p>For those of you who are more interested in the gritty details of command line redirection, RaymondC&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381783">
				<div id="div-comment-381783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381783">
			May 17, 2006 at 1:52 pm</a>		</div>

		<p>Yes, it is annoying when you want to use wildcards and the Windows program you are running doesn&#8217;t accept them. Of course there&#8217;s nothing stopping you from just running a wildcard-expanding shell (either a native POSIX version or a Win32 version like cygwin). If you&#8217;re compiling it yourself with VC, you could even link in setargv.obj (as described in <a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/8bch7bkk.aspx" rel="nofollow">http://msdn2.microsoft.com/en-us/library/8bch7bkk.aspx</a>) and you get wildcards expanded automatically.</p>
<p>If you&#8217;re really annoyed by some program not getting wildcards expanded, you can write your own program to handle it via ImageFileExecutionOptions. Raymond may hate you if you do this.</p>
<p>Anyway, having wildcards in the shell is a nice feature, but it still doesn&#8217;t prevent programs from having to implement wildcards (like ls, find, ftp, and unzip). If the shell expansion isn&#8217;t good enough and the program you want to use doesn&#8217;t implement them, you&#8217;re stuck with running it through for or find anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381493">
				<div id="div-comment-381493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381493">
			May 17, 2006 at 8:23 am</a>		</div>

		<p>If your directory has a file named -rf in it, then that&#8217;s when you would use &quot;rm &#8212; *&quot;. &nbsp;That is, after all, the whole point of the &quot;&#8211;&quot; argument.</p>
<p>As far as &quot;only the filesystem layer has to implement wildcards&quot; &#8212; yes, but if only every program would *use* that layer. &nbsp;Use of the pattern matching function(s) in NTFS is sadly inconsistent between programs &#8212; too many of them expect each file to be given to them, one at a time, and don&#8217;t use FindFirstFile/FindNextFile at all. &nbsp;(And this isn&#8217;t just programs ported from Unix, where they wouldn&#8217;t have to worry about it; several programs provided as part of a &quot;bare&quot; win2k install do it as well. &nbsp;Unfortunately I can&#8217;t remember which ones they are at the moment.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381843">
				<div id="div-comment-381843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://64bitter.blogspot.com' rel='external nofollow' class='url'>64bitter</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381843">
			May 17, 2006 at 3:53 pm</a>		</div>

		<p>we should take the further debate out of raymond&#8217;s blog. I am sure no one else cares about it :)</p>
<p>I have no quarrel over remote queries like the one you mention, however, the unix way to do it would probably (I&#8217;m not a unix expert by any means)be to run rsh ls *.txt at the remote and collect the output.<br />
<br />Remember, Unix was networked when networks were even slower :-)</p>
<p>To me, doing it in the driver is optimizing for the pathological case at the cost of future extensiblity (which you haven&#8217;t addressed). &nbsp;</p>
<p>BTW, if I add a new FSD, does it also have to implement the wildcard expansion ? I would hope not. It&#8217;s been a while since I looked at the IFS docs, but I don&#8217;t remember them saying anything about that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-381863">
				<div id="div-comment-381863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381863">
			May 17, 2006 at 4:12 pm</a>		</div>

		<p>running &quot;rsh ls *.txt&quot; seems like a strange way to solve the problem. An operation that used to require only directory read privileges now needs remote logon privileges?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381873">
				<div id="div-comment-381873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381873">
			May 17, 2006 at 5:09 pm</a>		</div>

		<p>But &quot;remote logon privileges&quot; may be required anyway, depending on how the directory tree was exported to the client.</p>
<p>(NFS? &nbsp;Yes, that would need extra privileges to do it on the server. &nbsp;SMB? &nbsp;Depends; the client would probably need new privileges, but possibly not, depending on the way the SMB &quot;handlers&quot; on both ends were done. &nbsp;SCP/SFTP? &nbsp;No new privileges are required for that. &nbsp;Granted, exposing a remote directory tree via only scp/sftp is probably pathological&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381903">
				<div id="div-comment-381903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381903">
			May 17, 2006 at 8:57 pm</a>		</div>

		<p>Wednesday, May 17, 2006 5:56 AM by Gabe<br />
<br />&gt; Norman, if old shells put filename lists<br />
<br />&gt; into files for the commands to read, every<br />
<br />&gt; single command would have to know how to get<br />
<br />&gt; its parameters from a file</p>
<p>In sufficiently old versions of Unix, that was true, exactly as I stated.</p>
<p>&gt; and xargs would never need to have been<br />
<br />&gt; written.</p>
<p>In sufficiently old versions of Unix, that was true, exactly as you stated.</p>
<p>Wednesday, May 17, 2006 7:41 AM by Anonymous Coward<br />
<br />&gt; Personally, I much prefer the Unix way of<br />
<br />&gt; wildcard processing. It&#8217;s predictable within<br />
<br />&gt; the shell,</p>
<p>and it doesn&#8217;t change until you open up an editor and start typing search expressions or commands.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-381803">
				<div id="div-comment-381803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://64bitter.blogspot.com' rel='external nofollow' class='url'>64bitter</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381803">
			May 17, 2006 at 2:16 pm</a>		</div>

		<p>Gabe: Good points, but my gripe is exactly with the filesystem having to implement wildcards. To me, that&#8217;s a more complex OS, not simpler. It also means that the Windows wildcard expansion is sadly limited. * and ? do not make for much power beyond simple groupings.<br />
<br />For example, can I do &quot;ls [A-C]*.txt&quot; with dir ?</p>
<p>As far as your argument that the shell should not handle wildcards, I disagree. As I was trying to point out, dir /s is fine, but how do you handle ren /s without re-writing cmd.exe ? What about some other arbitrary command that needs to operate on a set of files ?</p>
<p>Wouldn&#8217;t it be better if no command ever had to worry about whether it should recurse or not or how it should parse wildcards (or not parse them) ?</p>
<p>If I want to add ** (for arguments sake) to windows, I have to update an FSD and/or ntdll/kernel32 instead of &nbsp;a shell. </p>
<p>How often does a normal user run into the pathological case of a &gt; 128k command line ? (which btw is only 32k on Windows :) Is it really worth optimizing for that case ? They can always write scripts to get around pathological cases.</p>
<p>In my experience Unix shells have been consistent on the basic regex language they support.<br />
<br />ls -l **/*.txt does exactly what dir /s *.txt does. </p>
<p>And the nice thing about that is that any program that runs under zsh would have that pattern expanded for it. None of them would have to learn new patterns as they were developed. For example, ** was developed just to overcome the recursion problem. It required no changes to ls, cp, mv or any other existing tools. </p>
<p>I can understand both approaches, and I think they each fill a need.</p>
<p>The best part, of course, is that you can use Unix shells on Windows and get most of the Unix behaviors you want. If you use native ports instead of cygwin, relative speed is not an issue generally.</p>
<p>So the debate about which is better is really a non-issue. They both work on Windows, so the lesson is to use Windows :-)</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-381823">
				<div id="div-comment-381823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-381823">
			May 17, 2006 at 3:25 pm</a>		</div>

		<p>64bitter, the reason that filesystems *should* implement wildcards is to put the processing closest to the data. Running &quot;dir 64bit*&quot; will take the same amount of time running on an NTFS directory of 10 files as 1000000 files. Running &quot;ls 64bit*&quot; will require 100000x more time to process, even if the filesystem happens to have directories indexed by name.</p>
<p>This is even more pronounced over a network. I would rather be able to ask a fileserver &quot;which files start with &#8216;.txt&#8217;?&quot; than to have to send every single filename over the network just to figure out which ones end with txt. Remember, networks can be slow and directories can be large.</p>
<p>It&#8217;s essentially the same difference as using SQL Server vs. accessing an MDB file sitting on a server.</p>
<p>And &quot;dir /s *.txt&quot; is the equivalent of &quot;ls -lR *.txt&quot; because when you run &quot;ls -l **/*.txt&quot; ls doesn&#8217;t have the ability to show listings per-directory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-382023">
				<div id="div-comment-382023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-382023">
			May 18, 2006 at 9:15 am</a>		</div>

		<p>&lt;i&gt;Granted, exposing a remote directory tree via only scp/sftp is probably pathological&#8230;&lt;/i&gt;</p>
<p>Not quite that pathological: the Linux user-mode-filesystem driver interface &lt;a href=&quot;<a rel="nofollow" target="_new" href="http://freshmeat.net/projects/lufs/&quot;&gt;lufs&lt;/a&gt;" rel="nofollow"></a><a href="http://freshmeat.net/projects/lufs/&quot;&gt;lufs&lt;/a&#038;gt" rel="nofollow">http://freshmeat.net/projects/lufs/&quot;&gt;lufs&lt;/a&#038;gt</a>; includes an implementation of &#8216;sshfs&#8217; which is essentially the same as mounting a remote filesystem while only having &#8216;scp&#8217; access. &nbsp;This is deployed in live end-user systems; access to this filesystem driver is one of the most common reasons for people to install the package, I understand.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-382213">
				<div id="div-comment-382213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-382213">
			May 18, 2006 at 4:54 pm</a>		</div>

		<p>Sorry Norman, but I have a hard time believing that. Do you have any evidence? The V3 man page for sh says &quot;&#8230;a list of names is obtained which match the argument&#8230;and the resulting sequence of arguments replaces the single argument&#8230;and finally the command is called with the resulting list of arguments.&quot; This means that as early as Feb 1973 the standard Unix shell was inserting the results directly into the command line.</p>
<p>64bitter, you&#8217;re not too far off the mark. zsh actually does some pretty heinous stuff to perform its tab-completion.</p>
<p>Any new filesystem would have to implement wildcards, but only to the extent of calling the system-provided functions. Feel free to start your own blog entry about it if you wish.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-382263">
				<div id="div-comment-382263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-382263">
			May 18, 2006 at 8:30 pm</a>		</div>

		<p>Thursday, May 18, 2006 4:54 PM by Gabe<br />
<br />&gt; Do you have any evidence?</p>
<p>Mine dated from 1976 rather than 1973. &nbsp;Sorry I didn&#8217;t bring it to Japan and can&#8217;t quote from it directly.</p>
<p>I do thank you for quoting from the 1973 version.</p>
<p>Still, think about the memory problems they would have run into in those days. &nbsp;It&#8217;s not surprising that they might have experimented with workarounds and then reverted an experiment like this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-382333">
				<div id="div-comment-382333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-382333">
			May 19, 2006 at 1:03 am</a>		</div>

		<p>It is quite instructive to see how systems have evolved. For example, back then (1973) piping used the same syntax as file redirection. You might see a command like this:</p>
<p>ls &gt;&quot;pr -h &#8216;My directory&#8217;&quot;&gt;</p>
<p>Note that the quotes were necessary in order to tell that the next tokens belong to pr instead of ls. This caused them to rethink things, and they decided on the | character we all know and love now (or ^ for those who are ASCII impaired).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-382733">
				<div id="div-comment-382733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060516-07/?p=31193#comment-382733">
			May 21, 2006 at 11:02 pm</a>		</div>

		<p>Friday, May 19, 2006 1:03 AM by Gabe<br />
<br />&gt; and they decided on the | character we all<br />
<br />&gt; know and love now (or ^ for those who are<br />
<br />&gt; ASCII impaired).</p>
<p>Yeah that brings back a memory. &nbsp;I saw someone use ^ in a command line, asked what it was, received a correct answer, and was puzzled. &nbsp;This was in an environment where all the terminals were ASCII, so even if I fully understood the answer then I still might have been puzzled.</p>
<p>In some non-ASCII environments there could be a different answer. &nbsp;Typing | requires pressing a Shift key, but ^ is a shiftless character. &nbsp;A command line typist could obtain a performance improvement 5% at a time ^_^</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

