<html>
<head>
<title>Keep your eye on the code page: Is this string CP_ACP or UTF-8?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Keep your eye on the code page: Is this string CP_ACP or UTF-8?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 11, 2015 / year-entry #121</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer had a problem with strings and code pages. The customer has a password like "M¸llwagen" for a particular user. Note the umlaut over the u. That character is encoded as the two bytes C3 BC according to UTF-8. When the customer passes this password to the Logon≠User function in order to authenticate the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>A customer had a problem with strings and code pages.</p>
<blockquote class="q"><p>  The customer has a password like <code>"M&uuml;llwagen"</code> for a particular user. Note the umlaut over the <i>u</i>. That character is encoded as the two bytes <code>C3 BC</code> according to UTF-8. When the customer passes this password to the <code>Logon&shy;User</code> function in order to authenticate the user, the call fails, claiming that the password is invalid. </p>
<p> If we encode the <i>&uuml;</i> as the single byte <code>FC</code>, then the call to <code>Logon&shy;User</code> succeeds. </p>
<p> Therefore, if the string is in UTF-8 form, it needs to be converted, and to do this we use the <code>Multi&shy;Byte&shy;To&shy;Wide&shy;Char</code> function. Once converted, the logon is successful. </p>
<p> The problem is that we are not sure if the password being given to the application will encode the <i>&uuml;</i> as <code>C3 BC</code> or as <code>FC</code>. If it arrives as <code>FC</code>, and we try to convert it with the <code>Multi&shy;Byte&shy;To&shy;Wide&shy;Char</code> function, the <i>&uuml;</i> <a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/05/04/10300670.aspx"> is converted to <code>U+FFFD</code></a>. </p>
<p> If I take the <code>FC</code>-encoded string and convert it with the <code>Multi&shy;Byte&shy;To&shy;Wide&shy;Char</code> function, passing <code>CP_<wbr>ACP</wbr></code> as the first parameter, then it converts successfully (no <code>U+FFFD</code>), and the call to <code>Logon&shy;User</code> is successful. </p>
<p> For the application, the customer does not want to distinguish the two cases or implement any retry logic or anything like that. Can you help us understand the issue, what we are doing wrong, and how we can fix it? </p>
</blockquote>
<p> As the problem is stated, you are screwed. </p>
<p> You have a bunch of bytes, and you don't know what encoding they are in. The byte sequence <code>C3 BC</code> might be a UTF-8 encoding of <i>&uuml;</i>, or it could be a <code>CP_<wbr>ACP</wbr></code> encoding of <i>&Atilde;&frac12;</i>. You are stuck with guessing. But for something as important as passwords, you shouldn't guess. You need to know for sure, because an incorrect guess will generate audit entries, and may cause the user to become locked out of the account due to too many incorrect passwords. </p>
<p> This means that you need to make sure that whoever is passing you the string also tells you what encoding it is using. </p>
<p> The customer liaison replied, </p>
<blockquote class="q"><p> Thanks. I went back and talked to the customer, and it turns out that the password is always in UTF-8 form, so the problem is solved. We will always pass <code>CP_<wbr>UTF8</wbr></code> when converting the string. </p>
</blockquote>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242056">
				<div id="div-comment-1242056" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1242056">
			June 11, 2015 at 7:04 am</a>		</div>

		<p>It amazes me how many developers still do not have a basic understanding of character encodings. &nbsp;I imagine the customer was hoping there was a RandomGarbageToWideChar function that would just wave a magic wand over the bytes and convert them into the Right Thing for any given scenario.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242046">
				<div id="div-comment-1242046" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1242046">
			June 11, 2015 at 7:18 am</a>		</div>

		<p>Similarly, it&#39;s amazing how developers don&#39;t understand that any bunch of bytes doesn&#39;t have any meaning unless there&#39;s some additional data describing the format it&#39;s in (such as the HTTP/MIME/etc. Content-Type header). This is just as true for various texty-type bunches of bytes as it is for graphical-type bunches of bytes. Reading a UTF-8 string assuming it&#39;s in Windows-1252 encoding makes exactly as much sense as reading a PNG image assuming it&#39;s in JPG encoding. And while in either case it&#39;s possible to make reasonable guesses some (or even most) of the time by looking at the bytes, it really makes much more sense to just carry the information about the type along with the bytes, since that way you know for sure.</p>
<p>I sometimes wish that UTF-8 shifted the US-ASCII letters by one position or something, just so it&#39;d be obvious all the time that it&#39;s being read in the wrong encoding, rather than developers assuming everything&#39;s working just because they&#39;d never tried &quot;one of the funny &#39;special&#39; characters&quot;. All characters should be &quot;special&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1242036">
				<div id="div-comment-1242036" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1242036">
			June 11, 2015 at 7:20 am</a>		</div>

		<p>The huge boon for UTF-8 is that it can be validated, and that a most UTF-8 multibyte sequences, when converted to Windows-1252, give sequences that are not meaningful in any human language.</p>
<p>Which means UTF-8 multibyte sequences are highly unlikely to appear in most CP_ACP text, which means [i]if it validates as UTF-8, it can be relatively safely assumed to be so[/i].</p>
<p>Of course it&#39;s probabilistic, but hey, so are random GUIDs and other practices like identifying a file by its hash.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242026">
				<div id="div-comment-1242026" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1242026">
			June 11, 2015 at 7:37 am</a>		</div>

		<p>@pc And how do you specify/encode the encoding? At some point, some code is going to have to make an assumption.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1242016">
				<div id="div-comment-1242016" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1242016">
			June 11, 2015 at 8:01 am</a>		</div>

		<p>Is he really using an &quot;ANSI&quot; variant of that Logon¬≠User function, instead of the &quot;Wide&quot; variant? The Windows 9x series died a long time ago. Back then, it made sense to use the &quot;ANSI&quot; functions since they worked in both 9x and NT, but nowadays it&#39;s much better to just use &#8230;W functions everywhere. If you want an 8-bit encoding, use UTF-8 and convert it to UTF-16 when calling Windows APIs.</p>
<p>(Of course, that doesn&#39;t prevent all problems; the same way the Unix API is actually &quot;a sequence of 8-bit numbers&quot;, the Windows API is actually &quot;a sequence of 16-bit numbers&quot;, so you might have to deal with unpaired surrogates, which can&#39;t be converted to valid UTF-8. That&#39;s why the WTF-8 encoding exists, it can round-trip unpaired surrogates just fine.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1242006">
				<div id="div-comment-1242006" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1242006">
			June 11, 2015 at 8:15 am</a>		</div>

		<p>@M: It depends. &nbsp;GUI elements should be handing you data in a specified format. &nbsp;Stdio is less predictable, assuming you want to be as portable as possible. &nbsp;Anything over HTTP should have a declared encoding in both the headers and (for HTML) the meta tags. &nbsp;Other situations have their own rules.</p>
<p>But opening a TXT file is a crapshoot no matter how you slice it. &nbsp;You&#39;ll need out-of-band information to make that work (like HTTP headers).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241996">
				<div id="div-comment-1241996" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241996">
			June 11, 2015 at 8:34 am</a>		</div>

		<p>@M: That&#39;s largely my point, that any system which transfers bytes without also specifying the meaning of those bytes (part of which is a character encoding if those bytes represent something texty) is a buggy system. The bytes don&#39;t mean anything without that. Something like the classic Windows convention of &quot;a file ending in &#39;.txt&#39; contains only human-readable text&quot; is wholly insufficient, as it does not convey enough information about the contents to be able to read it; it&#39;s just a meaningless bunch of bytes without some other out-of-band information or agreement about the contents of the file.</p>
<p>And yes, often the name of the encoding is itself encoded in US-ASCII (such as in HTTP&#39;s Content-Type header), which is fine because that&#39;s what the specification all parties are using say. A specification describing how a program is getting data saying &quot;all text is in UTF-16&quot; or &quot;all text is in EBCDIC&quot; is perfectly fine as well, since that contains the out-of-band information about how to interpret the data. A specification saying a program gets &quot;plain text from STDIN&quot; is meaningless.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241976">
				<div id="div-comment-1241976" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241976">
			June 11, 2015 at 11:24 am</a>		</div>

		<p>Mandatory reading on the subject: <a rel="nofollow" target="_new" href="http://joelonsoftware.com/articles/Unicode.html">joelonsoftware.com/&#8230;/Unicode.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1241966">
				<div id="div-comment-1241966" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muzer_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241966">
			June 11, 2015 at 12:55 pm</a>		</div>

		<p>There is, of course, the important caveat that, depending on what you want to do with the text, there are some instances in which you don&#39;t need to know its character encoding. For example, as long as you know it&#39;s encoded in (an 8-bit encoding or UTF-8), there&#39;s a lot of things you can do with text without actually having to parse it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241956">
				<div id="div-comment-1241956" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241956">
			June 11, 2015 at 1:49 pm</a>		</div>

		<p>@Cesar Depends. If you&#39;re stuck using garbage programming languages to update garbage applications, you may be stuck with no Unicode support, or support that would take aeons to implement.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241946">
				<div id="div-comment-1241946" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241946">
			June 11, 2015 at 2:35 pm</a>		</div>

		<p>@Cesar That&#39;s what they are doing, note the use of &quot;Multi¬≠Byte¬≠To¬≠Wide¬≠Char&quot;. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-davebacher odd alt thread-odd thread-alt depth-1" id="comment-1241936">
				<div id="div-comment-1241936" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241936">
			June 11, 2015 at 4:02 pm</a>		</div>

		<p>Often what happens with this is a program starts off on a US English system, then heads to some other system. &nbsp;The programmers never considered this issue when they were designing, and it never comes up during testing. &nbsp;Then a customer from another country purchases the program, and it has issues &#8212; and so the developer is then stuck with &quot;what can we do here that doesn&#39;t involve writing a lot of code?&quot;</p>
<p>I think it&#39;s safe to assume &#8212; from the description, etc. &#8212; that is likely what happened in this case, too. &nbsp;They sent it out, they said &quot;WTF, why is this failing&quot; they traced it to a character set issue and were looking for something they could do in just one spot to fix it, versus having to fix it in n spots, in already deployed apps.</p>
<p>That&#39;s the big issue here usually &#8212; it&#39;s no big deal to go to the server, and make a change at the password function (* by no big deal, I mean &quot;changing devices you control&quot;). &nbsp;Changing a client, however, can cause problems depending on circumstance (e.g. if you have to log in for the app to self-patch, a somewhat common scenario in some apps, then not being able to login would complicate delivery of the patch). &nbsp;You have users circumventing patches, or unpatched apps connecting up and attempting to authenticate &#8212; and so if you didn&#39;t plan on this from the get go, it gets really ugly really fast.</p>
<p>And it&#39;s something that at least our local colleges still do not require in the Computer Science classes. &nbsp;However, they still require people who are going to graduate and write web back ends for line of business apps to have ridiculous amounts of math and engineering, because clearly that&#39;s much more important than basic data integrity or, you know, design/architecture. &nbsp;It&#39;s not important at all for me to be able to communicate requirements to coworkers, as long as they can solve double integrals.</p>
<p>Or, and I&#39;m not asking for a ton here, but basic use of a debugger (which is also not taught, apparently).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241926">
				<div id="div-comment-1241926" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241926">
			June 11, 2015 at 9:39 pm</a>		</div>

		<p>I have a few rules of thumb for encodings:</p>
<p>1. When working with pre-existing file formats and protocols, carefully read what encodings they specify.</p>
<p>2. If a pre-existing format or protocol has a means of specifying encoding: (a) consume any IANA-registered encoding; (b) produce UTF-8 unless explicitly overridden by the user.</p>
<p>3. When designing new formats or protocols, use UTF-8 exclusively and note this in the specification.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241906">
				<div id="div-comment-1241906" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241906">
			June 12, 2015 at 1:55 am</a>		</div>

		<p>I&#39;m always surprised at how web pages manage to mangle my last name. I can understand ƒç being interpreted as √Ñ¬ç (or just √Ñ), but how do Microsoft&#39;s pages manage to encode it as √® (which implies it&#39;s converted to CP1250 somewhere in their systems, then read as CP1252)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241886">
				<div id="div-comment-1241886" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241886">
			June 12, 2015 at 5:48 am</a>		</div>

		<p>In the unlikely event that I&#39;m communicating with an external system using a protocol or format that actually specifies an encoding (like XML), it&#39;s usually meaningless because the encoding is hard-coded as part of a wrapper that knows nothing of the data being sent.</p>
<p>So a user will enter some text in their native encoding into a GUI app, which gets sent to a server that stores it as a byte string in a DB. Then I ask a web service for data from the DB and the web service tells me the data is UTF-8, when in fact it has no idea what encoding was used when the data was entered!</p>
<p>I also have problems with systems that store times in the user&#39;s local time zone but tell me that it&#39;s in the server&#39;s current local time zone.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241876">
				<div id="div-comment-1241876" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241876">
			June 12, 2015 at 6:42 am</a>		</div>

		<p>@Dave Bacher</p>
<p>MODERN encoding issues scream one of two things:</p>
<p>1) The developer has no clue how to write software.</p>
<p>2) The developer may actually be racist/nationalist, consciously or not.</p>
<p>You&#39;d be surprised, or maybe not, how often 2 is actually the case &#8212; and not just for Western speakers/coders.</p>
<p>Assuming that everyone in the entire world speaks your language, and that ONLY your language speakers will ever use anything in your country, is pretty racist/nationalist. Even if unintentionally so.</p>
<p>Software that doesn&#39;t properly handle Unicode or foreign-encodings is usually not Accessible &#8212; uses Red/Green all over the place for Bad/Good, doesn&#39;t expose UIA properties for screen-readers, makes use of seizure-inducing flashes to get the user&#39;s attention, etc. etc.</p>
<p>I can accept most of these problems in software from the Pre-2000s, but we&#39;ve known that we NEED to handle this for 30 years, and have had EASY ways to handle all of this for at least a decade.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241856">
				<div id="div-comment-1241856" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241856">
			June 12, 2015 at 7:18 am</a>		</div>

		<p>&quot;I sometimes wish that UTF-8 shifted the US-ASCII letters by one position or something, just so it&#39;d be obvious all the time that it&#39;s being read in the wrong encoding, rather than developers assuming everything&#39;s working just because they&#39;d never tried &quot;one of the funny &#39;special&#39; characters&quot;. All characters should be &quot;special&quot;.&quot;</p>
<p>Well, that would kill one of the pillars for the design of UTF-8: Making it an extended ASCII character-set, which means all ASCII is UTF-8 and software which does not care which ASCII extension is in use, and there is much of that, would no longer silently work with it.</p>
<p>That&#39;s actually also the reason UTF-8-BOM is an abomination&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241846">
				<div id="div-comment-1241846" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241846">
			June 12, 2015 at 8:04 am</a>		</div>

		<p>@pc: &nbsp;Very good points. &nbsp;We are able to mis-read UTF8 as ASCII quite often (I think I&#39;m saying the right thing) without paying any penalties. &nbsp;That&#39;s probably a bad thing for internationalization.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241836">
				<div id="div-comment-1241836" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241836">
			June 12, 2015 at 9:40 am</a>		</div>

		<p>If you are using VS.NET, this addon can help:</p>
<p><a rel="nofollow" target="_new" href="https://visualstudiogallery.msdn.microsoft.com/540ac2d8-f881-4794-8b00-810d28257b70">visualstudiogallery.msdn.microsoft.com/540ac2d8-f881-4794-8b00-810d28257b70</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241826">
				<div id="div-comment-1241826" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241826">
			June 12, 2015 at 12:04 pm</a>		</div>

		<p>@Vahid</p>
<p>Mangling the file by removing the BOM doesn&#39;t help.</p>
<p>If an application doesn&#39;t recognise a BOM, the broken application should be fixed to recognise the BOM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1221721">
				<div id="div-comment-1221721" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1221721">
			June 12, 2015 at 6:14 pm</a>		</div>

		<p>I wish that programs could set their code page to CP_UTF8, so that the *A versions of the Win32 API took UTF-8 strings instead of (typically, for this audience) Windows-1252. &nbsp;This would make portability easier, since the other major OS&#39;s all use UTF-8. &nbsp;In fact, the only native-code systems that use UTF-16 that I can think of are all from Redmond: Windows NT (+ XBone), 3DS, Wii U.</p>
<div class="post">[<em>That would be using a global solution to a local problem. Suppose you set your app to CP_UTF8 (i.e., all *A functions use UTF-8 instead of CP_ACP). Then some code in a DLL executes, and it can&#39;t handle characters that take more than 2 bytes to encode and it blows up. Theoretically, there could be a *U8 version of every function that takes UTF-8, but that&#39;s also something that could be handled by the application, similar to unicows. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241786">
				<div id="div-comment-1241786" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241786">
			June 12, 2015 at 6:23 pm</a>		</div>

		<p>@Yuri Khan: I&#39;d like to append:</p>
<p>4. When writing an application, create an operating system abstraction layer. &nbsp;Everywhere within the application except two kinds of places&#8211;this OS abstraction layer, and any module that must work with files or data that may be of another encoding&#8211;use precomposed UTF-8. &nbsp;Thus, your application &quot;thinks&quot; in precomposed UTF-8, and only ever uses anything else at the interprogram boundaries.</p>
<p>Your OS abstraction layer then translates to and from the appropriate encoding when calling into the OS system calls. &nbsp;For Windows, that means doing UTF-8 &lt;-&gt; UTF-16 translation. &nbsp;For Mac OS X, that sometimes means doing precomposed &lt;-&gt; composite translation within UTF-8, but usually this is not needed. &nbsp;For most others, including Linux, no translation is needed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241776">
				<div id="div-comment-1241776" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241776">
			June 13, 2015 at 1:00 am</a>		</div>

		<p>@Myria: I actually disagree about precomposed Unicode (more accurately, the Normalization Form C).</p>
<p>Firstly, precomposed form only exists for a handful of characters that existed in pre-Unicode encodings, as a backward compatibility measure. E.g. there are Latin vowel + diacritic accents composites, because those were in CP437. But there are no Cyrillic vowel + accent composites. Similarly, there are almost no precomposed forms with more than one diacritic. The decomposed form is simply more generic.</p>
<p>Secondly and more importantly, automatically normalizing the user‚Äôs data, in any direction, is disrespectful. They might depend on the subtle encoding difference (e.g. to demonstrate a font rendering difference between a precomposed and decomposed forms). They might be using versioning tools that will report spurious diffs between original and normalized files. (Good luck getting git diff to ignore normalization-only changes.)</p>
<p>Of course, the application is free to pefrorm temporary internal normalization for the purposes of text processing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241726">
				<div id="div-comment-1241726" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241726">
			June 13, 2015 at 10:06 pm</a>		</div>

		<p>@Myria</p>
<p>Every person in the world that reads and manipulates a language other than English would rather that everyone switch to UTF-16, at least.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter even thread-even depth-1" id="comment-1241716">
				<div id="div-comment-1241716" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241716">
			June 14, 2015 at 2:12 am</a>		</div>

		<p>Windows for Workgroups did try all passwords as UPPERCASE and Uppercasefirstletter and lowercase when logging on. Why can&#39;t NT do this also? Please add the code back (Ctrl+C, Ctrl+V).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241676">
				<div id="div-comment-1241676" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241676">
			June 14, 2015 at 8:44 am</a>		</div>

		<p>That&#39;s where you are wrong. Since UTF-16 is no longer UCS-2, there&#39;s no advantage left to using it instead of UTF-8. Quite the opposite even.</p>
<p>Now normalizing withough need, that can be bad&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn even thread-even depth-1" id="comment-1241666">
				<div id="div-comment-1241666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241666">
			June 14, 2015 at 11:21 am</a>		</div>

		<p>The comments above criticize the way the client side has been implemented, and many are very true. But there is the other side to this specific situation, the server side. The password verification procedure.</p>
<p>Why should it require &quot;Latin letters and digits, at least 7 characters but no more than 9 characters&quot;? How often do we see such restrictions?</p>
<p>Also, again and again, we see that the system will not recognize the password if it was typed by mistake with wrong keyboard language layout, or Caps Lock. Why, for goodness sake? Does accepting mYcAMELtYPEsECRET or –¨–≥–°—Ñ—å—É–¥–ï–≥–∑—É–´—É—Å–∫—É–µ really compromise system security?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241656">
				<div id="div-comment-1241656" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241656">
			June 15, 2015 at 1:15 am</a>		</div>

		<p>@Alex Cohn:</p>
<p>&gt; Why should it require &quot;Latin letters and digits, at least 7 characters but no more than 9 characters&quot;?</p>
<p>Having a restriction on maxumum length and allowed characters is a sure sign that there&#39;s something wrong with the way passwords are stored (passwords should always be stored as a salted one-way hash, and thus not have any length requirements).</p>
<p>&gt; Also, again and again, we see that the system will not recognize the password if it was typed by mistake with wrong keyboard language layout, or Caps Lock. Why, for goodness sake? Does accepting mYcAMELtYPEsECRET or –¨–≥–°—Ñ—å—É–¥–ï–≥–∑—É–´—É—Å–∫—É–µ really compromise system security?</p>
<p>When you store passwords properly (as a hash), there&#39;s no way to know that ABC and abc are the same password &#8211; their hashes are different. Even more so for different keyboard layouts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1221711">
				<div id="div-comment-1221711" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1221711">
			June 15, 2015 at 1:27 am</a>		</div>

		<p>&quot;Theoretically, there could be a *U8 version of every function that takes UTF-8&quot; I think there *should*, and haven&#39;t given up hope that there might be someday, and this is why it&#39;s indispensable *not to ditch the TCHAR*. The TCHAR is the key to lessening the pain of transitioning to UTF-8 versions of each function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-anonymouscommenter odd alt thread-odd thread-alt depth-1" id="comment-1241636">
				<div id="div-comment-1241636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymouscommenter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241636">
			June 15, 2015 at 6:30 am</a>		</div>

		<p>I think @640k is on to something. We should really just start entering the user&#39;s password for them, that way they don&#39;t need to remember casing at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1241596">
				<div id="div-comment-1241596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241596">
			June 15, 2015 at 9:35 am</a>		</div>

		<p>Alex Cohn might be on to something too: Instead of memorizing the password itself, why not memorize the co√∂rdinates of the keys used in typing it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn odd alt thread-odd thread-alt depth-1" id="comment-1241586">
				<div id="div-comment-1241586" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1241586">
			June 15, 2015 at 11:34 am</a>		</div>

		<p>@ender: I have no problems with the fact that password lengthy and constitution are regulated; the problem is that too often these regulations are crazy. If a password will be typed by humans, make you software compensate for some most typical human confusions, not the other way around. With passwords the challenge is even more important, because the user cannot see what she types, and can only fix by retyping all once again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1221701">
				<div id="div-comment-1221701" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1221701">
			June 16, 2015 at 9:54 am</a>		</div>

		<p>@Myria: I agree 100% with your wish to support UTF-8 as an ANSI code page. &nbsp;If not for the Win32 API, then at least for the MSVCRT. &nbsp;As it is, you can&#39;t even use Standard C functions like fopen or printf if your strings are in UTF-8. &nbsp;That makes it *extremely* painful to write cross-platform code that needs to handle non-ASCII characters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1221691">
				<div id="div-comment-1221691" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20150611-00/?p=45401#comment-1221691">
			June 16, 2015 at 10:04 am</a>		</div>

		<p>[Theoretically, there could be a *U8 version of every function that takes UTF-8, but that&#39;s also something that could be handled by the application, similar to unicows. -Raymond.]</p>
<p>That&#39;s not even the problem. The problem is the console borks itself on certain kinds of UTF-8 proceeding. I could solve the whole rest of it *today* if the console code in csrss.exe could really accept UTF-8. Trying to fix the rest of it w/o that ends up backing into recreating Cygwin.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

