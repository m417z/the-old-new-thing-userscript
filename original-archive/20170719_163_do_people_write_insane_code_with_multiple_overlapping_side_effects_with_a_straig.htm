<html>
<head>
<title>Do people write insane code with multiple overlapping side effects with a straight face?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Do people write insane code with multiple overlapping side effects with a straight face?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 19, 2017 / year-entry #164</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>68</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">I guess some do.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
On an internal C# discussion list, a topic that comes up
every so often is asking about
the correct interpretation of statements like
</p>
<pre>
    a -= a *= a;
    p[x++] = ++x;
</pre>
<p>
I asked,
</p>
<blockquote CLASS=q><p>
Who writes code like that with a straight face?
It's one thing to write it because you're trying to win the IOCCC
or you're writing a puzzle,
but in both cases, you know that you're doing something bizarre.
Are there people who write
<code>a -= a *= a</code> and
<code>p[x++] = ++x;</code>
and think,
"Gosh, I'm writing really good code?"
</p>
</blockquote>
<p>
<a HREF="http://ericlippert.com/">Eric Lippert</a> replied
"Yes, there are most certainly such people."
He gave as one example a book from an apparently-successful author
(sales of over four million and counting)
who firmly believed that the terser your code,
the faster it ran.
The author crammed multiple side effects into a single expression,
used ternary operators like they were going out of style,
and generally believed that run time was proportional to the number
of semicolons executed,
and every variable killed a puppy.
</p>
<p>
Sure, with enough effort,
you could do enough flow analysis to have
the compiler emit a warning like
"The result of this operation may vary depending upon the order
of evaluation",
but then you have to deal with other problems.
</p>
<p>
First of all, there will be a lot of false positives.
For example, you might write
</p>
<pre>
    total_cost = p-&gt;base_price + p-&gt;calculate_tax();
</pre>
<p>
This would raise the warning because the compiler observes
that the <code>calculate_</code><code>tax</code> method is not <code>const</code>,
so it is worried
that executing the method may modify
the <code>base_</code><code>price</code>,
in which case it matters whether you add the tax to the original base price
or the updated one.
Now, you may know (by using knowledge not available to the compiler)
that the <code>calculate_</code><code>tax</code> method updates the tax
locale for the object,
but does not update the base price,
so you know that this is a false alarm.
</p>
<p>
The problem is that there are going to be an awful lot of these
false alarms, and people are just going to disable the warning.
</p>
<p>
Okay, so you dial things back and warn only for more blatant cases,
where a variable is modified and evaluated within the same expression.
"Warning: Expression relies on the order of evaluation."
</p>
<p>
Super-Confident Joe Expert programmer knows that his code
is awesome
and the compiler is just being a wuss.
"Well, <i>obviously</i> the variable is incremented first,
and then it is used to calculate the array index,
and then the result of the array lookup is stored back to the variable.
There's no order of evaluation conflict here.
<i>Stupid compiler</i>."
Super-Confident Joe Expert turns off the warning.
But then again,
Super-Confident Joe Expert is probably a lost cause,
so maybe we don't worry
about him.
</p>
<p>
Joe Beginner programmer doesn't really understand the warning.
"Well, let's see.
I compiled this function five times,
and I got the same result each time.
The result looks reliable to me.
Looks like a spurious warning."
The people who would benefit from the warning don't have the necessary
background to understand it.
</p>
<p>
Sure enough,
some time later,
it came up again.
Somebody asked why
<code>x ^= y ^= x ^= y</code> doesn't work in C#,
even though it works in C++.
More proof that people write code that rely upon
multiple side effects,
and they passionately believe that what they are doing is obvious
and guaranteed.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (68)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1302435">
				<div id="div-comment-1302435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">French Guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302435">
			July 19, 2017 at 7:45 am</a>		</div>

		<p>That&#8217;s intended to swap the values of x and y without using a temporary variable, right? Basically, a one-expression version of &#8220;x ^= y; y ^= x; x ^= y;&#8221;</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-mzzt odd alt depth-2 parent" id="comment-1302446">
				<div id="div-comment-1302446" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/The+MAZZTer' rel='external nofollow' class='url'>The MAZZTer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302446">
			July 19, 2017 at 8:14 am</a>		</div>

		<p>I think in C#7 you could use tuples. I don&#8217;t have access to VS2017 at the moment but this might work:</p>
<p>(y, x) = (x, y);</p>
<p>Not sure.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-aadsso-1live-com00037ffe8545d1b7 even depth-3" id="comment-1302575">
				<div id="div-comment-1302575" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/David+Totzke' rel='external nofollow' class='url'>David Totzke</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302575">
			July 19, 2017 at 1:46 pm</a>		</div>

		<p>You are correct sir.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-3 parent" id="comment-1302826">
				<div id="div-comment-1302826" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Warren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302826">
			July 20, 2017 at 1:34 pm</a>		</div>

		<p>Tuples for the win&#8230; </p>
<p>Of course, there are now two temp variables (a tuple of them) that is constructed on the stack and then read from during the assignment.  </p>
<p>But it is clearer.  </p>
<p>Unless, your understanding of tuples assignments is that they are just a grouping of individual assignments, with a mere translation to x = y; y = x, which is obviously correct because its more optimal and doesn&#8217;t waste all that unnecessary stack, which means the simple looking assignment is actually wrong in a horribly subtle way, so you freak out and start sending hate mail to your fellow developer for making that noob mistake&#8230;</p>
<p>Until you realize that you were wrong.. and that the C# design team (or at least one pushy member) thought it would be really cool if the assignment allowed swap to work, so they personally would never have to remember how to do that swap trick or need to name a local variable &#8216;temp&#8217; anymore.. </p>
<p>But maybe that&#8217;s just me.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-msn even depth-4" id="comment-1303275">
				<div id="div-comment-1303275" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/poizan42' rel='external nofollow' class='url'>poizan42</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303275">
			July 23, 2017 at 6:57 am</a>		</div>

		<p>The clr stack != the processor stack. If enregistration works as it is supposed to in RyuJIT then the tuple struct should never exist on stack. After that the flow analysis should be able to figure out that it can be compile to an exchange instruction.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2 parent" id="comment-1302485">
				<div id="div-comment-1302485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DWalker07</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302485">
			July 19, 2017 at 8:58 am</a>		</div>

		<p>Sure, it&#8217;s possible to swap the values of two variables without using a temp variable.</p>
<p>But, in the real world (outside of contests), is it worth it?  Sure, variables might be expensive (it depends), but programming errors and confusion by the programmer-hired-later-to-update-code are much more expensive.  Clarity is key.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-3 parent" id="comment-1302525">
				<div id="div-comment-1302525" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302525">
			July 19, 2017 at 9:53 am</a>		</div>

		<p>In the real world, the CPU has these temporary variables called &#8220;registers&#8221;.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1302636">
				<div id="div-comment-1302636" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302636">
			July 19, 2017 at 5:14 pm</a>		</div>

		<p>It occurred to me the warning should say &#8220;statement depends on the compiler version&#8221; where the same expression within wrote to the same variable twice. Joe Newbie has a decent chance of understanding that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4" id="comment-1302675">
				<div id="div-comment-1302675" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">The_Assimilator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302675">
			July 20, 2017 at 12:29 am</a>		</div>

		<p>The kind of person who writes this sort of code probably considers using a register an unnecessary performance overhead.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-3 parent" id="comment-1302746">
				<div id="div-comment-1302746" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302746">
			July 20, 2017 at 8:59 am</a>		</div>

		<p>This is where I wonder where the compiler would figure out to optimize out or not even use a memory address if it&#8217;s a temp variable. </p>
<p>There&#8217;s also the 80/20, 90/10, 95/5 rules where most of the program is in a small amount of the code. </p>
<p>Sometimes newer developers overthink the RAM cost, and it&#8217;s an easy thing to do. However, math can save you from insanity. Let&#8217;s say you have an 160 int temp variables in your file. That&#8217;s 320 bytes on a 64-bit CPU, assuming int in C++. That&#8217;s bytes, not kilobytes. On today&#8217;s devices where you are expected to have at least 512 MB of RAM on a mobile device (32 MB available for programs on lower-end Android devices), those 320 bytes are more than likely not what&#8217;s wrong with your program if something&#8217;s going wrong</p>
<p>I also see a push to minimize lines of code. In many cases, this is alright. However, it sometimes gets taken to an extreme by cramming many lines of code or statements on a single line that will expand to a bunch of lines anyways once it gets compiled down. If you are in a language without the Elvis operator, pray that you don&#8217;t have a null value in that chain.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1302755">
				<div id="div-comment-1302755" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302755">
			July 20, 2017 at 9:00 am</a>		</div>

		<p>&#8230; and I can&#8217;t edit the math on the previous comment. I thought it was 20 int vars. 160 int vars on 64-bit C++ is 1280 bytes, 1.2k.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-archangelpip odd alt depth-2 parent" id="comment-1302486">
				<div id="div-comment-1302486" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302486">
			July 19, 2017 at 9:07 am</a>		</div>

		<p>The funny thing is, a compiler with optimisations enabled should always remove the temporary variable anyway, so for the majority of cases using the temporary variable is the simpler option. This is especially true if you can&#8217;t guarantee that the variables are not aliased.<br />
But this is another problem with less experienced programmers, then never take into account what the compiler itself is capable of doing and then uses these &#8220;tricks&#8221; to try to speed things up. Not realising that what they are doing will probably be the same speed, or maybe even slower.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1302805">
				<div id="div-comment-1302805" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302805">
			July 20, 2017 at 1:07 pm</a>		</div>

		<p>I have been witness to rare circumstances on both military and medical projects where the output of different compilers were required to be identical regardless of the haphazard omission/modification of compiler settings to ensure that binaries sourced from different parties weren&#8217;t tampered with (think shared codebases between different nations militaries&#8217; where trust cannot be assumed).  More often than not much of this code was written in assembly to avoid trouble, but there were a ton of creative workarounds utilized in higher level languages when working at a lower level of code could not be done for whatever reason.  Readability and maintenance were nightmarish, but sometimes that&#8217;s just what the project requires.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1302855">
				<div id="div-comment-1302855" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302855">
			July 20, 2017 at 5:19 pm</a>		</div>

		<p>See reproducible-builds for the modern way.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1302505">
				<div id="div-comment-1302505" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302505">
			July 19, 2017 at 9:21 am</a>		</div>

		<p>Even if the compiler doesn&#8217;t remove the temporary variable, it isn&#8217;t a great loss. The variable, being short-lived, can be stored in a register, avoiding touching memory. And even if it is stack-based (or if spills into the stack), the top of the stack will probably be at the level 1 cache, so it shouldn&#8217;t cause a cache fault.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302445">
				<div id="div-comment-1302445" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302445">
			July 19, 2017 at 8:05 am</a>		</div>

		<p>I hate such code. It&#8217;s obfuscation, plain and simple.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-archangelpip even thread-even depth-1" id="comment-1302475">
				<div id="div-comment-1302475" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302475">
			July 19, 2017 at 8:44 am</a>		</div>

		<p>I always find it fun when you have the kind of people who think that writing less code is faster, and then you show them seemingly more code that does the same thing in the same amount of time, or even faster.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1302495">
				<div id="div-comment-1302495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302495">
			July 19, 2017 at 9:09 am</a>		</div>

		<p>But sir, there is only so much space on the drum for my environment, build tools, code, and resulting text file.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-jeremytais even depth-2" id="comment-1302596">
				<div id="div-comment-1302596" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/SimonRev' rel='external nofollow' class='url'>SimonRev</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302596">
			July 19, 2017 at 3:00 pm</a>		</div>

		<p>You laugh, but I once interviewed a software developer that stated in all seriousness that since his work PC&#8217;s hard drive was too small, he would uninstall Visual Studio version x and install Visual Studio version y every time he had to switch projects.  I normally try to avoid delving into the work environment of a previous employer, but I seriously had to follow up and nail down that his employer would rather pay him to reinstall visual studio twice a day than buy him a bigger hard drive.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1302496">
				<div id="div-comment-1302496" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302496">
			July 19, 2017 at 9:12 am</a>		</div>

		<p>Writing less code (i.e., less tokens) can be slightly faster in *interpreted* languages like PHP (a script and all of its includes are parsed each and every time it is invoked, at least in versions prior to PHP 7). But in those languages, the biggest gains come from avoiding including (and parsing) files you know you are not needing (in PHP, include() is a sentence, which makes it easy to do &#8220;lazy includes&#8221;). Playing tricks to save one or two lines of code isn&#8217;t clever if the code isn&#8217;t readable and causes trouble when debugging or adding new features. Once again, is a matter of using common sense and trying to hit a balance.</p>
<p>Of course, in compiled languages with modern compilers, compressing the code does not make much sense, unless you really know what you are doing and you are optimizing an inner loop that runs thousand of times a second. And even then, you have to get in the compiler&#8217;s shoes, and think in terms of machine operations, and not high level language sentences.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1302515">
				<div id="div-comment-1302515" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin Fee</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302515">
			July 19, 2017 at 9:35 am</a>		</div>

		<p>I once wrote code similar to the p[x++] = x++; It made sense as I wrote it, two discreet blocks of everything moving forward. The instant after I wrote it, I read it, at which point I said, &#8220;That is completely unreadable.&#8221; and I created a local variable for each of the increments to make it absolutely clear which order I was expecting. I didn&#8217;t even run it. I now suspect it may not have evaluated in the order I expected, so either way it&#8217;s a good thing I did.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1302535">
				<div id="div-comment-1302535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">user</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302535">
			July 19, 2017 at 11:03 am</a>		</div>

		<p>I wonder what would be a positive example of an expression making good usage of side effects?  It seems to me that the concept of &#8220;a *= b&#8221; or &#8220;a++&#8221; evaluating to a number just opens the door for this kind of abuse.  If they were &#8220;void&#8221; expressions that only change the variable but don&#8217;t evaluate to anything, these examples with multiple overlapping side effects would not be possible.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1302536">
				<div id="div-comment-1302536" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302536">
			July 19, 2017 at 11:16 am</a>		</div>

		<p>I think the standard argument for assignments returning a value making any sort of sense is initializations like &#8220;a = b = c = 1&#8221;. This syntax may derive from a more mathy based syntax used in descriptions of algorithms. (That is, I could see that line being used on a whiteboard, and it seeming like a good idea to allow it directly in code.)</p>
<p>But yes, I think trading away being able to do &#8220;tricks&#8221; like that so we have could assignments be statements instead of expressions and do away with some nonsense would be worthwhile. Keep in mind if you&#8217;re ever designing a new programming language.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1302556">
				<div id="div-comment-1302556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302556">
			July 19, 2017 at 1:07 pm</a>		</div>

		<p>Pascal and Basic (among others) make assignments first class sentences. Basic even had a keyword for that, LET, which got dropped latter. Both Pascal and Basic predate C (but IMHO are better suited for application development).</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4 parent" id="comment-1302626">
				<div id="div-comment-1302626" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://adamrosenfield.com' rel='external nofollow' class='url'>Adam Rosenfield</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302626">
			July 19, 2017 at 4:26 pm</a>		</div>

		<p>Python too.  Assignments are statements, not expressions, and you can&#8217;t chain them together at all.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1302627">
				<div id="div-comment-1302627" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://adamrosenfield.com' rel='external nofollow' class='url'>Adam Rosenfield</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302627">
			July 19, 2017 at 4:29 pm</a>		</div>

		<p>(That last phrase is wrong.  You can chain simple assignments like x=y=z=0.  But you cannot chain augmented assignments like x^=y^=x^=y)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1302617">
				<div id="div-comment-1302617" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://nbtparse.org' rel='external nofollow' class='url'>Kevin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302617">
			July 19, 2017 at 4:23 pm</a>		</div>

		<p>Python splits the difference: Chained assignments are legal because the language grammar makes it so, but assignment is a statement not an expression.  You can&#8217;t do &#8220;clever&#8221; things like while (data = file.read(length)), which I suppose might tend to annoy some people.  But the upshot is that you *never* confuse = with ==, because the former is a syntax error in expression context.</p>
<p>(I suppose you could write x == 5 when you intended to initialize x to 5, and Python would interpret this as an expression-statement, but I don&#8217;t see that error very often in practice.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-3" id="comment-1304097">
				<div id="div-comment-1304097" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timothy Byrd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1304097">
			July 28, 2017 at 12:41 am</a>		</div>

		<p>In Ruby, everything is an expression. All statements return a value. So this is valid:<br />
x = if 1 &gt; 2 then 3 else 4 end</p>
<p>And it has parallel assignment built-in, so this works to swap variables:<br />
x,y = y,x</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1302545">
				<div id="div-comment-1302545" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302545">
			July 19, 2017 at 11:16 am</a>		</div>

		<p>I would have expected that C#&#8217;s strict rules on order of evaluation would require the expression x ^= y ^= x ^= y to &#8216;work&#8217;.  I see now that C#&#8217;s rules on order of evaluation actually has two parts:</p>
<p>    1) operators are evaluated according to the rules of precedence and associativity, but<br />
    2) operands are evaluated strictly left to right</p>
<p>Item 2 means that both times `x` is used in the expression as a operand, it has the value that `x` started out with.  This ruins the xor-swap trick.</p>
<p>However, I&#8217;m going to confess that I still don&#8217;t feel that I understand how the &#8220;operands are evaluated strictly left to right&#8221; rule works when an operand is a sub-expression that is more complicated than a variable name. I&#8217;m not sure how important it is to understand that (which I think is the point of the article).</p>
<p>In this case the C++ situation is much simpler: all bets are off, the compiler can do whatever it wants. So there&#8217;s no point even trying to understand how the expression should work.  Though there is a point in understanding that even though you might be getting the result you expect, there is no guarantee of that and it&#8217;ll likely break at some point.  The solution is the same: don&#8217;t do that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd odd alt thread-even depth-1" id="comment-1302595">
				<div id="div-comment-1302595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302595">
			July 19, 2017 at 2:13 pm</a>		</div>

		<p>Eric Brumer [MSFT] has an excellent talk on Channel 9 about the thing that nobody considers much today: only 1% of your CPU is for computation. 99% of your CPU is dedicated to dealing with slow-memory, and re-writing your code (changing the order of instructions) so that it has to wait on memory less. </p>
<p><a href="https://channel9.msdn.com/Events/Build/2013/4-329" rel="nofollow">https://channel9.msdn.com/Events/Build/2013/4-329</a></p>
<p>Eric, if you&#8217;re around, your presentations are **great**! I wish there was more.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1302635">
				<div id="div-comment-1302635" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://reedbeta.com' rel='external nofollow' class='url'>Nathan Reed</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302635">
			July 19, 2017 at 4:34 pm</a>		</div>

		<p>Didn&#8217;t you just write such code with a straight face yourself only yesterday? ;) In your bytecode interpreter example:</p>
<p>  memory[NextUnsigned16()] = NextUnsigned8();</p>
<p>Presumably the NextUnsigned8/16 functions have side effects of advancing a buffer pointer, so this is nearly the equivalent of p[x++] = ++x.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1302646">
				<div id="div-comment-1302646" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene Hamilton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302646">
			July 19, 2017 at 7:08 pm</a>		</div>

		<p>FTA:<br />
The C# order of evaluation guarantees that the left hand side is evaluated before the right hand side. Therefore, the 16-bit unsigned integer is read first, and that value is used to determine which element of the memory array is being assigned. Then the 8-bit unsigned integer is read next, and that value is stored into the array element.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1302656">
				<div id="div-comment-1302656" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://reedbeta.com' rel='external nofollow' class='url'>Nathan Reed</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302656">
			July 19, 2017 at 8:33 pm</a>		</div>

		<p>Yes, I know, because I read Raymond&#8217;s post yesterday. :) The point is, that was effectively the same as the &#8220;insane code&#8221; Raymond&#8217;s complaining about today!</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1302685">
				<div id="div-comment-1302685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">The_Assimilator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302685">
			July 20, 2017 at 12:38 am</a>		</div>

		<p>The difference is that the behaviour is now contained in those methods, so callers theoretically do not have to worry about side effects. Plus the methods can now be tested to ensure they behave as expected, including not having unwanted side effects.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1302815">
				<div id="div-comment-1302815" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Warren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302815">
			July 20, 2017 at 1:19 pm</a>		</div>

		<p>Yes, this is the same thing. :-)   It just doesn&#8217;t seem as obfuscated because its got words instead of punctuation.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-even depth-1" id="comment-1302645">
				<div id="div-comment-1302645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302645">
			July 19, 2017 at 7:07 pm</a>		</div>

		<p>&gt;every variable killed a puppy<br />
Believe it or not, *every* local variable in Visual C (independent of scope) takes a separate location on the function stack, even in the release build. At least that&#8217;s what the VC code analysis thinks. There was that time when I had to go through a big IOCTL switch statement and prune those local pointers in case blocks (replace with a common variable on the top of function), otherwise the code analysis and SDV would not be happy because of stack size.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-odd thread-alt depth-1 parent" id="comment-1302655">
				<div id="div-comment-1302655" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302655">
			July 19, 2017 at 7:11 pm</a>		</div>

		<p>I once tried to convince my fellow programmer to fix this abomination in C code:</p>
<p>i = i++;</p>
<p>He kept telling that the compiler does what he wants (increments i) in this case. Even considering that previously he had a lecture from me on evils of writing code with undefined behavior.</p>
<p>I had to sneak a drive-by fix in another commit.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1302706">
				<div id="div-comment-1302706" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Viila</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302706">
			July 20, 2017 at 6:38 am</a>		</div>

		<p>&#8230;&#8230;.uhhh&#8230; even if it did do exactly what he wanted, why on Earth would he write that over just &#8220;i++;&#8221;?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1302716">
				<div id="div-comment-1302716" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302716">
			July 20, 2017 at 7:43 am</a>		</div>

		<p>As someone who cut my teeth on really slow processors (Z80s back in the 80s) and who worked in many tight nested loops, I know that:<br />
++i;<br />
as a simple statement is just about always preferable to:<br />
i++;<br />
I&#8217;m sure that a modern optimizer probably optimizes a simple post-increment statement to just an increment statement, but pre-increment never generate more code than a post increment (back in the day on my completely non-optimizing Z80 compiler, it was like the difference one instruction and five instructions).<br />
I&#8217;ve had many people remark that I always pre-increment the loop variable in a for-loop statement.  I worry when some of my colleagues don&#8217;t understand my explanation.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1302765">
				<div id="div-comment-1302765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BZ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302765">
			July 20, 2017 at 9:55 am</a>		</div>

		<p>I just write ++i, not i++ because that&#8217;s what K&amp;R has in its earliest examples</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-4 parent" id="comment-1303025">
				<div id="div-comment-1303025" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waitingForTheStorm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303025">
			July 21, 2017 at 8:20 am</a>		</div>

		<p>But you are mistaken in some cases.  On old Univac computers (1110, 1100/80, 1100/90) the instruction set included a hardware based post-increment operator that was free:  it happened as an integral part of the instruction interpretation in the central processor.  If memory serves, it happened on practically every instruction that included a reference to a memory location through one of the index registers (16 of said registers, 4 overlapped with the arithmetic register set).  It has been a long time, but I know that I used post incrementers all of the time on these engines because the math was free.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1303455">
				<div id="div-comment-1303455" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303455">
			July 24, 2017 at 4:02 pm</a>		</div>

		<p>That&#8217;s why I said &#8220;just about always preferable&#8221;; I&#8217;ve worked on oddball instruction set computers before (Data General Nova was perhaps the weirdest I worked on &#8211; I think that&#8217;s what I&#8217;m remembering).  Did your Univac post-increment really run faster than a pre-incrementing equivalent?  That would surprise me.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong even thread-even depth-1 parent" id="comment-1302666">
				<div id="div-comment-1302666" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302666">
			July 19, 2017 at 9:24 pm</a>		</div>

		<p>&#8220;Well, let&#8217;s see. I compiled this function five times, and I got the same result each time. The result looks reliable to me. Looks like a spurious warning.&#8221;</p>
<p>On yeah. I&#8217;ve had a hard time trying to convince my ex-colleague that &#8220;If you try to update any UI element on spawned thread, you need to check if Invoke is required first&#8221; back in the days everyone was still running WinXP. He said it works and always works on his computer, so directly updating the UI must be okay. //faceplam</p>
<p>And no, I left the company so I don&#8217;t know whether there were any customer hit by this.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2 parent" id="comment-1302715">
				<div id="div-comment-1302715" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302715">
			July 20, 2017 at 7:40 am</a>		</div>

		<p>But you *don&#8217;t* need to check if Invoke is required.  You just use BeginInvoke for all UI updates (unless they&#8217;re directly written in UI event handlers which are guaranteed always to run on the UI thread).  Control.Invoke already checks InvokeRequired, so for you to do it again is a waste.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong even depth-3" id="comment-1303305">
				<div id="div-comment-1303305" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303305">
			July 23, 2017 at 7:29 pm</a>		</div>

		<p>Well, my point is he&#8217;s not doing .Invoke() at all when trying to update UI from code that could be running on another thread.</p>
<p>And btw, I remember that .NET v1.x documentation still use:</p>
<p>if (control.InvokeRequired) { control.Invoke(somemethod); } else { somemethod(); }</p>
<p>pattern at that time.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302725">
				<div id="div-comment-1302725" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://commandlinefanatic.com' rel='external nofollow' class='url'>Josh</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302725">
			July 20, 2017 at 8:01 am</a>		</div>

		<p>Just wait until you see what Knuth does in Assembler&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ericlippert even thread-even depth-1 parent" id="comment-1302775">
				<div id="div-comment-1302775" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Eric+Lippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302775">
			July 20, 2017 at 10:03 am</a>		</div>

		<p>Thanks for the shout-out. I&#8217;m glad to see the return of CLR week!</p>
<p>I remember that book very well; it was by far the worst C# book I&#8217;ve ever edited. Tragically, I cannot find my review notes, otherwise I would share a few choice morsels.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1302825">
				<div id="div-comment-1302825" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Warren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302825">
			July 20, 2017 at 1:21 pm</a>		</div>

		<p>Of course, you only said all that to justify your own abusive coding practices!</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1302785">
				<div id="div-comment-1302785" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pliosoft.com' rel='external nofollow' class='url'>Christopher Lord</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302785">
			July 20, 2017 at 10:23 am</a>		</div>

		<p>I wish compilers with undefined behaviour would add a switch that randomized the undefined behaviour. If order of evaluation is undefined, let me compile with the order <i>actively</i> randomized. Then the issues will become apparent. Any dependency on the undefined behaviour will be more obvious. In that case, also emit the warnings so as to help guide people to the right places to fix.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ryan-ries odd alt thread-even depth-1 parent" id="comment-1302865">
				<div id="div-comment-1302865" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Ryan+Ries+%5BMSFT%5D' rel='external nofollow' class='url'>Ryan Ries [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302865">
			July 20, 2017 at 5:28 pm</a>		</div>

		<p>There is no shame in writing simple, dumb code.</p>
<p>If you exhaust all your cleverness writing the cleverest code possible, then you are, by definition, not smart enough to debug that code, because debugging the code takes even more cleverness than writing it did.</p>
<p>Don&#8217;t write code that you can&#8217;t debug. That&#8217;s my motto.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-ryan-ries even depth-2" id="comment-1302867">
				<div id="div-comment-1302867" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Ryan+Ries+%5BMSFT%5D' rel='external nofollow' class='url'>Ryan Ries [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302867">
			July 20, 2017 at 5:37 pm</a>		</div>

		<p>That&#8217;s paraphrased Brian Kernighan.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt depth-2 parent" id="comment-1302896">
				<div id="div-comment-1302896" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302896">
			July 20, 2017 at 7:21 pm</a>		</div>

		<p>But can God of Programming write a routine He can&#8217;t debug?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-ryan-ries even depth-3" id="comment-1302907">
				<div id="div-comment-1302907" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Ryan+Ries+%5BMSFT%5D' rel='external nofollow' class='url'>Ryan Ries [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302907">
			July 20, 2017 at 9:16 pm</a>		</div>

		<p>&lt;3</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302935">
				<div id="div-comment-1302935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kerrash</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302935">
			July 20, 2017 at 11:43 pm</a>		</div>

		<p>Entire article on how developers focus on the wrong things; comments focus on the closing statement&#8230; :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1302956">
				<div id="div-comment-1302956" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeff Moden</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302956">
			July 21, 2017 at 4:18 am</a>		</div>

		<p>BWAAAA-HAAAA!!!  And then those same people say that SQL is difficult! ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302965">
				<div id="div-comment-1302965" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">penguinapricot</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302965">
			July 21, 2017 at 5:37 am</a>		</div>

		<p>As someone who programmed 8-bit opcodes directly into a 256 byte ram connected to a z80,<br />
I laugh in a jovial and patronizing way at anybody who thinks the length or amount of C# lines they type has any relationship to execution speed or efficiency.<br />
You are using a super-high-level language, on top of an intelligent interpreter , on top of highly optimized API, on a super computer with endless amounts of memory, and multiple cores.</p>
<p>1. Put every operation, including &#8216;x++&#8217; on a separate line.<br />
2. Write, long meaningful comments.<br />
3. Give variable names, super long and meaningful names such as : &#8216;user_surname_abbreviated&#8217;</p>
<p>This is  so when other programmers need to fix your highly efficient, not-working code, we can understand what it&#8217;s meant to do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1302967">
				<div id="div-comment-1302967" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jorick.us' rel='external nofollow' class='url'>Ricky</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302967">
			July 21, 2017 at 5:56 am</a>		</div>

		<p>That&#8217;s illegal code.  Not necessarily for the compiler but for our company.  Since we sell devices that emit up to 3000 volts, any software engineer that tried to do this kind of programming and get it around our safety checks would be fired.  I&#8217;m sure he&#8217;d have a straight face when he was led out the door by Security.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1302976">
				<div id="div-comment-1302976" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Humphries</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1302976">
			July 21, 2017 at 6:44 am</a>		</div>

		<p>This will sound crazy, but I met a &#8216;developer&#8217; once who wrote some code to remove the comments from the source code prior to compilation, honestly believing it would result in a smaller faster executable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1303017">
				<div id="div-comment-1303017" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waitingForTheStorm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303017">
			July 21, 2017 at 8:13 am</a>		</div>

		<p>I have been a developer for a very long time (40+ years).  I dislike code with side-effects.  My coding style is a clear, top to bottom, simplistic flow of logic with simple declarative statements and straight-forward logical constructs.  Why?  Much more of the life cycle is support, and even 6 months after writing code, you will be like a newby to the code.  If you have to eat your own dog food, and I have most of my life, it engenders a simplistic discipline.  On almost every team I have joined, my colleagues can tell me that they know immediately when they walk into my code because it is a model of simplicity.  I have never had any complaints.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1303205">
				<div id="div-comment-1303205" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MikeB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303205">
			July 22, 2017 at 7:41 am</a>		</div>

		<p>I couldn&#8217;t agree more.  Simplicity is the first virtue to strive for.  I&#8217;ve said before that you should read my code and think I&#8217;m a bit of a simpleton.  Support is most of the life cycle and we all do more of that then anything else.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1303045">
				<div id="div-comment-1303045" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Patrick Thurmond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303045">
			July 21, 2017 at 8:42 am</a>		</div>

		<p>Death to hard to read code!!!</p>
<p>I am a code formatting Nazi. If I saw a pull request with crap like that come through, I would reject it out of hand and force the developer to clean up their act.</p>
<p>Given that I now manage a team of 12 developers I can be outright ruthless about it. But I do so with reason and I explain the reasons to the devs that make these mistakes. They have just gotten used to it and for the most part do it right. I let them slide on missing line breaks and spaces here an there though.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip odd alt depth-2" id="comment-1303155">
				<div id="div-comment-1303155" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303155">
			July 21, 2017 at 3:21 pm</a>		</div>

		<p>But do you go insane on things like:<br />
int *i; vs. int* i;?<br />
That is the real teller.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1303165">
				<div id="div-comment-1303165" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paulo Zemek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303165">
			July 21, 2017 at 3:47 pm</a>		</div>

		<p>About this case: p[x++] = ++x;<br />
I don&#8217;t know if this actually happens, but I can see this being interpreted in two different ways (depending on the compiler, optimizations etc).</p>
<p>int value = ++x;<br />
p[x++] = value;</p>
<p>or</p>
<p>int index = x++;<br />
p[index] = ++x;</p>
<p>Which would definitely yield different results.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-alegrigoriev odd alt depth-2" id="comment-1303286">
				<div id="div-comment-1303286" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303286">
			July 23, 2017 at 5:53 pm</a>		</div>

		<p>A third (legal) possible option is where &#8216;x&#8217; gets incremented only once.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even depth-2" id="comment-1303295">
				<div id="div-comment-1303295" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303295">
			July 23, 2017 at 5:55 pm</a>		</div>

		<p>(I&#8217;m talking about C, not C#, though)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1303175">
				<div id="div-comment-1303175" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.jazzsoftware.co.nz/default.aspx' rel='external nofollow' class='url'>Robert Barnes</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303175">
			July 21, 2017 at 4:52 pm</a>		</div>

		<p>In my 1975 PL/I textbook (&#8220;PL/I for Programmers&#8221;) my second rule of quality was &#8220;A program must be obvious&#8221; (the first was &#8220;A program must be correct&#8221;).  Later these became one rule &#8220;A program must be obviously correct&#8221;.   Efficiency is unimportant if this rule is broken: I don&#8217;t care how quickly you can do something that might be wrong.<br />
    a -= a *= a;<br />
    p[x++] = ++x;<br />
fail the &#8220;obvious&#8221; test so it&#8217;s bad code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1303265">
				<div id="div-comment-1303265" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark W Allen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303265">
			July 23, 2017 at 6:17 am</a>		</div>

		<p>Some people do it just to be obtuse on purpose</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1303427">
				<div id="div-comment-1303427" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170719-00/?p=96645#comment-1303427">
			July 24, 2017 at 12:14 pm</a>		</div>

		<p>This has been going on for ages at mcrosoft, when will you learn? Don&#8217;t optimize the experience for develpers who cannot be bothered to learn the profession, you should not  care about these stereotypical developers who write bad code. Instead optimize the experience for professional developers who write good code.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

