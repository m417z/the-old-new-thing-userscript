<html>
<head>
<title>The apocryphal history of file system tunnelling</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The apocryphal history of file system tunnelling</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 15, 2005 / year-entry #191</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">One of the file system features you may find yourself surprised by is tunneling, wherein the creation timestamp and short/long names of a file are taken from a file that existed in the directory previously. In other words, if you delete some file "File with long name.txt" and then create a new file with the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>One of the file system features you may find yourself surprised by is tunneling, wherein the creation timestamp and short/long names of a file are taken from a file that existed in the directory previously. In other words, if you delete some file "File with long name.txt" and then create a new file with the same name, that new file will have the same short name and the same creation time as the original file. You can <a href="http://support.microsoft.com/?kbid=172190"> read this KB article</a> for details on what operations are sensitive to tunnelling.</p>
<p> Why does tunneling exist at all? </p>
<p> When you use a program to edit an existing file, then save it, you expect the original creation timestamp to be preserved, since you're editing a file, not creating a new one. But internally, many programs save a file by performing a combination of save, delete, and rename operations (such as the ones listed in the linked article), and without tunneling, the creation time of the file would seem to change even though from the end user's point of view, no file got created. </p>
<p> As another example of the importance of tunneling, consider that file "File with long name.txt", whose short name is say "FILEWI~1.TXT". You load this file into a program that is not long-filename-aware and save it. It deletes the old "FILEWI~1.TXT" and creates a new one with the same name. Without tunnelling, the associated long name of the file would be lost. Instead of a friendly long name, the file name got corrupted into this thing with squiggly marks. Not good. </p>
<p> But where did the name "tunneling" come from? </p>
<p> From quantum mechanics. </p>
<p> Consider the following analogy: You have two holes in the ground, and a particle is in the first hole&nbsp;(A) and doesn't have enough energy to get out. It only has enough energy to get as high as the dotted line. </p>
<table cellspacing="0">
<tr>
<td style="border-top: solid .75pt black;                border-right: solid .75pt black;                border-bottom: dotted .75pt black">&nbsp;</td>
<td style="width: 2em; border-bottom: dotted .75pt black">&nbsp;</td>
<td style="border-top: solid .75pt black; width: 2em;                border-left: solid .75pt black;                border-right: solid .75pt black;                border-bottom: dotted .75pt black">&nbsp;</td>
<td style="width: 2em; border-bottom: dotted .75pt black">&nbsp;</td>
<td style="border-top: solid .75pt black;                border-left: solid .75pt black;                border-bottom: dotted .75pt black">&nbsp;</td>
</tr>
<tr>
<td style="border-right: solid .75pt black">&nbsp;</td>
<td align="CENTER" style="border-bottom: solid .75pt black">A</td>
<td style="border-left: solid .75pt black;                border-right: solid .75pt black;">&nbsp;</td>
<td align="CENTER" style="border-bottom: solid .75pt black">B</td>
<td style="border-left: solid .75pt black">&nbsp;</td>
</tr>
</table>
<p> You get distracted for a little while, maybe watch  <a href="http://www.superbowl.com/">the Super Bowl</a> halftime show, and when you come back, the particle somehow is now in hole&nbsp;B. This is impossible in classical mechanics, but thanks to the wacky world of quantum mechanics, it is not only possible, but <strong>actually happens</strong>. The phenomenon is known as <a href="http://scienceworld.wolfram.com/physics/Tunneling.html"> tunneling</a>, because it's as if the particle "dug a tunnel" between the two holes, thereby allowing it to get from one hole to another without ever going above the dotted line. </p>
<p> In the case of file system tunneling, it is information that appears to violate the laws of classical mechanics. The information was destroyed (by deleting or renaming the file), yet somehow managed to reconstruct itself on the other side of a temporal barrier. </p>
<p> The developer who was responsible for implementing tunneling on Windows&nbsp;95 got kind of carried away with the quantum mechanics analogy: The fragments of information about recently-deleted or recently-renamed files are kept in data structures called "quarks". </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-290653">
				<div id="div-comment-290653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nate</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290653">
			July 15, 2005 at 10:46 am</a>		</div>

		<p>I can see why you would want the long file name to be tunneled, because of this scenario of when a file is edited with a non-LFN aware application, but why is the creation date preserved?  If an application does a savetemp/delete/rename operation to save a file, the expected behavior from such an app would be to be to have a shiny new creation date.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290663">
				<div id="div-comment-290663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Janne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290663">
			July 15, 2005 at 10:59 am</a>		</div>

		<p>I&#8217;m guessing this &quot;safe save&quot; was used by a large number of old DOS (and old Windows) programs to avoid the risk of losing all versions of a file if the computer crashed (or suffered a power failure) during the write operation, since FAT wasn&#8217;t a journaled file system like NTFS. And, if my memory isn&#8217;t lacking, FAT didn&#8217;t HAVE a &quot;creation date&quot; until Windows 95, so that&#8217;s when the problem first came into existance.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290673">
				<div id="div-comment-290673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290673">
			July 15, 2005 at 11:13 am</a>		</div>

		<p>It goes well beyond &quot;if the computer crashes&quot;.  The last thing you want to do is delete your original and then hope your software will be able to write the new file.  If it fails, you have lost all the users work.</p>
<p>Assume your program will fail during the serialization of the new file.  What will the user be able to do when the program fails?  Sure, it is rare, but it is also very easy to implement a backup system that helps protect against failures.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290683">
				<div id="div-comment-290683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">A regular viewer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290683">
			July 15, 2005 at 11:13 am</a>		</div>

		<p>Totally OT, did you use a tool to generate that neat image using &lt;table&gt; tags, if so which one? If you hand coded that image/table, a darned good job.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290713">
				<div id="div-comment-290713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.noveltheory.com' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290713">
			July 15, 2005 at 11:35 am</a>		</div>

		<p>um.. if this is the &quot;apocryphal&quot; history&#8230;. What&#8217;s the real one?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-patriotb odd alt thread-odd thread-alt depth-1" id="comment-290723">
				<div id="div-comment-290723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">PatriotB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290723">
			July 15, 2005 at 11:44 am</a>		</div>

		<p>Unfortunately, tunneling didn&#8217;t help Visual C++ 6.  Everytime you save a file, the create date is wiped out and replaced with the current date/time.</p>
<p>Looks like its fixed in VS.NET and newer versions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290733">
				<div id="div-comment-290733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">vince</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290733">
			July 15, 2005 at 11:51 am</a>		</div>

		<p>Why not just have the application get the original creation time, and then when it creates the new file, update the creation time of the new file to be the same as the old one?</p>
<p>This is the way *NIX editors work, and it seems like the task is much more appropriate to userspace than kernel space.</p>
<p>Especially if your app makes the (reasonable) assumption that if it deletes an old file and creates a new one with the same name that is should have the new creation date.</p>
<p>I cringe to think of how many other silly hacks like this are cluttering up the windows kernel.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290753">
				<div id="div-comment-290753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290753">
			July 15, 2005 at 12:27 pm</a>		</div>

		<p>Wow&#8230; Short file names. It&#8217;s a good thing that I run &quot;fsutil behavior set disable8dot3 1&quot; immediately after installing a fresh copy of XP. Significantly improves the installation of programs with 10s of 1000s of files (like Visual Studio).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290763">
				<div id="div-comment-290763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.highprogrammer.com/alan/' rel='external nofollow' class='url'>Alan De Smet</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290763">
			July 15, 2005 at 12:27 pm</a>		</div>

		<p>Re: why not have the application handle setting the creation time correctly?</p>
<p>Because while you are a conscientious developer who always does the Right Thing, there are many developers who are sloppy, who don&#8217;t care, or just accidentally overlooked subtle rule 47.A.iv &quot;On replacing files&quot;.</p>
<p>While applications should be responsible for many things, ultimately it&#8217;s up the OS to try and provide some level of consistency.  This is how &quot;silly hacks&quot; like protected memory, preemptive multi-tasking, and OS enforced file permissions get into kernels.</p>
<p>I will note that strictly speaking Unix-like systems don&#8217;t have a &quot;create&quot; time; they have a &quot;change&quot; time which tracks the last change to the inode.  And enough programs replace files by clobbering the original that the ctime is usually the same as m(odified)time.</p>
<p>I&#8217;m not sure I agree with this particular hack; but I&#8217;m sympathetic to the design.  Ultimately the lack of reliable ctimes on Unix has never been a problem for me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290783">
				<div id="div-comment-290783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290783">
			July 15, 2005 at 12:59 pm</a>		</div>

		<p>I tried disabling short filenames for a while. I was surprised to find that it was me rather than any of my software that was incompatible. I have this habit &#8212; that I hadn&#8217;t really noticed until it didn&#8217;t work anymore &#8212; of performing the sequence Ctrl+Esc, R, c:progra~1 (or c:docume~1). Without the short filenames stored, that doesn&#8217;t work anymore.</p>
<p>I also use a similar trick to install programs whose installers are intolerant of paths containing spaces. (Usually, they don&#8217;t bother to call GetLongFileName either)</p>
<p>Is there a way, I wonder, to have progra~1 and docume~1 work without bothering to store them anywhere else? I suppose I could just create a junction point at c:progra~1 pointing at c:program files, but then c:progra~1 will show up in directory listings, and stupid programs like the lame virus scanner I use will end up checking it all twice. Bleh.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290793">
				<div id="div-comment-290793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290793">
			July 15, 2005 at 1:10 pm</a>		</div>

		<p>Nate: &gt;&gt; but why is the creation date preserved &lt;&lt;</p>
<p>This is done because the file systems on 32-bit Microsoft platforms support 3 time stamps for files:  Creation, Last Access, and Last Modified.  So the creation time stamp should be preserved when the editor &#8216;saves&#8217; the file, but the other time stamps will be updated.</p>
<p>vince: &gt;&gt; Why not just have the application get the original creation time, and then when it creates the new file, update the creation time of the new file to be the same as the old one? &lt;&lt;</p>
<p>I&#8217;d guess that the primary reason is so that legacy applications that were written for platforms (MS-DOS, Win16) that have no concept of a Creation timestamp &#8211; only a Last modified timestamp &#8211; would work in the expected manner on newer filesystems.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290803">
				<div id="div-comment-290803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mg.to/' rel='external nofollow' class='url'>Michael Geary</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290803">
			July 15, 2005 at 1:36 pm</a>		</div>

		<p>&quot;I&#8217;m guessing this &#8216;safe save&#8217; was used by a large number of old DOS (and old Windows) programs to avoid the risk of losing all versions of a file if the computer crashed (or suffered a power failure) during the write operation, since FAT wasn&#8217;t a journaled file system like NTFS.&quot;</p>
<p>Whoa there. I don&#8217;t think NTFS journaling will protect your data if a program does an &quot;unsafe&quot; save by directly overwriting the original file data in place. The &quot;safe&quot; save technique is needed on NTFS as much as any other filesystem. (Or am I mistaken?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290813">
				<div id="div-comment-290813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mg.to/' rel='external nofollow' class='url'>Michael Geary</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290813">
			July 15, 2005 at 1:38 pm</a>		</div>

		<p>&quot;I&#8217;m guessing this &#8216;safe save&#8217; was used by a large number of old DOS (and old Windows) programs to avoid the risk of losing all versions of a file if the computer crashed (or suffered a power failure) during the write operation, since FAT wasn&#8217;t a journaled file system like NTFS.&quot;</p>
<p>Whoa there. I don&#8217;t think NTFS journaling will protect your data if a program does an &quot;unsafe&quot; save by directly overwriting the original file data in place. The &quot;safe&quot; save technique is needed on NTFS as much as any other filesystem. (Or am I mistaken?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290823">
				<div id="div-comment-290823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">waleri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290823">
			July 15, 2005 at 1:41 pm</a>		</div>

		<p>Yet another problem with save/delete/rename scenario is that if edited file is actualy a hard link, the link is broken. Whether this is a good or bad thing, depends entirely on your own point of view. Actually, I&#8217;ve never used an editor that can handle this situation correctly, which means that all those editors creates a new file and modify creation date</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290833">
				<div id="div-comment-290833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290833">
			July 15, 2005 at 2:06 pm</a>		</div>

		<p>Somebody should probably mention the ReplaceFile api which does the delete/rename/fixup in a more controlled way and handles stuff like getting the security reset correctly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-290853">
				<div id="div-comment-290853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290853">
			July 15, 2005 at 2:37 pm</a>		</div>

		<p>I was wondering why I didn&#8217;t know about ReplaceFile, but I see it first appeared in Windows 2000.</p>
<p>NTFS journalling does not protect user data, it only protects filesystem data. All that NTFS guarantees is that a valid consistent filesystem will be available after recovery.</p>
<p>&quot;Transactional NTFS&quot; is scheduled in for Longhorn, but this still won&#8217;t protect every user data write. It&#8217;s opt-in, and from what I&#8217;ve heard, moderately expensive in terms of time. The only way it can work, IMO, is if it logs all writes (both the before and after images, so the write can be rolled back if required) to the log file, then makes the changes in cache.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290863">
				<div id="div-comment-290863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290863">
			July 15, 2005 at 2:42 pm</a>		</div>

		<p>I&#8217;m with vince, this is cringe-worthy. Apple didn&#8217;t do hacks like this when moving Mac OS 9 from 32 ASCII to 255 Unicode characters; app upgrades are required for preservation of long file names. Admittedly, 32 is a lot of characters in the first place, so the problem is less acute, but you really don&#8217;t want to have to live with this sort of hack forever. The downside is too user-visible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290873">
				<div id="div-comment-290873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cyrille Ch&#233;p&#233;lov</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290873">
			July 15, 2005 at 3:24 pm</a>		</div>

		<p>Michael Geary: last I, uh, experienced it, NTFS exhibits at best a metadata-journalling behaviour.</p>
<p>To afford doing what you describe, you need a file system with complete transaction semantics, and an implementation that supports those. To the extent that its debugging went enough ahead, &lt;a href=&quot;www.namesys.com&quot;&gt;reiser4&lt;/a&gt; might be an example, but leveraging its atomic capabilities requires a significant userland cooperation (meaning that in a Win32 land, with exatons of stuff to support, you simply can&#8217;t do it)</p>
<p>Now, give me an atomic TernaryRenameAndCopyAttributes(LPCTSTR FileName, LPCTSTR BackupName, LPCTSTR ReplacementName); :-)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290883">
				<div id="div-comment-290883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">informator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290883">
			July 15, 2005 at 4:23 pm</a>		</div>

		<p>To Mike Dimmick:</p>
<p>Yes, and don&#8217;t forget that on IDE drives (and most of SATA drives) disk controller&#8217;s cache data are not written through even if you&#8217;re using unbuffered IO/write through flag. The reliable way here is to issue FlushFileBuffers after log write to make sure that log write data are in the media, then write data and issue another FlushFileBuffers call. This is required because when FlushFileBuffers is called, the pending writes in the controller&#8217;s cache may be written to the media in non-chronological order (this is for IDE/most of SATA drives).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290913">
				<div id="div-comment-290913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290913">
			July 15, 2005 at 4:57 pm</a>		</div>

		<p>Except that some (but very few) IDE drives don&#8217;t flush their caches even when the OS tells them to &#8212; I believe this was a performance hack, though I don&#8217;t know for sure.</p>
<p>I do know that it&#8217;s what prompted the Win95 or 98 (can&#8217;t remember which) &quot;shutdown update&quot;.  The update merely prolonged the OS shutdown, though, to try to get the problematic drive(s) to flush its/their cache before it/they lost power.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290693">
				<div id="div-comment-290693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arlie Davis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290693">
			July 15, 2005 at 11:24 am</a>		</div>

		<p>Perhaps the *app* expects a new, shiny date, but the *user* certainly does not.</p>
<p>This is the right behavior in 99.9% of all situations.  The tunneling behavior only kicks in during short time windows, when certain sequences of operations occur.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290743">
				<div id="div-comment-290743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">vince</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290743">
			July 15, 2005 at 12:21 pm</a>		</div>

		<p>How embarassing, I misunderstood what typical *NIX editors do (yes I had checked code before posting my previous post, but misunderstood).</p>
<p>*NIX filesystems actually don&#8217;t store the creation time at all, so this is a non-problem for editors.  What confused me is when an editor makes a backup copy when you start making changes to a file, it does preserve the access/modified times for you.</p>
<p>I still stand by my claim that having the OS doing what windows does is needless bloat though and unwisely causes hidden side-effects to simple code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290923">
				<div id="div-comment-290923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290923">
			July 15, 2005 at 9:07 pm</a>		</div>

		<p>ReplaceFile &#8211; Drool&#8230;</p>
<p>In my last job I had to support 95+/NT4+ so I often lost track of new API.  Now that I don&#8217;t have those restrictions, I really need to review the API library.</p>
<p>I have some code to fix so it start uses ReplaceFile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290933">
				<div id="div-comment-290933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ipoverscsi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290933">
			July 15, 2005 at 10:16 pm</a>		</div>

		<p>I would seriously like to thank you for pointing out this tunneling phenomenon.  I once wrote a program that looked for new files by checking the creation time that consistently failed because of this issue.  It took me a while to figure out that tunneling was occurring, but I assumed it was merely a fluke of accessing the file over a share.  My coworkers, of course, didn&#8217;t believe me that this was occurring.  Now I can finally say &#8216;I told you so.&#8217; :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-290943">
				<div id="div-comment-290943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290943">
			July 16, 2005 at 7:55 am</a>		</div>

		<p>Friday, July 15, 2005 10:59 AM by Janne<br />
<br />&gt; I&#8217;m guessing this &quot;safe save&quot; was used by a<br />
<br />&gt; large number of old DOS (and old Windows)<br />
<br />&gt; programs to avoid the risk of losing all<br />
<br />&gt; versions of a file if the computer crashed<br />
<br />&gt; (or suffered a power failure) during the<br />
<br />&gt; write operation,</p>
<p>I also think so, and this actually made a large number of old DOS programs smarter than a large number of old Unix programs.  In 1976 I used the &quot;ed&quot; editor in Unix (&quot;vi&quot; hadn&#8217;t been invented yet) to make a few changes to a file of around 1,000 lines, typed the &quot;w&quot; command, and didn&#8217;t get any feedback.  When Unix came back up, it had never heard of my file, not the old version, not the new version.  A few years later I saw companies advertising database systems running on Unix and I couldn&#8217;t believe that anyone would use such a system for anything important.  A few more years later, I finally got used to the idea that Unix was becoming somewhat reliable.  (A few more years later, Windows 95 taught me that Unix had not been the world&#8217;s most unreliable OS.)</p>
<p>Friday, July 15, 2005 2:37 PM by Mike Dimmick<br />
<br />&gt; NTFS journalling does not protect user data,<br />
<br />&gt; it only protects filesystem data.</p>
<p>Agreed.  After a BSOD, files that had been open for writing often have a few sectors of binary zeroes instead of data that the user thought they had written.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-290973">
				<div id="div-comment-290973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-290973">
			July 16, 2005 at 11:52 am</a>		</div>

		<p>Friday, July 15, 2005 2:37 PM by Mike Dimmick<br />
<br />&quot;Transactional NTFS is scheduled in for Longhorn, but this still won&#8217;t protect every user data write. It&#8217;s opt-in, and from what I&#8217;ve heard, moderately expensive in terms of time. The only way it can work, IMO, is if it logs all writes (both the before and after images, so the write can be rolled back if required) to the log file, then makes the changes in cache.&quot;</p>
<p>You can do better than this, and I believe reiser4 does.  You write any changes to free sectors on the disk.  When the write is committed you update the metadata to point at the new data instead of the old data (or write the metadata changes to the transaction log).  If the write is rolled-back you put the new sectors back on the free list.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-291003">
				<div id="div-comment-291003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-291003">
			July 17, 2005 at 1:02 am</a>		</div>

		<blockquote><p>
  Transactional NTFS is scheduled for Longhorn</p>
<p>Netware had transactional filesystem support (TTS) back in the early 1990&#8217;s.  It&#8217;s amazing that NTFS still hasn&#8217;t caught up.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding odd alt thread-odd thread-alt depth-1" id="comment-291023">
				<div id="div-comment-291023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-291023">
			July 17, 2005 at 8:01 pm</a>		</div>

		<blockquote><p>
  Netware had transactional filesystem support (TTS) back<br />
  <br />&gt; in the early 1990&#8217;s. It&#8217;s amazing that NTFS still hasn&#8217;t<br />
  <br />&gt; caught up.</p>
<p>I just had a look at TTS, and it&#8217;s really nothing like TNTFS.  TTS only works for certain files and for certain changes, whereas TNTFS works for any file and any type of change.  Also, it uses the new &quot;kernel&quot; transactions, so anything else that supports kernel transactions can be modified in the same transaction (for example, the registry also supports them).  They also participate in COM+ and DTS transactions, so you can join them to database transactions and have the whole operation atomic.</p>
<p>&gt; I&#8217;m with vince, this is cringe-worthy. Apple didn&#8217;t do hacks<br />
  <br />&gt; like this when moving Mac OS 9 from 32 ASCII to 255 Unicode<br />
  <br />&gt; characters; app upgrades are required for preservation<br />
  <br />&gt; of long file names.</p>
<p>Yes, well, we all know Apple&#8217;s stance on backwards-compatibility&#8230;
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-291033">
				<div id="div-comment-291033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">William</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-291033">
			July 17, 2005 at 10:25 pm</a>		</div>

		<p>&quot;Quarks&quot;&#8230; so could we expect the color theory being implemented somewhere? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-291043">
				<div id="div-comment-291043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">vince</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-291043">
			July 18, 2005 at 12:09 am</a>		</div>

		<p>Dean Harding Said:<br />
<br />&gt; Yes, well, we all know Apple&#8217;s stance on<br />
<br />&gt; backwards-compatibility&#8230;</p>
<p>Was that meant as sarcasm?  Apple has done an admirable job of keeping backwards compatibility going, including changes of architecture (m68k to ppc, the forthcoming ppc to x86) and vast changes in OS design (classic under  OSX).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-291063">
				<div id="div-comment-291063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.zabkat.com' rel='external nofollow' class='url'>nikos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-291063">
			July 18, 2005 at 9:51 am</a>		</div>

		<p>waleri:</p>
<p>&gt;Yet another problem with save/delete/rename<br />
<br />&gt;scenario is that if edited file is actualy<br />
<br />&gt;a hard link, the link is broken</p>
<p>this is my pet peeve too<br />
<br />most editors (including Visual studio) cause it, and in the old days at least the MFC CFile class was to blame that does all this rename/delete in the background whenever you save.</p>
<p>surely some other &quot;safety&quot; alternative could be possible, e.g. saving a backup in TEMP or whatever</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-291843">
				<div id="div-comment-291843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CN</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-291843">
			July 21, 2005 at 10:36 am</a>		</div>

		<p>Carlos:</p>
<p>I imagine that the actual implementation uses the free sector approach. After all, this should be quite comparable to what the current Volume Shadow feature does.</p>
<p>(Hey, you could do semi-transactions today by quickly manipulating volume shadows. The performance would be a joke, but it would be kind of fun.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-293013">
				<div id="div-comment-293013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GregM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-293013">
			July 27, 2005 at 1:05 pm</a>		</div>

		<p>Mike, thank you for mentioning ReplaceFile.  I would have used this API a few weeks ago had I known about it.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-295253">
				<div id="div-comment-295253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://bloggingabout.net/blogs/erwyn/archive/2005/08/08/8841.aspx' rel='external nofollow' class='url'>Erwyn van der Meer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050715-14/?p=34923#comment-295253">
			August 8, 2005 at 9:07 am</a>		</div>

		<p>Today I experienced some strange unexpected log&amp;amp;nbsp;file roll-overs when logging messages using the&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

