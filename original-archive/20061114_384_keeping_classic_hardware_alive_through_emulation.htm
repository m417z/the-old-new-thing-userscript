<html>
<head>
<title>Keeping classic hardware alive through emulation</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Keeping classic hardware alive through emulation</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 14, 2006 / year-entry #385</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>25</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">At the Windows†2000 Conference and Expo which coincided with the operating system's launch, I paid a visit to the emulators.com booth, where they were excitedly showing off SoftMac†2000, a Mac emulator that ran on Windows†2000. Emulator trivia: MacOS booted in five seconds under Windows†2000, which was faster than the real Mac, because the emulator simulated...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>At the Windows&nbsp;2000 Conference and Expo which coincided with the operating system's launch, I paid a visit to the <a href="http://www.emulators.com/">emulators.com</a> booth, where they were excitedly showing off SoftMac&nbsp;2000, a Mac emulator that ran on Windows&nbsp;2000. Emulator trivia: MacOS booted in five seconds under Windows&nbsp;2000, which was <strong>faster</strong> than the real Mac, because the emulator simulated a 1GB Mac so the Mac memory manager never had to do any paging. Now, the host computer didn't have 1GB of real RAM, so the host computer was still paging, but it turns out that you're better off letting the Windows&nbsp;2000 kernel do the paging than the copy of MacOS running inside the emulator.</p>
<p> Anyway, Darek Mihocka, the proprietor of emulators.com, has started <a href="http://www.emulators.com/secrets.htm"> posting his thoughts on Intel's new Core 2</a>, and given the promo titles of his upcoming entries, it looks like he's going to start digging into running Vista on his Mac Pro. </p>
<p> But all of this yammering about emulation is just a sideshow to the real issue: The picture of the hardware that Darek's retiring. I mean, look at it. He's retiring more computers than I own! I bet he's one of those people who relocates his computers during the winter in order to use them as space heaters. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (25)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-442253">
				<div id="div-comment-442253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Puckdropper</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442253">
			November 14, 2006 at 10:21 am</a>		</div>

		<p>I only counted 5 systems in the picture. &nbsp;I&#8217;ve got 4 systems on my desk at home&#8230; and another 2 at school, and another 3 sitting on the entertainment center&#8230;</p>
<p>Granted, they&#8217;re all 8088s &#8211; Pentium 4s, but 5 systems is nothing to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442263">
				<div id="div-comment-442263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anon for good reason</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442263">
			November 14, 2006 at 10:46 am</a>		</div>

		<p>&quot;the real issue: The picture of the hardware that Darek&#8217;s retiring.&quot;</p>
<p>Hey can you upload that picture please?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442283">
				<div id="div-comment-442283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.damieng.com/blog/' rel='external nofollow' class='url'>damien@envytech.co.uk</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442283">
			November 14, 2006 at 11:35 am</a>		</div>

		<p>Letting Windows 2000 do the paging will, of course, be faster because it&#8217;s paging is native x86 code running on x86 hardware.</p>
<p>If you let MacOS do the paging you&#8217;re emulating the 68000/PPC code that does the paging as well as the memory management hardware that makes it possible.</p>
<p>[)amien</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442293">
				<div id="div-comment-442293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ale</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442293">
			November 14, 2006 at 11:40 am</a>		</div>

		<p>I think you missed what he was saying damieng. The boot was faster under emulation then on native hardware because Windows 2000 is better at paging.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442303">
				<div id="div-comment-442303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ping?</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442303">
			November 14, 2006 at 11:45 am</a>		</div>

		<p>But is Windows better at paging, or was it simply due to running it on faster hardware than the original Mac?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442333">
				<div id="div-comment-442333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442333">
			November 14, 2006 at 12:07 pm</a>		</div>

		<p>As I understand it, older Macs used a rather obscure page-replacement algorithm (FIFO with a second chance for pages used since the last time around), so it isn&#8217;t suprising that Win2K&#8217;s LRU replacement works somewhat better.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442343">
				<div id="div-comment-442343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">kbiel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442343">
			November 14, 2006 at 12:09 pm</a>		</div>

		<p>The year being 2000, tells me that Raymond was witnessing a MacOS 9 installation. &nbsp;It wasn&#8217;t until OS X (released in March of 2001) that the Mac had a flat memory model and a decent memory manager. &nbsp;It didn&#8217;t even have true pre-emptive multitasking until OS X. &nbsp;That is why it worked faster in emulation with Windows 2000 doing the real paging.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442353">
				<div id="div-comment-442353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TimMisiak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442353">
			November 14, 2006 at 12:16 pm</a>		</div>

		<p>Raymond, looks like you just got slashdotted&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442373">
				<div id="div-comment-442373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442373">
			November 14, 2006 at 12:23 pm</a>		</div>

		<p>anon for good reason: &nbsp;The pictures are shown at the blog that Raymond linked to.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442513">
				<div id="div-comment-442513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene Hamilton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442513">
			November 14, 2006 at 3:07 pm</a>		</div>

		<p>I also guess it&#8217;s better to have let Win2k do all the paging not because it does a better job, but more because the two memory managers don&#8217;t &#8220;fight&#8221; each other.</p>
<p>Imagine that MacOS believes that a bunch of pages are in memory, but the Win2k memory manager has them paged out to disk. &nbsp;It uses those pages, causing Windows to pull the pages back into memory, while maybe paging more stuff back to disk that the MacOS memory thinks is still in memory.</p>
<div class=post>[<i>That doesn&#8217;t explain why it&#8217;s faster than a native Mac. There is no &#8220;fighting&#8221; when you run MacOS on a Mac. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442523">
				<div id="div-comment-442523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene Hamilton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442523">
			November 14, 2006 at 3:20 pm</a>		</div>

		<p>I didn&#8217;t say that is the reason why it runs faster. &nbsp;My comment was directed more at the logic of letting the emulator simulate 1GB of Mac memory and why it was better to let Win2k handle it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442543">
				<div id="div-comment-442543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Good at bad things</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442543">
			November 14, 2006 at 3:50 pm</a>		</div>

		<p>Windows is optimized to swap. It&#8217;s a long tradition of all windows versions. Other OS doesn&#8217;t rely heavily on swapping to disk, windows starts swapping long before the physical memory is consumed. Is it even possible to run windows without a swapfile?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442553">
				<div id="div-comment-442553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442553">
			November 14, 2006 at 4:15 pm</a>		</div>

		<p>Having used SoftMac, I know that it only emulates 680&#215;0 Macs.</p>
<p>Seeing as you are emulating a ~1994 computer on a ~2000 computer, it&#8217;s highly likely that the emulated computer is faster than any real 680&#215;0 Mac. Thus the observed results are unsurprising.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442593">
				<div id="div-comment-442593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.emulators.com' rel='external nofollow' class='url'>Darek</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442593">
			November 14, 2006 at 5:13 pm</a>		</div>

		<p>You&#8217;d be surprised how many people did not find it unsurprising. You have to remember, when I was demoing SoftMac at Macworld Expo New York in 1999, a) the public perception of PCs in 1999 was that they were slower than Macs, and b) that emulation was a slow technology.</p>
<p>Back then it was really quite the uphill battle to convince people that what they were witnessing actual unmodified Mac OS 8.1 bits booting on Intel hardware and educate them about those myths.</p>
<p>It&#8217;s not simply an issue of emulating 68040 being fast. 68040 is quite a difficult instruction set to emulate. That&#8217;s compounded by the fact that a lot of Mac code used self-modifying tricks and executing in middle of instructions and such. Getting that right is hard. When I did the PowerPC emulation on x86 a couple years later, it actually turned out to be easier to emulate. PowerPC can be emulated at a faster speed levels than 68040. (Just look at the perf of Rosetta on Intel Macs, validation that Intel processors truly are faster than PowerPC and that emulation is not inherently a slow technology).</p>
<p>It&#8217;s also not an issue of emulating 1994 hardware on 2000 hardware. At the 1999 Macworld, I was running a 1999 era PC (450 MHz Pentium III running Windows 98) booting a 1998 OS (Mac OS 8.1) on 1997 virtual hardware (Mac Quadra). Remember, new Mac Quadra models were still being released in 1997, and what blew people&#8217;s minds was seeing a $2000 PC emulating a $5000 Quadra, and faster than any real Quadra. After all, the main selling point of the Quadra was it was the fast Mac, and thus the selling point of SoftMac at that time was that it was a software solution that gave them faster-than-real-time emulation of $5000 Mac hardware on $2000 PC hardware. Oh how I loved to rub that in to the die-hard Mac fanatics &lt;grin&gt;</p>
<p>Even users of PowerPC based Macs (which in 1999 would have been various G3 machines running Mac OS 8.x) were surprised to see Mac OS 8.1 boot up MUCH faster than they&#8217;d seen on a real Mac. It was not uncommon for people to look under the table to verify that I didn&#8217;t actually have a real Mac under the table. At future demos, I used a Gateway laptop for the demos to quash that and at the 2001 Macworld Tokyo I used a handheld Sony VAIO to really drive that point home.</p>
<p>What non-technical people didn&#8217;t realize in the late 1990&#8217;s is that Windows PCs were far better suited for emulation than Macs were. Why?</p>
<p>As has been mentioned, virtual memory and swapping was MUCH faster on Windows than wa simplemented in the Mac OS. The Mac ran faster when VM was off, but most Macs were being run with VM on. So by emulating a virtal Macintosh with up to 1 gigabyte of physical RAM and booting the Mac OS with its own VM disabled, that did in fact give huge speedsups.</p>
<p>But the other main factor was due to the superior design of the P6 processor architecture, which appeared first in the Pentium Pro processor, and then later the Pentium II, Pentium III, and today in Core Duo based Macs. I can go into technical details if anyone cares, but it was really after playing around with a Pentium Pro in 1996 that led me to decide to write a Mac emulator for Windows and realize there was a profitable business opportunityh there. For both 68040 and PowerPC emulation, the P6 architecture can effectively emulate those processors in software with only about a 2x to 4x perceived clock cycle slowdown, which is generally much faster than wehn you go the other way around. Add to that the VM advantage, the faster memory bandwidth and FSB speeds, the larger L1 and L2 caches on x86 processors, and it literally allowed for close to real-time emulation. Thus demoing a 500 MHz virtual Macintosh to people whose real hardware was a 33 to 300 MHz Macintosh did make a lot of jaws drop.</p>
<p>For the February 2000 demo at the Windows 2000 launch that Raymond refered to, I also had the benefit of a 600 MHz AMD Athlon based desktop, which briefly overtook the P6 architecture in speed until 2003 when Intel revamped P6 as the Pentium M processor (&quot;Centrino&quot;) and today as the Core 2. The Core 2 is just a beautiful chip for emulation and virtual machine purposes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442453">
				<div id="div-comment-442453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jenk.livejournal.com' rel='external nofollow' class='url'>JenK</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442453">
			November 14, 2006 at 1:02 pm</a>		</div>

		<p>*remembers rearranging my office at msft in winter to put warmer computers between me &amp; the window*</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442663">
				<div id="div-comment-442663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442663">
			November 14, 2006 at 9:47 pm</a>		</div>

		<p>Darek, thanks dude. Fascinating stuff.</p>
<p>Raymond, you really surprise me, I thought you would&#8217;ve had a garage/shed/whatever full of Trash80s and wot not&#8230; I&#8217;m sure someone famous said &quot;never judge a man by his blog&quot;. Oh no, wait. That was me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442723">
				<div id="div-comment-442723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">aarony</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442723">
			November 15, 2006 at 1:30 am</a>		</div>

		<p>Darek, I believe you are misinformed. &nbsp;</p>
<p>First of all no new Quadras were produced after 1995. (Introduced in 1994 and cancelled in August 95) &nbsp;These machines were not $5000, more like the introduction price of $1,200 a little higher with a CD-Rom drive. &nbsp;(Actually I got a Performa 630CD for $3000 with monitor, when monitors where $500 and CD-Roms were $400, hell the floppy drive cost $140) &nbsp;You have to realize that this was the same year that the PPC 601s came out because the 603s didn&#8217;t have enough cache to emulate 68k instructions natively.</p>
<p>Second, PowerPC emulation has been amazingly difficult, and for nearly a decade after it&#8217;s introduction it remained all but unemulated. &nbsp;What emulators were around were slow and worthless. &nbsp;And I remember because endianness made emulation from either side amazingly difficult. &nbsp;Even SheepShaver would only work on BeOS PPC in 1998, it had no emulation at the time. &nbsp;Just spend 15 minutes on PearPC and tell me that PPC emulation is easy. &nbsp;And I&#8217;m talking no SIMD or anything fancy, it is garbage.</p>
<p>However I completely agree on the fact that the 68040 is extremely complex. &nbsp;It was the first modern computing chip, and if anything the Amiga users showed all of us that it really was more than we ever needed in basic computing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442743">
				<div id="div-comment-442743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">emuauthor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442743">
			November 15, 2006 at 4:11 am</a>		</div>

		<p>I have a somewhat offtopic question, although it&#8217;s for an emulator I&#8217;m writing, and it does use virtual memory :)</p>
<p>I need the mirroring behaviour that you can get with some tricks using MapViewOfFile, and the pagewise memory protection granularity you get with VirtualProtect. So far, using VirtualProtect on mapped memory works fine, but is this supported behaviour?</p>
<p>Also, why are the mapping functions 16-page-granular while the VirtualAlloc family are page-granular? Is it Alpha legacy that could be removed now that only x86/x64 and Itanium are supported, or are the risks too high?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442793">
				<div id="div-comment-442793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442793">
			November 15, 2006 at 9:32 am</a>		</div>

		<p>Nice to see,that I am not alone.80486;P1 133MHz;P1 188MHz and Commodor 64.It may be considered as an advertisment,but I am looking for old computers for my collection-dead or alive,parts or entire,it doesn&#8217;t matter&#8230;</p>
<p>Beware shipping to Czech Republic can be too expensive.</p>
<p>Klimax(danklima@gmail.com)</p>
<p>P.S.:I collect them for new museum of computers!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-442913">
				<div id="div-comment-442913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marcel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442913">
			November 15, 2006 at 12:57 pm</a>		</div>

		<p>&quot;68040 is quite a difficult instruction set to emulate.&quot;</p>
<p>The adressing modes of the 20+ CPUs are just completely over the top, but for a simple interpreting emulator the instruction set is actually very cool, as the more complex the instructions are, the less is the overhead of the interpreter :-) JIT might be a different issue&#8230;</p>
<p>I&#8217;m saying this after, too, having developed and maintained a commercial 68k emulator for well over 10 years. All in assembler. I thought it was fun. :-)</p>
<p>&quot;That&#8217;s compounded by the fact that a lot of Mac code used self-modifying tricks and executing in middle of instructions and such.&quot;</p>
<p>Seeing that even the real 68040 chips (unlike Intel) had huge problems executing modifying code without a prior cache flush, was that really such a big problem? I did some sketches of a JIT version and invaliding the compiled code on a cache flush seemed to be enough to keep things running fine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-442773">
				<div id="div-comment-442773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-442773">
			November 15, 2006 at 8:39 am</a>		</div>

		<p>emuauthor: Generally, requests for future articles are better put in the Suggestion Box post (see the Basics part of the navbar over on the right).</p>
<p>Second, Raymond has already talked about the 64K granularity issues before, and it is a holdover from one of the other processors that NT was written for. &nbsp;I don&#8217;t remember for sure if it was Alpha or MIPS, but one of them could only load an immediate value into a register 16 bits at a time, and it&#8217;s MUCH easier to do function relocation when you&#8217;re only doing one load per function call (instead of two).</p>
<p>That same architecture had some kind of issue with treating numbers as signed versus unsigned; this is why there&#8217;s a 64K hole just below the 2G limit. &nbsp;If those addresses were allowed, the function-call calculations would have been even *more* complicated, to handle the case where the page happened to fall in that range. &nbsp;It was much easier to just remove access to that 64K area.</p>
<p>As for removing that support now that the Alpha and MIPS processors are no longer supported, I doubt it&#8217;ll happen. &nbsp;It might be nice, but I&#8217;d bet that when the kernel core is semi-portable, it&#8217;s easier to make other kinds of modifications (like to x86-64).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-443163">
				<div id="div-comment-443163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anjelina</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-443163">
			November 16, 2006 at 12:56 pm</a>		</div>

		<p>&quot;If you let MacOS do the paging you&#8217;re emulating the 68000/PPC code that does the paging as well as the memory management hardware that makes it possible.&quot;</p>
<p>*snicker* &nbsp;Microsoft lemmings are so funny. &nbsp;While it&#8217;s true that the emulator being discussed handles 68000/PPC code, Apple has been building on a UNIX core (EFI boot) for years now. &nbsp;Solid, fast, and superior. &nbsp;Looks like Vista continues Microsoft&#8217;s tradition of endlessly trying to polish their BIOS turd. &nbsp;</p>
<p>You kids are so cute.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-443243">
				<div id="div-comment-443243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://qstuff.blogspot.com/' rel='external nofollow' class='url'>Justin Olbrantz (Quantam)</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-443243">
			November 16, 2006 at 7:14 pm</a>		</div>

		<p>&quot;*snicker* &nbsp;Microsoft lemmings are so funny. &nbsp;While it&#8217;s true that the emulator being discussed handles 68000/PPC code, Apple has been building on a UNIX core (EFI boot) for years now. &nbsp;Solid, fast, and superior. &nbsp;Looks like Vista continues Microsoft&#8217;s tradition of endlessly trying to polish their BIOS turd.&quot;</p>
<p>That&#8217;s a parody, right? You&#8217;re trying to make us think that all Mac users are overzealous, self-righteous fanboys/fangirls out to actively evangelize, right?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-444143">
				<div id="div-comment-444143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-444143">
			November 21, 2006 at 11:44 am</a>		</div>

		<p>Ignorant bravado is something we&#8217;ve all come to expect from a certain type of Mac evangelist. &nbsp;Heaven knows why they think it is an appealing quality that will convert average users. &nbsp;It&#8217;s so clearly a case of overcompensation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-447113">
				<div id="div-comment-447113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.emulators.com' rel='external nofollow' class='url'>Darek</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061114-15/?p=29003#comment-447113">
			November 30, 2006 at 7:34 pm</a>		</div>

		<p>Aaron, I disagree about the price points of 1995 era Quadras. The ‚ÄúPerforma‚Äù and ‚ÄúLC‚Äù branded Macs were stripped down versions of the Quadra, and while they were lower in price than the $5000 I mentioned, you quote $3000, they were also lower in CPU performance, memory size, and other specs compared to real Quadra branded machines. Either price point exemplifies the selling point of using a Mac emulator on a Windows PC to emulate a Quadra at full Quadra speed and still do it for less money than the cost of the Quadra. Emulation and virtualization technology <em>can</em> save real money on hardware costs. It‚Äôs not just an issue of running legacy software.</p>
<p>Regarding the endianness issue, it in itself is not a reason for slower perf. PearPC‚Äôs slowness has much to do with the fact that it‚Äôs written in C++ for portability. SoftMac was not written to be portable to anything but Windows running on x86 processors, and as such is mostly written in hand coded x86 assembly language so as to execute 100 million or more 680&#215;0 instructions per second. Endianness penalties then you would <em>think</em> would be amplified in such a more efficient emulator, but this was designed into both my 680&#215;0 and PowerPC emulation engines from day one. Most emulators that have to deal with the endianness differences naively perform a byte swap type of operation on <em>every</em> memory read and write larger than a byte. This in itself is the wrong place to do that swap, but play along for a minute. Generally on x86 you can use the XCHG AH,AL instruction to byte swap a 16-bit quantity, and the BSWAP EAX instruction to byte swap a 32-bit quantity. The Fusion PC 3.0 Mac emulator from MS-DOS which I distribute uses this scheme as it is written purely in 486 compatible assembly. Emulators written in C or C++ generally won‚Äôt have the luck of having the compiler emit the XCHG or BSWAP instructions, as those operations are generally not compiler intrinsic and thus have to be compiled using an ugly sequence of logical shifts, ANDs, and ORs. Even in Fusion PC, the extra cost of the occasional one-cycle BSWAP EAX or XCHG AL,AH instruction accounts an almost negligible amount of execution time since as it turns out, most memory operations do not need them. Byte operations to/from memory don‚Äôt need them. Storing immediate constants to memory does not need them. Memory-to-memory MOVE instructions (such as memory copy loops) don‚Äôt need them. An emulator that uses XCHG and BSWAP and intelligently filters out the huge number of unnecessary byte swap operations takes a negligible performance hit due to endianness. I did a test to inject bogus BSWAP instructions into Fusion just to test this out and it really is negligible. So your statement that ‚Äúendianness made emulation from either side amazingly difficult‚Äù is just plain inaccurate.</p>
<p>Regardless, back in 1990 I was designing my first 68000 emulation engine for the 386 processor, I did not even have the luxury of using the BSWAP instruction. BSWAP was introduced in the 486 processor but in 1990 (and even in 1995) many DOS and Windows users did not own a 486. So I delved into the issue further and realized that BSWAP and XCHG weren‚Äôt even necessary. There are x86 instruction sequences one can use which take care of the endianness without introducing any extra instructions, extra code bytes, or extra data dependency stalls, as using XCHG and BSWAP do. I know for a fact that if x86 was the same endianness as 68040/PowerPC, my SoftMac emulator would not be any faster. The ‚Äúcost‚Äù of endianness in SoftMac is effectively zero, and if people used my 386-compatible techniques in their emulators it would similarly be zero for them. There just happen to be emulators that handle endianness in a stupid manner which might slow down their perf. But that‚Äôs an implementation mistake, <em>not</em> an issue that inherently limits the performance of an emulator that has to work on a different endianness.</p>
<p>PowerPC in itself is a very simple instruction set to emulate and it can be emulated more efficiently than 68040. And ironically requires even less byte swapping due to the lower percentage of PowerPC code that performs memory operations. So I stand by my statement. In the spring of 2001 I demonstrated at MacHack and at Macworld Expo a working PowerPC emulation on a Pentium III laptop that achieved something like the speed of the 100 MHz PowerPC 601 machines. Slow by today‚Äôs standards, but at the time perfectly suitable speed for running something like Mac OS 8 as people did on that class of PowerMac. I would say the reason for there being a lack of PowerPC emulators in the 1990‚Äôs is simply because PowerPC processors and PowerPC based Macs arrived over 10 years after 68000 did, and so of course the emulators had more than a 10 year head start with 680&#215;0. I started writing my PowerPC engine in the spring of 2000, a good 10 years after I started tackling 68000 emulation. My first prototype PowerPC engine I whipped out in about 3 weeks in C code in 2000, then re-wrote in assembly for the demos in 2001. 68000 took me over a year to implement, and then another year in 1998-1999 to add 68020 and 68040 functionality. I would guess other Mac emulator developers similarly didn‚Äôt tackle PowerPC until much later, not realizing that in fact it was the easier CPU emulation problem to tackle.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

