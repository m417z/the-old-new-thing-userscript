<html>
<head>
<title>The name WinMain is just a convention</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The name WinMain is just a convention</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 4, 2006 / year-entry #400</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>37</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Although the function WinMain is documented in the Platform SDK, it's not really part of the platform. Rather, WinMain is the conventional name for the user-provided entry point to a Windows program. The real entry point is in the C runtime library, which initializes the runtime, runs global constructors, and then calls your WinMain function (or...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p> Although the function <code>WinMain</code> is documented in the Platform SDK, it's not really part of the platform. Rather, <code>WinMain</code> is the conventional name for the user-provided entry point to a Windows program. </p>
<p> The real entry point is in the C&nbsp;runtime library, which initializes the runtime, runs global constructors, and then calls your <code>WinMain</code> function (or <code>wWinMain</code> if you prefer a Unicode entry point). </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (37)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-447703">
				<div id="div-comment-447703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-447703">
			December 4, 2006 at 10:26 am</a>		</div>

		<p>Where&#8217;s the documentation for the actual OS entrypoint?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-447743">
				<div id="div-comment-447743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ac</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-447743">
			December 4, 2006 at 10:41 am</a>		</div>

		<p>@Anonymous</p>
<p>At least on VC 6, to make a Unicode program, entry had to be defined manually. Search for</p>
<p>/ENTRY:wWinMainCRTStartup for examples. I don&#8217;t know how that is done on more recent VC versions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-447753">
				<div id="div-comment-447753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">maine</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-447753">
			December 4, 2006 at 10:41 am</a>		</div>

		<p>Why isn&#8217;t it called main?</p>
<div class="post">[<i>Because that name was already taken. I can&#8217;t believe I had to write that. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-447783">
				<div id="div-comment-447783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://whatisURL' rel='external nofollow' class='url'>Peter Trevethan Murch</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-447783">
			December 4, 2006 at 10:47 am</a>		</div>

		<p>Two years ago I had quite a severe Stroke, my short memory is badly damaged &amp; I am 75 years old. &nbsp;Though I do have computer qualifications, my memory is awful, so please help me!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-447793">
				<div id="div-comment-447793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-447793">
			December 4, 2006 at 10:48 am</a>		</div>

		<p>&quot;Where&#8217;s the documentation for the actual OS entrypoint?&quot;</p>
<p>Here:</p>
<p><a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/f9t8842e.aspx" rel="nofollow">http://msdn2.microsoft.com/en-us/library/f9t8842e.aspx</a></p>
<p>Although I think it&#8217;s wrong for EXEs. &nbsp;It says the entrypoint should have the same signature as WinMain, but the OS doesn&#8217;t actually supply any parameters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-447863">
				<div id="div-comment-447863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://david.acz.org/' rel='external nofollow' class='url'>David Phillips</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-447863">
			December 4, 2006 at 11:21 am</a>		</div>

		<p>This excellent article has source for a tiny C runtime:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/msdnmag/issues/01/01/hood/" rel="nofollow">http://msdn.microsoft.com/msdnmag/issues/01/01/hood/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-447883">
				<div id="div-comment-447883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-447883">
			December 4, 2006 at 11:34 am</a>		</div>

		<p>Carlos: I&#8217;m fairly sure the OS actually does supply the parameters, but the CRT doesn&#8217;t currently make use of them. To avoid faults surrounding misaligned stack, due to the incorrect signature (and I think also incorrect calling convention, the entry point function should be __stdcall), the CRT calls ExitProcess rather than returning from xxxCRTStartup.</p>
<p>This isn&#8217;t a problem, because that&#8217;s all that kernel32!BaseProcessStart is going to do after the executable&#8217;s entry point function returns.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448053">
				<div id="div-comment-448053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448053">
			December 4, 2006 at 12:56 pm</a>		</div>

		<p>I think that question of why main() isn&#8217;t used instead of WinMain() is a valid one. &nbsp;Sure, main() is taken, but in the same way that WinMain() is taken &#8211; it&#8217;s just the name of a function that the CRT calls when it&#8217;s finished initializing. &nbsp;So the CRT could just as easily call main() instead of WinMain() for Windows programs (which is what C runtimes do for pretty much every other target environment).</p>
<p>So, why doesn&#8217;t the MS C compiler for Windows simply use the long-standing convention of calling main for the user&#8217;s program?</p>
<p>I&#8217;d guess the answer is because the first Windows programs were really DOS programs that ran in a new, funky, graphical environment, and the compiler and CRT had no idea that Windows was the program&#8217;s target. So the first Windows programs had both a main() and a WinMain() (which was called by main()). &nbsp;</p>
<p>Also, WinMain() takes different parameters that main(), but that issue could be handled some other way (requiring the Windows program to call some sort of WinInit() API to get that information or something). &nbsp;</p>
<p>As a matter of fact, Andrew Schulman and David Maxey wrote a library (WINIO) that let programmers write C programs using standard I/O functions in Win16 programs (and those programs had a main() entry point &#8211; as far as the end-user programmer was concerned). &nbsp;WINIO used globals to let the programmer access the WinMain() parameters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-448073">
				<div id="div-comment-448073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448073">
			December 4, 2006 at 1:23 pm</a>		</div>

		<p>@Mike Dimmick: On entry to the app the stack just seems to contain some random cruft from the OS process initialisation. &nbsp;It definitely doesn&#8217;t have the WinMain parameters (e.g. there&#8217;s no command-line pointer). &nbsp;If the stack cruft does mean something, I can&#8217;t fathom what.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448123">
				<div id="div-comment-448123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.asvguy.com' rel='external nofollow' class='url'>Burak KALAYCI</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448123">
			December 4, 2006 at 1:38 pm</a>		</div>

		<p>&gt;The real entry point is in the C runtime library</p>
<p>Does the above refer to the CRT used by Windows or used by the application? (I&#8217;m a bit confused, what if the application wasn&#8217;t written in C/C++?).</p>
<p>Best regards,</p>
<p>Burak</p>
<div class=post>[<i><u>In the context of what happens if you use WinMain</u>, the real entry point is the C runtime library. If you don&#8217;t use WinMain then the real entry point is whatever your programming framework uses. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-448153">
				<div id="div-comment-448153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DriverDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448153">
			December 4, 2006 at 1:47 pm</a>		</div>

		<p>The entry point for Win32 console apps is main. Just like every other command-line C environment. And of course the real entry point is still in the C runtime, which zeros globals, etc.</p>
<p>Is is true that a Win32 console apps can do everything a &quot;GUI&quot; Win32 program can &#8211; but the programmer has to do more work?</p>
<p>&#8212;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448273">
				<div id="div-comment-448273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom_</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448273">
			December 4, 2006 at 2:48 pm</a>		</div>

		<p>As far as I can tell, yes, console programs have all the power of the normal Windows ones. Indeed virtually all my programs are console ones in debug builds, so I can use printf for debugging messages. (This is not advice. Just information.)</p>
<p>The amount of work required is minimal.</p>
<p>You do need a main() function, that calls WinMain. I just say &quot;return WinMain(0,0,0,0);&quot;.</p>
<p>You don&#8217;t actually need real WinMain arguments, because you can get them elsewhere. GetModuleHandle(0) retrieves you hInstance, hPrevInstance is always 0, and GetCommandLine or COmmandLineToArgvW will suffice for the arguments (though they are not quite in the same form as lpCmdLine). You might not need do anything about nShowCmd, because ShowWindow handles that for you automatically the first time it&#8217;s called, but if you need it later you can use GetStartupInfo to find it.</p>
<p>Look in the C runtime source code (crtexe.c); the difference between calling main and calling WinMain is not great.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-448283">
				<div id="div-comment-448283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random Reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448283">
			December 4, 2006 at 2:58 pm</a>		</div>

		<p>The WinMain signature as documented in the PSDK is valid though. &nbsp;The Windows loader expects to find a pointer to a function of that style in the PE header&#8217;s EntryPoint slot for exe files. &nbsp;You can use the MS linker&#8217;s /ENTRY switch to set that whatever function you want; I do that when not linking with the CRT. &nbsp;(Why don&#8217;t I link with the CRT? &nbsp;Because I&#8217;m writing a small utility that uses only the bare Windows API, and I don&#8217;t want the CRT&#8217;s size overhead in my final tiny executable.)</p>
<p>DriverDude, the only difference between console and GUI applications at the OS level is one flag in the PE header that tells the Windows loader to pre-create a console for it (and attach to the caller&#8217;s console, if appropriate). &nbsp;Everything else is identical.</p>
<p>Note the CRT does much more initialization work for console apps, to provide the standard C environment everyone expects.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448503">
				<div id="div-comment-448503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.ookii.org' rel='external nofollow' class='url'>Sven Groot</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448503">
			December 4, 2006 at 6:04 pm</a>		</div>

		<p>&quot;Is is true that a Win32 console apps can do everything a &quot;GUI&quot; Win32 program can &#8211; but the programmer has to do more work?&quot;</p>
<p>Yes this is true. You don&#8217;t even need to do more work, really. The only difference is that a console app will show a console, and that console doesn&#8217;t close until the app finishes (or if the user closes the console, it kills the program). If a console app that shows UI is started from the console, that console won&#8217;t return to the prompt until the app is finished unlike what it does for a GUI app.</p>
<p>This is different from most *nixes which don&#8217;t make that distinction. An app launched from e.g. the Gnome panel doesn&#8217;t get a console, period, and a GUI app started from a console will always block the console unless it&#8217;s started in background mode (or suspended and then backgrounded). The GUI app can also still write to that console, whereas printf/cout statements from a Windows GUI app end up in a void unless a debugger is attached or CreateProcess is used to redirect those streams.</p>
<p>(I&#8217;m doing a lot of this from memory, feel free to correct me if I got some details wrong).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-448613">
				<div id="div-comment-448613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448613">
			December 4, 2006 at 9:29 pm</a>		</div>

		<blockquote><p>
  I would be interested in finding out how the</p>
<p>  entry point gets selected.
</p></blockquote>
<p>It depends on what you select for the /SUBSYSTEM linker parameter. If you don&#8217;t specify a /SUBSYSTEM parameter, the linker works it out depending on which of main() or WinMain() is defined (if both are defined I don&#8217;t know what it does &#8211; perhaps an error, or perhaps it just chooses one).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448663">
				<div id="div-comment-448663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://levicki.blogspot.com/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448663">
			December 5, 2006 at 1:31 am</a>		</div>

		<p>I prefer to build my executables with /NOENTRY linker switch and then craft their resources in such a way that Windows Explorer crashes while trying to extract an icon resulting in buffer overflow which in turn starts the executable.</p>
<p>Signed,</p>
<p>Evil Hax0r</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-448703">
				<div id="div-comment-448703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Robert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448703">
			December 5, 2006 at 3:21 am</a>		</div>

		<blockquote><p>
  It says the entrypoint should have the same signature as WinMain, but the OS doesn&#8217;t actually supply any parameters.
</p></blockquote>
<p>I believe the signature of the real entry point function you specify with the /ENTRY switch is DWORD __stdcall main(void) or int __cdecl main(void) (both produce exactly the same code on a 32bit compiler). Anyway the only thing that happens after the function returns is calling ExitThread with the return value, so the state of the stack doesn&#8217;t matter much.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448553">
				<div id="div-comment-448553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Craig Ringer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448553">
			December 4, 2006 at 8:02 pm</a>		</div>

		<p>mikeb:</p>
<p>&lt;pre&gt;</p>
<p>int main(int argc, char* argv[]);</p>
<p>int WinMain( &nbsp; &nbsp; &nbsp;</p>
<p> &nbsp; &nbsp;HINSTANCE hInstance,</p>
<p> &nbsp; &nbsp;HINSTANCE hPrevInstance,</p>
<p> &nbsp; &nbsp;LPSTR lpCmdLine,</p>
<p> &nbsp; &nbsp;int nCmdShow</p>
<p>);</p>
<p>&lt;/pre&gt;</p>
<p>&#8230; it seems pretty clear to me why they used different names. In C it&#8217;s not even legal to have overloads, and the linkage of WinMain() / main() must be C-style, for one thing. Of course, you&#8217;re not really overloading if only one prototype and definition are visible to the compiler, but really &#8230; why complicate things by using the same name for two functions with different signatures?</p>
<p>This way there are no confusing crashes in main() because it&#8217;s being called by the runtime with the WinMain arguments (but you expect traditional C-style arguments), and things generally make more sense.</p>
<p>Remember that Windows and the compiler/linker are perfectly happy with a main() function. Much of my code uses just that, because I often don&#8217;t need the extra arguments from WinMain and since I write portable code all the awful Windows typedefs drive me nuts.</p>
<p>I would be interested in finding out how the entry point gets selected. I&#8217;ve always assumed it&#8217;s the linker doing the job, but I just don&#8217;t understand the Windows runtime linking process and app startup as well as the *nix one. Anyone know?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-448563">
				<div id="div-comment-448563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Craig Ringer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448563">
			December 4, 2006 at 8:07 pm</a>		</div>

		<p>Sven,</p>
<p>You&#8217;re quite right re the behaviour of the console on *nix. After all, on UNIX apps the console is just another application that reads an app&#8217;s stdout and stderr and writes any input to its stdin . The Win32 console seems to provide the same service for Windows console apps, but it&#8217;s quite special to the application and there&#8217;s API to manipulate it. That&#8217;s just not true on *nix &#8211; if you want to manipulate the console, you use (unfortunately highly variable depending on the specific *nix flavour) escape sequences.</p>
<p>Panel apps can have a console, though. The .desktop file can specify that the app should be launched in a console, in which case an xterm/gnome-terminal will be spawned with instructions to exec the program its self. Again that&#8217;s very different to Windows where the console is innate to the application and is spawned by the runtime (?) on app startup.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448573">
				<div id="div-comment-448573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448573">
			December 4, 2006 at 8:42 pm</a>		</div>

		<p>Monday, December 04, 2006 8:02 PM by Craig Ringer</p>
<p>&gt; In C it&#8217;s not even legal to have overloads,</p>
<p>&gt; and the linkage of WinMain() / main() must be</p>
<p>&gt; C-style, for one thing.</p>
<p>In C it&#8217;s not legal for a program to do overloading, but implementations are required to provide two overloads for main. &nbsp;Implementations have to accept programs that conform to either of the following prototypes:</p>
<p>int main()</p>
<p>or</p>
<p>int main(int, char**)</p>
<p>Implementations could provide other overloads for main if they wished. &nbsp;For example some implementations allow this:</p>
<p>void main()</p>
<p>and/or this:</p>
<p>void main(int, char**)</p>
<p>Portable programs don&#8217;t take advantage of such implementation extensions. &nbsp;Non-portable programs (such as PE executables) can freely use whatever an implementation offers to them.</p>
<p>&gt; I would be interested in finding out how the</p>
<p>&gt; entry point gets selected.</p>
<p>Visual Studio has defaults which you can override. &nbsp;Visual Studio informs the linker of whatever the setting is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dean-harding even thread-even depth-1" id="comment-448603">
				<div id="div-comment-448603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dean+Harding' rel='external nofollow' class='url'>Dean Harding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448603">
			December 4, 2006 at 9:27 pm</a>		</div>

		<p>&gt; In C it&#8217;s not legal for a program to do overloading, but</p>
<p>&gt; implementations are required to provide two overloads for main.</p>
<p>That&#8217;s not true, main() is declared as __cdecl (*), which means the caller is meant to clean up the stack. This means that if you declare your main() as:</p>
<p>int main();</p>
<p>The C runtime will still pass the argc and argv parameters to you, your function just ignores them. The __cdecl declaration means the C runtime is responsible for cleaning up those parameters.</p>
<p>Now, some implementation DO allow you to declare main() as returning void, but this is a special case &#8211; the compiler will insert an implicit &quot;return 0;&quot; at the end of your function.</p>
<p>This does not mean main() is an overload of main(int, char **), and it does not mean that you could just as easily provide &quot;different overloads&quot; of main() &#8211; just that either of those two SPECIFIC definitions will work, given the semantics of __cdecl.</p>
<p>* Note: __cdecl is the Microsoft compiler specific terminology, other compilers may express the same decoration in different ways, I&#8217;m not sure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448693">
				<div id="div-comment-448693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448693">
			December 5, 2006 at 2:36 am</a>		</div>

		<p>Monday, December 04, 2006 9:27 PM by Dean Harding</p>
<p>[Norman Diamond:]</p>
<p>&gt;&gt; In C it&#8217;s not legal for a program to do</p>
<p>&gt;&gt; overloading, but implementations are</p>
<p>&gt;&gt; required to provide two overloads for main.</p>
<p>&gt;</p>
<p>&gt; That&#8217;s not true, main() is declared as</p>
<p>&gt; __cdecl (*), </p>
<p>Which page of the standard gives the definition of __cdecl? &nbsp;Oh wait a minute, that (*) wasn&#8217;t part of your prototype&#8230;</p>
<p>&gt; * Note: __cdecl is the Microsoft compiler</p>
<p>&gt; specific terminology</p>
<p>Then try taking another look at the standard. &nbsp;Implementations are required to provide two overloads for main&#8230;</p>
<p>&gt; That&#8217;s not true</p>
<p>Liar. &nbsp;And to think there are people calling me a troll.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-448793">
				<div id="div-comment-448793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448793">
			December 5, 2006 at 8:39 am</a>		</div>

		<p>Sven:</p>
<p>&gt; An app launched from e.g. the Gnome panel doesn&#8217;t get a console, period</p>
<p>Actually, it does &#8212; it gets whichever console you ran &quot;startx&quot; on, if you start X like that.</p>
<p>If you start X from xdm, kdm, or gdm, then it gets whichever console xdm, kdm, or gdm is running on. &nbsp;This is usually the console inherited from init, because init spawns the *dm process. &nbsp;init, in turn, gets its console from the kernel at boot time &#8212; this is almost always VT 1. &nbsp;It *may* be possible for it to be a serial console, but I&#8217;m not sure how well X would work if it&#8217;s started from a serial console, so I&#8217;ll ignore that. &nbsp;;-)</p>
<p>(Back when I ran KDE &#8212; several years ago &#8212; I crashed some program that I&#8217;d started from the menu system. &nbsp;When I exited X and went back to the console, I saw the segfault message there.)</p>
<p>Craig:</p>
<p>&gt; After all, on UNIX apps the console is just another application that reads an app&#8217;s stdout and stderr and writes any input to its stdin</p>
<p>Well, sort of, but not really. &nbsp;Terminal emulator programs like xterm, gnome-terminal, or Eterm are actually running a virtual console. &nbsp;The shell runs on this virtual console (provided by the kernel), and the terminal emulator program interprets all the output that the shell sends to the console (including escape sequences, etc.). &nbsp;The emulator also takes X keysyms and does whatever to them to make the virtual console provide the corresponding characters as input to the shell.</p>
<p>But if the shell is running on a real console (e.g. /dev/tty0), then there&#8217;s no program to manage this console. &nbsp;All that processing is done by the kernel, interfacing directly with the screen and keyboard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-448953">
				<div id="div-comment-448953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-448953">
			December 5, 2006 at 10:50 am</a>		</div>

		<p>Norman: &quot;Implementations are required to provide two overloads for main&#8230;&quot;</p>
<p>Calling this an &quot;overload&quot; is missing the point of what overloading is. &nbsp;In almost all implementations of C, no extra action is required here, because of how C&#8217;s function call semantics work. &nbsp;However to support both</p>
<p>int main (int argc, char ** argv)</p>
<p>and</p>
<p>LRESULT main (HINSTANCE hInstance, HINSTANCE hInstPrev, LPCSTR szCmdLine, int nCmdShow)</p>
<p>in the same implementation would require some substantial hackery.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-449163">
				<div id="div-comment-449163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Todd Greer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-449163">
			December 5, 2006 at 2:07 pm</a>		</div>

		<p>They could easily have used a signature like:</p>
<p>int main(int argc, char** argv, HINSTANCE hInstance, HINSTANCE hInstPrev, int nCmdShow)</p>
<p>Given the __cdecl calling convention, this would have automatically supported the two required signatures. It would have been a perfectly reasonable and fully compliant C extension and would have avoided the confusion of having two entry points on Windows.</p>
<p>Does anyone know why they chose otherwise? mikeb&#8217;s suggestion that it was done so that an executable could have both seems reasonable, but I&#8217;m curious if the reason is known.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-449293">
				<div id="div-comment-449293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-449293">
			December 5, 2006 at 5:04 pm</a>		</div>

		<p>I am just guessing here, but I&#8217;d suspect it had something to do with Win16 having to fit inside 640K of memory.</p>
<p>It would have taken n more pointers (where n is the number of command-line args) to give WinMain the array-of-strings that the C standard specified. &nbsp;(They could have used the same storage for the strings themselves, they just would have had to replace spaces that actually separate args with 0 bytes, and then created another array of n pointers.) &nbsp;*Plus* you&#8217;d have to add all the parsing code &#8212; command.com (or whatever) got the command line as a single string, so it would have had to do the splitting on its own.</p>
<p>And then Win32 kept source-code compatibility whenever possible, so they didn&#8217;t break programs where it didn&#8217;t matter.</p>
<p>Now this may or may not be a good excuse (it certainly did hurt *nix compatibility a bit, though the issues are easily worked around), but it might be the reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-449433">
				<div id="div-comment-449433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-449433">
			December 5, 2006 at 10:09 pm</a>		</div>

		<p>Tuesday, December 05, 2006 8:39 AM by BryanK</p>
<p>&gt;Sven:</p>
<p>&gt;&gt; An app launched from e.g. the Gnome panel</p>
<p>&gt;&gt; doesn&#8217;t get a console, period</p>
<p>&gt;</p>
<p>&gt; Actually, it does [&#8230;] If you start X from</p>
<p>&gt; xdm, kdm, or gdm, then it gets whichever</p>
<p>&gt; console xdm, kdm, or gdm is running on. &nbsp;This</p>
<p>&gt; is usually the console inherited from init,</p>
<p>Oh neat. &nbsp;Then an app launched from the Gnome panel gets a console that it doesn&#8217;t have permission to either read or write, right?</p>
<p>Tuesday, December 05, 2006 10:50 AM by Jules </p>
<p>&gt;&gt; Norman: &quot;Implementations are required to</p>
<p>&gt;&gt; provide two overloads for main&#8230;&quot;</p>
<p>&gt;</p>
<p>&gt; Calling this an &quot;overload&quot; is missing the</p>
<p>&gt; point of what overloading is.</p>
<p>In a way I agree, because C programs aren&#8217;t allowed to define both overloads (which makes me want to try it in C++ ^_^). &nbsp;Maybe the requirement for implementations to accept either version needs a different word, maybe overprototype?</p>
<p>&gt; In almost all implementations of C, no extra</p>
<p>&gt; action is required here,</p>
<p>Whether or how much extra work is required are irrelevant to what the standard requires. &nbsp;(Sometimes they&#8217;re relevant in persuading the committee to remove or adjust a requirement in the standard but that&#8217;s a separate issue.)</p>
<p>&gt; However to support both</p>
<p>&gt; &nbsp; int main (int argc, char ** argv)</p>
<p>&gt; and</p>
<p>&gt; &nbsp; LRESULT main (HINSTANCE hInstance,</p>
<p>&gt; &nbsp; HINSTANCE hInstPrev, LPCSTR szCmdLine,</p>
<p>&gt; &nbsp; int nCmdShow)</p>
<p>&gt; in the same implementation would require some</p>
<p>&gt; substantial hackery.</p>
<p>I&#8217;ll bet that in the general case it would only require a small amount of hackery. &nbsp;I&#8217;ll bet that in some cases where implementations already provide definitions of LRESULT, HINSTANCE, etc., it wouldn&#8217;t require any additional hackery at all.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-449603">
				<div id="div-comment-449603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-449603">
			December 6, 2006 at 8:11 am</a>		</div>

		<blockquote><p>
  Oh neat. &nbsp;Then an app launched from the Gnome panel gets a console that it doesn&#8217;t have permission to either read or write, right?
</p></blockquote>
<p>I&#8217;m pretty sure it does have permission, although I don&#8217;t use any *dm so I don&#8217;t know for sure. &nbsp;I know that when I log in (using /sbin/agetty and /bin/login), the permissions on the controlling terminal are set so that I can read and write to it, and this terminal is the one that X programs get when started from a menu/panel/whatever.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-450333">
				<div id="div-comment-450333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-450333">
			December 6, 2006 at 11:35 pm</a>		</div>

		<p>Geewhiz, what&#8217;s the point of arguing that WinMain should have been just &#8216;main&#8217;? &nbsp;There is nothing a &quot;standard&quot; C program could do in that main, no stdin or stdout. &nbsp;It&#8217;s totally not standard to begin with!! Who does that benifit? &nbsp;Make a console app if you want to compile standard C programs on Windows!</p>
<p>Think of defining a windows app as defining a plug-in for a toolkit, and the callback you need to define is to get called when it hands the program flow to you is.. WinMain. &nbsp;In other toolkits, it&#8217;s something else.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-450313">
				<div id="div-comment-450313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-450313">
			December 6, 2006 at 10:44 pm</a>		</div>

		<p>Wednesday, December 06, 2006 8:11 AM by BryanK </p>
<p>[Norman Diamond:]</p>
<p>&gt;&gt; Oh neat. &nbsp;Then an app launched from the</p>
<p>&gt;&gt; Gnome panel gets a console that it doesn&#8217;t</p>
<p>&gt;&gt; have permission to either read or write,</p>
<p>&gt;&gt; right?</p>
<p>&gt;</p>
<p>&gt; I&#8217;m pretty sure it does have permission,</p>
<p>&gt; although I don&#8217;t use any *dm so I don&#8217;t know</p>
<p>&gt; for sure.</p>
<p>The following observation also isn&#8217;t proof, just enough to lend a hunch. &nbsp;When shutting down a Linux system, when the display reverts to the first VT in text mode, I&#8217;ve never seen any output from programs than ran during the session. &nbsp;I ought to try deliberately accessing that VT though. &nbsp;(/dev/tty01? &nbsp;I&#8217;ll have to check.)</p>
<p>&gt; I know that when I log in (using /sbin/agetty</p>
<p>&gt; and /bin/login), the permissions on the</p>
<p>&gt; controlling terminal are set so that I can</p>
<p>&gt; read and write to it, and this terminal is</p>
<p>&gt; the one that X programs get when started from</p>
<p>&gt; a menu/panel/whatever.</p>
<p>Yes, but that&#8217;s because permissions to your tty were set when you logged in through that tty, and you started X from a shell controlled by that tty. &nbsp;This provides no evidence one way or the other about logins through a *dm.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-450673">
				<div id="div-comment-450673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-450673">
			December 7, 2006 at 12:29 pm</a>		</div>

		<blockquote><p>
  Yes, but that&#8217;s because permissions to your tty were set when you logged in through that tty, and you started X from a shell controlled by that tty.
</p></blockquote>
<p>Right, that&#8217;s why I don&#8217;t know about any *dm.</p>
<p>But here&#8217;s something you could do to see what TTY your X programs are running on: &nbsp;start up a terminal from the panel, figure out what the terminal&#8217;s PID is, and look at /proc/&lt;pid&gt;/fd/0 (and 1, and 2). &nbsp;The target of these virtual symlinks is where the corresponding FD is pointing.</p>
<p>I suspect it&#8217;ll be /dev/tty0 or (if that doesn&#8217;t exist) /dev/tty1, but it might actually be nothing. &nbsp;I don&#8217;t know.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-451503">
				<div id="div-comment-451503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-451503">
			December 8, 2006 at 10:21 am</a>		</div>

		<p>On Win16 the OS used to pass the startup parameters in registers. On Win32 the OS doesn&#8217;t appear to pass the startup parameters at all, if crt0.c is anything to go by:</p>
<p>mainret = WinMain(GetModuleHandleA(NULL), NULL, lpszCommandLine, StartupInfo.dwFlags &amp; STARTF_USESHOWWINDOW ? StartupInfo.wShowWindow : SW_SHOWDEFAULT);</p>
<p>Oh, and you&#8217;re also allowed to write int main(int argc, char **argv, char **envp)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452173">
				<div id="div-comment-452173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Owen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-452173">
			December 11, 2006 at 1:50 pm</a>		</div>

		<blockquote><p>
  &gt; But here&#8217;s something you could do to see what TTY</p>
<p>  &gt; your X programs are running on: &nbsp;start up a</p>
<p>  &gt; terminal from the panel, figure out what the</p>
<p>  &gt; terminal&#8217;s PID is, and look at /proc/&lt;pid&gt;/fd/0</p>
<p>  &gt; (and 1, and 2). &nbsp;The target of these virtual</p>
<p>  &gt; symlinks is where the corresponding FD is pointing.
</p></blockquote>
<p>I grabbed my Opera instance&#8217;s PID (Started by KWin when I logged in) and found fd0 to be pointed at /dev/null. 1 and 2 are pipes</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452373">
				<div id="div-comment-452373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-452373">
			December 12, 2006 at 7:39 am</a>		</div>

		<p>Oh, it&#8217;s very simple, actually: the entry point for an EXE must expect no parameters. None at all. It must also not return and not leak exceptions (unless it&#8217;s a mixed-mode .NET program written in Managed C++, but let&#8217;s not get silly).</p>
<p>It just so happens, but don&#8217;t quote me on this, that in Windows NT a single parameter *may* be passed on the stack, a pointer to the PEB, but it&#8217;s not like you _need_ it, the PEB is pointed by a field of the TEB. It&#8217;s not mandatory either, in fact creating a process in Windows NT is a pretty liberal affair, in that the caller gets to decide exactly how many threads the process should start with, and their exact registers and stacks</p>
<p>Basically, a Windows process starts with exactly zero arguments, there&#8217;s no &#8220;arguments&#8221;, only &#8220;environment&#8221;. You start from the thread&#8217;s environment, and you can reach everything else from there (command line, environment strings, DLLs, etc.), with enough indirections. This requires zero APIs, it&#8217;s 100% pointer indirections, and of course 100% undocumented &#8211; just use GetStartupInfo, GetModuleHandle, etc. and spare yourself pain and grief!</p>
<div class=post>[<i>There are no parameters. What you see on the stack is your caller&#8217;s local variables (and it&#8217;s not the PEB as far as I can tell). This is of course subject to change at any time, and it&#8217;ll certainly be different on x64! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-452573">
				<div id="div-comment-452573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-452573">
			December 12, 2006 at 3:46 pm</a>		</div>

		<p>Owen &#8212; that just means that somebody set Opera&#8217;s stdin to /dev/null (not quite sure why, it won&#8217;t get any input anyway&#8230;) and set stdout/stderr to pipes &#8212; in other words, somebody ran:</p>
<p>opera &lt;/dev/null 2&gt;&amp;1 | other-program</p>
<p>(Except they might have set stderr to a different pipe than stdout, so they can capture the stuff sent to each FD separately. &nbsp;Doesn&#8217;t really affect anything though.)</p>
<p>If I had to guess, I&#8217;d say that this is probably so that KDE can capture any error output from the program and display it in a &quot;your program printed this error out:&quot; type window. &nbsp;Just like it does when a KDE program segfaults, except the segfault dialog has e.g. stack backtraces and such.</p>
<p>What&#8217;s on the other end of those pipes? &nbsp;fuser and/or lsof may be helpful. &nbsp;I&#8217;d guess it&#8217;s probably dcopserver or some process like that.</p>
<p>(I should have said that this kind of thing may be changed by your DE. &nbsp;I&#8217;d like to know what the setup is without the DE changing anything, though; maybe I just need to patch KDE so it doesn&#8217;t do this redirection, install the patched version, start a program, and find out.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-452693">
				<div id="div-comment-452693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-452693">
			December 12, 2006 at 9:10 pm</a>		</div>

		<p>Tuesday, December 12, 2006 7:39 AM by KJK::Hyperion</p>
<p>&gt; but don&#8217;t quote me on [&#8230;]</p>
<p>OK, at least I get to quote you on words other than [&#8230;].</p>
<p>&gt; the caller gets to decide exactly how many</p>
<p>&gt; threads the process should start with, and</p>
<p>&gt; their exact registers and stacks</p>
<p>Yikes. &nbsp;MSDN says PROCESS_INFORMATION contains:</p>
<p>* &nbsp;hThread</p>
<p>* &nbsp; Handle to the primary thread of the newly</p>
<p>* &nbsp; created process.</p>
<p>&quot;THE&quot; primary thread? &nbsp;Who says there&#8217;s only one? &nbsp;So then, if the caller decides that the process will start with 6 threads, how do 6 handles get shoved into hThread?</p>
<p>* &nbsp;dwThreadId</p>
<p>* &nbsp; Value that can be used to identify a thread.</p>
<p>Whew, a narrow escape on that one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-573433">
				<div id="div-comment-573433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2007/12/03/6644060.aspx' rel='external nofollow' class='url'>MSDN Blog Postings &raquo; How do 16-bit programs start up?</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20061204-01/?p=28853#comment-573433">
			December 3, 2007 at 10:23 am</a>		</div>

		<p>PingBack from <a href="http://blogs.msdn.com/oldnewthing/archive/2007/12/03/6644060.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2007/12/03/6644060.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

