<html>
<head>
<title>How to check if a pointer is in a range of memory</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How to check if a pointer is in a range of memory</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>September 27, 2017 / year-entry #216</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>33</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Thanks to the C language standard, it's trickier than it seems.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Suppose you have a range of memory described by two variables, say,
</p>
<pre>
byte* regionStart;
size_t regionSize;
</pre>
<p>
And suppose you want to check whether a pointers lies within that
region.
You might be tempted to write
</p>
<pre>
if (p &gt;= regionStart &amp;&amp; p &lt; regionStart + regionSize)
</pre>
<p>
but is this actually guaranteed according to the standard?
</p>
<p>
The relevant portion of the C standard (6.5.8 Relational Operators)&sup1;
says
</p>
<blockquote CLASS=q><p>
If two pointers to object or incomplete types both point to the same object,
or both point one past the last element of the same array object,
they compare equal.
If the objects pointed to are members of the same aggregate object,
pointers to structure members declared later
compare greater than pointers to members declared earlier in the structure,
and pointers to array elements with larger subscript
values compare greater than pointers to elements
of the same array with lower subscript values.
All pointers to members of the same union object compare equal.
If the expression P points to an element of an array object
and the expression Q points to the last element of the same array object,
the pointer expression Q+1 compares greater than P.
In all other cases, the behavior is undefined.
</p>
</blockquote>
<p>
Now remember that the C language was defined to cover a large
range of computer architectures,
including many which would be considered museum relics today.
It therefore takes a very conservative view of what is permitted,
so that it remains possible to write C programs for those ancient systems.
(Which weren't quite so ancient at the time.)
</p>
<p>
Bearing that in mind,
it is still possible for an allocation to generate a pointer
that satisfies the condition
despite the pointer not pointing into the region.
This will happen, for example, on an 80286 in protected mode,
which is used by Windows 3.x in Standard mode and OS/2 1.x.
</p>
<p>
In this system,
pointers are 32-bit values,
split into two 16-bit parts,
traditionally written as <code>XXXX:YYYY</code>.
The first 16-bit part (<code>XXXX</code>)
is the "selector", which chooses a bank of
64<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20090611-00/?p=17933">KB</a>.
The second 16-bit part (<code>YYYY</code>)
is the "offset",
which chooses a byte within that 64KB bank.
(It's more complicated than this,
but let's just leave it at that for the purpose of this discussion.)
</p>
<p>
Memory blocks larger than 64KB are broken up into 64KB chunks.
To move from one chunk to the next, you add 8 to the selector.
For example, the byte after <code>0101:FFFF</code>
is <code>0109:0000</code>.
</p>
<p>
But why do you add 8 to move to the next selector?
Why not just increment the selector?
Because the bottom three bits of the selector are used for other things.
In particular,
the bottom bit of the selector is used to choose the selector table.
Let's ignore bits 1 and 2 since they are not relevant to the discussion.
Assume for convenience that they are always zero.&sup2;
</p>
<p>
There are two tables
which describe how selectors correspond to physical memory,
the Global Descriptor Table
(for memory shared across all processes)
and the Local Descriptor Table
(for memory private to a single process).
Therefore, the selectors available for process private memory
are <code>0001</code>,
<code>0009</code>,
<code>0011</code>,
<code>0019</code>,
<i>etc</i>.
Meanwhile, the selectors available for global memory are
<code>0008</code>,
<code>0010</code>,
<code>0018</code>,
<code>0020</code>,
<i>etc</i>.
(Selector <code>0000</code> is reserved.)
</p>
<p>
Okay, now we can set up our counter-example.
Suppose <code>regionStart = 0101:0000</code>
and
<code>regionSize = 0x00020000</code>.
This means that the guarded addresses are
<code>0101:0000</code>
through
<code>0101:FFFF</code>
and
<code>0109:0000</code>
through
<code>0109:FFFF</code>.
Furthermore, <code>regionStart + regionSize = 0111:0000</code>.
</p>
<p>
Meanwhile,
suppose there is some global memory that happens to be
allocated at <code>0108:0000</code>.
This is a global memory allocation because the selector is an even number.
</p>
<p>
Observe that the global memory allocation
is not part of the guarded region,
but its pointer value does satisfy the numeric inequality
<code>0101:0000</code> &le; <code>0108:0000</code> &lt; <code>0111:0000</code>.
</p>
<p>
<b>Bonus chatter</b>:
Even on CPU architectures with a flat memory model,
the test can fail.
Modern compilers take advantage of undefined behavior
and optimize accordingly.
If they see a relational comparison between pointers,
they are permitted to assume that the pointers point
into the same aggregate or array
(or one past the last element of that array),
because any other type of relational comparison is undefined.
Specifically,
if <code>regionStart</code> points to the start of an array or aggregate,
then
the only pointers that can legally be relationally compared with
<code>regionStart</code>
are the ones of the form
<code>regionStart</code>,
<code>regionStart + 1</code>,
<code>regionStart + 2</code>,
&hellip;,
<code>regionStart + regionSize</code>.
For all of these pointers,
the condition <code>p &gt;= regionStart</code>
is true and can therefore be optimized out,
reducing the test to
</p>
<pre>
if (p &lt; regionStart + regionSize)
</pre>
<p>
which will now be satisfied for pointers
that are numerically less than <code>regionStart</code>.
</p>
<p>
(You might run into this scenario if, as in the original question
that inspired this answer,
you allocated the region with
<code>regionStart = malloc(n)</code>,
or if your region is a "quick access" pool of preallocated items
and you want to decide whether you need to <code>free</code> the pointer.)</p>
<p>
<b>Moral of the story</b>:
This code is not safe, not even on flat architectures.
</p>
<p>
<b>But all is not lost</b>:
The pointer-to-integer conversion is implementation-defined,
which means that your implementation must document how it works.
If your implementation defines the pointer-to-integer conversion
as producing the numeric value of the
linear address of the object referenced by the pointer,
and you know that you are on a flat architecture,
then what you can do is compare
<i>integers</i> rather than <i>pointers</i>.
Integer comparisons are not constrained
in the same way that pointer comparisons are.
</p>
<pre>
    if ((uintptr_t)p &gt;= (uintptr_t)regionStart &amp;&amp;
        (uintptr_t)p &lt; (uintptr_t)regionStart + (uintptr_t)regionSize)
</pre>
<p>
&sup1;
Note that comparison for equality and inequality are not considered
relational comparisons.
</p>
<p>
&sup2;
I know that in practice they aren't.
I'm assuming they are zero for convenience.
</p>
<p>
(This article was adapted from
<a HREF="https://stackoverflow.com/questions/39160613/can-the-following-code-be-true-for-pointers-to-different-things">
my answer on StackOverflow</a>.)
</p>
<p>
<b>Update</b>: Clarification that the "start of region"
optimization is available only when <code>regionStart</code>
points to the start of an array or aggregate.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (33)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1310416">
				<div id="div-comment-1310416" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310416">
			September 27, 2017 at 7:08 am</a>		</div>

		<p>If you can&#8217;t compare two general pointer to see which one is &#8220;bigger&#8221; then it&#8217;s broken.<br />
I&#8217;ll leave others to argue if it&#8217;s the compiler or the standard that&#8217;s broken, but something certainly is.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1310426">
				<div id="div-comment-1310426" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310426">
			September 27, 2017 at 7:21 am</a>		</div>

		<p>If you&#8217;re on a flat architecture you can write portable code to suoress that optimization. Pass the address of the pointer to a function that does nothing but can&#8217;t be inlined.</p>
<p>If you&#8217;re not on a flat architecture then there&#8217;s no way to write this. This is one of the reasons memmove is a platform function. You cannot write memmove in portable C.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1310466">
				<div id="div-comment-1310466" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310466">
			September 27, 2017 at 8:43 am</a>		</div>

		<p>You may say vintage architectures are broken from our modern point of view, now that non-flat models are little more than relics. But good luck taking the time machine and convincing designers of former architectures, which had to put up with compatibility, performance and memory economy. The original 8086, for example, introduced the segmented model so it could both run 8-bit software with little modification (if you use the &#8220;tiny memory model&#8221;, where all segments pointed to the same 64 KB area, you get something pretty similar to a &#8220;virtual 8080&#8221; mode) while allowing modern software to address up to 1 MB of memory.</p>
<p>Of course, the 8086 is not binary compatible with the 8080. But Intel specifically designed its architecture and instruction set so each 8080 opcode had an 8086 equivalent. That way, you could use an special &#8220;translation assembler&#8221; to generate 8086 binaries from 8080 assembly files, which would run fine in the tiny memory model. This allowed to easily port CP/M software into MS-DOS, which was very important back in the day.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1310435">
				<div id="div-comment-1310435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://nullprogram.com/' rel='external nofollow' class='url'>Chris</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310435">
			September 27, 2017 at 7:30 am</a>		</div>

		<p>There&#8217;s a very inefficient method that is 100% portable and doesn&#8217;t rely on implementation-defined behavior: Use == rather than . Walk the region one byte at a time and compare each byte == to p. In theory the compiler could convert this into the efficient  form in assembly, but I&#8217;ve never seen this optimization occur in practice.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1310675">
				<div id="div-comment-1310675" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310675">
			September 28, 2017 at 7:02 am</a>		</div>

		<p>That&#8217;s not portable. It will crash if you make a pointer to memory that doesn&#8217;t exist, and if the hardware checks for such pointers when they are loaded into registers rather than when the register is dereferenced. (Checking on load may be more efficient if a pointer is loaded once and dereferenced many times.)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1310437">
				<div id="div-comment-1310437" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andre</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310437">
			September 27, 2017 at 7:37 am</a>		</div>

		<p>&gt; If they see a relational comparison between pointers, they are permitted to assume that the pointers point into the same aggregate or array<br />
Okay<br />
&gt; Specifically, the only pointers that can legally be relationally compared with regionStart are the ones of the form regionStart,<br />
regionStart + 1, regionStart + 2, …,</p>
<p>How does the second follow from the first? If the compiler can&#8217;t see where regionStart comes from, it may be possible regionStart itself points inside an array, but not to the first element. For example:</p>
<p>byte data[50];<br />
byte* regionStart = data+10;<br />
size_t regionSize = 20;<br />
non_inline_function_doing_the_comparison(regionStart, regionSize, data+5);</p>
<p>Maybe I missed something.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1310447">
				<div id="div-comment-1310447" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310447">
			September 27, 2017 at 7:44 am</a>		</div>

		<p>You&#8217;re right. The optimization is available only if the compiler can observe that regionStart is the start of an array. (Which might be something people do. &#8220;If the pointer is in my &#8220;quick access&#8221; array, then don&#8217;t call free.&#8221;)</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1310455">
				<div id="div-comment-1310455" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andre</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310455">
			September 27, 2017 at 7:49 am</a>		</div>

		<p>Ah, I see. That &#8220;local pool&#8221; scenario indeed seems very realistic and a hard to catch bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-3 parent" id="comment-1310506">
				<div id="div-comment-1310506" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310506">
			September 27, 2017 at 9:04 am</a>		</div>

		<p>Also: Lost in editing was that the original code initialized <code>regionStart</code> as <code>regionStart = malloc(n);</code>, and that puts <code>regionStart</code> at the start of an aggregate.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4 parent" id="comment-1310566">
				<div id="div-comment-1310566" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310566">
			September 27, 2017 at 5:16 pm</a>		</div>

		<p>And the compiler knows I didn&#8217;t replace malloc with an arena implementation how?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5" id="comment-1310575">
				<div id="div-comment-1310575" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310575">
			September 27, 2017 at 6:13 pm</a>		</div>

		<p>Because you&#8217;re not allowed to do that. 7.1.3 Reserved Identifiers: &#8220;[A]ll external identifiers defined by the library are reserved in a hosted environment. This means, in effect, that no user-supplied external names may match library names, <i>not even if the user function has the same specification</i>.&#8221; (Emphasis in original.) This is what allows, for example, the compiler to inline standard library functions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-wndsks odd alt depth-5" id="comment-1310736">
				<div id="div-comment-1310736" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/skSdnW' rel='external nofollow' class='url'>skSdnW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310736">
			September 29, 2017 at 7:26 am</a>		</div>

		<p>@Raymond VC will sometimes convert a loop into a call to memset and it does this even when you use /Zl. How are you supposed to provide your own memset (to work around a VC bug) if it is reserved?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-5" id="comment-1310765">
				<div id="div-comment-1310765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310765">
			September 29, 2017 at 10:13 am</a>		</div>

		<p>It should be clear that the standard cannot provide standard-compliant ways of working around bugs in the implementation. It&#8217;s not like the standard can say &#8220;If the implementation implements integer division incorrectly, a conforming program can use this workaround to force the implementation to use an alternate division algorithm,&#8221; (And repeat for each possible thing an implementation could have a bug in.) Working around implementation bugs is clearly an implementation-specific matter, outside the scope of the standard.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1310456">
				<div id="div-comment-1310456" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310456">
			September 27, 2017 at 7:58 am</a>		</div>

		<p>So the only way to do it &#8220;properly&#8221; is to check each pointer in the region one-by-one?</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1310495">
				<div id="div-comment-1310495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310495">
			September 27, 2017 at 9:00 am</a>		</div>

		<p>Basically, the specification boils down to &#8220;only comparisons of pointers to the same object [array, structure, etc.] are defined&#8221;. As noted by Raymond, the only way to do it &#8220;properly&#8221; depends on the conversion from pointer to integer. And, as that operation is machine-dependant, there is not way to make it in a portable fashion.</p>
<p>Not that it matters much. It would be argued that code which compares pointers to different objects and, thus, depends on memory allocation order is broken. Range-checking only makes sense in the cases defined by the C specification.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1310595">
				<div id="div-comment-1310595" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Viila</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310595">
			September 27, 2017 at 9:55 pm</a>		</div>

		<p>Sometimes depending on the memory allocation order is exactly what you want. I have few times used the memory addresses to provide total ordering for a group of objects. It&#8217;s especially handy to breaking ties (two objects compare equal in the ordering criteria? Fine, the one with lower address is less than), or sometimes the objects don&#8217;t even have any useful way to compare them (in which case you probably don&#8217;t care in what order the are, just that they are in <i>some</i> stable order, so memory order is fine).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1 parent" id="comment-1310476">
				<div id="div-comment-1310476" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310476">
			September 27, 2017 at 8:53 am</a>		</div>

		<p>One for the nitpicker&#8217;s corner: the selector bit which toggled between the GDT and the LDT was bit 2, not bit 0. See <a href="http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection/" rel="nofollow">http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection/</a> . This doesn&#8217;t change Raymond&#8217;s exposition, as GDT and LDT selectors are still interleaved.</p>
<p>Bits 0 and 1 contains the &#8220;requested RPL&#8221; for the segment. Basically, it&#8217;s a two bit integer (0, 1, 2 or 3) telling which privilege level you are requesting when accessing the segment. If your requested privilege level is wrong (it compares with the descriptor&#8217;s privilege level on segment register load), the petition will be denied, and you won&#8217;t go to space today :-) .</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1310665">
				<div id="div-comment-1310665" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">parkrrrr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310665">
			September 28, 2017 at 5:38 am</a>		</div>

		<p>Thank you for making me feel slightly less insane. I had a vague thought that that was the case, from a youth misspent doing assembly language for the 80286 on an operating system that actually used call gates and such, but I was feeling too lazy to look it up.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ranta even thread-odd thread-alt depth-1 parent" id="comment-1310525">
				<div id="div-comment-1310525" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ranta' rel='external nofollow' class='url'>ranta</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310525">
			September 27, 2017 at 10:00 am</a>		</div>

		<p>C++ has std::less, which returns consistent results and does not cause undefined behavior when comparing pointers into different arrays; but AFAICT it still isn&#8217;t required to be useful for checking whether an address is within an array. For instance, with far pointers, it could treat offsets as more significant than selectors. And unlike casting to uintptr_t, the behavior isn&#8217;t even implementation-defined.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2 parent" id="comment-1310535">
				<div id="div-comment-1310535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310535">
			September 27, 2017 at 10:28 am</a>		</div>

		<p>Good point. std::less merely extends the existing partial order to a total order, so it removes the undefined behavior, but you could still have pointers p that satisfy x ≤ p < (x+n) even though p is not in the array of length n pointed to by x.
</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-ranta even depth-3" id="comment-1310945">
				<div id="div-comment-1310945" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/ranta' rel='external nofollow' class='url'>ranta</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310945">
			October 2, 2017 at 8:48 am</a>		</div>

		<p>Thinking a bit further…</p>
<p>You could first use std::less etc. to check whether the pointer seems to be between the beginning and the end of the array. If the result is negative, then that is reliable.  If the result is positive, then run a binary search to find the apparent position in the array, and finally use == to make sure.  The complexity would be O(log(size of array)).</p>
<p>OTOH, this kind of code would be useful only as a fallback for (architecture, compiler) pairs on which the uintptr_t cast doesn&#8217;t work. So if you don&#8217;t support customers building your code on random DeathStations, then there&#8217;s hardly a reason to optimize the fallback.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1310545">
				<div id="div-comment-1310545" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DonH</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310545">
			September 27, 2017 at 10:56 am</a>		</div>

		<p>It was even worse than that on OS/2 1.x, because you couldn&#8217;t just add 8 to the selector.  You needed to call DosGetHugeShift(&amp;usShiftCount), then shift 1 left by usShiftCount, and then use the resulting number as the selector increment.  I can&#8217;t imagine why this system never caught on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1310556">
				<div id="div-comment-1310556" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.NovelTheory.com' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310556">
			September 27, 2017 at 2:01 pm</a>		</div>

		<p>I recall being at a C++ standardization meeting were they had a similar debate.  They wanted to say something (an array or vector or such) was in &#8220;contiguous&#8221; memory.  But what exactly is &#8220;contiguous&#8221; memory?  When one byte is &#8220;next&#8221; to another?  So the diodes have to be adjacent on the chip?  And an algorithmic method of defining it runs into problems when you remember that in C++ you can redefine the meaning of ++, [ ],  ==,  in reference to your object.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1310605">
				<div id="div-comment-1310605" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fred</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310605">
			September 28, 2017 at 12:22 am</a>		</div>

		<p>This is the kind of optimisation that would make me consider the compiler &#8220;broken&#8221;, because any compiler smart enough to see that it&#8217;s &#8220;UB that can be optimised away&#8221; should also be smart enough to see that the test was put here for a reason (much like, say, an attempt to detect overflow in the result of a mathematical operation).</p>
<p>Or at least, it should output a warning that the comparison relies on UB.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1310615">
				<div id="div-comment-1310615" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fred</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310615">
			September 28, 2017 at 12:31 am</a>		</div>

		<p>In fact, range checking and after-the-fact overflow checks seem to be the main occurrences of the &#8220;ha ha it&#8217;s actually UB&#8221; gotcha, but are there other similar cases?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-3" id="comment-1310695">
				<div id="div-comment-1310695" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310695">
			September 28, 2017 at 11:20 am</a>		</div>

		<p><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120831-00/?p=6713">The premature downcast</a> and <a href="https://kristerw.blogspot.com/2017/09/why-undefined-behavior-may-call-never.html" rel="nofollow">calling a never-called function</a> are two examples that aren&#8217;t array-out-of-bounds or overflow.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1310625">
				<div id="div-comment-1310625" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310625">
			September 28, 2017 at 2:28 am</a>		</div>

		<p>&#8220;But why do you add 8 to move to the next selector? Why not just increment the selector? Because the bottom three bits of the selector are used for other things. In particular, the bottom bit of the selector is used to choose the selector table. Let&#8217;s ignore bits 1 and 2 since they are not relevant to the discussion. Assume for convenience that they are always zero.²&#8221; </p>
<p>Back in the days of 16 bit Windows you, or more likely a C compiler, could write code which referenced a magic windows kernel variable called (IIRC)_AHINCR. That told you &#8216;how much to increment a selector by to move 64 bytes forward&#8217;. So in 16 bit protected mode it would be 8 and in 16 bit real mode it would 1000h (65536&gt;&gt;4). </p>
<p>So a n*64K buffer would have n 64K selectors assigned to it, and you add _AHINCR to the value in the segment register to move between them.</p>
<p>Once 32 bit protected mode was possible the kernel would set the limit to the first selector to span the whole buffer on a 386+. So if the application knew about 32 bit mode it could just use a 32 bit offset from the first selector to access the whole buffer and it didn&#8217;t need to reload segment values. Which was no bad thing because loading a selector value into a segment register was not a fast process.</p>
<p>I always thought the whole scheme was rather neat &#8211; you could write gnarly segment arithmetic code for huge pointer access which was portable between real and protected mode and run on 8086,80286,80386+. And you could optionally write fast code for that avoid reloading segment values if you knew you were on a 386+.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1310635">
				<div id="div-comment-1310635" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Hewitt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310635">
			September 28, 2017 at 3:55 am</a>		</div>

		<p>As so often happens when I read your blog I realise I&#8217;ve been doing it wrong for years.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1310685">
				<div id="div-comment-1310685" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310685">
			September 28, 2017 at 7:31 am</a>		</div>

		<p>As an aside, range checks are much easier to read if the &#8216;&lt;&#039; signs all point the same way, like (low &lt;= value &amp;&amp; value = low &amp;&amp; value &lt; high).</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-mngoldeneagle odd alt depth-2 parent" id="comment-1310705">
				<div id="div-comment-1310705" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310705">
			September 28, 2017 at 2:06 pm</a>		</div>

		<p>It also works best when you use actual comparison operators (==) instead of assignment operators (=).</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1310745">
				<div id="div-comment-1310745" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310745">
			September 29, 2017 at 7:39 am</a>		</div>

		<p>Looks like the text editor got confused by the &lt; &amp; characters. What I typed had &quot;<i>this</i> rather than <i>that</i>&#8220;, with two expressions for <i>this</i> and <i>that</i>, but the text edited combined them to look like one monster expression. It&#8217;s pure luck it compiles at all.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1310735">
				<div id="div-comment-1310735" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Rogers (ex-MSFT)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310735">
			September 29, 2017 at 6:33 am</a>		</div>

		<p>It&#8217;s also interesting to note that there is a similar problem with UB in (signed) integer overflow if you&#8217;re trying to validate &#8220;(pointer + size)&#8221; where &#8220;pointer&#8221; and &#8220;size&#8221; are incorrect / untrusted and may cause integer overflow.</p>
<p>There is an interesting security corollary to these facts: pointer tests that can only fail if they trigger undefined behaviour can be validly optimised away. An example of this with integer overflow UB was reported on GCC, way back in 2006,:</p>
<p><a href="http://www.kb.cert.org/vuls/id/162289" rel="nofollow">http://www.kb.cert.org/vuls/id/162289</a><br />
<a href="http://gcc.gnu.org/ml/gcc-bugs/2006-04/msg01297.html" rel="nofollow">http://gcc.gnu.org/ml/gcc-bugs/2006-04/msg01297.html</a></p>
<p>Though MSVC at the time wasn&#8217;t using this UB as an optimisation opportunity, it sparked a purge of such UB on integer overflow within MSFT. Interestingly, some 10 years later, the codegen (compiler) team have created a new optimiser that can and does take advantage of integer overflow UB (c.f. &#8220;Taking advantage of signed integer overflow being undefined&#8221;):</p>
<p><a href="https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/" rel="nofollow">https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/</a></p>
<p>While they are still specifically trying to avoid optimising away anything that looks like a pointer test, the moral is that you need to avoid relying on UB in any integer arithmetic and in particular, if you rely on integer arithmetic UB, you may find parts of your code changed in ways that you didn&#8217;t expect (like having security checks removed)!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1310815">
				<div id="div-comment-1310815" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170927-00/?p=97095#comment-1310815">
			September 30, 2017 at 4:07 am</a>		</div>

		<p>Of course, an 80286 OS might decide not to use GDT entries for &#8220;compatibility&#8221; so that no valid pointer value can occur in the middle of a huge allocation. (I understand that Windows Standard Mode made very sparse use of GDT entries and it wouldn&#8217;t surprise me if this was a contributing factor.)</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

