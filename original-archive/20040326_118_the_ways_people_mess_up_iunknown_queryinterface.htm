<html>
<head>
<title>The ways people mess up IUnknown::QueryInterface</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The ways people mess up IUnknown::QueryInterface</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 26, 2004 / year-entry #119</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>33</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">When you're dealing with application compatibility, you discover all sorts of things that worked only by accident. Today, I'll talk about some of the "creative" ways people mess up the IUnknown::QueryInterface method. Now, you'd think, "This interface is so critical to COM, how could anybody possible mess it up?" Forgetting to respond to IUnknown. Sometimes...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
When you're dealing with application compatibility,
you discover all sorts of things that worked only by accident.
Today, I'll talk about some of the "creative" ways people
mess up the
<a HREF=http://msdn.microsoft.com/library/en-us/com/htm/cmi_q2z_7fvp.asp>
IUnknown::QueryInterface method</a>.
</p>
<p>
Now, you'd think, "This interface is so critical to COM,
how could anybody possible mess it up?"
</p>
<dl>
<dt>Forgetting to respond to IUnknown.</p>
<dd>
<p>
Sometimes you get so excited about responding to all these
great interfaces that you forget to respond to IUnknown itself.
We have found objects where</p>
<pre>
IShellFolder *psf = some object;
IUnknown *punk;
psf-&gt;QueryInterface(IID_IUnknown, (void**)&amp;punk);
</pre>
<p>fails with E_NOINTERFACE!
</p>
<dt>Forgetting to respond to your own interface.</p>
<dd>
<p>
There are some methods which return an object with a specific
interface. And if you query that object for its own interface,
its sole reason for existing, it says "Huh?"
</p>
<pre>
IShellFolder *psf = some object;
IEnumIDList *peidl, *peidl2;
psf-&gt;EnumObjects(..., &amp;peidl);
peidl-&gt;QueryInterface(IID_IEnumIDList, (void**)&amp;peidl2);
</pre>
<p>
There are some objects which return E_NOINTERFACE to the QueryInterface
call, even though you're asking the object for itself!
"Sorry, I don't exist," it seems they're trying to say.
</p>
<dt>Forgetting to respond to base interfaces.</p>
<dd>
<p>
When you implement a derived interface, you implicitly implement
the base interfaces, so don't forget to respond to them, too.</p>
<pre>
IShellView *psv = some object;
IOleView *pow;
psv-&gt;QueryInterface(IID_IOleView, (void**)&amp;pow);
</pre>
<p>Some objects forget and the QueryInterface fails with E_NOINTERFACE.
</p>
<dt>Requiring a secret knock.</p>
<dd>
<p>
In principle, the following two code fragments are equivalent:
</p>
<pre>
IShellFolder *psf;
IUnknown *punk;
CoCreateInstance(CLSID_xyz, ..., IID_IShellFolder, (void**)&amp;psf);
psf-&gt;QueryInterface(IID_IUnknown, (void**)&amp;punk);

CoCreateInstance(CLSID_xyz, ..., IID_IUnknown, (void**)&amp;punk);
punk-&gt;QueryInterface(IID_IShellFolder, (void**)&amp;psf);
</pre>
<p>
In reality, some implementations mess up and fail the second call
to CoCreateInstance. The only way to create the object successfully
is to create it with the IShellFolder interface.
</p>
<dt>Forgetting to say "no" properly.</p>
<dd>
<p>
One of the rules for saying "no" is that you have to set the
output pointer to NULL before returning.  Some people forget to do
that.
</p>
<pre>
IMumble *pmbl;
punk-&gt;QueryInterface(IID_IMumble, (void**)&amp;pmbl);
</pre>
<p>
If the QueryInterface succeeds, then pmbl must be non-NULL on return.
If it fails, then pmbl <strong>must be NULL on return</strong>.
</p>
</dl>
<p>
The shell has to be compatible with all these buggy objects because
if it weren't, customers would get upset and the press would have
a field day.  Some of the offenders
are big-name programs. If they broke, people would report,
"Don't upgrade to Windows XYZ, it's not compatible with
&lt;big-name program&gt;."
Conspiracy-minded folks would shout,
"Microsoft intentionally broke &lt;big-name program&gt;!
Proof of unfair business tactics!"
</p>
<p>
[Raymond is currently on vacation; this message was pre-recorded.]</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (33)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-157813">
				<div id="div-comment-157813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reuben Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157813">
			March 26, 2004 at 7:45 am</a>		</div>

		<p>I once saw a whole family of COM objects whose clients were forced to clean up via something like :</p>
<p> while (pObj-&gt;Release() &gt; 0) {<br />
<br /> }</p>
<p>I.e. you had to keep calling Release() until the refcount dropped to zero, at which point you could be sure they&#8217;d destroyed themselves.</p>
<p>Unless you did that (cos their reference counting was broken) apps leaked horribly and machines eventually died.</p>
<p>Did I mention that this was on ultra-mission-critical City finance systems?!<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-157843">
				<div id="div-comment-157843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157843">
			March 26, 2004 at 8:02 am</a>		</div>

		<p>Once again, these problems wouldn&#8217;t be there if Microsoft Windows had enforced correct behaviour to begin with.</p>
<p>That, and &lt;big-name program&gt; is most likely Office 95.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-157863">
				<div id="div-comment-157863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157863">
			March 26, 2004 at 8:18 am</a>		</div>

		<p>Every time I hear an accusation such as &quot;don&#8217;t upgrade to MS update X because it introduces an incompatibility with program Y,&quot; I wish MS would publish details on why program Y was to blame.  And links to MS public docs that spell out the rules that Y is violating.</p>
<p>Not only would this shut up the conspiraicy theorists, it just might shame the vendor of program Y into not doing these problems.</p>
<p>Of course, politics would let that happen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-157903">
				<div id="div-comment-157903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157903">
			March 26, 2004 at 10:10 am</a>		</div>

		<p>FYI, IShellView is derived from IOleWindow, not IOleView. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-157923">
				<div id="div-comment-157923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://schanda.co.za/blog' rel='external nofollow' class='url'>senkwe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157923">
			March 26, 2004 at 10:28 am</a>		</div>

		<p>Somebody care to explain the &quot;Requiring A Secret Knock&quot; example?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-157943">
				<div id="div-comment-157943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.redwoodroot.org' rel='external nofollow' class='url'>Peter Evans</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157943">
			March 26, 2004 at 11:12 am</a>		</div>

		<p>The &quot;Requiring A Secret Knock&quot; example has to deal with failing to have the Class constructor&#8217;s CreateInstance function invoked by CoCreateInstance allow itself to be assigned to an IUnknown pointer on creation.  Yet this is perfectly legal since all objects derive from IUnknown.</p>
<p>Its like the class constructor has this psuedo c++ code.  NOTE: iid is a guid so equivalence is usually done differently.</p>
<p>CreateInstance(&#8230;) {<br />
<br />switch (iid) {<br />
<br />case: IID_IShellFolder<br />
<br />{ //instatiate IShellFolder and return interface IShellFolder<br />
<br />&#8230; }<br />
<br />case: IID_IUnknown<br />
<br />{ &#8230;; return E_NOINTERFACE}<br />
<br />&#8230;<br />
<br />}<br />
<br />instead of<br />
<br />CreateInstance(&#8230;) {<br />
<br />switch (iid) {<br />
<br />case: IID_IShellFolder<br />
<br />{ //instatiate IShellFolder and return interface IShellFolder<br />
<br />&#8230; }<br />
<br />case: IID_IUnknown<br />
<br />{ //instatiate IShellFolder and return interface IUnknown<br />
<br />}<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-157963">
				<div id="div-comment-157963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.redwoodroot.org' rel='external nofollow' class='url'>Peter Evans</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157963">
			March 26, 2004 at 11:23 am</a>		</div>

		<p>Forgetting to respond to your own interface<br />
<br />QI==Are you you? NO!</p>
<p>&quot;FOO: Once again, these problems wouldn&#8217;t be there if Microsoft Windows had enforced correct behaviour to begin with. </p>
<p>That, and &lt;big-name program&gt; is most likely Office 95. &quot;</p>
<p>ooh! Great IDEA! Microsoft Windows the new stack machine enforcement agency regime (SMEAR).  No CPU should be allowed to run without it. :)</p>
<p>With any software its a wonder dynamic binding works at all.  I suppose we could all live in the realm of CNF and distributive protocol MATHEMATICS where if it doesn&#8217;t conform to safety and liveness properties or discrete mathematics the implementation shouldn&#8217;t exist or execute even if it does.  Have a dull deterministic day foo.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-157983">
				<div id="div-comment-157983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.popcornfilms.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157983">
			March 26, 2004 at 11:32 am</a>		</div>

		<p>Barry: Returning the value from Release is not optional; however, its value is binary &#8211; either the object has been completely released, or it&#8217;s in use.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158003">
				<div id="div-comment-158003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://schanda.co.za/blog' rel='external nofollow' class='url'>senkwe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158003">
			March 26, 2004 at 12:39 pm</a>		</div>

		<p>Peter, thanks for the response. If I understand you correctly &quot;Requiring A Secret Knock&quot; is a re-wording of &quot;Forgetting to respond to IUnknown&quot;? At least that&#8217;s how I saw it and hence my confusion.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-158023">
				<div id="div-comment-158023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158023">
			March 26, 2004 at 2:09 pm</a>		</div>

		<p>More to the point, trying to divine the reference count from outside is almost certainly an error. What would you do with the reference count if you knew it?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158033">
				<div id="div-comment-158033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158033">
			March 26, 2004 at 2:11 pm</a>		</div>

		<p>Follow up:</p>
<p>Specifically, think about the multi-threaded case. The reference count might change between AddRef/Release returning, and your thread executing the next instruction. So the value has no meaning that you can safely act upon. (What would you want to do with it anyway?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-157933">
				<div id="div-comment-157933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BarryTannenbaum</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-157933">
			March 26, 2004 at 11:02 am</a>		</div>

		<p>re: calling Release until it returns 0</p>
<p>Don&#8217;t forget that returning the reference count from AddRef and Release is *optional*.  Attempting to write code to debug COM object reference counting errors is a nightmare because of this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158013">
				<div id="div-comment-158013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Barry Tannenbaum</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158013">
			March 26, 2004 at 12:52 pm</a>		</div>

		<p>You&#8217;re right Simon, I wrote in haste.</p>
<p>However, it still would have been *way* easier if AddRef and Release were required to return the reference count.</p>
<p>Of course, that raises the question of whether this is the reference count for the interface or the object, which is probably why it&#8217;s undefined.  But it&#8217;s still a pain.  Trying to divine the reference count from the outside is error-prone, to say the least.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-158063">
				<div id="div-comment-158063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158063">
			March 26, 2004 at 9:34 pm</a>		</div>

		<p>I suspect that the reason why AddRef is not required to return exact reference count is to allow implementations to simply return the result of InterlockedIncrement.</p>
<p>On old CPUs (and OSes), return value of InterlockedIncement was not guaranteed to be exact. The only thing you could depend on was the sign of the return value (<a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/interlockedincrement.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/interlockedincrement.asp</a>).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158083">
				<div id="div-comment-158083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Entin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158083">
			March 26, 2004 at 10:45 pm</a>		</div>

		<p>Judging by earlier topic on the different ways companies defraud WHQL certification process, enforcing correct COM behavior does not seem possible.</p>
<p>The best solution is good libraries, like ATL. I&#8217;ve seen dozens of such bugs in pre-ATL code, but don&#8217;t remember any in ATL-based code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-158053">
				<div id="div-comment-158053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158053">
			March 26, 2004 at 5:25 pm</a>		</div>

		<p>He stated that he would be using it *to debug* COM objects.  I think this is a legitimate use of the return value; even MSDN itself agrees ( <a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/htm/cmi_q2z_59np.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/htm/cmi_q2z_59np.asp</a> ):<br />
<br />&quot;Return Value<br />
<br />Returns the resulting value of the reference count, which is used for diagnostic/testing purposes only.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158073">
				<div id="div-comment-158073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158073">
			March 26, 2004 at 10:17 pm</a>		</div>

		<p>In the presence of proxies, the return value also loses its meaning, since it is the reference count of the proxy, not of the underlying object.</p>
<p>foo: How do you recommend that Microosft enforce correct behavior? Since an IID is just a GUID, you cannot prove just by looking at an IID whether it is derived from another IID. You also cannot prove that an object implements all the methods correctly. I&#8217;ve seen objects that break the rules but but only when you ask them for a *specific* interface:</p>
<p>IUnknown::QueryInterface() {<br />
<br />if (riid == IID_BadInterface)<br />
<br />{ return S_OK; /*error*/ }<br />
<br />else { &#8230; /* correct implementation */ }<br />
<br />}</p>
<p>The only way to detect this ahead of time is to attempt to QueryInterface all 2^128 IIDs in the hopes of finding the bad one. And it&#8217;s possible that the bad QI is written like this:</p>
<p>IUnknown::QueryInterface() {<br />
<br />if (&#8230; complex condition &#8230;)<br />
<br />{ return S_OK; /*error*/ }<br />
<br />else { &#8230; /* correct implementation */ }<br />
<br />}</p>
<p>how can you test externally for this error? &quot;complex condition&quot; could be anything.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-158103">
				<div id="div-comment-158103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158103">
			March 27, 2004 at 2:09 pm</a>		</div>

		<p>The solution to the &quot;Secret Knock&quot; is to write your class factory like this: </p>
<p>CreateInstance(&#8230;) {<br />
<br />CObject *p = new CObject(&#8230;);<br />
<br />if (p) {<br />
<br />p-&gt;QueryInterface(&#8230;);<br />
<br />p-&gt;Release();<br />
<br />}<br />
<br />} </p>
<p>If you switch on the iid in your CreateInstance, then when you add a new interface to your CObject, you will also have to update the CreateInstance to support it &#8211; something you can easily forget to do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158143">
				<div id="div-comment-158143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.JCABs-Rumblings.com' rel='external nofollow' class='url'>JCAB</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158143">
			March 27, 2004 at 5:05 pm</a>		</div>

		<p>Raymond: &quot;How do you recommend that Microosft enforce correct behavior?&quot;</p>
<p>Designing the interface so that it&#8217;s a lot harder to make mistakes, of course. Implementing CoQueryInterface as a free API function that takes care of all the trivial cases would do just nicely.</p>
<p>Same goes for CreateInstance(). There&#8217;s no reason for CoCreateInstance() not to handle the interface itself.</p>
<p>Well&#8230; yes, there&#8217;s a reason: CreateInstance() could decide not to create the object at all if the interface is not supported. But, if a COM class was required to publish its list of supported interfaces together with CreateInstance(), that wouldn&#8217;t be needed either. Besides, that would help a free CoQueryInterface function to properly handle hierarchies itself.</p>
<p>JCAB<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-158173">
				<div id="div-comment-158173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158173">
			March 27, 2004 at 11:00 pm</a>		</div>

		<p>The problem with the proposed CoQueryInterface is that it would prevent people from implementing tear-offs, dynamic interfaces, object pseudo-interfaces, and other clever games inside QI. But the worst part would be that everybody would have to register their interfaces so CoQI can know about everybody&#8217;s interface hierarchies. Today you can run guidgen and ta-da, you have a new interface. No registration necessary. Just start using it.</p>
<p>The new world of the CLR has basically done what you suggested &#8211; interface management is no longer done by the object itself. Instead, you tell the CLR what your objects and interfaces derive from and it implements QI for you.  (Well, okay, the CLR QI doesn&#8217;t support tear-offs or dynamic interfaces&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158293">
				<div id="div-comment-158293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158293">
			March 28, 2004 at 6:46 pm</a>		</div>

		<p>&gt; IUnknown *punk;<br />
<br />&gt; psf-&gt;QueryInterface(IID_IUnknown, (void**)<br />
<br />&gt;  &amp;punk);</p>
<p>punk is not a void*.  punk is an IUnknown*.</p>
<p>void** is not a universal pointer type.  void* is a universal pointer type, and char* and relatives are grandparented in to be equivalent in that way, but void** is not.</p>
<p>Casting &amp;punk to type (void**) is just as risky as casting it to type (int*) or (struct s*).  Casting &amp;punk to type (void**) is just as risky as casting &amp;some_int to type (double*).</p>
<p>Casting &amp;punk to type (void*) would be safe, but that is not what you did.</p>
<p>If you want to obey the calling convention and avoid horrible deaths, you have to do this:<br />
<br />IUnknown *punk;<br />
<br />void *punkvoid;<br />
<br />psf-&gt;QueryInterface(IID_IUnknown, &amp;punkvoid);<br />
<br />punk = (IUnknown *) punkvoid;</p>
<p>And you know it.  Lots of other MSDN contributors made the same identical mistake.  Many of your articles correct the mistakes of MSDN contributors, and this should have been one of them.  You&#8217;ll probably tell me that it works in all VC++ implementations to date, but that doesn&#8217;t make it correct code, you&#8217;re still violating the calling convention.</p>
<p>(By the way, the requirement for that (IUnknown *) cast, though safe, is still dangerous.  All usage of casts desensitizes people so they forget to check how dangerous casts usually are.  It would have been better if C++ still allowed C-style assignment directly from void* to other data pointer types, with implicit conversion instead of requiring the cast.  Of course the compiler would still generate code necessary for this conversion.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-158343">
				<div id="div-comment-158343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158343">
			March 29, 2004 at 12:53 am</a>		</div>

		<p>I agree that the distinction is theoretically necessary (on word-addressed machines), but COM assumes a byte-addressed machine.</p>
<p>I think the intentionally-incorrect (void**) was chosen to try to catch people making the mistake</p>
<p>IUnknown *punk;<br />
<br />psf-&gt;QueryInterface(IID_IUnknown, punk); </p>
<p>which would otherwise go unnoticed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158383">
				<div id="div-comment-158383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158383">
			March 29, 2004 at 4:49 am</a>		</div>

		<p>&quot;It would have been better if C++ still allowed C-style assignment directly from void* to other data pointer types, with implicit conversion instead of requiring the cast&quot;</p>
<p>&quot;better&quot; in the sense of preventing the compiler from catching certain bugs?</p>
<p>How&#8217;s that an improvement?</p>
<p>I don&#8217;t know about you, but I think it&#8217;s quite desirable that this issue an error:<br />
<br />char ch(0);<br />
<br />char* pc(&amp;ch);<br />
<br />void* pv(pc);<br />
<br />int* pi(pv);<br />
<br />*pi = 0; // ruh roh raggy.</p>
<p>void* can point at anything, so it&#8217;s not unreasonable that I should have to specify exactly what I want to convert to.</p>
<p>It&#8217;s not immediately clear how this is a calling convention issue; object representations (the requirement that<br />
<br />T t;<br />
<br />foo((void**)&amp;t)<br />
<br />is equivalent to<br />
<br />T t;<br />
<br />void* pv(&amp;t);<br />
<br />foo(&amp;pv);<br />
<br />insofar as in either case the pointer can be dereferenced once to yield a T* and twice to yield a T) should surely not be specified as part of a calling convention.</p>
<p>The use of C style casts is another abomination.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-158703">
				<div id="div-comment-158703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158703">
			March 29, 2004 at 5:01 pm</a>		</div>

		<p>3/29/2004 12:53 AM Raymond Chen:</p>
<p>&gt; I agree that the distinction is<br />
<br />&gt; theoretically necessary (on word-addressed<br />
<br />&gt; machines), but COM assumes a byte-addressed<br />
<br />&gt; machine.</p>
<p>You&#8217;ve proved in other topics that you know why this excuse is invalid.</p>
<p>I&#8217;ve read that there&#8217;s a machine where some pointers can be 128 bytes long (that&#8217;s the pointer not the item being pointed to), but I don&#8217;t think all pointers are 128 bytes long on that machine.  I don&#8217;t know if it&#8217;s a byte-addressed machine though.  If we want to consider some known byte-addressed machines, we know of some cases where pointers to member functions aren&#8217;t the same size as pointers to ordinary functions, though I admit that neither of these is a pointer to data or void*.</p>
<p>&gt; I think the intentionally-incorrect (void**)<br />
<br />&gt; was chosen to try to catch people making the<br />
<br />&gt; mistake<br />
<br />&gt; IUnknown *punk;<br />
<br />&gt; psf-&gt;QueryInterface(IID_IUnknown, punk);<br />
<br />&gt; which would otherwise go unnoticed.</p>
<p>I&#8217;m really confused by this statement.  It doesn&#8217;t see incorrect (intentionally or otherwise) to define the second parameter with type (void**).  So I can only guess at the moment, would you consider it more correct to define the second parameter with type (IUnknown**)?  But if that were done, then your example error would indeed be caught.  Besides, it would prevent querying for interfaces other than IUnknown, so I don&#8217;t really think that would be more correct.</p>
<p>On the other hand, use of a cast prevents the compiler from diagnosing lots of possible actual errors.  This is really why it is dangerous to desensitize people to the use of this dangerous tool.</p>
<p>Anyway, you know that the following code works, and you know why it should be used:<br />
<br />void *punkvoid;<br />
<br />psf-&gt;QueryInterface(IID_IUnknown, &amp;punkvoid);<br />
<br />punk = (IUnknown *) punkvoid;</p>
<p>3/29/2004 4:49 AM DrPizza:</p>
<p>&gt; &quot;better&quot; in the sense of preventing the<br />
<br />&gt; compiler from catching certain bugs?<br />
<br />&gt; int* pi(pv); </p>
<p>You think that C++&#8217;s requirement for coding casts prevents this bug?<br />
<br />int* pi = (int*) pv;</p>
<p>What else are you going to do with your pv?  If you think it points to something, you&#8217;re planning to use the value of that something eventually.  Sure when you think it points to something and it doesn&#8217;t, that&#8217;s a bug, but that bug is not eliminated by desensitizing people to the use of casts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158863">
				<div id="div-comment-158863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-158863">
			March 30, 2004 at 1:24 am</a>		</div>

		<p>&quot;You think that C++&#8217;s requirement for coding casts prevents this bug? &quot;</p>
<p>It&#8217;s self-evident.  The code won&#8217;t compile.</p>
<p>&quot;What else are you going to do with your pv?&quot;<br />
<br />Who knows?  Normally it&#8217;s given to someone else to deal with because I&#8217;m working with some crufy C API.</p>
<p>&quot;If you think it points to something, you&#8217;re planning to use the value of that something eventually. Sure when you think it points to something and it doesn&#8217;t, that&#8217;s a bug, but that bug is not eliminated by desensitizing people to the use of casts. &quot;</p>
<p>There is no desensitization.  Casts like that are extremely rare in good C++.  Far from desensitizing programmers, it makes abundantly clear to them that they&#8217;re doing something that&#8217;s potentially dangerous.  They only perform such casts infrequently, so it serves as an effective warning.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-159173">
				<div id="div-comment-159173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-159173">
			March 30, 2004 at 4:26 pm</a>		</div>

		<p>&gt;&gt; You think that C++&#8217;s requirement for coding<br />
<br />&gt;&gt; casts prevents this bug?<br />
<br />&gt;&gt; int* pi = (int*) pv;<br />
<br />&gt;<br />
<br />&gt; It&#8217;s self-evident. The code won&#8217;t compile.</p>
<p>That doesn&#8217;t look very self-evident to me.</p>
<p>&gt; There is no desensitization. Casts like that<br />
<br />&gt; are extremely rare in good C++.</p>
<p>I wonder how to reply to this.</p>
<p>1.  C++ forces that kind of cast to be used, whereas C allows pointers of type (void*) to be assigned to pointers that point to data.  That was because C knew that (void*) was added to meet a need, which it did meet, while it did not replace the need for ordinary pointers to be used normally.  Do you mean that good C++ code extremely rarely has any need for pointers of type (void*), as opposed to good C code which only moderately needed them?</p>
<p>2.  At least it seems you&#8217;re agreeing with me that this:<br />
<br />&gt; [&#8230;] (void**)&amp;punk [&#8230;]<br />
<br />is not good C++ code.  But the problem remains that even when this bad code is removed, C++ still forces a cast to be used in a subsequent assignment, in the location where C would not force it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-159333">
				<div id="div-comment-159333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-159333">
			March 31, 2004 at 6:10 am</a>		</div>

		<p>&quot;1. C++ forces that kind of cast to be used, whereas C allows pointers of type (void*) to be assigned to pointers that point to data.&quot;<br />
<br />Which is good, it prevents accidents.</p>
<p>&quot;That was because C knew that (void*) was added to meet a need, which it did meet, while it did not replace the need for ordinary pointers to be used normally. Do you mean that good C++ code extremely rarely has any need for pointers of type (void*), as opposed to good C code which only moderately needed them? &quot;<br />
<br />Correct.  In general I would suggest that the only time void* should be used in C++ is when calling those unwrapped C APIs that require it.  Many of those APIs (though not this one) probably deserve lightweight wrappers anyway.</p>
<p>&quot;is not good C++ code. But the problem remains that even when this bad code is removed, C++ still forces a cast to be used in a subsequent assignment, in the location where C would not force it. &quot;<br />
<br />But that&#8217;s a /good/ thing, not a bad one.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-164283">
				<div id="div-comment-164283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skywing</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-164283">
			April 15, 2004 at 6:06 pm</a>		</div>

		<p>I&#8217;m gay</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-368933">
				<div id="div-comment-368933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jeffdav/archive/2006/04/11/573776.aspx' rel='external nofollow' class='url'>jeff's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-368933">
			April 11, 2006 at 7:38 pm</a>		</div>

		<p>IOleCommandTarget is very useful.&amp;amp;nbsp; It provides a generic way of sending commands between objects.&amp;amp;nbsp;&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-451483">
				<div id="div-comment-451483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/12/08/1239911.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-451483">
			December 8, 2006 at 10:00 am</a>		</div>

		<p>Returning E_NOINTERFACE from IUnknown::QueryInterface has very specific meaning.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-491753">
				<div id="div-comment-491753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jeffdav/archive/2007/04/10/on-ccomqiptr.aspx' rel='external nofollow' class='url'>jeff's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-491753">
			April 10, 2007 at 6:43 pm</a>		</div>

		<p>You&#8217;re writing some code that uses COM. Do you use SmartPointers or not use SmartPointers? Debate on</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-499843">
				<div id="div-comment-499843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2007/05/04/2402028.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-499843">
			May 4, 2007 at 4:44 pm</a>		</div>

		<p>Watch what?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-529113">
				<div id="div-comment-529113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2007/07/23/4003873.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040326-00/?p=40033#comment-529113">
			July 23, 2007 at 12:46 pm</a>		</div>

		<p>It&#8217;s in the design.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

