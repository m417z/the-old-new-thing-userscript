<html>
<head>
<title>How did MS-DOS report error codes?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How did MS-DOS report error codes?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 17, 2005 / year-entry #15</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>62</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The old MS-DOS function calls (ah, int 21h), typically indicated error by returning with carry set and putting the error code in the AX register. These error codes will look awfully familiar today: They are the same error codes that Windows uses. All the small-valued error codes like ERROR_FILE_NOT_FOUND go back to MS-DOS (and possibly...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>The old MS-DOS function calls (ah, int 21h), typically indicated error by returning with carry set and putting the error code in the AX register.  These error codes will look awfully familiar today: They are the same error codes that Windows uses.  All the small-valued error codes like ERROR_FILE_NOT_FOUND go back to MS-DOS (and possibly even further back).</p>
<p> Error code numbers are a major compatibility problem, because you cannot easily add new error code numbers without breaking existing programs.  For example, <a href="http://blogs.msdn.com/LarryOsterman/archive/2004/04/05/108065.aspx"> it became well-known that "The only errors that can be returned from a failed call to OpenFile are 3 (path not found), 4 (too many open files), and 5 (access denied)."</a> If MS-DOS ever returned an error code not on that list, programs would crash because they used the error number as an index into a function table without doing a range check first. Returning a new error like 32 (sharing violation) meant that the programs would jump to a random address and die. </p>
<p> More about error number compatibility next time. </p>
<p> When it became necessary to add new error codes, compatibility demanded that the error codes returned by the functions not change.  Therefore, if a new type of error occurred (for example, a sharing violation), one of the previous "well-known" error codes was selected that had the most similar meaning and that was returned as the error code. (For "sharing violation", the best match is probably "access denied".) Programs which were "in the know" could call a new function called "get extended error" which returned one of the newfangled error codes (in this case, 32 for sharing violation). </p>
<p> The "get extended error" function returned other pieces of information. It gave you an "error class" which gave you a vague idea of what type of problem it is (out of resources? physical media failure? system configuration error?), an "error locus" which told you what type of device caused the problem (floppy? serial? memory?), and what I found to be the most interesting meta-information, the "suggested action". Suggested actions were things like "pause, then retry" (for temporary conditions), "ask user to re-enter input" (for example, file not found), or even "ask user for remedial action" (for example, check that the disk is properly inserted). </p>
<p> The purpose of these meta-error values is to allow a program to recover when faced with an error code it doesn't understand.  You could at least follow the meta-data to have an idea of what type of error it was (error class), where the error occurred (error locus), and what you probably should do in response to it (suggested action). </p>
<p> Sadly, this type of rich error information was lost when 16-bit programming was abandoned.  Now you get an error code or an exception and you'd better know what to do with it. For example, if you call some function and an error comes back, how do you know whether the error was a logic error in your program (using a handle after closing it, say) or was something that is externally-induced (for example, remote server timed out)? You don't. </p>
<p> This is particularly gruesome for exception-based programming. When you catch an exception, you can't tell by looking at it whether it's something that genuinely should crash the program (due to an internal logic error - a null reference exception, for example) or something that does not betray any error in your program but was caused externally (connection failed, file not found, sharing violation). </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (62)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-245343">
				<div id="div-comment-245343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Somebody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245343">
			January 17, 2005 at 7:39 am</a>		</div>

		<p>&quot;When you catch an exception, you can&#8217;t tell by looking at it&#8230;&quot;</p>
<p>What about:</p>
<p>try {<br />
<br />   // do stuff<br />
<br />}<br />
<br />catch (ExceptionThatShouldCrashProgram e) {<br />
<br />   crashAndBurn();<br />
<br />}<br />
<br />catch (ExceptionCausedByExternalFactors e) {<br />
<br />   // do stuff to recover<br />
<br />}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245353">
				<div id="div-comment-245353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245353">
			January 17, 2005 at 7:42 am</a>		</div>

		<p>You write that you cannot tell by looking at an Exception what kind of error originally occured. Of course you can!</p>
<p>I&#8217;m not familar with .NET programming and I&#8217;m definitely not up in raising another Java/.NET battle but since Java is what I&#8217;m doing every day I can say that there is a way to tell the cause and severeness of an Exception, by simply looking at the class of Exception that has been thrown</p>
<p>Let&#8217;s consider this small piece of demo code:</p>
<p>try {<br />
<br />  doStuff();<br />
<br />} catch(OutOfMemoryError e) {<br />
<br />  System.err.println(&quot;Cause of error was not enough memory&quot;);<br />
<br />} catch(FileNoFoundException e) {<br />
<br />  System.err.println(&quot;Cause of error was a missing file&quot;);<br />
<br />} catch(ConnectException e) {<br />
<br />  System.err.println(&quot;Could not connect to remote machine&quot;);<br />
<br />}</p>
<p>It&#8217;s even a lot more comfortable to add additional information. A FileNotFoundException might be subclassed by, let&#8217;s say a DriveUnavailableException (user tried to access K:test.txt where no drive K is available).</p>
<p>Any old program just knowing the existence of FileNotFoundException continues to work properly, and any new feature might perfom an explicit check for the new kind of Exception.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245363">
				<div id="div-comment-245363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245363">
			January 17, 2005 at 7:46 am</a>		</div>

		<p>It has been my experience that the caller, more often than the callee, knows how severe a particular error is in the current context. Asking the error producer things like &quot;Should we close the program because of this?&quot; isn&#8217;t usually a good thing. </p>
<p>To use the file access error example; if you are trying to open a file and you get a sharing violation, you may just want to default to a read-only state. </p>
<p>As for what produced the error in the first place, any relevant information should be included in the exception type or members whenever possible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245373">
				<div id="div-comment-245373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.benwatson.org' rel='external nofollow' class='url'>Ben</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245373">
			January 17, 2005 at 7:50 am</a>		</div>

		<blockquote><p>
  &gt;&gt;you can&#8217;t tell by looking at it whether it&#8217;s something that genuinely should crash the program (due to an internal logic error &#8211; a null reference exception, for example) or something that does not betray any error in your program but was caused externally (connection failed, file not found, sharing violation). &lt;&lt;&lt;</p>
<p>If an exception happens due to external factors, that&#8217;s supposed to be handled by your code in any case, with a well-defined clean-up/recovery strategy&#8211;that should be recognizable, at least.</p>
<p>If it&#8217;s an internal logic error, at some point an exception or error will be returned, crashing your program because you didn&#8217;t plan for buggy code. </p>
<p>Granted, there are always truly exceptional situations that you can&#8217;t plan for that might cause an unforeseen error that is indistinguishable from buggy code.</p>
<p>In the case of bugs causing &quot;access denied&quot; exceptions, for example, shouldn&#8217;t that bug be fleshed out with a decent set of test cases?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245383">
				<div id="div-comment-245383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.benwatson.org' rel='external nofollow' class='url'>Ben (II)</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245383">
			January 17, 2005 at 7:52 am</a>		</div>

		<p>BTW, Those are two different Bens who posted 4 minutes apart. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245393">
				<div id="div-comment-245393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245393">
			January 17, 2005 at 7:53 am</a>		</div>

		<p>Chris/Ben/Somebody:<br />
<br />  You&#8217;re all missing the &quot;Fuzzy Abstraction&quot; effect.</p>
<p>  What happens when my application calls into class A, which calls into class B, which calls into external assembly C, which calls into class D, which calls into external assembly E.</p>
<p>E throws an exception that&#8217;s 100% relevant to its situation &#8211; the app doesn&#8217;t even know that E&#8217;s going to the internet (or floppy, or whatever) to fetch its data.</p>
<p>Classes A, B and D correctly ignore the exception (they do unwind correctly of course).</p>
<p>But what does the application do with that exception?  It doesn&#8217;t know why E was going to the net.  It doesn&#8217;t know whether or not the circumstances that caused E to go to the net were transient or not.</p>
<p>All it knows is that an exception&#8217;s occurred.</p>
<p>The only way around this is for classes A, B, and D to catch ALL possible exceptions, reframe them in terms of their own exception hierarchy, and then rethrow.  But whenever they do this, they lose information about the exception.  By the time the application gets the error, all they see is the equivilant of E_FAIL.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245443">
				<div id="div-comment-245443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim Davidson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245443">
			January 17, 2005 at 8:13 am</a>		</div>

		<p>Larry,</p>
<p>Your objection comes down to translation of exceptions at module/application boundaries. </p>
<p>The answer is that those (few) exceptions that can usefully transmit information across such boundaries should be subclassed and tested for, and then possibly translated.</p>
<p>Surely exactly the same kind of problem arises when trying to apply a global list of error codes across multiple projects with different sponsors and schedules?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245463">
				<div id="div-comment-245463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245463">
			January 17, 2005 at 8:41 am</a>		</div>

		<p>Chris: Oops, you forgot ServerClosedConnectionException. Too bad testing didn&#8217;t find that case either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245473">
				<div id="div-comment-245473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/EricLippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245473">
			January 17, 2005 at 8:45 am</a>		</div>

		<p>For similar reasons, VB6/VBScript&#8217;s error codes are backwards-compatible back to the original Altair BASIC code written by Bill &amp; Paul 30 years ago:</p>
<p><a target="_new" href="http://blogs.msdn.com/ericlippert/archive/2004/09/09/227461.aspx" rel="nofollow">http://blogs.msdn.com/ericlippert/archive/2004/09/09/227461.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245483">
				<div id="div-comment-245483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245483">
			January 17, 2005 at 8:46 am</a>		</div>

		<p>Chris: Oops, you forgot ServerClosedConnectionException. Too bad testing didn&#8217;t find that case either.</p>
<p>Ben Cooke: &quot;I would expect that a caller would know what it&#8217;s direct callee is going to do.&quot;</p>
<p>Okay, what exceptions should the caller of StreamReader.ReadLine() be expecting?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245493">
				<div id="div-comment-245493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245493">
			January 17, 2005 at 9:06 am</a>		</div>

		<p>Don&#8217;t you love religion in Programming?  Exception handling is one of the &quot;new&quot; religious dogmas.  (If you&#8217;ve been programming for 25 years.)  What is amusing is the &quot;jump to the defense of exceptions&quot; that happens.  This then promotes the &quot;pound harder on exceptions&quot; responses.</p>
<p>Fundamentally, error handling is hard.  There is no one method that solves all problems.</p>
<p>I find that try/catch blocks can make the code even more messy than ever, making it harder to understand what the code is doing, and are all the cases handled.  Try/catch forces you to use one of a limited set of algorithms, and it seems to be hard to make &quot;clean&quot; code, whatever that means.</p>
<p>File IO errors are especially difficult to handle, since the range of possible errors seems to keep increasing over time.  At least the Tape I/O errors seem to have left the general lexicon.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245503">
				<div id="div-comment-245503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245503">
			January 17, 2005 at 9:16 am</a>		</div>

		<p>Raymond,<br />
<br />That depends on the design of the standardized exception library. For Java&#8217;s version of that function, there is one exception called IOException, which everything else can subclass. If a program is just operating on a stream with no idea what kind of stream it has, then it can catch IOException and fail gracefully, because any kind of error while reading is probably a show-stopper. If a specific caller knows it&#8217;s really operating on a socket, it can catch SocketException and handle that case in a more special way.</p>
<p>My point, basically, is that increased abstraction for your call means increased abstraction for (and thus less granularity in) error reporting. The heirarchy of exception classes is just like a heirarchy of error codes, but with arbitrary metadata attached to each depending on the needs of the caller. If you are operating on any kind of stream, then all you can do is know that there was some kind of stream error, because you can&#8217;t possibly know about all of the things that can go wrong with all streams. However, you can know that streams can go wrong in various ways and differentiate these from errors such as a bug in the library you&#8217;re calling causing a divide by zero, or suchlike.</p>
<p>In practice, though, Java&#8217;s Exception classes are pretty useless when it comes to metadata; most don&#8217;t really give you anything beyond a cryptic natural-language message. The heirarchy and standardization are good, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245513">
				<div id="div-comment-245513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Shuttlewood</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245513">
			January 17, 2005 at 9:16 am</a>		</div>

		<blockquote><p>
  &gt; Okay, what exceptions should the caller of StreamReader.ReadLine() be expecting? </p>
<p>Java has checked exceptions which ameliorate this to some degree.</p>
<p>public String readLine()<br />
  <br />                throws IOException</p>
<p>Of course, if I happen to readLine() in my code, that doesn&#8217;t magically bubble downwards from E to A either, as it would have to be explicitly declared by D, C and B to bubble downwards. D will have to either state that it will bubble downwards or wrap it in it&#8217;s own exception type or possibly handle it in a different way.</p>
<p>Exceptions got mentioned on lambda a<br />
  <br />&lt;a href=&quot;<a target="_new" href="http://lambda-the-ultimate.org/node/view/472#comment-3488&quot;&gt;couple" rel="nofollow">http://lambda-the-ultimate.org/node/view/472#comment-3488&quot;&gt;couple</a> of days ago &lt;/a&gt;.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245523">
				<div id="div-comment-245523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew Shuttlewood</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245523">
			January 17, 2005 at 9:18 am</a>		</div>

		<p>Erk. Can you fix the link please? Never quite sure how these things will deal with links :|</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245533">
				<div id="div-comment-245533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245533">
			January 17, 2005 at 9:19 am</a>		</div>

		<p>Raymond: all the ones it has in its throw list.  A program shouldn&#8217;t compile if a caller doesn&#8217;t handle or declare as throwable all the exceptions its callee throws.</p>
<p>Vorn</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245543">
				<div id="div-comment-245543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245543">
			January 17, 2005 at 9:21 am</a>		</div>

		<blockquote><p>
  I find that try/catch blocks can make the code even more messy than ever.<br />
  <br />I agree on this point, and certainly don&#8217;t think that exceptions are some magic answer to all error-handling needs. My posts thus far were simply intended to address what I saw as an error on Raymond&#8217;s part, and later on Larry&#8217;s part. Raymond said:<br />
  <br />&quot;When you catch an exception, you can&#8217;t tell by looking at it whether it&#8217;s something that genuinely should crash the program [&#8230;] or something that does not betray any error in your program but was caused externally [&#8230;].&quot;</p>
<p>&#8230;but if you have some standardized exception class heirarchy, you can distinguish between &quot;I tried to read from a stream but some external problem prevented it&quot; and &quot;I tried to read from a stream but this stupid I/O library tried to dereference a null pointer/object&quot;.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245553">
				<div id="div-comment-245553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245553">
			January 17, 2005 at 9:35 am</a>		</div>

		<p>Too bad .NET&#8217;s WebException and SocketException don&#8217;t derive from IOException, for example.</p>
<p>But even that wouldn&#8217;t fix everything. What about &quot;access denied&quot; on a registry key or service? That&#8217;s not an I/O exception but it is something a program should be prepared for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245563">
				<div id="div-comment-245563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://supersat.livejournal.com/' rel='external nofollow' class='url'>Karl Koscher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245563">
			January 17, 2005 at 9:42 am</a>		</div>

		<p>Java makes some distinction between types of exceptions. Anything derived from java.lang.Exception should be caught and dealt with. Anything derived from java.lang.Error is a serious problem and shouldn&#8217;t be caught or dealt with. You&#8217;re required to handle (or at least re-throw) any Exception a method may throw, but you&#8217;re not required to handle an Error.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245603">
				<div id="div-comment-245603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Levine</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245603">
			January 17, 2005 at 9:59 am</a>		</div>

		<p>Checked exceptions dont scale or version well; not using them doesn&#8217;t scale or version well either. :-) </p>
<p>Error handling is hard, and using exceptions for it is still hard. It&#8217;s better then using error codes, especially since you can catch-wrap-throw up the callstack, adding context as you go.</p>
<p>There is a fundamental contradiction in error handling. In general, the further away the recovery code is from the site of the exception the less able it will be to correctly deal with the specific problem; it will have full business logic of the context leading to the failure but little technical knowledge on how to proceed with recovery. However, the closer the recovery code is to the failure point the less likely it is to have sufficient business context, resources, or access to new/different data, to be able to recover, even though it has full technical knowledge of the cause.</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245613">
				<div id="div-comment-245613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245613">
			January 17, 2005 at 10:52 am</a>		</div>

		<p>Raymond,<br />
<br />Failures reading the registry is something hardly any program does well, because it&#8217;s usually abstracted away so that the caller doesn&#8217;t even know the registry&#8217;s involved. Exceptions or not, reporting that error without &quot;giving away&quot; that you&#8217;re hitting the registry is a hard problem, unless you want every single function, regardless of purpose, to be able to return an &quot;I wasn&#8217;t allowed to do that for some reason&quot; error.</p>
<p>One reason why people have come to dislike return status codes so much is that functions traditionally can only return one value, so you can&#8217;t return an answer and a status code at the same time unless you resort to the technique of using invalid values to indicate errors. For those that love return status codes, there should be a separate &quot;result&quot; value returned from every function in addition to its answer.  Of course, no-one wants to do that because of the extra overhead it would cause when in most cases the result would end up getting discarded anyway&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245623">
				<div id="div-comment-245623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/ericlippert' rel='external nofollow' class='url'>Eric Lippert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245623">
			January 17, 2005 at 11:03 am</a>		</div>

		<p>I understand the criticism that exception handling makes it harder to write correct code because it&#8217;s non-obvious what all possible program flows are.</p>
<p>However, I don&#8217;t understand the criticism that it&#8217;s hard to know that you&#8217;ve handled all the exceptions you need to handle.  As Raymond points out in this very article, it&#8217;s equally impossible to know all the error codes that a call could return.</p>
<p>As a mitigation to this problem &#8212; that external components could be throwing any darn thing &#8212; exceptions are CLEARLY superior to error codes.  Exceptions are extensible, subclassable, nestable information bearing structures that contain not just what went wrong, but where in the code it went wrong, and what error to report to the user.  Exceptions, unlike HRESULTs, are self-describing and unique.  (A FACILITY_CONTROL HRESULT tells you nothing if you do not know what control returned it.)</p>
<p>For me, the value proposition for exceptions which makes them worth the pain entailed by the first criticism is a consequence of the first criticism: exceptions, unlike error codes, cannot be accidentally ignored without crashing the program.</p>
<p>Writing correct error handling code is hard.  Hard enough that people often skip it, or write lousy error handling.  Code which ignores error return codes tends to muddle on even when its in a bad state.  Exceptions, which cannot be ignored, make such programs brittle.</p>
<p>Brittle is good in the application development world!  I want badly written programs to be brittle, so that developers are encouraged to design careful error handling via negative reinforcement.  I want programs to die horribly and immediately if there&#8217;s an unanticipated problem, not muddle on, making me think its working when in fact it&#8217;s doing heaven only knows what.</p>
<p>Exception-throwing languages force you to think hard about error handling. Anything that forces you to think hard about important problems is goodness in my book.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245643">
				<div id="div-comment-245643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245643">
			January 17, 2005 at 11:37 am</a>		</div>

		<p>Eric: Exception-throwing languages force you to think hard about error handling. </p>
<p>No they don&#8217;t.  Not in the least.  All they do is change how you ignore the errors.  I have seen too many instances where people use &quot;catch (&#8230;)&quot; to ignore nasty errors such as access violations.</p>
<p>I bet most people here have run into bad applications where OnPaint throws an exception, pops up a error message and then throws an exception again when the dialog is cleared and the window tries to repaint.  Thank god for task manager.</p>
<p>In a perfect world, exceptions ARE clearly superior.  However, in the real world where programmers are poorly trained and on a tight schedule, exceptions are just another form of the same nightmare.</p>
<p>The idea that exceptions force you to do anything is absurd.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245653">
				<div id="div-comment-245653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Boris Zakharin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245653">
			January 17, 2005 at 1:13 pm</a>		</div>

		<p>Then maybe catch(&#8230;) should not exist?</p>
<p>Yes, I admit, I do it too. But in my case, any time a serious exception (i.e. one I don&#8217;t specifically handle) comes up, I display an &quot;A serious error has occured. Would you like to attempt to recover?&quot; message, so at least in theory, the user should be able to click &quot;no&quot; to quit if the message comes up over and over again. (On thne other hand, if the user does click &quot;yes&quot; somew fun things happen, such as loosing the DialogProc and being unable to quit)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245673">
				<div id="div-comment-245673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">The first Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245673">
			January 17, 2005 at 1:34 pm</a>		</div>

		<p>I&#8217;ve seen good arguments for why C# doesn&#8217;t have strong exception checking before, and I believe they were right in leaving that out. But I wonder if it would be possible to introduce exception checking that just displays compile warnings? </p>
<p>It seems a mistake to rely on documentation to tell you what exceptions could come out of a particular method. Why can&#8217;t the compiler check this and just let you know? It could still compile the code. It could even be a switch similiar to &quot;Option Explicit&quot; in VB.</p>
<p>This has probably been discussed many times before and I&#8217;ve just missed it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245703">
				<div id="div-comment-245703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/mgrier' rel='external nofollow' class='url'>Michael Grier</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245703">
			January 17, 2005 at 2:32 pm</a>		</div>

		<p>Re: brittle, extensible (Eric Lippert&#8217;s comment):</p>
<p>Catching unsealed exception types is semantically equivalent to catch(&#8230;) since you don&#8217;t really know, over time, what&#8217;s going to derive from that exception type.</p>
<p>The categorization of failures problem tends to disallow any single inheritance tree from being able to organize the exception type hierarchy.  The extensibility of exception types means that over time the contract of what exceptions you&#8217;re catching changes.</p>
<p>The entity at the top of the conceptual stack (the application) is entitled to screw itself up as much as it likes.  Things in the middle are the problem, so in general, you should only catch exceptions originated in your same call frame or the next call frame down.  (I&#8217;ll ignore &quot;trivial&quot; frames that come with template classes.)</p>
<p>Throwing exceptions is great.  Catching them is terrible.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245733">
				<div id="div-comment-245733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245733">
			January 17, 2005 at 3:07 pm</a>		</div>

		<p>&quot;3. &quot;What you probably should do in response to it (suggested action)&quot;<br />
<br />Again, from .NET&#8217;s Exception class you find this information: &#8211; HelpLink, &#8211; Message&quot;</p>
<p>But I haven&#8217;t written an English language parser yet. &quot;Message&quot; is great for showing to the end user, but how does the program know whether it should just &quot;wait 3 seconds and retry&quot;? Or should it just offload that to the user?  &quot;Unable to save the file due to the following error: Routing tables are being built. Wait three seconds and try again.&quot;</p>
<p>Note that InvalidOperationException includes things that are programming logic errors, like NullReferenceException and ObjectDisposedException.  What is the user expected to do when prompted with &quot;Unable to save the file for the following reason: Cannot access a closed stream.&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245403">
				<div id="div-comment-245403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245403">
			January 17, 2005 at 8:03 am</a>		</div>

		<p>Larry,<br />
<br />I agree with you to a certain extent, but I would expect that a caller would know what it&#8217;s direct callee is going to do and what kind of exceptions it can throw. Therefore accurately &quot;re-framing&quot; the exception in different terms can be done to a sensible extent without the loss of important information.</p>
<p>However, if the exception *does* bubble up unmodified from E to A, at least A knows that the error had something to do with the network, or a disk, or whatever. Assuming that the exception classes are reasonably standardized (as in Java) and designed in a sensible manner, the original caller A can at least handle some superclass of the exception and use an overridden method to get information that the user might find useful to rectify the situation.</p>
<p>Of course, in practice applications make up new exception types willy-nilly, so all you really end up handling is plain old Exception, and short of just putting the message inside in a dialog box onscreen there&#8217;s not much you can do with that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245413">
				<div id="div-comment-245413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CN</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245413">
			January 17, 2005 at 8:07 am</a>		</div>

		<p>&gt; But whenever they do this, they lose information about the exception.</p>
<p>Why would you lose anything if you keep &quot;causes&quot; with the inner exception. That way, you both have the basic &quot;failure in component I know about&quot; data, but with an easy way to reach in and check out what was really going on.</p>
<p>I don&#8217;t see any way that error codes make this specific scenario easier. The possibility to subclass and wrap exceptions gives, IMHO, a flexible way to keep it simple *and* keep a way to handle specific errors in a custom way. Of course, the simplicity may lead to code that keeps it simple where a more thorough solution is really needed. I think that&#8217;s like saying that garbage collection makes resource leakage more frequent because it (sort of) eliminates memory leakage.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245743">
				<div id="div-comment-245743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/andyandyx' rel='external nofollow' class='url'>Andreas H&#228;ber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245743">
			January 17, 2005 at 4:37 pm</a>		</div>

		<p>Seems like I misunderstood what you meant with &quot;suggested action&quot;. I thought you meant the error messages you get in MS-DOS for example during file copy. &quot;Media error. (R)etry, (I)gnore, (A)bort&quot; (just an example error message, probably wrong).</p>
<p>So I agree that there ain&#8217;t anything like &quot;suggested action&quot; in the Exception class(but could be added in a derived class).</p>
<p>Guess it has been discontinued is because the action to take depends on how fault tolerant the application needs to be.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245633">
				<div id="div-comment-245633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Muck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245633">
			January 17, 2005 at 11:23 am</a>		</div>

		<p>While I agree that exceptions are no silver bullet for error checking, and in some cases make things worse, they are usually not as bad as Raymond argues.</p>
<p>As others have pointed out, some of the issues that are adressed in this blog are weakened or don&#8217;t apply at all to checked exceptions.</p>
<p>((This is not a pro-Java rant. I have used both Java and C# and must say that I like C# better. But I also like checked exceptions. Here&#8217;s why.))</p>
<p>First, checked exceptions *force* the API designer to have new error conditions derive from old ones. With &quot;Too bad .NET&#8217;s WebException and SocketException don&#8217;t derive from IOException, for example.&quot;, Raymond describes an API design flaw that would not have happened in the first place if .NET/C# had had checked exceptions.</p>
<p>There are ways to fight against checked exceptions, of course. The point is that these leave visible marks in the source. There&#8217;s the empty catch block, and there&#8217;s &quot;throws FooException&quot; in the method declaration. The first one loudly screams DANGER to every person reviewing the code. The second one is a bit sneakier; however, a function that &quot;throws IOException&quot; while not doing any IO itself must be considered suspicous as well. At the very least is the &quot;throws&quot; declaration part of the function&#8217;s public API and as such is expected to be documented. If it isn&#8217;t, you have a bug in the documentation, and probably in the code as well.</p>
<p>A third way to fight against exception checking in Java are RuntimeExceptions. I think they should have been called UncheckedExceptions, or else been given an equally derogatory name. Then it would be more clear that these are intended for checking things that are actually mild bugs in your code; NOT normal failure conditions that a (hypothetical) correct program would have to prepare for. Like accessing an array outside of its bounds. Of course, mis-use of RuntimeExceptions is also easy to spot (and fix).</p>
<p>Of course, &quot;they&quot; probably can&#8217;t add checked exceptions to C# this late, which is unfortunate but inevitable. As C# seems to combine the worst features of C like error codes (= ability to ignore easily) with those of exception handling (hard to spot code paths), I expect the most of the exception handling proponents to come from a Java background. I could be wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245783">
				<div id="div-comment-245783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Jr.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245783">
			January 17, 2005 at 7:43 pm</a>		</div>

		<p>Many Microsoft APIs have a well defined system for handling error codes: a boolean return value indicating success or failure.  If you want to return anything else from the function, you should pass in a pointer to the return value.  This system makes avoidance of return value checking a hazardous proposition since a false return value could mean your pointed-to return value is undefined.  It also makes error-checking of sequential statements rather easy by using the short-circuit AND operator.  Obtaining extended error information using GetLastError() makes it relatively easy to create a single code path for reporting errors, but the quality of the error information is limited by the number of available bits in the return code.</p>
<p>I would agree with others on this list that exceptions can provide more detailed information about errors than a single DWORD.  Java makes good use of heirarchical exception classes, but sometimes the code can become littered with catch() blocks.  In C++, on the other hand, exceptions seem so rare that most times all I see is a top-level catch(&#8230;).</p>
<p>Thinking out loud, one thing most exception systems are missing is resumable exceptions.  In both Java and C++, by the time you&#8217;ve caught the exception your automatic objects have already been collected.  Structured Exception Handling seems close, but due to the types of exceptions raised you&#8217;re limited in what you can actually do to recover.  Now, depending on what kind of severity you consider exceptions to be, resuming from any exception might be a bad thing (for C++ that is probably the case),  but a Resumable exception class that gets thrown when a user could clearly solve the problem (floppy in drive?) might be nice to have.</p>
<p>P.S. Since this is my first time posting to Mr. Chen&#8217;s &#8216;blog, I&#8217;d like to thank him for this great resource.  Your attention to detail &#8212; particularly with legacy systems &#8212; has provided quite an insight into the Win32 API.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245803">
				<div id="div-comment-245803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245803">
			January 17, 2005 at 8:14 pm</a>		</div>

		<p>Btw, this discussion wouldn&#8217;t be complete without including: <a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/automat/htm/chap11_2nlb.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/automat/htm/chap11_2nlb.asp</a><br />
<br />which is an attempt at providing a facility like the MS-DOS facility for COM objects.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245813">
				<div id="div-comment-245813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben #3</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245813">
			January 17, 2005 at 9:34 pm</a>		</div>

		<p>So what error mechanism do you recommend Raymond?  If you could design a language from scratch to return an IErrorData object when an error occurs, how would you design things to make it easier for applications to make decisions?</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245723">
				<div id="div-comment-245723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/andyandyx' rel='external nofollow' class='url'>Andreas H&#228;ber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245723">
			January 17, 2005 at 2:58 pm</a>		</div>

		<p>&quot;Then maybe catch(&#8230;) should not exist? &quot;</p>
<p>No, it is needed. But should only be used at a top-level for handling unknown exceptions not caught anywhere else. For example OutOfMemoryException or similar would be caught here. (Anders Heljsberg explains this  better here: <a target="_new" href="http://www.artima.com/intv/handcuffs2.html" rel="nofollow">http://www.artima.com/intv/handcuffs2.html</a>)</p>
<p>What can you do with that exception? Log it somewhere, like the event log, and depending on the error recovery needed(forward, backward) you should do something intelligent now. In many situations this might be to show some dialog that something has gone wrong and ask the user if it should be restarted(such as using ReportFault in Win32). Or rollback and try again, try a different algorithm, etc. But exceptions forces you to do something explicitly, which could be something stupid like &quot;catch(&#8230;){ /* do nothing */}&quot;. With error codes you might forget to check the error code of printf and a lot later see that the application crashes.</p>
<p>&quot;Too bad .NET&#8217;s WebException and SocketException don&#8217;t derive from IOException, for example.&quot;<br />
<br />I see no problem with WebException. It derives from InvalidOperationException which fits better, IMHO.</p>
<p>SocketException could benefit from multiple inheritance, since it is both a Win32Exception and an IOException. Deriving from Win32Exception discloses internal information about the class.</p>
<p>But isn&#8217;t the information you get from an exception similar to the error information you miss from the 16-bit days?<br />
<br />1. &quot;Type of error it was (error class)&quot;<br />
<br />This is the exception class.</p>
<p>2. &quot;Where the error occurred (error locus)&quot;<br />
<br />In .NET&#8217;s Exception class you find these members with this kind of information:<br />
<br />&#8211; Source<br />
<br />&#8211; StackTrace<br />
<br />&#8211; TargetSite<br />
<br />You might find more details in sub-classes.</p>
<p>3. &quot;What you probably should do in response to it (suggested action)&quot;<br />
<br />Again, from .NET&#8217;s Exception class you find this information:<br />
<br />&#8211; HelpLink<br />
<br />&#8211; Message</p>
<p>But obviously it is important that you think about where exceptions are to be catched. You don&#8217;t have that choice with error codes. And there will be exceptions you get that you didn&#8217;t think about first, but that applies to error codes as well.</p>
<p>Finally, Larry Osterman wrote in a response: &quot;The only way around this is for classes A, B, and D to catch ALL possible exceptions, reframe them in terms of their own exception hierarchy, and then rethrow. But whenever they do this, they lose information about the exception. By the time the application gets the error, all they see is the equivilant of E_FAIL.&quot;<br />
<br />Nope, that&#8217;s what InnerException. You should have all the information about the failure in the exception. Otherwise it is _bad code_ and the developer should read about exception handling. Let&#8217;s say that class A eventually gets a RemotingException. This will contain the exceptions from the other classes, maybe a WebException from class E etc. This is a lot more information then you get from E_FAIL :) What can you do with that information? Maybe decide that the webservice in E is down at the moment and try to use a different&#8230; If class A only gets something like E_FAIL it doesn&#8217;t know that it was class E which failed, could&#8217;ve been class D instead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245833">
				<div id="div-comment-245833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran Pušić</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245833">
			January 18, 2005 at 1:30 am</a>		</div>

		<p>Larry Osterman wrote:<br />
<br />&gt;You&#8217;re all missing the &quot;Fuzzy Abstraction&quot; effect.<br />
<br />&gt;<br />
<br />&gt;What happens when my application calls into class A, which calls into class B,<br />
<br />&gt;which calls into external assembly C, which calls into class D, which calls into<br />
<br />&gt;external assembly E. E throws an exception that&#8217;s 100% relevant to its situation &#8211;<br />
<br />&gt;the app doesn&#8217;t even know that E&#8217;s going to the internet (or floppy, or whatever)<br />
<br />&gt;to fetch its data.</p>
<p>Hmmm&#8230; Let me try the same, but in a slightly different way (warning: irony ahead):</p>
<p>What happens when my function calls into Win32 API A, which calls Win32 API B, which calls &#8230; you get the drill&#8230; into Win32 API E. E returns FALSE and sets last error that&#8217;s 100% relevant to its situation &#8211; but my function doesn&#8217;t even know that E&#8217;s going to the internet (or floppy, or whatever) to fetch its data.</p>
<p>Tell me that I&#8217;m wrong, but typically, D, C, B, A , if they see FALSE return from E, D, C, B, simply clean-up and return FALSE, too (they &quot;correctly ignore the exception&quot;). So, in your example, there is no practical difference between &quot;exceptions-code&quot; and &quot;error-return-code&quot;. (The same goes for Raymond&#8217;s last paragraph).</p>
<p>So, what I&#8217;m saying is this: people are complaining that not enough info is available from exception when it is caught. But, info is not available from error-return, too! Well, at least not in the code I&#8217;m working on on a daily basis, and I dare you to say that you have different situation. And methinks meknows why: because, in order to provide &quot;enough&quot; error information with either &quot;error-return-code&quot; or exceptions, one needs to write A LOT more code, and one is usually not doing this. So&#8230;</p>
<p>There is one upside to exceptions, though: there is less error checking and more &quot;meat&quot;, i.e. less noise when reading the code to find out what it does in the normal course of operation. And, this is more important! We write code to do stuff, and not to cope with errors. (It has to cope, but that is NOT the MAIN concern).</p>
<p>The downside is in Raymond&#8217;s prevoius post (let&#8217;s call this &quot;invisible exception problems&quot;). But, methinks, we need to be trained to spot these. Hehe, I know I feel pain in my stomach when I see problems like this and I have to work on something else (its probably some rare neural system disease, it does not seem that many other people suffer from this :-))</p>
<p>Also, note that that recent programming frameworks do not endorse error-return as error-handling strategy anymore? (Let&#8217;s see&#8230; What we had recently&#8230; Java, VCL, .NET&#8230; Nope, no BOOL DoStuff(params) in any of those). Mesay, resistance is futile. Learn and live with it, because they will not dissapear (at least not Java and .NET :-)).</p>
<p>(Note to C++ people: read Herb Sutter&#8217;s books. I will do it, too :-) ! I&#8217;m going to ask for money for books from my boss immediately!)</p>
<p>Goran.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245843">
				<div id="div-comment-245843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/andyandyx' rel='external nofollow' class='url'>Andreas H&#228;ber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245843">
			January 18, 2005 at 1:53 am</a>		</div>

		<p>Goran: Agreed, except that exceptions may persist this information across boundaries. An example is an exception during remoting in .NET: you get a stack trace from both sides of the call. Guess you get this with most RPC solutions available, like java&#8217;s RMI.</p>
<p>Larry: I find it better explained (together with most recent error handling mechanisms used in Windows) in Chris Brumme&#8217;s article &quot;The Exception Model&quot; here <a target="_new" href="http://blogs.msdn.com/cbrumme/archive/2003/10/01/51524.aspx" rel="nofollow">http://blogs.msdn.com/cbrumme/archive/2003/10/01/51524.aspx</a>. Obviously this is written from the opposite point of view then this blog :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245863">
				<div id="div-comment-245863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran Pušić</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245863">
			January 18, 2005 at 2:37 am</a>		</div>

		<p>Andreas H&#228;ber: </p>
<p>Yes, stack trace is very nice thing to have. We poor unmanaged C++ poeple don&#8217;t have it though (snif!). Stack trace provides excellent &quot;context-info&quot; for support people (assuming they can get hold of it from some log or whatever). Error-return code cannot provide that (well, at least, not out-of-the box; may be a theme for Raymond &#8211; please tell us how to get something similar from PDBs etc?).</p>
<p>OK, that&#8217;s it, I&#8217;m moving to .NET programming! ( I can already hear my boss: &quot;Yeah, you wish, you lazy bastard! Write these ifs for our existing unhandled error-returns first!&quot; )</p>
<p>Goran.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245873">
				<div id="div-comment-245873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245873">
			January 18, 2005 at 2:49 am</a>		</div>

		<p>&quot;This is particularly gruesome for exception-based programming. When you catch an exception, you can&#8217;t tell by looking at it whether it&#8217;s something that genuinely should crash the program (due to an internal logic error &#8211; a null reference exception, for example) or something that does not betray any error in your program but was caused externally (connection failed, file not found, sharing violation). &quot;<br />
<br />So you can&#8217;t catch std::logic_error&amp;, std::runtime_error&amp;, or whatever other subclass you want?</p>
<p>News to me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245883">
				<div id="div-comment-245883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245883">
			January 18, 2005 at 4:00 am</a>		</div>

		<p>The problem &#8211; a problem perhaps &#8211; really boils down to, someones exceptional condition is someone elses normal flow control.</p>
<p>That is, exceptions demand special syntax to catch and process. Which makes them different to normal &quot;if error then&quot; type flow control.</p>
<p>Which means that, In an exception &quot;enabled&quot; environment you will frequently end up with some muppet of a module throwing exceptions for what a caller would like to treat as a non exceptional &#8211; i.e. handled with traditional flow control &#8211; condition.</p>
<p>So you end up with two entirely different sytles of flow control interleaved.</p>
<p>For the most part, most programmers, when exposed to exceptions, get very excited and start creating all manner of new exception types due to an utter lack of solid guidelines for determining what sort of program event should be categorized as an exception, and what should not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-245903">
				<div id="div-comment-245903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dmitri Toseland</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245903">
			January 18, 2005 at 6:21 am</a>		</div>

		<p>Chris, I&#8217;d see that as the crux. After all, most applications need to use both exception-based and return-value-based error handling. There is a great lack of good writing out there about how to arrive at a good error handling policy for large applications made out of several modules. Not too surprising, since people only really started getting a good grip of how to use exceptions in C++ about 6 years ago or so.</p>
<p>But some exception-handling patterns are fairly well known by now. For example, using exceptions instead of for-loops or other standard control flow mechanisms is not a good thing. Also, &quot;catch&quot; should be rare, but &quot;finally&quot; (Java/C#) or releasing in destructors (C++) should be common. Also, it&#8217;s not necessary for every exception to have its own subclass, but it&#8217;s very useful for every exception to have a common base class. Also, the lowest-level API for something like a stack shouldn&#8217;t combine mutators and accessors (seperate operations like &quot;pop&quot; and &quot;top&quot;).</p>
<p>So it&#8217;s not like there&#8217;s nothing out there nowadays &#8211; this is largely a matter of education. There may be a fuzzy line at the boundary between where exceptions and error-returns should be used, but it&#8217;s not all that fuzzy. There are many large projects out there that have this kind of issue pretty well sorted out, and as a result have error handling that is clear, comprehensive and robust.</p>
<p>However, you need to be prepared to alter interfaces to a module as its role in a system changes. For instance, exception semantics for error handling may make sense when a module is first written. Later on, it ends up being used as a base for s wide range of clients, some of which require error-return semantics. So you then might provide a new interface which gives such semantics. No-one gets all aspects of interfaces right to start with, and error handling should be revisited as much as any other aspect of an interface.</p>
<p>Incidentally, this is why error-return is the way to go for low-level APIs that are to be used by a large number of clients in the field. Examples are DOM, sockets, Win32 and so on. Since you can build an exception layer on an error-return layer, but can&#8217;t do the reverse nearly so well, and you can&#8217;t change the interface once it&#8217;s out, it makes more sense to put out the lowest-level API with the lower-level of error handling semantics.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245983">
				<div id="div-comment-245983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245983">
			January 18, 2005 at 7:41 am</a>		</div>

		<p>DrPizza: Okay, so you caught a std::runtime_error&amp;. Now what? Should you retry up to three times? Prompt the user before retrying? Fail the operation? Abort the program?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246063">
				<div id="div-comment-246063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mdahmus.thebaba.com/blog/' rel='external nofollow' class='url'>Mike Dahmus</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246063">
			January 18, 2005 at 8:30 am</a>		</div>

		<p>Larry and others:</p>
<p>Actually, Java&#8217;s model is even better than others have let on &#8211; if you&#8217;re writing an API level class (say class D which uses class E which throws the original exception), you can write your own Exception class which stores the original exception from the library function in E. In fact, I see this quite frequently in code I use.</p>
<p>So when debugging on your end (the guy who calls D or some variant of such), you can see D&#8217;s interpretation of the exception, plus, the original exception from E if you want it, as in:</p>
<p>public class DLibraryException extends Exception<br />
<br />{<br />
<br />   private ELibraryException rootCause;</p>
<p>   public ELibraryException getRootCause()<br />
<br />   {<br />
<br />      return rootCause;<br />
<br />   }<br />
<br />}</p>
<p>you&#8217;d want a bunch more stuff in D to handle other possible sublibraries and handle its own case, but you get the picture I&#8217;m sure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-245853">
				<div id="div-comment-245853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul Spendlove</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-245853">
			January 18, 2005 at 1:57 am</a>		</div>

		<p>Q.1) Is catch(&#8230;) like catching unsealed exceptions?</p>
<p>A.1) No. When you are handling in a catch(&#8230;) clause, you have *no* information about what the exception is. You either swallow it and lose all exception information, or log the fact that &quot;some kind of exception occured&quot; and rethrow it. That&#8217;s all you can do. But when you have a typed exception, even if the true class is unknown, you can often use a virtual function or some kind of RTTI to at least get at the true type of the exception. </p>
<p>Q.2) Is catch(&#8230;) useful sometimes?</p>
<p>A.2) Yes. If you&#8217;re about to leave C++ and go into another language or environment (COM, .NET, Java, Excel, Python, etc&#8230;), exceptions can&#8217;t propogate. So you have to have a last-ditch handler that even copes with exceptions you don&#8217;t know about.</p>
<p>Q.3) Are Java checked exceptions good or bad? </p>
<p>A.3) They&#8217;re both. They&#8217;re good because they provide a guarantee of exactly which exceptions to expect. They&#8217;re bad because your exceptions then become part of the signature of your function, leading to later problems when you refactor things. I&#8217;ve seen Java developers go either way on which effect is more important.</p>
<p>Q.4) When is a good example of when exceptions are *not* good for error handling?</p>
<p>A.4) When you&#8217;re providing a low-level API for use by a range of clients, for instance a cross-platform sockets layer. Some clients will expect connection failures and retry across a range of potential servers. But then again, some clients will always throw an exception on connection failures, as they will be hosed. The best way to provide both sets of behaviour is via an API/error code approach.</p>
<p>Q.5) When is a good example of when error codes are *not* good for error handling?</p>
<p>A.5) When you&#8217;re providing a generalised set of integration routines for valuating financial derivatives. Sometimes models will fail to calibrate or converge. Providing error codes obfuscates the flow of the maths, while offering no benefit, since all one can typically do is release the resources and relay that the attempted mathematical operation was impossible.</p>
<p>Q.6) So it&#8217;s not some kind of either-or thing between exceptions and error codes? They both have their uses in different areas?</p>
<p>A.6) Yep.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246243">
				<div id="div-comment-246243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Old Fart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246243">
			January 18, 2005 at 10:41 am</a>		</div>

		<p>Exceptions are essential a COME FROM, popularised by languages like INTERCAL on the basis that they helped make any code that uses them incomprehensible.  This certainly seems to be the case in much exception-using code that I&#8217;ve looked at, where it&#8217;s often necessary to spend a great deal of time figuring out exactly what it&#8217;s going to do under different situations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246293">
				<div id="div-comment-246293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246293">
			January 18, 2005 at 11:32 am</a>		</div>

		<p>Stuart:<br />
<br />&gt; Obviously it&#8217;s a good idea if someone catching a FileNotFoundException can determine what the file is</p>
<p>Perhaps you could start with the file you just attempted to open?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246343">
				<div id="div-comment-246343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246343">
			January 18, 2005 at 11:58 am</a>		</div>

		<p>I don’t see many programs translating error-codes, unless when it is to make the error <em>less_informative</em>. Usually, the intermediate function does a clean up and relays the error-code to its caller, and that goes all the way up until the user gets that annoying E_FAIL and has no idea what the heck went wrong.</p>
<p>So I don’t see the point on saying one looses information with exceptions.</p>
<p>Of course exceptions don’t do things automagically, but it’s much easier to enrich them with useful information than with plain 32 bit codes. For instance, with exceptions you could capture the callstack to give some context, so you don’t need to translate it everywhere. And if the program can’t recover and needs to throw the error at the user, you could serialize the exception and try to match it against a knowledge base to get better information. Now try to do that with an HRESULT and what you get is something like this: <a target="_new" href="http://www.microsoft.com/windows/windowsmedia/mp10/errors.aspx#c00d11cd_0x00000000" rel="nofollow">http://www.microsoft.com/windows/windowsmedia/mp10/errors.aspx#c00d11cd_0x00000000</a></p>
<p>Are exceptions harder to program than error-code based software? Of course! But so is OO compared to procedural programming. And so is Calculus compared to basic Arithmetic. These things are more complex, but they allow for the solution of whole new classes of problems. As Robert C. Martin says, it takes complexity to manage complexity.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246423">
				<div id="div-comment-246423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Scott McCaskill</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246423">
			January 18, 2005 at 1:35 pm</a>		</div>

		<p>&quot;This is particularly gruesome for exception-based programming.&quot;</p>
<p>Huh?  How does it follow that this problem (information loss in error reporting) is somehow inherently worse for exception-based error propagation?</p>
<p>There are legitimate arguments one can make in favor of using error codes rather than exceptions for error propagation, but I don&#8217;t see how this could be one of them.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246443">
				<div id="div-comment-246443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246443">
			January 18, 2005 at 1:52 pm</a>		</div>

		<p>Win32 uses both error codes and exceptions. Error code for nonfatal errors and exceptions for fatal errors. That&#8217;s how you can tell the difference.  But if your only error model is exceptions, then you have to come up with some other way of determining whether a particular exception is fatal or nonfatal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246453">
				<div id="div-comment-246453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246453">
			January 18, 2005 at 1:54 pm</a>		</div>

		<p>Win32 throws SEH exceptions for non-fatal errors.</p>
<p>So, no, you can&#8217;t tell the difference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246463">
				<div id="div-comment-246463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246463">
			January 18, 2005 at 2:03 pm</a>		</div>

		<p>That InitializeCriticalSection raises an exception in low memory is just a design flaw. But it turns out that you can&#8217;t catch it anyway since the exception is not raised in an exception-safe manner! (The critical section object is left in a corrupted state.) So you can&#8217;t catch it and do anything meaningful. End result is the same: Don&#8217;t catch it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246053">
				<div id="div-comment-246053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul Spendlove</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246053">
			January 18, 2005 at 8:24 am</a>		</div>

		<p>Well, surely it depends on what software you&#8217;re writing. That having been said:</p>
<p>1) If you know about classes inheriting from std::runtime_error, you use dynamic_cast&lt;&gt; to check for them and handle any errors appropriately.</p>
<p>2) If it&#8217;s not that, then it&#8217;s an actual std::runtime_error, or some other subclass of it that you don&#8217;t know about. You recover back up the stack to whatever level knows enough about your process to continue with the next task, or to restart, or whatever makes sense for your particular application.</p>
<p>3) So, for instance, if you&#8217;re processing trades in a batch, you might mark this one as &quot;bad&quot;, together with the text string in the exception and any subclass information you *have* been able to get, and then you continue onwards.</p>
<p>4) Of course, your error string will generally include, generated by a standard macro everyone uses instead of &quot;throw&quot;:<br />
<br />&#8211; the file and line the exception was thrown at<br />
<br />&#8211; the name of the function (on platforms supporting __FUNCTION__)<br />
<br />&#8211; nested exceptions that may have been added at intervening levels</p>
<p>&#8230;so a quick investigation will often pinpoint exactly what happened. </p>
<p>5) This seems superior to trying to decipher a numeric return value (while praying that no intervening level of control has changed the value, of course).</p>
<p>Am I missing something?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246073">
				<div id="div-comment-246073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sab39.dev.netreach.com/' rel='external nofollow' class='url'>Stuart Ballard</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246073">
			January 18, 2005 at 8:30 am</a>		</div>

		<p>It&#8217;s certainly possible to put an &quot;enum SuggestedAction&quot; into the next version of the BCL and provide that facility in all exceptions.</p>
<p>It also would certainly be possible for the framework to have chosen a more coherent hierarchy of exceptions so that catching a base class was useful more of the time.</p>
<p>And checked exceptions certainly help; I&#8217;m still holding out hope for a ThrowsAttribute in future versions of C# so that at least checked exceptions can be *optionally* enabled.</p>
<p>But one thing that bugs me like crazy is exception types that don&#8217;t use Message for a human-readable error message. FileNotFoundException puts the filename that couldn&#8217;t be found into Message. Why??? Obviously it&#8217;s a good idea if someone catching a FileNotFoundException can determine what the file is, but it would have been easy to have a FileName property on the exception for that purpose. Using Message for that purpose makes it impossible to write code like:</p>
<p>try {<br />
<br />  DoLotsOfStuff();<br />
<br />} catch (Exception e) {<br />
<br />  DisplayMessage(&quot;An unexpected error occurred: &quot; + e.Message);<br />
<br />}</p>
<p>Message should be a (localized or localizable) *message* that the program can display to the user, otherwise it&#8217;s entirely useless. Currently the semantics of Message are essentially &quot;some arbitrary string that may be useful in figuring out what happened as long as you know what the thrower of this particular Exception subclass puts there&quot;.</p>
<p>And this kind of thing can&#8217;t be fixed without breaking backwards compatibility. Grrr!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246393">
				<div id="div-comment-246393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Timothy Fries</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246393">
			January 18, 2005 at 1:12 pm</a>		</div>

		<p>&gt; Perhaps you could start with the file you just attempted to open?</p>
<p>But you don&#8217;t *know* what file you just attempted to open when you call something seemingly unrelated to files on Class A, which calls Class B, which calls Class C, which calls Class D, which calls Class E, which may decide to use a local cache, or hit the network.</p>
<p>I&#8217;d argue though, that if exceptions are being allowed to leak out that expose inner implementation details, that&#8217;s a design failure. (After all, Class D should recognize the FileNotFoundException and *know* what the path of resolution is.)  But then we&#8217;re back to the whole checked vs. unchecked exception debate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246553">
				<div id="div-comment-246553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran Pušić</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246553">
			January 18, 2005 at 10:07 pm</a>		</div>

		<blockquote><p>
  Raymond:<br />
  <br />&gt;But if your only error model is exceptions,<br />
  <br />&gt;then you have to come up with some other way<br />
  <br />&gt;of determining whether a particular exception<br />
  <br />&gt;is fatal or nonfatal</p>
<p>Let me try this slightly differently:</p>
<p>But if your only error model is error codes, then you have to come up with some other way of determining whether a particular error code is fatal or non-fatal.</p>
<p>Why I say this: in Win32 APIs, when are SEs thrown? Frankly, I don&#8217;t know of any other reason but errors in my code.</p>
<p>(Exception to this: InitializeCriticalSection, which, as you think, has a design flaw (Thanks! I agree with this!)).</p>
<p>So, actually, it&#8217;s this: we should treat SEs as just a consequence of bugs in our code. Thus they are NOT an error-handling mechanism, but rather a bug-reporting mechanism.</p>
<p>As far as I can see, in Win32 API, error-returns are the only way to treat execution errors, so &quot;you have to come up up with some other way&#8230;&quot;. You seem to suggest that SEs somehow report &quot;fatal&quot; errors (as opposed to &quot;regular&quot; errors reportd by error returns), but all I see is that they report my bugs!</p>
<p>Or am I missing something? I.e what is the number of APIs that actually use SEs to report errors not caused by bugs?</p>
<p>Goran.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246563">
				<div id="div-comment-246563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246563">
			January 18, 2005 at 10:30 pm</a>		</div>

		<p>Correct, in Win32, exceptions are primarily a bug-reporting mechanism. That&#8217;s why you should rarely if ever try to catch them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-246933">
				<div id="div-comment-246933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246933">
			January 19, 2005 at 12:07 pm</a>		</div>

		<p>DrPizza: How do you know that the access violation didn&#8217;t come from operator&lt;&lt;? Maybe somebody closed std::cout while you weren&#8217;t looking?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246923">
				<div id="div-comment-246923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blog.ensoft-software.com/archive/2005/01/19/198.aspx' rel='external nofollow' class='url'>Ensoft Mind Dump</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246923">
			January 19, 2005 at 2:23 pm</a>		</div>

		<p>What we&#8217;re realling missing from exception handlers, user friendly relevant meta-data for suggesting ways to fix the problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-247013">
				<div id="div-comment-247013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-247013">
			January 19, 2005 at 3:38 pm</a>		</div>

		<p>Because I didn&#8217;t enable iostream exception throwing, so the faulty write will just set failbit.</p>
<p>And of course in real code I&#8217;d turn on SEH translation and catch a C++ exception instead of an SEH exception, so I could in any case tell the difference.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246903">
				<div id="div-comment-246903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-246903">
			January 19, 2005 at 10:54 am</a>		</div>

		<p>This code has no real error and no real bug, and throws a perfectly catchable SEH exception:<br />
<br />__try<br />
<br />{<br />
<br />    while(true)<br />
<br />    {<br />
<br />        int* ptr(reinterpret_cast&lt;int*&gt;(rand());<br />
<br />        std::cout &lt;&lt; *ptr &lt;&lt; std::endl;<br />
<br />    }<br />
<br />}<br />
<br />__except(GetExceptionCode() == STATUS_ACCESS_VIOLATION)<br />
<br />{<br />
<br />    std::cerr &lt;&lt; &quot;oh well.&quot; &lt;&lt; std::endl;<br />
<br />}</p>
<p>It mightn&#8217;t be particularly useful, but useful programs can do similar things (and are forced to operate in a similar way, because IsBadXxxPtr is useless).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-248913">
				<div id="div-comment-248913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joku</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-248913">
			January 24, 2005 at 5:15 pm</a>		</div>

		<p>EMD wrote: &quot;What we&#8217;re really missing from exception handlers, user friendly relevant meta-data for suggesting ways to fix the problem. &quot;</p>
<p>One possibility is that, if there&#8217;s internet connectivity on the machine running the app, when exception is thrown, the &quot;chain&quot; of exceptions thrown and the context would generate some sort of unique id, this would then be matched against some online database where the &quot;ways to fix the problem&quot; are described and could also be added. Think of something like this comment on the this blog. The initial blogging is the exception on app, and my comment is the &quot;way to fix&quot; the problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-253133">
				<div id="div-comment-253133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sandbender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-253133">
			February 4, 2005 at 3:23 pm</a>		</div>

		<p>Augh, sorry about the formatting &#8212; the quoted text was indented here and there&#8217;s no preview button.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-253123">
				<div id="div-comment-253123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://verdandi.homedns.org:8080/notes/index.php/Exception' rel='external nofollow' class='url'>Sandbender</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050117-00/?p=36683#comment-253123">
			February 4, 2005 at 3:21 pm</a>		</div>

		<p>Larry Oosterman:<br />
<br />  What happens when my application calls into class A, which calls into class B, which calls into external assembly C, which calls into class D, which calls into external assembly E.</p>
<p>  E throws an exception that&#8217;s 100% relevant to its situation &#8211; the app doesn&#8217;t even know that E&#8217;s going to the internet (or floppy, or whatever) to fetch its data.</p>
<p>  Classes A, B and D correctly ignore the exception (they do unwind correctly of course).</p>
<p>  But what does the application do with that exception? It doesn&#8217;t know why E was going to the net. It doesn&#8217;t know whether or not the circumstances that caused E to go to the net were transient or not.</p>
<p>  All it knows is that an exception&#8217;s occurred.</p>
<p>  The only way around this is for classes A, B, and D to catch ALL possible exceptions, reframe them in terms of their own exception hierarchy, and then rethrow. But whenever they do this, they lose information about the exception. By the time the application gets the error, all they see is the equivilant of E_FAIL.</p>
<p>This is actually my biggest problem with the C++ exception model.  Exceptions aren&#8217;t, by default, checked, and the C++ exception specifier mechanism is somewhat broken in that throwing a subtype instance of a declared exception isn&#8217;t allowed.  I presume one can throw a pointer to a subtype, as long as it&#8217;s thrown as a declared pointer type, but allocating exceptions on the heap seems like a potentially-leaky situation:</p>
<p>  int someFunctionThatThrows () {<br />
<br />    // &#8230;<br />
<br />    throw new SomeException ();<br />
<br />  }</p>
<p>And elsewhere:</p>
<p>  try {<br />
<br />    someFunctionThatThrows ();<br />
<br />  } catch (&#8230;) {<br />
<br />    std::cerr &lt;&lt; &quot;Unhandled exception.&quot; &lt;&lt; endl;<br />
<br />    // IMPORTANTLY: the &#8216;new SomeException&#8217; instance is not deleted!<br />
<br />  }</p>
<p>Furthermore, C++ compilers don&#8217;t, as a rule, check for unhandled declared exceptions, and there&#8217;s no rules about what exception types should be checked vs. unchecked as in Java.</p>
<p>Java&#8217;s unified exception heirarchy is a fairly elegant solution, but it goes against C++&#8217;s &quot;only pay for what you use&quot; philosophy by requiring programs that want to declare their own exceptions to inherit from, and therefore &quot;pay the cost of&quot;, the full java.lang.Exception (and Throwable) classes.</p>
<p>Raymond Chen:<br />
<br />  Chris: Oops, you forgot ServerClosedConnectionException. Too bad testing didn&#8217;t find that case either.</p>
<p>  Ben Cooke: &quot;I would expect that a caller would know what it&#8217;s direct callee is going to do.&quot;</p>
<p>  Okay, what exceptions should the caller of StreamReader.ReadLine() be expecting?</p>
<p>Whatever StreamReader.readLine () is declared or documented to throw.</p>
<p>(Note that my impression is that C# doesn&#8217;t do Java-style exception checking.  This may be wrong &#8212; should research it.)</p>
<p>Ben Cooke:<br />
<br />  Raymond,<br />
<br />  That depends on the design of the standardized exception library. For Java&#8217;s version of that function, there is one exception called IOException, which everything else can subclass. If a program is just operating on a stream with no idea what kind of stream it has, then it can catch IOException and fail gracefully, because any kind of error  while reading is probably a show-stopper. If a specific caller knows it&#8217;s really operating on a socket, it can catch SocketException and handle that case in a more special way.</p>
<p>Raymond Chen:<br />
<br />  Too bad .NET&#8217;s WebException and SocketException don&#8217;t derive from IOException, for example.</p>
<p>This is a failure of .NET&#8217;s exception heirarchy, I think, not a problem with the use of exceptions itself.  If there is a way to use a socket or some piece of a socket in exactly the same way as you&#8217;d use a stream, and it&#8217;s declared to conform to the stream interface (including IOException), then it should never throw an exception that&#8217;s not an IOException.  In Java, SocketInputStream and SocketOutputStream (which are the two streams available for each open socket) both conform to the InputStream and OutputStream interfaces, but their operations still only throw IOExceptions &#8212; even for things like ConnectionResetByPeerException.</p>
<p>Conceptually, SocketExceptions *are* a failure during I/O, so this even makes perfect sense.</p>
<p>  But even that wouldn&#8217;t fix everything. What about &quot;access denied&quot; on a registry key or service? That&#8217;s not an I/O exception but it is something a program should be prepared for.</p>
<p>The API that interfaces with the registry should declare the exceptions it could throw and the documentation for the interface should outline the circumstances for each exception.  If you have an implementation of the stream interface that talks to the registry, it should frame failures *during stream operations* in terms of IOException, and failures in methods specific to the hypothetical RegistryOutputStream class in whatever terms are appropriate.  For a general interface, the interface should throw a very general exception type which implementations can subclass.</p>
<p>And &quot;access denied&quot; in the middle of an I/O operation certainly is an I/O exception.</p>
<p>Tim Smith:<br />
<br />  In a perfect world, exceptions ARE clearly superior. However, in the real world where programmers are poorly trained and on a tight schedule, exceptions are just another form of the same nightmare.</p>
<p>The nightmare here is that we tolerate &quot;enterprise&quot; systems and consumer-deployed applications that are written by &quot;poorly trained&quot; programmers.</p>
<p>Michael Grier:<br />
<br />  Catching unsealed exception types is semantically equivalent to catch(&#8230;) since you don&#8217;t really know, over time, what&#8217;s going to derive from that exception type. </p>
<p>Augh!  No!  Exception subclassing is in no way semantically equivalent to catching an unknown exception, if the exception heirarchy has had any thought put into it.  This (obviously) ties back to Tim Smith&#8217;s comment about tight schedules and poorly-trained programmers, but a failure to use a tool well does not make the tool unusable.</p>
<p>Raymond Chen:<br />
<br />  DrPizza: Okay, so you caught a std::runtime_error&amp;. Now what? Should you retry up to three times? Prompt the user before retrying? Fail the operation? Abort the program?</p>
<p>There is a running thread in Raymond&#8217;s comments that can be expressed as &quot;any exception should have only one correct way to respond.&quot;  Certainly any one application should respond consistently to errors, but (to pick an example out of thin air) ConnectionResetByPeerException could be considered a fatal error for one application (say, a file transfer program that connects, delivers a file, and disconnects) and a recoverable error for another program (which could decide to reconnect).  A third program may not care specifically *why* the exception failed.</p>
<p>Chris Becke:<br />
<br />  The problem &#8211; a problem perhaps &#8211; really boils down to, someones exceptional condition is someone elses normal flow control. </p>
<p>That&#8217;s a remarkably apt summary of exceptions.</p>
<p>David Levine:<br />
<br />  Error handling is hard&#8230;</p>
<p>Yep.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

