<html>
<head>
<title>This code would be a lot faster if it weren't for the synchronization</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>This code would be a lot faster if it weren&#8217;t for the synchronization</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>February 26, 2013 / year-entry #55</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>56</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">This is a story from a friend of a friend, which makes it probably untrue, but I still like the story. One of my colleagues jokingly suggested that we could speed up our code by adding these lines to our project #define EnterCriticalSection(p) ((void)0) #define LeaveCriticalSection(p) ((void)0) I replied, "You think you're joking, but you're...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
This is a story from a friend of a friend,
which makes it probably untrue, but I still like the story.
</p>
<p>
One of my colleagues jokingly suggested that we could speed up
our code by adding these lines to our project
</p>
<pre>
#define EnterCriticalSection(p) ((void)0)
#define LeaveCriticalSection(p) ((void)0)
</pre>
<p>
I replied, "You think you're joking, but you're not."
</p>
<p>
According to legend, there was a project whose product
was running too slow,
so they spun off a subteam to see what architectural changes
would help them improve their performance.
The subteam returned some time later with a fork of the project
that they had "tuned".
And it was indeed the case that the performance-tuned version
ran a lot faster.
</p>
<p>
Later, the development team discovered that part of the "tuning"
involved simply deleting all the synchronization.
They didn't replace it with lock-free algorithms
or anything that clever.
They just removed all the critical sections.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (56)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1041483">
				<div id="div-comment-1041483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/steve.dower_4000_live.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>steve.dower@live.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041483">
			February 26, 2013 at 7:12 am</a>		</div>

		<p>I was at a conference recently where a researcher got up and told us that his major performance improvement was due to removing synchronisation around a result variable being accessed by multiple threads&#8230; (to be fair, the writers did not have to read the variable or write to it in sequence, but it was still too big for an implicit atomic write)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041493">
				<div id="div-comment-1041493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack B Nimble</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041493">
			February 26, 2013 at 7:20 am</a>		</div>

		<p>You can&#39;t argue with progress.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041503">
				<div id="div-comment-1041503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041503">
			February 26, 2013 at 7:23 am</a>		</div>

		<p>This is uncomfortably familiar. &nbsp;We had a team &quot;speed things up&quot; by throwing a bunch of threads into the application. &nbsp;Synchronizing everything, not so much&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041513">
				<div id="div-comment-1041513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NotARealName</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041513">
			February 26, 2013 at 7:38 am</a>		</div>

		<p>Reminds me of a dev I know who shall remain nameless. He thought he didn&#39;t have to add any synchronization to an application with ~15 threads because the target hardware was single core.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041553">
				<div id="div-comment-1041553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041553">
			February 26, 2013 at 8:26 am</a>		</div>

		<p>I thought the punchline was going to be that it was the proper thing to do. I&#39;ve seen programs with completely unnecessary threads and synchronization. Sometimes it is faster to just remove the cruft, while still ending up with a correct program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041563">
				<div id="div-comment-1041563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041563">
			February 26, 2013 at 8:35 am</a>		</div>

		<p>I thought you just go in and reduce the sleep value a little bit. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041573">
				<div id="div-comment-1041573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">12BitSlab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041573">
			February 26, 2013 at 8:37 am</a>		</div>

		<p>Given that I am old enough to have voted for Lincoln &#8212; when he ran for the Senate &#8212; I have seen my share of code over the years. &nbsp;It has been my experience that when code is not &quot;fast enough&quot;, very rarely is the CPU used by synchronization the true root cause. &nbsp;In most cases, performance problems are poorly thought out algorithms. &nbsp;</p>
<p>I am still amazed at the so-called skill level of some developers. &nbsp;Please note that it is not worse today than it was in the olden times. &nbsp;My guess is that 10% of the people who work in IT, truly understand what they are doing – today or in times past. &nbsp;The rest are charlatans.</p>
<p>As the old saying goes:</p>
<p>Those who can, do.</p>
<p>Those who can’t, teach.</p>
<p>Those who can’t teach, teach PhyEd.</p>
<p>Those who can’t teach PhysEd, work in IT for the government.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041583">
				<div id="div-comment-1041583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nksingh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041583">
			February 26, 2013 at 9:00 am</a>		</div>

		<p>A former wall-street software type told me that their high frequency trading algorithms work in a similar way. Lock-free, Unsynchronized, and running the world&#39;s financial market.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041593">
				<div id="div-comment-1041593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tain</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041593">
			February 26, 2013 at 9:01 am</a>		</div>

		<p>First rule of optimization: it doesn&#39;t need to be correct as long as it&#39;s fast.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041603">
				<div id="div-comment-1041603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/tlwest_4000_gmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>tlwest@gmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041603">
			February 26, 2013 at 9:05 am</a>		</div>

		<p>Sigh, I always hate it when the thing I care most about (stability) takes a distant second place to cost and speed in the minds of our customers. &nbsp;I mean they want stability of course, but if we&#39;re going to be slower or more costly than our competitors, that&#39;s a whole different kettle of fish. &nbsp;To stay in business, the company goal became &quot;somewhat less buggy than our competitors&quot; :-).</p>
<p>What does one say to the fact that de-emphasizing quality control saved the company?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041613">
				<div id="div-comment-1041613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jmdesp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041613">
			February 26, 2013 at 9:13 am</a>		</div>

		<p>I once had a code which synchronization routine was broken like that. On one platform, some code that was supposed to run only once at end of application was actually running everytime soon after the start, and it&#39;s biggest side-effect was actually just to disable the multi-thread synchronization call-backs.</p>
<p>It took us more than one year before we saw a case where a client actually had a problem with the synchronization disabled.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041623">
				<div id="div-comment-1041623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Riataman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041623">
			February 26, 2013 at 9:43 am</a>		</div>

		<p>That&#39;s why I always sprinkle sleep() calls all around my version 1.0. Makes easy to make speed improvements in later versions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041633">
				<div id="div-comment-1041633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frank</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041633">
			February 26, 2013 at 10:08 am</a>		</div>

		<p>While this story might be apocryphal, I did run into something similar. &nbsp;Our project was handed off to a junior dev to profile and fix the biggest offenders he would find. &nbsp;Much later he reported his results: &nbsp;His profiling had determined that the synchronization methods were very slow and accounted for most of the execution time. &nbsp;He was able to fix that by removing the synchronization methods, but sadly that appeared to uncover a host of other existing bugs he was working to fix. &nbsp;He was flabbergasted when we suggested removing the synchronization methods might be the bugs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041653">
				<div id="div-comment-1041653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041653">
			February 26, 2013 at 11:35 am</a>		</div>

		<p>Another (true) story about synchronization: For years, the Norwegian state railroads ran a &quot;distributed&quot; database across five computers in different towns, keeping track of all their carriages. In those days, communication was slow and expensive, so they didn&#39;t&#8230; Each regional database was operated independently. When carriages moved between regions, each regional database made an educated (more or less&#8230;) guess about what happened to it on the other side of the region border. Every two weeks, logs were exchanged among the regions to see which assumptions had been made, and if the guess was incorrect, a database guy went into the database to patch up, by hand, the data structures to correspond to reality!</p>
<p>Since the great majority of carriages were running according to fairly static schedules, the frequency of wrong assumptions was quite low; there wasn&#39;t much manual database patchup. But when called for, such procedures were an established part the database maintenance work. The database had a common data model, with a distribution scheme clearly defining which data was affected.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041673">
				<div id="div-comment-1041673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041673">
			February 26, 2013 at 12:56 pm</a>		</div>

		<p>I had trouble on an SQL Server once where contention during one particularly heavily executed transaction was a major performance killer.</p>
<p>I fixed the issue by taking an exclusive table lock at the beginning of the transaction and holding it until commit. Although only a single application could now actually do anything, overall performance improved.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041693">
				<div id="div-comment-1041693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaron Murray</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041693">
			February 26, 2013 at 1:17 pm</a>		</div>

		<p>jb &#8211; that Railroad story still happens all of the time, only it has a fancier name now: Eventual Consistency</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041713">
				<div id="div-comment-1041713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Somebody</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041713">
			February 26, 2013 at 1:51 pm</a>		</div>

		<p><a rel="nofollow" target="_new" href="http://i.imgur.com/3yhwL.jpg" rel="nofollow">http://i.imgur.com/3yhwL.jpg</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041723">
				<div id="div-comment-1041723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041723">
			February 26, 2013 at 1:57 pm</a>		</div>

		<p>While removing sychronization may lead to catastrophes, locking only what needs to be locked and only for as long as it needs to be locked requires skill and experience. Seemingly, some professors have scared the sh*t out of their students about the dangers of access conflicts &#8211; junior programmers more or less starting any operation by locking more or less all the data, and keeping it locked until they are done, &quot;to be on the safe side&quot;. Which certainly can reduce system throughput to a crawl.</p>
<p>My impression is that synchronization frequently is taught as an add-on, not as an integral part of neither system design nor algorithm design. Most students will establish all their fundamental concepts of programming before they are introduced to multithreaded or multiprocess designs. Some programming languages provide a far lower threshold for parallellism, with synchronization being an integral part of the language design (e.g. to start a thread, call something called a &#39;proc&#39; rather than a &#39;procedure&#39;), but few of these languages are in much use today. In most popular languages the syntactical overhead for process management and synchronization is so large that you, sort of, can understand why the lecturers don&#39;t want to overload the minds of freshman students with such complexities.</p>
<p>In the long run, we probably would have gained a lot if parallellism and synchronization was introduced from day one as a fact of life, rather than being kept back as something &quot;advanced&quot; which the students don&#39;t have to worry about when learning basic concepts. Because they ARE basic concepts!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041733">
				<div id="div-comment-1041733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JustSomeGuy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041733">
			February 26, 2013 at 2:26 pm</a>		</div>

		<p>Zeroth rule of optimisation: you can&#39;t get any less optimised than &quot;wrong&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041743">
				<div id="div-comment-1041743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jolyon.smith_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jolyon.smith@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041743">
			February 26, 2013 at 3:44 pm</a>		</div>

		<p>Reminds me of something that happened to me very early in my career. &nbsp;It was my first Windows, multi-user SQL application &#8211; way back in 1990/91. &nbsp;My previous &#8211; brief &#8211; experience of DB work was with BTrieve, so both myself and my colleague at the time, knew nothing of &quot;transactions&quot; or implicit locking. &nbsp;We had been told &quot;With RDBMS&#39;s, that&#39;s taken care of for you.&quot;</p>
<p>So when our code was deployed into a multi-user situation for the first time (pre-production beta, thankfully), we found that our app was riddled with locking issues. &nbsp;After a crash course from an RDBMS consultant who told us how things really were, we spent a couple of weeks going through the app (already quite large at this point) adding the additional Commit calls we needed at appropriate points.</p>
<p>A few weeks later, it happened that both of us were on leave at the same time, and our Project Manager said he would cover for us while we were away, dealing with any major bugs that came up etc.</p>
<p>When we got back, our inbox started filling up with reports of the app locking and hanging &#8211; the exact same problems we fixed with the transaction handling.</p>
<p>After looking at the code, we discovered that all our carefully inserted COMMIT calls had gone !!!</p>
<p>In our absence, the Project Manager had been exploring our work and seeing some calls to COMMIT that he thought were unnecessary, had decided to go through and &quot;tidy up&quot; our code by removing them all !!</p>
<p>It was this incident that also taught us the lesson that your backup strategy is only as good as your most recent restore test. &nbsp;We had no VCS at the time (we had no real excuse for that, thinking in our youthful naivety that our daily backup&#39;s were a crude but sufficient alternative).</p>
<p>I think it&#39;s fair to say we both learned a great deal on that particular job. &nbsp;:) &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041753">
				<div id="div-comment-1041753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041753">
			February 26, 2013 at 4:15 pm</a>		</div>

		<p>@j b: &quot;In the long run, we probably would have gained a lot if parallellism and synchronization was introduced from day one as a fact of life, rather than being kept back as something &quot;advanced&quot; which the students don&#39;t have to worry about when learning basic concepts. Because they ARE basic concepts!&quot;</p>
<p>There&#39;s some push toward this &#8212; introducing concurrency early. Curricula are slow to change, and that&#39;s compounded by the problem that we don&#39;t really know how to teach programming well already, let alone parallel programming. And of course universities, even if they wanted to teach some language that has parallelism worked in from the ground up, face a lot of pressures from companies and stuff to teach more immediately practical skills, and so they stick with Java and stuff like that. Even the new-fangled movement for intro courses, Python, isn&#39;t very good to teach parallelism in.</p>
<p>@JustSomeGuy: &quot;Zeroth rule of optimisation: you can&#39;t get any less optimised than &quot;wrong&quot;.&quot;</p>
<p>Reminds me of a joke I&#39;ve heard for which I forget correct attribution: Every program can be optimized, and every program has bugs. Therefore, every program can be optimized down to a single procedure which does nothing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041763">
				<div id="div-comment-1041763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041763">
			February 26, 2013 at 4:15 pm</a>		</div>

		<p>Depending on your choice of framework, you don&#39;t need to hand-roll a typedef. Just (mis)use a built-in framework class. <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/65s59wwc(v=vs.110).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/65s59wwc(v=vs.110).aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041773">
				<div id="div-comment-1041773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041773">
			February 26, 2013 at 5:11 pm</a>		</div>

		<p>Reminds me of a project that I once worked which was having performance and deadlock problems in the database. The &quot;fix&quot; was to add WITH NOLOCK to all select statements&#8230; No consideration as to whether dirty reads are acceptable or not. Following this, there were countless non-reproducible bug reports of impossible data being generated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041783">
				<div id="div-comment-1041783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henning Makholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041783">
			February 26, 2013 at 7:36 pm</a>		</div>

		<p>Sounds like a perfect example of test-driven development. Remove the synchronizations one at a time and check each time that the code still passes the test suite. If somebody wants synchronization in the code, they&#39;d better start by writing an automated test case that demonstrates the need for it!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041793">
				<div id="div-comment-1041793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041793">
			February 26, 2013 at 9:44 pm</a>		</div>

		<p>@Henning: if there&#39;s one thing that&#39;s very hard to catch with testing, it&#39;s synchronization bugs. What you&#39;re essentially arguing is that we care more about the performance of the code than about getting it correct, because this errs on the side of not having synchronization.</p>
<p>At the very least you&#39;d need something more advanced than your regular testing frameworks, because a undesirable concurrent execution may be possible to demonstrate in theory, but impossible in practice on the hardware you happen to be using. You&#39;d need to instrument the code just to make it appear in the first place &#8212; yet &quot;it works on this machine&quot; is not a valid argument for leaving out synchronization.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041803">
				<div id="div-comment-1041803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Smit-Tay</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041803">
			February 27, 2013 at 12:51 am</a>		</div>

		<p>What&#39;s not indicated in the story is whether the synchronization was needed in the first place. &nbsp;Maybe that really was a valid solution, we, the readers of this story, have no way to know.</p>
<p>One thing that is certain is that most developers use multi-threading far too eagerly. &nbsp;In my experience, over 25 years worth, is that 99% of all applications written don&#39;t require any more than 2 threads. &nbsp;One for the UI, and one to do work. &nbsp;If your app doesn&#39;t need a UI, it probably doesn&#39;t need more than a single thread either.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041823">
				<div id="div-comment-1041823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041823">
			February 27, 2013 at 2:37 am</a>		</div>

		<p>Well of course the obvious example of this is the single-processor version of the kernel. I was particularly gratified when I added a second processor to a PC and Windows proudly proclaimed that it had found new hardware and upgraded me to the multiprocessor kernel.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041833">
				<div id="div-comment-1041833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny Moules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041833">
			February 27, 2013 at 3:35 am</a>		</div>

		<p>@Henning: Good luck making bulletproof deterministic tests for all possible race conditions. Very excellent as your particular hammer may be, this isn&#39;t the nail you&#39;re looking for.</p>
<p>@Neil: Um&#8230; multitasking (and the problems it creates) occurs regardless of how many processors you have on Windows.</p>
<p>@JustSomeGuy Stealing that quote!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041843">
				<div id="div-comment-1041843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041843">
			February 27, 2013 at 3:51 am</a>		</div>

		<p>Therac-25 used the &quot;no locks&quot; solution. &nbsp;On a radiation therapy machine used by hospitals. &nbsp;The results were what you&#39;d expect &#8211; fatal. &nbsp;See <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Therac-25" rel="nofollow">en.wikipedia.org/&#8230;/Therac-25</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041853">
				<div id="div-comment-1041853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041853">
			February 27, 2013 at 3:57 am</a>		</div>

		<p>@Anon. The therac 25 problem was due to bugs, not due to someone trying to optimise the program. Duh.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041863">
				<div id="div-comment-1041863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041863">
			February 27, 2013 at 4:55 am</a>		</div>

		<p>[Neglecting the hardware reductions due to cost or whatever optimisation] Sorry &#8211; didn&#39;t consider that at first.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041873">
				<div id="div-comment-1041873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041873">
			February 27, 2013 at 5:07 am</a>		</div>

		<p>we did that in one of our apps, stub out all the lockincrement/decrement in a IUnknown implementation every object used. but we didn&#39;t really need it, not for every object anyway. it was just one of those thing where a dev wants to write the most future looking code evar. &nbsp;however, the actual problem was IMHO that we shouldn&#39;t have been calling addref and release so much that is would come up in a v-tune as the top bottleneck in a perfermonance critical scenario. &nbsp;the whole approach was probably wrong</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041893">
				<div id="div-comment-1041893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041893">
			February 27, 2013 at 5:49 am</a>		</div>

		<p>Danny Moules: When the kernel is running on just a single processor, nothing else can be running simultaneously, so it doesn&#39;t need locks. Of course it can still be interrupted by hardware, so it just has to disable interrupts when it enters critical sections.</p>
<p>In other words, the uniprocessor kernel just defines EnterCriticalSection to be the CLI instruction and LeaveCriticalSection to be STI. This makes it faster and smaller.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1041903">
				<div id="div-comment-1041903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041903">
			February 27, 2013 at 6:47 am</a>		</div>

		<p>@Gabe:</p>
<p>This is incorrect.</p>
<p>The uniprocessor kernel (which doesn&#39;t exist anymore, by the way), has the same implementation of Enter/LeaveCriticalSection. Its implementation of spinlocks, however, only does set IRQL, and doesn&#39;t bother with setting/clearing the spinlock variable. In the big picture, this &quot;optimization&quot; is not worth it, because an interlocked operation on single-proc Pentium and later is as fast as non-locked, and only has a trivial cost.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041963">
				<div id="div-comment-1041963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041963">
			February 27, 2013 at 9:35 am</a>		</div>

		<p>&gt; Thread A can be interrupted by timer expirations after its read but before its write. &nbsp;In the meantime, while Thread A is suspended, Thread B can read the (old) value (that has not been incremented by Thread A), increment it, and write it back. &nbsp;Then Thread A is dispatched again, when it writes its incremented value back from its own copy. &nbsp;</p>
<p>How did you split the assembly instruction inc [address], which is what my compiler generates for increment?</p>
<div class="post">[<em>Your analysis may be true for a single instruction on a uniprocessor system, but in the general case, the operations are multi-instruction. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1041983">
				<div id="div-comment-1041983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041983">
			February 27, 2013 at 10:39 am</a>		</div>

		<p>The first 32-bit CPU I ever programmed (well.. I had been programming 36 bit ones earlier) had a user level instruction SOLO, disabling all interrupts for up wto 255 clock cycles, or until a TUTTI instruction was executed. If no TUTTI was execeuted, a non-maskable exception was raised in the running process on the 256th clock cycle. Each of these instructions took one clock cycle to execute.</p>
<p>You can do quite a lot in 255 clock cycles (most non-FP instructions were single cycle on this CPU). If the entire update couldn&#39;t be completed in that time, you could certainly test and set a semaphore (even maintain a queue for it). Not involving any sort of privilege change and no MMS related changes, just two single-cycle instructions, made a very low-cost (in terms of CPU load) synchronization mechanism. It is a pity that instructions like SOLO / TUTTI are not available on every machine architecture today.</p>
<p>(For the curious ones: I am talking about a machine called the ND-500, introduced to the market in 1980. Obviously, I/O was handled by DMA and interrupt handlers which could buffer input for 256 cycles or more; low latency interruptw were provided through programmable controllers, so no system component were dependent on the CPU giving them attention in less than 256 clock cycles.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041993">
				<div id="div-comment-1041993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">&lt;a href=&quot;http://bing.com&quot;&gt;BingItOn&lt;/a&gt;</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041993">
			February 27, 2013 at 10:47 am</a>		</div>

		<p>Little things we ignore in life turn out to be most important. Same way your blog post is talking about &quot;Presence of Synchronization&quot; being the culprit but in reality its &quot;Bad Algorithm&quot; that&#39;s causing the problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042063">
				<div id="div-comment-1042063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dsn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042063">
			February 27, 2013 at 1:52 pm</a>		</div>

		<p>@joshua &#8211; on a multiprocessor, the inc instruction turns into the uops</p>
<p>load [adddress]</p>
<p>inc</p>
<p>store [address]</p>
<p>which can be interleaved. &nbsp;To test, just run two threads which increment n times simultaneously. &nbsp;when I did, I didn&#39;t get 2n in the counter at the end.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1042073">
				<div id="div-comment-1042073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042073">
			February 27, 2013 at 2:37 pm</a>		</div>

		<p>Reminds me of the time I told the client that their application was not, in fact, running on all 5 (very expensive) servers, it was running on just 1, and it could not work on more than 1 server due to complete absence of synchronisation between servers. It took a while before they believed me. Exhibit A: Task Manager on servers 2-&gt;5.</p>
<p>&quot;But it used to work on all of them.&quot; Not possible. &quot;But&#8230;&quot;. Not possible. &quot;But&#8230;&quot;. Not. Possible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042103">
				<div id="div-comment-1042103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042103">
			February 27, 2013 at 4:41 pm</a>		</div>

		<p>@dsn: Oh right I forgot it needs to be lock inc [address] (which it is when I need to force it to be safe).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1041953">
				<div id="div-comment-1041953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1041953">
			February 27, 2013 at 9:22 am</a>		</div>

		<p>@Gabe: &nbsp;you are completely wrong. &nbsp;Consider one thread reading a value from storage, incrementing it, and writing it back, while another thread reads the same value, increments it, and writes it back. &nbsp;On a single-processor system. &nbsp;Disabling all interrupts is not always possible or desirable; should interrupts from the keyboard, or I/O completion, or timer expirations, be halted while a thread is running? &nbsp;What about runaway threads?</p>
<p>Thread A can be interrupted by timer expirations after its read but before its write. &nbsp;In the meantime, while Thread A is suspended, Thread B can read the (old) value (that has not been incremented by Thread A), increment it, and write it back. &nbsp;Then Thread A is dispatched again, when it writes its incremented value back from its own copy. &nbsp;</p>
<p>Thread B&#39;s increment has been LOST; its incremented value was overwritten by Thread A.</p>
<p>You need to realize that single-processor systems have multiple things going on at once, and you shouldn&#39;t (or can&#39;t) disable all interrupts in user code. &nbsp;Critical sections are designed to prevent this. &nbsp;Threads A and B *each* need to obtain a lock of some kind before reading the value, and release that lock AFTER each has written the value back.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042083">
				<div id="div-comment-1042083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042083">
			February 27, 2013 at 3:36 pm</a>		</div>

		<p>steveg,</p>
<p>Do you know for sure that the application was not differently structured in an earlier version?</p>
<p>After all, some (maybe most) applications have some parts that are completely independent of other parts, so they don&#39;t NEED any synchronzation. Old *nix programmers, from before *nix got decent threading mechanisms (well, do they have decent ones, even today?) were often good at splitting up their applications into *nix processes that didn&#39;t share working data structures. Synchronization had to use the file system, which required far more resources than simple critical regions or semaphores. You completed your part of the work before you wrote it to a file/pipe to another process, and very often, shared data had one producer, one consumer (pipe fashion).</p>
<p>If the application had old *nix origins. but a more recent refactoring gathered five *nix-style processes into one process with five threads, then it could be that the old version could utilize five CPUs (assuming that there were e.g. pipe communication between them) while the new version can not. </p>
<p>In the old days of the VAX 730 (known as &quot;Turtle VAX&quot;) switching between VMS processes could take up to 100 ms (yes, one tenth of a second!). A friend of mine who worked on a DBMS on a Turtle VAX significantly speeded up the system performance by merging three VMS processes into two, to avoid those process switches. If your application were run &lt;i&gt;on a single server&lt;/i&gt;, redesigning it from five processes to five threads might have speeded it ut significantly, but killing the opportunity to distribute it on five servers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-zlynx even thread-even depth-1" id="comment-1042113">
				<div id="div-comment-1042113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Zan+Lynx%27' rel='external nofollow' class='url'>Zan Lynx'</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042113">
			February 27, 2013 at 4:43 pm</a>		</div>

		<p>j b,</p>
<p>&quot;Old *nix programmers, from before *nix got decent threading mechanisms (well, do they have decent ones, even today?)&quot;</p>
<p>Yes. Some bits are much faster than WNT. I am always annoyed by how slow an inter-process Mutex is. A shared pthread_mutex on Linux is about 5x faster and doesn&#39;t usually take a kernel syscall hit. Not to mention the WNT lack of condition variables (in XP which everyone must still support, sigh) or inter-process read-write locks.</p>
<div class="post">[<em>Actually, inter-process read/write locks do exist. They&#39;re called file region locks. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042163">
				<div id="div-comment-1042163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cavaler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042163">
			February 28, 2013 at 2:58 am</a>		</div>

		<p>As horrible as it may seem, this is indeed a valid solution in at least one case I encountered myself:</p>
<p>Developing a single-threaded application with MS Visual Studio 2005 or later, which don&#39;t have single-threaded runtime at all now, only multi-threaded. And I did not need any std::_Lockit really.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-1042193">
				<div id="div-comment-1042193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042193">
			February 28, 2013 at 7:08 am</a>		</div>

		<p>@JM, @Danny Moules regarding Henning Makholm&#39;s comment:</p>
<p>I&#39;m not in Henning&#39;s head, but in his shoes I&#39;d answer with the &quot;That&#39;s the Joke&quot; reaction image.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1042213">
				<div id="div-comment-1042213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042213">
			February 28, 2013 at 8:08 am</a>		</div>

		<p>@ZanLynx:</p>
<blockquote><p>
  I am always annoyed by how slow an inter-process Mutex is. A shared pthread_mutex on Linux is about 5x faster and doesn&#39;t usually take a kernel syscall hit.
</p></blockquote>
<p>How do you implement inter-process sync object without having to handle it in kernel mode? Shared memory?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1042223">
				<div id="div-comment-1042223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042223">
			February 28, 2013 at 8:12 am</a>		</div>

		<p>@ j b:</p>
<p>Unfortunately, SOLO/TUTTI would only work for single processor systems. You can&#39;t have protection by just using some glorified CLI/STI.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042143">
				<div id="div-comment-1042143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042143">
			February 28, 2013 at 12:36 am</a>		</div>

		<p>Zan Lynx&#39;,</p>
<p>There is a lot more to &quot;decency&quot; than mere execution speeed &#8211; such as syntactical cleanliness and simplicity, consistency with other architectural elements, protection against incorrect use (/non-use) etc. And there is more to threading than just semaphores.</p>
<p>I got my parallellism education in a time when mutexes where not synchronizing mechanisms, but building blocks (at a level comparable to assembly coding) for _creating_ synchronizing mechanisms: Critical regions, monitors, rendevouzes, buffers. This was in the age of Brinch-Hansen and Concurrent Pascal, and the only *nix provision for synchronization was to use the (non)existence of a file as a &quot;semaphore&quot;. A few years later, semaphores did creep into *nix, and those of us who had come to know all sorts of high-level mechanisms expected *nix development to progress to mechanisms we had considered basic since around 1980. It never came; *nix people simply replaced the binary file &quot;semaphore&quot; with an in-memory binary semaphore, and never established regions and monitors as the standard way of doing things. Sure, you can build them yourself from the primitives, but that is sort of like building your own OO mechanisms from traditional c structs&#8230;</p>
<p>Furthermore: Being faster than WNT doesn&#39;t make you the king of the world, especially when we are talking about primitives at the very lowest level. (You would never argue that the speed of one specific machine instruction makes one machine faster, or &quot;more decent&quot;, than another.) I am quite sure using the mechanisms I mentioned in an earlier posting (about 8 entries before this one), that a machine with the SOLO and TUTTI instructions could implement mutexes a magnitude faster than the Linux pthread_mutex. If your programming system had decent(!) sync mechanisms, such a the CHILL language, the compiler could generate the code for protecting its critical regions or monitors in inline, user space code. But as long as you rely on the application programmer to make the asocciation between a semaphore and what it protects, you cannot easily do much optimization, such as not setting the actual lock until immediately before variables are accessed and releasing them immediately after the last access. (Certainly, the use of, say SOLO/TUTTI instructions, is in principle independent of, say compiler supported regions/monitors, but combining the two could give you synchronization at a very low cost.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-1042333">
				<div id="div-comment-1042333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042333">
			February 28, 2013 at 10:10 am</a>		</div>

		<p>alegr1: Jeff Richter&#39;s &#39;Programming Server-Side Applications for Windows 2000&#39; book has sample code implementing a shared-memory critical section object. He calls it an &#39;optex&#39;. I&#39;m using it to protect another shared-memory structure for old-style performance counters (also borrowed from that book).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042353">
				<div id="div-comment-1042353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042353">
			February 28, 2013 at 10:17 am</a>		</div>

		<p>alegr1,</p>
<p>Certainly true, but for thread synchronization it was very valuable. Even if they do not solve all sorts of problems, that shouldn&#39;t be a reason for reject in cases where they might have an essential effect.</p>
<p>These instructions could still be valuable as building blocks for making a distributed sync mechanism. But once you go into distributed synchronization requiring message exchanges, you raise the minimal cost by a few orders of magnitude anyway.</p>
<p>Could any mechanism based on atomic operations (i.e. various variants of turning off the interrupt system) by themselves serve in a distributed system? This also includes the case when the kernel (or whatever handles the sync mechanism) runs at a higher hardware priority level: While it prevents local processes from interfering with the semaphore update, it will not be communicated to other CPUs.</p>
<p>As long as the processors have physically common RAM, the CPU and memory controller could offer some uncached and memory locked read&amp;set or increment instruction, where one CPU may ask the memory controller to delay accesses from other CPUs until the composite access is completed. That wouldn&#39;t help you if the CPUs don&#39;t have common memory. SOLO might also set similar flags to the memory controller. (In fact, you could have up to four ND-500 CPUs working on the same RAM, but I never checked out the effect of the SOLO instruction &#8211; I never worked on a multi-CPU system in those days.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1042453">
				<div id="div-comment-1042453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042453">
			February 28, 2013 at 2:19 pm</a>		</div>

		<p>@Mike, ZanLynx:</p>
<p>With cooperating processes, one can come with very elaborate shared memory synchronization, including a shared memory equivalent of CRITICAL_SECTION.</p>
<p>But a KMUTANT solves the generic problem of synchronization for different processes, even across the security boundary, which is not possible with shared memory. It also solves the priority inversion problem, which CRITICAL_SECTION and equivalents don&#39;t do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042483">
				<div id="div-comment-1042483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042483">
			February 28, 2013 at 3:32 pm</a>		</div>

		<p>As an alternative example, if two threads each need to read a value from storage, increment it by four or eight, and write it back&#8230; most machine languages don&#39;t have a single instruction primitive for that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1042553">
				<div id="div-comment-1042553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042553">
			February 28, 2013 at 6:52 pm</a>		</div>

		<p>@j b: yes, the application never worked properly &#8212; it had been in production for a year when the old vendor lost the contract to the company I worked for. I discovered it didn&#39;t/couldn&#39;t work in Test, so I went looking at Production to find out what was going on, checked the logs and confirmed servers 2-5 had been sitting idle for a year. FWIW it was Windows not Unix.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1042563">
				<div id="div-comment-1042563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Totzke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042563">
			February 28, 2013 at 6:58 pm</a>		</div>

		<p>@Anon &#8211; thanks for the reminder of the Therac-25 story. &nbsp;I remember reading the full account of this by Nancy Leveson some time ago. &nbsp;It is a very well written article and a fascinating story. &nbsp;I would recommend giving it a read. &nbsp;The bullet-point findings don&#39;t do the story justice. &nbsp;IIRC, what seem to be obvious bugs to us now (irrespective of the lack of hardware lockouts) were in fact quite subtle and even examination of the code seemed to confirm that what was happening was &quot;impossible&quot;. &nbsp;</p>
<p>Of course, I myself have created many &quot;impossible&quot; bugs in my career; sometimes even before lunch on a good day. &nbsp;Fortunately, the only biological damage was to my ego. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1042983">
				<div id="div-comment-1042983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042983">
			March 1, 2013 at 5:13 pm</a>		</div>

		<blockquote><p>
  As an alternative example, if two threads each need to read a value from storage, increment it by four or eight, and write it back&#8230; most machine languages don&#39;t have a single instruction primitive for that.
</p></blockquote>
<p>This is where InterlockedCompareExchange helps a lot.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1042993">
				<div id="div-comment-1042993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130226-00/?p=5133#comment-1042993">
			March 1, 2013 at 5:14 pm</a>		</div>

		<blockquote><p>
  increment it by four or eight, and write it back
</p></blockquote>
<p>In IA32, XADD (InterlockedExchangeAdd) would do.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

