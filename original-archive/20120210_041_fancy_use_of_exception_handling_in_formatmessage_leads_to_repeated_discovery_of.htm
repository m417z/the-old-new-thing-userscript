<html>
<head>
<title>Fancy use of exception handling in FormatMessage leads to repeated "discovery" of security flaw</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Fancy use of exception handling in FormatMessage leads to repeated &quot;discovery&quot; of security flaw</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>February 10, 2012 / year-entry #42</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>24</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Every so often, somebody "discovers" an alleged security vulnerability in the Format­Message function. You can try it yourself: #include <windows.h> #include <stdio.h> char buf[2048]; char extralong[128*1024]; int __cdecl main(int argc, char **argv) { memset(extralong, 'x', 128 * 1024 - 1); DWORD_PTR args[] = { (DWORD_PTR)extralong }; FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, "%1", 0, 0, buf, 2048, (va_list*)args);...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Every so often, somebody "discovers" an alleged
security vulnerability in the <code>Format&shy;Message</code> function.
You can try it yourself:
</p>
<pre>
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

char buf[2048];
char extralong[128*1024];

int __cdecl main(int argc, char **argv)
{
 memset(extralong, 'x', 128 * 1024 - 1);
 DWORD_PTR args[] = { (DWORD_PTR)extralong };
 FormatMessage(FORMAT_MESSAGE_FROM_STRING |
               FORMAT_MESSAGE_ARGUMENT_ARRAY, "%1", 0, 0,
               buf, 2048, (va_list*)args);
 return 0;
} 
</pre>
<p>
If you run this program under the debugger and you tell it to break
on all exceptions,
then you will find that it breaks on an access violation
trying to write to an invalid address.
</p>
<pre>
eax=00060078 ebx=fffe0001 ecx=0006fa34 edx=00781000 esi=0006fa08 edi=01004330
eip=77f5b279 esp=0006f5ac ebp=0006fa1c iopl=0         nv up ei pl nz na pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00010203
ntdll!fputwc+0x14:
77f5b279 668902           mov     [edx],ax              ds:0023:00781000=????
</pre>
<p>
Did you just find a buffer overflow security vulnerability?
</p>
<p>
The <code>FormatMessage</code> function was part of the original
Win32 interface,
back in the days when you had lots of address space
(two whole <i>gigabytes</i>) but not a lot of RAM (12 megabytes,
or 16 if you were running Server).
The implementation of <code>FormatMessage</code> reflects
this historical reality by
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2003/10/10/55256.aspx">
working hard to conserve RAM</a>
but not worrying too much about conserving address space.
And it takes advantage of this fancy new <i>structured
exception handling</i> feature.
</p>
<p>
The <code>FormatMessage</code> uses the
<i>reserve a bunch of address space but commit pages only as they
are necessary</i> pattern, illustrated in MSDN
under the topic
<a HREF="http://msdn.microsoft.com/library/aa366803.aspx">
Reserving and Committing Memory</a>.
Except that the sample code on that page contains serious errors.
For example, if the sample code encounters an exception other than
<code>STATUS_<wbr>ACCESS_<wbr>VIOLATION</code>, it still "handles"
it by doing nothing and returning
<code>EXCEPTION_<wbr>EXECUTE_<wbr>HANDLER</code>.
It fails to handle random access to the buffer
or access violations caused by DEP.
Though in the very specific sample, it mostly works since the
protected region does only one thing, so there aren't many
opportunities for the other types of exceptions to occur.
(Though if you're really unlucky, you might get an
<code>STATUS_<wbr>IN_<wbr>PAGE_<wbr>ERROR</code>.)
But enough complaining about that sample.
</p>
<p>
The <code>FormatMessage</code>
function reserves
64<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/11/9725386.aspx">KB</a>
of address space, commits the first page,
and then calls an internal helper function whose job it is
to generate the output,
passing the start of the 64KB block of address space as the
starting address and telling it to give up when it reaches 64KB.
Something like this:
</p>
<pre>
struct DEMANDBUFFER
{
  void *Base;
  SIZE_T Length;
};

int
PageFaultExceptionFilter(DEMANDBUFFER *Buffer,
                         EXCEPTION_RECORD ExceptionRecord)
{
  int Result;

  <a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2012/02/09/10265660.aspx">DWORD dwLastError = GetLastError();</a>

  // The only exception we handle is a continuable read/write
  // access violation inside our demand-commit buffer.
  if (ExceptionRecord-&gt;ExceptionFlags &amp; EXCEPTION_NONCONTINUABLE)
    Result = EXCEPTION_CONTINUE_SEARCH;

  else if (ExceptionRecord-&gt;ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
    Result = EXCEPTION_CONTINUE_SEARCH;

  else if (ExceptionRecord-&gt;NumberParameters &lt; 2)
    Result = EXCEPTION_CONTINUE_SEARCH;

  else if (ExceptionRecord-&gt;ExceptionInformation[0] &amp;
      ~(EXCEPTION_READ_FAULT | EXCEPTION_WRITE_FAULT))
    Result = EXCEPTION_CONTINUE_SEARCH;

  else if (ExceptionRecord-&gt;ExceptionInformation[1] -
      (ULONG_PTR)Buffer-&gt;Base &gt;= Buffer-&gt;Length)
    Result = EXCEPTION_CONTINUE_SEARCH;

  else {
    // If the memory is already committed, then committing memory won't help!
    // (The problem is something like writing to a read-only page.)
    void *ExceptionAddress = (void*)ExceptionInformation[1];
    MEMORY_BASIC_INFORMATION Information;
    if (VirtualQuery(ExceptionAddress, &amp;Information,
                     sizeof(Information)) != sizeof(Information))
      Result = EXCEPTION_CONTINUE_SEARCH;

    else if (Information.State != MEM_RESERVE)
      Result = EXCEPTION_CONTINUE_SEARCH;

    // Okay, handle the exception by committing the page.
    // Exercise: What happens if the faulting memory access
    // spans two pages?
    else if (!VirtualAlloc(ExceptionAddress, 1, MEM_COMMIT, PAGE_READWRITE))
      Result = EXCEPTION_CONTINUE_SEARCH;

    // We successfully committed the memory - retry the operation
    else Result = EXCEPTION_CONTINUE_EXECUTION;
  }

  <a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2011/04/29/10159322.aspx">RestoreLastError</a>(dwLastError);
  return Result;
}

DWORD FormatMessage(...)
{
  DWORD Result = 0;
  DWORD Error;
  DEMANDBUFFER Buffer;
  Error = InitializeDemandBuffer(&amp;Buffer, FORMATMESSAGE_MAXIMUM_OUTPUT);
  if (Error == ERROR_SUCCESS) {
    __try {
     Error = FormatMessageIntoBuffer(&amp;Result,
                                     Buffer.Base, Buffer.Length, ...);
    } __except (PageFaultExceptionFilter(&amp;Buffer,
                   GetExceptionInformation()-&gt;ExceptionRecord)) {
     // never reached - we never handle the exception
    }
  }
  if (Error == ERROR_SUCCESS) {
   Error = CopyResultsOutOfBuffer(...);
  }
  DeleteDemandBuffer(&amp;Buffer);
  if (Result == 0) {
    SetLastError(Error);
  }
  return Result;
}
</pre>
<p>
The <code>FormatMessageIntoBuffer</code> function takes an output
buffer and a buffer size, and it writes the result to the output buffer,
stopping when the buffer is full.
The <code>DEMANDBUFFER</code> structure and the
<code>PageFaultExceptionHandler</code>
work together to create the output buffer on demand
as the <code>FormatMessageIntoBuffer</code> function does its work.
</p>
<p>
To make discussion easier, let's say that the
<code>FormatMessage</code> function merely took printf-style arguments
and supported only
<code>FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER</code>.
</p>
<pre>
DWORD FormatMessageFromStringPrintfAllocateBuffer(
    PWSTR *ResultBuffer,
    PCWSTR FormatString,
    ...)
{
  DWORD Result = 0;
  DWORD ResultString = NULL;
  DWORD Error;
  DEMANDBUFFER Buffer;
  va_list ap;
  va_start(ap, FormatString);
  Error = InitializeDemandBuffer(&amp;Buffer, FORMATMESSAGE_MAXIMUM_OUTPUT);
  if (Error == ERROR_SUCCESS) {
    __try {
     SIZE_T MaxChars = Buffer.Length / sizeof(WCHAR);
     int i = _vsnwprintf((WCHAR*)Buffer.Base, MaxChars,
                         FormatString, ap);
     if (i &lt; 0 || i &gt;= MaxChars) Error = ERROR_MORE_DATA;
     else Result = i;
    } __except (PageFaultExceptionFilter(&amp;Buffer,
                   GetExceptionInformation()-&gt;ExceptionRecord)) {
     // never reached - we never handle the exception
    }
  }
  if (Error == ERROR_SUCCESS) {
   // Exercise: Why don't we need to worry about integer overflow?
   DWORD BytesNeeded = sizeof(WCHAR) * (Result + 1);
   ResultString = (PWSTR)LocalAlloc(LMEM_FIXED, BytesNeeded);
   if (ResultBuffer) {
    // Exercise: Why CopyMemory and not StringCchCopy?
    CopyMemory(ResultString, Buffer.Base, BytesNeeded);
   } else Error = ERROR_NOT_ENOUGH_MEMORY;
  }
  DeleteDemandBuffer(&amp;Buffer);
  if (Result == 0) {
    SetLastError(Error);
  }
  *ResultBuffer = ResultString;
  va_end(ap);
  return Result;
}
</pre>
<p>
Let's run this function in our head to see what happens if
somebody triggers the alleged buffer overflow by calling
</p>
<pre>
PWSTR ResultString;
DWORD Result = FormatMessageFromStringPrintfAllocateBuffer(
                   &amp;ResultString, L"%s", VeryLongString);
</pre>
<p>
After setting up the demand buffer, we call
<code>_vsnwprintf</code>
to format the output into the demand buffer,
but telling it not to go past the buffer's total length.
The <code>_vsnwprintf</code> function parses the format
string and sees that it needs to copy <code>VeryLongString</code>
to the output buffer.
Let's say that the <code>DEMANDBUFFER</code> was allocated at
address <code>0x00780000</code> on a system with 4KB pages.
At the start of the copy, the address space looks like this:
</p>
<table STYLE="border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=16 ALIGN=center STYLE="border-top: solid .75pt black; border-left: solid .75pt black; border-right: solid .75pt black">64KB</td>
<td></td>
</tr>
<tr>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>0000</code></font><br>C</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>1000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>2000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>3000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>4000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>5000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>6000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>7000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>8000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>9000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>A000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>B000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>C000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>D000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>E000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>F000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0079<br>0000</code></font><br>X</td>
</tr>
<tr>
<td COLSPAN=16 ALIGN=left>^ output pointer</td>
</tr>
</table>
<p>
"C" stands for a committed page, "R" stands for a reserved page,
and "X" stands for a page that, if accessed, would be a buffer overflow.
We start copying <code>VeryLongString</code> into the output buffer.
After copying 2048 characters, we fill the first committed page;
copying character 2049 raises a page fault exception.
</p>
<table STYLE="border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=16 ALIGN=center STYLE="border-top: solid .75pt black; border-left: solid .75pt black; border-right: solid .75pt black">64KB</td>
<td></td>
</tr>
<tr>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>0000</code></font><br>C</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>1000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>2000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>3000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>4000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>5000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>6000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>7000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>8000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>9000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>A000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>B000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>C000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>D000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>E000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>F000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0079<br>0000</code></font><br>X</td>
</tr>
<tr>
<td></td>
<td COLSPAN=15 ALIGN=left>^ output pointer</td>
</tr>
</table>
<p>
This is the point at which over-eager people observe the first-chance
exception, capture the register dump above,
and begin writing up their security vulnerability report,
cackling with glee.
(Observe that in the register dump,
the address we are writing to is of the form <code>0x####1000</code>.)
</p>
<p>
As with all first-chance exceptions,
it goes down the exception chain.
Our custom <code>PageFaultExceptionFilter</code> recognizes this
as an access violation in a page that it is responsible for,
and the page hasn't yet been committed, so it commits the page as
read/write and resumes execution.
</p>
<table STYLE="border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=16 ALIGN=center STYLE="border-top: solid .75pt black; border-left: solid .75pt black; border-right: solid .75pt black">64KB</td>
<td></td>
</tr>
<tr>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>0000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>1000</code></font><br>C</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>2000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>3000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>4000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>5000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>6000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>7000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>8000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>9000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>A000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>B000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>C000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>D000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>E000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>F000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0079<br>0000</code></font><br>X</td>
</tr>
<tr>
<td></td>
<td COLSPAN=15 ALIGN=left>^ output pointer</td>
</tr>
</table>
<p>
Copying character 2049 now succeeds, as does the copying of characters
2050 through 4096.
When we hit character 4097, the cycle repeats:
</p>
<table STYLE="border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=16 ALIGN=center STYLE="border-top: solid .75pt black; border-left: solid .75pt black; border-right: solid .75pt black">64KB</td>
<td></td>
</tr>
<tr>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>0000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>1000</code></font><br>C</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>2000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>3000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>4000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>5000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>6000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>7000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>8000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>9000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>A000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>B000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>C000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>D000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>E000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>F000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0079<br>0000</code></font><br>X</td>
</tr>
<tr>
<td COLSPAN=2></td>
<td COLSPAN=14 ALIGN=left>^ output pointer</td>
</tr>
</table>
<p>
Again, the first-chance exception is sent down the chain,
our
<code>PageFaultExceptionFilter</code>
recognizes this as a page it is responsible for,
and it commits the page and resumes execution.
</p>
<table STYLE="border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=16 ALIGN=center STYLE="border-top: solid .75pt black; border-left: solid .75pt black; border-right: solid .75pt black">64KB</td>
<td></td>
</tr>
<tr>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>0000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>1000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>2000</code></font><br>C</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>3000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>4000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>5000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>6000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>7000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>8000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>9000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>A000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>B000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>C000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>D000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>E000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>F000</code></font><br>R</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0079<br>0000</code></font><br>X</td>
</tr>
<tr>
<td COLSPAN=2></td>
<td COLSPAN=14 ALIGN=left>^ output pointer</td>
</tr>
</table>
<p>
If you think about it, this is exactly what the memory manager does
with memory that has been allocated but not yet accessed:
The memory is not present,
and the moment an application tries to access it,
the not-present page fault is raised,
the memory manager commits the page,
and then execution resumes normally.
It's memory-on-demand, which is one of the essential elements of
virtual memory.
What's going on with the <code>DEMANDBUFFER</code> is that we are
simulating in user mode what the memory manager does in kernel mode.
(The difference is that while the memory manager takes committed
memory and makes it present on demand,
the <code>DEMANDBUFFER</code> takes reserved address space
and commits it on demand.)
</p>
<p>
The cycle repeats 13 more times, and then we reach another interesting
part of the scenario:
</p>
<table STYLE="border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=16 ALIGN=center STYLE="border-top: solid .75pt black; border-left: solid .75pt black; border-right: solid .75pt black">64KB</td>
<td></td>
</tr>
<tr>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>0000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>1000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>2000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>3000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>4000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>5000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>6000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>7000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>8000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>9000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>A000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>B000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>C000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>D000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>E000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>F000</code></font><br>C</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0079<br>0000</code></font><br>X</td>
</tr>
<tr>
<td COLSPAN=16 ALIGN=right>output pointer ^</td>
</tr>
</table>
<p>
We are about to write 32768th character into the
<code>DEMANDBUFFER</code>.
Once that's done, the buffer will be completely full.
One more byte and we will overflow the buffer.
(Not even a wafer-thin byte will fit.)
</p>
<p>
Let's write that last character and
<a HREF="http://www.slipups.com/items/698.html">
cover our ears in anticipation</a>.
</p>
<table STYLE="border-collapse: collapse; text-align: center">
<tr>
<td COLSPAN=16 ALIGN=center STYLE="border-top: solid .75pt black; border-left: solid .75pt black; border-right: solid .75pt black">64KB</td>
<td></td>
</tr>
<tr>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>0000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>1000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>2000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>3000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>4000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>5000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>6000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>7000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>8000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>9000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>A000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>B000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>C000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>D000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>E000</code></font><br>C</td>
<td BGCOLOR=#FFFF80 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0078<br>F000</code></font><br>C</td>
<td BGCOLOR=#808080 STYLE="width: 5%; border: .75pt solid black"><font SIZE=-1><code>0079<br>0000</code></font><br>X</td>
</tr>
<tr>
<td COLSPAN=16 align=right>output pointer</td>
<td ALIGN=left>^</td>
</tr>
</table>
<p>
Oh noes!
Completely full!
Run for cover!
</p>
<p>
But wait.
We passed a buffer size to the
<code>_vsnwprintf</code> function, remember?
We already told it never to write more than 32768 characters.
As it's about to write character 32769, it realizes,
"Wait a second, this would overflow the buffer I was given.
I'll return a failure code instead."
</p>
<p>
The feared write of the 32769th character never takes place.
We never write to the "X" page.
Instead, the <code>_vnswprintf</code> call returns that the
buffer was not large enough, which is converted into
<code>ERROR_MORE_DATA</code> and returned to the caller.
</p>
<p>
If you follow through the entire story, you see that everything
worked as it was supposed to and no overflow took place.
The <code>_vnswprintf</code> function ran up to the brink of
disaster but stopped before taking that last step.
This is hardly anything surprising; it happens whenever
the <code>_vnswprintf</code> function encounters a buffer
too small to hold the output.
The only difference is that along the way, we saw a few
first-chance exceptions,
exceptions that had nothing to do with avoiding the buffer
overflow in the first place.
They were just part of <code>FormatMessage</code>'s
fancy buffer management.
</p>
<p>
It so happens that in Windows Vista,
the fancy buffer management technique was abandoned, and
the code just allocates 64KB of memory up front and doesn't
try any fancy commit-on-demand games.
Computer memory has become plentiful enough that a momentary allocation
of 64KB has less of an impact than it did twenty years ago,
and performance measurements showed that the new
"Stop trying to be so clever" technique was now about 80 times
faster than the "gotta scrimp and save every last byte of memory"
technique.
</p>
<p>
The change had more than just a performance effect.
It also removed the first-chance exception from <code>FormatMessage</code>,
which means that it no longer does that thing which everybody
mistakes for a security vulnerability.
The good news is that nobody reports this as a vulnerability
in Windows&nbsp;Vista any more.
The bad news is that people still report it as a vulnerability
in Windows&nbsp;XP,
and each
time this issue comes up,
somebody (possibly me) has to sit down and
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2007/12/18/6793468.aspx">
reverify that the previous analysis is still correct</a>,
in the specific scenario being reported,
because who knows, maybe this time they really did find a problem.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (24)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-966263">
				<div id="div-comment-966263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966263">
			February 10, 2012 at 7:44 am</a>		</div>

		<p>Wow, thanks for the writeup and the peering into the internals. &nbsp;A factor of 80 improvement? &nbsp;Is that averaged over some large corpus of error strings and use cases, both long and short? &nbsp;In any case, that&#39;s impressive &#8212; was the previous version of FormatMessage really spending 98.75% of its time just dispatching access violations and VirtualQuery/VirtualAlloc?</p>
<p>The documentation on FormatMessage is a little confusing regarding the arguments array. &nbsp;In re the FORMAT_MESSAGE_ARGUMENT_ARRAY flag, it says that it can&#39;t be used with 64-bit integer values, yet the description of the Arguments parameter says that you need to pass a pointer to an array of DWORD_PTR values when you use that flag. &nbsp;On 64-bit Windows, a DWORD_PTR is a 64-bit integer, so these statements seem contradictory.</p>
<div class="post">[<i>No contradiction. You can&#39;t use <code>%1!I64d!</code> in a format. The DWORD_PTR is there so you can pass a string pointer to <code>%1</code>. (Think about the problems that would arise if 64-bit and 32-bit Windows packed 64-bit integers differently.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966273">
				<div id="div-comment-966273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy O'Neal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966273">
			February 10, 2012 at 8:03 am</a>		</div>

		<p>Adam: Raymond likes to throw out &quot;example numbers&quot; which aren&#39;t based on actual data. (E.g. he usually refers to a program in question as &quot;Program Q&quot; or similar). That said, the page buffer reallocate method is extremely slow because of the context switch into the Kernel to satisfy the memory commit request, so I&#39;d not be surprised if between that and other machinery to do this that it&#39;d be 80 times faster in some cases.</p>
<div class="post">[<i>In this case, the number 80 came from actual measurements. I did not conduct the measurements so I don&#39;t know what the methodology was. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-joshuaganes even thread-even depth-1" id="comment-966283">
				<div id="div-comment-966283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Joshua+Ganes' rel='external nofollow' class='url'>Joshua Ganes</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966283">
			February 10, 2012 at 8:19 am</a>		</div>

		<p>I understand that somebody has to look at incoming vulnerability reports, even if they are absurd. Once you recognize that the report is describing the same issue that was reported dozens of times before, how much time and effort do you actually spend on the analysis?</p>
<div class="post">[<i>You have to verify that the previous analysis is still correct. Who knows, maybe a subsequent change to the function introduced a security issue. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966293">
				<div id="div-comment-966293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeremy Stanley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966293">
			February 10, 2012 at 8:37 am</a>		</div>

		<p>I find a 64KB allocation surprising. &nbsp;How many formatted messages fill more than even a single 4KB page? &nbsp;I guess (1) 64KB is the undocumented minimum virtual address space reservation, and (2) using the process heap is out of the question? &nbsp;I might have considered committing just the first 4KB page of the reservation, and then committing the rest in one fell swoop if the first-chance exception is hit. &nbsp;Then again, it sounds like avoiding the first-chance exception is a feature too, and RAM is cheap as free these days anyhow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jader3rd even thread-even depth-1" id="comment-966303">
				<div id="div-comment-966303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jader3rd' rel='external nofollow' class='url'>jader3rd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966303">
			February 10, 2012 at 9:20 am</a>		</div>

		<p>It&#39;s going to pain some people to read that in some ways Vista is faster than it&#39;s predecessors.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966313">
				<div id="div-comment-966313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rick C</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966313">
			February 10, 2012 at 10:37 am</a>		</div>

		<p>@Jeremy Stanley, regarding &quot;I might have considered committing just the first 4KB page of the reservation, and then committing the rest in one fell swoop if the first-chance exception is hit,&quot; that doesn&#39;t go well with the stated goal of using as little memory as possible. &nbsp;Allocating 60K when you are likely to only need 4 or 8 is wasteful (considering the timeframe.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966333">
				<div id="div-comment-966333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeremy Stanley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966333">
			February 10, 2012 at 11:19 am</a>		</div>

		<p>@Rick C, you misunderstand; I was suggesting this as an alternative to the newer Vista behavior, which was commit 64KB for every call. &nbsp;The idea was to keep (presumably) common &lt; 4KB cases efficient, but then handle big ones with just one &quot;page fault&quot; instead of fifteen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966343">
				<div id="div-comment-966343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966343">
			February 10, 2012 at 11:39 am</a>		</div>

		<p>Here&#39;s a (possibly naive) follow-up question. &nbsp;Why allocate a fixed buffer at all? &nbsp;Why not run through the formatting once to count the number of characters, allocate the exact amount of space needed, and then run through a second time to actually fill the buffer?</p>
<div class="post">[<i>See: TOCTTOU. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966353">
				<div id="div-comment-966353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966353">
			February 10, 2012 at 1:28 pm</a>		</div>

		<p>&quot;[See: TOCTTOU. -Raymond]&quot;</p>
<p>And? &nbsp;Somebody&#39;s going to change the parameters and cause the program to crash? &nbsp;Oh noes! &nbsp;Also, the entire registry API (blah blah time machine blah blah).</p>
<p>But yeah, 64KB is a reasonable size to allocate up front; simpler than the alternatives.</p>
<div class="post">[<i>You&#39;re lucky if it crashes. If you&#39;re unlucky, you have a remotely exploitable buffer overflow. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966363">
				<div id="div-comment-966363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966363">
			February 10, 2012 at 1:51 pm</a>		</div>

		<p>You still know the size of the buffer ahead of time so you shouldn&#39;t be in danger of an overflow.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966373">
				<div id="div-comment-966373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian D.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966373">
			February 10, 2012 at 2:38 pm</a>		</div>

		<p>Why not update FormatMessage in XP to work the same as Vista to make those reports go away? &nbsp;Seems like a no brainer, especially if the machine has a GB or more. &nbsp;Keep the old method around for the smaller machines.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966383">
				<div id="div-comment-966383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966383">
			February 10, 2012 at 2:49 pm</a>		</div>

		<p>Ian D.: I&#39;m pretty sure the cost of regression-testing and distributing a new Kernel32 binary vastly outweighs the lost engineering time from the occasional &quot;security vulnerability.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-966393">
				<div id="div-comment-966393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966393">
			February 10, 2012 at 3:08 pm</a>		</div>

		<p>Oh, but sir&#8230; it&#39;s only wafer-thin&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966403">
				<div id="div-comment-966403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966403">
			February 10, 2012 at 3:17 pm</a>		</div>

		<p>@Ian:</p>
<p>Well, the reasoning for the cludge did not vanish, so how could you justify removing the cludge?</p>
<p>You cannot suddenly say &#39;Oh, and by the way, you must dump all your obsolete business-critical xp machines or live without security fixes.&#39;</p>
<p>There&#39;s going to be someone suing you for sure, besides the nice advertisement.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966423">
				<div id="div-comment-966423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavel Lebedinsky</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966423">
			February 10, 2012 at 11:18 pm</a>		</div>

		<p>The &quot;commit on demand&quot; technique doesn&#39;t actually save any physical memory, because physical pages are allocated on demand anyway (at the time of first access). The only thing it saves in the FormatMessage example is a transient, extremely short-lived 60K spike in commit, which is for all practical purposes free, even on a 12 MB machine from 15 years ago.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966443">
				<div id="div-comment-966443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966443">
			February 11, 2012 at 6:48 am</a>		</div>

		<p>&quot;[See: TOCTTOU. -Raymond]&quot;</p>
<p>I don&#39;t follow. &nbsp;The concern is that the parameter values might change between your allocation and writing the string? That seems like an unusual edge case to me. &nbsp;Wouldn&#39;t be ok to just fail in that case? The output is unlikely to be consistent anyway.</p>
<div class="post">[<i>News flash: Unusual edge cases are where the security vulnerabilities tend to hang out. And sure you could decide to fail that case &#8211; but you now have to write code to detect that you are in that case. It&#39;s not a slam-dunk &quot;Just format it twice.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966463">
				<div id="div-comment-966463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966463">
			February 11, 2012 at 7:27 am</a>		</div>

		<p>What is this kind of stupid architectural limitations? On a 32-bit system, strings should be able to be 2^32-1 bytes long. On a 64-bit system, strings should be able to be 2^64-1 bytes long. And NO slack memory should be allocated, not a single byte. It should be 100% secure too. Please go back to the drawing board and learn how to program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966473">
				<div id="div-comment-966473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pierre de Fermat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966473">
			February 11, 2012 at 8:34 am</a>		</div>

		<p>@640K: I had a 32-bit system with a string of 2^32-1 bytes once. I would have made a truly marvellous screenshot as proof, but unfortunately, memory was too marginal to contain it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966483">
				<div id="div-comment-966483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Erzengel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966483">
			February 11, 2012 at 9:39 am</a>		</div>

		<p>I was wondering what these first-chance exceptions in format message were that was filling up my debugger logs. They didn&#39;t seem to be doing any damage to my app, so I ignored them, but I always wondered. Thanks for explaining.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966493">
				<div id="div-comment-966493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CN</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966493">
			February 12, 2012 at 9:01 am</a>		</div>

		<p>It would be interesting to here some rebuttal/comment on Pavel&#39;s claim that this was a symptom of over-optimization, where the underlying systems are not understood. Kind of like that story about optimizing based on profiling and end up making the idle loop x % faster&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966503">
				<div id="div-comment-966503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966503">
			February 12, 2012 at 9:25 am</a>		</div>

		<p>Anyway, the &quot;measure, allocate, fill&quot; pattern is common, but it only works when you can guarantee that nothing&#39;s going to be changed in another thread in the middle of the process. To be robust in that situation (which you have to be, if you&#39;re packaging up the whole thing in a library function), you&#39;d need to do it in a loop, or add an extra check. Some unix libc&#39;s strdup functions get this wrong (they use memcpy, which means they can silently truncate and not null-terminate a string in this situation &#8211; MSVCRT _strdup uses strcpy_s, which at least does a check and crashes.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-966513">
				<div id="div-comment-966513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jas71_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jas71@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966513">
			February 12, 2012 at 11:28 am</a>		</div>

		<p>@Pierre: Not impossible &#8211; for that matter, of course, there&#39;s nothing to say a 32 bit system should be constrained to 2^32 bytes: you can do 64 or even 128 bit arithmetic. The same techniques were much more useful back in 16 bit days, of course, where limiting resources to 64 kilobytes would be a real problem: not much market for a word processor which dies on a 64k file, or an image editor which can&#39;t load a 640&#215;480 bitmap &#8211; but Windows added the Address Windowing Extensions, so 32 bit applications could access more RAM than would fit in a 32 bit address space.</p>
<p>The 80-fold speedup from removing this &quot;efficiency&quot; technique reminded me of working on an old VB application years ago. It performed a fairly simple calculation on a batch of numbers, displaying a progress indicator which slowly crept across the screen. Tasked with speeding it up, I profiled the code &#8230; 99% of the CPU time was going on drawing the progress bar itself! Remove that, the remaining code was fast enough there was no need for any progress indicator anyway&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-966523">
				<div id="div-comment-966523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John von Neumann</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966523">
			February 12, 2012 at 1:09 pm</a>		</div>

		<p>@jas88: you forgot the simplest way of all to cheat &#8212; if the string is a C string, all we require is that the final byte in memory is a NUL. If that&#39;s the case, then all of memory can be interpreted as a string. I had such a string once and making a screenshot was fairly easy because it contained bytes that decoded to instructions for doing so&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-davebacher odd alt thread-odd thread-alt depth-1" id="comment-966673">
				<div id="div-comment-966673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Dave+Bacher' rel='external nofollow' class='url'>Dave Bacher</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120210-00/?p=8333#comment-966673">
			February 13, 2012 at 7:38 pm</a>		</div>

		<p>Looks like a pretty smart way of doing it really (don&#39;t worry, I&#39;ll go back to being negative soon enough).</p>
<p>I&#39;d imagine if you put a metric on the number of calls that return without the first chance exception being raised &#8212; especially when the decision was made &#8212; it would probably be above 90%. &nbsp;In C/C++, generally programmers favor the built-ins, and the built-ins (printf family, etc.) don&#39;t generally route through FormatMessage because it would be a pain to translate the one set of semantics into the other. &nbsp;So for the 90% case where FormatMessage is being used to recover a message from the OS for an error code, and then invoked a second time to format the message for MessageBox, the 4k buffer would be totally adequate.</p>
<p>Also, if you were smart, you keep the buffer around because if the thread needed 20k on one call, chances are it might make that call again. &nbsp;I&#39;d think that would be a case you&#39;d probably optimize for (for the case of FormatMessage going to a log file &#8212; which would be the most common case where I&#39;d expect to see &gt; 4k messages, potentially in an inner loop).</p>
<p>In terms of counting &#8212; that seems like it would be really hard to do without two separate implementations of FormatMessage. &nbsp;Traditionally, one version of FormatMessageA/FormatMessageW called through to the other, didn&#39;t it? &nbsp;So lets say that I&#39;m on NT so FormatMessageA calls FormatMessageW, then does a Unicode to MBCS conversion. &nbsp;How do I count that for shift-JIS (and if you want to bring modern Windows into the mix, assume that there are surrogates in the unicode string).</p>
<p>Also, for each character position you have a switch and either an accumulate or a produce (at least, that&#39;s how I&#39;d expect it works inside). &nbsp;If you assume that, then you&#39;ve got this huge ass switch statement and accumulate/reduce logic that you&#39;ve got to repeat. &nbsp;And so you&#39;re really &#8212; during the counting pass &#8212; going to probably tokenize into a series of instructions, if you were going to do it that way. &nbsp;At that point, you&#39;re back to needing a variable sized buffer &#8212; but now you need two of them.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

