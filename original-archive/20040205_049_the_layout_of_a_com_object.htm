<html>
<head>
<title>The layout of a COM object</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The layout of a COM object</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>February 5, 2004 / year-entry #50</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>39</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The Win32 COM calling convention specifies the layout of the virtual method table (vtable) of an object. If a language/compiler wants to support COM, it must lay out its object in the specified manner so other components can use it. It is no coincidence that the Win32 COM object layout matches closely the C++ object...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
The Win32 COM calling convention specifies the layout of
the virtual method table (vtable) of an object.
If a language/compiler wants to support COM, it must lay
out its object in the specified manner so other components
can use it.</p>
<p>
It is no coincidence that the Win32 COM object layout matches
closely the C++ object layout.  Even though COM was originally
developed when C was the predominant programming language,
the designers saw fit to "play friendly" with the up-and-coming
new language C++.
</p>
<p>
The layout of a COM object is made explicit in the header files
for the various
interfaces. For example, here's IPersist from objidl.h, after cleaning
up some macros.</p>
<pre>
typedef struct IPersistVtbl
{
    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IPersist * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IPersist * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IPersist * This);

    HRESULT ( STDMETHODCALLTYPE *GetClassID )(
        IPersist * This,
        /* [out] */ CLSID *pClassID);

} IPersistVtbl;

struct IPersist
{
    const struct IPersistVtbl *lpVtbl;
};
</pre>
<p>
This corresponds to the following memory layout:
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 STYLE="border-collapse: collapse">
<col SPAN=5 ALIGN=center>
<tr>
<td>p</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow">&nbsp; &nbsp;lpVtbl&nbsp; &nbsp;</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">QueryInterface</td>
</tr>
<tr>
<td ROWSPAN=3></td>
<td ROWSPAN=3></td>
<td ROWSPAN=3></td>
<td ROWSPAN=3></td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">AddRef</td>
</tr>
<tr>
<td STYLE="border: solid 1px buttonshadow; height: 2em">Release</td>
</tr>
<tr>
<td STYLE="border: solid 1px buttonshadow; height: 2em">GetClassID</td>
</tr>
</table>
<p>
What does this mean?
</p>
<p>
A COM interface pointer is a pointer to a structure that consists
of just a vtable.
The vtable is a structure that contains a bunch of function pointers.
Each function in the list takes that interface pointer (p) as its first
parameter ("this").
</p>
<p>
The magic to all this is that since your function gets p
as its first parameter, you can "hang" additional
stuff onto that vtable:
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 STYLE="border-collapse: collapse">
<col SPAN=5 ALIGN=center>
<tr>
<td>p</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow">&nbsp; &nbsp;lpVtbl&nbsp; &nbsp;</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">QueryInterface</td>
</tr>
<tr>
<td ROWSPAN=3></td>
<td ROWSPAN=3></td>
<td ROWSPAN=3 STYLE="border: solid 1px buttonshadow">...<br>
          other stuff<br>...</td>
<td ROWSPAN=3></td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">AddRef</td>
</tr>
<tr>
<td STYLE="border: solid 1px buttonshadow; height: 2em">Release</td>
</tr>
<tr>
<td STYLE="border: solid 1px buttonshadow; height: 2em">GetClassID</td>
</tr>
</table>
<p>
The functions in the vtable can use offsets relative to the
interface pointer to access its other stuff.
</p>
<p>
If an object implements multiple interfaces but they are all descendants
of each other, then a single vtable can be used for all of them.
For example, the object above is already set to be used either as
an IUnknown or as an IPersist, since IUnknown is a subset of IPersist.
</p>
<p>
On the other hand, if an object implements multiple interfaces
that are not descendants of each other, then you get multiple
inheritance, in which case the object is typically laid out in
memory like this:
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 STYLE="border-collapse: collapse">
<col SPAN=7 ALIGN=center>
<tr>
<td>p</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow">&nbsp; &nbsp;lpVtbl&nbsp; &nbsp;</td>
<td>&rarr;</td>
<td ALIGN=center>&rarr;</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">QueryInterface (1)</td>
</tr>
<tr>
<td>q</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow">&nbsp; &nbsp;lpVtbl&nbsp; &nbsp;</td>
<td>&rarr;</td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">QueryInterface (2)</td>
<td ROWSPAN=4><span STYLE="width: 2em"></span></td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">AddRef (1)</td>
</tr>
<tr>
<td ROWSPAN=3 COLSPAN=2></td>
<td ROWSPAN=3 STYLE="border: solid 1px buttonshadow">...<br>
          other stuff<br>...</td>
<td ROWSPAN=3></td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">AddRef (2)</td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">Release (1)</td>
</tr>
<tr>
<td STYLE="border: solid 1px buttonshadow; height: 2em">Release (2)</td>
<td STYLE="border: solid 1px buttonshadow; height: 2em">...</td>
</tr>
<tr>
<td STYLE="border: solid 1px buttonshadow; height: 2em">...</td>
</tr>
</table>
<p>
If you are using an interface that comes from the first vtable, then
the interface pointer is p.  But if you're using an interface that
comes from the second vtable, then the interface pointer is q.
</p>
<p>
Hang onto that diagram, because
tomorrow we will learn about those mysterious "adjustor thunks".</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (39)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-141223">
				<div id="div-comment-141223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeneffect.com' rel='external nofollow' class='url'>Ian Hanschen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141223">
			February 5, 2004 at 7:30 am</a>		</div>

		<p>Raymond,<br />
<br />Good read.</p>
<p>How are you creating your diagrams?  Manually writing the HTML, using Word, or?  I really dislike having to use photoshop to throw something together that&#8217;s going to sit in html that would look just fine using vml/tables.<br />
<br />-Ian</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141233">
				<div id="div-comment-141233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.geekdojo.net/pdbartlett/archive/2004/02/05/858.aspx' rel='external nofollow' class='url'>Paul's Imaginary Friend</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141233">
			February 5, 2004 at 10:49 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141253">
				<div id="div-comment-141253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/brianjo/archive/2004/02/05/68215.aspx' rel='external nofollow' class='url'>BufferOverrun</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141253">
			February 5, 2004 at 3:39 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141313">
				<div id="div-comment-141313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://alias:ndiamond@msdn.discussions.microsoft.com' rel='external nofollow' class='url'>Norman Diamond</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141313">
			February 5, 2004 at 8:21 pm</a>		</div>

		<p>For a change of pace I have a genuine technical question as a followup, and it even reveals some of my incompetence.</p>
<p>When a COM object is designed with a dual interface, access to the COM interface is pretty straightforward, callable from Visual Basic and JavaScript etc.  The COM interface is also more or less accessible by C++ applications, depending on what fraction of the DLL&#8217;s Type Library is understood by Class Wizard.  For example if the COM interface uses SAFEARRAYs and the .odl file imports &quot;oaidl.idl&quot; (which by the way is a different file than MSDN says to import for SAFEARRAY) then Visual Basic arrays map onto it perfectly but VC++ clients don&#8217;t get interfaces generated by Class Wizard.</p>
<p>However, the purpose of a dual interface is that the VTBL interface should also be visible to VC++ clients, right?  Then the DLL can export methods using unsafe arrays and VC++ clients can call those methods directly, right?</p>
<p>But I&#8217;ve never figured out how to code a VC++ application to access the VTBL interface of classes/methods exported from a DLL.  If I try to #include the relevant .h files of the DLL itself then those bring in all kinds of baggage related to the fact that the DLL is a COM server.  If I use Class Wizard to generate a .h file from the Type Library then we&#8217;re back to the COM interface (and the limitations of Class Wizard).  I think I have sufficient skills to hand-code a .h file that will result in compiling the client application, but I&#8217;m very suspicious of doing things this way.  The purpose of a dual interface is to expose both interfaces to clients, VC++ wizards generate all sorts of code to assist developers, and I don&#8217;t think tedious hand-construction of one .h file fits this scenario.  There must be something I&#8217;m missing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141323">
				<div id="div-comment-141323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeneffect.com' rel='external nofollow' class='url'>Ian Hanschen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141323">
			February 5, 2004 at 10:02 pm</a>		</div>

		<p>Perhaps I&#8217;m misunderstanding your question but why not use the #import directive?<br />
<br /><a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_predir_the_.23.import_directive.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_predir_the_.23.import_directive.asp</a><br />
<br />-Ian</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141343">
				<div id="div-comment-141343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://alias:ndiamond@msdn.discussions.microsoft.com' rel='external nofollow' class='url'>Norman Diamond</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141343">
			February 5, 2004 at 11:20 pm</a>		</div>

		<p>2/5/2004 10:02 PM Ian Hanschen:</p>
<p>&gt; why not use the #import directive?</p>
<p>Isn&#8217;t the effect the same?  It interprets the DLL&#8217;s Type Library and produces new classes which mostly describe the COM object&#8217;s COM interface?</p>
<p>I want to try accessing the COM object&#8217;s VTBL interface but can&#8217;t figure out how.  I thought the purpose of a dual interface was that clients could access it either way, not being restricted to COM interface (in the case of C++, not being restricted to the portion of the COM interface that VC++ tools understand).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141353">
				<div id="div-comment-141353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141353">
			February 6, 2004 at 2:53 am</a>		</div>

		<p>Norman:</p>
<p>A dual interface has the same structure whether you access it through the vtable or through IDispatch. The methods have the same types. If you want a more C++-friendly interface, use a custom interface.</p>
<p>The #import statement produces vtable access code; ClassWizard always produces IDispatch access code.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141363">
				<div id="div-comment-141363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nate</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141363">
			February 6, 2004 at 3:07 am</a>		</div>

		<p>Internet Explorer, it still can&#8217;t render transparent PNGs properly, but it can display VML&#8230;..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141373">
				<div id="div-comment-141373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reuben Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141373">
			February 6, 2004 at 3:10 am</a>		</div>

		<p>I thought the purpose of a dual interface was to allow clients to invoke methods either natively or by name (through IDispatch). Both involve calling through interface pointers&#8230;</p>
<p>Were you hoping for a plain C++ class with normal methods corresponding to what&#8217;s the typelib?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141383">
				<div id="div-comment-141383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141383">
			February 6, 2004 at 6:07 am</a>		</div>

		<p>Reuben is correct. The point of dual interfaces is that instead of</p>
<p>IDispatch *pd;<br />
<br />CoCreateInstance(CLSID_Shell, NULL, CLSCTX_ALL, IID_IDispatch, &amp;pd);<br />
<br />LPOLESTR pszCmd = L&quot;ControlPanelItem&quot;;<br />
<br />DISPID dispid;<br />
<br />pd-&gt;GetIDsOfNames(IID_NULL, &amp;pszCmd, 1, LOCAL_SYSTEM_DEFAULT, &amp;dispid);<br />
<br />VARIANT vt;<br />
<br />V_VT(&amp;vt) = VT_BSTR;<br />
<br />V_BSTR(&amp;vt) = SysAllocString(L&quot;keyboard&quot;);<br />
<br />DISPPARAMS dp = { &amp;vt, NULL, 1, 0 };<br />
<br />pd-&gt;Invoke(dispid, IID_NULL, LOCAL_SYSTEM_DEFAULT, DISPATCH_METHOD, &amp;dp, NULL, NULL, NULL);</p>
<p>you can do this:</p>
<p>#include &lt;shldisp.h&gt;<br />
<br />IShellDispatch *psd;<br />
<br />CoCreateInstance(CLSID_Shell, NULL, CLSCTX_ALL, IID_IShellDispatch, &amp;psd);<br />
<br />BSTR bs = SysAllocString(L&quot;keyboard&quot;);<br />
<br />psd-&gt;ControlPanelItem(bs);</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141393">
				<div id="div-comment-141393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs/geekdojo.net/pdbartlett' rel='external nofollow' class='url'>Paul Bartlett</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141393">
			February 6, 2004 at 7:11 am</a>		</div>

		<p>I also think that Norman thought dual interfaces would allow certain parameter types to be treated differently (he mentions SAFEARRAY and &quot;unsafe&quot; arrays, which I take to mean conformant, or counted, arrays as the size is needed by the marshalling code). Unfortunately this is not the case. Dual interfaces merely permit &quot;normal&quot; or IDispatch-based calling (a.k.a. early and late binding)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141553">
				<div id="div-comment-141553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/archive/0001/01/01/68695.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141553">
			February 8, 2004 at 12:09 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141593">
				<div id="div-comment-141593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://alias:ndiamond@msdn.discussions.microsoft.com' rel='external nofollow' class='url'>Norman Diamond</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141593">
			February 8, 2004 at 7:45 pm</a>		</div>

		<p>2/6/2004 6:07 AM Raymond Chen:</p>
<p>&gt; #include &lt;shldisp.h&gt;<br />
<br />&gt; IShellDispatch *psd;<br />
<br />&gt; CoCreateInstance(CLSID_Shell, NULL,<br />
<br />&gt;    CLSCTX_ALL, IID_IShellDispatch, &amp;psd);<br />
<br />&gt; BSTR bs = SysAllocString(L&quot;keyboard&quot;);<br />
<br />&gt; psd-&gt;ControlPanelItem(bs);</p>
<p>Thank you.  For some reason I hadn&#8217;t heard of IShellDispatch before.  I&#8217;m a bit disappointed that even this moderate degree of complexity is necessary.  I was hoping for something resembling an ordinary DLL that could export methods of an ordinary class, and the DLL&#8217;s client can just include the .h file and make ordinary calls directly.  The client didn&#8217;t even have to know that a vtbl is involved, though as C++ programmers we know about it.  Starting now I will think of [dual] as permitting access through either IDispatch or IShellDispatch, but still not really directly through the vtbl.</p>
<p>2/6/2004 7:11 AM Paul Bartlett:</p>
<p>&gt; I also think that Norman thought dual<br />
<br />&gt; interfaces would allow certain parameter<br />
<br />&gt; types to be treated differently (he mentions<br />
<br />&gt; SAFEARRAY and &quot;unsafe&quot; arrays</p>
<p>Yes I was hoping for that.  SAFEARRAYs do get marshalled between the COM DLL&#8217;s COM interface and callers in Visual Basic, JavaScript, etc.  The DLL&#8217;s .odl file has to import &quot;oaidl.idl&quot; (which by the way is a different file than MSDN says to import for SAFEARRAY).  But I don&#8217;t want to force an ordinary C++ client to use SAFEARRAYs just to access my DLL, so I wanted to export a method with pointer and count parameters through the vtbl.  For a plain ordinary DLL without COM that would of course be most straightforward.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141613">
				<div id="div-comment-141613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141613">
			February 8, 2004 at 10:37 pm</a>		</div>

		<p>I guess I don&#8217;t understand what you mean by &quot;not really directly through the vtbl&quot;. When you write</p>
<p>  psd-&gt;ControlPanelItem(bs);</p>
<p>you&#8217;re calling the method through the vtbl, just like any other C++ object.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141763">
				<div id="div-comment-141763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://alias:ndiamond@msdn.discussions.microsoft.com' rel='external nofollow' class='url'>Norman Diamond</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141763">
			February 9, 2004 at 7:05 pm</a>		</div>

		<p>2/8/2004 10:37 PM Raymond Chen:</p>
<p>&gt; When you write<br />
<br />&gt; psd-&gt;ControlPanelItem(bs);<br />
<br />&gt; you&#8217;re calling the method through the vtbl</p>
<p>You&#8217;re right, so that accomplishes what I said I was asking for.  Mike Dimmick also explained part of it, saying that the #import statement yields knowledge of the vtbl instead of being a clone of Class Wizard&#8217;s knowledge of the COM interface.  Now when I have time I need to experiment.  I guess I was confused because it was still necessary to call CoCreateInstance() instead of just including a .h file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141783">
				<div id="div-comment-141783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141783">
			February 9, 2004 at 10:15 pm</a>		</div>

		<p>CoCreateInstance creates the object. If not with CCI, how else would you be able to create the object?  (I guess the .h file could have its own creation function, like DirectDrawCreate, but then you&#8217;d also need a .lib to link against.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141873">
				<div id="div-comment-141873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mo.mckinlay.me.uk' rel='external nofollow' class='url'>Mo</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141873">
			February 10, 2004 at 8:00 am</a>		</div>

		<p>I think what Norman was getting at (to a point) is something which exports either a set of plain C functions, or a C++ class which effectively wraps a given CoClass in a typelib &#8211; i.e., such that the client doesn&#8217;t have to know anything about COM at all.</p>
<p>Perhaps he&#8217;d like something like this:</p>
<p>  Shell *pshell = new Shell();<br />
<br />  pshell-&gt;ControlPanelItem(&quot;Keyboard&quot;);</p>
<p>Letting the class constructor deal with the CoCreateInstance() for you.</p>
<p>The problem with this is, of course, that the only sane way to do that is to have a stub class which deals with the construction and marshals parameters for you. </p>
<p>Alternatively, you could play with deriving the interface structures and add static methods which constructed the COM object for you, giving you something like:</p>
<p>ShellDispatch *psd = ShellDispatch::Create();</p>
<p>or perhaps:</p>
<p>ShellDispatch *psd = Shell::CreateDispatch();</p>
<p>But that still leaves you with a few problems; most importantly, you have the fundamental problem of interfaces vs. classes. Do you try and roll all of a CoClass&#8217;s interfaces into a single C++ class? Or do you have a separate class for each interface? Perhaps you return IShellDispatch like normal, but construct it using a helper class? Whatever your answer, it hasn&#8217;t really got you very far (and isn&#8217;t much above calling CoCreateInstance(), besides looking prettier).</p>
<p>I guess what would be really nice (and potentially what Norman *might* have been hankering after) was a way of using COM to, for want of a better term, marshal C++ method calls. We all know how to write COM servers in C++ &#8211; wouldn&#8217;t it be nice if the client side looked (from a programming interface point of view) like the servers?</p>
<p>The answer to that is a definite maybe. In reality, COM (and I can only assume by design) went out of its way to strike a balance between convenience and extensibility; the clear division between clients and servers, and between interfaces and classes (which are opaque, save for IUnknown, of course), does you an awful lot of favours. It&#8217;s certainly true that the COM APIs aren&#8217;t the nicest in the world, but CoCreateInstance isn&#8217;t too bad, and once you have your instance there&#8217;s very little reason to touch them throughout the lifetime of the instance.</p>
<p>My suggestion: if CoCreateInstance puts you off, wrap it in a macro call:</p>
<p>#define CreateShellDispatch(inst) CoCreateInstance(CLSID_Shell, NULL, CLSCTX_ALL, IID_IShellDispatch, &amp;(inst))<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-141883">
				<div id="div-comment-141883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141883">
			February 10, 2004 at 8:40 am</a>		</div>

		<p>If the only quibble was having to use CoCreateInstance instead of &quot;new&quot;, then &#8211; well &#8211; that&#8217;s what happens when you are designing a language-neutral interoperability system. A wrapper class or helper macro will have to do.</p>
<p>If you use IDL to generate your interfaces, then the marshalling is done for you by the MIDL compiler. The catch is that the things you pass need to be MIDL-friendly, but that&#8217;s unavoidable since MIDL isn&#8217;t psychic.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-141903">
				<div id="div-comment-141903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mo.mckinlay.me.uk' rel='external nofollow' class='url'>Mo</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-141903">
			February 10, 2004 at 9:25 am</a>		</div>

		<p>Well, yes, you&#8217;re completely right (of course). In a system such as COM, you&#8217;re always going to get a divide between the &quot;ideal&quot; and the &quot;sane&quot;.</p>
<p>From experience, the two biggest hurdles for people using COM for the first time seem to be memory management (especially if delving into the shell interfaces) and parameter types. It&#8217;s not so much that there&#8217;s anything wrong with the way things are done, more that they&#8217;re just so different that it takes a little getting used to.</p>
<p>Learning COM can often mean throwing out a mindset you&#8217;ve built up using various programming languages and trying to think of the bigger picture &#8211; a lot of people doing COM stuff will never ever do anything besides inproc servers, so a few of the things COM makes you do might seem like overkill. Even trying to get your head around why IUnknown even works can be a bit of a leap of faith to begin with :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153143">
				<div id="div-comment-153143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153143">
			March 10, 2004 at 6:42 pm</a>		</div>

		<p>OK, I think I figured out what I wish for.  It is something less than COM, it is only for in-process servers where marshalling would be trivial.</p>
<p>As previously mentioned, the server provides an interface which is accessible from clients in Visual Basic, JavaScript, etc., using their ordinary function or method calls and member variable accesses and &quot;new&quot; operations.</p>
<p>The same interface is accessible from clients in Visual C++ through the entire weighty COM client infrastructure.  For out-of-process or distributed servers, of course all this stuff is necessary in order to do the marshalling.  For in-process stuff, besides being overkill, it also overkills ordinary C++ client programmers.  The Class Wizard operation builds helpers that map BSTR* to CString to help make some things easier for C++ clients, but it doesn&#8217;t understand SAFEARRAY.  #import understands all data types used in the class library but it doesn&#8217;t build helpers.  CString cannot be used in IDL.</p>
<p>For in-process servers with trivial marshalling, C++ clients of ordinary DLLs can do ordinary function or method calls equally simply as Visual Basic programmers can call COM interfaces.  Of course Visual Basic calling COM does have all the execution overhead, but client programmers can write simple code.</p>
<p>To provide an in-process server with simple interface access from VC++ clients, it still looks like I have to make a separate DLL from the DLL that serves clients in other languages.  It would be nice if a single DLL could provide an in-process server with trivial marshalling and simple calling from clients in all languages, instead of needing two DLLS.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153153">
				<div id="div-comment-153153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153153">
			March 10, 2004 at 6:45 pm</a>		</div>

		<p>All you have to do now is come up with a language-independent &quot;new&quot; operator &#8211; and then you find that you&#8217;ve reinvented CoCreateInstance.</p>
<p>I don&#8217;t see why you need two DLLs for this.  C++ clients can link to a DLL just as well as COM. After all, shell32 exposes some objects (CLSID_ShellLink) through COM and still can export functions (SHGetFileInfo) normally.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153173">
				<div id="div-comment-153173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153173">
			March 10, 2004 at 7:44 pm</a>		</div>

		<p>I put a second interface in the IDL file and corresponding code in the .h and .cpp files, intending to make this an interface for C++ clients.  Up to a point it worked.  But when I added a CString parameter, the MIDL compiler complained.  If I use BSTRs then we&#8217;re halfway back to the situation where C++ clients have to be overkilled and there&#8217;s no point having the second interface any more.  (Well, for arrays there might still be a purpose in having the second interface.)</p>
<p>Or do you mean that the server&#8217;s .h and .cpp files can contain additional C++ methods that are not even mentioned in the IDL file?  Then I could tell clients of C++ clients not to use either the Class Wizard or #import, ignore the difficult exported methods and just use the simple ones.  If a C++ client uses the DLL directly and a VB client uses the COM mechanism, both clients will be served properly?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153183">
				<div id="div-comment-153183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153183">
			March 10, 2004 at 8:23 pm</a>		</div>

		<p>Right, MIDL doesn&#8217;t know how to marshal a CString. It does understand boring LPCWSTR though; that may be good enough.</p>
<p>Or you can just put the stuff you don&#8217;t want MIDL to mess with inside a cpp_quote directive. Then MIDL will just emit it blindly without interpreting it.</p>
<p>And yes then you can tell C++ clients to just #include the header file and make direct calls. VB clients can still use the COM mechanism.  Shell32 does this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153203">
				<div id="div-comment-153203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153203">
			March 10, 2004 at 9:44 pm</a>		</div>

		<p>OK, maybe I&#8217;ve figured it out now.  One DLL can export two classes.  A generic class serves C++ clients and serves an ATL class.  The ATL class serves all other languages.  The generic class must be declared in its own .h file so that C++ clients can #include that one without being forced to understand a COM interface.</p>
<p>I still worry that the DLL might get unloaded when the COM usage count goes to 0 and COM doesn&#8217;t know that the DLL has non-COM clients.</p>
<p>Meanwhile, back to the attempted use of #import from a COM interface,</p>
<p>&gt; MIDL [&#8230;] does understand boring LPCWSTR</p>
<p>I neglected to try LPCTSTR.  It knows both of the possible underlying types but does it suit VC++ style to a _T()?</p>
<p>&gt; put the stuff you don&#8217;t want MIDL to mess<br />
<br />&gt; with inside a cpp_quote directive</p>
<p>I can&#8217;t figure out what to use it for.  For anything that I want to add to the server and/or make visible to C++ clients, I can just type it into a .h file and MIDL will never see it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153213">
				<div id="div-comment-153213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153213">
			March 10, 2004 at 9:53 pm</a>		</div>

		<p>If the DLL has non-COM clients they will have done their own LoadLibrary of the target DLL (either by an explicit call to LoadLibrary or implicitly by the loader when it sees the link in the import table), so the DLL reference count will not drop to zero.  Even if COM shows up, it will LoadLibrary you (bring your DLL reference count up to 2), and then FreeLibrary you when it&#8217;s done, dropping the count to 1 (not zero &#8211; so the DLL is not freed).</p>
<p>You can&#8217;t use LPCTSTR in a header file &#8211; that means that your function will get passed Unicode strings by Unicode callers and ANSI strings by ANSI callers &#8211; and you can&#8217;t tell which is which. If you want to support both Unicode and ANSI callers you need two functions, one W and one A.</p>
<p>Using cpp_quote lets you reduce to two files (foo.idl and foo.h). Otherwise you need three (foo.idl, foo.h, and fooextra.h where fooextra.h contains the C++ interfaces).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153223">
				<div id="div-comment-153223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153223">
			March 10, 2004 at 10:14 pm</a>		</div>

		<p>&gt; Even if COM shows up [&#8230;]</p>
<p>OK, thank you.</p>
<p>&gt; You can&#8217;t use LPCTSTR in a header file</p>
<p>In an IDL file, for the reason you mentioned.  You&#8217;re right, I still need to supply separate methods to C++ ANSI clients and C++ Unicode clients (besides the separate interface for all non-C languages).</p>
<p>&gt; Using cpp_quote lets you reduce to two files<br />
<br />&gt; (foo.idl and foo.h).</p>
<p>That I don&#8217;t see.  If foo.idl generates foo.h then foo.h declares a class with its COM interface declaration.  If C++ clients #include foo.h then they will have to understand the entire COM interface declaration even if they don&#8217;t use it.  I need fooextra.h for C++ clients regardless of whether foo.idl has any cpp_quote stuff.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153243">
				<div id="div-comment-153243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153243">
			March 10, 2004 at 10:28 pm</a>		</div>

		<p>The COM interface declaration is plain C/C++ once you unwrap the macros. Check out objidl.h, for example.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153253">
				<div id="div-comment-153253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153253">
			March 10, 2004 at 11:13 pm</a>		</div>

		<p>&gt; The COM interface declaration is plain C/C++<br />
<br />&gt; once you unwrap the macros.</p>
<p>Of course, but clients do not automatically include all the header files required for that unwrapping.  I already got lost, trying to hunt down everything that would have to be included for it.  Even though foo.cpp compiles while it&#8217;s including foo.h, it&#8217;s pretty hard to make fooclient.cpp compile when it&#8217;s including foo.h.  It seems to be easier to let fooclient.cpp include fooextra.h instead of foo.h.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153273">
				<div id="div-comment-153273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153273">
			March 11, 2004 at 12:25 am</a>		</div>

		<p>MIDL automatically sticks the necessary #include directives at the top of the generated .h file. But if you don&#8217;t like it, then fine, create two .h files.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153283">
				<div id="div-comment-153283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153283">
			March 11, 2004 at 12:52 am</a>		</div>

		<p>&gt; MIDL automatically sticks the necessary<br />
<br />&gt; #include directives at the top of the<br />
<br />&gt; generated .h file.</p>
<p>I guess VC++ .NET did that for you.  For me, VC++ 6 SP5 sticks some necessary #include directives at the top of foo.h, some buried further down in foo.h, some in StdAfx.h, and some at the top foo.c.  For a client (.exe) it didn&#8217;t generate as many #include directives as for the server (.dll), and didn&#8217;t generate all of the needed ones.  It&#8217;s not a matter of liking it or not, but I kept getting lost when following the chains of #include directives and could not get a client to compile when the client had #include foo.h.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153303">
				<div id="div-comment-153303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153303">
			March 11, 2004 at 1:04 am</a>		</div>

		<p>foo.c?  stdafx.h?  I was talking about foo.idl and the autogenerated foo.h. At the top of the foo.h that is produced by the MIDL compiler you&#8217;ll see</p>
<p>#include &quot;rpc.h&quot;<br />
<br />#include &quot;rpcndr.h&quot;<br />
<br />#include &quot;windows.h&quot;<br />
<br />#include &quot;ole2.h&quot;</p>
<p>These define the macros used by the interface declarations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-153683">
				<div id="div-comment-153683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153683">
			March 11, 2004 at 7:40 pm</a>		</div>

		<p>OK, I wasn&#8217;t clear when mentioning which #include directives were generated by which parts of VC++ 6.  The MFC DLL wizard generates foo.h and StdAfx.h.  The MIDL compiler generates foo_i.h, foo_i.c, and foo_p.c.</p>
<p>When a client&#8217;s .h file had #include foo.h, it didn&#8217;t compile.  I kept getting lost while trying to track down other header files that it needed.  From your latest reply I guess I should have tried to #include foo_i.h.</p>
<p>Meanwhile I finished making a foo_extra.h and refactored the server.  The COM interface is working for a VB client and the extra class is working for a VC++ client, so my real wish seems to have come true, it&#8217;s all one DLL.</p>
<p>Whether development effort can be further optimized by telling VC++ clients to #include foo_i.h instead of foo_extra.h, I&#8217;ll experiment again when I have time.</p>
<p>Hmm, now I see why cpp_quote can reduce the number of .h files.  Stuff that is presently in foo.h can be fed into foo_i.h through cpp_quote instead.  But then what happens if someone uses the VC++ 6 IDE to add a class member?  Additions to Ifoo go in foo.idl, but additions to Cfoo ordinarily go into foo.h.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-153763">
				<div id="div-comment-153763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-153763">
			March 11, 2004 at 9:46 pm</a>		</div>

		<p>True if you have other tools that munge header files then you can&#8217;t use cpp_quote. Personally I don&#8217;t use any of those wizardly things. If I want to edit something, I whip out &quot;vi&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-215303">
				<div id="div-comment-215303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/archive/2004/10/06/239019.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-215303">
			October 6, 2004 at 9:06 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-266993">
				<div id="div-comment-266993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2005/03/23/401151.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-266993">
			March 23, 2005 at 3:52 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-267013">
				<div id="div-comment-267013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2005/03/23/401157.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-267013">
			March 23, 2005 at 4:00 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-273033">
				<div id="div-comment-273033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/ericlippert/archive/2005/04/26/412199.aspx' rel='external nofollow' class='url'>Fabulous Adventures In Coding</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-273033">
			April 26, 2005 at 12:55 pm</a>		</div>

		<p>I&#8217;ve talked a few times in this blog about the semantics of the equality operators in various languages&#8230;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-496333">
				<div id="div-comment-496333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2007/04/24/2252261.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-496333">
			April 24, 2007 at 12:12 pm</a>		</div>

		<p>Use the vtable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-549643">
				<div id="div-comment-549643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://ramblings.aaronballman.com/2007/09/com_in_realbasic.html' rel='external nofollow' class='url'>Ramblings</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040205-00/?p=40733#comment-549643">
			September 14, 2007 at 9:00 am</a>		</div>

		<p>So in my last entry, I teased you with a hint that you can now work with COM using pure REALbasic code. Today, I&#8217;m going to tease you a bit more. ;-) Before you can understand how to write COM&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

