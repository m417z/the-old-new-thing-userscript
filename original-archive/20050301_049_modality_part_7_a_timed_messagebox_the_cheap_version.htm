<html>
<head>
<title>Modality, part 7: A timed MessageBox, the cheap version</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Modality, part 7: A timed MessageBox, the cheap version</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 1, 2005 / year-entry #50</td></tr>
<tr><td><b>Tags:</b></td><td>code;modality</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">As we noted at the end of part 3, now that you know the conventions surrounding the WM_QUIT message you can put them to your advantage. The more robust you want the TimedMessageBox function to be, the more work you need to do. Here's the cheap version, based on the sample in the Knowledge Base, but...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
<a href="http://blogs.msdn.com/oldnewthing/archive/2005/02/22/378018.aspx">
As we noted at the end of part&nbsp;3</a>,
now that you know the conventions surrounding
<a HREF="http://msdn.microsoft.com/library/en-us/winui/WinUI/WindowsUserInterface/Windowing/Windows/WindowReference/WindowMessages/WM_QUIT.asp">
the <code>WM_QUIT</code> message</a>
 you can put them to your advantage.
</p>
<p>
The more robust you want the <code>TimedMessageBox</code> function
to be, the more work you need to do.
Here's the cheap version,
based on the
<a HREF="http://support.microsoft.com/?scid=181934">
sample in the Knowledge Base</a>,
but with some additional bug fixes.
</p>
<pre>
static BOOL s_fTimedOut;
static HWND s_hwndMBOwnerEnable;

void CALLBACK
CheapMsgBoxTooLateProc(HWND hWnd, UINT uiMsg, UINT_PTR idEvent, DWORD dwTime)
{
    s_fTimedOut = TRUE;
    if (s_hwndMBOwnerEnable) EnableWindow(s_hwndMBOwnerEnable, TRUE);
    PostQuitMessage(42); // value not important
}

// Warning! Not thread-safe! See discussion.
int CheapTimedMessageBox(HWND hwndOwner, LPCTSTR ptszText,
    LPCTSTR ptszCaption, UINT uType, DWORD dwTimeout)
{
    s_fTimedOut = FALSE;
    s_hwndMBOwnerEnable = NULL;
    if (hwndOwner &amp;&amp; IsWindowEnabled(hwndOwner)) {
      s_hwndMBOwnerEnable = hwndOwner;
    }
    UINT idTimer = SetTimer(NULL, 0, dwTimeout, CheapMsgBoxTooLateProc);
    int iResult = MessageBox(hwndOwner, ptszText, ptszCaption, uType);
    if (idTimer) KillTimer(NULL, idTimer);
    if (s_fTimedOut) {			// We timed out
	MSG msg;
	// Eat the fake WM_QUIT message we generated
	PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
	iResult = -1;
    }
    return iResult;
}
</pre>
<p>
This <code>CheapTimedMessageBox</code> function acts just like
<a HREF="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/dialogboxes/dialogboxreference/dialogboxfunctions/messagebox.asp">
the <code>MessageBox</code> function</a>,
except that if the user doesn't respond
within <code>dwTimeout</code> milliseconds, we return -1.
The limitation is that only one timed message box can be active at a time.
If your program is single-threaded, this is not a serious limitation,
but if your program is multi-threaded, this will be a problem.
</p>
<p>
Do you see how it works?
</p>
<p>
The global static variable <code>s_fTimedOut</code>
tells us whether we generated
a fake <code>WM_QUIT</code> message as a result of a timeout.
When the <code>MessageBox</code> function returns, and we indeed timed out,
we use
<a HREF="http://msdn.microsoft.com/library/en-us/winui/WinUI/WindowsUserInterface/Windowing/MessagesandMessageQueues/MessagesandMessageQueuesReference/MessagesandMessageQueuesFunctions/PeekMessage.asp">
the <code>PeekMessage</code> function</a>
to remove the fake <code>WM_QUIT</code> message from the
queue before returning.
</p>
<p>
Note that we remove the <code>WM_QUIT</code> message only if we were the ones
who generated it.
In this way, <code>WM_QUIT</code> messages generated by other
parts of the program remain in the queue for processing by the
main message loop.
</p>
<p>
Note also that when we decide that the timeout has occurred,
we re-enable the original owner window before we cause
the message box to bail out of its message loop by posting a quit message.
Those are the rules for
<a href="http://blogs.msdn.com/oldnewthing/archive/2004/02/27/81155.aspx">
the correct order for disabling and enabling windows</a>.
</p>
<p>
Note also that we used a thread timer rather than a window timer.
That's because we don't own the window being passed in and therefore
don't know what timer IDs are safe to use.  Any timer ID we pick
might happen to collide with a timer ID being used by that window,
resulting in erratic behavior.
</p>
<p>
Recall that when you pass <code>NULL</code> as the
<code>hwnd</code> parameter to
<a HREF="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/timers/timerreference/timerfunctions/settimer.asp">
the <code>SetTimer</code> function</a>
and also pass zero as the 
<code>nIDEvent</code> parameter,
then the <code>SetTimer</code> function
creates a brand new timer, assigns it a unique ID, and returns the ID.
Most people, when they read that part of the specification for
<code>SetTimer</code>,
scratch their heads and ask themselves, "Why would
anybody want to use this?"
</p>
<p>
Well, this is one scenario where this is exactly what you want.
</p>
<p>
Next comes the job of making the function a tad more robust.
But before we do that, we'll need two quick sidebars.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-258253">
				<div id="div-comment-258253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">david</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258253">
			March 1, 2005 at 7:47 am</a>		</div>

		<p>Why doesn&#8217;t MessageBox re-enable the parent window?  After all, it disabled it&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258293">
				<div id="div-comment-258293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Johan Ericsson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258293">
			March 1, 2005 at 8:22 am</a>		</div>

		<p>Could you cause &quot;collataral damage&quot; to other message pumps? For instance, consider if you were in an STA, and the implementation of another timer function called an out-of-proc COM server. In that case, you might abort the COM call message pump, as well as the MessageBox message pump.</p>
<p>Is this really safe?<br />
<br />&#8212;<br />
<br />Actually, I just tested this and it appears as if the COM message pump just ignores the quit message. Ie: the COM message pump doesn&#8217;t exit just because a WM_QUIT message showed up. So, the message box doesn&#8217;t get dismissed until the out-of-proc COM call is completed.</p>
<p>I also tested CoWaitForMultipleHandles(). As I expected (since this method uses the COM modal loop), it also ignored the WM_QUIT message.</p>
<p>That&#8217;s interesting behavior&#8230; since if I was trying to write my own message pumping waiting routing, I would probably respond to WM_QUIT, thinking that&#8217;s what a good citizen does. That&#8217;s exactly the advice that you give in your &quot;Modality, part 3&quot; :&quot;if ever [&#8230;] you get a WM_QUIT message, you must not only exit your modal loop, but&#8230;&quot;. Apparently, this isn&#8217;t always true. You can delay exiting your modal loop if you feel that you&#8217;re important enough.</p>
<p>This is a really interesting series&#8230; thanks!!!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258323">
				<div id="div-comment-258323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Johan Ericsson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258323">
			March 1, 2005 at 8:40 am</a>		</div>

		<p>Oops. I made a mistake in my earlier posting. Actually, after further experimenting, it appears that a COM modal loop doesn&#8217;t process WM_TIMER messages. Therefore, the WM_TIMER message that invokes WM_QUIT doesn&#8217;t actually occur until after the COM modal loop is ended. So, my test was flawed.</p>
<p>I tried the following code:<br />
<br />    HANDLE hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);<br />
<br />    DWORD index;<br />
<br />    PostQuitMessage(42);<br />
<br />    HRESULT hr = CoWaitForMultipleHandles(COWAIT_WAITALL,INFINITE,1,&amp;hEvent,&amp;index);</p>
<p>which deadlocks the threads. This implies that CoWaitForMultipleHandles doesn&#8217;t handle WM_QUIT&#8230; (I think, unless I missed something again)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258333">
				<div id="div-comment-258333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com/' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258333">
			March 1, 2005 at 8:41 am</a>		</div>

		<p>G. Man: there are three different timers in the .NET Framework for three different purposes.</p>
<p>System.Threading.Timer is a wrapper for a dedicated timer thread. As such it will fire events on a thread-pool thread &#8211; it does not fire on the calling thread. The nearest Win32 API equivalent is CreateTimerQueueTimer.</p>
<p>System.Timers.Timer is a wrapper for System.Threading.Timer that endeavours to get back onto the correct thread, if the SynchronizingObject property is set to an object that implements ISynchronizeInvoke.</p>
<p>System.Windows.Forms.Timer wraps SetTimer. It uses a thread timer rather than a window timer.</p>
<p>The Win32 API also has a Waitable Timer kernel object.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258363">
				<div id="div-comment-258363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.eluent.com/freeware.htm' rel='external nofollow' class='url'>Doug Harrison</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258363">
			March 1, 2005 at 8:51 am</a>		</div>

		<p>To G. Man:</p>
<p>I think the documentation is no longer ambiguous, though it&#8217;s still confusing. I&#8217;d agree that the SetTimer API tries to do too much. The worst thing about allowing the user to specify the timer ID for window timers is that there&#8217;s no way to avoid stepping on existing timers. You just have to know somehow that (say) listview windows use timer IDs 42 and 43 internally to help manage their in-place editing windows (IIRC).</p>
<p>And what do you do when you receive a WM_TIMER for a timer ID you recognize as your own? Do you pass it on to the previous wndproc? Given that you may have usurped that timer (and disregarding the frequency issue), you might think you should, but then you find that (say) listview kills your timer unconditionally, no matter what its ID is.</p>
<p>So, WM_TIMER is not a message that can be harmlessly passed to the superclass. I think these are the rules. You must only handle IDs you recognize, and you mustn&#8217;t pass them to the superclass unless you wrote the superclass and know what it does. On the other hand, you must forward WM_TIMER for IDs you don&#8217;t recognize to the superclass with no additional processing. And when subclassing a window, you must determine its WM_TIMER IDs, which may not be documented, so that you don&#8217;t overwrite them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258383">
				<div id="div-comment-258383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258383">
			March 1, 2005 at 8:56 am</a>		</div>

		<p>&quot;There should be another SetTimer API function that doesnt use window handles.&quot;</p>
<p>There are many timer functions that don&#8217;t use window handles. Feel free to use those if you like.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258403">
				<div id="div-comment-258403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://dkgoodman.com/blog.html' rel='external nofollow' class='url'>Dave Goodman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258403">
			March 1, 2005 at 9:26 am</a>		</div>

		<p>As a user, I like self-destructing message boxes because I don&#8217;t have to waste a click dismissing them. There&#8217;s a situation, however, in which they irritate me.</p>
<p>Say the message box has a long timeout (especially since I&#8217;m a speed-reader) and I want to click its OK button to dismiss. So I click, but between my brain&#8217;s command to click and my finger executing it, the message box has self-destructed. Where does my click go? To the window behind it, of course. And what if there was a control behind it? Then I just clicked the wrong button. I have the same problem with pop-up windows stealing the focus.</p>
<p>One solution would be to have the message box start fading a few seconds before its timeout, warning me of its imminent demise. Another would be to disable clicks for a second or so after its destruction. I wish the OS had options for these situations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258423">
				<div id="div-comment-258423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeproject.com/script/articles/list_articles.asp?userid=152' rel='external nofollow' class='url'>Mike Dunn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258423">
			March 1, 2005 at 9:59 am</a>		</div>

		<p>Raymond&gt; Sorry for the OT question, but is there a MessageBox-like function that also has a &quot;don&#8217;t show me this again&quot; checkbox?<br />
<br />I was skimming MSDN a few months ago and came across such a function, but I didn&#8217;t write down the name, and now I can&#8217;t find it again. It wasn&#8217;t ShellMessageBox or SoftwareUpdateMessageBox, but something similar.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258453">
				<div id="div-comment-258453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nelson Faria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258453">
			March 1, 2005 at 10:36 am</a>		</div>

		<p>G. Man,</p>
<p>Passing NULL to SetTimer is valid(read MSDN)! The consequence is that the nIDEvent passed is ignored.<br />
<br />So, Windows wont send a WM_TIMER, but call the function specified in last arg.</p>
<p>From MSDN:</p>
<p>If the function succeeds and the hWnd parameter is NULL, the return value is an integer identifying the new timer. An application can pass this value to the KillTimer function to destroy the timer. </p>
<p>If the function succeeds and the hWnd parameter is not NULL, then the return value is a nonzero integer. An application can pass the value of the nIDEvent parameter to the KillTimer function to destroy the timer.</p>
<p>Best regards,<br />
<br />Nelson Faria<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258463">
				<div id="div-comment-258463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jerry Pisk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258463">
			March 1, 2005 at 10:58 am</a>		</div>

		<p>Dave, if a message is not important enough to stay on the screen until you read it then it should not be a modal message box.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258493">
				<div id="div-comment-258493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258493">
			March 1, 2005 at 11:48 am</a>		</div>

		<p>Mike: SHMessageBoxCheck.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258513">
				<div id="div-comment-258513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258513">
			March 1, 2005 at 12:56 pm</a>		</div>

		<p>Why would your code be not thread-safe? As far as I understand even timer-less timers are internally dispatched using messages so there shouldn&#8217;t be problems imo</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258523">
				<div id="div-comment-258523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258523">
			March 1, 2005 at 1:24 pm</a>		</div>

		<p>Consider if two threads call CheapTimedMessageBox at the same time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258533">
				<div id="div-comment-258533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258533">
			March 1, 2005 at 1:53 pm</a>		</div>

		<p>Mike: try this one instead <a target="_new" href="http://www.kkow.net/etep/code/mb/" rel="nofollow">http://www.kkow.net/etep/code/mb/</a> (and specifically how to make a messagebox with a checkbox <a target="_new" href="http://www.kkow.net/etep/code/assert.html" rel="nofollow">http://www.kkow.net/etep/code/assert.html</a>).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258543">
				<div id="div-comment-258543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeproject.com/script/articles/list_articles.asp?userid=152' rel='external nofollow' class='url'>Mike Dunn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258543">
			March 1, 2005 at 1:55 pm</a>		</div>

		<p>Jonathan&gt; Sweet, thanks!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-258553">
				<div id="div-comment-258553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon Potter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258553">
			March 1, 2005 at 3:01 pm</a>		</div>

		<p>&quot;Passing NULL to SetTimer is valid(read MSDN)! The consequence is that the nIDEvent passed is ignored.<br />
<br />So, Windows wont send a WM_TIMER, but call the function specified in last arg. &quot;</p>
<p>That&#8217;s if you specify a function in the last arg &#8211; if you don&#8217;t, WM_TIMER is posted as normal but with a null hwnd, so you need to process it in the GetMessage() loop.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-258263">
				<div id="div-comment-258263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">G. Man</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-258263">
			March 1, 2005 at 7:58 am</a>		</div>

		<p>SetTimer is just a broken API function, period.</p>
<p>SetTimer should not take an event id parameter as input. It should only return an event id. Then, it would be clear that I need to use the returned ID to reference the timer in future calls.</p>
<p>As it is, I can&#8217;t tell what&#8217;s up with the id input vs. the id returned. Is it safe to assume they are the same? Apparently not, since then it wouldn&#8217;t need to return an id. But if they are different, which id do I use in which circumstances?</p>
<p>Also, passing NULL as and hwnd should be illegal. There should be another SetTimer API function that doesnt use window handles.</p>
<p>It looks like an effort to solve this in .NET, but now there are three different &quot;timer&quot; classes just in the BCL. Don&#8217;t *even* get me started on that.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-260163">
				<div id="div-comment-260163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260163">
			March 1, 2005 at 7:23 pm</a>		</div>

		<p>3/1/2005 9:26 AM Dave Goodman</p>
<p>&gt; Another would be to disable clicks for a<br />
<br />&gt; second or so after its destruction.</p>
<p>Bingo.  That would catch a lot of situations where windows either suddenly appear (stealing focus) or disappear, causing the user&#8217;s click to go to a window different from the one the user intended.  Mr. Chen, please see if you can get that feature added.  Of course 1 second will be too long for some people and too short for others.</p>
<p>In the base note:</p>
<p>&gt; Any timer ID we pick might happen to collide<br />
<br />&gt; with a timer ID being used by that window,</p>
<p>How is it guaranteed that the timer ID picked by Windows won&#8217;t also collide with a timer ID being used by that window?  Even if Windows carefully chooses a timer ID different from all the ones that the window is using at this moment, the code for that window might still be intending to use a colliding timer ID a few seconds later.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-260183">
				<div id="div-comment-260183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260183">
			March 1, 2005 at 7:47 pm</a>		</div>

		<blockquote><p>
  Disable input for one second after focus changes. </p>
<p>It is not within my power to make the change you request but I will bring it to the attention of the people who can consider it. (I suspect however that the answer will be &quot;no&quot;. How often do you sit there with your finger poised waiting for a dialog box to appear so you can immediately type &quot;Y&quot; or click &quot;OK&quot; in response to a question you know is coming? Personally I do it a lot. Alt+FXN for example to exit Notepad without saving.) </p>
<p>&gt; How does Windows make sure its timer IDs don&#8217;t conflict with the ones that the window itself uses? </p>
<p>The window manager doesn&#8217;t doesn&#8217;t call SetTimer on windows it doesn&#8217;t own for precisely this reason.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-260213">
				<div id="div-comment-260213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CoMargo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260213">
			March 2, 2005 at 3:30 am</a>		</div>

		<p>Jonathan, Mike:<br />
<br />I&#8217;ve searched MSDN and Includes directory, but didn&#8217;t find such function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-260223">
				<div id="div-comment-260223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260223">
			March 2, 2005 at 7:15 am</a>		</div>

		<p>@CoMargo:<br />
<br /><a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/shlwapi/others/SHMessageBoxCheck.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/shlwapi/others/SHMessageBoxCheck.asp</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-260243">
				<div id="div-comment-260243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.eluent.com/freeware.htm' rel='external nofollow' class='url'>Doug Harrison</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260243">
			March 2, 2005 at 7:36 am</a>		</div>

		<blockquote><p>
  The window manager doesn&#8217;t doesn&#8217;t call SetTimer on windows it doesn&#8217;t own for precisely this reason.&lt;</p>
<p>Assuming the double negative was unintentional &lt;g&gt;, I guess in this context, &quot;owns&quot; means &quot;called RegisterClass&quot;. Is that correct?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-260253">
				<div id="div-comment-260253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260253">
			March 2, 2005 at 7:45 am</a>		</div>

		<p>Right. The implementor of the window class owns most aspects of a window: Messages in the WM_USER range, timers, window and class extra bytes&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-260433">
				<div id="div-comment-260433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.eluent.com/freeware.htm' rel='external nofollow' class='url'>Doug Harrison</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260433">
			March 2, 2005 at 11:23 am</a>		</div>

		<blockquote><p>
  Right. The implementor of the window class owns most aspects of a window: Messages in the WM_USER range, timers, window and class extra bytes&#8230; &lt;</p>
<p>It would be good to document how this applies to timers somewhere, assuming I haven&#8217;t simply overlooked it. Considerations like this aren&#8217;t exactly obvious, and they become especially blurred when using API abstractions like MFC. Many, many people don&#8217;t think twice about calling SetTimer on listview (CListView or CListrCtrl) and other window types, and usually, they get away with it.</p>
<p>I think the best solution would be to review the existing SetTimer usage and document it. For example, I observe listview to create timer IDs 42 and 43. Maybe it would be possible to designate a timer ID range [1,n] for all standard window types that programs could use for themselves. I&#8217;d guess that if n were (say) as large as 40, it would bless what many programs are doing anyway. This would also help avoid accidentally breaking them in the future.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-260503">
				<div id="div-comment-260503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260503">
			March 2, 2005 at 5:30 pm</a>		</div>

		<p>3/1/2005 7:47 PM Raymond Chen<br />
<br />&gt;&gt; Disable input for one second after focus<br />
<br />&gt;&gt; changes.<br />
<br />&gt;<br />
<br />&gt; (I suspect however that the answer will<br />
<br />&gt; be &quot;no&quot;. How often do you sit there with<br />
<br />&gt; your finger poised waiting for a dialog box<br />
<br />&gt; to appear so you can immediately type</p>
<p>The problem is exactly the opposite.  How often do you sit there typing quickly into Outlook, Word, Internet Explorer, etc., and suddenly find that your keystroke has been stolen by a dialog box?  Some time ago you replied to another commenter showing that you are aware of this problem.  Perhaps less often you&#8217;ve been doing another opposite, not having your finger poised but happening to notice that a dialog box popped up a few minutes ago, and when you want to click you happen to be a microsecond too late because it was a Timed MessageBox.</p>
<p>Here Mr. Goodman proposed a solution, and it sure looks like a good solution.</p>
<p>&gt; Personally I do it a lot.</p>
<p>As frequently as your ordinary keystrokes into Outlook, Word, etc.?  Or maybe not, but your priorities say you want to take the risk in order to speed up the response in these situations.  Well, that is why I said that 1 second would be too slow for some people.  But I&#8217;ll bet Mr. Goodman and I are not the only people who have been hit by keystrokes or clicks getting stolen by the wrong app, and we&#8217;re not the only ones who would like to get a 1-second (or settable) block when focus changes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-260513">
				<div id="div-comment-260513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260513">
			March 2, 2005 at 5:48 pm</a>		</div>

		<p>There are sometimes you want to block input after a focus change, and sometimes you don&#8217;t. In the Alt+FXN case I don&#8217;t want input blocked &#8211; that ruins typeahead. </p>
<p>If computers could read your mind, maybe it could block input based on your mental state.</p>
<p>Nevertheless, I forwarded the suggestion you sent to me via email to the people who are responsible for input and focus changes for their consideration.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-260543">
				<div id="div-comment-260543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spacebunny.xepher.net/' rel='external nofollow' class='url'>KJK::Hyperion</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260543">
			March 3, 2005 at 3:17 am</a>		</div>

		<p>I&#8217;m surprised the WM_TIMER message even gets dispatched. DispatchMessage can&#8217;t dispatch messages posted to no window, so you should never rely on this trick working for any modal loop. The documentation recommends installing a hook for the calling thread:</p>
<p>&quot;Messages that are not associated with a window cannot be dispatched by the DispatchMessage function. Therefore, if the recipient thread is in a modal loop (as used by MessageBox or DialogBox), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-260683">
				<div id="div-comment-260683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260683">
			March 3, 2005 at 9:25 am</a>		</div>

		<p>KJK: I&#8217;ve submitted a correction to the documentation. There should be words to the effect of &quot;As a general rule&quot; at the start of that first sentence. The DispatchMessage documentation mentions WM_TIMERs as dispatchable provided the lParam is NULL. Note however that the documentation you quoted comes from PostThreadMessage, and you can&#8217;t post a WM_TIMER message; therefore, the sentence is correct in context although perhaps not strictly correct in an absolute sense.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-260843">
				<div id="div-comment-260843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260843">
			March 3, 2005 at 6:06 pm</a>		</div>

		<p>3/2/2005 5:48 PM Raymond Chen</p>
<p>&gt; There are sometimes you want to block input<br />
<br />&gt; after a focus change, and sometimes you<br />
<br />&gt; don&#8217;t. In the Alt+FXN case I don&#8217;t want<br />
<br />&gt; input blocked &#8211; that ruins typeahead.</p>
<p>In the intended typeahead case you don&#8217;t want input blocked.  Perhaps the condition should be that the new window is owned by the window that had focus?  In that case the user might have expected the focus change and typed ahead.</p>
<p>If the new (or newly focused) window isn&#8217;t owned by the window that previously had focus, then let&#8217;s try to consider which cases the user might have intended keystrokes or clicks to go to them immediately.  If the window was already partly or fully displayed, and the user clicked in a part that was already displayed in order to give it focus, that would be one example.  I can&#8217;t think of other examples at the moment.  In other cases I think it&#8217;s pretty obvious that the user didn&#8217;t intend input to go to that window, until the user has had time to notice what window is now there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-260853">
				<div id="div-comment-260853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-260853">
			March 3, 2005 at 6:18 pm</a>		</div>

		<p>What about the case where you visit a web site and know that it&#8217;s going to display a popup window after 5 seconds, so you wait anxiously and the moment the popup appears you click the X / hit Alt+F4. How can the system distinguish this (an expected popup, not owned by the previous focus window) from an unexpected popup? I understand the value of underlying principle, but it in large part requires understand the user&#8217;s frame of mind, something computers aren&#8217;t very good at yet.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-261343">
				<div id="div-comment-261343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-261343">
			March 6, 2005 at 6:06 pm</a>		</div>

		<p>If you know exactly where that X is going to appear and be clickable, then you want to set your duration of disabled keyboard/mouse input to 0 instead of 1 second.  I think there are a lot of people who will still find 1 second preferable, because the damage done by not having it is sometimes far more severe.  Let us have the option.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-261363">
				<div id="div-comment-261363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-261363">
			March 6, 2005 at 6:42 pm</a>		</div>

		<p>As I already noted to you via email, I sent your proposal off to the team that would be responsible for it. But beware &quot;too many options&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-261593">
				<div id="div-comment-261593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-261593">
			March 7, 2005 at 4:24 pm</a>		</div>

		<blockquote><p>
  As I already noted to you via</p>
<p>via your blog here.  Yes you did, but you keep opposing the idea.  So please let me add another bit in support of Dave Goodman&#8217;s proposal.  Again in response to your hypothesis:</p>
<p>&gt; so you wait anxiously and the moment the<br />
  <br />&gt; popup appears you click the X / hit Alt+F4</p>
<p>Yes, and a focus-stealing application unrelated to your web browser window pops up its window and you Alt+F4 that one before reading it.  Suddenly you&#8217;ll wish you had agreed with us.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-261603">
				<div id="div-comment-261603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050301-00/?p=36333#comment-261603">
			March 7, 2005 at 4:28 pm</a>		</div>

		<p>I&#8217;m not opposed to the idea. I&#8217;m just pointing out that there are places where the &quot;one second delay&quot; would be undesirable. Perhaps heuristics could be added to recognize those scenarios. I don&#8217;t know. (For example, maybe there&#8217;s a program that puts up ten message boxes in a row that you want to dismiss. You used to be able to just hold down the ESC key and they all go away. Now they disappear one per second. Yes, there&#8217;s the risk that I might have dismissed the wrong message box. Is the risk worth the benefit?)</p>
<p>But as I have already noted twice now, I forwarded your message to the people responsible and it is their decision at this point. My opinion carries no weight. In particular I did not include my opinion when I forwarded your suggestion to them.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

