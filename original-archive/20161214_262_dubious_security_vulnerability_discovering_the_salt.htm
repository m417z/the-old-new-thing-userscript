<html>
<head>
<title>Dubious security vulnerability: Discovering the salt</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Dubious security vulnerability: Discovering the salt</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 14, 2016 / year-entry #263</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>22</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The salt is not a secret.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
A security vulnerability report came in that went
something like this:
</p>
<blockquote CLASS=q>
<p>
The XYZ component has a feature where it can cache
the password used to access a network resource.
It encrypts this password with the
<code>Crypt&shy;Protect&shy;Data</code>
function,
using the
default options so that
only the user who encrypted
the data can decrypt it.
It then saves this encrypted password in a file that is
accessible only to the user.
</p>
<p>
The security vulnerability is that
when the component encrypts the data,
it uses a predictable entropy,
namely the name of the network resource.
This means that any program running as the user
can open the file that has the encrypted password,
pass the name of the network resource as the
entropy,
and then call the
<code>Crypt&shy;Unprotect&shy;Data</code>
function to decrypt the password.
</p>
<p>
The XYZ component needs to use an entropy
that cannot be predicted.
Otherwise, any program running as the user
can extract the password.
</p>
</blockquote>
<p>
When you protect data with the
<code>Crypt&shy;Protect&shy;Data</code> function,
you can optionally pass some additional data
that will be used as part of the encryption key.
The
<code>Crypt&shy;Protect&shy;Data</code> function
calls this extra data
<i>entropy</i>,
but a more common name for it is
<a HREF="https://en.wikipedia.org/wiki/Salt_(cryptography)">
<i>salt</i></a>.
</p>
<p>
It is not important that the salt be unpredictable.
What's important is that the salt is different for each
network resource.
</p>
<p>
The salt serves multiple purposes.
</p>
<p>
One use for the salt is to prevent someone from
taking an encrypted password from one network resource
and applying it to another network resource.
The idea here is that somebody might get their hands
on the file,
and even though they cannot decrypt the password,
they can copy the encrypted password from the entry for
one network resource and paste it into the entry for
another network resource,
trying to take advantage of the fact that
people often reuse passwords.&sup1;
Alternatively, the attacker can expend effort to decrypt
one password, and once they do, they can look for the
same encrypted data elsewhere and know that they have
the password for that other resource as well.
</p>
<p>
Salting the encryption with the name of the network
resource
foils this trick.
Since each password is encrypted with a different salt,
if you take
an encrypted password from one network resource
and try to decrypt it for another network resource,
the decryption will fail because the salt (and therefore
the decryption key) does not match.
</p>
<p>
Another purpose for the salt is to make it
more computationally expensive to precalculate
passwords.
A common way of attacking a stolen password database
is to take a dictionary of possible passwords,
and encrypt each individual password.
You then invert the table so that the encrypted
password is the lookup key and the decrypted password
is the value.
</p>
<p>
Building this giant table takes a long time,
but once you have it, you can attack a large number
of passwords at once because you can just take every
stolen encrypted password and look it up in the table.
If it's in the table, then you have the decrypted password
almost immediately.
</p>
<p>
The salt foils this attack:
Since each password is encrypted with a different salt,
somebody who wants to mount a reverse-lookup
attack would have to have multiple reverse lookup tables,
one for each salt.
And if you give each password a different salt,
then the reverse-lookup attack completely dissolves,
because your reverse-lookup table is good for attacking
only one password.
</p>
<p>
Another clue that the salt is not sensitive information
is the fact that on classic Unix systems, the master password
database <code>/etc/passwd</code> is readable by everyone.
It encrypts each password with a different salt,
and the salt is <i>readable by anyone</i>.
</p>
<p>
So if you're concerned that some Windows component
doesn't do a good job of protecting its salt,
then you should be even more concerned that classic
Unix systems don't even try to protect the salt at all!
</p>
<p>
<b>Bonus chatter</b>:
This report is even more bogus even if you get past the
fact that the salt is easily guessed.
Even if the salt were hard to guess,
you can still figure out what it is because you can
reverse-engineer the code to the XYZ component and see
how it calculates the salt.
And then you can replicate this calculation in your own
rogue program.
</p>
<p>
The algorithm for generating the salt needs to be
deterministic, because you have to be able to generate
the same salt that was used to encrypt the data
in order to decrypt it.
And that algorithm must operate on publically-known data,
because it is generating the inputs to the decryption function!
If the salt were itself encrypted, then you've begged
the question: How do you decrypt the salt?
Is it
<a HREF="https://en.wikipedia.org/wiki/Turtles_all_the_way_down">
salt all the way down</a>?
</p>
<p>
<b>Bonus bonus chatter</b>:
An attacker wouldn't even need to extract the salt
in order to get the password.
The weak salt is a complete red herring.
Since the XYZ component runs in-process,
the decrypted password is already in
memory in the same process.
So the attacker just needs to load the XYZ
component and ask it to connect to the network
resource using the cached password.
The XYZ component will decrypt the password,
and now the decrypted password is in the
attacker's process.
It just needs to go copy it.
</p>
<p>
Now, the attacker could spend a lot of effort
studying the XYZ component to see where
it stores the decrypted password in memory.
Or it can just
detour the
<code>Crypt&shy;Unprotect&shy;Data</code>
function!
The XYZ component will call
<code>Crypt&shy;Unprotect&shy;Data</code>,
and that will call the detour.
The detour passes the call through to the
original function, and then inspects the result.
Bingo, instant password.
</p>
<p>
&sup1;
Or create a new entry for a network resource
that the attacker controls, and copy the encrypted
password to it.
If you can convince the user to connect to your
rogue server, then you will receive the decrypted password.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (22)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-koldude even thread-even depth-1 parent" id="comment-1276895">
				<div id="div-comment-1276895" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276895">
			December 14, 2016 at 7:19 am</a>		</div>

		<p>This reminds me of the sort of things you get a lot from <a>Security Theater Auditors</a> that don&#8217;t know what they are doing and are just hired to shift liability.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-koldude odd alt depth-2 parent" id="comment-1276905">
				<div id="div-comment-1276905" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276905">
			December 14, 2016 at 7:20 am</a>		</div>

		<p>darn it removed the link: <a href="http://serverfault.com/q/293217" rel="nofollow">http://serverfault.com/q/293217</a></p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3" id="comment-1276945">
				<div id="div-comment-1276945" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">CarlD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276945">
			December 14, 2016 at 9:43 am</a>		</div>

		<p>Just.  Wow.  Thanks for that link!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-3 parent" id="comment-1276975">
				<div id="div-comment-1276975" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wayne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276975">
			December 14, 2016 at 10:27 am</a>		</div>

		<p>That is the scariest thing I Read in a long time.  I wish I could unread it.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-cheong even depth-4" id="comment-1277015">
				<div id="div-comment-1277015" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277015">
			December 14, 2016 at 5:43 pm</a>		</div>

		<p>Agreed. I wonder how that auditor could stay in the industry that long (assuming he didn&#8217;t lie about this), and not be fired when the mail is CC-ed to the CTO.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1276915">
				<div id="div-comment-1276915" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276915">
			December 14, 2016 at 8:43 am</a>		</div>

		<p>Why are these passwords being encrypted and decrypted in the first place, rather than hashed?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2" id="comment-1276925">
				<div id="div-comment-1276925" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276925">
			December 14, 2016 at 9:15 am</a>		</div>

		<p>Because the network resource doesn&#8217;t let you sign in with a userid and a hash.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-scott-brickey odd alt thread-even depth-1 parent" id="comment-1276935">
				<div id="div-comment-1276935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Scott+Brickey' rel='external nofollow' class='url'>Scott Brickey</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276935">
			December 14, 2016 at 9:18 am</a>		</div>

		<p>bigger question&#8230; with the performance abilities to brute force password attack (hashcat), which can probably be given a specific salt / entropy&#8230; does the encryption use effort based algorithms or linear time algorithms? I suspect the latter (I generally tend to assume the worst when it comes to security), which then becomes the actual weakness</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2" id="comment-1276986">
				<div id="div-comment-1276986" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276986">
			December 14, 2016 at 10:36 am</a>		</div>

		<p>Pretty sure you have mixed up encryption and hashing in your question. (only hashing has difficulty algorithms) Second, I don&#8217;t think it is applicable. Without getting sufficiently high level access there is no access to encrypted password (and once there, you don&#8217;t really need it anymore) or you get code running in correct process under correct account and then see this article.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1276936">
				<div id="div-comment-1276936" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Colin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276936">
			December 14, 2016 at 9:25 am</a>		</div>

		<p>&#8220;And if you give each password a different salt, then the reverse-lookup attack completely _dissolves_&#8221;</p>
<p>Pun intended? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1276955">
				<div id="div-comment-1276955" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Touset</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276955">
			December 14, 2016 at 10:03 am</a>		</div>

		<p>Raymond, you are confusing a salt with an initialization vector or nonce. Salts apply to password hashing, and are not relevant to symmetric encryption; CryptProtectData is a symmetric encryption function and not a password hash. The purpose of an IV in this scenario is vastly different, and has nothing to do with rainbow tables.</p>
<p>It&#8217;s hard to tell exactly what that API actually does under the hood because its cryptographic guarantees don&#8217;t seem to be documented (which is an extraordinarily poor idea for an encryption function), but if it&#8217;s using *only* the optional entropy parameter as the value of its IV, it&#8217;s entirely plausible then it&#8217;s highly plausible there *is* a security vulnerability here, if not the one originally reported. On the other hand, if the optional entropy is just AAD passed to an AEAD cipher, then using the name of the network resource here is completely acceptable.</p>
<p>Either way, the lack of documentation about what security guarantees that function actually provides makes it a cryptographic landmine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1276965">
				<div id="div-comment-1276965" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">alexi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276965">
			December 14, 2016 at 10:21 am</a>		</div>

		<p>I apoliogise if I am trumpeting my ignorance to all and sundry, but doesn&#8217;t this type of &#8220;vulnerability&#8221; stem from a confusion between &#8220;salting&#8221; (protection against precomputed dictionaries) versus &#8220;key stretching&#8221; (protection against brute force attacks)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1276985">
				<div id="div-comment-1276985" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yukkuri</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276985">
			December 14, 2016 at 10:30 am</a>		</div>

		<p>I love these dubious vulnerability posts :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1276995">
				<div id="div-comment-1276995" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1276995">
			December 14, 2016 at 10:50 am</a>		</div>

		<p>The problem has a difficult solution if you need to provide the clear password to the remote server. You could (and, in fact, you *should*) generate a different, pseudo-random salt for every password (I use the hash of the concatenation of the current timestamp with a short pseudo-random string). But you have to store it along with the encrypted password, and if you use a two-way function, attackers would have enough information to decrypt the password. Encrypting a password with a two-way function only dissuade occasional lookers, and is never a serious security measure. No hash, no security: even the weakest hash is (marginally) more secure than the most complex reversible algorithm.</p>
<p>Alternatively, you could ask the user for a &#8220;master password&#8221; and use it as the salt (without storing it on disk, of course). But you would need to ask the user for the master password at least once for every session a network connection is made, and that would defeat the purpose of storing the password. It would only make a difference if the software made several connections to different servers (the user would have to enter the password only once instead of several times), but that is an unlikely scenario.</p>
<p>See that I&#8217;m considering that the process&#8217; private memory is safe, and thus I&#8217;m free to store plain text passwords there (but not on disk). If you need to make sure you don&#8217;t store plain passwords even in private memory, the rules change completely, and one-way hashes are mandatory.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-fredericmagnyf even depth-2" id="comment-1277045">
				<div id="div-comment-1277045" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277045">
			December 15, 2016 at 2:19 am</a>		</div>

		<p>If you have a master password, why use it as salt rather than as base input for deriving the key to decrypting the password? (of course it still needs to be accompanied by salt; personnally I&#8217;d store this salt in plaintext alongside the encrypted password)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1277025">
				<div id="div-comment-1277025" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277025">
			December 14, 2016 at 6:05 pm</a>		</div>

		<p>I may be mistaken, but I think that CryptProtectData already uses a master password.  (Specifically, the user&#8217;s logon password.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1277035">
				<div id="div-comment-1277035" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Koopa</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277035">
			December 14, 2016 at 11:55 pm</a>		</div>

		<p>&#8220;Bonus bonus chatter&#8221;? It really is christmas :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1 parent" id="comment-1277195">
				<div id="div-comment-1277195" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Petr Kadlec</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277195">
			December 16, 2016 at 8:00 am</a>		</div>

		<p>OK, I am confused about the “classic Unix” remark. OK, there was a time when Unix systems stored password _hashes and salts_ in world-readable /etc/passwd. Nowadays, publicizing _hashes_ is considered a bad idea (especially when used with an outdated hashing algorithm, among others limiting the password to eight characters), so Unix systems moved _hashes and salts_ to non-readable /etc/shadow. Was there a time when hashes were private, while salts public? Or, why say “the salt is readable by anyone”?? It feels like the whole two paragraphs are just a red herring. Also, I’d say the terminology here is a bit mixed. “Salt” is generally used for (password) _hashing_, not password _encryption_. For encryption, we typically have initialization vectors, nonces, and tweaks.</p>
<p>(Even though when discussing “dubious security vulnerabilities”, it is difficult to distinguish “this is wrong because the original idea is wrong” from “this explanation of the original idea is wrong”, it may be just a matter of taste/opinion.)</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1277217">
				<div id="div-comment-1277217" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277217">
			December 16, 2016 at 11:34 am</a>		</div>

		<p>Yes, I meant super-classic Unix, where the /etc/passwd file was world-readable. (Because that&#8217;s the Unix I had when I grew up.)</p>
<p>And yes, I&#8217;m confusing salts with nonces. Encryption is not my field of expertise.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3" id="comment-1277226">
				<div id="div-comment-1277226" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277226">
			December 17, 2016 at 3:31 am</a>		</div>

		<p>These days /etc/passwd is still world-readable, and has to be such that numeric user-IDs can be converted to usernames, and vice-versa.</p>
<p>But (salted) hashes are now stored in a non-readable file.  I think the parent was asking whether there was ever a time when the hashes were private but the salts were public, and I suspect there never was such a time.  But it doesn&#8217;t spoil your illustration :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-3 parent" id="comment-1277255">
				<div id="div-comment-1277255" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jack</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277255">
			December 18, 2016 at 2:16 pm</a>		</div>

		<p>Very old Unix (including Version 7 and the like) did encrypt passwords rather than hash them, as far as I&#8217;m aware.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-4" id="comment-1277425">
				<div id="div-comment-1277425" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20161214-00/?p=94935#comment-1277425">
			December 19, 2016 at 8:28 pm</a>		</div>

		<p>If I remember rightly, they used an encryption algorithm to generate a hash.  The password wasn&#8217;t encrypted, it was used as the encryption key.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

