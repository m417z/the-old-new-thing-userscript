<html>
<head>
<title>Take it easy on the automatic retries</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Take it easy on the automatic retries</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 7, 2005 / year-entry #339</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>54</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">When I saw a discussion of how to simulate retry via try/catch, using as inspiration a Ruby function that retried a network operation three times before finally giving up, I felt the need to caution against automatic retry. Your natural inclination when faced with a failure that has a good chance of being caused by...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>When I saw a discussion of <a href="http://blogs.msdn.com/abhinaba/archive/2005/10/01/476026.aspx"> how to simulate retry via try/catch</a>, using as inspiration a Ruby function that retried a network operation three times before finally giving up, I felt the need to caution against automatic retry.</p>
<p> Your natural inclination when faced with a failure that has a good chance of being caused by a transient condition is to retry it a few times. The second, or possibly third, try will finally work, and your function can continue. The user gets what they want without an annoying "Abort, Retry, Cancel"-type dialog, one less support call for you. What could possibly go wrong? </p>
<p> I've seen this go wrong many times. So much so that my personal recommendation is simply never to retry automatically. If something fails, then report the failure. If the user wants to retry, let them be the ones to make that decision. </p>
<p> Here's how it goes wrong. This is a real example, but the names have been removed because I'm not trying to ridicule anybody; I want you to learn. There was a networking feature that implemented some type of distributed networking capability. It is the nature of networks to be unreliable, so the implementors of the functionality decided to retry ten times before finally giving up. The operation they were performing was implemented by another group, and that other group also decided to retry five times before giving up. That second group called a networking function with a timeout of thirty seconds. Meanwhile, the application that used this networking capability attempted the operation fifteen times. </p>
<p> Let's do some math. At the bottom was a timeout of thirty seconds. Five retries comes out to two and a half minutes. Ten retries from the next layer brings this to twenty-five minutes. Fifteen retries from the application layer takes us to over six hours. An operation that would normally have completed (with a failure code) in thirty seconds became, through the multiplicative effect of multiple layers of retrying, a six-hour marathon. And then you get a very angry call from one of your customers demanding that you deliver them a fix yesterday because this problem is taking down their entire sales force. </p>
<p> (<a href="http://www.codeproject.com/system/NoDeleteDelay.asp">Explorer is hardly blameless in this respect</a>. Though the article's attempt to patch shell32.dll is doomed to failure since shell32.dll is frequently updated by security patches.) </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (54)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-319363">
				<div id="div-comment-319363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.rotd.org/' rel='external nofollow' class='url'>Andreas Magnusson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319363">
			November 7, 2005 at 10:35 am</a>		</div>

		<p>I have many nice anecdotes on retries&#8230;once I refactored a device driver where the original implementor had decided to retry all operations 3 times instead of checking any error codes.</p>
<p>But my all time favourite (because it took me two weeks to find) was in a network driver where someone had deiced that the correct way to write to the cards registers would be through a:</p>
<p>do<br />
<br />{<br />
<br />  outp(reg, val);<br />
<br />} while(inp(reg) != val);</p>
<p>Never caring that one of the bits in one of those registers was write-only&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319373">
				<div id="div-comment-319373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gene</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319373">
			November 7, 2005 at 10:47 am</a>		</div>

		<p>And the tough thing is this sort of stuff is hard to test. It works fine on a normally reliable network. Plus you have to have code visibility down to almost the driver level to fix it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319393">
				<div id="div-comment-319393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319393">
			November 7, 2005 at 11:56 am</a>		</div>

		<p>Well, this really explains how things get so slow on the modern computer which should, theoretically, be able to process billions of instructions per second.</p>
<p>My biggest problem are the delays to change the current directory to the network folder which is not available. Apparently, the process gets stuck, even if it tries a thing like that from the separate thread (I didn&#8217;t try that myself, but I use Total Commander and the author claims that the symptoms are as described).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319413">
				<div id="div-comment-319413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">andy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319413">
			November 7, 2005 at 12:18 pm</a>		</div>

		<p>Another common mistake I see often is increasing a server timeout value when it starts getting overloaded.  What happens then is that those long running operations take up all the threads on the server and none of the other operations get a chance to run, and the entire server goes down, instead of just a few slow operations being denied.</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319423">
				<div id="div-comment-319423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dhchait</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319423">
			November 7, 2005 at 12:24 pm</a>		</div>

		<p>This is a solved problem; it&#8217;s called &quot;Exponential Backoff&quot;.  Subsequent retries wait longer and longer period of time (exponential); introduce a random small jitter to prevent several clients from harmonizing, and collar it at some max timespan to prevent it from getting ridiculous.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319433">
				<div id="div-comment-319433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://ebersys.blogspot.com' rel='external nofollow' class='url'>BlackTigerX</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319433">
			November 7, 2005 at 12:39 pm</a>		</div>

		<p>I use the retry technique (3 times) on systems where we have about 100 computers running the same process, if I had the user do the &quot;retry&quot; every time the network failed, we couldn&#8217;t operate at all</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319443">
				<div id="div-comment-319443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319443">
			November 7, 2005 at 12:54 pm</a>		</div>

		<p>Daniel: Your solution doesn&#8217;t take into account the fact that even though you collar the retries, if the three guys in the chain below you all do the same thing the problem is still there. It&#8217;s just not as bad. Your solution only works if you are in absolute control of the whole sequence of operations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319453">
				<div id="div-comment-319453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Laurence Hartje</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319453">
			November 7, 2005 at 12:58 pm</a>		</div>

		<p>Is this related to what happens when you click on a network drive in Explorer, when the destination machine is unavailable? I&#8217;ve seen this hang up the specific Explorer window for over a minute&#8230;</p>
<p>And annoyingly enough Explorer is &quot;smart&quot; enough to not open a duplicate window &#8212; so when the &quot;My Computer&quot; window is sitting there and spinning, I can&#8217;t open another &quot;My Computer&quot; window to try to navigate to the mapped drive. </p>
<p>The only work around I&#8217;ve figured out is to start / run / explorer &#8211; but it&#8217;s still annoying.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319463">
				<div id="div-comment-319463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.picoposter.com' rel='external nofollow' class='url'>K.T.</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319463">
			November 7, 2005 at 1:09 pm</a>		</div>

		<ul>
<li>&quot;Exponential Backoff&quot;
<p>Daniel, doesn&#8217;t this make this particular problem exponentially worse?</p>
<p>To me it sounds like &quot;Exponential Backoff&quot; is designed to stop DOS rather than solve timeout woes.</li>
</ul>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319473">
				<div id="div-comment-319473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter Ibbotson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319473">
			November 7, 2005 at 1:34 pm</a>		</div>

		<p>This really does depend, for example with SQL server clustering if you are trying to keep connections over the server swap transparently from your upper layers then you need to have retry code that pops up a box to tell the user to wait.</p>
<p>Often a good idea is to auto-retry but give the user the chance to abort. Basically after two to three seconds users assume the PC has hung completely, giving them feedback that if they wait it may recover (and doing that recovery automagically).</p>
<p>The real problem here is that users won&#8217;t wait for very long</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319493">
				<div id="div-comment-319493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319493">
			November 7, 2005 at 1:54 pm</a>		</div>

		<p>Raymond&#8217;s example provides a good argument for open source. Most people aren&#8217;t going to sit there and rewrite their software, but when your whole sales force is down it would be nice and easy to just change that 15 to 1 and get on with business.</p>
<p>Raymond is also correct that most times you do not actually want to retry. The only times you would are in situations where you know that specific errors are transient. For example, pretty much every UNIX system call can exit with the error EINTR if a signal was caught during the call, so after every important system call you might want to check for EINTR and try again because the error condition is transient. EVERY OTHER ERROR you would not want to retry though.</p>
<p>This is particularly maddening with something like Explorer which will sit there trying to delete something 5 times because whatever is causing it to fail (like Explorer has the directory open) isn&#8217;t likely to clear up spontaneously. It&#8217;s even worse when the function that&#8217;s being retried is one that has side-effects. I&#8217;ve seen accounts get locked out because WinXP tried to log somebody in with the same incorrect credentials 3 times in a row! As if the wrong password would somehow become correct?</p>
<p>On the other hand, there is nothing worse than having a program so stupid that it gives up at the first sign of failure. Most FTP programs are like this. Network connections are unreliable and prone to failure, so any large transfer has a decent probability of not finishing. If there is a transient failure (and most FTP failures are transient) retry automatically and let the user know so they can cancel it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319503">
				<div id="div-comment-319503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319503">
			November 7, 2005 at 1:55 pm</a>		</div>

		<p>If the user wants to retry, let them be the ones to make that decision.</p>
<p>Then there&#8217;s the programs that follow the &quot;fail once, never try again, even when the user wants to&quot; method. I just now had a certian microsoft program tell me &quot;The service is busy&quot; after a connection failure, then when the &quot;Retry&quot; button was pressed, the same message reappeared instantly, without an attempt to connect. Closing an re-opening the program fixed the issue, although it can be more annoying when the program decides that Outlook is using it&#8217;s services and refuses to close&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-319513">
				<div id="div-comment-319513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319513">
			November 7, 2005 at 2:04 pm</a>		</div>

		<p>If only it were as easy as &quot;changing that 15 to a 1&quot;. It&#8217;s really fifteen different &quot;1&quot;s scattered all over the place.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319523">
				<div id="div-comment-319523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.guyswithtowels.com' rel='external nofollow' class='url'>Tim</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319523">
			November 7, 2005 at 2:19 pm</a>		</div>

		<p>&quot;the article&#8217;s attempt to patch shell32.dll is doomed to failure since shell32.dll is frequently updated by security patches.&quot;</p>
<p>Wouldn&#8217;t it, then, be super-duper fantastic if one day shell32.dll got patched to not retry 5 times by, ooh, someone on the Shell team? :-)</p>
<p>&quot;Exponential Backoff&quot;</p>
<p>Isn&#8217;t that for negotiating who gets access to a resource &#8211; it&#8217;s nothing to do with network reliability (e.g. link might be down)? It&#8217;s used by stuff like CSMA/CD (by e.g. ethernet) etc.</p>
<p>&quot;And the tough thing is this sort of stuff is hard to test. It works fine on a normally reliable network.&quot;</p>
<p>I&#8217;ve always wanted a much simpler way of writing a file system driver on Windows, so that I can write file systems/layers that fail on demand.  e.g., this file is undeleteable, when I read the 2nd 8k of data from this file, I want it to fail, etc. Or, for example, many years ago, I wanted a CD filing system that would mount an ISO and then simulate the speed of a CD drive seeks/reads, etc.  Unfortunately, this seems to require IFS and kernel coding, which is the programming equivalent of paying a friend to come and stamp on your reproductive organs every 15 minutes. I&#8217;ve often wondered if it would be possible to write a generic IFS stub that somehow talked to userland processes, so you could just provide a nice simple set of entry points that could allow you to develop a filing system using the usual tools without having to get into kernel debugging.  But I&#8217;ve never had the time.  Or the protective clothing :-).  Plus, the last time I checked, IFS dev involved paying &#163;1000 for a header file, or downloading some iffy GPL&#8217;d subset of it.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319533">
				<div id="div-comment-319533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pass</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319533">
			November 7, 2005 at 2:25 pm</a>		</div>

		<p>When logging on the network with windows, it tries up to 3 times with &quot;Password&quot;, &quot;PASSWORD&quot; and &quot;password&quot;. Some servers has a maximum logon-try before the account is locked (3 failed tries=lock for 30 min), when retrying automatically 3 times, the user must type the correct password at the first try or wait for 30 min. This does also confuse the user what his password actually is.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319543">
				<div id="div-comment-319543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319543">
			November 7, 2005 at 2:34 pm</a>		</div>

		<p>Thousand retries and lots of waiting?  Sounds like DCOM to me.  I feel sorry for the Industrial Automation folks who bought hook, like, and sinker into that stuff and spun their whole &quot;OPC&quot; methodology around it on the promise of easy linkages between devices.  Everyone has to run Windows, everyone has to wait a long time, and everyone has to guess what the one error code returned by DCOM actually means.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-319553">
				<div id="div-comment-319553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319553">
			November 7, 2005 at 2:53 pm</a>		</div>

		<p>Now consider the compatibility risks of removing the 5 retries from shell32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319573">
				<div id="div-comment-319573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319573">
			November 7, 2005 at 6:21 pm</a>		</div>

		<p>Gabe,</p>
<p>Changing that 15 to a 1 is hardly that easy.  Open source doesn&#8217;t always mean that you have that kind of control or flexibility.  As Raymond noted, the 15 may be in several places, and referenced in several ways.</p>
<p>But more importantly, you&#8217;re assuming that the company has taken the original source code and is now maintaining an in-house branch.  In that circumstance, I can see your point, although it&#8217;s still a little more complicated than that, since I&#8217;m assuming there&#8217;s some red tape if the company is large enough to have an in-house development team (unless, of course, they&#8217;re a dev shop).  Such a problem would still have to be reported internally, diagnosed, and a new build compiled, tested, and deployed.  The big difference is now you&#8217;re sucking up the costs, rather than a vendor.</p>
<p>Very often, however, you&#8217;re using an open source product that is not maintained by your company.  While you can modify the source code, any changes made in-house now have to be carefully tracked and integrated into future product versions, which won&#8217;t reflect your change.  More likely, you&#8217;ll end up making the same call to whomever supports the product that you would have made to Microsoft et al.</p>
<p>My point isn&#8217;t so much to refute open source, nor to prove you wrong.  It&#8217;s more to point out that open source does not equate literally to flexibility nirvana.  Open source software is still software, and the process of debugging, coding, testing, and deploying must still be managed.</p>
<p>Despite the differing philosophies of open and close source software, there are some things you just can&#8217;t shortcut.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319583">
				<div id="div-comment-319583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ifeanyi Echeruo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319583">
			November 7, 2005 at 7:25 pm</a>		</div>

		<p>Retry is an application level policy decision.<br />
<br />Components and libraries should fail fast and report an error or provide an alternative with a timeout (not a retry count).<br />
<br />Whether the application should make the user decide, retry automatically, retry while informing the user of current status or just format your drive for giving it so much hard work, is another discussion altogether.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319593">
				<div id="div-comment-319593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Koro</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319593">
			November 7, 2005 at 8:20 pm</a>		</div>

		<p>Really insightful post, I did not think about that point, in fact, I may have the same bug in one of my programs.</p>
<p>Do you know, however, if TCP does attempt reconnection on behalf of the application if the host can not be reached when trying to connect to it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319613">
				<div id="div-comment-319613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319613">
			November 7, 2005 at 8:33 pm</a>		</div>

		<p>andy:<br />
<br />Another common mistake I see often is increasing a server timeout value when it starts getting overloaded. What happens then is that those long running operations take up all the threads on the server and none of the other operations get a chance to run, and the entire server goes down, instead of just a few slow operations being denied.</p>
<p>This is a symptom of poor server design. The fix here is to use roughly 20 threads that service all incoming connections and perhaps add a sweeper that notices dead connections.</p>
<p>Tim:<br />
<br />&quot;Exponential Backoff&quot;</p>
<p>Isn&#8217;t that for negotiating who gets access to a resource &#8211; it&#8217;s nothing to do with network reliability (e.g. link might be down)? It&#8217;s used by stuff like CSMA/CD (by e.g. ethernet) etc. </p>
<p>It&#8217;s for avoiding a progressive degradation that would kill a network in a high-traffic situation, so yes, it is reliability related.</p>
<p>Koro:<br />
<br />Do you know, however, if TCP does attempt reconnection on behalf of the application if the host can not be reached when trying to connect to it?</p>
<p>Sort of. TCP rides on top of UDP, and packets that are lost get retransmitted. Once the connection dies, it&#8217;s dead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319623">
				<div id="div-comment-319623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319623">
			November 7, 2005 at 8:49 pm</a>		</div>

		<blockquote><p>
  Explorer is hardly blameless in this respect.</p>
<p>Thank you, it is a relief to see this kind of frankness.</p>
<p>Now speaking of drivers, I&#8217;ve read reports of open source IDE drivers doing the same kind of multiplicative retries so a bad block on a CD-ROM causes hangs for ages before the user can abort the operation.  For some reason I have the impression that certain closed source IDE drivers do the same.  What we really need is flexibility.  If the user wants a tool to do maximum tweaks and retries in hopes of recovering some fraction of the data, do it.  If a user is just doing an ordinary operation then let the abort be quick.  Maybe the user has or can make extra copies of the defective CD.</p>
<p>Monday, November 07, 2005 12:24 PM by Daniel Chait<br />
  <br />&gt; &quot;Exponential Backoff&quot;.</p>
<p>Yes (for issues involving contention rather than defects).</p>
<p>&gt; [&#8230;] longer and longer period of time<br />
  <br />&gt; [&#8230;] random small jitter</p>
<p>Yes.</p>
<p>&gt; collar it at some max timespan to prevent it<br />
  <br />&gt; from getting ridiculous.</p>
<p>That I&#8217;ve never understood.  It seems to me that collaring is going to recreate the same problem that you started out pretending to solve.  If you think that the length of time has grown ridiculous, but the amount of contention is so high that you still can&#8217;t get served, you don&#8217;t want to collar it, you want to abort.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319633">
				<div id="div-comment-319633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319633">
			November 7, 2005 at 9:01 pm</a>		</div>

		<blockquote><p>
  If you think that the length of time has grown ridiculous, but the amount of contention is so high that you still can&#8217;t get served, you don&#8217;t want to collar it, you want to abort.</p>
<p>That&#8217;s what you do &#8211; collar should refer to the total time spent attempting transmission, not wait time.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319653">
				<div id="div-comment-319653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bilal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319653">
			November 7, 2005 at 9:45 pm</a>		</div>

		<p>You actually see the .NET framework doing something like this. (I know, this is not a .NET blog, but this was something that came into mind when I read this blog)</p>
<p>Try this</p>
<p>Set up an isolated network (hook up the PC to a router so it has a IP, but no Internet connection)<br />
<br />Create a .NET assembly that is strong named, digitally signed and installed in the GAC.<br />
<br />Now create an exe that uses that assembly. You will see that it takes 10+ seconds for the exe to load the assembly.<br />
<br />I came to find out that the CLR was doing a certification revocation list (CRL) check and the reason for the delay is because the WinTrust API (which is used by the CLR) keep on retrying to connect to the CRL to verify the certificate of the assembly (even though it was in a trusted location, the GAC). The only way to get around this is to disable the CRL check completely(using the registry or IE). The number of retries or the delay is not configurable. Which kinda sucks&#8230; So it looks like your app initialization takes more than 10 seconds.. You can imagine how exciting poeple find that ;)<br />
<br />But I&#8217;m just venting.. </p>
<p>Hey, my first comment on this blog :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319663">
				<div id="div-comment-319663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319663">
			November 7, 2005 at 10:38 pm</a>		</div>

		<blockquote><p>
  Now consider the compatibility risks of removing the 5 retries from shell32. </p>
<p>Compatibility is important, yes, but how exactly does anyone write a program that relies on 5 attempts to delete a file in some critical manner?  That&#8217;s a very special achievement, and I didn&#8217;t know there was a special olympics for the computing world.</p>
<p>Even if there&#8217;s some legitimate reason why a multi-threaded app wants to delete a file but isn&#8217;t sure when another thread will release it, this retry scheme is still not guaranteed to work, because the relevant thread only needs to get blocked for a short while and it&#8217;ll miss all the retries. It might increase the number of transitory failures, but it&#8217;s not like 5 retries is guaranteed to always work while only having 4 retries could occasionally fail.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319673">
				<div id="div-comment-319673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Pryhodko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319673">
			November 8, 2005 at 12:27 am</a>		</div>

		<blockquote><p>
  I feel sorry for the Industrial Automation folks who bought hook, like,<br />
  <br />&gt; and sinker into that stuff and spun their whole &quot;OPC&quot; methodology around it<br />
  <br />&gt; on the promise of easy linkages between devices.</p>
<p>Right&#8230; Guys, who decided to use COM/DCOM in OPC, should have their hands broken, fixed and broken again. I was writing some OPC-compliant stuff &#8212; it really hurts. Especially considering how simple and efficient it could be done without COM.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-basuabhinabayahoo-com even thread-even depth-1" id="comment-319683">
				<div id="div-comment-319683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Abhinaba+Basu+%5BMSFT%5D' rel='external nofollow' class='url'>Abhinaba Basu [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319683">
			November 8, 2005 at 1:23 am</a>		</div>

		<p>I am honoured to be linked Raymond for good or bad :)</p>
<p>I agree that just retrying does not work in all situation. In  <a rel="nofollow" target="_new" href="http://blogs.msdn.com/abhinaba/archive/2005/10/01/476026.aspx" rel="nofollow">http://blogs.msdn.com/abhinaba/archive/2005/10/01/476026.aspx</a><br />
<br />the example I used does not arbitrarily  retry the operation 3 times. It uses an Exception class which explicitly uses a public member to signal whether the operation is retryable.</p>
<p>In all situation asking the user for retrying does not work. Lets take the example of one of the source code repository converters we are working on. This takes a VSS repository and migrates all data in it to Team Foundation Server repository. This includes thousands of files and hundreds of versions of each of them and takes a day to migrate. In this super-high stress situation VSS server sometimes acts-up and either times-out or throws an error. So what do we do, expect the user to sit around for the whole day and see each failure and prompt him Retry (Y/N)? or fail the migration that was going on for the last 8 hours?</p>
<p>My point is in some situaion like an interactive program (UI client) prompting the user for retry is the correct thing to do. In long running un-attended batch conversion job where we know for sure that transient failures occur and get resolved on retrying, using retry is the right approach.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319693">
				<div id="div-comment-319693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jerry</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319693">
			November 8, 2005 at 2:47 am</a>		</div>

		<p>as alway &#8211; it depends.<br />
<br />We write a lot of automation stuff and know that every customer is totally different, having networks where small locations are connected with some Kb and the bigger ones with Mbit lines, different network load and latency.<br />
<br />If you know that sometimes you reach a timeout &#8211; and that the layers &quot;down there&quot; just don&#8217;t care &#8211; it&#8217;s a good thing to retry.<br />
<br />I think its about intelligent programming &#8211; carefully deciding if it is necessary, and if it makes the users life better.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319703">
				<div id="div-comment-319703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mirobin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319703">
			November 8, 2005 at 4:15 am</a>		</div>

		<p>I&#8217;ll admit it, I&#8217;m an evil auto-retrier.  :)</p>
<p>My implementation lets the user know that the first operation failed, and that it is trying the operation again.  The user can cancel the operation if they get tired of waiting.</p>
<p>I&#8217;d have to give a nod to Ifeanyi, as I think he&#8217;s pretty much nailed the proper way to handle such cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-319713">
				<div id="div-comment-319713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319713">
			November 8, 2005 at 4:23 am</a>		</div>

		<p>Giving the user the ability to cancel an automatic retry is great, but what if you&#8217;re a layer with no UI? How can the networking layer display a cancel button?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-319723">
				<div id="div-comment-319723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319723">
			November 8, 2005 at 4:28 am</a>		</div>

		<p>&quot;how exactly does anyone write a program that relies on 5 attempts to delete a file in some critical manner?&quot;</p>
<p>Ah, that was my exercise for you. Here&#8217;s one example: Consider an automation script. It opens Excel, creates a spreadsheet, saves it, then opens Word, embeds the spreadsheet into a document, prints the result, then closes Word and Excel and then deletes the temporary spreadsheet. Repeat four times, once for each department.</p>
<p>Remove the retries and now the script gets a &quot;file in use&quot; error because it tried to delete the temporary spreadsheet before Word finished closing the document. Script fails, monthly sales reports not generated for three of the departments, angry call to Microsoft coming soon for breaking a script that is essential to their business.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319733">
				<div id="div-comment-319733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://home.swiftdsl.com.au/~Piquet/blog/index.php/archive/2005/10/21/while-retries/' rel='external nofollow' class='url'>Peter Hancock</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319733">
			November 8, 2005 at 4:43 am</a>		</div>

		<p>I&#8217;d posted along similar lines just recently.  My concern was that nobody ever puts down WHY it retries.  A simple comment in code like, &quot;we retry because of an issue with the xxx connection failing consistently on the first try but then works&quot; at least tells me that the developer was aware of the condition.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319743">
				<div id="div-comment-319743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.divelements.co.uk/' rel='external nofollow' class='url'>Tim Dawson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319743">
			November 8, 2005 at 5:10 am</a>		</div>

		<p>The more you pander to the types of people that write code like that (bad code) the more these compatibility issues will grow &#8211; exponentially.</p>
<p>People are sick of waiting for explorer to timeout, as documented by various posters in this thread. Would the benefits of removing these retries not outweigh the small number of scripts that are broken?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319753">
				<div id="div-comment-319753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mirobin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319753">
			November 8, 2005 at 6:55 am</a>		</div>

		<p>If you&#8217;re a network layer, how retries are performed, if any at all, should be determined by the API specification.</p>
<p>It is up to the API to determine how to handle the cases that no application would ever care about (if such a thing is possible ;)) and to surface cases that an application could possibly care about.</p>
<p>At minimum I would expect one or more of the following:<br />
<br />1) API documents how long an attempt takes to time out or otherwise fail<br />
<br />2) API documents how many times and under what conditions it attempts to perform a retry if at all<br />
<br />3) API provides a mechanism to cancel a call<br />
<br />4) API provides a way to specify or imposes a time limit on the total length of the call<br />
<br />5) API provides a way to specify number of attempts and/or intervals between attempts<br />
<br />6) API just fails and returns an error code on timeout</p>
<p>In the example you site in this post, the issue could probably have been avoided if each API documented how long the worst case timeout for each operation could be (assuming someone using the API reads the docs beforehand and is smart enough to realize that making 5 calls taking &gt; n minutes is a dumb thing to do).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319783">
				<div id="div-comment-319783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319783">
			November 8, 2005 at 9:46 am</a>		</div>

		<p>I agree that in nearly all cases, lower level layers should not retry.  The exceptions are when retries are a requirement, such as the TCP others have pointed out.  It should NEVER be a &quot;convenience&quot; retry for the application.</p>
<p>As for the .NET CRL thing, that&#8217;s broken.  It needs to let the user know what&#8217;s going on so they can cancel or at least know what&#8217;s going on.  And don&#8217;t say it&#8217;s not a UI layer.  I bet it notifies the user if it actually encounters a revoked CRL, so it should be able to notify the user in the event of a retry.  The whole CRL thing is doubly broken if the final default is to assume that the certificate isn&#8217;t broken.  At that point, it should require admin intervention to even allow the component to run.  Otherwise it&#8217;s a security risk.</p>
<p>Raymond, the real problem isn&#8217;t that Explorer retries calls.  As someone pointed out, that decision is an application-level choice.  Explorer is application-level, so it can make that choice.  The problem is that you&#8217;re leaving the user in the dark.  It shouldn&#8217;t take explorer five seconds to let me know it&#8217;s trying to do something.  TELL ME if you&#8217;re retrying.  Show a dialog with a cancel button.  That&#8217;s all I want, and then the behavior becomes tolerable (though still pretty much useless).  The same with accessing a network folder.  Long operations should not hang the UI.  That&#8217;s basic design everyone knows (or should know).  Give me an intervention mechanism, and then I won&#8217;t have to sit at my computer cursing Microsoft.</p>
<p>Sometimes it seems Microsoft uses the &quot;compatability&quot; excuse to avoid work.  Seriously, this kind of compatability shouldn&#8217;t need to be carried across OS versions, possibly not even service packs.  What corporation can afford to deploy a new OS (or service pack) but can&#8217;t afford to check their scripts on the new OS?  Put a disclaimer on the service pack saying that things have changed, and scripts should be checked before deployment.  That should be enough, and OS versions shouldn&#8217;t even require that disclaimer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-319823">
				<div id="div-comment-319823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319823">
			November 8, 2005 at 11:13 am</a>		</div>

		<p>&quot;Would the benefits of removing these retries not outweigh the small number of scripts that are broken?&quot;</p>
<p>The retries were originally introduced, not at the request of scripts, but a the request of beta testers! &quot;If I try to delete a file too quickly after closing the program that had the file open, the delete fails. Explorer should sleep a little bit and try again because the reason it can&#8217;t delete might be transient.&quot;</p>
<p>One man&#8217;s feature is another man&#8217;s bug.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319873">
				<div id="div-comment-319873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319873">
			November 8, 2005 at 12:49 pm</a>		</div>

		<p>I think the easiest solution to this problem is not to retry N times, but to retry for at most X seconds. That way you don&#8217;t have to worry about how many times the layer below you has retried and retry delays won&#8217;t be multiplicative.</p>
<p>Also, if an API is going to retry something, it should be documented and/or configurable (how many times, for how long) so that the layer(s) above it can do something intelligent. Batch processes would want to retry indefinitely or after the queue is empty, while interactive processes would want to be able to wait a brief period and allow the user to cancel.</p>
<p>In the case of Explorer, it should pop a message box that says &quot;Cannot delete file XYZ123 because it is locked. Retrying in 5&#8230;4&#8230;3&#8230;2&#8230;1&quot; with a Cancel button. Even better would be to have a button that would show me what process has the file locked. As an added bonus, Explorer would be able to tell if it&#8217;s the process that has the object locked and automatically close all handles to it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319883">
				<div id="div-comment-319883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319883">
			November 8, 2005 at 12:52 pm</a>		</div>

		<p>Explorer should autoretry, but the code that runs when scripts are using it should not.  Explorer runs at the app level, unless it&#8217;s being used from scripts.</p>
<p>It should have always failed the call that the script made, using an error that was clearly documented as &quot;this may be a transient error&quot;, and the script should have decided whether to retry (and how many times).</p>
<p>In other words: The script should not be calling into the exact same routine that the Explorer UI code calls into when you press the delete key.  The actual &quot;delete file&quot; code should be in a separate function, which is called by both the scripting interface and Explorer&#8217;s UI.</p>
<p>Of course you can&#8217;t change that now (not without breaking a bunch of scripts, at least).  But I still think that it&#8217;s the Right Way to do it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319903">
				<div id="div-comment-319903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319903">
			November 8, 2005 at 1:48 pm</a>		</div>

		<blockquote><p>
  Remove the retries and now the script gets a &quot;file in use&quot; error because it tried to delete the temporary spreadsheet before Word finished closing the document. Script fails, monthly sales reports not generated for three of the departments, angry call to Microsoft coming soon for breaking a script that is essential to their business.</p>
<p>So Word returns before the operation is complete? What kind of scripting support is that?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-319913">
				<div id="div-comment-319913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319913">
			November 8, 2005 at 1:53 pm</a>		</div>

		<p>What&#8217;s this &quot;returns&quot; thing? You&#8217;d be surprised how many scripts consist of replaying mouse clicks and keystrokes. Simulate a lcick on Word&#8217;s &quot;X&quot; button, then simulate a click on the temporary file, then simulate a press of the DELETE key, then simulate a press of the &quot;Y&quot; key. That&#8217;s why I&#8217;m kind of baffled by the people who talk about removing the delay from the &quot;scripting interface&quot; to Explorer. These scripts aren&#8217;t using the scripting interface in the first place. They&#8217;re simulating an end user.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319933">
				<div id="div-comment-319933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319933">
			November 8, 2005 at 3:09 pm</a>		</div>

		<p>&#8230; Oh.</p>
<p>OK, I read &quot;script&quot; and thought &quot;VBscript, i.e. COM/ActiveX&quot;.  I figured there was an ActiveX interface to most of what Explorer allows (even though I&#8217;ve never used it, that obviously doesn&#8217;t mean it doesn&#8217;t exist), and these scripts that you were referring to used it.</p>
<p>So never mind; many of those objections don&#8217;t hold if the script is acting like a user.</p>
<p>(Of course, in that case, Explorer has a UI, too &#8212; that&#8217;s what the script is using.  So Explorer could show a window saying &quot;delete in progress, cancel?&quot; or something.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319763">
				<div id="div-comment-319763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319763">
			November 8, 2005 at 8:25 am</a>		</div>

		<p>&gt; How can the networking layer display a cancel<br />
<br />&gt; button?</p>
<p>The network layer shouldn&#8217;t be retrying *in the first place*!  (Except for the TCP layer&#8217;s retransmissions &#8212; but that stuff&#8217;s specified by the appropriate RFCs; you can&#8217;t get rid of it and claim to have a TCP/IP stack.  It should also be documented in the APIs.)</p>
<p>As several people have said &#8212; retrying should be an application level decision, *NOT* a lower-layer decision.  No lower layers should be auto-retrying *AT ALL* &#8212; not network, not DCOM, not the .net framework code, nothing.</p>
<p>Put information in the API documentation to tell developers that operation X might fail due to transient conditions, and if they&#8217;re writing *application layer* code, they may want to retry the operation.  It would probably be a good idea to make it explicit that code without a UI should pass the failure up to its caller instead of retrying on its own.</p>
<p>Services may be a problem, unless their only goal in life is to provide some functionality to a higher layer of code.  (Then they should not be retrying.)  Although when are people waiting on a service?  Usually, only on boot &#8212; and that might be solvable by making the &quot;OK, this service is started&quot; call happen earlier.</p>
<p>And yes, I realize Windows maybe can&#8217;t fix this anymore, but it&#8217;s still the right fix.  In the meantime, documenting which API calls auto-retry (and how many max retries happen) should forestall a lot of future issues with this.  If I see in the documentation for some IE activex function that it will retry up to 10 times, I&#8217;ll definitely think twice about making that call more than once.  If it fails back to me, that means it&#8217;s already tried 10 times and failed all 10, so there&#8217;s likely not much I can do about the problem by just autoretrying.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-320003">
				<div id="div-comment-320003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Derek</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-320003">
			November 8, 2005 at 5:28 pm</a>		</div>

		<blockquote><p>
  I think the easiest solution to this problem is<br />
  <br />&gt;not to retry N times, but to retry for at most X<br />
  <br />&gt;seconds. That way you don&#8217;t have to worry about<br />
  <br />&gt;how many times the layer below you has retried<br />
  <br />&gt;and retry delays won&#8217;t be multiplicative. </p>
<p>The problem is that lower layers shouldn&#8217;t be retrying at all.  If you decide to retry for, say, 5 seconds, and the function you call decides to keep going for 3 years, what can you do about it?  If the layer underneath doesn&#8217;t have some sort of timeout functionality, you&#8217;re just going to have to wait.  You could create a second thread to monitor and kill the first thread if it takes too long but that&#8217;s problematic because it&#8217;s 1) way to complex a fix for something that shouldn&#8217;t be happening at all, and 2) going to cause massive problems with resource leaks in the inknowingly-terminated thread.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-universalis odd alt thread-odd thread-alt depth-1" id="comment-319773">
				<div id="div-comment-319773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Universalis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319773">
			November 8, 2005 at 9:33 am</a>		</div>

		<p>But the whole trouble here was that Windows Explorer *was* an application layer program and as soon as you added scripting to it, it ceased to be.<br />
<br />This is an example of the philosophical incoherence of the &quot;automate by scripting an application program&quot; model. Unfortunately, apart from being philosophically incoherent, that model is damned useful!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319813">
				<div id="div-comment-319813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bryan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319813">
			November 8, 2005 at 11:12 am</a>		</div>

		<p>Universalis:</p>
<p>&gt; But the whole trouble here was that Windows<br />
<br />&gt; Explorer *was* an application layer program and<br />
<br />&gt; as soon as you added scripting to it, it ceased<br />
<br />&gt; to be.</p>
<p>Sort of.  It was an app-level program, yes.  So the retries should have been done in Explorer&#8217;s code, yes.</p>
<p>But when scripting got added, it should not have been added as a layer above this retry code; that&#8217;s the problem.  The code that handles the retries should have been at the same layer as the scripting consumer.</p>
<p>&quot;Automate by scripting an application program&quot; is broken, I&#8217;ll agree &#8212; instead of automating the app itself, I think it&#8217;s smarter to expose the code one layer below the autoretry code to scripts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-319943">
				<div id="div-comment-319943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319943">
			November 8, 2005 at 3:34 pm</a>		</div>

		<p>&gt; You&#8217;d be surprised how many scripts consist of replaying mouse clicks and keystrokes.</p>
<p>*shudder* Maybe not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-319953">
				<div id="div-comment-319953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-319953">
			November 8, 2005 at 3:49 pm</a>		</div>

		<p>As I said &#8211; if 4 retries are not sufficient, then 5 retries are no guarantee of success. The current system can *at best* mask problems up until something makes excel take 5.01 seconds instead of 4.99 seconds to release a file.</p>
<p>This means that scripts will fail erratically, not consistently, and if they&#8217;re really that important then they damn well ought to be written by someone who&#8217;s done more than read half way through &quot;Learn Visual Basic For Applications in 21 Days&quot;.  (Either that or the accountant writing scripts should quit whining when some coder who&#8217;s read half of &quot;Accounting For Dummies&quot; thinks they know more about business management than the guy who spent 5 years at Harvard. Apparantly there&#8217;s something in the water that makes people have no respect for any profession besides their own.)</p>
<p>Yeah, the current system can mask problems and make amateurs think that their badly written code is actually reliable. I&#8217;m not sure that&#8217;s worth the irritaion of every user who gets an unresponsive user interface, but there&#8217;s programers all over the world who&#8217;ld disagree with me.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-320033">
				<div id="div-comment-320033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mirobin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-320033">
			November 9, 2005 at 2:20 am</a>		</div>

		<p>Terminating a thread to abort an operation is never a safe thing to do, and is a good way to introduce a deadlock in your application.  You have no idea what kind of resources/locks the thread you are terminating has a hold on (ex:  the loader lock) when you yank the rug out, leading to unpredictable behavior later down the line.</p>
<p>At best, you would write the thread in such a manner that it could be abandoned by your application.</p>
<p>As far as the points the AC raises about retrying always being an unreliable solution, I would disagree to a point.  If you expect that the application could take up to 5 seconds to shutdown, then yes retrying for 5 seconds is not reliable.  If you expect that the *worst case* is that the application takes 5 seconds to shutdown then it is reliable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-320073">
				<div id="div-comment-320073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.guyswithtowels.com' rel='external nofollow' class='url'>Tim</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-320073">
			November 9, 2005 at 10:47 am</a>		</div>

		<p>&quot;Sometimes it seems Microsoft uses the &quot;compatability&quot; excuse to avoid work.&quot;</p>
<p>Somewhere, Raymond&#8217;s head is exploding :-D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-320173">
				<div id="div-comment-320173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-320173">
			November 9, 2005 at 12:58 pm</a>		</div>

		<p>Ok &#8211; a bit off topic, but tangentially related to the retry delay on delete. When you are viewing a sub directory in an explorer window and right-click on a parent directory (in the folder list) and choose delete, you experience the delay while explorer retries deleting something that it has locked itself.</p>
<p>I can&#8217;t tell you how many times I do this as it is so natural. You&#8217;d think I&#8217;d learn&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-321503">
				<div id="div-comment-321503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-321503">
			November 11, 2005 at 11:52 am</a>		</div>

		<p>Similarly I look at the files on a floppy before deciding I can format it (see later blog!) and of course the format fails because explorer has locked the drive&#8230;</p>
<p>Surely that &quot;Deleting&#8230;&quot; progress dialog should display while Explorer is retrying? Or maybe it does now, and I should upgrade.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-322103">
				<div id="div-comment-322103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nekto</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-322103">
			November 15, 2005 at 10:39 am</a>		</div>

		<p>&quot;If I try to delete a file too quickly after closing the program that had the file open&quot;</p>
<p>;)<br />
<br />The &quot;best&quot; solution whould be for DeleteFile function is to trace who is using file and find out if it trying to close itself. If yes &#8211; show message &quot;Sorry we are waiting for that slow thing..&quot; in notfication area. And to delete it after.<br />
<br />*joke*</p>
<p>What do you think about &quot;unix way&quot;? To delete file from list but not from disk until any handler exist and delete it only when that is freed. So user see file deleted instantly.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-322693">
				<div id="div-comment-322693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-322693">
			November 17, 2005 at 9:53 am</a>		</div>

		<p>Nekto &#8212; I would love to see that done (for one, it would mean you could install most patches without a reboot: the only updates that would require a reboot would be the ones that affect services or drivers that are required at all times by the kernel).</p>
<p>Unfortunately, I don&#8217;t know how many programs use that (IMO mis-) feature as a way to do a lock-file with automatic clean-up (where if a process holds the lock-file and crashes, it&#8217;ll get cleaned up the next time someone requests the lock).  A change like that would break compatibility, which is extremely unfortunate.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-416583">
				<div id="div-comment-416583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/09/05/741110.aspx' rel='external nofollow' class='url'>The Old New Thing : Just change that 15 to a 1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051107-20/?p=33433#comment-416583">
			September 5, 2006 at 10:01 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/09/05/741110.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/09/05/741110.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

