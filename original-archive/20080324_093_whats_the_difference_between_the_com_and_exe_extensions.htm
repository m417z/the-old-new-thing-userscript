<html>
<head>
<title>What's the difference between the COM and EXE extensions?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>What&#8217;s the difference between the COM and EXE extensions?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 24, 2008 / year-entry #94</td></tr>
<tr><td><b>Tags:</b></td><td>history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>42</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Commenter Koro asks why you can rename a COM file to EXE without any apparent ill effects. (James MAstros asked a similar question, though there are additional issues in James' question which I will take up at a later date.) Initially, the only programs that existed were COM files. The format of a COM file...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Commenter Koro asks
<a HREF="http://blogs.msdn.com/oldnewthing/pages/407234.aspx#503035">
why you can rename a COM file to EXE without any apparent ill effects</a>.
(James MAstros
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2006/01/30/519388.aspx#519544">
asked a similar question</a>,
though there are additional issues in James' question
which I will take up at a later date.)
</p>
<p>
Initially, the only programs that existed were COM files.
The format of a COM file is... um, none.
There is no format.
A COM file is just a memory image.
This "format" was inherited from CP/M.
To load a COM file,
the program loader merely sucked the file into memory unchanged
and then jumped to the first byte.
No fixups, no checksum, nothing.
Just load and go.
</p>
<p>
The COM file format had many problems, among which was that
programs could not be bigger than about 64KB.
To address these limitations, the EXE file format was introduced.
The header of an EXE file begins with
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2006/01/30/519388.aspx">
the magic letters "MZ"</a> and continues with other information that
the program loader uses to load the program into memory and prepare it
for execution.
</p>
<p>
And there things lay, with COM files being "raw memory images"
and EXE files being "structured",
and the distinction was rigidly maintained.
If you renamed an EXE file to COM, the operating system would
try to execute the header as if it were machine code (which didn't
get you very far), and conversely if you renamed a COM file to EXE,
the program loader would reject it because the magic MZ header
was missing.
</p>
<p>
So when did the program loader change to ignore the extension entirely
and just use the presence or absence of an MZ header to determine
what type of program it is?
Compatibility, of course.
</p>
<p>
Over time, programs like <code>FORMAT.COM</code>,
<code>EDIT.COM</code>,
and even <code>COMMAND.COM</code> grew larger than about 64KB.
Under the original rules, that meant that the extension
had to be changed to EXE,
but doing so introduced a compatibility problem.
After all, since the files had been COM files up until then,
programs or batch files that wanted to, say, spawn a command interpreter,
would try to execute <code>COMMAND.COM</code>.
If the command interpreter were renamed to <code>COMMAND.EXE</code>,
these programs which hard-coded the program name
would stop working since there was no
<code>COMMAND.COM</code> any more.
</p>
<p>
Making the program loader more flexible meant that these
"well-known programs" could retain their COM extension
while no longer being constrained by the "It all must fit into 64KB"
limitation of COM files.
</p>
<p>
But wait, what if a COM program just happened to begin with the
letters MZ?
Fortunately, that never happened, because the machine code for
"MZ" disassembles as follows:
</p>
<pre>
0100 4D            DEC     BP
0101 5A            POP     DX
</pre>
<p>
The first instruction decrements a register whose initial value
is undefined, and the second instruction underflows the stack.
No sane program would begin with two undefined operations.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-611583">
				<div id="div-comment-611583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">wades</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611583">
			March 24, 2008 at 11:14 am</a>		</div>

		<p>&#8220;To load a COM file, the program loader merely sucked the file into memory unchanged and then jumped to the first byte. No fixups, no checksum, nothing. Just load and go.&#8221;</p>
<p>You left out the part that the &#8220;first byte&#8221; gets loaded at offset 0x100 relative to the value of the segment registers though. And the &#8220;no fixups&#8221; part meant that the image had to be self-relocating.</p>
<div class=post>[<i>There are plenty of details I left out since they were not relevant to the topic. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com000300008195987d odd alt thread-odd thread-alt depth-1" id="comment-611593">
				<div id="div-comment-611593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Spire' rel='external nofollow' class='url'>Spire</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611593">
			March 24, 2008 at 11:30 am</a>		</div>

		<p>I wonder if Mark Zbikowski ever thought to verify that DEC BP and POP DX were indeed undefined operations at the beginning at a program &#8212; just in case Microsoft ever decided to be sneaky and start renaming EXE files to COM files. If not, then that&#8217;s a pretty happy coincidence.</p>
<p>In retrospect, I can&#8217;t help but think that something like &#8220;É0Σ═!&#8221; (90 30 E4 CD 21) would have been a better EXE marker. That disassembles to a NOP followed by XOR AH, AH and INT 21h (a call to DOS to terminate the program).</p>
<p>Optionally: Allow a sequence of bytes to be inserted in between the NOP and the termination call. This would give EXE files the flexibility to contain a stub COM file that could print something like &#8220;This is an EXE program.&#8221; before terminating.</p>
<p>Now where&#8217;s that time machine?</p>
<div class=post>[<i>Um, you do realize that your &#8220;optionally&#8221; means that every COM program would get misdetected as an EXE? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611603">
				<div id="div-comment-611603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611603">
			March 24, 2008 at 11:45 am</a>		</div>

		<p>@wades:</p>
<p>I&#8217;d say that COM images aren&#8217;t self-relocating at all. Self-relocating means (IMO) that you can load them at another address than 0x100 but that really doesn&#8217;t work with a COM image.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611613">
				<div id="div-comment-611613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kalle Olavi Niemitalo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611613">
			March 24, 2008 at 12:12 pm</a>		</div>

		<p>IIRC, there is a 0000H on the stack when a COM program starts, and an INT 20H at PSP:0000H. &nbsp;This is so that the program can exit just by doing a RETN. &nbsp;So the POP DX would not really underflow the stack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611623">
				<div id="div-comment-611623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogdorocco.wordpress.com/2008/03/24/a-diferenca-entre-arquivos-com-e-exe/' rel='external nofollow' class='url'>A diferen??a entre arquivos .COM e .EXE &laquo; Blog do Rocco</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611623">
			March 24, 2008 at 12:27 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://blogdorocco.wordpress.com/2008/03/24/a-diferenca-entre-arquivos-com-e-exe/" rel="nofollow">http://blogdorocco.wordpress.com/2008/03/24/a-diferenca-entre-arquivos-com-e-exe/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611633">
				<div id="div-comment-611633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://ebersys.blogspot.com' rel='external nofollow' class='url'>Eber Irigoyen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611633">
			March 24, 2008 at 12:28 pm</a>		</div>

		<p>but why wasn&#8217;t the loader modified ONLY for the &quot;well known programs&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611643">
				<div id="div-comment-611643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611643">
			March 24, 2008 at 12:29 pm</a>		</div>

		<p>But if there really is no prolog and you just jump and execute, how are you guaranteed that there&#8217;s a 0000h on the top of the stack?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611683">
				<div id="div-comment-611683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611683">
			March 24, 2008 at 12:54 pm</a>		</div>

		<p>Raymond: Your question &quot;So when did the program loader change&quot; is answered &quot;Compatibility&quot;, which leads me to think that by &quot;when&quot;, you meant &quot;why&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611693">
				<div id="div-comment-611693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stephen Eilert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611693">
			March 24, 2008 at 12:58 pm</a>		</div>

		<p>&quot;&quot;To load a COM file, the program loader merely sucked the file into memory unchanged and then jumped to the first byte. No fixups, no checksum, nothing. Just load and go.&quot;</p>
<p>You left out the part that the &quot;first byte&quot; gets loaded at offset 0x100 relative to the value of the segment registers though. And the &quot;no fixups&quot; part meant that the image had to be self-relocating.&quot;</p>
<p>Interestingly, CP/M and its successors(including MSX-DOS and MS-DOS) all loaded their programs at offset 0x100. It is perhaps the only thing that can be called &quot;standard&quot; among .COM files, even when different processor architectures are involved.</p>
<p>The Z80 processor that was pretty common at the time could only adress 64KB of RAM, so no segment registers to worry about. I think it was no coincidence that the 8086 segments were created in that size.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611713">
				<div id="div-comment-611713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://deadnode.org/' rel='external nofollow' class='url'>James</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611713">
			March 24, 2008 at 1:03 pm</a>		</div>

		<p>Eber: Which &#8216;well known&#8217; programs? OK, maybe in the beginning this was only needed by COMMAND.COM and EDIT.COM &#8211; but that list grew. Better to come up with a generic solution, allowing ANY .COM executable to exceed 64K by being in .EXE format, rather than keep updating a list of file-specific hacks!</p>
<p>Also, Visual C++&#8217;s compiler uses a related trick at some point to provide both a GUI and command line version of itself under the same name (excluding file extension) &#8211; by having both .EXE and .COM versions, with the command line trying to run the .COM version first, unlike the GUI. If the .COM/.EXE hack were filename specific, this wouldn&#8217;t be possible &#8211; at least without the Visual Studio team getting the OS loader updated specially for them, which would probably irritate a lot of people as well as being bad engineering in principle.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611723">
				<div id="div-comment-611723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611723">
			March 24, 2008 at 1:04 pm</a>		</div>

		<blockquote><p>
  &gt; But if there really is no prolog and you just jump and execute, how are you guaranteed that there&#8217;s a 0000h on the top of the stack?
</p></blockquote>
<p>Now, that&#8217;s quite a nitpick. &nbsp;Raymond didn&#8217;t actually say that the loader performed absolutely no preparation for the COM program &#8211; he just said that nothing was done to the program image.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611743">
				<div id="div-comment-611743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611743">
			March 24, 2008 at 1:08 pm</a>		</div>

		<p>Useless trivia for the day: &nbsp;Either &quot;MZ&quot; or &quot;ZM&quot; was a valid EXE header signature &#8211; at least in DOS. &nbsp;I&#8217;m not sure about Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611753">
				<div id="div-comment-611753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">doynax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611753">
			March 24, 2008 at 1:10 pm</a>		</div>

		<p>&quot;I&#8217;d say that COM images aren&#8217;t self-relocating at all. Self-relocating means (IMO) that you can load them at another address than 0x100 but that really doesn&#8217;t work with a COM image.&quot;</p>
<p>Sure you can. With segment addresses overlapping the near 16-bit offset you could load it at any 16-byte aligned address in memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611783">
				<div id="div-comment-611783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kenny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611783">
			March 24, 2008 at 2:33 pm</a>		</div>

		<blockquote><p>
  &gt; Sure you can. With segment addresses overlapping the near 16-bit offset you could load it at any 16-byte aligned address in memory.
</p></blockquote>
<p>Nitpicking. The CS:IP would be xxxx:0100 anyway.</p>
<blockquote><p>
  &gt; In retrospect, I can&#8217;t help but think that something like &quot;&#201;0Σ═!&quot; (90 30 E4 CD 21) would have been a better EXE marker. That disassembles to a NOP followed by XOR AH, AH and INT 21h (a call to DOS to terminate the program).
</p></blockquote>
<p>In retrospect, that would be overkill. &nbsp;It&#8217;s not like everyone was going to rename EXEs in COMs everyday.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611803">
				<div id="div-comment-611803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611803">
			March 24, 2008 at 2:44 pm</a>		</div>

		<blockquote><p>
  Interestingly, CP/M and its successors(including MSX-DOS and MS-DOS) all loaded their programs at offset 0x100. It is perhaps the only thing that can be called &quot;standard&quot; among .COM files, even when different processor architectures are involved.
</p></blockquote>
<p>I believe the historic reason is that the memory from 0x00 to 0xFF is used for the stack, which in turn originated in certain old CPU architecture (Z80 for example I think) where the stack pointer is only 8-bit. &nbsp;Anyway, MS-DOS was derived from CP/M so naturally it followed the same convention as CP/M for COM images.</p>
<blockquote><p>
  Also, Visual C++&#8217;s compiler uses a related trick at some point to provide both a GUI and command line version of itself under the same name (excluding file extension) &#8211; by having both .EXE and .COM versions, with the command line trying to run the .COM version first, unlike the GUI.
</p></blockquote>
<p>That sounds inaccurate to me. &nbsp;16-bit Windows executables uses the NE format, which builds on top of the MS-DOS exe format such that there&#8217;s an MS-DOS exe &quot;stub&quot; (which is really just arbitrary code) that gets run if you run the program under MS-DOS, and the new NE-specific stuff essentially follows after the stub. &nbsp;It makes much more sense for VC++ to make use of that, rather than .COM/.EXE, to support the dual-UI feature.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611813">
				<div id="div-comment-611813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://pne.livejournal.com/' rel='external nofollow' class='url'>Philip Newton</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611813">
			March 24, 2008 at 2:56 pm</a>		</div>

		<p>@reader: The stack started at 0xFFFE and grew downwards.</p>
<p>0x00 to 0xFF was the Program Segment Prefix, which included such things as the command line arguments and two File Control Blocks, at least the first of which was helpfully filled in for you (IIRC) if the first argument looked like a filename.</p>
<p>Another backwards-compatibility tidbit was that address 0x0005 contained a jump to an interrupt routine so that CP/M-like programs which did &quot;CALL 0005&quot; rather than &quot;INT 21H&quot; would also work.</p>
<p>See also <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Program_Segment_Prefix" rel="nofollow">http://en.wikipedia.org/wiki/Program_Segment_Prefix</a> .</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611833">
				<div id="div-comment-611833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">poochner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611833">
			March 24, 2008 at 3:49 pm</a>		</div>

		<p>CP/M didn&#8217;t start out on on the Zilog (Z80) CPU. &nbsp;It ran on the 8080 (8-bit precursor to the Intel 8086). &nbsp;It just so happened that the Z80, (coincidentally you know, not planned or anything&#8230; ahem), that the Z80 was a superset of the 8080 and could run 8080 programs just fine, thanks. &nbsp;Plus it had a couple of other registers and a few extra instructions. &nbsp;But CP/M ran on it, and that was the important part. &nbsp;Under CP/M, the OS (such as you could call it one) owned the memory below 0x100. &nbsp;It had bios call tables, the command line / default disk buffer, and a bunch of other undocumented things that people depended on not to move or change ever again. &nbsp;(Raymond&#8217;s compatibility problems go back at least that far). &nbsp;I don&#8217;t recall exactly what SP was set to, but if you saved it you could return directly to the &quot;command interpreter,&quot; rather than doing a reset that required the interpreter to be reloaded. &nbsp;The stack pointer was most definitely 16 bits. &nbsp;There were some older chips that had 8 bit stack pointers, though. &nbsp;Some of those are still around being used as micro-controllers (like toasters and exercise bikes). &nbsp;When you want a bunch of them, getting them for a nickel is a good thing.</p>
<p>Sorry, I&#8217;m rambling again. &nbsp;Age will do that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611843">
				<div id="div-comment-611843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">afaucher</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611843">
			March 24, 2008 at 3:58 pm</a>		</div>

		<p>Thought I would mention, I found the book &quot;Virus Research &amp; Defense&quot; published by the Symantec press (I forget the author name) to have quite an informative history of how code files evolved. &nbsp;Including lots of details on window&#8217;s PE format. &nbsp;It of course focuses on how they were abused over time, but it is still quite relevant.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611853">
				<div id="div-comment-611853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mats Gefvert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611853">
			March 24, 2008 at 4:02 pm</a>		</div>

		<p>I would be curious to know when exactly COMMAND.COM was renamed into CMD.EXE and how that affected compatibility? It seems like a much bigger, breaking change than renaming FORMAT.COM into FORMAT.EXE.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611863">
				<div id="div-comment-611863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mats Gefvert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611863">
			March 24, 2008 at 4:05 pm</a>		</div>

		<p>And, just because of that, I noticed that COMMAND.COM is still around. Huh, never realized that&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611873">
				<div id="div-comment-611873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611873">
			March 24, 2008 at 4:18 pm</a>		</div>

		<p>&quot;I believe the historic reason is that the memory from 0x00 to 0xFF is used for the stack, which in turn originated in certain old CPU architecture (Z80 for example I think) where the stack pointer is only 8-bit.&quot;</p>
<p>Hm, the z80 had a 16-bit SP. &nbsp;6502 had an 8-bit SP, but its stack was at 0x100 &#8211; 0x1FF, just above zero page.</p>
<p>But 0x000 &#8211; 0x0FF tended to have things hardwired in it like rst vectors.</p>
<p>&quot;And the &#8216;no fixups&#8217; part meant that the image had to be self-relocating.&quot;</p>
<p>Well, they could be loaded in any segment, and I recall a lot of push cs/pop ds&#8230; or es&#8230; &nbsp;I don&#8217;t remember exactly which registers&#8230; &nbsp;But I might be thinking of boot records, where it&#8217;s just smaller than loading the address you already know you&#8217;re at.</p>
<p>But anyway, that&#8217;s a bit different from being really position independent or self-relocating. &nbsp;With only one segment, addressing is flat and fixed so there&#8217;s nothing to patch internally.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611883">
				<div id="div-comment-611883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Blake Coverett</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611883">
			March 24, 2008 at 4:19 pm</a>		</div>

		<p>&nbsp;&quot;That sounds inaccurate to me. &nbsp;16-bit Windows executables uses the NE format, which builds on top of the MS-DOS exe format such that there&#8217;s an MS-DOS exe &quot;stub&quot; (which is really just arbitrary code) that gets run if you run the program under MS-DOS, and the new NE-specific stuff essentially follows after the stub. &nbsp;It makes much more sense for VC++ to make use of that, rather than .COM/.EXE, to support the dual-UI feature.&quot;</p>
<p>James was correct. &nbsp;There were other, older, DOS/Win16 Microsoft tools that used the MZ stub and the NE executable to provide dual-mode behavior, but what devenv did was a different sort of hack. &nbsp;There was both devenv.com and devenv.exe, both were in fact PE&#8217;s with a standard stub, but because .COM files were found first by CMD.EXE (given the default PATHEXT) when you typed &#8216;devenv&#8217; from a command prompt you got devenv.com, the console subsystem PE executable, but the start menu/etc shortcuts were to devenv.exe the windows subsystem PE executable.</p>
<p>It was a hack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611903">
				<div id="div-comment-611903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xepol</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611903">
			March 24, 2008 at 4:39 pm</a>		</div>

		<p>Or, they could have provided small .com stubs to launch the .exe files.</p>
<p>Nah, that would have been sane and kept things simple instead of doing something overly complicated and prone to strange side effects.</p>
<p>And hey, as long as it all fits on a floppy, right?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611913">
				<div id="div-comment-611913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611913">
			March 24, 2008 at 5:21 pm</a>		</div>

		<blockquote><p>
  &gt; Or, they could have provided small .com stubs to launch the .exe files.
</p></blockquote>
<p>Nah, that would have been sane and kept things simple instead of doing something overly complicated and prone to strange side effects. &lt;&lt;</p>
<p>How is that simpler than simply having the loader look for the MZ signature? &nbsp;What strange side effects does what Raymond described have?</p>
<p>Having a small .com stub shell out to the real .exe is probably the first solution that would have come to my mind, but it has the downside that now you have to make sure 2 executables are available (and then you&#8217;d have Raymond&#8217;s article explaining &quot;Why do some standard executables have both a .com file and a .exe file, such as format.com and format.exe?&quot;). &nbsp;Personally, I think having the loader not care about the extension is much cleaner and preferable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611923">
				<div id="div-comment-611923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611923">
			March 24, 2008 at 5:23 pm</a>		</div>

		<p>Btw, is Cmd.exe also in &quot;maintenance mode&quot; or legacy stuff. Why isn&#8217;t it being improved?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-aadsso-1live-com000300008195987d odd alt thread-odd thread-alt depth-1" id="comment-611933">
				<div id="div-comment-611933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Spire' rel='external nofollow' class='url'>Spire</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611933">
			March 24, 2008 at 6:11 pm</a>		</div>

		<p>[Um, you do realize that your &#8220;optionally&#8221; means that every COM program would get misdetected as an EXE? -Raymond]</p>
<p>No, only every COM program that starts with a NOP.</p>
<div class=post>[<i>Ah, right, sorry; I missed that part. It does make parsing the header significantly more difficult, however, since locating the header becomes O(n). -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611943">
				<div id="div-comment-611943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611943">
			March 24, 2008 at 6:13 pm</a>		</div>

		<p>command.com seems to have more compatibility stuff than cmd.exe, which wouldn&#8217;t need it since cmd.exe wasn&#8217;t around in DOS/9x/ME.</p>
<p>At least, I recall I prefer cmd.exe over command.com and I think that was the reason why.</p>
<p>I always knew about the &quot;MZ&quot; header but didn&#8217;t realize it was some guy&#8217;s initials.</p>
<p>Here&#8217;s some fun: <a rel="nofollow" target="_new" href="http://www.eicar.org/anti_virus_test_file.htm" rel="nofollow">http://www.eicar.org/anti_virus_test_file.htm</a></p>
<p>The ASCII string which is actually a binary COM file. &nbsp;You can paste it into notepad and save it as a .COM file and run it to see if your anti-virus catches it (it&#8217;s a harmless &quot;Hello World!&quot; style program used as a test for anti-virus products). &nbsp;I always thought it was kinda neat how it didn&#8217;t have any control codes or &gt;= 0x80 characters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-611953">
				<div id="div-comment-611953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611953">
			March 24, 2008 at 6:16 pm</a>		</div>

		<p>anon: There&#8217;s your problem. &nbsp;Starting a COM file with a NOP is perfectly acceptable since COM files have no syntax. &nbsp;The only way your idea would work is if you started the file with something that would be impossible to use at the beginning of the COM file because it wouldn&#8217;t work&#8230; like &quot;MZ&quot;. &nbsp;Of course if you use that or any variant your idea no longer works since it&#8217;s based on the idea that the file starts with acceptable COM code!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-611993">
				<div id="div-comment-611993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-611993">
			March 24, 2008 at 8:03 pm</a>		</div>

		<blockquote><p>
  And hey, as long as it all fits on a floppy, right?
</p></blockquote>
<p>To which end it appears that something along the lines of PKSFX was used to compress the executable.</p>
<p>As for using the real-mode stub for a PE executable, I&#8217;ve only seen it done once, I think it was for some old version of Excel that shipped with its own copy of Windows (since most people didn&#8217;t have Windows then) and the job of the stub was simply to execute &quot;win excel&quot;.</p>
<p>I guess fitting on a floppy was the main reason why Windows 95 xcopy.exe launched xcopy32.exe instead of being dual-mode.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-612003">
				<div id="div-comment-612003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Maxie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612003">
			March 24, 2008 at 8:04 pm</a>		</div>

		<p>The ZM signature was valied in DOS but not in Windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-612023">
				<div id="div-comment-612023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian Reiter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612023">
			March 24, 2008 at 8:37 pm</a>		</div>

		<blockquote><p>
  &gt; Also, Visual C++&#8217;s compiler uses a related trick at some point to provide both a GUI and command line version of itself under the same name (excluding file extension) &#8211; by having both .EXE and .COM versions, with the command line trying to run the .COM version first, unlike the GUI.</p>
<p>  That sounds inaccurate to me. &nbsp;
</p></blockquote>
<p>And yet it is true. If you use a command shell to execute &quot;devenv /build mysolution.sln&quot; then you&#8217;ll get devenv.com and it will be a text mode build. That&#8217;s because .COM comes before .EXE in the PATHEXT environmental variable.</p>
<p>One person&#8217;s backwards compatibility hack becomes another&#8217;s feature.</p>
<p>PS&gt; ($env:PATHEXT)</p>
<p>.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</p>
<p>PS&gt; get-command devenv | fl</p>
<p>Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: devenv.com</p>
<p>CommandType &nbsp; &nbsp; : Application</p>
<p>Definition &nbsp; &nbsp; &nbsp;: C:Program Files (x86)Microsoft Visual Studio 8Common7IDEdevenv.com</p>
<p>Extension &nbsp; &nbsp; &nbsp; : .com</p>
<p>Path &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: C:Program Files (x86)Microsoft Visual Studio 8Common7IDEdevenv.com</p>
<p>FileVersionInfo : File: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C:Program Files (x86)Microsoft Visual Studio 8Common7IDEdevenv.com</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;InternalName: &nbsp; &nbsp; DEVENV.COM</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OriginalFilename: DEVENV.COM</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FileVersion: &nbsp; &nbsp; &nbsp;8.0.50727.42 built by: RTM</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FileDescription: &nbsp;Microsoft Visual Studio Command Line</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Product: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Microsoft&#174; Visual Studio&#174; 2005</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ProductVersion: &nbsp; 8.0.50727.42</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Debug: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;False</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Patched: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;False</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PreRelease: &nbsp; &nbsp; &nbsp; True</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PrivateBuild: &nbsp; &nbsp; True</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SpecialBuild: &nbsp; &nbsp; False</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Language: &nbsp; &nbsp; &nbsp; &nbsp; English (United States)</p>
<p>Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: devenv.exe</p>
<p>CommandType &nbsp; &nbsp; : Application</p>
<p>Definition &nbsp; &nbsp; &nbsp;: C:Program Files (x86)Microsoft Visual Studio 8Common7IDEdevenv.exe</p>
<p>Extension &nbsp; &nbsp; &nbsp; : .exe</p>
<p>Path &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: C:Program Files (x86)Microsoft Visual Studio 8Common7IDEdevenv.exe</p>
<p>FileVersionInfo : File: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C:Program Files (x86)Microsoft Visual Studio 8Common7IDEdevenv.exe</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;InternalName: &nbsp; &nbsp; devenv.exe</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OriginalFilename: devenv.exe</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FileVersion: &nbsp; &nbsp; &nbsp;8.0.50727.867 built by: vsvista</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FileDescription: &nbsp;Microsoft Visual Studio 2005</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Product: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Microsoft&#174; Visual Studio&#174; 2005</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ProductVersion: &nbsp; 8.0.50727.867</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Debug: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;False</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Patched: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;False</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PreRelease: &nbsp; &nbsp; &nbsp; True</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PrivateBuild: &nbsp; &nbsp; True</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SpecialBuild: &nbsp; &nbsp; False</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Language: &nbsp; &nbsp; &nbsp; &nbsp; English (United States)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-612063">
				<div id="div-comment-612063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">reader</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612063">
			March 24, 2008 at 10:01 pm</a>		</div>

		<blockquote><p>
  @reader: The stack started at 0xFFFE and grew downwards.
</p></blockquote>
<p>0x00 to 0xFF was the Program Segment Prefix,</p>
<p>Oops, you&#8217;re right, I remembered incorrectly. &nbsp;My bad.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-612083">
				<div id="div-comment-612083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612083">
			March 24, 2008 at 10:37 pm</a>		</div>

		<p>I always liked the MZ+LE trick where you could write a VxD with a Dos stub was actually the Dos version of the program. The idea was that if you run it in Dos only the MZ part was used. &nbsp;But that hooks int 2fh and uses that hook to load a small VxD when with just enough logic to make it keep working after Windows has virtualized everything.</p>
<p><a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/74516" rel="nofollow">http://support.microsoft.com/kb/74516</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-612093">
				<div id="div-comment-612093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612093">
			March 24, 2008 at 11:03 pm</a>		</div>

		<p>I think xcopy32 was around just to give 16-bit xcopy long filename support.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-612123">
				<div id="div-comment-612123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://sourceforge.net/projects/winrosh' rel='external nofollow' class='url'>Robbie Mosaic</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612123">
			March 25, 2008 at 12:45 am</a>		</div>

		<p>cmd.exe is good enough, right? &nbsp;I don&#8217;t think it requires much improvement. &nbsp;We can build simple tools that drive cmd.exe such as my project winrosh to make it more fun. &nbsp;OTOH, xcopy, copy and move commands can be improved (to make copying/moving files more capable than using GUI operations), but not replaced with a single robocopy command.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-612033">
				<div id="div-comment-612033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612033">
			March 24, 2008 at 8:41 pm</a>		</div>

		<p>The .com + .exe trick for Visual Studio was introduced at least as early as VC6 (msdev.com, msdev.exe) and adapted for eMbedded Visual C++ (evc.com/.exe) then adopted also for the &#8216;unified IDE&#8217; of VS.NET 2002. VS 2008 still ships devenv.com and devenv.exe. The .com file is a small stub which loads the .exe, passing it a handle to the console that the .com was loaded in, so that Visual Studio&#8217;s build system can send output to that console. The ability to attach a program not already associated with a console to an existing console, using the AttachConsole function, was only added in Windows XP. The devenv.com program itself is a renamed console-subsystem Windows executable (PE file).</p>
<p>@Mats Gefvert: CMD.EXE is a console-mode subsystem command interpreter. It isn&#8217;t required for running console-mode programs. x64 systems have a 32-bit version in %SystemRoot%SysWOW64 and a 64-bit build in %SystemRoot%System32.</p>
<p>COMMAND.COM is the 16-bit DOS interpreter, and it *is* loaded for a DOS environment as DOS programs expected it to be there. x64 systems do not contain COMMAND.COM as they have no Virtual DOS Machine environment (ntvdm), as the required processor submode was removed by AMD. (It&#8217;s still there if you boot the processor in 32-bit protected mode, but a 64-bit OS cannot access it.) If you type COMMAND into the run box rather than CMD, you get a less functional, slower command interpreter on 32-bit, and an error on 64-bit. Use CMD.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-612153">
				<div id="div-comment-612153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612153">
			March 25, 2008 at 4:51 am</a>		</div>

		<p>@Mike Dimmick</p>
<p>&quot;x64 systems do not contain COMMAND.COM as they have no Virtual DOS Machine environment (ntvdm), as the required processor submode was removed by AMD. (It&#8217;s still there if you boot the processor in 32-bit protected mode, but a 64-bit OS cannot access it.)&quot;</p>
<p>True enough. But did you know that HAL in Windows XP x64 actually emulates 16 bit Bios code in software so that video drivers which still need to can call it? I guess by the time Vista 64 shipped the video card vendors had had enough time to find another way to get whatever information they wanted, because the emulator is no longer present there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-612163">
				<div id="div-comment-612163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Elliott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612163">
			March 25, 2008 at 5:59 am</a>		</div>

		<p>When 8-bit CP/M needed an expanded COM file format, the magic number used was 0xC9, which in 8080 machine code is RET. Later another extension was added by third-party developers, and that used 0xC7 (RST 0; it would be like starting a DOS COM file with 0xCD 0x20, INT 20h).</p>
<p>I think there&#8217;s another criterion for a file being treated as EXE rather than COM; it&#8217;s got to be big enough to contain the EXE header. So this: 4d 5a ba 0c 01 b1 09 e8 fb fe cd 20 48 65 6c 6c 6f 24 is run as a COM file (at least on XP), despite starting MZ.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-612243">
				<div id="div-comment-612243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Yuhong Bao</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612243">
			March 25, 2008 at 10:55 am</a>		</div>

		<p>&quot;But did you know that HAL in Windows XP x64 actually emulates 16 bit Bios code in software so that video drivers which still need to can call it? I guess by the time Vista 64 shipped the video card vendors had had enough time to find another way to get whatever information they wanted, because the emulator is no longer present there.&quot;</p>
<p>Indeed the call for doing this was removed in WDDM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-612493">
				<div id="div-comment-612493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">me</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612493">
			March 25, 2008 at 2:12 pm</a>		</div>

		<p>Just a little nitpicking: .COM files are not limited to 64 KB. They can grow larger and address all of the space, at least on MS-DOS 3.2 and after. The only problem is that the writer of the .COM file has to handle all the segment arithmetic on his own, as the DOS loader did not perform any adjustments (as it does with .EXE files).</p>
<p>Of course, switching to the MZ-EXE was a good move in the first place.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-612553">
				<div id="div-comment-612553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-612553">
			March 25, 2008 at 3:20 pm</a>		</div>

		<p>DEVENV.exe vs DEVENV.com</p>
<p>this is true.</p>
<p>DevEnv.com is the one that correctly handles piping/buffering the output so you can pipe it in something else. &nbsp;</p>
<p>So when you build at the command line, it uses devenv.com and you see the build output as it &nbsp;progresses.. &nbsp;if you used DevEnv.exe, you only got the result at the end.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-632593">
				<div id="div-comment-632593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://wampir.mroczna-zaloga.org/archives/344-Tamagotchi-XI-zagubione-pliki.html' rel='external nofollow' class='url'>Wampiryczny blog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033#comment-632593">
			May 23, 2008 at 4:10 pm</a>		</div>

		<p>Wiem już, że kilka plik&#243;w, kt&#243;re były wykorzystywane podczas infekcji, nie jest widocznych w systemie plik&#243;w. Oznacza to (najprawdopodobniej), że zostały one usunięte&#8230; Czego szukam&#8230; Pliki, kt&#243;rych szukam: C:Documents and SettingsAdmini</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

