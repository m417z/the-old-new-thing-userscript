<html>
<head>
<title>Basic ground rules for programming - function parameters and how they are used</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Basic ground rules for programming &#8211; function parameters and how they are used</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 20, 2006 / year-entry #101</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>48</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">There are some basic ground rules that apply to all system programming, so obvious that most documentation does not bother explaining them because these rules should have been internalized by practitioners of the art to the point where they need not be expressed. In the same way that when plotting driving directions you wouldn't even...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>There are some basic ground rules that apply to all system programming, so obvious that most documentation does not bother explaining them because these rules should have been internalized by practitioners of the art to the point where they need not be expressed. In the same way that when plotting driving directions you wouldn't even consider taking a shortcut through somebody's backyard or going the wrong way down a one-way street, and in the same way that an experienced chess player doesn't even consider illegal moves when deciding what to do next, an experienced programmer doesn't even consider violating the following basic rules without explicit permission in the documentation to the contrary:</p>
<ul>
<li>Everything not defined is undefined.     This may be a tautology, but it is a useful one.     Many of the rules below are just special cases of this rule. </li>
<li>All parameters must be valid.     The contract for a function applies only when the caller adheres     to the conditions, and one of the conditions is that the parameters     are actually what they claim to be.     This is a special case of the "everything not defined is undefined"     rule.     
<ul>
<li>Pointers are not <code>NULL</code> unless explicitly permitted     otherwise.     </li>
<li>Pointers actually point to what they purport to point to.     <a href="http://cboard.cprogramming.com/showthread.php?t=73713">     If a function accepts a pointer to a <code>CRITICAL_SECTION</code>,     then you really have to pass pointer to a valid     <code>CRITICAL_SECTION</code></a>.     </li>
<li>Pointers are properly aligned.     Pointer alignment is a fundamental architectural requirement,     yet something many people overlook having been pampered by     a processor architecture that is very forgiving of alignment errors.     </li>
<li>The caller has the right to use the memory being pointed to.     This means no pointers to memory that has been freed     or memory that the caller does not have control over.     </li>
<li>All buffers are valid to the size declared or implied.     If you pass a pointer to a buffer and say that it is ten bytes     in length, then the buffer really needs to be ten bytes in length.     </li>
<li>Handles refer to valid objects that have not been destroyed.     If a function wants a window handle, then you really have     to pass a valid window handle.     </li>
</ul>
</li>
<li>All parameters are stable.     
<ul>
<li>You cannot change a parameter while the function call is     in progress.     </li>
<li>If you pass a pointer, the pointed-to memory will not     be modified by another thread for the duration of the call.     </li>
<li>You can't free the pointed-to memory either.     </li>
</ul>
</li>
<li>The correct number of parameters is passed with the correct     calling convention.     This is another special case of the "everything not defined is undefined"     rule.     
<ul>
<li>Thank goodness modern compilers refuse to pass the wrong     number of parameters, though you'd be surprised     how many people manage to sneak the wrong number of parameters     past the compiler anyway, usually by devious casting.     </li>
<li>When invoking a method on an object, the <code>this</code>     parameter is the object.     Again, this is something modern compilers handle automatically,     though people using COM from C (and yes they exist) have to     pass the <code>this</code> parameter manually, and occasionally     they mess up.     </li>
</ul>
</li>
<li>Function parameter lifetime.     
<ul>
<li>The called function can use the parameters during the execution     of the function.     </li>
<li>The called function cannot use the parameters once the function     has returned.     Of course, if the caller and the callee have agreed on a means of     extending the lifetime, then those rules apply.     
<ul>
<li>The lifetime of a parameter that is a pointer to a COM     object can be extended by the use of the <code>IUnknown::AddRef</code>     method.     </li>
<li>Many functions are passed parameters with the express intent     that they be used after the function returns.     It is then the caller's responsibility to ensure that the lifetime     of the parameter is at least as long as the function needs it.     For example, if you register a callback function, then the callback     function needs to be valid until you deregister the callback function.     </li>
</ul>
</li>
</ul>
</li>
<li>Input buffers.     
<ul>
<li>A function is permitted to read from the full extent of the buffer     provided by the caller, even if not all of the buffer is required     to determine the result.     </li>
</ul>
</li>
<li>Output buffers.     
<ul>
<li>An output buffer cannot overlap an input buffer or another     output buffer.     </li>
<li>A function is permitted to write to the full extent of the buffer     provided by the caller, even if not all of the buffer is required     to hold the result.     </li>
<li>If a function needs only part of a buffer to hold the     result of a function call, the contents of the unused portion of     the buffer are undefined.     </li>
<li>If a function fails and the documentation does not specify     the buffer contents on failure,     then the contents of the output buffer are undefined.     This is a special case of the "everything not defined is undefined"     rule.     </li>
<li>Note that COM imposes its own rules on output buffers.     COM requires that all output buffers be in a marshallable state     even on failure.     For objects that require nontrivial marshalling     (interface pointers and BSTRs being the most common examples),     this means that the output pointer must be <code>NULL</code>     on failure.     </li>
</ul>
</li>
</ul>
<p> (Remember, every statement here is a basic ground rule, not an absolute inescapable fact.  Assume every sentence here is prefaced with "In the absence of indications to the contrary". If the caller and callee have agreed on an exception to the rule, then that exception applies. For example, a pointer is prototyped as <code>volatile</code> is explicitly marked as "This value can change from another thread," so the rule against modifying function parameters does not apply to such a pointer.) </p>
<p> Coming up with this was hard, in the same way it's hard to come up with a list of illegal chess moves. The rules are so automatic that they aren't really rules so much as things that simply are and it would be crazy even to consider otherwise. As a result, I'm sure there are other "rules so obvious they need not be said" that are missing. (For example, "You cannot terminate a thread while it is inside somebody else's function.") </p>
<p> One handy rule of thumb for what you can do to a function call is to ask, "How would I like it if somebody did that to me?" (This is a special case of the "Imagine if this were possible" test.) </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (48)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-356423">
				<div id="div-comment-356423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356423">
			March 20, 2006 at 10:56 am</a>		</div>

		<p>A very useful cluestick to hit people with who really should know this (or stop coding for a living) is:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncomg/html/msdn_therules.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncomg/html/msdn_therules.asp</a></p>
<p>It covers a number of the most common rules that I&#8217;ve found other people break, apart from one. I can&#8217;t seem to find anywhere on MSDN the rule that says that NULL is a valid BSTR, and must be accepted as if it were a BSTR of zero length. I&#8217;ve got it in a couple of books, seen it around on the net (in particular Eric Lippert&#8217;s blog), and know it to be true, but I can&#8217;t find an <em>authoritative</em> (i.e. official documentation) URL to point people who aren&#8217;t in the same office as me at.</p>
<p>Any help anyone?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356433">
				<div id="div-comment-356433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356433">
			March 20, 2006 at 11:28 am</a>		</div>

		<p>This is one of my favorites.</p>
<p>&quot;An output buffer cannot overlap an input buffer or another output buffer.&quot;</p>
<p>On a project I used to work on, I debugged several intermittent crashes caused by calls like this:</p>
<p>strFoo.Format(&quot;prefix %s suffix&quot;, strFoo);</p>
<p>(where strFoo is ATL::CString). &nbsp;At a glance, it&#8217;s not immediately obvious that you&#8217;re overlapping input and output buffers. &nbsp;In fact, for some string implementations, this wouldn&#8217;t be an overlap.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-356443">
				<div id="div-comment-356443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356443">
			March 20, 2006 at 11:31 am</a>		</div>

		<p>Adam: &quot;A null pointer is a valid value for a BSTR variable. By convention, it is always treated the same as a pointer to a BSTR that contains zero characters.&quot;</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/en-us/wcedcom/html/cerefStringManipulationFunctions.asp" rel="nofollow">http://msdn.microsoft.com/library/en-us/wcedcom/html/cerefStringManipulationFunctions.asp</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356453">
				<div id="div-comment-356453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://matthew.chaboud.com' rel='external nofollow' class='url'>Matthew Chaboud</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356453">
			March 20, 2006 at 11:38 am</a>		</div>

		<p>Clearly, Raymond has no sense of adventure.</p>
<p>I have to admit that I occasionally find code that is so incomprehensibly inane that I wonder how the code every managed to work in the first place. &nbsp;Sometimes it violates some of these rules. &nbsp;Sometimes it&#8217;s code I wrote ten years ago&#8230;</p>
<p>Imagine if you were first handed the keys to a car in an unpopulated city with no instruction. &nbsp; You very well might drive on the lawns. &nbsp;I think that programmers need to be taught what is right many times, taught what is wrong a few times, or learn it on their own, once.</p>
<p>I know plenty of programmers who will never need to care about argument volatility because they will never be charged with handling threading on their own. &nbsp;This is, honestly, probably a good thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356463">
				<div id="div-comment-356463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356463">
			March 20, 2006 at 12:12 pm</a>		</div>

		<p>On the flip side, functions that declare parameters as const MUST NOT change them. I remember tracking down a crash in a call to a Microsoft multimedia library routine many years ago. The author of the routine apparently decided that const meant it was okay to change a byte in the caller&#8217;s const string as long as he changed it back before returning. Since the string was declared in a read-only segment this didn&#8217;t work too well, even in a single-threaded environment. Imagine how much fun it would have been to track down that bug in a multi-threaded situation if the string had been writeable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356473">
				<div id="div-comment-356473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Raymond II</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356473">
			March 20, 2006 at 12:18 pm</a>		</div>

		<p>&quot;Pointers are not NULL unless explicitly permitted otherwise.&quot;</p>
<p>I guess it&#8217;s assumed that most, if not all functions that accept a handle to a device context, allow the pointer to be NULL, or else programs would have to start checking the return value of BeginPaint before passing the DC handle along. &nbsp;Although &quot;indoctrinated&quot; developers may have no problem understanding (accepting) this, more critical people may question why there&#8217;s no mention of this anywhere in the documentation?</p>
<p>Example: The function TextOut states only this (hDC): &quot;[in] Handle to the device context.&quot; &nbsp;There&#8217;s no mention of a NULL hDC.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356483">
				<div id="div-comment-356483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://msmvps.com/alunj' rel='external nofollow' class='url'>Alun Jones</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356483">
			March 20, 2006 at 12:33 pm</a>		</div>

		<p>My favourite rule, from over a decade of telling people how to write Winsock programs, is that a &quot;flags&quot; value that is documented that it &quot;may be any of the following values&quot; can also be zero, which gives the default behaviour. &nbsp;Only when a flag &quot;must be a combination of one or more of these values&quot; do you have to pick at least one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356493">
				<div id="div-comment-356493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dmitry Shaporenkov</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356493">
			March 20, 2006 at 12:44 pm</a>		</div>

		<p>Quoting Raymond:</p>
<p>&quot;All parameters are stable.</p>
<p> &nbsp; &nbsp;* You cannot change a parameter while the function call is in progress.&quot;</p>
<p>I don&#8217;t understand why my function can&#8217;t change a value of a parameter if the parameter is passed by value and is thus equivalent to a local variable whose lifetime is limited by a function execution time? Thanks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-356503">
				<div id="div-comment-356503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356503">
			March 20, 2006 at 12:49 pm</a>		</div>

		<p>Raymond II: NULL is indeed an invalid value for TextOut&#8217;s HDC parameter. (And which the chk version of Windows reports to the debugger.) </p>
<p>I already explained in this post why it isn&#8217;t mention that you can&#8217;t pass invalid parameters. </p>
<p>Dmitry: If you pass it by value, then the value you&#8217;re changing isn&#8217;t the one that you passed to the function. (The function got a copy, and you&#8217;re not changing the copy.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356513">
				<div id="div-comment-356513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356513">
			March 20, 2006 at 1:51 pm</a>		</div>

		<p>Amazingly, I&#8217;ve seen C compilers accept the wrong number of arguments without a warning.<br />
<br />It was some time ago, so I can&#8217;t remember whether the header containing the function prototype was correctly included, but even that should generate a warning.</p>
<p>(I can&#8217;t remember if it was an old GCC or an (older?) IBM &nbsp;RS6000 &#8216;cc&#8217;. I used both at the time)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356523">
				<div id="div-comment-356523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">theorbtwo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356523">
			March 20, 2006 at 2:30 pm</a>		</div>

		<p>There are, of course, interesting times when you really want to do interesting things, when you can get away with ignoring the rules. &nbsp;For example, there&#8217;s a lovely perl module, Win32::API, which lets you call arbitrary (winapi calling convention) functions without complining C for every call you want to do. &nbsp;It works by using inline assembler to push the arguments to the stack, then calls the function with too few arguments on purpose.</p>
<p>Is it fragile code? &nbsp;Yes. &nbsp;Is it the least fragile way possible to do what you want done? &nbsp;In this case, yes. &nbsp;Breaking the rules is sometimes neccessary to make the impossible possible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356533">
				<div id="div-comment-356533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Raymond II</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356533">
			March 20, 2006 at 2:33 pm</a>		</div>

		<p>oldnewthing: &quot;NULL is indeed an invalid value for TextOut&#8217;s HDC parameter.&quot;</p>
<p>I mentioned checking the return value of BeginPaint for a reason. &nbsp;I haven&#8217;t seen any application do this, despite the fact that the programmers would know nothing about the behaviour when passing an invalid value, other than &quot;oh well, it appears to work.&quot;<br />
<br />It&#8217;s easy when you know the answer. &nbsp;Some aren&#8217;t even aware of the questions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356543">
				<div id="div-comment-356543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Noob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356543">
			March 20, 2006 at 2:40 pm</a>		</div>

		<p>All parameters must be valid. </p>
<p>does it means that the fonction doesnt need to check for range for exemple ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-356553">
				<div id="div-comment-356553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356553">
			March 20, 2006 at 2:47 pm</a>		</div>

		<p>&quot;does it means that the fonction doesnt need to check for range for exemple?&quot;</p>
<p>It means that a program that passes invalid parameters will experience undefined behavior. The function can do anything it wants. That&#8217;s what &quot;undefined&quot; means.</p>
<p>The perl module that conses up a callstack is ultimately following the rules &#8211; it just does it in a strange way. When the called function gets control, the correct number of parameters are on the stack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356563">
				<div id="div-comment-356563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Purplet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356563">
			March 20, 2006 at 2:50 pm</a>		</div>

		<blockquote><p>
  &gt; Amazingly, I&#8217;ve seen C compilers accept the wrong number of arguments without a warning. </p>
<p>As far as I know, the &quot;&#8230;&quot; for variadic functions was introduced with C++. </p>
<p>So under C89 (don&#8217;t know about C99) and before, the prototype of printf was :</p>
<p>int printf (const char * format); </p>
<p>Note that since under a &quot;cdecl&quot; calling convention this works (by design) because parameters are pushed right to left and are removed from the stack by the caller.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356573">
				<div id="div-comment-356573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356573">
			March 20, 2006 at 2:50 pm</a>		</div>

		<p>Noob: &nbsp;</p>
<p>There are different schools of thought on that one. &nbsp;Many people say that routine should always check parameters, but that just leads to slow code. &nbsp;An alternative is to assert parameter checks so they aren&#8217;t in release builds. &nbsp;</p>
<p>IMHO, anytime you are jumping a wall (for example, a programmer calling one of your functions inside your library), you should check the input parameters. &nbsp;However, once checked, any routines in your library that you call from inside your library should not check the input parameters since you assume that you know how to call you own code. &nbsp;This helps to protect you from external parameter bugs while not slowing your internal code down with a lot of parameter checks.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356583">
				<div id="div-comment-356583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Csaboka</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356583">
			March 20, 2006 at 3:05 pm</a>		</div>

		<p>Purplet: I think you&#8217;re wrong. I&#8217;ve read the Kernighan-Ritchie C book (the updated version that follows the ANSI standard), and it does contain the using of &quot;&#8230;&quot; in parameter lists, plus how the callee can access the extra parameters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356593">
				<div id="div-comment-356593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark Steward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356593">
			March 20, 2006 at 3:25 pm</a>		</div>

		<p>Now that&#8217;s a nice URL &#8211; in the future, I&#8217;m gonna send everyone to <a rel="nofollow" target="_new" href="http://blogs.msdn.com/555511.aspx" rel="nofollow">http://blogs.msdn.com/555511.aspx</a> :D</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356603">
				<div id="div-comment-356603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356603">
			March 20, 2006 at 4:10 pm</a>		</div>

		<p>You forgot the sine qua non of correct function calls:</p>
<p>Every time you write a function call, read the function&#8217;s documentation.</p>
<p>Obviously I&#8217;m exaggerating a little, but not much.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356613">
				<div id="div-comment-356613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.kotarski.org' rel='external nofollow' class='url'>Nick Kotarski</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356613">
			March 20, 2006 at 4:17 pm</a>		</div>

		<p>I seem to remember a maxim from the old days: constants arn&#8217;t, variables won&#8217;t.</p>
<p>Also with Fortran compilers passing a constant (say 1) to a function could result in the constant being changed globally, or at least for that compilation unit, (to say 2). This leads to some very bizarre behavior.</p>
<p><a rel="nofollow" target="_new" href="http://www.ibiblio.org/pub/languages/fortran/ch1-8.html#01" rel="nofollow">http://www.ibiblio.org/pub/languages/fortran/ch1-8.html#01</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356623">
				<div id="div-comment-356623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Purplet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356623">
			March 20, 2006 at 4:28 pm</a>		</div>

		<blockquote><p>
  &gt; Purplet: I think you&#8217;re wrong.</p>
<p>You&#8217;re right :) C89 uses infact ellipsissesesses (or whatever the plural of ellipsis is :)). </p>
<p>It is not even K&amp;R since in K&amp;R no format parameter can be there.. so probably I smoked something when I thought of this issue :|
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356633">
				<div id="div-comment-356633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nate</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356633">
			March 20, 2006 at 4:40 pm</a>		</div>

		<blockquote><p>
  Pointers are properly aligned.</p>
<p>Now there&#8217;s a new one to me! &nbsp;Call me pampered&#8230; &nbsp;Can you elaborate on this? &nbsp;Isn&#8217;t it true that a pointer is a pointer is a pointer?!<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-356643">
				<div id="div-comment-356643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356643">
			March 20, 2006 at 4:47 pm</a>		</div>

		<p>Nate: Type &quot;alignment&quot; into the search box.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356653">
				<div id="div-comment-356653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356653">
			March 20, 2006 at 5:14 pm</a>		</div>

		<p>Of course, &quot;Pointers are not NULL unless explicitly permitted otherwise.&quot; makes sense to a C programmer, but a C++ developer community could reasonably assume that a reference would be used unless something interesting is going on.</p>
<p>There are really two types of rule here: those that have no exception, which are better enumerated by the language and platform definitions, and those that are specific to a culture or developers. Code within a project should be consistent, but pretending such rules are broader than that is foolish. Since it doesn&#8217;t specify a scope, your list is foolish.</p>
<p>Overall, it&#8217;s better to document &quot;p != NULL&quot; or &quot;The range (a, a+N] is readable and disjoint from the range (b, b+N], which is writable&quot; than to assume that they&#8217;re &quot;so obvious they don&#8217;t need stating!&quot;. free and fread differ on the first point; memcpy and memmove differ on the latter. If you think there&#8217;s a general case, you need to get out of your box.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356663">
				<div id="div-comment-356663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356663">
			March 20, 2006 at 5:18 pm</a>		</div>

		<p>While I&#8217;m not arguing against this guideline I do have a rant against people doing this &quot;no pointer can be null&quot; rule blindly:</p>
<p>The problem is that the C standard uses pointers to mean both pointers to objects and array iterators but they didn&#8217;t provide a way to define a low overhead 0 sized array. The C++ standard requires (T<em>)0+0==(T</em>)0 and (T<em>)0-(T</em>)0==0 and many vector implementations take advantage of this instead of trying to allocate some dummy argument to support this. The C standard isn&#8217;t so smart in this area and most standard functions are undefined if you pass it a null pointer even you pass in the size as 0.</p>
<p>Moral of this story, if taking an array and allowing 0 size to be valid, do (size!=0 &amp;&amp; ptr==0) instead of (ptr==0) or just don&#8217;t do any pointer checks at all. Your users will thank you for it.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356683">
				<div id="div-comment-356683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sebastian Redl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356683">
			March 20, 2006 at 7:29 pm</a>		</div>

		<p>Yay, I feel famous! I&#8217;m the CornedBee in that linked thread.</p>
<p>By the way, is what I said about SuspendThread correct?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356693">
				<div id="div-comment-356693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://notes.dpdx.net' rel='external nofollow' class='url'>Brooks Moses</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356693">
			March 20, 2006 at 7:35 pm</a>		</div>

		<p>&quot;does it means that the fonction doesnt need to check for range for exemple?&quot;</p>
<p>No. &nbsp;There&#8217;s a concept from the current Fortran standards that&#8217;s very useful here &#8212; the distinction between requirements on the user and requirements on the provider of the interface (which, in the Fortran standard, is the compiler).</p>
<p>That is, when you are <em>using</em> a function, you should not assume that it will check for invalid range, unless told otherwise.</p>
<p>However, when you are <em>writing</em> a function, that&#8217;s a different set of constraints. &nbsp;In my opinion, if you&#8217;re writing something for general use, you should check for invalid inputs unless you&#8217;ve got a good reason (e.g., performance or excessive code complication) not to.</p>
<p>And then, having written the function, you should document whether or not it checks for valid inputs.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356703">
				<div id="div-comment-356703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://notes.dpdx.net' rel='external nofollow' class='url'>Brooks Moses</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356703">
			March 20, 2006 at 7:37 pm</a>		</div>

		<p>Nick, you&#8217;re unfairly slighting Fortran compilers. &nbsp;That problem only happened on a few very ancient compilers. &nbsp;Even the worst Fortran compilers from two decades ago are smart enough not to do such things. &nbsp;(The problem, fundamentally, is that Fortran is normally implemented as pass-by-reference, and the compilers were passing a reference to a reused pooled constant rather than a copy of it, and there was no protection to keep it from being overwritten.)</p>
<p>This is compounded by the fact that Fortran programs can be compiled in multiple separate pieces, with the older versions of the language having no C-header-like methods for transferring interface information from one piece to another so the compiler can check it. &nbsp;(This has been much improved in newer versions of Fortran.)</p>
<p>I&#8217;m surprised that the problems with lack of compiler-checking for argument matchup don&#8217;t happen in C programs, too. &nbsp;Sure, you include the function prototypes in a header file in everything you compile, but what if you change the prototype, recompile only half the code, and then link it all? &nbsp;Or what if you simply use the wrong header file that happens to have a function of the same name in it?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356713">
				<div id="div-comment-356713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356713">
			March 20, 2006 at 7:43 pm</a>		</div>

		<blockquote><p>
  Nate: Type &quot;alignment&quot; into the search box. </p>
<p>Yippee! I&#8217;m Chaotic Good.</p>
<p>Seriously though, it is very nice and wonderfully idealised academic list Raymond&#8217;s written, but I think the word &quot;Rule&quot; is, at best, a touch strong. If you break a rule in chess you have cheated and get disqualified.</p>
<p>Even if you break Raymonds Rules above you&#8217;re still competing in the Great Coding Tournament of Life.</p>
<p>Perhaps we should be using Scrabble instead of Chess as the analogy; Scrabble allows cheating, sometimes you get caught, sometimes you don&#8217;t.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356723">
				<div id="div-comment-356723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356723">
			March 20, 2006 at 8:02 pm</a>		</div>

		<blockquote><p>
  Yippee! I&#8217;m Chaotic Good. </p>
<p>Good for you. I&#8217;m Chaotic Neutral &#8211; I like excitement!
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356733">
				<div id="div-comment-356733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356733">
			March 20, 2006 at 8:11 pm</a>		</div>

		<p>Then meet my &amp;sword++;</p>
<p>:-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356753">
				<div id="div-comment-356753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356753">
			March 20, 2006 at 8:37 pm</a>		</div>

		<p>Brooks:</p>
<p>In C, those type of issues do happen a lot. &nbsp;Old C compilers didn&#8217;t require you to prototype routines. &nbsp;So they assumed you knew what you were doing. &nbsp;Even after prototypes were required (by either the standard or by compiler warnings), there are things you can do to mess up. &nbsp;For example if you declare your function in one module as taking 2 arguments but in another module declare the prototype with only one argument, C will compile and link just fine. &nbsp;The big difference between C and C++ are the mangled names used by the linker in C++. &nbsp;Those mangled names contain all the argument information thus preventing the prototype error . &nbsp;C doesn&#8217;t mangle the names. &nbsp;Thus &quot;void Bob (int)&quot; in one module and &quot;int Bob (char *)&quot; in another both compile down to a routine name of &quot;_Bob&quot;. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356673">
				<div id="div-comment-356673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Purplet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356673">
			March 20, 2006 at 5:49 pm</a>		</div>

		<p>&gt;&gt; Pointers are properly aligned. </p>
<p>I think (this is not my evening so think is the proper word) that he&#8217;s saying that a pointer should point to a memory location which is correctly aligned for the data type you will access.</p>
<p>Given typical sizes for types (16bit for short and wchar_t, 32bit for int and float, 64bit for double) a short* and a wchar_t* should point to a 16bit aligned address (that is, an even number); an int* and a float* should point to 32bit aligned addresses; double* should point to 64bit aligned addresses.<br />
<br />Also care must be taken for pointers.. on 64bit machines, void** should be 64bit aligned.</p>
<p>Raymond is referring to forgivin processors because x86 processors handle misaligned data accesses themselves (if the AC flag is 0, which it usually is) and only a small, often negligible, performance impact incours. Other processors (MIPS, PowerPC, Alpha) may raise an exception on misaligned data access and thus your program might fail to work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356793">
				<div id="div-comment-356793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">8</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356793">
			March 21, 2006 at 6:08 am</a>		</div>

		<p>Never pass a pointer to a goto label as an argument.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356803">
				<div id="div-comment-356803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jasonhaley.com/blog/archive/2006/03/21/136339.aspx' rel='external nofollow' class='url'>Jason Haley</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356803">
			March 21, 2006 at 8:34 am</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356823">
				<div id="div-comment-356823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356823">
			March 21, 2006 at 9:41 am</a>		</div>

		<p>Nick,</p>
<p>It isn&#8217;t a question about &quot;on purpose&quot;. &nbsp;In large systems, without well managed prototype files, it happens a fair amount.</p>
<p>In C++ you have to go out of your way to do it. &nbsp;In C, it happens by mistake.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356833">
				<div id="div-comment-356833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cd-MaN</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356833">
			March 21, 2006 at 10:30 am</a>		</div>

		<blockquote><p>
  Pointers are properly aligned.</p>
<p>A question: do modern compilers automatically align variables? Because if not and you have to put #pragma&#8217;s all over your code to keep it aligned, this rule seems kind of hard to follow and in the spirit of &quot;let&#8217;s squeeze every bit of performance, event if it makes the impossible to maintain&quot;.</p>
<p>Also, what if I have to access a dword member of a structure which is byte aligned?<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-356863">
				<div id="div-comment-356863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356863">
			March 21, 2006 at 10:43 am</a>		</div>

		<p>VC has been using natural alignment for a very long time. &nbsp;The default is eight byte alignment which means that data will be aligned by size up to eight bytes in size. &nbsp;In a more geek term, (address MOD size) == 0 for anything eight bytes and smaller.</p>
<p>In general, you don&#8217;t have to worry about alignment unless you are packing data into memory or reading structures from disk. &nbsp;If you don&#8217;t want to worry about alignment but still want your structures and classes to be small, then order your member variables by size. &nbsp;The biggest problem is having small member variables mixed in with large ones. &nbsp;You end up with gaps in the structure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-356783">
				<div id="div-comment-356783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick Lamb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-356783">
			March 21, 2006 at 4:41 am</a>		</div>

		<p>“if you declare your function in one module as taking 2 arguments but in another module declare the prototype with only one argument, C will compile and link just fine”</p>
<p>But you can only do this &quot;on purpose&quot;, that is to say by having two declarations of the function which are hidden from each other (you&#8217;ll get a compiler warning or error if it sees both, depending on the context). It&#8217;s possible to conjure the same mistake in C++ by judicious casting. Cast the function to the wrong type in your headers, then call it, and you get the wrong answers.</p>
<p>int (* wrongBob)(char *) = (int (*)(char *)) Bob;<br />
<br />int result = wrongBob(&quot;my input&quot;); /* unexpected results */</p>
<p>I&#8217;m not sure its necessary to wait for the user to swing the gun round and stuff it into their own mouth before agreeing to shoot them in the foot if they so ask.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-357193">
				<div id="div-comment-357193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DavidE</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-357193">
			March 21, 2006 at 1:47 pm</a>		</div>

		<p>Thank you for this! I wish I had this set of rules at my last job. We often had well-meaning but overzealous testers who wanted us to handle invalid pointers and other garbage inputs in APIs that weren&#8217;t designed for it. In one project, my team was forced to catch NULL pointers as errors because the testers assumed that the programmers using our APIs were too lazy to check for them (and yet they would somehow handle error returns properly).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-357303">
				<div id="div-comment-357303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.kotarski.org' rel='external nofollow' class='url'>Nick Kotarski</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-357303">
			March 21, 2006 at 3:05 pm</a>		</div>

		<blockquote><p>
  Nick, you&#8217;re unfairly slighting Fortran compilers. &nbsp;That problem only happened on a few very ancient compilers. &nbsp;Even the worst Fortran compilers from two decades ago are smart enough not to do such things. &nbsp;(The problem, fundamentally, is that Fortran is normally implemented as pass-by-reference, and the compilers were passing a reference to a reused pooled constant rather than a copy of it, and there was no protection to keep it from being overwritten.)</p>
<p>Brooks, you are reading far too much into my little quip.</p>
<p>Firstly: &quot;in the old days&quot; applied to the Fortran as well. This was between 25 and 30 years ago on a Pr1me 300 mini. I don&#8217;t even remember if the hardware could do write protection.</p>
<p>Secondly: some compilers used call by reference others used call-by-value-return. I suspect that the Pr1me compiler used call by reference. &nbsp;Ed Post points out in &quot;Real Programmers Don&#8217;t Use Pascal&quot; that call-by-value-return is the only parameter passing mechanism used by Real Programmers.</p>
<p>Thirdly: I know all that about pooled constants and the link explained that.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-357313">
				<div id="div-comment-357313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-357313">
			March 21, 2006 at 3:12 pm</a>		</div>

		<p>Brooks Moses:</p>
<p>&gt; what if you change the prototype, recompile only half the code, and then link it all?</p>
<p>That&#8217;s what make(1) is for. &nbsp;You tell it which C files depend on which header files (or you use the compiler to do it for you, as in gcc&#8217;s -Mx arguments), you tell it that any .o file can be compiled from a .c file of the same name (or you depend on the default rule that says this), and you tell it which .o files you want to link. &nbsp;Then when you change a header, make will rebuild all the C files for you, before it relinks the final executable.</p>
<p>nmake probably works similarly, though I don&#8217;t know what kind of default rules it has, and I don&#8217;t know whether the VC compiler can generate header dependencies automatically or not.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-357413">
				<div id="div-comment-357413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rich</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-357413">
			March 21, 2006 at 7:23 pm</a>		</div>

		<p>&quot;That is, when you are <em>using</em> a function, you should not assume that it will check for invalid range, unless told otherwise. </p>
<p>However, when you are <em>writing</em> a function&#8230;you should check for invalid inputs &quot;</p>
<p>So, why are we as developers admonished to provide idiot-proof APIs when the OS developers are apparently held to no such standard?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-357933">
				<div id="div-comment-357933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.synesthesia.co.uk/blog/archives/2006/03/22/links-35/' rel='external nofollow' class='url'>Synesthesia &raquo; Links Roundup for 2006-03-21</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-357933">
			March 22, 2006 at 2:58 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.synesthesia.co.uk/blog/archives/2006/03/22/links-35/" rel="nofollow">http://www.synesthesia.co.uk/blog/archives/2006/03/22/links-35/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-358983">
				<div id="div-comment-358983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-358983">
			March 24, 2006 at 11:54 am</a>		</div>

		<p>&quot;So, why are we as developers admonished to provide idiot-proof APIs when the OS developers are apparently held to no such standard?&quot;</p>
<p>If you can&#8217;t answer this question, just play it safe and idiot-proof your own APIs and assume that no other API is idiot-proof. &nbsp;This is a rule of thumb (<a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Rule_of_thumb" rel="nofollow">http://en.wikipedia.org/wiki/Rule_of_thumb</a>), not any sort of standard.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-359283">
				<div id="div-comment-359283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">D</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-359283">
			March 27, 2006 at 7:24 am</a>		</div>

		<p>&quot;though you&#8217;d be surprised how many people manage to sneak the wrong number of parameters past the compiler anyway&quot;</p>
<p>VB6 made doing this easy. Try adding a class, and add a public function to that class that has no arguments and returns a variant. </p>
<p>I remember finding you could pass whatever you like to this function and it compiles fine&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-359293">
				<div id="div-comment-359293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">8</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-359293">
			March 27, 2006 at 8:15 am</a>		</div>

		<p>But in VB, you could also skip arguments, like somefunction(arg1,,arg3) iirc</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-368083">
				<div id="div-comment-368083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.steve-lacey.com/blogarchives/2006/04/flagged_article_12.shtml' rel='external nofollow' class='url'>Random Thoughts</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060320-13/?p=31853#comment-368083">
			April 10, 2006 at 1:08 am</a>		</div>

		<p>Three weeks in one this time&amp;amp;#8230; Here&amp;amp;#8217;s my links of interest for the three weeks ending April 8th, 2006&amp;amp;#8230; Daring Fireball: Windows: The New Classic &#8211; John GruberGreat commentary and analysis on Apple&amp;amp;#8217;s release of BootCamp</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

