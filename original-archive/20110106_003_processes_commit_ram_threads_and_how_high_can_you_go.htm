<html>
<head>
<title>Processes, commit, RAM, threads, and how high can you go?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Processes, commit, RAM, threads, and how high can you go?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 6, 2011 / year-entry #4</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>35</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Back in 2008, Igor Levicki made a boatload of incorrect assumptions in an attempt to calculate the highest a process ID can go on Windows NT. Let's look at them one at a time. So if you can't create more than 2,028 threads in one process (because of 2GB per process limit) and each process needs...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Back in 2008,
Igor Levicki
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2008/02/28/7925962.aspx#7966261">
made a boatload of incorrect assumptions in an attempt to calculate
the highest a process ID can go on Windows&nbsp;NT</a>.
Let's look at them one at a time.
</p>
<blockquote CLASS=q><p>
So if you can't create more than 2,028 threads in one process
(because of 2GB per process limit)
and each process needs at least one thread,
that means you are capped by the amount of physical RAM available for stack.
</p>
</blockquote>
<p>
One assumption is that <i>each process needs at least one thread</i>.
Really?
What about a process that has exited?
(Some people call these <i>zombie</i> processes.)
There are no threads remaining in this process,
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2004/07/23/192531.aspx">
but the process object hangs around until all handles are closed</a>.
</p>
<p>
Next, the claim is that <i>you are capped by the amount of physical
RAM available for stack</i>.
This assumes that stacks are non-pageable,
which is an awfully strange assumption.
User-mode stacks are most certainly pageable.
In fact, <i>everything</i> in user-mode is pageable unless you take
special steps to make it not pageable.
</p>
<blockquote CLASS=q>
<p>
Given that the smallest stack allocation is 4KB
and assuming 32-bit address space:
</p>
<p>
4,294,967,296 / 4,096 = 1,048,576 PIDs
</p>
</blockquote>
<p>
This assumes that all the stacks live in the same address space,
but user mode stacks from different processes most certainly do not;
that's the whole point of separate address spaces!
(Okay, kernel stacks live in the same address space, but the discussion
about "initial stack commit" later makes it clear he's talking about
user-mode stacks.)
</p>
<blockquote CLASS=q>
<p>
Since they have to be a multiple of 4:
</p>
<p>
1,048,576 / 4 = 262,144 PIDs
</p>
</blockquote>
<p>
It's not clear why we are dividing by four here.
Yes,
process IDs are a multiple of four
(<a HREF="http://blogs.msdn.com/oldnewthing/archive/2008/02/28/7925962.aspx"
>implementation detail, not contractual, do not rely on it</a>),
but that doesn't mean that three quarters of the stacks are no longer any good.
It just means that we can't use more than 4,294,967,296/4 of them
since we'll run out of names after 1,073,741,824 of them.
In other words, this is not a division but rather a <code>min</code> operation.
And we already dropped below 1 billion when we counted kernel stacks,
so this <code>min</code> step has no effect.
</p>
<p>
It's like saying, "This street is 80 meters long.
The minimum building line is 4 meters, which means that you can
have at most 20 houses on this side of the street.
But house numbers on this side of the street must be even,
so the maximum number of houses is half that, or 10."
No, the requirement that house numbers be even doesn't cut the number
of houses in half; it just means you have to be more careful how you
assign the numbers.
</p>
<blockquote CLASS=q><p>
Having 262,144 processes would consume 1GB of RAM
just for the initial stack commit
assuming that all processes are single-threaded.
If they commited 1MB of stack each you would need 256 GB of memory.
</p>
</blockquote>
<p>
Commit does not consume RAM.
Commit is merely a promise from the memory manager that the RAM will
there when you need it, but the memory manager doesn't have to
produce it immediately (and certainly doesn't have to keep the RAM
reserved for you until you free it).
Indeed, that's the whole point of virtual memory,
to decouple commit from RAM!
(If commit consumed RAM, then what's the page file for?)
</p>
<p>
This calculation also assumes that process IDs are allocated
"smallest available first", but it's clear that it's not as simple
as that:
Fire up Task Manager and look at the highest process ID.
(I've got one as high as 4040.)
If process IDs are allocated smallest-available-first, then a process ID
of 4040 implies that at some point there were 1010 processes in the system
simultaneously!
Unlikely.
</p>
<p>
Here's a much simpler demonstration that process IDs are not allocated
smallest-available-first:
Fire up Task Manager, tell it to <i>Show processes from all users</i>,
go to the Processes tab, and
enable the PID column if you haven't already.
Now launch Calc. Look for Calc in the process list and 
observe that it was not assigned the lowest available PID.
If your system is like mine, you have PID zero assigned to the System
Idle Process (not really a process but it gets a number anyway),
and PID 4 assigned to the System process (again, not really a process
but it gets a number anyway), and then you have a pretty big gap before
the next process ID (for me, it's 372).
And yet Calc was given a process ID in the 2000's.
Proof by counterexample that the system does not assign PIDs
smallest-available-first.
</p>
<p>
So if they aren't assigned smallest-available-first,
what's to prevent one from having a process ID of 4000000000?
</p>
<p>
(Advanced readers may note that kernel stacks do all share a single
address space, but even in that case, a thread that doesn't exist
doesn't have a stack.
And it's clear that Igor was referring to user-mode stacks since he
talked about 1MB stack commits, a value which applies to user mode
and not kernel mode.)
</p>
<p>
Just for fun, I tried to see how high I could get my process ID.
</p>
<pre>
#include &lt;windows.h&gt;
int __cdecl _tmain(int argc, TCHAR **argv)
{
 DWORD dwPid = 0;
 TCHAR szSelf[MAX_PATH];
 GetModuleFileName(NULL, szSelf, MAX_PATH);
 int i;
 for (i = 0; i < 10000; i++) {
  STARTUPINFO si = { 0 };
  PROCESS_INFORMATION pi;
  if (!CreateProcess(szSelf, TEXT("Bogus"),
        NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL,
        &amp;si, &amp;pi)) break;
  TerminateProcess(pi.hProcess, 0);
  CloseHandle(pi.hThread);
  // intentionally leak the process handle so the
  // process object is not destroyed
  // CloseHandle(pi.hProcess); // leak
  if (dwPid < pi.dwProcessId) dwPid = pi.dwProcessId;
 }
 _tprintf(_TEXT("\nCreated %d processes, ")
          _TEXT("highest pid seen was %d\n"), i, dwPid);
 _fgetts(szSelf, MAX_PATH, stdin);
 return 0;
}
</pre>
<p>
In order to get the program to complete before I got bored,
I ran it on a Windows&nbsp;2000 virtual machine with 128MB of memory.
It finally conked out at 5245 processes with a PID high water mark
of 21776.
Along the way, it managed to consume 2328KB of non-paged pool,
36KB of paged pool, and 36,092KB of commit.
If you divide this by the number of processes, you'll see that
a terminated process consumes about 450 bytes of non-paged pool,
a negligible amount of paged pool, and 6KB of commit.
(The commit is probably left over page tables and other detritus.)
I suspect commit is the limiting factor in the number of processes.
</p>
<p>
I ran the same program on a Windows&nbsp;7 machine with 1GB of RAM,
and it managed to create all 10,000 processes with a high process ID
of 44264.
I cranked the loop limit up to 65535, and it still comfortably
created 65535 processes with a high process Id of 266,232,
easily exceeding the limit of
262,144 that Igor calculated.
</p>
<p>
I later learned that the Windows&nbsp;NT folks do try to keep
the numerical values of process ID from getting too big.
Earlier this century,
the kernel team
experimented with letting the numbers get really huge,
in order to reduce the rate at which process IDs get reused,
but they had to go back to small numbers, not for any technical
reasons, but because people complained that the large process IDs
looked ugly in Task Manager.
(One customer even asked if something was wrong with his computer.)
</p>
<p>
That's not saying that the kernel folks won't go back and try
the experiment again someday.
After all, they managed to
<a HREF="https://channel9.msdn.com/shows/Going+Deep/Arun-Kishan-Farewell-to-the-Windows-Kernel-Dispatcher-Lock/">
get rid of the dispatcher lock</a>.
Who knows what other crazy things will change next?
(And once they get process IDs to go above 65535&mdash;like they
were in Windows&nbsp;95, by the way&mdash;or
if they decided to make process IDs no
longer
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2008/02/28/7925962.aspx">
multiples of 4</a>
in order to keep process IDs low,
<a HREF="http://groups.google.com/group/microsoft.public.win32.programmer.kernel/browse_thread/thread/6326c306e22e05bb/c0fee26e301bbcf2">
this guy's program</a>
will stop working, and it'll be Microsoft's fault.)</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (35)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-leo-davidson even thread-even depth-1" id="comment-886453">
				<div id="div-comment-886453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Leo+Davidson' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886453">
			January 6, 2011 at 8:13 am</a>		</div>

		<p>&quot;this guy&#39;s program will stop working, and it&#39;ll be Microsoft&#39;s fault&quot;</p>
<p>He can&#39;t say he wasn&#39;t warned.</p>
<p>I remember that thread well. The particularly bad thing is relying on undocumented behaviour when there are easier, more obvious methods to achieve the exact same thing in a kosher way, some of which were mentioned in the thread.</p>
<p>But what can ya do? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886463">
				<div id="div-comment-886463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886463">
			January 6, 2011 at 8:19 am</a>		</div>

		<p>Gotta love that Hugo guy:</p>
<p>&quot;This is called thinking out of the box incidentally, for those of an overly</p>
<p>conservative mindset.&quot;</p>
<p>Out of that annoyingly constraining box of writing robust software, it seems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886473">
				<div id="div-comment-886473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886473">
			January 6, 2011 at 8:31 am</a>		</div>

		<p>The pointed thing is the guy&#39;s claim that no large system can be developed depending on only the written documentation.</p>
<p>Trouble is, he&#39;s right.</p>
<p>Even on UNIX, there&#39;s the POSIX definitions and the oral tradition. Microsoft implemented POSIX in a way that ignored the oral tradition to a point that few UNIX programs could run in the environment. They were rightly flamed for it, and now we have Cygwin which comes much closer to what it should have been. Cygwin uses crazy undocumented hacks because the NT kernel cannot support the oral traditions.</p>
<p>More on the point is his claim is for all operating systems, including embedded realtime operating systems. It has bitten UNIX itself. time_t is a signed number, hence the 2038 bug.</p>
<p>Microsoft is stuck with this kind of behavior. They are not alone.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-886483">
				<div id="div-comment-886483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886483">
			January 6, 2011 at 8:53 am</a>		</div>

		<p>Why do you have to wait for your program to complete? &nbsp;Just have it print out the &quot;highest PID so far&quot; every time it changes and let it run indefinitely.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886493">
				<div id="div-comment-886493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt [Visual C++ MVP]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886493">
			January 6, 2011 at 9:19 am</a>		</div>

		<p>@Maurits: Possibly because the I/O is going to slow down the progress of the program by several orders of magnitude. &nbsp;However, you could check for a new &quot;highest PID&quot; on every spawn, but only set a dirty flag and only actually print out anything every 1000 spawns or so.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886503">
				<div id="div-comment-886503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jcs</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886503">
			January 6, 2011 at 9:33 am</a>		</div>

		<p>If you read that Hugo guy&#39;s comments more closely, you&#39;ll see that he is likely writing code for the financial industry.</p>
<p>Now does it surprise you that he lampoons the &quot;overly conservative mindset&quot; of those who write robust software?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886513">
				<div id="div-comment-886513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886513">
			January 6, 2011 at 10:10 am</a>		</div>

		<p>Well, when I think about this kind of discussion I always remember the Pushing the Limits of Windows on Mark Russinovich&#39;s blog. For anyone curious about what these limits are on Windows, I think this series is a really good read. You can find the first one here (<a rel="nofollow" target="_new" href="http://blogs.technet.com/markrussinovich/archive/2008/07/21/3092070.aspx" rel="nofollow">blogs.technet.com/&#8230;/3092070.aspx</a>) and the rest are linked in that entry.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886523">
				<div id="div-comment-886523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886523">
			January 6, 2011 at 10:12 am</a>		</div>

		<p>Joshua: Not to start a flamewar, but if Microsoft wrote their POSIX code to the spec, and POSIX programs couldn&#39;t run because of some unpublished &quot;oral traditions&quot;&#8230; how is that Microsoft&#39;s fault? It seems to me that the authors of the POSIX standards, or possibly the writers of that software, are at fault.</p>
<p>This is not an isolated case; the same thing happens to the IE team all the time while implementing W3C standards. Other browsers (being open source) just &quot;borrow&quot; each others&#39; implementations, but the IE team writes it from scratch&#8211; then the IE team is blamed when incompatibilities inevitably arise. The W3C is seen as the perfect voice of reason, even though their vague standards were the source of the confusion in the first place.</p>
<p>I guess the lesson here is &quot;life just isn&#39;t fair.&quot; Heh.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886533">
				<div id="div-comment-886533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skyborne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886533">
			January 6, 2011 at 10:42 am</a>		</div>

		<p>&quot;Just for fun, I tried to see how high I could get my process ID.&quot;</p>
<p>It was difficult not to burst out in evil laughter at this point. &nbsp;I should try this on Linux sometime. &nbsp;(A machine at hand happened to show <code>ps</code> at 32755, so I ran it a few times until it rolled over from 32767 to 300. &nbsp;But I don&#39;t know if that represents a limit or a convenient point to start recycling if available.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kwadwomi odd alt thread-odd thread-alt depth-1" id="comment-886543">
				<div id="div-comment-886543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Master+Programmer' rel='external nofollow' class='url'>Master Programmer</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886543">
			January 6, 2011 at 10:45 am</a>		</div>

		<p>From my observations process ids and threads share the same namespace (or number space). That&#39;s why the first process id is in the hundreds. Most of the space is taken by system threads.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886563">
				<div id="div-comment-886563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886563">
			January 6, 2011 at 11:13 am</a>		</div>

		<p>I wonder, does cygwin still abuse hacks or did they fixed them? (in 2005 they hacked their way for del of current directory)</p>
<p>Anyway if you use undocumented features/API/hacks/&#8230; then either you overthink it,do horrible things or horribly or don&#39;t know any better/was told so on some sites like StackOverflow. Neither should be acceptable.</p>
<p>One should never ever rely on undocumented things &#8211; so far I never saw a reason why to. (Maybe one should read books like Windows System Programming.)</p>
<p>But then I generally use WxWidgets or DirectX. (and so far no hacks seen in Wx)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886573">
				<div id="div-comment-886573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886573">
			January 6, 2011 at 11:20 am</a>		</div>

		<p>Great article except for the counterexample &quot;&#8230; and then you have a pretty big gap before the next process ID (for me, it&#39;s 372). And yet Calc was given a process ID in the 2000&#39;s. Proof by counterexample that the system does not assign PIDs smallest-available-first.&quot;</p>
<p>Not a counterexample, as there can be an easy explanation for that gap. Take my Linux machine for example. After boot, a few background daemons have low PIDs like 200 etc., however, the first programs I start get PIDs in the 1000s or 2000s as well. Yet process IDs do get assigned sequentially. So this counterexample isn&#39;t one. You should have started two calcs right after another and compared their PIDs as a counterexample, so that the time period between both start was so low that it is unlikely that the &quot;missing&quot; PIDs in between just got used by other programs, which have already exited.</p>
<div class="post">[<i>The fact that Calc was not given a process ID below 372, even though we knew that those IDs were available, shows that process IDs are not assigned lowest-available-first. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886583">
				<div id="div-comment-886583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886583">
			January 6, 2011 at 11:30 am</a>		</div>

		<p>Alex:</p>
<p>That of course is assuming Windows works like linux, which is a bad assumption.</p>
<p>But anyway, if you want that kind of proof. Try starting two instances of calc in quick succession (I did it on the command line using the up key, but I&#39;m sure you can get the second instance even faster by using a script), it gives two pretty different PIDs. For me it was 2016 and 4292.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886593">
				<div id="div-comment-886593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Justin Olbrantz (Quantam)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886593">
			January 6, 2011 at 11:37 am</a>		</div>

		<p>A while back &lt;a href=&quot;<a rel="nofollow" target="_new" href="http://qstuff.blogspot.com/2008/11/audio-driver-incident.html&quot;&gt;I" rel="nofollow">qstuff.blogspot.com/&#8230;/audio-driver-incident.html&quot;&gt;I</a> noted&lt;/a&gt; via a buggy app that Windows had no problem with a process having 4 million registry handles, in case anybody cares. I actually had no idea that Windows supported that many simultaneous handles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886603">
				<div id="div-comment-886603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886603">
			January 6, 2011 at 11:40 am</a>		</div>

		<p>Justin:</p>
<p>Windows has an upper limit of over 16.5 million handles per process (exact figure is 16,777,216, the source being the Pushing the Limits of Windows article I posted earlier).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886613">
				<div id="div-comment-886613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886613">
			January 6, 2011 at 11:47 am</a>		</div>

		<p>UNIX oral tradition cases in point:</p>
<p>1) The shell is /bin/sh. NT4 POSIX didn&#39;t have /bin. Because #! (which is in the standard), moving /bin was ill-advised.</p>
<p>2) Deleting your own binary works. While POSIX allowed -ETXTBUSY, it wasn&#39;t supposed to be issued unless the underlying filesystem didn&#39;t support hardlinks.</p>
<p>3) Deleting a file with an open handle must succeed on the primary filesystem and allow another file to be created with the same name. This broke thousands of applications.</p>
<p>As far as I know, Cygwin got their hacks down to 4.</p>
<p>1) NtCreateXxxxx security api (name omitted so Raymond doesn&#39;t complain) is used by ssh. This is kind-of avoidable now but the documented method has so many caveats that the old undocumented method is favored (see oral tradition case 2).</p>
<p>2) fork() does crazy things to address space. Not a problem unless somebody else is using AppInitDlls. Don&#39;t dll-inject Cygwin processes either. The hack&#39;s only particular dependency is the system dlls are loaded at the same address space for all process of the same bitness. With the Vista documentation, this fact is finally documented in the ABI.</p>
<p>3) The various methods of unlocking current directory (oral tradition case 3)</p>
<p>4) Delete file in use uses a similar hack to NFS.</p>
<p>Actually the problem of a malicious implementation was considered by the POSIX writers and dubbed weirdnix. The spec authors were horrified when NT produced a functioning weirdnix.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886623">
				<div id="div-comment-886623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886623">
			January 6, 2011 at 12:23 pm</a>		</div>

		<p>@Raymond: as always, you are right :) Missed that nuance.</p>
<p>@Crescens2k: No I did not assume that anywhere, I just compared the two. I simply totally stupidly missed the fact that if numbers 1, 4 and 372 are taken, then 2 would be the lowest available number (unless available is defined as &quot;not recently used&quot;).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886633">
				<div id="div-comment-886633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GL1zdA</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886633">
			January 6, 2011 at 12:37 pm</a>		</div>

		<p>Actually the multiple of 4 is specific to the Windows version for Intel &#8211; on both Alpha and PowerPC (have no MIPS/Itanium to test it) the NT 4.0 Task Manager shows odd PID numbers, so they definitely are not a multiple of 4.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886643">
				<div id="div-comment-886643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886643">
			January 6, 2011 at 1:50 pm</a>		</div>

		<p>Joshua: 3) Why they don&#39;t switch current directoy to known existing one like &quot;temp/sub&quot; where sub is created by cygwin at the beginning with random name? Is there some problem?</p>
<p>4)This one is though one. (currently user of unlocker &nbsp;mainly to see who is still holding that bloddy lock)</p>
<p>Malicious implementation? Weirdnix? What is that?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886653">
				<div id="div-comment-886653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886653">
			January 6, 2011 at 1:52 pm</a>		</div>

		<p>Joshua: If they anticipated that their spec could be interpreted &quot;incorrectly&quot; (to make &#39;weirdnix&#39;), why didn&#39;t they fix the spec? &#8230;and you&#39;re still blaming Microsoft? My brain boggles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886673">
				<div id="div-comment-886673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886673">
			January 6, 2011 at 6:30 pm</a>		</div>

		<p>dancol:</p>
<p>The problem is that Win32 works differently from posix in a few cases and these sticking points are in major implementation differences. So does Win32 really need to be fixed up when it is working in the way it was intended?</p>
<p>Cygwin is basically an emulation layer on top of Win32, so it should be expected to work in the bounds of the operating system it is running upon. The reverse would hold true too, would you think a function would be added to the *nix kernel just to help Wine run better?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886683">
				<div id="div-comment-886683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886683">
			January 6, 2011 at 7:00 pm</a>		</div>

		<p>@dancol: There are several reasons why Windows separated out its POSIX and OS/2 support into subsystems; this is one of those reasons. Pick up any of the &quot;Inside Windows NT&quot; editions (section 5.1.1.1 &quot;Providing Multiple Environments&quot; in the first edition by Helen Custer [Microsoft Press, 1993]; I don&#39;t have the other editions on hand) and the rationale is pretty clear.</p>
<p>I appreciate the work that the designers of the kernel did to anticipate changes to hardware architecture in the 1990&#39;s (for example, until reading the above book, I didn&#39;t realize that the VM was architectured to support 64-bit addresses from the beginning!) As long as I follow the fairly simple rule of treating opaque values as just that &#8212; opaque &#8211;, I should never have to worry about strange assumptions that will bite me later.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886553">
				<div id="div-comment-886553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886553">
			January 6, 2011 at 11:04 am</a>		</div>

		<p>Danny: Better still, that comment comes at the end of a message which can be summarised as, &quot;I stress-tested my application and found that it failed, but that doesn&#39;t count because it was deliberate stress testing.&quot; &nbsp;*Flamboyantly* un-conservative!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dancol odd alt thread-odd thread-alt depth-1" id="comment-886703">
				<div id="div-comment-886703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Daniel++Colascione' rel='external nofollow' class='url'>Daniel Colascione</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886703">
			January 6, 2011 at 7:54 pm</a>		</div>

		<p>@Crescens2k, functionality is added all the time. We didn&#39;t always have condition variables either.</p>
<p>@erikf, I&#39;ve read the latest edition of Windows Internals. It&#39;s an excellent survey of the operation of the NT kernel, but it doesn&#39;t address a lot of the historical justification of that design. While subsystem separation is elegant in theory, it doesn&#39;t address many real-world concerns because subsystems are inherently isolated, and additionally because non-win32 subsystems are often neglected (see the sad case of poll(2) support in psxss). Frankly, as a practical matter, the SKU restrictions for POSIX limit adoption as well. Adding a few capabilities to the win32 subsystem doesn&#39;t impair its current users and makes a major class of user scenarios work much better, and the idea shouldn&#39;t rejected out of hand.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao even thread-even depth-1" id="comment-886723">
				<div id="div-comment-886723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886723">
			January 6, 2011 at 9:36 pm</a>		</div>

		<p>&quot;They were rightly flamed for it, and now we have Cygwin which comes much closer to what it should have been&quot;</p>
<p>Don&#39;t forget Interix (now an optional feature in Vista/7 Enterprise/Ultimate) which extends the POSIX subsystem to provide a better Unix environment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886733">
				<div id="div-comment-886733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Engywuck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886733">
			January 6, 2011 at 10:56 pm</a>		</div>

		<p>Crescens2k: There&#39;s an even faster way: just use &amp;&amp; operator in between :)</p>
<p>calc &amp;&amp; calc &amp;&amp; calc &amp;&amp; calc &amp;&amp; calc</p>
<p>gives me the PIDs 2272, 4276, 6092, 6100, 6108</p>
<p>so some sort of &quot;re-use&quot; seems to happen.</p>
<p>When I added another ten instances of calc (without closing the previous 5) it gave me 4520, 5020, 5152, 5304, 5308, 5412, 5416, 5548, 5696 (all in between the &quot;original 5&quot;) so the difference of &quot;8&quot; between the last three just happens to be &quot;by accident&quot;</p>
<p>Or, worded differently: don&#39;t make assumptions about the PID you&#39;ll be getting when starting another instance.</p>
<p>In linux I&#39;ve seen often enough that PIDs tend to be &quot;increase only&quot; until some sort of wraparound (don&#39;t know if the wrap is variable), here it seems to be different. Both subject to change, though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886743">
				<div id="div-comment-886743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886743">
			January 6, 2011 at 11:28 pm</a>		</div>

		<p>IIRC. in ancient versions of Linux, there was a max PID value of 65536. ISTR that this really wasn&#39;t an issue since a practical system could host only 10,000 processes or so. These days, I don&#39;t know what the limit is. I&#39;m guessing it&#39;s a 32-bit int now, but wraps under 65536 when it can to avoid large PIDs.</p>
<p>Or maybe legacy keeps it at 65536 processes (threads share the same PID).</p>
<p>Easy way is to disable resource limits and forkbomb the machine. The reason things fail when I did this 10+ years ago was &quot;No more PIDs&quot;. Of course, Linux back then (don&#39;t know now) struggled when the loadavg hit the low 10s. Not sure if this is still the case (I&#39;ve heard FreeBSD could handle the better part of a 100 loadavg without skipping audio and still being somewhat responsive).</p>
<p>Wish Windows had a loadavg metric.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886753">
				<div id="div-comment-886753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny Moules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886753">
			January 7, 2011 at 12:58 am</a>		</div>

		<p>@James Schend: That&#39;s simply not true. Their interpretations of the specification weren&#39;t &#39;creatively distinct&#39;. They were wrong. Wrong in so many places, so much of the time. Just plain didn&#39;t work in huge places because somebody didn&#39;t read the specification or understand it even when there was no ambiguity to be had. It was ineptitude and it&#39;s hard to defend.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886763">
				<div id="div-comment-886763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny Moules</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886763">
			January 7, 2011 at 12:59 am</a>		</div>

		<p>@James Schend: That&#39;s simply not true. Their interpretations of the specification weren&#39;t &#39;creatively distinct&#39;. They were wrong. Wrong in so many places, so much of the time. Just plain didn&#39;t work in huge places because somebody didn&#39;t read the specification or understand it even when there was no ambiguity to be had.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dancol odd alt thread-odd thread-alt depth-1" id="comment-886663">
				<div id="div-comment-886663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Daniel++Colascione' rel='external nofollow' class='url'>Daniel Colascione</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886663">
			January 6, 2011 at 6:04 pm</a>		</div>

		<p>Klimax, that was one option considered; actually, you don&#39;t even need a random directory: you can use pipefs instead. There&#39;s a long thread from mid-2010 on cygwin-devel about the current directory hack; you can go and read it yourself. There&#39;s no easy solution; if the win32 API contained a SetCurrentDirectoryByHandle function, this hack wouldn&#39;t be necessary at all. *sigh* Ten lines of code in kernel32 could save a ton of pain for a popular, important user of the API.</p>
<p>A supported win32 fork would save a lot more pain, but it&#39;d also involve more work. (Not all *that* much more work though: the kernel already supports fork. It&#39;s just win32 that&#39;d need to be fixed up.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886783">
				<div id="div-comment-886783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886783">
			January 7, 2011 at 3:01 am</a>		</div>

		<p>XP Interix doesn&#39;t let you delete your own binary. This bit me when I tried to do the equivalent of</p>
<p>/bin/ln /bin/rm /tmp</p>
<p>/bin/rm /tmp/rm</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886793">
				<div id="div-comment-886793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886793">
			January 7, 2011 at 4:05 am</a>		</div>

		<p>Engywuck:</p>
<p>The fact that there was reuse wasn&#39;t debated. It was about whether the lowest free PID was reused first. As you can see for yourself it regulary grabs from the 2000-5000 range, but it doesn&#39;t fill in the gaps in what it grabs, and the lowest PID isn&#39;t the lowest available. Occasionally it gets a PID &lt; 2000, very rarely it gets a PID &lt; 1000 and this is done on a system where besides the calc processes being created there is nothing else going on.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-886823">
				<div id="div-comment-886823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886823">
			January 7, 2011 at 6:22 am</a>		</div>

		<p>@Skyborne, @Worf:</p>
<p>$ cat /proc/sys/kernel/pid_max</p>
<p>32768</p>
<p>Yes, the default limit is 32768 on Linux. Yes, it can be increased (just echo the new value to that file, or use the sysctl command, or edit /etc/systcl.conf which is read by the sysctl command on boot).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-886833">
				<div id="div-comment-886833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-886833">
			January 7, 2011 at 6:50 am</a>		</div>

		<p>@ Joshua &quot;The spec authors were horrified when NT produced a functioning weirdnix.&quot; Why weren&#39;t those things [and whatever else NT supposedly got wrong] in the standard? It seems like the entire <em>point</em> of POSIX is to create a subset [the real unix stuff is in XSI/UP/etc] of unix stuff that can be implemented <em>on a substantially non-unix-like OS</em>.</p>
<p>As for /bin/sh, there are plenty of unix OSes that don&#39;t have their <em>posix-conforming</em> shell [and other tools] in /bin &#8211; /usr/xpg4 anyone? Systems are supposed to prescribe a $PATH for conforming scripts to use, and you&#39;re never supposed to depend on the absolute path of something.</p>
<p>Re #! see <a rel="nofollow" target="_new" href="http://www.opengroup.org/platform/resolutions/bwg2000-004.html" rel="nofollow">http://www.opengroup.org/&#8230;/bwg2000-004.html</a> [no version I could find actually mandates support for this, though the &#39;sh&#39; documentation has a section &#39;on systems that support executable scripts&#39; and recommends that the paths be rewritten by installers]</p>
<p>(Re (2) the [ETXTBSY] case was actually explicitly allowed on systems that support hardlinks, <em>if there aren&#39;t any actual hardlinks to that file</em>. Don&#39;t know what NT&#39;s behavior is here, but [and re (3)] see also &quot;[EBUSY] The file named by the path argument cannot be unlinked because it is being used by the system or another process and the implementation considers this an error.&quot; &#8211; rename and rmdir also allow this)</p>
<p>I don&#39;t think that doing something different that the standard <em>has text devoted to explicitly allowing to be different</em> really counts as a &#39;weirdnix&#39; type situation &#8211; it&#39;s meant for unintentional oversights. &quot;The spirit of POSIX&quot; is not &quot;your entire system has to work exactly like Bell Labs UNIX circa 1979 down to every detail&quot;. Do you have any other/clearer examples for the NT POSIX stuff? (Citation also needed on anyone involved in creating POSIX having reported being horrified by the NT implementation, for that matter)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-887233">
				<div id="div-comment-887233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Sawyer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110106-00/?p=11813#comment-887233">
			January 10, 2011 at 5:59 pm</a>		</div>

		<p>Raymond, thanks for making my blood boil with your *this guy* link. </p>
<p>Hugo&#39;s blustering over why he needs to wedge PIDs into a 16 bit array (2 dimensions dontcha know &#39;cause a square takes less space than a line) instead of using a map or other trivial working solution is just too familiar. &nbsp;The pleading of others to write good code are to no avail. &nbsp;Maybe he can say &quot;my code is frequently featured in articles on leading websites&#8230; such as thedailywtf.com.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

