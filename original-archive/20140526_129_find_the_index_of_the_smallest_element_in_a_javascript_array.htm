<html>
<head>
<title>Find the index of the smallest element in a JavaScript array</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Find the index of the smallest element in a JavaScript array</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>May 26, 2014 / year-entry #130</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>49</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Today's Little Program isn't even a program. It's just a function. The problem statement is as follows: Given a nonempty JavaScript array of numbers, find the index of the smallest value. (If the smallest value appears more than once, then any such index is acceptable.) One solution is simply to do the operation manually, simulating...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Today's Little Program isn't even a program.
It's just a function.
</p>
<p>
The problem statement is as follows:
Given a nonempty JavaScript array of numbers,
find the index of the smallest value.
(If the smallest value appears more than once,
then any such index is acceptable.)
</p>
<p>
One solution is simply to do the operation manually,
simulating how you would perform the operation with
paper and pencil:
You start by saying that the first element is the winner,
and then you go through the rest of the elements.
If the next element is smaller than the one you have,
you declare that element the new provisional winner.
</p>
<pre>
function indexOfSmallest(a) {
 var lowest = 0;
 for (var i = 1; i &lt; a.length; i++) {
  if (a[i] &lt; a[lowest]) lowest = i;
 }
 return lowest;
}
</pre>
<p>
Another solution is to use the <code>reduce</code> intrinsic
to run the loop, so you merely have to provide
the business logic of the
initial guess
and the <code>if</code> statement.
</p>
<pre>
function indexOfSmallest(a) {
 return a.reduce(function(lowest, next, index) {
                   return next &lt; a[lowest] : index ? lowest; },
                 0);
}
</pre>
<p>
A third solution is to use JavaScript intrinsics to
find the smallest element and then convert
the element to its index.
</p>
<pre>
function indexOfSmallest(a) {
 return a.indexOf(Math.min.apply(Math, a));
}
</pre>
<p>
Which one is fastest?
</p>
<p>
Okay, well, first, before you decide which one is fastest,
you need to make sure they are all correct.
One thing you discover is that the <code>min/indexOf</code>
technique fails once the array gets really, really large,
or at least it does in Internet Explorer and Firefox.
(In my case, Internet Explorer and Firefox gave up at around
250,000 and 500,000 elements, respectively.)
That's because you start hitting engine limits on the number
of parameters you can pass to a single function.
Invoking <code>apply</code> on an array of 250,000 elements
is the equivalent of calling <code>min</code> with 250,000
function parameters.
</p>
<p>
So we'll limit ourselves to arrays of length at most 250,000.
</p>
<p STYLE="height: 10em">
Before I share the results, I want you to guess which
algorithm you think will be the fastest
and which will be the slowest.
</p>
<p STYLE="height: 10em">
Still waiting.
</p>
<p>
I expected the manual version to come in last place,
because, after all, it's doing everything manually.
I expected the reduce version to be slightly faster,
because it offloads some of the work into an intrinsic
(though the function call overhead may have negated
any of that improvement).
I expected the min/indexOf version to be fastest
because nearly all the work is being done in intrinsics,
and the cost of making two passes over the data
would be made up by the improved performance of the intrinsics.
</p>
<p>
Here are the timings of the three versions with arrays of
different size, running on random data.
I've normalized run times so that the results are independent
of CPU speed.
</p>
<table BORDER=1 BORDERCOLOR=black CELLPADDING=3
    STYLE="border-collapse: collapse">
<caption>
    <font SIZE=+1><b>Relative running time per array element</b></font>
</caption>
<tr>
<th>Elements</th>
<th>manual</th>
<th>reduce</th>
<th>min/indexOf</th>
</tr>
<tr>
<th COLSPAN=4>Internet Explorer 9</th>
</tr>
<tr>
<td ALIGN=right>100,000</td>
<td ALIGN=right>1.000</td>
<td ALIGN=right>2.155</td>
<td ALIGN=right>2.739</td>
</tr>
<tr>
<td ALIGN=right>200,000</td>
<td ALIGN=right>1.014</td>
<td ALIGN=right>2.324</td>
<td ALIGN=right>3.099</td>
</tr>
<tr>
<td ALIGN=right>250,000</td>
<td ALIGN=right>1.023</td>
<td ALIGN=right>2.200</td>
<td ALIGN=right>2.330</td>
</tr>
<tr>
<th COLSPAN=4>Internet Explorer 10</th>
</tr>
<tr>
<td ALIGN=right>100,000</td>
<td ALIGN=right>1.000</td>
<td ALIGN=right>4.057</td>
<td ALIGN=right>4.302</td>
</tr>
<tr>
<td ALIGN=right>200,000</td>
<td ALIGN=right>1.028</td>
<td ALIGN=right>4.057</td>
<td ALIGN=right>4.642</td>
</tr>
<tr>
<td ALIGN=right>250,000</td>
<td ALIGN=right>1.019</td>
<td ALIGN=right>4.091</td>
<td ALIGN=right>4.068</td>
</tr>
</table>
<p>
Are you surprised?
I sure was!
</p>
<p>
Not only did I have it completely backwards,
but the margin of victory for the manual version was way
beyond what I imagined.
</p>
<p>
(This shows that the only way to know
your program's performance characteristics for sure
is to <i>sit down and measure it</i>.)
</p>
<p>
What I think is going on is that the JavaScript optimizer
can do a really good job of optimizing the manual code
since it is very simple.
There are no function calls, the loop body is just one line,
it's all right out there in the open.
The versions that use intrinsics end up hiding some of the
information from the optimizer.
(After all, the optimizer cannot predict ahead of time whether
somebody has overridden the default implementation of
<code>Array.prototype.reduce</code> or
<code>Math.prototype.min</code>,
so it cannot blindly inline the calls.)
The result is that the manual version can run over twice
as fast on IE9 and over four times as fast on IE10.
</p>
<p>
I got it wrong because I thought of JavaScript too much like
an interpreted language.
In a purely interpreted language,
the overhead of the interpreter is roughly proportional
to the number of things you ask it to do,
as opposed to how hard it was to do any of those things.
It's like a fixed service fee imposed on every transaction,
regardless of whether the transaction was for $100 or 50 cents.
You therefore try to make one big purchase (call a complex intrinsic)
instead of a lot of small ones (read an array element,
compare two values, increment a variable, copy one variable to another).
</p>
<p>
<b>Bonus chatter</b>:
I ran the test on Firefox, too,
because I happened to have it handy.
</p>
<table BORDER=1 BORDERCOLOR=black CELLPADDING=3
    STYLE="border-collapse: collapse">
<caption>
    <font SIZE=+1><b>Relative running time per array element</b></font>
</caption>
<tr>
<th>Elements</th>
<th>manual</th>
<th>reduce</th>
<th>min/indexOf</th>
</tr>
<tr>
<th COLSPAN=4>Firefox 16</th>
</tr>
<tr>
<td ALIGN=right>100,000</td>
<td ALIGN=right>1.000</td>
<td ALIGN=right>21.598</td>
<td ALIGN=right>3.958</td>
</tr>
<tr>
<td ALIGN=right>200,000</td>
<td ALIGN=right>0.848</td>
<td ALIGN=right>21.701</td>
<td ALIGN=right>2.515</td>
</tr>
<tr>
<td ALIGN=right>250,000</td>
<td ALIGN=right>0.839</td>
<td ALIGN=right>21.788</td>
<td ALIGN=right>2.090</td>
</tr>
</table>
<p>
The same data collected on Firefox 16
(which sounds ridiculously old because Firefox
will be on version 523 by the time this
article reaches the head of the queue)
shows a different profile,
although the winner is the same.
The manual loop and the min/indexOf get more efficient
as the array size increases.
This suggests that there is fixed overhead that becomes
gradually less significant as you increase the size of the
data set.
</p>
<p>
One thing that jumps out is that the reduce method way
underperforms the others.
My guess is that setting up the function call
(in order to transition between the intrinsic and the script)
is very expensive,
and that implementors of the JavaScript engines haven't
spent any time optimizing this case because
<code>reduce</code> is not used much in real-world code.
</p>
<p>
<b>Update</b>:
I exaggerated my na&iuml;vet&eacute; to make for a better
narrative.
As I point out in
<a HREF="http://my.safaribooksonline.com/book/programming/microsoft-windows/0321440307/preface/pref02">
the preface</a>
to
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2006/12/07/1233002.aspx">
my book</a>,
my stories may not be completely true,
but they are true enough.
Of course I know that JavaScript is jitted nowadays,
and that changes the calculus.
(Also, the hidden array copy.)</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (49)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1125803">
				<div id="div-comment-1125803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mc</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125803">
			May 26, 2014 at 7:08 am</a>		</div>

		<p>I&#39;m always telling my programmers to keep things simple as possible and don&#39;t start optimizing code till you find it&#39;s necessary and then measure which bit is causing the problem and focus your efforts there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125813">
				<div id="div-comment-1125813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Cuccia</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125813">
			May 26, 2014 at 7:22 am</a>		</div>

		<p>Reminds me of Herb Sutter&#39;s discussion in his recent TechEd talk about cache lines and prefetchers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125823">
				<div id="div-comment-1125823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anyfoo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125823">
			May 26, 2014 at 7:24 am</a>		</div>

		<p>&gt; Firefox 16 (which sounds ridiculously old because Firefox will be on version 523 by the time this article reaches the head of the queue)</p>
<p>And predictably, you were right! It&#39;s not quite at 523 yet, but at 29 nonetheless. Almost twice the version number and 16 certainly seems old by now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125833">
				<div id="div-comment-1125833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Caron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125833">
			May 26, 2014 at 7:37 am</a>		</div>

		<p>My guess was aligned with the results, which makes me feel good, because every similar operation I&#39;ve done in Javascript (look for biggest/smallest, sum, etc) looks like the loop version, because I didn&#39;t even know there was a reduce function in Array!</p>
<p>On an unrelated note, the last version seems insane to me. Not a criticism, of course, since this it was written in the interests of performance testing/exploration. However, I would definitely flag it if I saw it in a code review.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125843">
				<div id="div-comment-1125843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RRR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125843">
			May 26, 2014 at 7:37 am</a>		</div>

		<p>Unless I&#39;m missing something here (and I might, cause I don&#39;t know crap about javascript), not surprised one bit.</p>
<p>This is one case where the obvious way is obviously the best way.</p>
<p>There is no way in hell you can find out the answer without going through the entire list, which is exactly what the &quot;manual&quot; way does.</p>
<p>Anything else done by the reduce or math stuff can only add more execution time in this case unless they do some magic; and we all know magic does not exist unless you do some multithreading or something (which I assumed and which I later found to be true when I asked the google about this).</p>
<p>Again, I might be missing something&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125853">
				<div id="div-comment-1125853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">RRR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125853">
			May 26, 2014 at 7:39 am</a>		</div>

		<p>Correction:</p>
<p>(which I assumed and which I later found to be true when I asked the google about this).</p>
<p>should be</p>
<p>(which I assumed about javascript in the browser and which I later found to be true when I asked google about this).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125863">
				<div id="div-comment-1125863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Caron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125863">
			May 26, 2014 at 7:40 am</a>		</div>

		<p>@RRR:</p>
<p>The thinking was that the reduce/min functions were written in native x86 code, not in javascript. Therefore, they are going to be much faster than the equivalent loop in javascript. Of course, as noted, there is overhead to function calls, and optimizations that can&#39;t take place when doing such things.</p>
<p>I wonder if using Math.min.call(Math, a) would be any faster, since it would need to unpack the argument array&#8230;</p>
<div class="post">[<em>Exactly. The core operation is minimal; most of the overhead is loop control. And native loop control is faster than interpreted loop control right? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125873">
				<div id="div-comment-1125873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ZoBook</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125873">
			May 26, 2014 at 7:48 am</a>		</div>

		<p>I also think that the manual is the fastest (not taking into account multi-threading) because as RRR noted, the ONLY way to find out is to go through the entire list&#8230;how do you do that will determine the &quot;speed&quot; of the process. If you can, like split the list in 4 and check simultaneously then you do (total / 4) + 2 testings, when you have the result of the 4 sublist, you do one more test (2 simultaneously, like in a semi-final soccer match) and then finally one more test (the final match).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125883">
				<div id="div-comment-1125883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125883">
			May 26, 2014 at 8:25 am</a>		</div>

		<p>The reason you are surprised is that the JIT mechanisms in modern JavaScript engines got really, really effective. The JIT actually finally produces the native code for the loop, but typically it has to see first that it&#39;s worth producing it (by running the first passes as the interpretation). That&#39;s why you observe initial costs. Once the loop is running native, it is very effective.</p>
<p>Here&#39;s one nice text about the internal architecture of one JIT multi-tier system.</p>
<p>My favorite demonstration of the JavaScript&#39;s modern JIT speeds is <a rel="nofollow" target="_new" href="http://bellard.org/jslinux/">http://bellard.org/jslinux/</a> As far as I remember, my fruit-flavored tablet v3 (AFAIK still without the last tier demonstrated above) is as fast to boot the Linux in JavaScript as my i5 650 running IE 11: around 18 seconds. JIT engines really fly today.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125893">
				<div id="div-comment-1125893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wladimir Palant</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125893">
			May 26, 2014 at 8:28 am</a>		</div>

		<p>The results weren&#39;t really surprising to me &#8211; but then again, I deal with JavaScript all the time. And I&#39;ve learned a while ago that function calls are really expensive in JavaScript. So functions like Array.reduce() that will do a function call for each array element are neat but should never be used on performance-critical paths. As to the variant using Math.min() &#8211; the issue here should be the implicit copying of the original array into the arguments array. Simple loops like in the &quot;manual&quot; approach on the other will be optimized really well by the current JIT compilers, the difference to native code won&#39;t really be significant there.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125903">
				<div id="div-comment-1125903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125903">
			May 26, 2014 at 8:35 am</a>		</div>

		<p>The text I&#39;ve mentioned in the previous post, somehow link was missing: <a rel="nofollow" target="_new" href="https://www.webkit.org/blog/3362/introducing-the-webkit-ftl-jit/">http://www.webkit.org/&#8230;/introducing-the-webkit-ftl-jit</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125913">
				<div id="div-comment-1125913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125913">
			May 26, 2014 at 8:53 am</a>		</div>

		<p>I&#39;d expect the reduce version to be linearly slower than the inline loop, just because of the function call. &nbsp;Just how much, only by benchmarking.</p>
<p>I wouldn&#39;t expect anything from the min/indexOf version, because it can easily fail due to the possible implementation-dependent limit of arguments.</p>
<p>Even so, I was expecting it to be about twice the manual version, because it must scan the whole array twice in the worse case. &nbsp;However, it does both less-than comparisons (&lt;, min) and strict equality comparisons (===, indexOf), which may explain the greater difference.</p>
<p>Here&#39;s an interactive way of testing for yourelf, and provide stats with your browser(s): <a rel="nofollow" target="_new" href="http://jsperf.com/index-of-smallest">jsperf.com/index-of-smallest</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125923">
				<div id="div-comment-1125923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125923">
			May 26, 2014 at 9:13 am</a>		</div>

		<p>I write JS for a living and have had this exact problem. &nbsp;I take the manual route every time.</p>
<p>Using math.min actually never occurred to me. &nbsp;Clever. &nbsp;I might try that in the future just to reduce the code written (typically speed isn&#39;t important except in specific instances where a piece of code is run a lot).</p>
<p>And then there is the fact that I have to write for IE7 and IE8 at work. &nbsp;There is no .reduce or .indexOf, so that limits your options. &nbsp;You can write shims of course but then you are still pursuing a manual method, just with more code and function call overhead! &nbsp;Ironically you&#39;re writing your code to be faster in non-IE and slower in IE. &nbsp;Not that I have too much of a problem with this.</p>
<p>PS: Raymond: Try using the IE Dev Tools profiler (and Chrome&#39;s own profiler) to time functions. &nbsp;Very interesting to look at and pretty easy to see where you need to optimize things&#8230; though typically for me all my time is spent in native DOM functions thus I end up needing to just rethink how I&#39;m doing the DOM manipulation. :(</p>
<p>@Mc Exactly. &nbsp;I worked with a guy who wanted to optimize everything up front. &nbsp;Smart guy, but he ended up WRITING HIS OWN STACK to get around a problem with IE6&#39;s ~2000 iteration stack limit for a specific recursive function&#8230; and we might not have needed to. &nbsp;Needless to say whenever that function was called you could not trust the real stack trace since it was destroyed. &nbsp;Made debugging a LOT harder.</p>
<p>Same reasoning was used to reject jQuery. &nbsp;I am on a smaller project now and I was able to call some shots this time, so I said we&#39;re using jQuery. &nbsp;It has helped so much more than I&#39;d dreamed. &nbsp;Much neater code when dealing with the DOM, auto-cross platform, etc. &nbsp;And where there have been inefficiencies I can identify them and drop back to normal DOM functions in a few specific places.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125933">
				<div id="div-comment-1125933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125933">
			May 26, 2014 at 9:28 am</a>		</div>

		<p>@Wladimir Palant, the array copying expains the difference even further.</p>
<p>So, the min/indexOf version may be at least 3 times slower than the manual version because:</p>
<p>&#8211; It copies the array to an arguments object inside Function.prototype.apply</p>
<p>&#8211; It scans the arguments to find the smallest element with &lt; inside Math.min</p>
<p>&#8211; It scans the array to find and return the smallest element&#39;s index with === inside Array.prototype.indexOf</p>
<p>I believe the manual version can be further optimized (a tiny bit) by remembering the smallest element and comparing to it, thus avoiding many a[lowest] accesses.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125943">
				<div id="div-comment-1125943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125943">
			May 26, 2014 at 9:56 am</a>		</div>

		<p>BTW Raymond you didn&#39;t mention whether the randomly generated data is ints or doubles. &nbsp;Some JS engines, like Chrome&#39;s, will optimize for integers. &nbsp;In my results below you can see a big difference in some of IE&#39;s tests.</p>
<p>Also your ternary in the second function is backwards (only noticed when I went to run it).</p>
<p>I did my own tests. &nbsp;Average of 100 runs. &nbsp;I used new Date() to time things so I only got MS granularity, at least in Chrome. &nbsp;Didn&#39;t check the others.</p>
<p>Relative running time per array element</p>
<p>Elements	manual	reduce	min/indexOf	</p>
<p>Chrome 37 dev &#8211; Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2008.2 Safari/537.36</p>
<p>100000 doubles	0.41	10.56	15.98	</p>
<p>100000 ints	0.41	11.18	14.14	</p>
<p>200000 doubles	0.89	23.26	ERROR	</p>
<p>200000 ints	0.93	23.18	ERROR	</p>
<p>250000 doubles	1.08	30.29	ERROR	</p>
<p>250000 ints	1.02	29.97	ERROR	</p>
<p>IE11 &#8211; Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET CLR 1.1.4322; .NET4.0C; .NET4.0E; rv:11.0) like Gecko</p>
<p>100000 doubles	0.47	6.76	8.24 </p>
<p>100000 ints	0.48	5.61	8.24 </p>
<p>200000 doubles	1.04	13.84	24.38 </p>
<p>200000 ints	0.93	11.76	11.24 </p>
<p>250000 doubles	1.34	17.37	29.38 </p>
<p>250000 ints	1.47	15.74	27.47 </p>
<p>Firefox Nightly 32.0a1 (2014-05-26) &#8211; Mozilla/5.0 (Windows NT 6.1; WOW64; rv:32.0) Gecko/20100101 Firefox/32.0</p>
<p>100000 doubles	0.21	1.05	1.46	</p>
<p>100000 ints	0.2	1.06	1.44	</p>
<p>200000 doubles	0.35	2.11	3.2	</p>
<p>200000 ints	0.36	2.23	2.9	</p>
<p>250000 doubles	0.54	2.79	4.05	</p>
<p>250000 ints	0.45	3.2	4</p>
<p>* &#8211; Chrome encountered stack overflow errors</p>
<p>Firefox has gotten stupid fast, it seems. &nbsp;I remember when 3.5 was so slow I jumped ship to Chrome first chance I got; was even worth losing add-ons at the time. &nbsp;Chrome is interestingly oddly slow in some cases, either the other browsers are catching up or one of my browser extensions is slowing things down a bit, who knows&#8230;</p>
<p>Here&#39;s the code I used: <a rel="nofollow" target="_new" href="http://jsfiddle.net/G83mW/1/">http://jsfiddle.net/G83mW/1/</a></p>
<p>Could probably use some code to throw up highest/lowest outlying test results. &nbsp;Thankfully we have a few functions for at least one of those purposes already!</p>
<p>Also could use shims for .indexOf, and .reduce if you want to test early IE versions.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125953">
				<div id="div-comment-1125953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marvin </cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125953">
			May 26, 2014 at 10:38 am</a>		</div>

		<p>Raymond, read about Asm.js and weep. The fastest way to use JS is to treat it as assembly and use C++ on top of it :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125973">
				<div id="div-comment-1125973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marvin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125973">
			May 26, 2014 at 11:05 am</a>		</div>

		<p>acq: Mine was a general comment about JS efficiency not this particular problem. If you want to write high level code doing things manually will become painful very quickly. JS today is efficient processing simple operators on vars and accessing arrays. Using this as a primitive you can build other languages on top that will give you higher level abstractions in a fast way. JS itself is not optimization friendly. </p>
<p>BTW: once you know this you could predict outcome of Raymond&#39;s experiment right away &#8211; wasn&#39;t surprising to me. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1125983">
				<div id="div-comment-1125983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125983">
			May 26, 2014 at 11:49 am</a>		</div>

		<p>Finding the array length only once: var n=a.length; for (var i = 1; i &lt; n; i++) &nbsp;speeds up both Firefox and IE 11 in &quot;manual.&quot; On 250k FF is 7 times faster than reduce version, and IE 11 even 31 times faster. The absolute time for FF manual is apparently 0.25s and IE 11 manual 0.31s.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125993">
				<div id="div-comment-1125993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125993">
			May 26, 2014 at 12:05 pm</a>		</div>

		<p>Correction, it&#39;s apparently &quot;milliseconds:&quot; here are number of full executions per second (a.length in loop, outside, reduce, apply):</p>
<p>Firefox</p>
<p>250000 doubles	 3333 &nbsp;4347 &nbsp;549 &nbsp;476</p>
<p>250000 ints	 3333 &nbsp;4347 &nbsp;558 &nbsp;450</p>
<p>IE 11</p>
<p>250000 doubles &nbsp;1190 &nbsp;3225 &nbsp;108 &nbsp;67 </p>
<p>250000 ints &nbsp;1190 &nbsp;3333 &nbsp;110 &nbsp;120 </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126003">
				<div id="div-comment-1126003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126003">
			May 26, 2014 at 12:26 pm</a>		</div>

		<p>Instead of quoting results, my version of The MAZZTer&#39;s bench: <a rel="nofollow" target="_new" href="http://jsfiddle.net/G83mW/4/">http://jsfiddle.net/G83mW/4/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126013">
				<div id="div-comment-1126013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeffrey Bosboom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126013">
			May 26, 2014 at 1:21 pm</a>		</div>

		<p>It&#39;s refreshing when the simple and obvious implementation is also the fastest.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126033">
				<div id="div-comment-1126033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126033">
			May 26, 2014 at 2:32 pm</a>		</div>

		<p>Matt, I agree. I&#39;ve already read the presentation of some &quot;smart&quot; guy who proposed &quot;the OS written in JavaScript.&quot; To make the really compact and effective code we still need C (and the real asm), although even as every now and then the programmers who depend on GCs and VMs think that everything is the nail for their hammer.</p>
<p>On another side, JavaScript engines got immensely faster in the last years. It all started with one company that made a new and at that moment much faster engine than any among older players&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126043">
				<div id="div-comment-1126043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shocking</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126043">
			May 26, 2014 at 2:38 pm</a>		</div>

		<p>As usual, IE is the slowest and most buggy browser. Who would have thought.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126053">
				<div id="div-comment-1126053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lucidfox</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126053">
			May 26, 2014 at 3:51 pm</a>		</div>

		<p>Number of executions per second.</p>
<p>Elements	manual	manualn	manualcmp	manualncmp	reduce	min/indexOf	</p>
<p>Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2011.0 Safari/537.36</p>
<p>250000 doubles	2631	2631	3333	3333	74	ERROR	RangeError: Maximum call stack size exceeded</p>
<p>250000 ints	2702	2702	3333	3333	75	ERROR	RangeError: Maximum call stack size exceeded</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126063">
				<div id="div-comment-1126063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126063">
			May 26, 2014 at 4:11 pm</a>		</div>

		<p>I am not surprised at the results and was predicting them before reading half the page (basically just long enough for parallel thought to overrun read after reading the problem statement). JavaScript is jitted now so it has the same behavior as other jotted code. If you want it fast don&#39;t bother to use higher order functions. I thought everybody knew this by now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126073">
				<div id="div-comment-1126073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126073">
			May 26, 2014 at 4:21 pm</a>		</div>

		<p>@Shocking:</p>
<p>Eh? Slowest? Most buggy? I think you got lost, the IE blog is elsewhere. That is where you bash IE isn&#39;t it?</p>
<p>Anyway, because I was bored, I also decided to get the results of IE x64.</p>
<p>Relative running time per array element</p>
<p>Elements manual reduce min/indexOf </p>
<p>Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; .NET4.0E; .NET4.0C; .NET CLR 3.5.30729; .NET CLR 2.0.50727; .NET CLR 3.0.30729; InfoPath.3; rv:11.0) like Gecko</p>
<p>100000 doubles 0.31 3.69 5.02 </p>
<p>100000 ints 0.29 2.92 3.03 </p>
<p>200000 doubles 0.58 6.72 9.77 </p>
<p>200000 ints 0.58 5.78 4.7 </p>
<p>250000 doubles 0.73 8.35 9.17 </p>
<p>250000 ints 0.73 7.23 11.64 </p>
<p>Relative running time per array element</p>
<p>Elements manual reduce min/indexOf </p>
<p>Mozilla/5.0 (Windows NT 6.3; Win64; x64; Trident/7.0; .NET4.0E; .NET4.0C; .NET CLR 3.5.30729; .NET CLR 2.0.50727; .NET CLR 3.0.30729; rv:11.0) like Gecko</p>
<p>100000 doubles 0.79 2.35 1.69 </p>
<p>100000 ints 0.31 1.98 2.07 </p>
<p>200000 doubles 0.59 3.8 ERROR </p>
<p>200000 ints 0.58 3.76 ERROR </p>
<p>250000 doubles 0.74 4.77 ERROR </p>
<p>250000 ints 0.73 4.69 ERROR </p>
<p>Number of executions per second.</p>
<p>Elements manual manualn manualcmp manualncmp reduce min/indexOf </p>
<p>Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; .NET4.0E; .NET4.0C; .NET CLR 3.5.30729; .NET CLR 2.0.50727; .NET CLR 3.0.30729; InfoPath.3; rv:11.0) like Gecko</p>
<p>250000 doubles 943 1282 2325 1315 99 72 </p>
<p>250000 ints 1298 1298 2325 2439 130 102 </p>
<p>Number of executions per second.</p>
<p>Elements manual manualn manualcmp manualncmp reduce min/indexOf </p>
<p>Mozilla/5.0 (Windows NT 6.3; Win64; x64; Trident/7.0; .NET4.0E; .NET4.0C; .NET CLR 3.5.30729; .NET CLR 2.0.50727; .NET CLR 3.0.30729; rv:11.0) like Gecko</p>
<p>250000 doubles 900 1265 2000 2777 194 ERROR </p>
<p>250000 ints 689 1176 2040 2857 198 ERROR </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1125963">
				<div id="div-comment-1125963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1125963">
			May 26, 2014 at 10:48 am</a>		</div>

		<p>Marvin, you don&#39;t need C++ to write asm.js code, at least implementing the &quot;manual indexOfSmallest&quot; demo should not be *that* hard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1126093">
				<div id="div-comment-1126093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126093">
			May 26, 2014 at 6:13 pm</a>		</div>

		<p>I have similar experience in writing VBA too. In VBA code, writing your code runs faster than built-in methods at many time.</p>
<p>Say if you look at the call to use Advanced Filter to copy unique values to another row, you&#39;ll find writing the code by yourself runs lightning fast (almost instant complete), and using that function is noticably slower)</p>
<p>On the other hand, if you&#39;re writing code that calls Office Automation from outside (like C#) you&#39;ll want to call built-in function to avoid COM transversal overhead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126103">
				<div id="div-comment-1126103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126103">
			May 26, 2014 at 8:51 pm</a>		</div>

		<p>I have to ask this: when was this article written? Firefox 16 is late 2012 IIRC. That&#39;s a 1.6 year delay between the article being written and its&#39; publication.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126023">
				<div id="div-comment-1126023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126023">
			May 26, 2014 at 2:06 pm</a>		</div>

		<p>I&#39;m a little bit worried by people jumping to all sorts of conclusions that JavaScript is somehow faster than the C++ code that backs it here. That&#39;s not what&#39;s going on.</p>
<p>Having written lots of these engines, the thing that&#39;s expensive is the *transition* between JavaScript and C++. The cost of wrapping an inlined float to a VARIANT structure and then calling the intrinsic over a IDispatch(Ex) and then unwrapping it from that variant in order to do the comparison kills the performance benefit of the C++ &#8211; especially when we recognise that a single &quot;&lt;&quot; operator is going to be JITted rather efficiently by the Trident engine and the loop can be unrolled and vectorized by the JIT engine if it doesn&#39;t contain anything crazy like an intrinsic or a virtual method call.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126123">
				<div id="div-comment-1126123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126123">
			May 27, 2014 at 3:51 am</a>		</div>

		<p>I tried to compare all three benchmarks on both 32-bit and 64-bit Firefox but the results were inconclusive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126153">
				<div id="div-comment-1126153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126153">
			May 27, 2014 at 6:00 am</a>		</div>

		<p>Neil, my end conclusion, observing only the &quot;manual&quot; code, is that Firefox actually doesn&#39;t care about a.length inside of the for condition but IE 11 definitely prefers to compare with a scalar. So the former obviously knows that specific optimization. Still both benefit if the inside of the loop the current minimum which is being compared is a scalar too. Compared to the &quot;reduce&quot; variant in the same browser, that fastest &quot;manual&quot; is 7 times faster on Firefox and almost 40 times faster on IE 11. Firefox is around 1/4th faster in such a fastest &quot;manual&quot; versus IE 11. The Chromium nightly has the same speed no matter if scalars are in the loop or not, but it&#39;s therefore two times slower than IE 11 and 2.5 times slower than Firefox. Chromium is also 20 times faster with its &quot;manual&quot; vs its own &quot;reduce.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126163">
				<div id="div-comment-1126163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126163">
			May 27, 2014 at 6:06 am</a>		</div>

		<p>Still, please note that all this doesn&#39;t necessarily translate to your use case: if there are much less loop passes, the JIT doesn&#39;t have to come to the point to generate the native code, so if you know that you&#39;ll process only a very small array, the reduce approach can be a better choice: The measurements we talk about only reflect the current state of the JIT engines in the browsers once they have a tight and long loops. The &quot;apply&quot; is however something that except for looking nice, in the present state, shouldn&#39;t be used for any possibly bigger array.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman odd alt thread-odd thread-alt depth-1" id="comment-1126173">
				<div id="div-comment-1126173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126173">
			May 27, 2014 at 7:02 am</a>		</div>

		<p>@Ben: As Raymond has said in the past: &quot;I&#39;m not the only one with a long posting queue. So remember that the next time you see a strange coincidence between an article that comes out of my queue and the date it appears.&quot; <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2010/12/31/10110525.aspx">blogs.msdn.com/&#8230;/10110525.aspx</a></p>
<p>Somewhere he once said that the queue was about 18 months, though I can&#39;t find the specific blog article in the search.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126213">
				<div id="div-comment-1126213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Lindholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126213">
			May 27, 2014 at 8:25 am</a>		</div>

		<p>This blog post discusses some reasons why &quot;reduce&quot; etc. are slow in Firefox: <a rel="nofollow" target="_new" href="http://rfrn.org/~shu/2013/03/20/two-reasons-functional-style-is-slow-in-spidermonkey.html">rfrn.org/&#8230;/two-reasons-functional-style-is-slow-in-spidermonkey.html</a></p>
<p>In this case it seems to come down to implementing all the additional logic needed to comply with the spec, most importantly the requirement of being able to handle sparse arrays. Writing a custom &quot;reduce&quot; function gives me performance on par with the manual loop: <a rel="nofollow" target="_new" href="http://jsfiddle.net/G83mW/10/">http://jsfiddle.net/G83mW/10/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126253">
				<div id="div-comment-1126253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126253">
			May 27, 2014 at 9:46 am</a>		</div>

		<p>@the jazzier: came here to see Fox is fastest, wasn&#39;t disappointed. Crazy people @Mozilla </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126263">
				<div id="div-comment-1126263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126263">
			May 27, 2014 at 9:46 am</a>		</div>

		<p>Thanks Simon! I understand your result that the main reason the &quot;reduce&quot; is slow in Firefox is that it&#39;s *not* implemented in javascript, and therefore JIT can&#39;t work on it. For those who don&#39;t run the jsfiddle tests: your hand-written &quot;reduce&quot; achieves the speed of a[i] &lt; a[lowest] &quot;manual&quot; version. Such &quot;reduce&quot; in IE 11 is almost 5 times faster than built-in, but still at least 4 times slower than &quot;manual.&quot;</p>
<p>Now that the path to the faster &quot;reduce&quot; is clearer, why in the world must &quot;min.apply&quot; get every array element separately copied as the parameter, and that *in all the engines*? The use case where the existing array is the second argument is documented and expected. Why &quot;flattening&quot;? It&#39;s definitely a very concise notation and worth supporting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1126303">
				<div id="div-comment-1126303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126303">
			May 27, 2014 at 6:20 pm</a>		</div>

		<p>This makes me remember something last night.</p>
<p>At 2009, I&#39;ve filed request on adding GREATEST() or LEAST() in T-SQL like what they have at PL/SQL on MS Connect. <a rel="nofollow" target="_new" href="https://connect.microsoft.com/SQLServer/feedback/details/509676/maxval-minval-and-avgval">connect.microsoft.com/&#8230;/maxval-minval-and-avgval</a></p>
<p>The SQL team expressed interest at the beginning, but later marked that as &quot;won&#39;t fix&quot;. Could it be because of similar reason?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126313">
				<div id="div-comment-1126313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126313">
			May 27, 2014 at 6:36 pm</a>		</div>

		<p>@Joshua: &quot;JavaScript is jitted now so it has the same behavior as other jotted code. If you want it fast don&#39;t bother to use higher order functions. I thought everybody knew this by now.&quot;</p>
<p>Except that if you write the same code in say Java, your higher-order function will be just as fast as the manual loop, because there&#39;s absolutely nothing inherent in higher-order functions that tells the JIT &quot;sorry you&#39;re not allowed to optimize this&quot;. It&#39;s just JavaScript once again being a horrible language beyond comparison making the life that much harder for JITs. So certainly not something everybody would or should know &#8211; if you&#39;re not optimizing JavaScript code why care about its peculiarities?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126333">
				<div id="div-comment-1126333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David M</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126333">
			May 27, 2014 at 9:57 pm</a>		</div>

		<p>My expectations matched your &#39;naive&#39; self. &nbsp;But my extra special naivety is showing, as I am still surprised.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jonathan-timssungard-com even thread-even depth-1" id="comment-1126373">
				<div id="div-comment-1126373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/carbon+twelve' rel='external nofollow' class='url'>carbon twelve</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126373">
			May 28, 2014 at 2:23 am</a>		</div>

		<p>My guess was that the manual version would be fastest; followed by the slightly higher level version; followed by the much higher level version.</p>
<p>This is just because that&#39;s how it&#39;s worked in pretty much every language I&#39;ve ever used: for all the guff about higher-level code being theoretically easier to optimise, it never actually seems to work out that way in practice!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126413">
				<div id="div-comment-1126413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126413">
			May 28, 2014 at 6:54 am</a>		</div>

		<p>@carbon twelve &quot; for all the guff about higher-level code being theoretically easier to optimise, it never actually seems to work out that way in practice!&quot;</p>
<p>JITs have crap optimisers because every millisecond spent optimising the code is a millisecond where the user is waiting before the code has even started running. </p>
<p>If you write your code in a statically-compiled language with a mature compiler like MSVC C/C++ you&#39;ll see simple loops get unrolled and aggressively vectorized and functional calls get inlined.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126463">
				<div id="div-comment-1126463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Silly</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126463">
			May 28, 2014 at 7:24 am</a>		</div>

		<p>Wouldn&#39;t you just ask it on the way into the array?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-iboyd odd alt thread-odd thread-alt depth-1" id="comment-1126553">
				<div id="div-comment-1126553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/IanBoyd' rel='external nofollow' class='url'>IanBoyd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126553">
			May 28, 2014 at 10:08 am</a>		</div>

		<p>I would think that the `reduce` intrinsic can start to do advanced things, such as dividing up the array into n-chunks (where n is your number of logical processors). Then reduce the array in parallel. </p>
<p>As we already know, multi-core performance gains don&#39;t come from multiple execution units: they come from having more cache (L1, L2, L3).</p>
<p>Bonus Viewing</p>
<p>Native Code Performance on Modern CPUs: A Changing Landscape by Eric Brumer</p>
<p><a rel="nofollow" target="_new" href="http://channel9.msdn.com/Events/Build/2013/4-329">channel9.msdn.com/&#8230;/4-329</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126623">
				<div id="div-comment-1126623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paranoid</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126623">
			May 28, 2014 at 10:51 am</a>		</div>

		<p>Talking about speed. What is the &quot;Post&quot; button doing that makes chrome hang for seconds and activate the hard drive?</p>
<p>What information are you collecting, mr nsa.. er I mean microsoft?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126643">
				<div id="div-comment-1126643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Drunk and stupid atm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126643">
			May 28, 2014 at 11:46 am</a>		</div>

		<p>&quot;I&#39;ve normalized run times so that the results are independent of CPU speed.&quot;</p>
<p>How do you achieve that?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1126743">
				<div id="div-comment-1126743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Lindholm</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126743">
			May 28, 2014 at 5:55 pm</a>		</div>

		<p>@acq: Firefox actually does implement &quot;reduce&quot; in JavaScript (i.e. self-hosts it), the implementation just happens to be quite slow because (mainly) of the need to support sparse arrays. Instead of using a regular for-loop &quot;for (var i = 0; i &lt; len; i++) { fn(ar[i]); }&quot; it does the equivalent of &quot;for (var i = 0; i &lt; len; i++) { if (i in ar) fn(ar[i]); }&quot; &#8211; see the source code at <a rel="nofollow" target="_new" href="http://dxr.mozilla.org/mozilla-central/source/js/src/builtin/Array.js">dxr.mozilla.org/&#8230;/Array.js</a>. But it&#39;s true that a non-self-hosted version would have been slower still.</p>
<p>As for why &quot;apply&quot; copies everything onto the stack: 1) adding another stack argument representation complicates JIT design, and might require additional branches 2) naively sharing memory doesn&#39;t work, since both arguments and array are mutable. And no-one has bothered to optimize &quot;Math.min.apply(Math, ar)&quot; (or ES6&#39;s &quot;Math.min(&#8230;ar)&quot;!) specifically, since it&#39;s an uncommon pattern, with a simple and fast alternative.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1126863">
				<div id="div-comment-1126863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1126863">
			May 29, 2014 at 4:08 am</a>		</div>

		<p>Simon, thanks a lot for the insights.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1127193">
				<div id="div-comment-1127193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140526-00/?p=903#comment-1127193">
			May 29, 2014 at 3:50 pm</a>		</div>

		<p>@acq, sharing the provided array with the arguments object (e.g. the actual underlying array) is a possible optimization if the compiler can prove that the callee won&#39;t change it. &nbsp;It could as well share until the point it&#39;s changed, and then copy it, with a smart implementation of copy-on-write sparse arrays.</p>
<p>In some lisps, apply is optimized on the caller when providing a (rest of a) list that was itself already on the stack, but as soon as that list is changed or provided as a normal argument to other functions from within the callee (other than with apply), the args list is reified to a fresh list. &nbsp;IIRC, the args list may or may not be the provided list, in order to allow an implementation to provide a copy of the variable amount of arguments on the stack.</p>
<p>I guess this is still an inspiration for current JS implementers. &nbsp;I think at least one or two scheme implementations have shown that native stacks are a bit overrated, but I guess they were talking about ease of capturing (managed) stacks for full continuations and all GC related stuff.</p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Spaghetti_stack">en.wikipedia.org/&#8230;/Spaghetti_stack</a></p>
<p><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Funarg_problem">en.wikipedia.org/&#8230;/Funarg_problem</a></p>
<p>Lisp was perceived as very slow, quite as much as current interpreted languages are relative to natively compiled, manually memory managed languages. &nbsp;Because of that, some expensive machines were made, dedicated to running lisp. &nbsp;And yes, the OS was in lisp itself, with GC, runtime function redefinitions, OO, etc. &nbsp;Much like what you see in a browser&#39;s developer tools, but with drivers (e.g. network), peripherals and devices (e.g. mouse, keyboard, printers), native applications, completely inspectable GUIs where most things are sensitive to mouse-over and the IDE (inspector, debugger, editor, etc) was part of the system, distributed services, and whatnot. &nbsp;Of Course, the chance to shoot yourself in the foot was just a tiny portion of bricking the machine.</p>
<p>Eventually, native compilers for non-dedicated machines (e.g. Unix, Windows) and GC got good enough that can (almost) match .NET and Java, but no one is seriously trying the OS thing anymore, at least not the kernel-in-lisp thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

