<html>
<head>
<title>The oft-misunderstood /3GB switch</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The oft-misunderstood /3GB switch</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>August 5, 2004 / year-entry #300</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>32</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">It's simple to explain what it does, but people often misunderstand. The /3GB switch changes the way the 4GB virtual address space is split up. Instead of splitting it as 2GB of user mode virtual address space and 2GB of kernel mode virtual address space, the split is 3GB of user mode virtual address space...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>It's simple to explain what it does, but people often misunderstand.</p>
<p>  The /3GB switch changes the way the 4GB virtual address space is split up.  Instead of splitting it as 2GB of user mode virtual address space  and 2GB of kernel mode virtual address space,  the split is 3GB of user mode virtual address space and 1GB of kernel mode  virtual address space.  </p>
<p>  That's all.  </p>
<p>  And yet people think it does more than that.  </p>
<p>  I think the problem is that people think that "virtual address space"  means something other than just "virtual address space".  </p>
<p>  The term "address space" refers to how a numerical value (known  as an "address") is interpreted when it is used to access some  type of resource.  There is a physical address space; each address  in the physical address space refers to a byte in a memory chip  somewhere.  (Note for pedants: Yes, it's actually spread out over  several memory chips, but that's not important here.)  There is an I/O address space; each address in the I/O address space  allows the CPU to communicate with a hardware device.  </p>
<p>  And then there is the virtual address space.  When people  say "address space", they usually mean "virtual address space".  </p>
<p>  The virtual address space is the set of possible pointer values  (addresses) that can be used at a single moment by the processor.  In other words, if you have  an address like 0x12345678, the virtual address space determines what  you get if you try to access that memory.  The contents of the virtual address space changes over time, for example,  as you allocate and free memory.  It also varies based on context: each process has its own virtual address  space.  </p>
<p>  Saying that 2GB (or 3GB) of virtual address space is available to user mode  means that at any given moment in time, out of the 4 billion  virtual addresses available in a 32-bit value, 2 billion  (or 3 billion) of them are potentially usable by user-mode code.  </p>
<p>  Over the next few entries, I'll talk about the  various consequences and misinterpretations of the /3GB switch.  </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (32)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-201273">
				<div id="div-comment-201273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miles Archer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201273">
			August 5, 2004 at 7:13 am</a>		</div>

		<p>It&#8217;s amazing how many times I&#8217;ve had to explain virtual memory and address space to people who should have already known it.</p>
<p>I do have one question. Is it really virtual address space if the machine has enough real memory? If you have a machine with 4GB of RAM, isn&#8217;t the distinction between virtual and real moot?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201283">
				<div id="div-comment-201283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeproject.com/script/articles/list_articles.asp?userid=152' rel='external nofollow' class='url'>Mike Dunn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201283">
			August 5, 2004 at 7:21 am</a>		</div>

		<p>That would be true only if all processes shared the same 4GB address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201323">
				<div id="div-comment-201323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Tandetnik</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201323">
			August 5, 2004 at 7:44 am</a>		</div>

		<p>The distinction is still necessary. Every process has its own 4GB virtual address space, but all share the same RAM. Two processes can have two different things at the same virtual address, which of course must map to two different RAM addresses.</p>
<p>For example, almost every EXE gets its image loaded at the same address, 0x400000 IIRC, in its own address space. So there&#8217;s no way for virtual addresses to directly correspond to RAM addresses.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201433">
				<div id="div-comment-201433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/carmencr' rel='external nofollow' class='url'>Carmen Crincoli</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201433">
			August 5, 2004 at 9:34 am</a>		</div>

		<p>This is exactly the of confusion that often needs to be clarified for people moving into the truly large memory realm.</p>
<p>Many thanks to Raymond for giving this topic the time it needs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201443">
				<div id="div-comment-201443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">runtime</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201443">
			August 5, 2004 at 9:43 am</a>		</div>

		<p>Just for comparison, Linux defaults to 3 GB for user mode and 1 GB for kernel mode. There are experimental patches to implement a separate virtual address space for the kernel, thus granting 4 GB for user mode AND 4 GB for kernel mode. Unfortunately, there is a 10-20% performance hit because every system call requires an address space switch (and TLB cache flush).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201453">
				<div id="div-comment-201453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201453">
			August 5, 2004 at 9:45 am</a>		</div>

		<p>Perhaps a more useful way to think about it is this. In order to bend the spoon first you must know that there is no spoon.</p>
<p>Likewise. There is no RAM. When you call new, or alloc() or the allocator of your choice on a Virtual Memory OS you are not allocating RAM. You are allocating space in a paging file on disk. Your &quot;memory&quot; allocation is actually a set of file system calls.</p>
<p>The virtual address space is nothing but a view of files. RAM in this sense is nothing more than a cache, to speed up all that disk access your program does everytime it changes the value in a &quot;memory location&quot;.</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201463">
				<div id="div-comment-201463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201463">
			August 5, 2004 at 9:47 am</a>		</div>

		<p>Ooops, that post by &quot;Igor&quot; was from me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201483">
				<div id="div-comment-201483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com/' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201483">
			August 5, 2004 at 9:54 am</a>		</div>

		<p>Remember that &#8216;virtual&#8217; means &#8216;fake&#8217;. Windows &#8211; and any other VMOS &#8211; fakes an address space for a user process, conning the process (OK, the user-mode programmer) into believing that they have a huge flat area of memory that they can randomly address at any time.</p>
<p>In reality, it&#8217;s full of holes where the programmer hasn&#8217;t indicated a desire to use a particular address yet. Of the addresses that the programmer has asked to use, the OS may or may not have currently allocated physical memory to that address. If it hasn&#8217;t, the OS will allocate physical memory when it&#8217;s accessed, seamlessly loading the appropriate data if required, suspending (blocking) the thread until the data arrives. If the data isn&#8217;t available, you&#8217;ll get some kind of exception. All versions of Windows, including CE, are demand-paged &#8211; you only get memory when it&#8217;s required.</p>
<p>Virtual addresses can be backed by memory-mapped files or by the swap file.</p>
<p>If you have 4GB of RAM &#8211; or even more &#8211; the system will continue to try to optimise the memory allocation between the working sets of all running processes, the system working set, and the system caches. If you&#8217;re not actively using the RAM for something, it will get used as data caches.</p>
<p>An understanding of how virtual memory really works is essential to understanding how to improve your software&#8217;s performance. With the overhead of paging being as high as it is, you want to keep your core working set as close together as possible, and get your data access strategies right. A true B-tree or linked list may be <em>algorithmically</em> better than a B+tree or an array, in pure processor time, but an actual implementation may display the opposite characteristics due to lower paging and better processor cache use.</p>
<p>I recommend &#8216;Inside Windows 2000, Third Edition&#8217; by Mark Russinovich and David Solomon for further reading. A new edition covering XP and 2003 is due out later in the year ( <a target="_new" href="http://www.solsem.com/books.html" rel="nofollow">http://www.solsem.com/books.html</a> ).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201493">
				<div id="div-comment-201493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com/' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201493">
			August 5, 2004 at 9:57 am</a>		</div>

		<p>OK, Igor/Chris explained it better, although you can often see that new and malloc have no effect on the reported VM size. This is because these operators and functions, which end up as calls to HeapAlloc, etc, run on top of the virtual memory system, allocating smaller blocks from whole pages.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201503">
				<div id="div-comment-201503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Candy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201503">
			August 5, 2004 at 11:30 am</a>		</div>

		<p>This is all nice to the user mode. But what about kernel mode. Either it didn&#8217;t need 2gb of space or it now has run out of space.</p>
<p>I knew what it meant. I just don&#8217;t understand how the kernal copes with memory mapped cache and AGP apertures, not to mention system.dlls.</p>
<p>In 9x virtual dos machines (I&#8217;m nor refering to ntvdm at all) required memory where the cache and AGP goes. Was this required for each V86 process (like 3.1 where all Win was in one V86 and each dos box in it&#8217;s own V86).</p>
<p>Or does it only use less than 1 gig of it&#8217;s 2 (in which case why isn&#8217;t /3gb standard)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201513">
				<div id="div-comment-201513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.zero-one-zero/vs' rel='external nofollow' class='url'>Jonathan Payne</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201513">
			August 5, 2004 at 11:32 am</a>		</div>

		<p>I understand that each user mode process has it&#8217;s own address space (so user mode programs can use number_of_processes x user_mode_memory_size mb of memory but am I right in thinking the kernel only ever has 1 or 2 GB available to it (in a 32 bit Windows)?</p>
<p>If so, what are the effects of giving the kernel more or less memory and why do the server vs non-server OSs have different defaults (is it a trade-off between a slightly quicker check for an address being kernel/user mode and the space available to processes)?</p>
<p>Also, doesn&#8217;t the /3GB switch have knock on effects on quite a few Microsoft programs (I thought Exchange, SQL server and link.exe all behaved differently when the switch is set)?</p>
<p>Jonathan</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201533">
				<div id="div-comment-201533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201533">
			August 5, 2004 at 12:07 pm</a>		</div>

		<p>Well, 1Gb is quite a lot for the kernel to access all things considered. SQL is usermode afterall.</p>
<p>The biggest things I can think of being in there would be DIBSections and DDB allocations made by the display driver in offscreen memory.</p>
<p>So, sure, there is some danger with the switch, but typically servers arn&#8217;t used for graphically intensive tasks so the probable cause of any 1Gb overflow can be eliminated.</p>
<p>If you use any non standard drivers though, it might be test to do some stability tests before using the switch.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201543">
				<div id="div-comment-201543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201543">
			August 5, 2004 at 1:22 pm</a>		</div>

		<p>Does 64-bit Windows have /12EB switch?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201563">
				<div id="div-comment-201563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201563">
			August 5, 2004 at 2:10 pm</a>		</div>

		<p>I understand virtual memory, but I had never heard of this switch.  I had to do some searching to discover it&#8217;s a boot.ini option.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201293">
				<div id="div-comment-201293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David McCabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201293">
			August 5, 2004 at 7:22 am</a>		</div>

		<p>Is it really virtual address space if the machine has enough real memory?</p>
<p>Of course it is. Just because you have 4Gb of physical RAM, it doesn&#8217;t mean it&#8217;s mapped into any process&#8217; virtual address space, just as having 4Gb of virtual address space doesn&#8217;t mean any physical RAM is mapped to any portion of that space. You *could* map the entire 4Gb of RAM to the address space of one process in a 1:1 mapping, but there&#8217;s no requirement to do so.</p>
<p>Add that to the fact that each process will have its own address space, and only the upper 2Gb (1Gb with /3GB) is shared. Mapping from physical RAM to virtual memory is done as required by the process.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201573">
				<div id="div-comment-201573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/carmencr' rel='external nofollow' class='url'>Carmen Crincoli</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201573">
			August 5, 2004 at 2:38 pm</a>		</div>

		<p>David/Jonathan: Depending on your needs, either 2GB is way more than needed, or not nearly enough.  That&#8217;s why we decided to make it tunable.</p>
<p>The way memory mapped cache works has more to do with the memory manager and cache manager than the VA space, to be honest.  Keeping track of the pages doesn&#8217;t equate to having them &quot;live&quot; in kernel mode VA space.  That&#8217;s a huge topic though, check out Inside Windows 2000 for a good treatment.</p>
<p>Chris: Like I said, 1GB can be nothing if you have lots of I/O that needs to be done.  DBA&#8217;s often assume that the more RAM they can get, at any cost, the better.  That&#8217;s only true if you&#8217;re not throttling your I/O.  What good is getting the data quickly if you can&#8217;t send it anywhere because of long queues?  I&#8217;ve seen many SQL implementations that take all the RAM they can get their hands on, and strangle the OS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201583">
				<div id="div-comment-201583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mikedimmick.blogspot.com/' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201583">
			August 5, 2004 at 3:44 pm</a>		</div>

		<p>Just flipping /3GB isn&#8217;t enough for most programs. It has the effect on the kernel, true, but unless your process&#8217;s executable has the Large Address Space Aware flag set, Windows won&#8217;t actually give you the full 3GB space. Link your executable with /LARGEADDRESSAWARE or use EDITBIN.</p>
<p>The reason you have to do this is that some programs were written to assume that bit 31 of a user-mode pointer would always be 0 and therefore that this bit could be reused for some other purpose. Some applications do this with bits 1 and 0 because for a 4-byte aligned quantity, bits 1 and 0 are also 0. When it wants to use the pointer, the repurposed bits values are stored somewhere, then they&#8217;re set to 0.</p>
<p>Of course, as soon as you start getting pointers in the 2-3GB region, bit 31 is set. The application sets the bit to 0 &#8211; whoops, you&#8217;re pointing at the wrong place.</p>
<p>So unless you&#8217;re working with an application you know is large address aware (Exchange Information Store and SQL Server spring to mind) don&#8217;t bother enabling /3GB, it&#8217;ll hurt kernel address space but do nothing for your processes.</p>
<p>As for what gets loaded into kernel VAs: memory sections for all loaded kernel mode modules (NTOSKRNL.EXE, HAL.DLL, WIN32K.SYS and a whole load of drivers), paged pool and non-paged pool (used for all the drivers&#8217; and system components&#8217; private memory heap allocations &#8211; non-paged pool for memory that may be accessed when paging is disabled, paged pool for everything else), system and process page tables, system and process working set lists, and the system caches.</p>
<p>Reducing the system space to 1GB with /3GB causes the maximum paged pool size to drop, according to &quot;Inside Windows 2000&quot;, from 482MB to 160MB, and removes a whole area 448MB in size which is used for system page table entries and system cache. The file system cache in Windows is based on mapped files: the system maps blocks of files 256KB at a time into virtual memory; when a process reads from or writes to a file, the virtual addresses are touched which causes the memory manager to swap data in from the file. This includes filesystem metadata &#8211; my system is currently showing 15MB &#8216;valid&#8217; (currently paged in), 6MB &#8216;standby/dirty&#8217; (removed from the working set and will be reused at some point, after being written to disk if dirty) and 542 views for a total of about 135MB of VA space for $Mft, the NTFS Master File Table. This is on a 512MB RAM system.</p>
<p>So reducing the amount of space available to the kernel can seriously affect disk caching and the ability of various components to allocate memory &#8211; probably reducing the number of asynchronous I/Os that can be pending. For the two components I mentioned before, Exchange Information Store and SQL Server, it can be worthwhile because they do a lot of their own disk buffering and a lot of unbuffered I/O to their transaction logs (e.g. STORE writes the entire content of every message to the transaction log before storing it in the appropriate database).</p>
<p>You can tune things even more on Windows XP and Server 2003 with the /USERVA switch.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201623">
				<div id="div-comment-201623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">M Hotchin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201623">
			August 5, 2004 at 6:42 pm</a>		</div>

		<p>Found on the web&#8230;.<br />
<br /><a target="_new" href="http://www.baetzler.de/humor/paging_game.html" rel="nofollow">http://www.baetzler.de/humor/paging_game.html</a></p>
<p>The Paging Game</p>
<p>The following is a technical update to IBM&#8217;s explaination of how virtual memory works. It was written by Jeff Berryman of the University of British Columbia and distributed at a share meeting shortly after IBM announced virtual memory for the 370 series.</p>
<p>RULES:<br />
<br />Each player gets several million &quot;things&quot;.</p>
<p>&quot;Things&quot; are kept in &quot;crates&quot; that hold 4096 &quot;things&quot; apiece. &quot;Things&quot; in the same &quot;crate&quot; are called &quot;crate-mates&quot;.</p>
<p>&quot;Crates&quot; are stored either in the &quot;workshop&quot; or the &quot;warehouse&quot;. The workshop is almost always too small to hold all the crates.</p>
<p>There is only one workshop, but there may be many warehouses. Everybody shares these.</p>
<p>To identify things, each thing has its own &quot;thing number&quot;.</p>
<p>What you do with a thing is to &quot;zark&quot; it. Everybody takes turns zarking.</p>
<p>You can only &quot;zark&quot; your things or shared things, not anyone else&#8217;s.</p>
<p>Things can only be &quot;zarked&quot; when they are in the workshop.</p>
<p>Only the &quot;Thing King&quot; knows whether a thing is in the workshop or the warehouse.</p>
<p>The longer the things in a crate go without being zarked, the grubbier the crate is said to become.</p>
<p>The way you get things is to ask the &quot;Thing King&quot;. He only gives out things in multiples of 4096 (that is, &quot;crates&quot;). This is to keep the royal overhead down.</p>
<p>The way you zark a thing is to give its thing number. If you give the number of a thing that happens to be in the workshop, it gets zarked right away. If it is in a warehouse, the Thing King packs the crate containing your thing into the workshop. If there is no room in the workshop, he first find the grubbiest crate in the workshop (irregardless of whether it is yours or someone else&#8217;s) and packs it off (along with its crate-mates) to a warehouse. In its place he puts the crate containing your thing. Your thing then gets zarked, and you never knew that it wasn&quot;t in the workshop all along.</p>
<p>Each player&quot;s stock of things has the same thing numbers (to the players) as everyone else&quot;s. The Thing King always knows who owns what thing, and whose turn it is to zark. Thus, one player can never accidentally zark another player&quot;s things, even though they may have the same thing numbers.</p>
<p>NOTES:<br />
<br />Traditionally, the Thing King sits at a large, segmented table, and is attended by pages (the so-called &quot;table pages&quot;) whose job it is to help the Thing King remember where all the things are and to whom they belong.</p>
<p>One consequence of rule #13 is that everyone&#8217;s thing numbers will be the similar from game to game, regardless of the number of players.</p>
<p>The Thing King has a few things of his own, some of which get grubbier, just as player&#8217;s things do, and so move back and forth between the workshop and the warehouse. Other things are used too often to get grubby, or are just to heavy to move.</p>
<p>With the given set of rules, oft-zarked things tend to get kept mostly in the workshop, while little-zarked things stay mostly out in the warehouse. This is efficient stock control.</p>
<p>Sometimes even the warehouses get full. The Thing King then has to start piling crates upon the dump out back. This makes the game slower because it takes a long time to get thing off the dump when they are needed in the workshop. In this case, the Thing King selects the grubbiest crates he can find in the warehouses and sends them to the dump in his spare time, thus keeping the warehouses from getting too full. This also means that the least-often zarked things end up on the dump, so the Thing King won&quot;t have to get things from the dump so often. This speeds up the game when there are a lot of players and the warehouses are getting full.</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201633">
				<div id="div-comment-201633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon Potter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201633">
			August 5, 2004 at 10:22 pm</a>		</div>

		<p>I have no difficulty understanding the difference between virtual addressing and real addressing, etc. But that zark stuff, my head&#8217;s still spinning from trying to follow that!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201643">
				<div id="div-comment-201643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201643">
			August 6, 2004 at 1:26 am</a>		</div>

		<p>things = bytes<br />
<br />crates = pages<br />
<br />crate-mates = ? but not important<br />
<br />workshop = cache<br />
<br />warehouse = physical memory<br />
<br />thing number = address<br />
<br />zark = dereference<br />
<br />thing king = CPU?<br />
<br />grubbier = older<br />
<br />royal overhead = system requirements<br />
<br />player = process<br />
<br />table pages = page tables<br />
<br />game = runs<br />
<br />dump = swap file</p>
<p>Basically describes a LRU scheme for a primitive CPU.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201753">
				<div id="div-comment-201753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anony</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201753">
			August 6, 2004 at 12:25 pm</a>		</div>

		<p>I think the warehouse is a pagefile and the dump is the original executable file, whose code is thrown out if there are too many other oft-zarked things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201783">
				<div id="div-comment-201783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201783">
			August 6, 2004 at 1:43 pm</a>		</div>

		<p>Ok, now I want to see that metaphorical example reworked to accound for the fact that my CPU has an L1 and an L2 cache, then physical RAM talking to an Hard Disk with its own 32Mb RAM cache.</p>
<p>:P</p>
<p>(If you manage that, then I suppose a dual CPU (with hyperthreading) wont stress you at ll :o )</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201723">
				<div id="div-comment-201723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201723">
			August 6, 2004 at 10:04 am</a>		</div>

		<p>asdf: Processors do *not* cache whole pages! The workshop is physical memory and the warehouse is disk. The Thing King is the kernel and the royal overhead is kernel memory. I think the dump is tape.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-201823">
				<div id="div-comment-201823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://channels.lockergnome.com/it/archives/20040806_when_is_4gb_of_ram_not_really_4gb_of_ram.phtml' rel='external nofollow' class='url'>Lockergnome's IT Professionals</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201823">
			August 6, 2004 at 11:01 pm</a>		</div>

		<p>Anyone with any experience administering applications like SQL Server and Exchange Server know how much they love memory. They&#8217;ll use every bit they can get their hands on. And then some more&#8230; The last thing you want to find out&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-201883">
				<div id="div-comment-201883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/evand/archive/2004/08/08/210926.aspx' rel='external nofollow' class='url'>Evan's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-201883">
			August 8, 2004 at 3:28 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-204883">
				<div id="div-comment-204883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.savagenomads.net/archives/000203.html' rel='external nofollow' class='url'>Savage Nomads</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-204883">
			August 20, 2004 at 1:45 pm</a>		</div>

		<p>&amp;nbsp; As Evan&amp;nbsp;already mentioned on his blog, Raymond Chen has a great series on /3GB switch on his blog. What is really cool is that Raymond takes on some myths about the /3GB switch and&amp;nbsp; the fact that he&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-205293">
				<div id="div-comment-205293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-205293">
			August 23, 2004 at 1:46 am</a>		</div>

		<p>I found that Exchange (at least 2003) moans about this setting on a 4GB system not having this set. Microsoft KB refers to this switch preferably to be set if using Exchange 2003.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240793">
				<div id="div-comment-240793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://chrisoverbeek.com/crashblog/archive/0001/01/01/719.aspx' rel='external nofollow' class='url'>crashBlog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-240793">
			January 9, 2005 at 2:39 pm</a>		</div>

		
		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-555033">
				<div id="div-comment-555033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://forums.pcapex.com/general_os_tweaks/115070-vista_not_reading_all_my_ram.html#post667901' rel='external nofollow' class='url'>Vista not reading all my RAM? - PC Apex Forums</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-555033">
			September 29, 2007 at 4:11 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://forums.pcapex.com/general_os_tweaks/115070-vista_not_reading_all_my_ram.html#post667901" rel="nofollow">http://forums.pcapex.com/general_os_tweaks/115070-vista_not_reading_all_my_ram.html#post667901</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-609733">
				<div id="div-comment-609733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://saltwetfish.wordpress.com/2008/03/13/windebug-3gb-and-pae-switches/' rel='external nofollow' class='url'>Windebug: 3GB and PAE switches &laquo; Salt * Wet * Bytes</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-609733">
			March 13, 2008 at 12:43 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://saltwetfish.wordpress.com/2008/03/13/windebug-3gb-and-pae-switches/" rel="nofollow">http://saltwetfish.wordpress.com/2008/03/13/windebug-3gb-and-pae-switches/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-677533">
				<div id="div-comment-677533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.kevinmills.name/2008/10/building-a-photoshop-workstation/' rel='external nofollow' class='url'>Building a Photoshop Workstation | Kevin's Photo Studio</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-677533">
			October 25, 2008 at 2:18 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.kevinmills.name/2008/10/building-a-photoshop-workstation/" rel="nofollow">http://www.kevinmills.name/2008/10/building-a-photoshop-workstation/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-695443">
				<div id="div-comment-695443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://tphinney.wordpress.com/2008/12/19/no-font-install/' rel='external nofollow' class='url'>Unable to install OpenType .otf &amp; PostScript Type 1 fonts &laquo; Phinney on Fonts</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040805-00/?p=38233#comment-695443">
			December 26, 2008 at 7:02 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://tphinney.wordpress.com/2008/12/19/no-font-install/" rel="nofollow">http://tphinney.wordpress.com/2008/12/19/no-font-install/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

