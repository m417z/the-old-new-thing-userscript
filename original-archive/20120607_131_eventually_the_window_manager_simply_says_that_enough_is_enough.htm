<html>
<head>
<title>Eventually the window manager simply says that enough is enough</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Eventually the window manager simply says that enough is enough</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 7, 2012 / year-entry #132</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Many window manager operations are recursive, and eventually the window manager will simply say that enough is enough when the recursion goes too deep. We've seen this when you nest windows more than 50 levels deep or nest menus more than 25 levels deep, for example. (Note also that these limits may change in the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Many window manager operations are recursive,
and eventually
the window manager will simply say that enough is enough
when the recursion goes too deep.
We've seen this when you
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2003/12/18/44379.aspx">
nest windows more than 50 levels deep</a>
or
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2003/12/30/46594.aspx">
nest menus more than 25 levels deep</a>,
for example.
(Note also that these limits may change in the future, so don't
rely on being able to walk right up to the edge.
Those values came from 32-bit Windows&nbsp;XP;
I don't know if the limits have been dropped even further in 
subsequent versions of Windows, and I'm not sufficiently
motivated to find out.)
</p>
<p>
A customer had some code which installed a message hook,
and they found that the message hook was not called consistently.
They tracked it down to another component in their application,
and that component also installed a message hook.
The contact actually came from the developer who maintained the
other component:
Did I write my message hook incorrectly?
Am I accidentally messing up other message hooks in the system?
</p>
<p>
The developer included their hook-management code, and it didn't
look obviously wrong.
All code paths eventually called <code>Call&shy;Next&shy;Hook&shy;Ex</code>,
so there shouldn't be any hook-loss.
</p>
<p>
The customer was kind enough to include a copy of their program
with instructions on how to trigger the problem,
and stepping through the hook code quickly revealed the source
of the problem.
Maybe you can see it too.
Here's a stack trace when the end of the hook chain is reached:
</p>
<pre>
ChildEBP RetAddr
0011cdc4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011cdf8 768231eb user32!DispatchHookA+0x104 
0011ce38 76824260 user32!CallHookWithSEH+0x21 
0011ce6c 773e642e user32!__fnHkINLPMSG+0x71 
0011ceb0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011ceb4 76844787 user32!NtUserCallNextHookEx+0xc 
0011ced8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011cf14 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011cf48 768231eb user32!DispatchHookA+0x104 
0011cf88 76824260 user32!CallHookWithSEH+0x21 
0011cfbc 773e642e user32!__fnHkINLPMSG+0x71 
0011d000 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d004 76844787 user32!NtUserCallNextHookEx+0xc 
0011d028 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d064 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d098 768231eb user32!DispatchHookA+0x104 
0011d0d8 76824260 user32!CallHookWithSEH+0x21 
0011d10c 773e642e user32!__fnHkINLPMSG+0x71 
0011d150 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d154 76844787 user32!NtUserCallNextHookEx+0xc 
0011d178 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d1b4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d1e8 768231eb user32!DispatchHookA+0x104 
0011d228 76824260 user32!CallHookWithSEH+0x21 
0011d25c 773e642e user32!__fnHkINLPMSG+0x71 
0011d2a0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d2a4 76844787 user32!NtUserCallNextHookEx+0xc 
0011d2c8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d304 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d338 768231eb user32!DispatchHookA+0x104 
0011d378 76824260 user32!CallHookWithSEH+0x21 
0011d3ac 773e642e user32!__fnHkINLPMSG+0x71 
0011d3f0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d3f4 76844787 user32!NtUserCallNextHookEx+0xc 
0011d418 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d454 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d488 768231eb user32!DispatchHookA+0x104 
0011d4c8 76824260 user32!CallHookWithSEH+0x21 
0011d4fc 773e642e user32!__fnHkINLPMSG+0x71 
0011d540 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d544 76844787 user32!NtUserCallNextHookEx+0xc 
0011d568 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d5a4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d5d8 768231eb user32!DispatchHookA+0x104 
0011d618 76824260 user32!CallHookWithSEH+0x21 
0011d64c 773e642e user32!__fnHkINLPMSG+0x71 
0011d690 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d694 76844787 user32!NtUserCallNextHookEx+0xc 
0011d6b8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d6f4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d728 768231eb user32!DispatchHookA+0x104 
0011d768 76824260 user32!CallHookWithSEH+0x21 
0011d79c 773e642e user32!__fnHkINLPMSG+0x71 
0011d7e0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d7e4 76844787 user32!NtUserCallNextHookEx+0xc 
0011d808 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d844 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d878 768231eb user32!DispatchHookA+0x104 
0011d8b8 76824260 user32!CallHookWithSEH+0x21 
0011d8ec 773e642e user32!__fnHkINLPMSG+0x71 
0011d930 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011d934 76844787 user32!NtUserCallNextHookEx+0xc 
0011d958 6fbdb1e0 user32!CallNextHookEx+0x71 
0011d994 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011d9c8 768231eb user32!DispatchHookA+0x104 
0011da08 76824260 user32!CallHookWithSEH+0x21 
0011da3c 773e642e user32!__fnHkINLPMSG+0x71 
0011da80 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011da84 76844787 user32!NtUserCallNextHookEx+0xc 
0011daa8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011dae4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011db18 768231eb user32!DispatchHookA+0x104 
0011db58 76824260 user32!CallHookWithSEH+0x21 
0011db8c 773e642e user32!__fnHkINLPMSG+0x71 
0011dbd0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011dbd4 76844787 user32!NtUserCallNextHookEx+0xc 
0011dbf8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011dc34 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011dc68 768231eb user32!DispatchHookA+0x104 
0011dca8 76824260 user32!CallHookWithSEH+0x21 
0011dcdc 773e642e user32!__fnHkINLPMSG+0x71 
0011dd20 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011dd24 76844787 user32!NtUserCallNextHookEx+0xc 
0011dd48 6fbdb1e0 user32!CallNextHookEx+0x71 
0011dd84 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011ddb8 768231eb user32!DispatchHookA+0x104 
0011ddf8 76824260 user32!CallHookWithSEH+0x21 
0011de2c 773e642e user32!__fnHkINLPMSG+0x71 
0011de70 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011de74 76844787 user32!NtUserCallNextHookEx+0xc 
0011de98 6fbdb1e0 user32!CallNextHookEx+0x71 
0011ded4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011df08 768231eb user32!DispatchHookA+0x104 
0011df48 76824260 user32!CallHookWithSEH+0x21 
0011df7c 773e642e user32!__fnHkINLPMSG+0x71 
0011dfc0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011dfc4 76844787 user32!NtUserCallNextHookEx+0xc 
0011dfe8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e024 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e058 768231eb user32!DispatchHookA+0x104 
0011e098 76824260 user32!CallHookWithSEH+0x21 
0011e0cc 773e642e user32!__fnHkINLPMSG+0x71 
0011e110 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011e114 76844787 user32!NtUserCallNextHookEx+0xc 
0011e138 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e174 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e1a8 768231eb user32!DispatchHookA+0x104 
0011e1e8 76824260 user32!CallHookWithSEH+0x21 
0011e21c 773e642e user32!__fnHkINLPMSG+0x71 
0011e260 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011e264 76844787 user32!NtUserCallNextHookEx+0xc 
0011e288 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e2c4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e2f8 768231eb user32!DispatchHookA+0x104 
0011e338 76824260 user32!CallHookWithSEH+0x21 
0011e36c 773e642e user32!__fnHkINLPMSG+0x71 
0011e3b0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011e3b4 76844787 user32!NtUserCallNextHookEx+0xc 
0011e3d8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e414 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e448 768231eb user32!DispatchHookA+0x104 
0011e488 76824260 user32!CallHookWithSEH+0x21 
0011e4bc 773e642e user32!__fnHkINLPMSG+0x71 
0011e500 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011e504 76844787 user32!NtUserCallNextHookEx+0xc 
0011e528 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e564 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e598 768231eb user32!DispatchHookA+0x104 
0011e5d8 76824260 user32!CallHookWithSEH+0x21 
0011e60c 773e642e user32!__fnHkINLPMSG+0x71 
0011e650 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011e654 76844787 user32!NtUserCallNextHookEx+0xc 
0011e678 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e6b4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e6e8 768231eb user32!DispatchHookA+0x104 
0011e728 76824260 user32!CallHookWithSEH+0x21 
0011e75c 773e642e user32!__fnHkINLPMSG+0x71 
0011e7a0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011e7a4 76844787 user32!NtUserCallNextHookEx+0xc 
0011e7c8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e804 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e838 768231eb user32!DispatchHookA+0x104 
0011e878 76824260 user32!CallHookWithSEH+0x21 
0011e8ac 773e642e user32!__fnHkINLPMSG+0x71 
0011e8f0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011e8f4 76844787 user32!NtUserCallNextHookEx+0xc 
0011e918 6fbdb1e0 user32!CallNextHookEx+0x71 
0011e954 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011e988 768231eb user32!DispatchHookA+0x104 
0011e9c8 76824260 user32!CallHookWithSEH+0x21 
0011e9fc 773e642e user32!__fnHkINLPMSG+0x71 
0011ea40 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011ea44 76844787 user32!NtUserCallNextHookEx+0xc 
0011ea68 6fbdb1e0 user32!CallNextHookEx+0x71 
0011eaa4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011ead8 768231eb user32!DispatchHookA+0x104 
0011eb18 76824260 user32!CallHookWithSEH+0x21 
0011eb4c 773e642e user32!__fnHkINLPMSG+0x71 
0011eb90 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011eb94 76844787 user32!NtUserCallNextHookEx+0xc 
0011ebb8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011ebf4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011ec28 768231eb user32!DispatchHookA+0x104 
0011ec68 76824260 user32!CallHookWithSEH+0x21 
0011ec9c 773e642e user32!__fnHkINLPMSG+0x71 
0011ece0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011ece4 76844787 user32!NtUserCallNextHookEx+0xc 
0011ed08 6fbdb1e0 user32!CallNextHookEx+0x71 
0011ed44 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011ed78 768231eb user32!DispatchHookA+0x104 
0011edb8 76824260 user32!CallHookWithSEH+0x21 
0011edec 773e642e user32!__fnHkINLPMSG+0x71 
0011ee30 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011ee34 76844787 user32!NtUserCallNextHookEx+0xc 
0011ee58 6fbdb1e0 user32!CallNextHookEx+0x71 
0011ee94 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011eec8 768231eb user32!DispatchHookA+0x104 
0011ef08 76824260 user32!CallHookWithSEH+0x21 
0011ef3c 773e642e user32!__fnHkINLPMSG+0x71 
0011ef80 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011ef84 76844787 user32!NtUserCallNextHookEx+0xc 
0011efa8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011efe4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f018 768231eb user32!DispatchHookA+0x104 
0011f058 76824260 user32!CallHookWithSEH+0x21 
0011f08c 773e642e user32!__fnHkINLPMSG+0x71 
0011f0d0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011f0d4 76844787 user32!NtUserCallNextHookEx+0xc 
0011f0f8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011f134 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f168 768231eb user32!DispatchHookA+0x104 
0011f1a8 76824260 user32!CallHookWithSEH+0x21 
0011f1dc 773e642e user32!__fnHkINLPMSG+0x71 
0011f220 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011f224 76844787 user32!NtUserCallNextHookEx+0xc 
0011f248 6fbdb1e0 user32!CallNextHookEx+0x71 
0011f284 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f2b8 768231eb user32!DispatchHookA+0x104 
0011f2f8 76824260 user32!CallHookWithSEH+0x21 
0011f32c 773e642e user32!__fnHkINLPMSG+0x71 
0011f370 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011f374 76844787 user32!NtUserCallNextHookEx+0xc 
0011f398 6fbdb1e0 user32!CallNextHookEx+0x71 
0011f3d4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f408 768231eb user32!DispatchHookA+0x104 
0011f448 76824260 user32!CallHookWithSEH+0x21 
0011f47c 773e642e user32!__fnHkINLPMSG+0x71 
0011f4c0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011f4c4 76844787 user32!NtUserCallNextHookEx+0xc 
0011f4e8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011f524 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f558 768231eb user32!DispatchHookA+0x104 
0011f598 76824260 user32!CallHookWithSEH+0x21 
0011f5cc 773e642e user32!__fnHkINLPMSG+0x71 
0011f610 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011f614 76844787 user32!NtUserCallNextHookEx+0xc 
0011f638 6fbdb1e0 user32!CallNextHookEx+0x71 
0011f674 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f6a8 768231eb user32!DispatchHookA+0x104 
0011f6e8 76824260 user32!CallHookWithSEH+0x21 
0011f71c 773e642e user32!__fnHkINLPMSG+0x71 
0011f760 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011f764 76844787 user32!NtUserCallNextHookEx+0xc 
0011f788 6fbdb1e0 user32!CallNextHookEx+0x71 
0011f7c4 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f7f8 768231eb user32!DispatchHookA+0x104 
0011f838 76824260 user32!CallHookWithSEH+0x21 
0011f86c 773e642e user32!__fnHkINLPMSG+0x71 
0011f8b0 768447aa ntdll!KiUserCallbackDispatcher+0x2e 
0011f8b4 76844787 user32!NtUserCallNextHookEx+0xc 
0011f8d8 6fbdb1e0 user32!CallNextHookEx+0x71 
0011f914 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011f948 768231eb user32!DispatchHookA+0x104 
0011f988 76824260 user32!CallHookWithSEH+0x21 
0011f9bc 773e642e user32!__fnHkINLPMSG+0x71 
0011f9d0 00030000 ntdll!KiUserCallbackDispatcher+0x2e 
0011fa28 6fbdb1e0 0x30000
0011fa64 16846e6e contoso!ContosoWindowEventHook+0x11b 
0011fa98 768231eb user32!DispatchHookA+0x104 
0011fad8 76824260 user32!CallHookWithSEH+0x21 
0011fb0c 773e642e user32!__fnHkINLPMSG+0x71 
0011fb20 00030000 ntdll!KiUserCallbackDispatcher+0x2e 
0011fb7c 768292a9 0x30000
0011fba8 6b2ce010 user32!PeekMessageW+0xfb 
</pre>
<p>
As you can see,
a <i>third</i> component in their application
installed at least <i>thirty-five hooks</i>.
After the thirty-fifth hook, the window manager stepped in and said,
"<a HREF="http://www.huffingtonpost.com/social/Wanderland/drunkest-countries-in-the-world_n_824757_78145314.html"
>That's it, I'm cutting you off</a>."
</p>
<p>
Now, the limit isn't actually thirty-five.
The window manager keeps dispatching hooks until the kernel stack
starts running low, and then it gives up.
This happens with a lot of
<a HREF="http://blogs.msdn.com/b/alejacma/archive/2009/08/11/controls-won-t-get-resized-once-the-nesting-hierarchy-of-windows-exceeds-a-certain-depth-x64.aspx">
recursive algorithms</a>:
The window manager plays the game for a while,
but when it looks like you're about to bluescreen,
it stops short and says,
"Okay, I'm not going to do that any more."
</p>
<p>
The developers now got to take their problem to the
developer responsible for the Contoso component,
and figure out why it's installing so many hooks.
Maybe that component could try to consolidate identical hooks.
Or maybe it's a leak.
They never did report back (not that I was expecting them to).
</p>
<p>
<b>Bonus chatter</b>:
Why is hook dispatch done recursively?
Shouldn't it be done iteratively?
</p>
<p>
Remember that windows hooks came from 16-bit Windows, where
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2006/08/09/693280.aspx">
economy was paramount</a>.
And the existing <code>Call&shy;Next&shy;Hook</code> pattern was
preserved, though it changed to
<code>Call&shy;Next&shy;Hook&shy;Ex</code>,
where you pass the hook handle directly instead of its address.
One advantage of the <code>Call&shy;Next&shy;Hook&shy;Ex</code> model
over an iterative model is that
explicitly forwarding to the previous hook lets you do work on the back end.
I.e., you can forward the call down the chain, and then
do something when control returns.
This is the sort of thing you probably use a lot when you subclass
a window or override a method in a derived class and call the base
class from your override.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-989903">
				<div id="div-comment-989903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-989903">
			June 7, 2012 at 7:05 am</a>		</div>

		<p>The limit is lower in 64-bit Windows, apparently because those in charge didn&#39;t see fit to increase the kernel stack space when the size of a pointer doubled. &nbsp;In some cases, the limit can become depressingly low.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-989913">
				<div id="div-comment-989913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-989913">
			June 7, 2012 at 7:18 am</a>		</div>

		<p>My buest guess that Contoso turd was installing the hook again based on some event.</p>
<p>This reminds Microsoft again to reduce inter-process coupling in Windows, even at a cost of some crapware not working anymore. Enough is enough already.</p>
<div class="post">[<i>The thread was installing a hook on itself, so your crackdown on inter-process hooks has no effect here. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-989943">
				<div id="div-comment-989943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lockwood</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-989943">
			June 7, 2012 at 7:54 am</a>		</div>

		<p>I&#39;m afraid to say I want to put my pedant hat on.</p>
<p>I like to avoid the Nitpicker&#39;s Corner, but&#8230;</p>
<p>&quot;The developers now got to take their problem to the developer responsible for the Contoso component&quot;</p>
<p>I needed to reread the start of that a couple of times to make sure I hadn&#39;t managed to skip a word, or worse do that thing where you skip to the line below and read on slightly confused but pretty much making sense. (ie this could have a line skip in it as I enter it to say &quot;I needed to reread slightly confused but &#8230;&quot;)</p>
<p>The developers have now got to?</p>
<p>The developers now have got to?</p>
<p>Not 100% sure which we want, but it seems to want a &quot;have&quot;</p>
<div class="post">[<i>&quot;get to&quot; = &quot;have the opportunity to&quot;. &quot;The developers now had the opportunity to take their problem to&#8230;&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-989953">
				<div id="div-comment-989953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Martin Bonner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-989953">
			June 7, 2012 at 8:02 am</a>		</div>

		<p>@Lockwood: &nbsp;I think Raymond probably needed &quot;The developers then got to &#8230;&quot; (being the past tense of &quot;The developers now got to &#8230;&quot;).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-989973">
				<div id="div-comment-989973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bob</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-989973">
			June 7, 2012 at 8:12 am</a>		</div>

		<p>&quot;didn&#39;t see fit to increase the kernel stack space when the size of a pointer doubled&quot;</p>
<p>The size of a kernel stack doubled in 64-bit windows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-989983">
				<div id="div-comment-989983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-989983">
			June 7, 2012 at 8:42 am</a>		</div>

		<p>Wow my window nest stack is already 16 and threatening to get deeper. (Nested child controls. The apparent stack is more like 3).</p>
<p>Modularization in .NET tends to create lots of useless child windows that just contain other children.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990003">
				<div id="div-comment-990003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/analisnudesette_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>analisnudesette@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990003">
			June 7, 2012 at 8:49 am</a>		</div>

		<p>I think I&#39;d rather the process crashed than have window messages randomly undelivered in these situations.</p>
<p>The non-delivery can leave the process in an undefined state, so crashing the process there &amp; then is safer and makes bugs easier to detect and fix.</p>
<p>Window messages are like function calls. Skipping a function call because the stack is low would be unthinkable.</p>
<p>I suspect this also explains why accidentally making a message handler infinitely recursive will blow the stack and crash your process in some situations (no hooks installed) but result in weird behaviour, and no crash, in others (a hook happens to be installed).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-990033">
				<div id="div-comment-990033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lockwood</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990033">
			June 7, 2012 at 9:20 am</a>		</div>

		<p>@Martin, Raymond</p>
<p>That also makes sense, with the &quot;then got to&quot;. Surely the present tense would be &quot;now get to&quot;?</p>
<p>At least I was paying attention to the article to notice such a fine detail!</p>
<div class="post">[<i>&quot;then got to&quot; is probably better. I sometimes get into this weird narrative state where I use present-tense adverbs with past-tense verbs&#8230; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990053">
				<div id="div-comment-990053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990053">
			June 7, 2012 at 12:48 pm</a>		</div>

		<p>I think Leo is right. After all, when you call a normal function too recursively, your process goes down with an ‘Out of stack space’ error, so I think the same should happen here.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-990063">
				<div id="div-comment-990063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990063">
			June 7, 2012 at 1:42 pm</a>		</div>

		<p>In principal I agree with the guys saying you should just exhaust the stack and die, but in reality these hooks can be installed in other programs so from the perspective of the user it&#39;s going to be explorer.exe that crashes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990073">
				<div id="div-comment-990073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990073">
			June 7, 2012 at 1:43 pm</a>		</div>

		<p>&quot;your process goes down with an ‘Out of stack space’ error, so I think the same should happen here.&quot;</p>
<p>Except it won&#39;t be &quot;your process&quot;, it would be a blue screen of death because the kernel would blow its stack &#8211; right&#8230;? &nbsp;If so, what do you propose if not a BSOD?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-990083">
				<div id="div-comment-990083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990083">
			June 7, 2012 at 1:53 pm</a>		</div>

		<p>@JamesJohnston:</p>
<p>Who was talking about kernel mode? So far, we&#39;re in the userland.</p>
<div class="post">[<i>Um, &quot;The window manager keeps dispatching hooks until the kernel stack starts running low, and then it gives up.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990103">
				<div id="div-comment-990103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990103">
			June 7, 2012 at 2:42 pm</a>		</div>

		<p>Probably some lousy DRM library which tries to allocate all available hooks to prevent debugging tools.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-989963">
				<div id="div-comment-989963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-989963">
			June 7, 2012 at 8:09 am</a>		</div>

		<p>Why are the limits being *lowered* for hooks, nested windows, menus? &nbsp;Why is the stack space not increased slightly in this age of 8 GB RAM computers?</p>
<p>At this rate, there will eventually be a limit of 5 and everything will break. &nbsp;(I exaggerate, but only slightly.)</p>
<p>As an application developer, what limit should I target? &nbsp;How can I even really target a limit, if it&#39;s a moving target going *downwards*?</p>
<p>(Yes, I realize that if you are nesting 50 windows, &quot;you&#39;re doing it wrong&quot; &#8211; but it&#39;s not unreasonable to think that a decently-architected program could go several levels deep &#8211; and the question is, how much is too much? &nbsp;How much will too much be in 10 years?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990113">
				<div id="div-comment-990113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990113">
			June 7, 2012 at 3:16 pm</a>		</div>

		<p>The real problem is doing recursion at all in kernel-mode. Kernel-mode stacks are NON_PAGED, and when you run out your system dies.</p>
<p>If you&#39;re writing kernel-mode code (yes, I&#39;m looking at you, Win32k.sys) and you decide to solve your problem using recursion, then You&#39;re Doing It Wrong (TM).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-990123">
				<div id="div-comment-990123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990123">
			June 7, 2012 at 3:40 pm</a>		</div>

		<p>&quot;Except it won&#39;t be &quot;your process&quot;, it would be a blue screen of death because the kernel would blow its stack &#8211; right&#8230;? &nbsp;If so, what do you propose if not a BSOD?&quot;</p>
<p>I think the commenters were proposing the idea of raising an user-mode exception.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hardon even thread-even depth-1" id="comment-990133">
				<div id="div-comment-990133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/gdalsnes' rel='external nofollow' class='url'>gdalsnes</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990133">
			June 7, 2012 at 4:38 pm</a>		</div>

		<p>Callbacks from kernel mode are just evil. Now that all pc&#39;s have several cpu cores, maybe it&#39;s time to dust of the pre NT4 CSRSS Win32 design. Wine also runs entirely in user mode and seems to get away with it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-990143">
				<div id="div-comment-990143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990143">
			June 7, 2012 at 4:46 pm</a>		</div>

		<p>arghhhhhhhhhhh: Especially with the introduction of per-session CSRSS with WinFrame.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990193">
				<div id="div-comment-990193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990193">
			June 8, 2012 at 5:37 am</a>		</div>

		<p>Could the existing API pattern be implemented in a tail-recursive way? Or could a new iterative model be added? We&#39;re no longer stuck with the &quot;each process forwards the message to the next one&quot; model for clipboard viewers.</p>
<div class="post">[<i>See final paragraph. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-990203">
				<div id="div-comment-990203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990203">
			June 8, 2012 at 7:14 am</a>		</div>

		<p>[Um, &quot;The window manager keeps dispatching hooks until the kernel stack starts running low, and then it gives up.&quot; -Raymond]</p>
<p>What I see in this post is user mode stack.</p>
<div class="post">[<i>When you&#39;re debugging the problem, you typically get to see only the user stack, so that&#39;s what I showed. It should be clear that if the user-mode stack is this deely nested in kernel callbacks, the kernel stack must be deeply nested with the callback invokers. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990213">
				<div id="div-comment-990213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@arghhhhhhhhh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990213">
			June 8, 2012 at 7:47 am</a>		</div>

		<blockquote><p>
  &gt; Wine also runs entirely in user mode and seems to get away with it.
</p></blockquote>
<p>Given it&#39;s (in)compatibility record, it doesn&#39;t get away with it well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-990223">
				<div id="div-comment-990223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990223">
			June 8, 2012 at 7:59 am</a>		</div>

		<p>&quot;Now that all pc&#39;s have several cpu cores, maybe it&#39;s time to dust of the pre NT4 CSRSS Win32 design.&quot;</p>
<p>Very good point. &nbsp;Wikipedia for CSRSS seems to indicate that GDI and window handling is done in win32k.sys, and that they were moved there for Windows NT 4.0 for performance reasons. &nbsp;Why they can&#39;t be moved back to user mode is beyond me&#8230; &nbsp;It&#39;s 2012 and I doubt it has to be done for performance reasons any more. &nbsp;Kernel mode is a dangerous place that has a higher risk of causing a system-wide crash or security failure; it seems like you&#39;d want to keep what&#39;s in there to a minimum.</p>
<div class="post">[<i>Presumably the change was made to improve performance by N%. Reversing it would decrease performance by N%. &quot;Hey, why did performance drop by N%?&quot; &quot;Sorry, I thought you weren&#39;t using that performance any more.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990273">
				<div id="div-comment-990273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990273">
			June 8, 2012 at 11:21 am</a>		</div>

		<blockquote><p>
  Given it&#39;s (in)compatibility record, it doesn&#39;t get away with it well.
</p></blockquote>
<p>We&#39;re talking about performance here. Except when Wine is copying bitmaps between GDI+ and GDI for programs that switch back and forth a lot it gets better performance than Windows. It is thought that this is mainly due to the performance advantage of ext3 over NTFS rather than Wine&#39;s architecture though.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-990303">
				<div id="div-comment-990303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990303">
			June 8, 2012 at 2:02 pm</a>		</div>

		<p>[When you&#39;re debugging the problem, you typically get to see only the user stack, so that&#39;s what I showed. It should be clear that if the user-mode stack is this deely nested in kernel callbacks, the kernel stack must be deeply nested with the callback invokers. -Raymond]</p>
<p>I don&#39;t think the whole chain of calls ever leaves the user mode. It&#39;s not possible to interleave usermode and kernel mode stacks. You&#39;re either in user mode, or entered the kernel until you return. You can&#39;t have part of your callstack in kernel mode and then in usermode again.</p>
<div class="post">[<i>You can see control leave user mode at NtUserCallNextHookEx and then return to user mode at KiUserCallbackDispatcher. <a href="http://blog.paulbetts.org/index.php/2010/07/20/the-case-of-the-disappearing-onload-exception-user-mode-callback-exceptions-in-x64/" rel="nofollow">Here&#39;s another example of a stack bouncing between kernel mode and user mode</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990313">
				<div id="div-comment-990313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/arcangelpip_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>arcangelpip@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990313">
			June 8, 2012 at 2:27 pm</a>		</div>

		<p>@alegr1</p>
<p>The answer to your dilema is in that call stack. KiUserCallbackDispatcher. This is an NTDLL kernel mode to usermode callback function. So this is transitioning between kernel mode and usermode. The transition to kernel mode is in NtCallNextHookEx, and then kernel mode switches back to user mode and calls KiUserCallbackDispatcher.</p>
<p>So yes, this does leave user mode. Anyway, since the Window Manager has been kernel mode since NT4, and Windows Hooks are obviously handled by the Window Manager, how would you suggest this occurs without the transition to kernel mode?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-990323">
				<div id="div-comment-990323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990323">
			June 8, 2012 at 2:29 pm</a>		</div>

		<p>@alegr1 &quot;I don&#39;t think the whole chain of calls ever leaves the user mode&quot;:</p>
<p>&quot;ntdll!KiUserCallbackDispatcher&quot;: This is a callback from win32k. The kernel-mode stack is waiting for a NtCallbackReturn to allow the kernel-mode stack to unwind.</p>
<p>As a general rule, don&#39;t try and criticize Raymond&#39;s lack of understanding of Windows. There aren&#39;t many people that understand it better than he. If you disagree with you, 98% of the time, it&#39;s because you&#39;re wrong.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990343">
				<div id="div-comment-990343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990343">
			June 8, 2012 at 4:40 pm</a>		</div>

		<p>Wait what wow that&#39;s a kernel callback chain on the stack. Time to dust-off the native call loader and see if it&#39;s possible to bluescreen the kernel by overrunning its stack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-990373">
				<div id="div-comment-990373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990373">
			June 8, 2012 at 6:56 pm</a>		</div>

		<p>That&#39;s just great. Let&#39;s nest some 30 hooks, and then issue random IOs and IOCTLs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990383">
				<div id="div-comment-990383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990383">
			June 8, 2012 at 8:25 pm</a>		</div>

		<p>@alegr1: Don&#39;t forget IO interrupts. I&#39;ve got a device driver in archive that wants &gt;4k for its bottom half handler.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-yuhong-bao odd alt thread-odd thread-alt depth-1" id="comment-990443">
				<div id="div-comment-990443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Yuhong+Bao' rel='external nofollow' class='url'>Yuhong Bao</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990443">
			June 9, 2012 at 10:56 pm</a>		</div>

		<p>@Joshua: AFAIK each time a user-mode callback is done, a new kernel stack is created (on Vista and later) to prevent this. Of course, there is a limit to how many such stacks can be created, and when you hit this limit, win32k get a failure code which is then passed back to the app.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990493">
				<div id="div-comment-990493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ender</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990493">
			June 11, 2012 at 12:51 am</a>		</div>

		<p>@Joshua: a driver for certain CPU maker&#39;s integrated graphics? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-990553">
				<div id="div-comment-990553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990553">
			June 11, 2012 at 7:22 am</a>		</div>

		<p>&nbsp; &nbsp;&quot;Presumably the change was made to improve performance by N%. Reversing it would decrease performance by N%. &quot;Hey, why did performance drop by N%?&quot; &quot;Sorry, I thought you weren&#39;t using that performance any more.&quot; -Raymond&quot;</p>
<p>Actually, looking in MSDN, hasn&#39;t something like that already happened with Vista? &nbsp;<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh437350(v=vs.85).aspx" target="_new" rel="nofollow">msdn.microsoft.com/&#8230;/hh437350(v=vs.85).aspx</a> &#8211; it looks like the windowing system might be moving in the direction of user mode anyway.</p>
<div class="post">[<i>Um, DirectComposition is not the window manager. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-990583">
				<div id="div-comment-990583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/johnstonj_4000_inn_2D00_soft.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>johnstonj@inn-soft.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-990583">
			June 11, 2012 at 8:00 am</a>		</div>

		<p>&quot;DirectComposition is not the window manager.&quot;</p>
<p>Right, but it interacts very closely with it and I&#39;d imagine it is very performance-critical &#8211; yet it&#39;s in user mode. &nbsp;If they were able to &quot;get away&quot; with putting something critical like that in user mode, they could probably &quot;get away&quot; with moving the entire window manager out of win32k.sys.</p>
<div class="post">[<i>The internal performance of DirectComposition is critical, but the performance of the communication channel between DirectComposition and the application is not as critical. And moving the window manager into kernel mode is all about reducing the communication latency. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-991033">
				<div id="div-comment-991033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120607-00/?p=7433#comment-991033">
			June 12, 2012 at 4:10 pm</a>		</div>

		<p>&quot;Reversing it would decrease performance by N%.&quot;</p>
<p>And decrease BSODs by N%.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

