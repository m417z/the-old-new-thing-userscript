<html>
<head>
<title>You still need the "safe" functions even if you check string lengths ahead of time</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>You still need the &quot;safe&quot; functions even if you check string lengths ahead of time</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 28, 2012 / year-entry #149</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>69</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Commenter POKE53280,0 claims, "If one validates parameters before using string functions (which quality programmers should do), the 'safe' functions have no reason to exist." Consider the following function: int SomeFunction(const char *s) { char buffer[256]; if (strlen(s) &ge; 256) return ERR; strcpy(buffer, s); ... } What could possibly go wrong? You check the length of...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Commenter
POKE53280,0
claims,
"If one validates parameters before using string functions
(which quality programmers should do),
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2010/12/08/10101773.aspx#10102139">
the 'safe' functions have no reason to exist</a>."
</p>
<p>
Consider the following function:
</p>
<pre>
int SomeFunction(const char *s)
{
  char buffer[256];
  if (strlen(s) &ge; 256) return ERR;
  strcpy(buffer, s);
  ...
}
</pre>
<p>
What could possibly go wrong?
You check the length of the string, and if it doesn't fit
in the buffer, then you reject it.
Therefore, you claim, the <code>strcpy</code> is safe.
</p>
<p>
What could possibly go wrong is that the length of the string
can change between the time you check it and the time you use it.
</p>
<pre>
char attack[512] = "special string designed to trigger a "
                   "buffer overflow and attack your machine. [...]";

void Thread1()
{
 char c = attack[256];
 while (true) {
  attack[256] ^= c;
 }
}

void Thread2()
{
 while (true) {
  SomeFunction(attack);
 }
}
</pre>
<p>
The first thread changes the length of the string rapidly between
255 and 511, between a string that passes validation and a string that
doesn't, and more specifically between a string that passes validation
and a string that, if it snuck through validation, would pwn the machine.
</p>
<p>
The second thread keeps handing this string to
<code>Some&shy;Function</code>.
Eventually, the following race condition will be hit:
</p>
<ul>
<li>Thread&nbsp;1 changes the length to 255.
<li>Thread&nbsp;2 checks the length and when it reaches attack[256],
    it reads zero and concludes that the string length is
    less than 256.</p>
<li>Thread&nbsp;1 changes the length to 511.
<li>Thread&nbsp;2 copies the string and when it reaches attack[256],
    it reads nonzero and keeps copying, thereby overflowing its buffer.
</ul>
<p>
Oops, you just fell victim to the
Time-of-check-to-time-of-use attack
(commonly abbreviated TOCTTOU).
</p>
<p>
Now, the code above as-written is not technically a vulnerability
because
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2010/02/16/10101773.aspx">
you haven't crossed a security boundary</a>.
The attack code and the vulnerable code are running under the same
security context.
To make this a true vulnerability, you need to have the attack code
running in a lower security context from the vulnerable code.
For example, if the threads were running user-mode code and
<code>Some&shy;Function</code> is a kernel-mode function,
then you have a real vulnerability.
Of course, if <code>Some&shy;Function</code> were at the boundary
between user-mode and kernel-mode, then it has other things
it needs to do, like verify that the memory is in fact readable
by the process.
</p>
<p>
A more interesting case where you cross a security boundary
is if the two threads are running code driven from an untrusted
source; for example, they might be threads in a script interpreter,
and the toggling of <code>attack[256]</code> is being done by
a function on a Web page.
</p>
<pre>
// this code is in some imaginary scripting language

var attack = new string("...");
procedure Thread1()
{
 var c = attack[256];
 while (true) attack[256] ^= c;
}

handler OnClick()
{
 new backgroundTask(Thread1);
 while (true) foo(attack);
}
</pre>
<p>
When the user clicks on the button, the script interpret
creates a background thread and starts toggling the
length of the string under the instructions of the script.
Meanwhile, the main thread calls <code>foo</code>
repeatedly.
And suppose the interpreter's implementation of <code>foo</code>
goes like this:
</p>
<pre>
void interpret_foo(const function_args& args)
{
 if (args.GetLength() != 1) wna("foo");
 if (args.GetArgType(0) != V_STRING) wta("foo", 0, V_STRING);
 char *s = args.PinArgString(0);
 SomeFunction(s);
 args.ReleasePin(0);
}
</pre>
<p>
The script interpreter has kindly converted the script
code into the equivalent native code, and now you have a problem.
Assuming the user doesn't get impatient and click "Stop script",
the script will eventually hit the race condition and cause
a buffer overflow in <code>Some&shy;Function</code>.
</p>
<p>
And then you get to scramble a security hotfix.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (69)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-994343">
				<div id="div-comment-994343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994343">
			June 28, 2012 at 7:09 am</a>		</div>

		<p>CPython&#39;s Global Interpreter Lock to the rescue!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994353">
				<div id="div-comment-994353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skyborne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994353">
			June 28, 2012 at 7:20 am</a>		</div>

		<p>My knowledge of threads in C is a bit fuzzy. &nbsp;Can you mount the same attack against <code>strlcpy</code> by a second thread toggling the length value between allocation and strlcpy call, or is the length value guaranteed to stay in a register (assuming non-volatile) in the strlcpy()ing thread?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994363">
				<div id="div-comment-994363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Philipp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994363">
			June 28, 2012 at 7:22 am</a>		</div>

		<p>@Adam Rosenfield No, the GIL wouldn&#39;t help at all. The GIL would only ensure that the call of strlen(s) would return the correct result at the time you call strlen (assuming strlen to be a native function). After the call to strlen, the GIL could still be acquired by the malicious thread before strcpy. What would help is a serialization of the program (i.e. disable multi-threading). That&#39;s obviously not going to happen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994373">
				<div id="div-comment-994373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tobi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994373">
			June 28, 2012 at 7:29 am</a>		</div>

		<p>Toggling the char using xor made you smile, didn&#39;t it? ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994383">
				<div id="div-comment-994383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994383">
			June 28, 2012 at 7:35 am</a>		</div>

		<p>@Philipp: If interpret_foo() holds the GIL, then SomeFunction() runs without interruption since the attacker&#39;s thread cannot run without the GIL. &nbsp;If SomeFunction() were itself implemented in script instead of natively, then yes, it could lose the GIL in between strlen() and strcpy(), but why the heck would you be calling strcpy() from a scripting language?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994393">
				<div id="div-comment-994393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994393">
			June 28, 2012 at 7:36 am</a>		</div>

		<p>Huh?</p>
<p>If your attacked has already injected a thread in your process that can modify memory during a call in another thread of your process, they already own you.</p>
<p>There are plenty of reasons it&#39;s foolish to not take advantage of pre-existing secure APIs, but I just don&#39;t see how this is one of them.</p>
<div class="post">[<i>The attacker didn&#39;t inject a thread. You invited them into your process! (Think multithreaded scripting language.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994403">
				<div id="div-comment-994403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994403">
			June 28, 2012 at 7:51 am</a>		</div>

		<p>But&#8230; If someone can execute code in your process already then how do they need a stack overflow to do anything useful. Surely they could just run the code directly. I understand that if the function is an operating system call or something that runs in kernel mode that it matters, but I can&#39;t see how this helps secure an ordinary process much. I&#39;m not arguing that it doesn&#39;t I just still don&#39;t understand the additional risk here.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994413">
				<div id="div-comment-994413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Avi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994413">
			June 28, 2012 at 8:04 am</a>		</div>

		<p>@John</p>
<p>Most embedded scripting languages expose a very limited set of what the machine can do. &nbsp;Think Lua scripting in WoW&#39;s client. &nbsp;If the script itself can trigger an overflow and inject its own machine code on the stack, that script can now do a lot more than Blizzard, or the player, ever intended.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994433">
				<div id="div-comment-994433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994433">
			June 28, 2012 at 8:20 am</a>		</div>

		<p>Congratulations. You just justified a nonsense practice with a chunk of code that violates the ground rules of programming.</p>
<p>Since there&#39;s obviously no sense in the matter (else you would have come up with a better example), I&#39;m turning that warning off and leaving it off.</p>
<div class="post">[<i>News flash: The bad guys don&#39;t care about the ground rules of programming. And even if the other code is not malicious, it may have violated the ground rules by mistake. You should take reasonable steps not to amplify a minor error into a security vulnerability. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994463">
				<div id="div-comment-994463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994463">
			June 28, 2012 at 8:23 am</a>		</div>

		<p>Can&#39;t the TOCTTOU issue still occur after the &quot;safe&quot; function checks the string, but before it does whatever string operation the caller requested?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994473">
				<div id="div-comment-994473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Avi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994473">
			June 28, 2012 at 8:28 am</a>		</div>

		<p>@Mmx:</p>
<p>Even such apps draw the line somewhere. &nbsp;You&#39;d be hard-pressed to create a keylogger in VBA, for example. &nbsp;Even a simple one using a hook. &nbsp;Or make an arbitrary network connection or start listening on a port for command&amp;control signals.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994493">
				<div id="div-comment-994493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994493">
			June 28, 2012 at 8:52 am</a>		</div>

		<p>@Joey</p>
<p>The issue isn&#39;t with the strlen. &nbsp;The version of the function written with the secure functions would look like</p>
<p>int SomeFunction(const char *s)</p>
<p>{</p>
<p>&nbsp;char buffer[256];</p>
<p>&nbsp;if (strcpy_s(buffer, _countof(buffer), s) != 0) { return ERR; }</p>
<p>&nbsp;&#8230;</p>
<p>}</p>
<p>(side note for nitpickers, deliberately calling the C version of the function instead of the C++ to illustrate the point).</p>
<p>The secure version ensures that buffer has a valid, null-terminated string that never writes out of buffers bounds. &nbsp;Raymond&#39;s sample version attempts to guarantee that but fails. &nbsp;</p>
<p>Now, given the docs for strcpy_s, I am honestly not sure if it really will behave correctly where the source string is being modified during the copy operation. &nbsp;If the source string is too large it will return ERANGE, but the destination buffer is not modified. &nbsp;This implies an initial size check, exactly like Raymond&#39;s original (vulnerable) example. &nbsp;The MSDN docs say nothing about what happens if the source string gets to large during the copy itself. &nbsp;I would hope that a sanity check in the copy would abort the copy if it is about to overflow the destination buffer, but I don&#39;t see that guarantee made in a multithread environment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994503">
				<div id="div-comment-994503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994503">
			June 28, 2012 at 9:15 am</a>		</div>

		<p>@SimonRev &quot;This implies an initial size check, exactly like Raymond&#39;s original (vulnerable) example.&quot; Yes, this is what I was thinking &#8212; how does letting the &quot;safe&quot; function pre-check the size for you accomplish anything in a multithreaded environment where the string could be changing mid-copy?</p>
<p>It may turn out that strcpy_s can handle this situation too, but as far as I can see, neither the docs nor Raymond have explicitly said this, which makes this multi-threaded TOCTTOU argument weak IMO (whatever other good reasons there are to use &quot;safe&quot; functions.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994533">
				<div id="div-comment-994533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Tait</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994533">
			June 28, 2012 at 9:45 am</a>		</div>

		<p>I disagree ur theory Raymond:</p>
<p>void func(char* s)</p>
<p>{</p>
<p>#pragma pack(push, 1)</p>
<pre><code>struct 

{

    char prepad;

    char buffer[256];

    char aftpad;

} locals;
</code></pre>
<p>#pragma pack(pop)</p>
<pre><code>memset(&amp;amp;locals, 0xcc, sizeof(locals));

StringCchCopyA(locals.buffer, sizeof(locals.buffer), s);

if(locals.prepad != 0xcc || locals.aftpad != 0xcc)

    MessageBoxA(NULL, &amp;quot;Oh noes!!&amp;quot;, &amp;quot;Oh noes! Stackoverflowed!&amp;quot;, MB_OK);
</code></pre>
<p>}</p>
<p>char attack[512];</p>
<p>DWORD __stdcall ThreadStart(PVOID pv)</p>
<p>{</p>
<pre><code>while(true) 

    attack[256] ^= &amp;#39;A&amp;#39;;
</code></pre>
<p>}</p>
<p>void main()</p>
<p>{</p>
<pre><code>memset(&amp;amp;attack, &amp;#39;A&amp;#39;, sizeof(attack));

CreateThread(NULL, 0, ThreadStart, NULL, 0, NULL);

while(true)

    func(&amp;amp;attack[0]);
</code></pre>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994553">
				<div id="div-comment-994553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994553">
			June 28, 2012 at 9:55 am</a>		</div>

		<p>It seems to me we&#39;re basically arguing: &quot;Hey instead of using a function that already does the checks I can just reimplement the functionality wherever I need it&quot;. Which I guess is true enough in most cases, but that applies to almost everything.</p>
<p>char buffer[256];</p>
<p>if (strlen(s) ≥ 256) return ERR;</p>
<p>strcpy(buffer, s);</p>
<p>vs.</p>
<p>char buffer[256];</p>
<p>if (strcpy_s(buffer, _countof(buffer), s) != 0) return ERR;</p>
<p>Seems more error prone, because it&#39;s easy to forget, longer and maybe even less efficient.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994563">
				<div id="div-comment-994563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">sean</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994563">
			June 28, 2012 at 9:56 am</a>		</div>

		<p>@matt</p>
<p>all bets are off if you pass the wrong size to StringCchCopy. &nbsp;</p>
<p>&quot;The size of the destination buffer, in characters. This value must equal the length of pszSrc plus 1 to account for the copied source string and the terminating null character.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994573">
				<div id="div-comment-994573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994573">
			June 28, 2012 at 9:58 am</a>		</div>

		<p>If the string passed into SomeFunction is being used, or even merely has the possibility to be used in multiple threads, then a wait lock on it should be taken immediately before reading, and released as soon as the reading is finished, and other threads should likewise respect that policy as well. &nbsp;Threads that take such locks have a dutiful responsibility to release them immediately. &nbsp;If you are wanting to code particicularly defensively, you could try a timed wait lock instead, and if after a certain amount of time the lock is still not available, then the function should simply fail, and return a status that indicates it did not succeed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994583">
				<div id="div-comment-994583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Tait</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994583">
			June 28, 2012 at 9:58 am</a>		</div>

		<p>I disagree with the premise of the article. The reason you should be using the safe functions is because people who try and do the checks themselves tend to get it wrong:</p>
<p>I&#39;ve seen lots of programmers smugly try &quot;if(strlen(X) &gt; COUNT(Y)) return ERR; else strcpy(X, Y)&quot;, only to end up with a one-byte heap/stack overwrite.</p>
<p>The idea that failing to use it is a TOCTOU bug isn&#39;t valid unless the function EXPECTS the parameter to be modified by another thread, for example when kernel-mode code is getting a pointer from user-mode. In this case, the bug isn&#39;t failing to call the safe function &#8211; it&#39;s failing to capture the buffer first.</p>
<p>Functions are entitled to expect their parameters to be thread-local. If you&#39;re building a multithreaded scripting language then you need to either capture the parameter first or somehow lock the object against writes before doing the checks.</p>
<p>The alternative is chaos, since if you have to expect other threads are attacking you then you suddenly need to mark all variables as volatile, to disable compiler pre-fetches, and do interlocked writes to make sure other threads don&#39;t get confused by your modifications. You COULD write your apps like that, but then you&#39;d go insane, and you&#39;d write pretty slow apps.</p>
<p>As a programmer you should use strcpy_s (actually StringCchCopy) because that way you can afford to suck at math every now and then. If you choose strcpy then you have to be sure that you don&#39;t suck at math, will never suck at math, and have never sucked at math before. Otherwise you&#39;re going to be dragged into work at 4am on a Sunday to patch your way of a hole when all your customers&#39; credit cards start disappearing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994593">
				<div id="div-comment-994593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Tait</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994593">
			June 28, 2012 at 9:59 am</a>		</div>

		<p>@voo.</p>
<p>True. But replace StringCchCopy with StringCbCopy and it still stack-overflows.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994603">
				<div id="div-comment-994603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994603">
			June 28, 2012 at 10:02 am</a>		</div>

		<p>Change two lines to</p>
<p>StringCbCopyA(locals.buffer, 3, s);</p>
<p>and</p>
<p>attack[3] ^= &#39;A&#39;;</p>
<p>and it still works (for the inevitable pedant who points out that I should have -1 in there somewhere).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994613">
				<div id="div-comment-994613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Tait</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994613">
			June 28, 2012 at 10:10 am</a>		</div>

		<p>Ugh. Stupid chars being signed in C. OK, StringCbCopy doesn&#39;t overflow, strcpy_s aborts given a wrong size, so replacing strcpy with strcpy_s turns an EoP into a DoS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994623">
				<div id="div-comment-994623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994623">
			June 28, 2012 at 10:15 am</a>		</div>

		<p>&quot;I disagree ur theory&quot; Matt Tait:</p>
<p>Your program that tries to prove wrongness is wrong: comparing any (signed) char with 0xcc is always false. The char you filled with 0xcc is implicitely casted to int, giving 0xffffffcc on the left and 0xcc on the right to be compared to equality.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994643">
				<div id="div-comment-994643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bah</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994643">
			June 28, 2012 at 10:25 am</a>		</div>

		<p>Didn&#39;t look at the cchDest thingy :/</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994663">
				<div id="div-comment-994663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/arcangelpip_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>arcangelpip@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994663">
			June 28, 2012 at 10:32 am</a>		</div>

		<p>Well, I&#39;ve looked into the implementation of strcpy_s and it can&#39;t overflow from the timed attack. What it does is to keep the length you passed in and for every character you copy, it subtracts one from that. Now if this gets to 0 and you haven&#39;t read a null character, then it will blank the entire string and return an error.</p>
<p>So strcpy_s isn&#39;t a moral equivalent of strlen followed by strcpy, it is more involved than that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994673">
				<div id="div-comment-994673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994673">
			June 28, 2012 at 10:44 am</a>		</div>

		<p>Aside from security/correctness, there&#39;s another reason that someone might want to use the &#39;secure&#39; version of strcpy() instead of checking the length then calling strcpy(): &nbsp;the safe version only makes a single pass over the original input (and may not even need to touch all of the input buffer).</p>
<p>So even if you&#39;re a programmer who never makes a mistake and injects bugs, you still might like to have it or something similar as an option.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994683">
				<div id="div-comment-994683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994683">
			June 28, 2012 at 10:48 am</a>		</div>

		<p>To those who think they&#39;re safe because their script language only supports a single thread: you&#39;re wrong. The guy who adds threads to your scripting language isn&#39;t going to audit all of your code to make sure that introducing threads doesn&#39;t create any race conditions. And if you rely on a third-party script engine, you might not even know that it ever became multithreaded!</p>
<p>Are you going to just do the right thing, or pretend you know better and allow every PDF to become a potential attack vector because somebody added threading to the JavaScript engine you embed in your PDF viewer?</p>
<p>But really, how is it in any way better to litter your code with string validation followed by unsafe calls when it is easier to just make safe calls in the first place?</p>
<p>Also, I&#39;m surprised by the use of &ge; rather than &gt;= for the &gt;= operator.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994703">
				<div id="div-comment-994703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joey</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994703">
			June 28, 2012 at 10:50 am</a>		</div>

		<p>@Crescens2k If this (and others&#39; analyses) is true, I still agree with Joshua about relying on undocumented behavior. &nbsp;If everyone has to look at the source of these functions (since docs don&#39;t seem to answer the question) to see if there&#39;s a TOCTTOU, we can&#39;t be sure these functions will always be thread-safe. &nbsp;But from Raymond saying, &quot;I&#39;ll see what I can do to make this clearer in the docs&quot;, I gather that the existing precautions we&#39;ve discovered will become documented.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994713">
				<div id="div-comment-994713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994713">
			June 28, 2012 at 10:57 am</a>		</div>

		<p>@mikeb:</p>
<p>strncpy(dst, src, buflen &#8211; 1)[buflen &#8211; 1] = 0;</p>
<p>There. Safe as strcpy_s.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994733">
				<div id="div-comment-994733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994733">
			June 28, 2012 at 11:40 am</a>		</div>

		<p>@Joshua Great, so you only have to do 3 things including calling a function to get the same behavior instead of calling the function to begin with. I assume you also don&#39;t use printf in C, because hey it&#39;s only a simple write to a known file descriptor and a bit of parsing involved?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994743">
				<div id="div-comment-994743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994743">
			June 28, 2012 at 11:47 am</a>		</div>

		<p>Too bad that portable code can&#39;t rely on strcat_s being available, at least not until C11 implementations become widely available (which has strncat_s).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994753">
				<div id="div-comment-994753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994753">
			June 28, 2012 at 11:49 am</a>		</div>

		<p>Err I meant to write strcpy_s()/strncpy_s(), though the same argument applies for the cats.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994773">
				<div id="div-comment-994773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994773">
			June 28, 2012 at 11:51 am</a>		</div>

		<p>@voo: Maybe because I&#39;m not willing to write an additional function to save 2 instructions:</p>
<p>&nbsp;mov ecx, buflen</p>
<p>&nbsp;mov [eax + ecx &#8211; 1], byte 0</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994803">
				<div id="div-comment-994803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steven</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994803">
			June 28, 2012 at 12:36 pm</a>		</div>

		<p>I&#39;m suddenly left wondering whether strdup/_strdup is safe. That would seem to be implementation dependent too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994813">
				<div id="div-comment-994813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">voo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994813">
			June 28, 2012 at 12:42 pm</a>		</div>

		<p>@Joshua A premature optimization &#8211; why didn&#39;t you mention that at first? But you&#39;re still going to call strcpy anyhow, so you only safe the additional guarantees made by strcpy_s which are pretty negligible..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994823">
				<div id="div-comment-994823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994823">
			June 28, 2012 at 12:50 pm</a>		</div>

		<p>@Cesar: Good point about strcpy_s not guaranteed to be thread-safe. &nbsp;Hopefully C11 adoption will be more swift than C99 adoption, since it made optional certain hard-to-implement features (such as VLAs) which were required in C99.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994843">
				<div id="div-comment-994843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994843">
			June 28, 2012 at 1:12 pm</a>		</div>

		<p>What about the case where the destination buffer is deleted by another thread? If we want to create ridiculous assumptions, you can pretty much make ANY code unsafe in some circumstance.</p>
<div class="post">[<i>The destination buffer tends to be trusted. These functions are typically used for transferring data from an untrusted location to a trusted location. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994853">
				<div id="div-comment-994853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henry Skoglund</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994853">
			June 28, 2012 at 1:50 pm</a>		</div>

		<p>Sorry a bit off topic but POKE53280,0 brings back memories, it set the border background color to black on the C-64 if I remember correctly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994863">
				<div id="div-comment-994863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994863">
			June 28, 2012 at 1:56 pm</a>		</div>

		<p>@SimonRev:</p>
<blockquote><p>
  &gt; If the source string is too large it will return ERANGE, but the destination buffer is not modified.
</p></blockquote>
<p>I can&#39;t find where the docs say this. &nbsp;In fact, they seem to say the opposite. &nbsp;From MSDN docs:</p>
<p>&nbsp;&#8211; strcpy_s(): &quot;The debug versions of these functions first fill the buffer with 0xFD.&quot;</p>
<p>&nbsp;&#8211; StringCchCopy(): &quot;STRSAFE_E_INSUFFICIENT_BUFFER &#8211; The copy operation failed due to insufficient buffer space. The destination buffer contains a truncated, null-terminated version of the intended result.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994443">
				<div id="div-comment-994443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mmx</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994443">
			June 28, 2012 at 8:21 am</a>		</div>

		<p>Scripting engines are hard to write.</p>
<p>Multithreaded code is hard to write.</p>
<p>Secure code is very hard to write.</p>
<p>Somehow, a scripting engine (hard), multithreaded (hard) and with a security requirement (very hard) is a bit of a corner case to explain the existence of a function in a *standard* library &#8211; surely someone with those three skills can write their own safe strcpy.</p>
<p>The real reason is that progammers often forget to apply good practices and if they already got into the habit of using secure functions the damage if they forget some sanity check would be limited. Because if programmers were following best practices 100% right in the first place, we wouldn&#39;t ahve the problem to start with: surely you have unit test for all boundary conditions, stress tests, security tests etc in place for every single line of code don&#39;t you ? :)</p>
<p>===</p>
<p>@Avi : I would change most with &quot;many&quot;. Many scripting scenarios are quite unrestricted and treat script basically as plugins. I don&#39;t know which way are most scripting engines, but I would not take security for granted. WoW of course is probably a secure case. Most LoB applications with scripting aren&#39;t secured on the scripting side instead and for a good reason: if a script can do operations on the LoB app, usually formatting the hard drive is the least damage it can do compared to intentionally corrupting business data, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994483">
				<div id="div-comment-994483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994483">
			June 28, 2012 at 8:49 am</a>		</div>

		<p>The original commenter was claiming that if you do your own check you don&#39;t need to use the secure version of the function. Well, that *might* be true sometimes, or it might not. It depends on how your code is going to be used. Raymond&#39;s example shows that there are cases where you really might want to worry about it.</p>
<p>So, at a minimum, you need to do some additional analysis to figure out if your check is sufficient. In some cases you won&#39;t know the answer, because you don&#39;t completely control the context in which your code is used (say because you are a library or other component which gets used in many different contexts). Plus, you might get the analysis wrong simply because you haven&#39;t considered certain lines of attack (would *you* have thought of Raymond&#39;s TOCTTOU example on your own?). Are you *sure* there are no other issues to worry about?</p>
<p>Compare the cost of doing that analysis (if you can), and the risk that you might have accidentally got it wrong, with the cost of just having a cast-iron rule that says &quot;always use the secure string functions&quot;. The cast-iron rule has very little downside, and prevents you from making a mistake.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994873">
				<div id="div-comment-994873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994873">
			June 28, 2012 at 4:11 pm</a>		</div>

		<p>@Steven Don:</p>
<p>As far as Microsoft&#39;s implementation of <code>strdup()</code>/<code>_strdup()</code> is concerned, it uses <code>strcpy_s()</code> to perform the copy into the allocated buffer (at least since VS2005 SP1 Update for Windows Vista, anyway) using the size value that was passed in to <code>malloc()</code>. &nbsp;However, that says nothing about older versions or non-Microsoft implementations.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994513">
				<div id="div-comment-994513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994513">
			June 28, 2012 at 9:26 am</a>		</div>

		<p>[You should take reasonable steps not to amplify a minor error into a security vulnerability. -Raymond]</p>
<p>Don&#39;t you go over not depending on undocumented behavior frequently?</p>
<p>There is no indication in the documentation that this is not a valid implementation of strcpy_s:</p>
<p>errno_t strcpy_s(char *s, size_t nemb, char *t)</p>
<p>{</p>
<p>&nbsp; if (!s || !t) return EINVAL;</p>
<p>&nbsp; size_t tl = strlen(t) + 1;</p>
<p>&nbsp; if (nemb &lt; tl + 1) return ERANGE;</p>
<p>&nbsp; strcpy(s, t);</p>
<p>&nbsp; memset(s + tl, 0, nemb &#8211; tl);</p>
<p>&nbsp; return 0;</p>
<p>}</p>
<p>I would have actually implemented like so (which just has a different problem with that race):</p>
<p>errno_t strcpy_s(char *s, size_t nemb, char *t)</p>
<p>{</p>
<p>&nbsp; if (!s || !t) return EINVAL;</p>
<p>&nbsp; size_t tl = strlen(t) + 1;</p>
<p>&nbsp; if (nemb &lt; tl + 1) return ERANGE;</p>
<p>&nbsp; memcpy(s, t, tl);</p>
<p>&nbsp; memset(s + tl, 0, nemb &#8211; tl);</p>
<p>&nbsp; return 0;</p>
<p>}</p>
<div class="post">[<i>I don&#39;t know what strcpy_s does, but StringCchCopy will not overflow the specified output buffer no matter how crazy the source string is. That&#39;s sort of its whole point. I&#39;ll see what I can do to make this clearer in the docs. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994523">
				<div id="div-comment-994523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994523">
			June 28, 2012 at 9:33 am</a>		</div>

		<p>‘is not technically a vulnerability because you haven&#39;t crossed a security boundary.’ &#8211; I strongly disagree. The attack string will probably come from outside rather than be a string constant. Maybe it&#39;s pasted by the user who has no idea that there&#39;s a chance that the strange accented letters mean ‘root my box’ or maybe it&#39;s from the *gasp* internet.</p>
<p>In practice though, I feel the example to be contrived, and buggy even if the safe string function is used. A better answer to our C64 fan would have been that the safe function forces you to do the check, whereas even the best programmers sometimes forget the check if they use the standard functions. Furthermore they sometimes get the check wrong in subtle ways (this article is an example). As someone who has seen various (non-Windows) kernels and rtls I feel this point cannot be stressed enough. I thus feel a certain amount of irritation that the safe functions still aren&#39;t available on most Posix systems. The developers of said systems are usually well aware of the safe string functions but tend to refuse to implement them (or deprecate the old ones) because of exactly that kind of arrogance.</p>
<p>That said, I tend to use a C++ string class library in which the string class really is whatever is most convenient (on Windows it&#39;s a BSTR).</p>
<p>@SimonRev: There is an assembler opcode which when correctly used in conjunction with other opcodes and initial conditions prevents the fault condition you describe. I haven&#39;t checked but it seems likely that the rtl would use that (or something that compiles to it) possibly with some optimisations thrown in (maybe copy full words first and then the left-over bytes).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994633">
				<div id="div-comment-994633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994633">
			June 28, 2012 at 10:21 am</a>		</div>

		<p>From the StringCbCopy source which ships with Visual Studio (actually inside StringCopyWorkerA called from StringCbCopyA):</p>
<p>&nbsp; &nbsp;while (cchDest &amp;&amp; cchToCopy &amp;&amp; (*pszSrc != &#39; &#39;))</p>
<p>&nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;*pszDest++ = *pszSrc++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;cchDest&#8211;;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;cchToCopy&#8211;;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;cchNewDestLength++;</p>
<p>&nbsp; &nbsp;}</p>
<p>It&#39;s correct, but only because the compiler inlined the dereference of *pszSrc. If it didn&#39;t, there&#39;s still a TOCTOU in there.</p>
<div class="post">[<i>It&#39;s correct even without the inlining, because the result will still be null-terminated and will still never overflow the destination. The result may be a mishmash of old and new strings (possibly even with an embedded null) but the output buffer will always be a valid null-terminated string. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994883">
				<div id="div-comment-994883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anoymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994883">
			June 28, 2012 at 5:22 pm</a>		</div>

		<p>To quote John Mc Enroe: &quot;YOU CAN NOT BE SERIOUS&quot;. If two threads are accessing the same buffer, all bets are off.</p>
<div class="post">[<i>But you should still fail safe. Or are you saying that you shouldn&#39;t be allowed to write a multithreaded script interpreter? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994893">
				<div id="div-comment-994893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994893">
			June 28, 2012 at 6:22 pm</a>		</div>

		<p>[But you should still fail safe. Or are you saying that you shouldn&#39;t be allowed to write a multithreaded script interpreter? -Raymond]</p>
<p>Personally I&#39;d not expect multithreaded script interpreters (or any interpreters for that matter) to have writable strings, but that&#39;s just me.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994763">
				<div id="div-comment-994763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994763">
			June 28, 2012 at 11:49 am</a>		</div>

		<p>Copying a string that is simultaneously being modified by another thread is undefined behaviour no matter what function you use to perform the copy. As far as I can see, using a function that is less likely to crash and burn is probably a *bad* idea, since the programmer needs to know about this truly horrible bug ASAP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994903">
				<div id="div-comment-994903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994903">
			June 28, 2012 at 6:57 pm</a>		</div>

		<p>Sorry, Raymond, but I don&#39;t buy it. You are engaging in a form of sophistry. The notion that the destination is trusted but the source not is completely artificial to simply make your argument. NOTHING in the function calls, let alone in programming implies the integrity of either side. Only the conditions of a highly artificial test create that relationship.</p>
<p>Moreover, I&#39;ll simply change the condition and have the other thread delete the source and force the memory to be invalidated. Then what?</p>
<p>While at it, a third thread writes a completely different string to the destination. A fourth thread finds the address of the first threads stack and overwrites it with zeroes.</p>
<div class="post">[<i>Yes, you could also delete the memory while it is being copied. That shouldn&#39;t result in a buffer overflow either. You are inventing malicious third and fourth threads. Whereas the second thread may have modified the buffer or freed it prematurely by mistake &#8211; a very common error. On the other hand, attacking another thread&#39;s stack is harder to do by mistake. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994913">
				<div id="div-comment-994913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994913">
			June 28, 2012 at 7:21 pm</a>		</div>

		<p>We might as well call a spade a spade. The whole point of this was really so Microsoft could get every potentially dangerous call (with respect to the class of bug that is string buffer overrun) in their entire codebase audited.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994783">
				<div id="div-comment-994783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994783">
			June 28, 2012 at 12:25 pm</a>		</div>

		<p>@Adam Rosenfield: do the C11 specification of strcpy_s guarantee thread safety? I took a quick look at the latest draft, and saw no mention of it. If there is no mention of thread safety in the specification, you cannot depend on it, because your code might be ported to something which uses a naive implementation of these functions (strlen+copy).</p>
<p>I believe the safety here is just a side effect of a performance optimization: it is faster to compute the length and copy at the same time (one pass) than to compute the length and copy separately (two passes).</p>
<p>As to waiting for C11 (which will take ages, some compiler vendors have not updated yet to the previous 10-year-old revision of the C standard), according to Wikipedia these _s functions are *optional*. It is best to just write a portable implementation of these functions and use it when the native implementation is not available (autoconf makes that easy), and you can that today.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-larryosterman even thread-even depth-1" id="comment-994923">
				<div id="div-comment-994923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Larry+Osterman+%5BMSFT%5D' rel='external nofollow' class='url'>Larry Osterman [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994923">
			June 28, 2012 at 8:13 pm</a>		</div>

		<p>@Joe: I encounter situations where the destination is trusted and the source is untrusted quite literally every day. &nbsp;Certainly any time you&#39;re dealing with content that could possibly have EVER come from the web, the source is 100% untrusted. &nbsp;It&#39;s possible that you live in a world that never deals with untrusted data (although I cannot for the life of me think of such a world), but the rest of us live in that world every day.</p>
<p>Don&#39;t forget: Whenever you read a file from the disk or accept an input from the user you&#39;re almost certainly dealing with untrusted data (there are some extremely limited scenarios where file input could be trusted but I can&#39;t think of any situation where user input is trusted). &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994933">
				<div id="div-comment-994933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Larry Osterman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994933">
			June 29, 2012 at 12:24 am</a>		</div>

		<p>It might be the case that your web-string is untrusted, but it&#39;s not the case that your web-string is being modified on another thread. String Variants are immutable in COM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994953">
				<div id="div-comment-994953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MMx</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994953">
			June 29, 2012 at 1:41 am</a>		</div>

		<p>@Avi</p>
<blockquote><p>
  &gt; You&#39;d be hard-pressed to create a keylogger in VBA, for example.
</p></blockquote>
<p>Quite easy really:</p>
<p>1) get a binary on a local disk (easier done than said, you can download from HTTP, fake a PNG image with a payload at the end, whatever)</p>
<p>2) shell execute it</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994963">
				<div id="div-comment-994963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Remus Rusanu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994963">
			June 29, 2012 at 3:07 am</a>		</div>

		<p>The implementation of the safe functions must itself be resilient, internally, to this attack (and other&#8230;).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994973">
				<div id="div-comment-994973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994973">
			June 29, 2012 at 3:27 am</a>		</div>

		<p>Do we need a safe version of strlen, or does everyone just use memchr(s, 0, 256)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-994983">
				<div id="div-comment-994983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994983">
			June 29, 2012 at 5:51 am</a>		</div>

		<p>StringCchLength(A|W) and strlen_s do that.</p>
<p>strlen is an SDL-banned function too :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-994993">
				<div id="div-comment-994993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-994993">
			June 29, 2012 at 6:04 am</a>		</div>

		<p>@Larry Osterman &quot;I can&#39;t think of any situation where user input is trusted&quot;</p>
<p>I think this is an artifact of the poorly defined category of &quot;trusted&quot;. You can certainly do things like pass user input directly to ShellExecute, or use it as a filename without removing &quot;..&quot; from it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-995003">
				<div id="div-comment-995003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995003">
			June 29, 2012 at 6:17 am</a>		</div>

		<p>@MikeB:</p>
<p>There is a giant table in the section called RETURN VALUE which states very explicitly that if the source buffer is larger than the destination buffer that the destination will be unchanged.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-995023">
				<div id="div-comment-995023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Louis Pace</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995023">
			June 29, 2012 at 7:19 am</a>		</div>

		<p>@Henry Skoglund: It was the border color. The background color was controlled by address 53281. Ah&#8230; fond memories&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-995093">
				<div id="div-comment-995093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995093">
			June 29, 2012 at 8:29 am</a>		</div>

		<p>I was believing Joey, who opined that the safe functions could also have the rug pulled out from under them. &nbsp;Someone pointed out that the implementation of the safe functions is more involved than that, so the safe functions don&#39;t have the problem.</p>
<p>Next, decided that the reason to use the safe functions is that if and when their implementation is improved, to use new machine instructions for example, all code that calls them will be automatically improved. &nbsp;</p>
<p>Then I decided that the implementation of the unsafe functions should be changed to have the undsafe functions internally call the safe functions. &nbsp;Is there any harm in that? &nbsp;Programmers won&#39;t have to change their code, and everything will get better. &nbsp;:-) &nbsp;Is there any harm in that?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-995123">
				<div id="div-comment-995123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">@David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995123">
			June 29, 2012 at 8:47 am</a>		</div>

		<blockquote><p>
  &gt; Then I decided that the implementation of the unsafe functions should be changed to have the undsafe functions internally call the safe functions. &nbsp;Is there any harm in that? &nbsp;Programmers won&#39;t have to change their code, and everything will get better. &nbsp;:-) &nbsp;Is there any harm in that?
</p></blockquote>
<p>It&#39;s not possible. The basic difference of the safe functions is that they take (at least) an additional parameter.</p>
<p>Take the most insecure function ever: &quot;gets&quot;.</p>
<p>char s[100];</p>
<p>gets(s);</p>
<p>As is, &quot;gets&quot; always overruns if the user is patient enough to type 100+ keys. You can basically change it in two ways that I can think of:</p>
<p>1) take the length of s and never overrun</p>
<p>2) introduce an arbitary limit and document it</p>
<p>1: is not compatible to be replaced, since you now have to call gets(s, 100); instead of gets(s);</p>
<p>2: is plain stupid as it does not secure those calls which are on a buffer under the arbitrary limit, and introduces an incompatibility for the code which should allow to type over that limit</p>
<p>Of course, with a friendlier string type (or language) it could derive from s its length; but for C strings you can&#39;t &#8211; the basic mistake was in the design of C strings which saved one byte in the sixties to bite us forever since then.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-995173">
				<div id="div-comment-995173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/arcangelpip_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>arcangelpip@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995173">
			June 29, 2012 at 9:43 am</a>		</div>

		<p>@David Walker</p>
<p>Umm, if you are talking about my comment earlier on, I never once even intended to imply that if you pull the rug out from under them, they would continue working. You see, if you end up decomitting a page of memory that it is reading from/writing to then obviously, even the safe functions will cause an access violation.</p>
<p>What the safe functions do is allow block any attempt at changing the length of the source string from overflowing the buffer. If that happens to the safe function, then it will get to the end of the destination buffer, notice that no null has been copied in and then fail. My comment was only to point out that a call to strcpy_s is not the same as a call to strlen followed by strcpy in the VC CRT.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-995243">
				<div id="div-comment-995243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995243">
			June 29, 2012 at 11:55 am</a>		</div>

		<p>@SimonRev:</p>
<p>I did &nbsp;overlook that table (I guess I focused too much on the comments section). &nbsp;However, it&#39;s only for VS2005 that the table describes the contents of strDestination as being unmodified when ERANGE is returned. &nbsp;For later versions of VS, it indicates that strDestination[0] is set to 0. &nbsp;I&#39;d assume that that&#39;s the case only if numberOfElements isn&#39;t 0 (another doc error). &nbsp;</p>
<p>I also wouldn&#39;t assume that other contents of the buffer are unmodified (in fact, in general they will be modified).</p>
<p>It also appears that strcpy_s() returns EINVAL if numberOfElements is 0, while the table indicates it will return ERANGE (however, the remarks section correctly says that it will return EINVAL in that case).</p>
<p>To summarize, testing on VS 2005 SP1 (with the Vista update) and VS 2010 SP1 shows that the buffer is modified when ERANGE is returned from strcpy_s(). There&#39;s also a minor doc error about when the dest buffer size is 0. &nbsp;So I think you should consider the docs for these functions to be subtly incorrect in certain error cases. &nbsp;I&#39;ll post soemthing to the MSDN &quot;Community Comments&quot; section about these small issues.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-995393">
				<div id="div-comment-995393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995393">
			June 30, 2012 at 5:00 pm</a>		</div>

		<p>@Larry, just because you encounter a situation doesn&#39;t make it the defacto rule, nor does it imply that it is always the case. Like Raymond, you keep changing the conditions. Who say the source string was user input? That&#39;s ex post facto reasoning.</p>
<p>A further point is that if a buffer is so untrusted that an initial check is unreliable, then you have serious problems with your algorithm and are simply using the safe function to fool yourself into thinking your algorithm is sound. More specifically, if a thread is modifying a buffer in an unprotected manner, you have lousy code and far bigger problems than a buffer overrun.</p>
<p>I&#39;d argue that the best practice would be to move user input to a trusted buffer and never worry about it again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-995413">
				<div id="div-comment-995413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/arcangelpip_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>arcangelpip@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995413">
			July 1, 2012 at 12:40 am</a>		</div>

		<p>@Joe</p>
<p>The thing is, it doesn&#39;t really have to be lousy code to be put in this kind of situation. All you have to do is get into the situation where you are a host to code you didn&#39;t write and then you are open to this kind of problem. Especially if as a host you allow communication to the hosted code.</p>
<p>So this isn&#39;t about user input, and you can&#39;t move anything since there is part of the code that you don&#39;t have control over. This is why they kept pointing out the scripting engine scenario. It isn&#39;t limited to that, applications that allow plugins that have string parameters are prone to this, just as an example. Oh, and in before anyone mentions putting a string length parameter in the plugin API. Unfortunately, I have come across some which are not that smart.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-995513">
				<div id="div-comment-995513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995513">
			July 2, 2012 at 9:20 am</a>		</div>

		<p>Joe: You&#39;re absolutely right &#8212; you should move the user input to a trusted buffer. But what function do you call to move that input to a trusted buffer?</p>
<p>Also, history has shown that trusted inputs have a way of becoming untrusted: a machine on a trusted LAN ends up getting put on the Internet; a trusted process ends up getting invoked by a web server. There&#39;s no harm in always using the safe functions, and there&#39;s clearly harm in not using them, so why not just always use them and then never have to worry about a certain class of bugs?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-995853">
				<div id="div-comment-995853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-995853">
			July 3, 2012 at 10:41 am</a>		</div>

		<p>@Gabe: You only eliminate compiler warnings, not bugs or security holes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-996143">
				<div id="div-comment-996143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-996143">
			July 4, 2012 at 11:08 am</a>		</div>

		<p>Basically, any function which writes a string, or traverses a string until  , without boundaries is unsafe.</p>
<p>The former is the most obvious case, but the latter surely triggers strlen fans to go wild and simply expose their inner denial with public rejection. OK, it might not be a security issue if and only if your program is both the source and consumer of such &quot;safe&quot; strings, but if a string comes from somewhere else, like a file, a DB or user input, you shouldn&#39;t trust it.</p>
<p>One of the most subtle &quot;string-security&quot; problem is when a string gets copied or concatenated without the guarantee we&#39;ll have a trailing  , such as in strncpy. So much so that if you keep using such functions, you&#39;ll most surely forget to null-terminate the result at some point, probably in the most obscure place.</p>
<p>Raymond, the string modification race condition isn&#39;t so much the trouble from my point of view. You answered to a comment that changing the stack at the buffer length argument is not as common as multiple threads handling the string, but I say it&#39;s fairly easy to happen even without malice, for instance, if you have a pointer to a struct which actually points wrongly to the said stack position, or some position above where the buffer lenght happens to be at the position of an integer field. So, the safe string functions are obviously not safe facing someone who&#39;s beyond the airtight hatchway, they&#39;re just (much!) safer than relying on the null of null-terminated strings or on the unbounded storage of characters.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-996153">
				<div id="div-comment-996153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120628-00/?p=7263#comment-996153">
			July 4, 2012 at 11:10 am</a>		</div>

		<p>Just to complement my previous post, you obviously need the safer functions to actually be able to avoid access violations.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

