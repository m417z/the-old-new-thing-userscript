<html>
<head>
<title>You can use a file as a synchronization object, too</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>You can use a file as a synchronization object, too</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>September 5, 2014 / year-entry #214</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>35</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer was looking for a synchronization object that had the following properties: Can be placed in a memory-mapped file. Can be used by multiple processes simultaneously. Bonus if it can even be used by different machines simultaneously. Does not leak resources if the file is deleted. It turns out there is already a synchronization...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
A customer was looking for a synchronization object that
had the following properties:
</p>
<ul>
<li>Can be placed in a memory-mapped file.
<li>Can be used by multiple processes simultaneously.
    Bonus if it can even be used by different machines simultaneously.</p>
<li>Does not leak resources if the file is deleted.
</ul>
<p>
It turns out there is already a synchronization object for this,
and you've been staring at it the whole time: The file.
</p>
<p>
File locking is a very old feature that most people consider
old and busted because it's just one of those dorky things
designed for those clunky database systems that use tape drives
like they have in the movies.
While that may be true, it's still useful.
</p>
<p>
The idea behind file locking is that every byte of a file
can be a synchronization object.
The intended pattern is that a database program indicates
its intention to access a section of a file by locking it,
and this prevents other processes from accessing that same
section of the file.
This allows the database program to update the file without
race conditions.
When the database program is finished with that section of the file,
it unlocks it.
</p>
<p>
One interesting bit of trivia about file locking is that
you can lock bytes that don't even exist.
It is legal to lock bytes beyond the end of the file.
This is handy in the database case if you want to extend the file.
You can lock the bytes you intend to add,
so that nobody else can extend the file at the same time.
</p>
<p>
The usage pattern for byte-granular file locks
maps very well to the customer's requirements.
The synchronization object is... the file itself.
And you put it in the file by simply choosing a byte to use
as the lock target.
(And the byte can even be imaginary.)
And if you delete the file, the lock disappears with it.
</p>
<p>
Note that the byte you choose as your lock target need not
be dedicated for use as a lock target.
You can completely ignore the contents of the file and simply
agree to use byte zero as the lock target.
You just have to understand that when the byte is locked,
only the owner of the lock can access it via the
<code>Read&shy;File</code> and <code>Write&shy;File</code>
family of functions.
(Reading or writing a byte that is locked by somebody
else will fail with
<code>ERROR_<wbr>LOCK_<wbr>VIOLATION</code>.
Note that access via memory-mapping is not subject to file locking,
which neatly lines up with the customer's first requirement.)
</p>
<p>
To avoid the problem with locking an actual byte,
you can choose imaginary bytes
at ridiculously
huge offsets purely for locking.
Since those bytes don't exist, you won't interfere
with other code that tries to read and write them.
For example, you might agree to lock byte
0xFFFFFFFF`FFFFFFFF, on the assumption that the file will never
become four
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/11/9725386.aspx">
exabytes</a> in size.
</p>
<p>
File locking supports the reader/writer lock model:
You can claim a lock for shared access (read)
or for exclusive access (write).
</p>
<p>
The basic <code>Lock&shy;File</code> function is a subset of the
more general
<code>Lock&shy;File&shy;Ex</code> function,
so let's look at the general function.
</p>
<p>
To lock a portion of a file, you call
<code>Lock&shy;File&shy;Ex</code> with the range you want to lock,
the style of lock (shared or exclusive),
and how you want failed locks to be handled.
To release the lock, you pass the <i>same range</i> to
<code>Unlock&shy;File&shy;Ex</code>.
Note that ranges cannot be chopped up or recombined.
If you lock bytes 0&ndash;10 and 11&ndash;19 with separate calls,
then you must unlock them with separate matching calls;
you can't make a single bulk call to unlock bytes
0&ndash;19, nor can you do a partial unlock of bytes
0&ndash;5.
</p>
<p>
Most of the mechanics of locking are straightforward,
except for the "how you want failed locks to be handled" part.
If you specify
<code>LOCKFILE_<wbr>FAIL_<wbr>IMMEDIATELY</code>
and the lock attempt fails, then the call simply fails
with <code>ERROR_<wbr>LOCK_<wbr>VIOLATION</code> and that's
the end of it.
It's up to you to retry the operation if that's what you want.
</p>
<p>
On the other hand, if you do not specify
<code>LOCKFILE_<wbr>FAIL_<wbr>IMMEDIATELY</code>,
and the lock attempt fails,
then the behavior depends on whether the handle is
synchronous or asynchronous.
If synchronous, then the call blocks until the lock is acquired.
If asynchronous, then the call returns immediately with
<code>ERROR_<wbr>IO_<wbr>PENDING</code>, and the I/O completes
when the lock is acquired.
</p>
<p>
The documentation in MSDN on how lock failures are handled is
a bit confusing, thanks to tortured sentence structure like
"X behaves like Y if Z unless Q."
Here is the behavior of lock failures in table form:
</p>
<table BORDER=1 BORDERCOLOR=black
    STYLE="border-collapse: collapse"
    CELLSPACING=0 CELLPADDING=3>
<tr>
<th ROWSPAN=2>If <code>Lock&shy;File&shy;Ex</code> fails</th>
<th COLSPAN=2>Handle type</th>
</tr>
<tr>
<th>Asynchronous</th>
<th>Synchronous</th>
</tr>
<tr>
<td><code>LOCKFILE_<wbr>FAIL_<wbr>IMMEDIATELY</code> specified</td>
<td COLSPAN=2 ALIGN=center>
        Returns <code>FALSE</code> immediately.<br>
        Error code is <code>ERROR_<wbr>LOCK_<wbr>VIOLATION</code>.
    </td>
</tr>
<tr>
<td><code>LOCKFILE_<wbr>FAIL_<wbr>IMMEDIATELY</code> not specified</td>
<td ALIGN=center>
        Returns <code>FALSE</code> immediately.<br>
        Error code is <code>ERROR_<wbr>IO_<wbr>PENDING</code>.<br>
        I/O completes when lock is acquired.</td>
<td ALIGN=center>
        Blocks until lock is acquired, returns <code>TRUE</code>.</td>
</table>
<p>
Here's a little test app that exercises all the options.
Run the program with two command line options.
The first is the name of the file you want to lock,
and the second is a string describing what kind of lock
you want.
Pass zero or more of the following letters:
</p>
<ul>
<li>"o" to open an overlapped (asynchronous) handle; otherwise,
    it will be opened non-overlapped (synchronous).</p>
<li>"e" to lock exclusively; otherwise, it will be locked shared
<li>"f" to fail immediately; otherwise, it will wait
</ul>
<p>
For example, you would pass "ef" to open a synchronous handle
and request an exclusive lock that fails immediately if it cannot
be acquired.
If you want all the defaults, then pass "" as the options.
</p>
<pre>
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

int __cdecl _tmain(int argc, TCHAR **argv)
{
 // Ensure correct number of command line arguments
 if (argc &lt; 3) return 0;

 // Get the options
 DWORD dwFileFlags = 0;
 DWORD dwLockFlags = 0;
 for (PTSTR p = argv[2]; *p; p++) {
  if (*p == L'o') dwFileFlags |= FILE_FLAG_OVERLAPPED;
  if (*p == L'e') dwLockFlags |= LOCKFILE_EXCLUSIVE_LOCK;
  if (*p == L'f') dwLockFlags |= LOCKFILE_FAIL_IMMEDIATELY;
 }

 // Open the file
 _tprintf(TEXT("Opening the file '%s' as %s\n"), argv[1],
          (dwFileFlags &amp; FILE_FLAG_OVERLAPPED) ?
          TEXT("asynchronous") : TEXT("synchronous"));
 HANDLE h = CreateFile(argv[1], GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | dwFileFlags, NULL);
 if (h == INVALID_HANDLE_VALUE) {
  _tprintf(TEXT("Open failed, error = %d\n"), GetLastError());
  return 0;
 }

 // Set the starting position in the OVERLAPPED structure
 OVERLAPPED o = { 0 };
 o.Offset = 0; // we lock on byte zero

 // Say what kind of lock we want
 if (dwLockFlags &amp; LOCKFILE_EXCLUSIVE_LOCK) {
  _tprintf(TEXT("Requesting exclusive lock\n"));
 } else {
  _tprintf(TEXT("Requesting shared lock\n"));
 }

 // Say whether we're going to wait to acquire
 if (dwLockFlags &amp; LOCKFILE_FAIL_IMMEDIATELY) {
  _tprintf(TEXT("Requesting immediate failure\n"));
 } else if (dwFileFlags &amp; FILE_FLAG_OVERLAPPED) {
  _tprintf(TEXT("Requesting notification on lock acquisition\n"));
  // The event that will be signaled when the lock is acquired
  // error checking deleted for expository purposes
  o.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
 } else {
  _tprintf(TEXT("Call will block until lock is acquired\n"));
 }

 // Okay, here we go.
 _tprintf(TEXT("Attempting lock\n"));
 BOOL fRc = LockFileEx(h, dwLockFlags, 0, 1, 0, &amp;o);

 // If the lock failed, remember why.
 DWORD dwError = fRc ? ERROR_SUCCESS : GetLastError();
 _tprintf(TEXT("Wait %s, error code %d\n"),
          fRc ? TEXT("succeeded") : TEXT("failed"), dwError);

 if (fRc) {
  _tprintf(TEXT("Lock acquired immediately\n"));
 } else if (dwError == ERROR_IO_PENDING) {
  _tprintf(TEXT("Waiting for lock\n"));
  WaitForSingleObject(o.hEvent, INFINITE);
  fRc = TRUE; // lock has been acquired
 }

 // If we got the lock, then hold the lock until the
 // user releases it.
 if (fRc) {
  _tprintf(TEXT("Hit Enter to unlock\n"));
  getchar();
  UnlockFileEx(h, 0, 1, 0, &amp;o);
 }

 // Clean up
 if (o.hEvent) CloseHandle(o.hEvent);
 CloseHandle(h);
 return 0;
}
</pre>
<p>
When you run this program, it will try to acquire
the lock in the manner requested,
and if the lock is successfully acquired,
it will wait for you press Enter,
then it will release the lock.
</p>
<p>
You naturally need to run multiple copies of this program
to see how the flags interact.
(If you run only one copy, then it will always succeed.)
</p>
<p>
<b>Exercise</b>:
What changes would you make if you wanted
to wait at most 5 seconds to acquire the lock?
(<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2011/02/02/10123392.aspx"
>Hint</a>.)</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (35)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1148033">
				<div id="div-comment-1148033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Farnsworth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148033">
			September 5, 2014 at 8:43 am</a>		</div>

		<p>IIUC, the exercise has a nasty gotcha in it. The obvious change to make is to change &quot;WaitForSingleObject(o.hEvent, INFINITE);&quot; to wait for no more than 5 seconds (instead of INFINITE).</p>
<p>The issue with doing this naively is that, as per the linked Hint, the I/O can complete at the wrong time and obliterate reused memory. The solution is in the Hint &#8211; after &quot;WaitForSingleObject(o.hEvent, 5000);&quot;, call &quot;CancelIo(h); GetOverlappedResult(h, &amp;o, TRUE);&quot;, which both cancels the requested I/O </p>
<p> and ensures that the OVERLAPPED has been returned to you, so no memory trample can happen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148043">
				<div id="div-comment-1148043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Madge</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148043">
			September 5, 2014 at 8:52 am</a>		</div>

		<p>&quot;You&#39;re soaking in it.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1148063">
				<div id="div-comment-1148063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148063">
			September 5, 2014 at 10:23 am</a>		</div>

		<p>Does CancelIo cancel FIOCTLs? LockFile FIOCTL may or may not be cancelable.</p>
<p>Also, keep in mind that the file lock scope is a handle, not a thread. If you want different threads locking against each other, open separate handles to the file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148073">
				<div id="div-comment-1148073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148073">
			September 5, 2014 at 10:35 am</a>		</div>

		<p>Clever. I don&#39;t think it would have ever occurred to me to use a file lock for something other than to make sure that reads/writes to portions of the file were safe from corruption.</p>
<p>And alegr1&#39;s helpful note would have almost certainly bitten me if I tried this for thread synchronization.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148083">
				<div id="div-comment-1148083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148083">
			September 5, 2014 at 11:31 am</a>		</div>

		<p>Good to know, I wasn&#39;t aware file locking was so powerful and flexible.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1148093">
				<div id="div-comment-1148093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148093">
			September 5, 2014 at 11:36 am</a>		</div>

		<p>@mikeb:</p>
<p>Also, duplicated handles within the same process may or may not have separate locking scope.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148103">
				<div id="div-comment-1148103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148103">
			September 5, 2014 at 11:55 am</a>		</div>

		<p>But file locking is broken on some file systems (e.g., some NASes).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jader3rd odd alt thread-odd thread-alt depth-1" id="comment-1148143">
				<div id="div-comment-1148143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/jader3rd' rel='external nofollow' class='url'>jader3rd</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148143">
			September 5, 2014 at 3:17 pm</a>		</div>

		<p>Does .Net always specify LOCKFILE_FAIL_IMMEDIATELY then? Because I hate dealing with trying to open a file, only to have it run into a &quot;File is already open&quot; exception.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1148163">
				<div id="div-comment-1148163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148163">
			September 5, 2014 at 4:10 pm</a>		</div>

		<p>@jader3rd:</p>
<p>File locking and SHARE flags are two different things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148173">
				<div id="div-comment-1148173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148173">
			September 5, 2014 at 5:58 pm</a>		</div>

		<p>@Kevin: That&#39;s why /var/lock is cleared on boot and why signal handlers existed since the bad old days. Unlike on Windows, unlinking the lock file was guaranteed to work (yes even if open).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148123">
				<div id="div-comment-1148123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148123">
			September 5, 2014 at 12:04 pm</a>		</div>

		<p>With careful use of open() and unlink(), it is common to use the *existence* of a file as a lock, at least under Unix (whose file-level locking is basically a non-feature). &nbsp;This has the blessing and curse that the lock remains locked if you crash while holding it. &nbsp;It&#39;s a blessing because it forces people to clean up their inconsistent data. &nbsp;It&#39;s a curse because it forces *you* to clean up your inconsistent data.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-amroamroamro odd alt thread-odd thread-alt depth-1" id="comment-1148183">
				<div id="div-comment-1148183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/amroamroamro' rel='external nofollow' class='url'>amroamroamro</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148183">
			September 6, 2014 at 12:21 am</a>		</div>

		<p>For anyone who tries the example using MinGW compilers, I had to disable output buffering to see the printed messages (or explicitly flush after each call): <a href="http://stackoverflow.com/a/1716621" rel="nofollow" target="_new">stackoverflow.com/&#8230;/1716621</a></p>
<div class="post">[<em>I don&#39;t see why that was necessary. All of my print statements end in n, so the buffer should have been flushed anyway (because stdout is line-buffered or unbuffered if the device is interactive). -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148263">
				<div id="div-comment-1148263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148263">
			September 6, 2014 at 2:52 pm</a>		</div>

		<p>@Joshua</p>
<p>Sure, that&#39;s great for daemons, but what about everyone else?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148303">
				<div id="div-comment-1148303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Major</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148303">
			September 6, 2014 at 11:58 pm</a>		</div>

		<p>In C#, How does this technique compares to using Mutex ?</p>
<div class="post">[<em>I don&#39;t see how a Mutex solves the problem. Can you store a Mutex in a memory-mapped file? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148333">
				<div id="div-comment-1148333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">loreb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148333">
			September 7, 2014 at 9:14 am</a>		</div>

		<p>@Raymond I don&#39;t have visual studio, but I can confirm that on mingw printf(&quot;whatevern&quot;) doesn&#39;t flush stdout (and if memory serves me right not even stderr); according to <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/86cebhfs(v=vs.120).aspx">msdn.microsoft.com/&#8230;/86cebhfs(v=vs.120).aspx</a> line buffering on win32 is just an alias for full buffering.</p>
<p>I bet you could write an post about it :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-harry-johnston odd alt thread-odd thread-alt depth-1" id="comment-1148363">
				<div id="div-comment-1148363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Harry+Johnston' rel='external nofollow' class='url'>Harry Johnston</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148363">
			September 7, 2014 at 7:55 pm</a>		</div>

		<p>@Lev: any NAS that supports SMB but doesn&#39;t do file locking properly should be put out to pasture, or better still shot immediately as a warning to others. &nbsp;Not the programmer&#39;s problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148403">
				<div id="div-comment-1148403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148403">
			September 8, 2014 at 3:50 am</a>		</div>

		<p>SMB2+ breaks file locking. DO NOT USE FILE LOCKING on WinVista+. SMB2 does not guarantee consistency. This is why all dbase-style shared flat-file databases are broken as hell on Vista+.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148413">
				<div id="div-comment-1148413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">acq</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148413">
			September 8, 2014 at 5:47 am</a>		</div>

		<p>Anon, can you please elaborate re: &quot;SMB2+ breaks file locking&quot;?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148423">
				<div id="div-comment-1148423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148423">
			September 8, 2014 at 6:03 am</a>		</div>

		<p>@Anon</p>
<p>WTF are you talking about?</p>
<p>Just for reference here is doc for SMB2 <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/cc246482.aspx">msdn.microsoft.com/&#8230;/cc246482.aspx</a></p>
<p>To my knowledge you are first to talk about that supposed massive problem. And incidentally there was nothing about this on Subversion dev mailing list. (as it would be applicable to SVN repo files)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1148373">
				<div id="div-comment-1148373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148373">
			September 7, 2014 at 11:06 pm</a>		</div>

		<p>@Lev: For NAS that don&#39;t properly support locking, you can&#39;t prevent access from ***other machines*** accessing the file at the same time anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148443">
				<div id="div-comment-1148443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148443">
			September 8, 2014 at 7:02 am</a>		</div>

		<p>@Klimax: subversion is from the Unix world. It doesn&#39;t depend on file locking. Network file locking has always been broken.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148453">
				<div id="div-comment-1148453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Elliott</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148453">
			September 8, 2014 at 7:15 am</a>		</div>

		<p>I maintain a product whose database is multiple flat files, using file locking to enforce consistency. It did indeed encounter some odd issues on a couple of SMB2 systems (writes would succeed but the files on disk would be left untouched, leaving the database inconsistent). Of course, the users went to Microsoft, and Microsoft said SMB2 wasn&#39;t buggy so the fault had to lie in our program. About six months later the users loaded a Microsoft hotfix for a (supposedly) unrelated problem, and the file corruption suddenly stopped happening.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148493">
				<div id="div-comment-1148493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148493">
			September 8, 2014 at 8:24 am</a>		</div>

		<p>For those of you who can&#39;t find the SMB2+ file locking problem:</p>
<p>Look at the auto-reconnect behavior: Connections can be lost and restored, apparently transparent to the user, and we believe user code. We have tested this and found it to be as true as we can test for including locks coming back after server reboots. (We had to take drastic measures after a month-old stuck lock despite weekly server reboots&#8211;the reboots were specifically for killing SQL locks that were breaking the backup process [not a bug&#8211;idiot engineers kept leaving transactions open in SQL windows]).</p>
<p>Considering the following scenario: Client #1 takes file lock. Connection breaks in a way immediately noticed by server but not immediately by client. Server releases lock but client doesn&#39;t know about it. Client #2 takes lock, manipulates file, and releases lock. Client #1 discovers the disconnect by timeout, reconnects, and reestablishes locks. Lock reestablishment succeeds.</p>
<p>To the claim of the API got it right: MoveFile&#39;s actual semantics don&#39;t match its documented semantics: <a rel="nofollow" target="_new" href="https://www.virtualbox.org/ticket/2350">http://www.virtualbox.org/&#8230;/2350</a> . Once having found one case of the documentation simply being wrong, finding more should not be surprising. Also, the samba code indicates the existence of rebuild open file handles on reconnect.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148533">
				<div id="div-comment-1148533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bzakharin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148533">
			September 8, 2014 at 9:13 am</a>		</div>

		<p>So is the bonus requirement not met? Locking does not work over the network. I found out the hard way. I was working on a problem in some very old code (It talked to telex machines via modem, that old) which had the problem for years (probably from day one of the Windows port. The original code was for VMS), but very intermittently, of one received message overwriting another on disk. Turns out we were doing file locking over the network. We fixed it. I don&#39;t remember how, but obviously it was some other sort of synchronization. Less than a year later Verizon, who acquired MCI, shut down telex, and the entire product became obsolete.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148613">
				<div id="div-comment-1148613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148613">
			September 8, 2014 at 10:34 am</a>		</div>

		<p>@Boriz Zakharin: Network file locking has always been broken. I can prove the following requirements triad has no solution: recover locks from transport (read: TCP/IP but changing protocol doesn&#39;t help) disconnect, clean up lock on client crash, and locks do not exist on server disk.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1148733">
				<div id="div-comment-1148733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bzakharin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148733">
			September 8, 2014 at 12:06 pm</a>		</div>

		<p>So how is &quot;Bonus if it can even be used by different machines simultaneously&quot; achieved then?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1148753">
				<div id="div-comment-1148753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148753">
			September 8, 2014 at 1:00 pm</a>		</div>

		<p>@Boriz Zakharin: I suggest NTFS Transactional API.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf odd alt thread-odd thread-alt depth-1" id="comment-1148873">
				<div id="div-comment-1148873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1148873">
			September 9, 2014 at 1:34 am</a>		</div>

		<p>The problem I see with this is that you can&#39;t lock a synchronous file handle with a timeout: You only get the choice between zero an INFINITE, or switching to an asynchronous mode.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1149083">
				<div id="div-comment-1149083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1149083">
			September 9, 2014 at 8:29 am</a>		</div>

		<p>@klimax</p>
<p>Here&#39;s the whitepaper:</p>
<p><a rel="nofollow" target="_new" href="http://www.dataaccess.com/whitepapers/opportunlockingreadcaching.html">http://www.dataaccess.com/&#8230;/opportunlockingreadcaching.html</a></p>
<p>Here&#39;s ONE of the patches to correct part of the issue:</p>
<p><a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/2028965">support.microsoft.com/&#8230;/2028965</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1149103">
				<div id="div-comment-1149103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1149103">
			September 9, 2014 at 8:59 am</a>		</div>

		<p>@Joshua</p>
<p>Microsoft is considering dropping NTFS transactions entirely:</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh802690%28v=vs.85%29.aspx">msdn.microsoft.com/&#8230;/hh802690%28v=vs.85%29.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1149173">
				<div id="div-comment-1149173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1149173">
			September 9, 2014 at 10:10 am</a>		</div>

		<p>OK that&#39;s bizarre. The low uptake is due to needing to support XP and 2003 for a few more years. Once again, MS doesn&#39;t look at the reason for the low uptake and thinks low uptake -&gt; drop.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1149533">
				<div id="div-comment-1149533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1149533">
			September 9, 2014 at 11:41 pm</a>		</div>

		<p>@Joshua</p>
<p>The problem is that there&#39;s no &quot;need&quot; to support XP/2003. They&#39;re ancient. Obsolete. Insecure. If they were Apple products, Apple would start denying that they ever existed and deleting (&quot;archiving&quot;) KB articles.</p>
<p>There is no valid reason for anyone to not be using Win7 at this point for desktop machines, especially given how well it runs on older hardware and the massive number of stability improvements that were made over XP.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1149953">
				<div id="div-comment-1149953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1149953">
			September 10, 2014 at 9:44 pm</a>		</div>

		<p>Anon: The need to support XP/2003 comes from our customers using it.</p>
<p>My company&#39;s biggest customer still has Server 2003 and my second-biggest has only recently finished migrating from XP to Win7 (bonus: they&#39;re currently considering migrating off IE8).</p>
<p>You can feel free to tell your customers that they have no valid reason to not be using &quot;modern&quot; OSes, but they&#39;ll likely disagree with you.</p>
<p>I am not in the position of dictating what software my customers use. If my product isn&#39;t compatible with their environment, they won&#39;t buy it, so I ensure that my product is supported by whatever environment they have (at least for customers that are willing to pay for the support).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1150053">
				<div id="div-comment-1150053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pinging @Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1150053">
			September 11, 2014 at 7:29 am</a>		</div>

		<p>Is there a reason for file servers not to keep on-disk metadata then? (It seems like that they do anyway from what you&#39;ve said earlier.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1150223">
				<div id="div-comment-1150223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Engywuck</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140905-00/?p=63#comment-1150223">
			September 11, 2014 at 9:05 am</a>		</div>

		<p>@Gabe: the problem is: sometimes the companies themselves *can&#39;t* update their servers, at least not all of them. </p>
<p>For example after we updated our DCs and File Servers to 2008R2 one production machine suddenly couldn&#39;t connect to the share where the production data was held. The reason: in 2006 the control panel with central processing of that machine was replaced &#8212; with a Win98 a control OS! (I&#39;d have partially understood NT). But Win98 doesn&#39;t &quot;speak&quot; modern security, which is enabled by default in 2008R2. Nearly the same for another machine which we bought new in 2012 or so: control OS was XP (&quot;we get support till 2017&quot; &#8211; that&#39;s what they said. Great.). </p>
<p>The &quot;reason&quot; in both cases: those who develop production machines develop their controls on one OS and have to recertify when changing the platform, which is really non-cheap. If you as customer are really lucky you are allowed to install updates (or they have mechanisms to reset on reboot). And no, you don&#39;t have a choice: the number of vendors of those specific machines is small (as in &quot;one digit&quot;). </p>
<p>We *really* try to only have modern OS&#39;s in our network, but&#8230; well&#8230; *perhaps* we lose the last W2k Server next year. If nothing bad happens. As we do lose the W2k Pro systems, which were needed for a LOB software written in QBasic and accessing some hardware. Maybe. If the programmer gets the departments to sign the new software off. </p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

