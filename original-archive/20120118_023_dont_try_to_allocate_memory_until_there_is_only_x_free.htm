<html>
<head>
<title>Don't try to allocate memory until there is only x% free</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Don&#8217;t try to allocate memory until there is only x% free</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 18, 2012 / year-entry #24</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>52</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">I have an ongoing conflict with my in-laws. Their concept of the correct amount of food to have in the refrigerator is "more than will comfortably fit." Whenever they come to visit (which is quite often), they make sure to bring enough food so that my refrigerator bursts at the seams, with vegetables and eggs...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>I have an ongoing conflict with my in-laws. Their concept of the correct amount of food to have in the refrigerator is "more than will comfortably fit." Whenever they come to visit (which is quite often), they make sure to bring enough food so that my refrigerator bursts at the seams, with vegetables and eggs and other foodstuffs crammed into every available nook and cranny. If I'm lucky, the amount of food manages to get down to "only slightly overfull" before their next visit. And the problem isn't restricted to the refrigerator. I once cleared out some space in the garage, only to find that they decided to use that space to store <i>more food</i>. (Who knows, maybe one day I will return from an errand to find that my parking space has been filled with <i>still more food</i> while I was gone.)</p>
<p> Occasionally, a customer will ask for a way to design their program so it continues consuming RAM until there is only x% free. The idea is that their program should use RAM aggressively, while still leaving enough RAM available (x%) for other use. Unless you are designing a system where you are the only program running on the computer, this is a bad idea. </p>
<p> Consider what happens if two programs try to be "good programs" and leave x% of RAM available for other purposes. Let's call the programs Program&nbsp;10 (which wants to keep 10% of the RAM free) Program&nbsp;20 (which wants to keep 20% of the RAM free). For simplicity, let's suppose that they are the only two programs on the system. </p>
<p> Initially, the computer is not under memory pressure, so both programs can allocate all the memory they want without any hassle. But as time passes, the amount of free memory slowly decreases. </p>
<table border="1" bordercolor="black" cellpadding="3" style="border-collapse: collapse; width: 80%; text-align: center">
<tr>
<td colspan="20" style="width: 20%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (20%)</td>
<td colspan="60" style="width: 60%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (60%)</td>
<td colspan="20" style="width: 20%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (20%)</td>
</tr>
<tr>
<td colspan="30" style="width: 30%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (30%)</td>
<td colspan="40" style="width: 40%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (40%)</td>
<td colspan="30" style="width: 30%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (30%)</td>
</tr>
<tr>
<td colspan="40" style="width: 40%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (40%)</td>
<td colspan="20" style="width: 20%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (20%)</td>
<td colspan="40" style="width: 40%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (40%)</td>
</tr>
</table>
<p> And then we hit a critical point: The amount of free memory drops below 20%. </p>
<table border="1" bordercolor="black" cellpadding="3" style="border-collapse: collapse; width: 80%; text-align: center">
<tr>
<td colspan="41" style="width: 41%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (41%)</td>
<td colspan="18" style="width: 18%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (18%)</td>
<td colspan="41" style="width: 41%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (41%)</td>
</tr>
</table>
<p> At this point, Program&nbsp;20 backs off in order to restore the amount of free memory back to 20%. </p>
<table border="1" bordercolor="black" cellpadding="3" style="border-collapse: collapse; width: 80%; text-align: center">
<tr>
<td colspan="41" style="width: 41%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (41%)</td>
<td colspan="20" style="width: 20%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (20%)</td>
<td colspan="39" style="width: 39%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (39%)</td>
</tr>
</table>
<p> Now, each time Program&nbsp;10 and Program&nbsp;20 think about allocating more memory, Program&nbsp;20 will say "Nope, I can't do that because it would send the amount of free memory below 20%." On the other hand, Program&nbsp;10 will happily allocate some more memory since it sees that there's a whole 10% it can allocate before it needs to stop. And as soon as Program&nbsp;10 allocates that memory, Program&nbsp;20 will free some memory to bring the amount of free memory back up to 20%. </p>
<table border="1" bordercolor="black" cellpadding="3" style="border-collapse: collapse; width: 80%; text-align: center">
<tr>
<td colspan="42" style="width: 42%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (42%)</td>
<td colspan="19" style="width: 19%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (19%)</td>
<td colspan="39" style="width: 39%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (39%)</td>
</tr>
<tr>
<td colspan="42" style="width: 42%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (42%)</td>
<td colspan="20" style="width: 20%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (20%)</td>
<td colspan="38" style="width: 38%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (38%)</td>
</tr>
<tr>
<td colspan="43" style="width: 43%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (43%)</td>
<td colspan="19" style="width: 19%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (19%)</td>
<td colspan="38" style="width: 38%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (38%)</td>
</tr>
<tr>
<td colspan="43" style="width: 43%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (43%)</td>
<td colspan="20" style="width: 20%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (20%)</td>
<td colspan="37" style="width: 37%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (37%)</td>
</tr>
<tr>
<td colspan="44" style="width: 44%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (44%)</td>
<td colspan="19" style="width: 19%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (19%)</td>
<td colspan="37" style="width: 37%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (37%)</td>
</tr>
<tr>
<td colspan="44" style="width: 44%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (44%)</td>
<td colspan="20" style="width: 20%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (20%)</td>
<td colspan="36" style="width: 36%" bgcolor="#C0FFFF" nowrap>     <b>Program&nbsp;20</b> (36%)</td>
</tr>
</table>
<p> I think you see where this is going. Each time Program&nbsp;10 allocates a little more memory, Program&nbsp;20 frees the same amount of memory in order to get the total free memory back up to 20%. Eventually, we reach a situation like this: </p>
<table border="1" bordercolor="black" cellpadding="3" style="border-collapse: collapse; width: 80%; text-align: center">
<tr>
<td colspan="75" style="width: 75%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (75%)</td>
<td colspan="20" style="width: 20%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (20%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
</table>
<p> Program&nbsp;20 is now curled up in the corner of the computer in a fetal position. Program&nbsp;10 meanwhile continues allocating memory, and Program&nbsp;20, having shrunk as much as it can, is forced to just sit there and whimper. </p>
<table border="1" bordercolor="black" cellpadding="3" style="border-collapse: collapse; width: 80%; text-align: center">
<tr>
<td colspan="76" style="width: 76%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (76%)</td>
<td colspan="19" style="width: 19%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (19%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="77" style="width: 77%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (77%)</td>
<td colspan="18" style="width: 18%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (18%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="78" style="width: 78%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (78%)</td>
<td colspan="17" style="width: 17%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (17%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="79" style="width: 79%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (79%)</td>
<td colspan="16" style="width: 16%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (16%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="80" style="width: 80%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (80%)</td>
<td colspan="15" style="width: 15%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (15%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="81" style="width: 81%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (81%)</td>
<td colspan="14" style="width: 14%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (14%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="82" style="width: 82%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (82%)</td>
<td colspan="13" style="width: 13%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (13%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="83" style="width: 83%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (83%)</td>
<td colspan="12" style="width: 12%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (12%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="84" style="width: 84%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (84%)</td>
<td colspan="11" style="width: 11%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (11%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
<tr>
<td colspan="85" style="width: 85%" bgcolor="#FFC0FF" nowrap>     <b>Program&nbsp;10</b> (85%)</td>
<td colspan="10" style="width: 10%" bgcolor="#C0C0C0" nowrap>     <b>Free</b> (10%)</td>
<td colspan="5" style="width: 5%" bgcolor="#C0FFFF" nowrap>     <font size="-2"><b>P20</b> (5%)</font></td>
</tr>
</table>
<p> Finally, Program&nbsp;10 stops allocating memory since it has reached its own personal limit of not allocating the last 10% of the computer's RAM. But it's too little too late. Program&nbsp;20 has already been forced into the corner, thrashing its brains out trying to survive on only 5% of the computer's memory. </p>
<p> It's sort of like when people from two different cultures with different concepts of <i>personal space</i> have a face-to-face conversation. The person from the not-so-close culture will try to back away in order to preserve the necessary distance, while the person from the closer-is-better culture will move forward in order to close the gap. Eventually, the person from the not-so-close culture will end up with his back against the wall anxiously looking for an escape route. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (52)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-960943">
				<div id="div-comment-960943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zan Lynx</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-960943">
			January 18, 2012 at 7:12 am</a>		</div>

		<p>It is a tricky problem. Your illustrations make the point very clear.</p>
<p>It still needs to be solved somehow though. There are programs (cough. web browsers. cough.) that can usefully use nearly unlimited amounts of RAM. (Predicatively fetch and render all the web pages you might decide to click on next? Sure!)</p>
<p>I suppose my solution would be to look at the total RAM of the system and pick a cache size based on that. I&#39;d also make it user or administrator configurable. It is probably the best you can do.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-960953">
				<div id="div-comment-960953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-960953">
			January 18, 2012 at 7:16 am</a>		</div>

		<p>Is there any solution to the problem which doesn&#39;t run into this issue? The problem being that I want a cache fitting into memory but can give some up to other programs if they need to? I guess the operating system should take the role of a negotiator.</p>
<p>I heared SQL server does something like this, interacting closely with the OS. Also I observed something similar with the .NET GC: after allocating/freeing a lot large objects the used memory (as seen in task manager and resource monitor) was large and only after starting another memory-hungry program the GC was eager to give back unused memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-960963">
				<div id="div-comment-960963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Crowell</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-960963">
			January 18, 2012 at 7:42 am</a>		</div>

		<p>Zarat,</p>
<p>The answer is to ask for whatever memory you need, not base it on how much is free.</p>
<p>I know any kind of caching needs to be smarter. &nbsp;SQL Server does some caching that can eat up memory, but I doubt they are using anything as naive as leave x% free. &nbsp;I doubt Raymond knows what SQL is doing, as he doesn&#39;t work on the SQL team.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-960973">
				<div id="div-comment-960973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy O'Neal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-960973">
			January 18, 2012 at 7:43 am</a>		</div>

		<p>I&#39;ve seen tools like &quot;RAMIdle&quot; and &quot;CacheMan&quot; which might want to do something like this &#8212; though their function was to force apps that were not being used out to the page file.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-960983">
				<div id="div-comment-960983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-960983">
			January 18, 2012 at 7:50 am</a>		</div>

		<p>Rather than having the strategy of &quot;always allow x% free&quot;, it&#39;s better to have the strategy of &quot;never allocate more than (100-x)%&quot;. That way you won&#39;t ever consume all the memory in the system, but large programs won&#39;t fight over it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-960993">
				<div id="div-comment-960993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">MPage</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-960993">
			January 18, 2012 at 7:51 am</a>		</div>

		<p>In contrast, there are programs I&#39;ve encountered such as XWidget (<a rel="nofollow" target="_new" href="http://xwidget.com/" rel="nofollow">http://xwidget.com/</a>) that try to &quot;minimize&quot; (quotes intended) memory usage by using &#39;SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T)-1, (SIZE_T)-1)&#39;. Their attempts are, of course, futile as the OS is surely smarter than them in memory management. A post on why one shouldn&#39;t use SetProcessWorkingSetSize (normally) would be nice.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961003">
				<div id="div-comment-961003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marco Schramp</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961003">
			January 18, 2012 at 7:52 am</a>		</div>

		<p>Most application use a even more naive approach: simply put a fixed cap on memory usage (that&#39;s how the Java VM does it: just set a max, SQL server does just the same). This still allows for overcommiting of memory, but at least it&#39;s a bit more controled than the example Raymond has given.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961013">
				<div id="div-comment-961013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim Lyon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961013">
			January 18, 2012 at 8:06 am</a>		</div>

		<p>I prefer to use the combination of what Marco recommends and what Raymond disrecommends: A program that is a major memory consumer should not allocate more than x% of the total memory, nor should it leave less than y% free.</p>
<p>Still not perfect, but not quite as obnoxious as either strategy alone.</p>
<p>Of course, the best idea yet is to try to run the memory hogs one at a time. It&#39;s hard to do this perfectly too, but depending on the situation is often worth trying.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961073">
				<div id="div-comment-961073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961073">
			January 18, 2012 at 8:15 am</a>		</div>

		<p>Yes, SQL server does something stupid as x% free. The admin limit doesn&#39;t always work.</p>
<p>It seems the only reliable way of dealing with it is to run a 32 bit machine with &gt;&gt; 4GB ram. SQL server is then forced to stop at 3GB, leaving plenty for everybody else.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961083">
				<div id="div-comment-961083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wladimir Palant</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961083">
			January 18, 2012 at 8:31 am</a>		</div>

		<p>@D-Coder: I guess that you are not married. Some things really aren&#39;t worth risking your happy marriage over. Yes, offending your in-laws does create tension in the family and maybe you want to skip on it this time.</p>
<div class="post">[<i>D-Coder seems to prefer the nuclear option. &quot;My brother will sometimes borrow my dremel and not return it for a long time, so I told him to piss of and I never wanted to see him again. Problem solved.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961093">
				<div id="div-comment-961093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961093">
			January 18, 2012 at 8:42 am</a>		</div>

		<p>I agree with the gist of what @GWO is saying. &nbsp;This approach is especially silly with a modern operating system that would page out some of those allocations when memory becomes tight. &nbsp;I find that when people come up with voodoo like this it&#39;s usually because they have a poor understanding of how the overall system works (like the mistaken notion that the system&#39;s globally available is meaningful to a user mode application).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961113">
				<div id="div-comment-961113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961113">
			January 18, 2012 at 9:14 am</a>		</div>

		<p>@Joshua: I guess we have different definitions of &quot;stupid&quot;. Since SQL Server, 99.9% of the time, is the only process running on a machine dedicated to running it, I&#39;m ok with it doing whatever the heck it wants with memory.</p>
<p>If you need to run SQL Server but also leave a lot of free memory&#8211; well, then get your workplace to set up a SQL Server for development work, because there&#39;s no reason you should need that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961123">
				<div id="div-comment-961123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961123">
			January 18, 2012 at 9:20 am</a>		</div>

		<p>Zarat suggested: &quot;I guess the operating system should take the role of a negotiator.&quot;</p>
<p>You could place &quot;discardable&quot; data in the memory that is mapped to a file-mapping object. The OS cache manager can then decide when to keep that data in real RAM or let it fall back to the disc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961143">
				<div id="div-comment-961143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961143">
			January 18, 2012 at 9:38 am</a>		</div>

		<p>I just wish non-OS programmers would stop thinking that they&#39;re somehow in charge of such things. &nbsp;Clue: You&#39;re NOT.</p>
<p>This is an OS/System domain issue, not an application-domain issue.</p>
<p>Rule: Use exactly what you need, and no more. &nbsp;Your users will thank you.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961153">
				<div id="div-comment-961153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961153">
			January 18, 2012 at 9:40 am</a>		</div>

		<p>It seems like a decent solution to this is if OSes provided a way to say &quot;take this memory first! and you don&#39;t need to page it out, just discard it&quot;. Do they?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961163">
				<div id="div-comment-961163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961163">
			January 18, 2012 at 9:40 am</a>		</div>

		<p>Isn&#39;t this pretty much what .NET&#39;s generational garbage collector does? &nbsp;&quot;Keep allocating memory and never clean anything up until you run into memory pressure.&quot; &nbsp;Only it does it automatically and it&#39;s built into the runtime, so you can&#39;t tell it not to.</p>
<p>I&#39;ve been saying for years that such a system makes your program a bad neighbor on any modern, multitasking computer. &nbsp;Thanks for writing this!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961173">
				<div id="div-comment-961173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961173">
			January 18, 2012 at 9:52 am</a>		</div>

		<p>@James Schend: Experiments indicate I can get much better performance by stacking APP and SQL servers on a single big enough box if I can keep SQL Server from hogging all the RAM.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961183">
				<div id="div-comment-961183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mason Wheeler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961183">
			January 18, 2012 at 9:56 am</a>		</div>

		<p>@Joshua: Yeah, that makes sense if your app server needs to talk to the database a lot. &nbsp;The network overhead, even for just having one computer on a LAN talk to another, can be non-trivial, and eliminating it will definitely speed things up, if done right.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961193">
				<div id="div-comment-961193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961193">
			January 18, 2012 at 9:58 am</a>		</div>

		<p>@JM: Sorry, but I have documented cases of chewing 1.5GB on 512MB limit when SQL had been idle for an hour (dev workstation). The condition is real.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961203">
				<div id="div-comment-961203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961203">
			January 18, 2012 at 10:12 am</a>		</div>

		<p>@Mason Wheeler</p>
<p>You confuse running into &quot;internal&quot;, self-induced memory pressure with running into system-wide memory pressure. GC typically (OK, I can&#39;t speak to .Net&#39;s specifically) acts a lot more like some of the other suggestions in the responses, where you set a max heap size and the system will GC when its memory usage approaches that regardless of what the rest of the system is doing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961213">
				<div id="div-comment-961213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961213">
			January 18, 2012 at 11:14 am</a>		</div>

		<p>It&#39;s too bad there&#39;s no memory manager function called &quot;HowMuchMemoryCanIReasonablyUse&quot;. Obviously, to use this API you&#39;d have to call it periodically because there&#39;s no static answer, but it would leave this idiocy to the entity best positioned to perform it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-961223">
				<div id="div-comment-961223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961223">
			January 18, 2012 at 11:36 am</a>		</div>

		<p>For large applications, it should be OK to be able to tell them how much memory they can consume. As long as they don&#39;t try to be smart and try to figure that behind your back. &quot;Smart&quot; applications doing things behind your back is one of biggest pet peeves of mine. Inevitably, they end up being stupid.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961243">
				<div id="div-comment-961243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Peter</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961243">
			January 18, 2012 at 11:45 am</a>		</div>

		<p>I agree with Zarat. &nbsp;It would be really nice if Windows had an API to create in-memory caches. &nbsp;The basic idea is that Windows would promise not to page out the memory but might change the size on you. &nbsp;The devil&#39;s in the details, of course.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961253">
				<div id="div-comment-961253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nawak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961253">
			January 18, 2012 at 11:57 am</a>		</div>

		<p>What if two Amazon Sellers did this?</p>
<p><a rel="nofollow" target="_new" href="http://www.michaeleisen.org/blog/?p=358" rel="nofollow">http://www.michaeleisen.org/blog</a></p>
<div class="post">[<i>That is awesome. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961263">
				<div id="div-comment-961263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/jas71_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>jas71@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961263">
			January 18, 2012 at 12:08 pm</a>		</div>

		<p>(Nice diagrams, Raymond, thanks!)</p>
<p>Wladimir has a point: even a guy with the social skills of a thermonuclear device will probably balk at the idea of chucking away gifts from family and admitting to it.</p>
<p>Some applications &#8211; the Varnish webcache for one &#8211; uses essentially the approach Ken Hagan suggests: your cache is an admin-defined size of file on disk, memory-mapped. The operating system itself will then page bits of that in and out as needed, depending on how busy those pages are and how much load there is from other applications. Trying to achieve the same manually &#8211; having separate disk and memory caches, plus code and some OS monitoring &#8211; amounts to reinventing the wheel.</p>
<p>@jalf: the &#39;free&#39; memory will never be &#39;completely unused&#39; except shortly after boot, since the NT kernel has used all &#39;unused&#39; memory pages for disk caching all along. (Give or take the handful kept around as pre-zeroed pages for new allocations, anyway.) Just because it isn&#39;t used by an application doesn&#39;t mean it goes to waste!</p>
<p>Remember, SQL Server ships as part of the Small Business Server product, intended to share a machine with Exchange, file/print/domain services and the other bits, only the Premium SKU adding the option of putting SQL Server on a second machine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961283">
				<div id="div-comment-961283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">&#198;ro</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961283">
			January 18, 2012 at 12:51 pm</a>		</div>

		<p>@Steve Wolf But how do you define how much memory you &quot;need&quot;? For example, should a web browser cache 20% more elements in RAM if that means it&#39;s 15% faster? How about 25% faster?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-961293">
				<div id="div-comment-961293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961293">
			January 18, 2012 at 12:58 pm</a>		</div>

		<p>A potential solution to the in-law problem is to put a second refrigerator in the garage for their use.</p>
<div class="post">[<i>They&#39;ve already suggested that we get a second refrigerator in the garage because the existing one is too small. All that would happen is that they would fill up the second one, too! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961303">
				<div id="div-comment-961303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961303">
			January 18, 2012 at 1:06 pm</a>		</div>

		<p>@Joshua: it&#39;s possible for an SQL Server to consume 1.5 GB with a buffer pool of only 512 MB. The article I linked to gives some hints on why this might be. Query plans, thread stacks and other internal objects all consume memory that doesn&#39;t count towards the buffer pool limit. However, if you&#39;re consuming 1 GB of memory not in the buffer pool, I would take a hard look at both your SQL Server version and what your clients are doing, because that&#39;s pretty extreme.</p>
<p>There is in any case no percentage-based allocation involved in SQL Server&#39;s strategy. Having said that, there is also no &quot;please don&#39;t consume more than X MB of memory absolutely&quot; setting either &#8212; &quot;max server memory&quot;, despite its name, is not this, and should have been named &quot;max buffer pool size&quot; instead. Also, note that SQL Server follows the First Rule of Acquisition: once you have their memory, you never give it back. If it&#39;s using 512 MB of buffer pool and the machine itself is not out of memory, it will never voluntarily shrink it no matter how long it idles. In order to force it to relinquish memory, you have to reduce the &quot;max server memory&quot; setting and then issue a DBCC DROPCLEANBUFFERS command. This will still not shrink memory not allocated to the buffer pool &#8212; DBCC FREESYSTEMCACHE will free some of it but not all of it (memory tied up in thread stacks can obviously not be returned, for example).</p>
<p>If you have a documented case of SQL Server persistently consuming more than X MB of buffer pool, with X the maximum amount of memory you configured, file a bug on Connect. That&#39;s not supposed to happen in any case, unless you&#39;re doing some really awful things to the machine that prevent SQL Server from even deallocating memory. You can use the sys.dm_os_buffer_descriptors DMV to get the size of the buffer pool.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961313">
				<div id="div-comment-961313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961313">
			January 18, 2012 at 1:17 pm</a>		</div>

		<p>@JM: I listed idle time so you would understand it had no clients connected. The machine would periodically run out of RAM until SQL server was restarted.</p>
<p>Never saw the behavior after replacing the machine with a new one.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-961343">
				<div id="div-comment-961343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961343">
			January 18, 2012 at 4:07 pm</a>		</div>

		<blockquote><p>
  All that would happen is that they would fill up the second one, too!
</p></blockquote>
<p>Right; the suggestion would only work if you could convince them to limit themselves to only one of the refrigerators. &nbsp;They might complain that there&#39;s not enough room in only one refrigerator for all of the food they want to buy. &nbsp;You would then nod, and say &quot;Exactly.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961023">
				<div id="div-comment-961023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961023">
			January 18, 2012 at 8:10 am</a>		</div>

		<p>@David: Requesting the memory you want is not a good solution for server (and some desktop) applications. They have a minimum set to run reasonably but can run better the more memory they get for caching *as long as this memory is not swapped to disk*. Overcommitting is plain stupid because once you start swapping too much the cache has no purpose anymore and you want to reduce the size. That is what I&#39;ve read SQL server does and what I observed with .NET GC.</p>
<p>I know the naive approach from the post is going nowhere, and I know Raymond doesn&#39;t know what SQL server does; I didn&#39;t ask about that.</p>
<p>Ideally I&#39;d want the OS to coordinate the distribution of free memory among applications which can make use of it, because anything else is a custom solution which not everyone can be aware of. But everyone can be aware of the OS they run on ;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961043">
				<div id="div-comment-961043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">D-Coder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961043">
			January 18, 2012 at 8:12 am</a>		</div>

		<p>It&#39;s *your* refridgerator.</p>
<p>After they leave, throw out whatever food you least want until you&#39;re happy (yep! it&#39;s garbage collection!).</p>
<p>If they ask what happened to the food, politely tell them. &nbsp;They will be so horrified that they will think before doing it again. &nbsp;Or, in the worst case, they&#39;ll stop coming over, which also solves your problem (yep! refridgerator overflow crash!).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-dwalker-wk even thread-even depth-1" id="comment-961053">
				<div id="div-comment-961053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/DWalker' rel='external nofollow' class='url'>DWalker</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961053">
			January 18, 2012 at 8:13 am</a>		</div>

		<p>The program that wanted to allocate memory until x% is free would work *only* if it was the only program doing that. &nbsp;Some programmers think they are clever, and they don&#39;t consider that maybe another program is doing the same thing. &nbsp;They are also assuming that the rest of the system is stable in its memory requirements. &nbsp;If that were really true for a given system, then *perhaps* one system could allocate memory until x% was free.</p>
<p>The flawed assumption, as Raymond&#39;s illustrations show very well, is that if two programs do this, the results are terrible. &nbsp;That&#39;s why the question &quot;what if two programs did this&quot; is always a good one to ask. &nbsp;(Such as with programs wanting to be &quot;topmost&quot;.)</p>
<p>I&#39;m not sure you can solve the problem like Jim suggests, by saying &quot;don&#39;t leave less than y% free&quot;. &nbsp;Why not? &nbsp;If all programs did that, then some of the expensive memory that you paid for would be wasted, since no program would allocate it.</p>
<p>Maybe, if every program would let you hint how much memory it should take, you could carefully tune your whole system. &nbsp;But that would be tedious and subject to change.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961063">
				<div id="div-comment-961063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GWO</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961063">
			January 18, 2012 at 8:15 am</a>		</div>

		<p>My general principle for this is : &quot;Whoever wrote the OS allocator / swap algorithm is *way* more experienced than I am at balancing OS / app working set / and filesystem cache than I am&quot; the core algorithms have been stress tested under more general workloads than I can even imagine. Further, any optimising I do based on &quot;I know best how this app will be used&quot; will be invalidated the first time anyone other than me uses it, and probably before then.</p>
<p>Jackons&#39;First and Second Rules of Program Optimisation hold</p>
<p>i) Don’t do it.</p>
<p>ii) (For experts only!): Don’t do it yet.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961103">
				<div id="div-comment-961103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jalf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961103">
			January 18, 2012 at 8:58 am</a>		</div>

		<p>&quot;I prefer to use the combination of what Marco recommends and what Raymond disrecommends: A program that is a major memory consumer should not allocate more than x% of the total memory, nor should it leave less than y% free.&quot;</p>
<p>Huh, so an application which can actually benefit from an infinite amount of memory *is going to leave a significant amount of memory on the system entirely unused*</p>
<p>Yeah, that&#39;s clever. Everyone knows you get the best performance when you don&#39;t use the resources at your disposal.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-961353">
				<div id="div-comment-961353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961353">
			January 18, 2012 at 5:28 pm</a>		</div>

		<p>Although part of me wants to suggest that you keep buying them refrigerators until either they say &quot;that&#39;s enough&quot; or you hit some unavoidable space/electrical limit&#8230; just as a sociological experiment.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961133">
				<div id="div-comment-961133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961133">
			January 18, 2012 at 9:33 am</a>		</div>

		<p>@Joshua: I call bollocks on that, sorry. The total amount of memory SQL Server consumes *can* go over the limit, but this is because the limit only limits the buffer pool and SQL Server has other memory to manage too. See <a rel="nofollow" target="_new" href="http://blogs.technet.com/b/askperf/archive/2008/03/25/lock-pages-in-memory-do-you-really-need-it.aspx" rel="nofollow">blogs.technet.com/&#8230;/lock-pages-in-memory-do-you-really-need-it.aspx</a> for an in-depth look (this talks about locked pages, but discusses how the memory settings for SQL Server work). It definitely does not work on percentages &#8212; even if no limit is specified, SQL Server will try to keep a constant amount of memory free (not a percentage) and, in fact, it will rely on Windows to tell it when the high memory watermark has been reached (so the value used is consistent across other applications that do the same).</p>
<p>Running 32-bit on a machine with lots of memory is throwing out the baby with the bathwater. It is true that SQL Server is meant to be the only app on the machine. If you want to run multiple SQL servers, you can, but this requires planning ahead. Running SQL Server alongside a different memory-hogging application (like Analysis Services) is best done by fixing the amount of memory each uses and leaving it at that &#8212; dynamic configuration will not run into the pathological scenario Raymond describes if all applications agree on the amount of memory should be left available, but that&#39;s a big if. </p>
<p>The alternate solution on really big hardware is to use virtualization (obviously a more complicated solution, which however also brings benefits of maintenance). As far as memory goes, though, this is almost the same solution as fixing the amount of memory each app uses (as the virtual machine has an upper limit too).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-961363">
				<div id="div-comment-961363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961363">
			January 18, 2012 at 6:17 pm</a>		</div>

		<p>As long as &quot;program 20&quot; has set a &quot;minimum limit&quot; on memory be freed for relief memory pressure, what&#39;s &quot;the bad&quot; be done to &quot;program 20&quot;?</p>
<p>Btw, this graph make me think that those &quot;make memory by allocating huge space to force other programs to give their share out&quot; type of programs have use afterall. :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961323">
				<div id="div-comment-961323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961323">
			January 18, 2012 at 1:24 pm</a>		</div>

		<p>@Joshua: OK &#8212; anomaly then. It wasn&#39;t clear from your post that it had *never* seen client connections. Once clients *have* connected, even if they&#39;re long since disconnected, memory may still be allocated (because, after all, you never know when new clients will drop by who need exactly that data).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-961383">
				<div id="div-comment-961383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961383">
			January 19, 2012 at 2:13 am</a>		</div>

		<p>Regarding the food problem, I think if they bring too much food, it&#39;s only logical to share some of them to your best neighbours. From time to time, you might be able to get some food when you &quot;perhep much larger now&quot; fridge feels a little empty. :P</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961393">
				<div id="div-comment-961393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961393">
			January 19, 2012 at 4:22 am</a>		</div>

		<p>I suspect the discardable memory features built in to Windows are rarely used. (The obvious case of which I am aware is the discardable bitmap used for windows with the CS_SAVEBITS class style.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961403">
				<div id="div-comment-961403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdbsd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961403">
			January 19, 2012 at 5:57 am</a>		</div>

		<p>@Ray Trent: What exactly is &quot;reasonable use&quot;? You can reasonably use all of the available memory. It&#39;s there for you, if you need it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961443">
				<div id="div-comment-961443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Larry Hosken</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961443">
			January 19, 2012 at 7:11 am</a>		</div>

		<p>cheong00&#39;s onto something. When your in-laws leave, you might want to hold an Iron Chef contest/potluck party. Early on some Saturday, you divvy up the left-behind food amongst some friends. That evening, they need to bring back dishes they cooked that incorporates that food. Then comes a dinner party/contest judging.</p>
<p>Heck, maybe don&#39;t wait until the in-laws leave. They probably bring food that they like to cook with. They might do well in the contest and thus feel happy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961503">
				<div id="div-comment-961503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skyborne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961503">
			January 19, 2012 at 7:46 am</a>		</div>

		<blockquote><p>
  swapping to a local file
</p></blockquote>
<p>And by that I actually mean a &quot;private&quot; file, but that brings up another point: what if your cache is accidentally on a network filesystem?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961663">
				<div id="div-comment-961663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lefty</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961663">
			January 19, 2012 at 1:46 pm</a>		</div>

		<p>Clearly the solution to this problem is to set your memory threshold level at something like 5% so you end up shutting out both Program A and Program B. As the author of Program C, I sure don&#39;t care about their performance.</p>
<p>And the solution to Raymond&#39;s &#39;too much food&#39; problem is to send the in-laws to my place. &nbsp;I love free food (maybe not fish eyes, though).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961493">
				<div id="div-comment-961493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Skyborne</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961493">
			January 19, 2012 at 7:44 am</a>		</div>

		<p>@Ken Hagan, I was thinking along those same lines, but it seems like Program 20 wants *discard* under pressure to implement a weak cache (and probably some strong-&gt;weak cache management in-app so that the entire cache doesn&#39;t drop and cause thrashing as it gets re-populated and immediately re-dropped under continuing pressure), but everything I know of (esp. on linux) creates *swap* under pressure behavior.</p>
<p>mmap is actually worse, because you get swapping to a local file, maybe on volume manager / encryption / software raid / an ssd that the user doesn&#39;t actually want you swapping your cache to all the time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961793">
				<div id="div-comment-961793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Danny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961793">
			January 20, 2012 at 2:50 am</a>		</div>

		<p>Ray, isn&#39;t this just another variation of walls and ladders game with a twist?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-961843">
				<div id="div-comment-961843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SheepNine</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961843">
			January 20, 2012 at 7:30 am</a>		</div>

		<p>Is it mere coincidence that it is the BLUE process whimpering fetally in the corner while the PINK process proceeds to consume huge swaths of available RAM?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-961923">
				<div id="div-comment-961923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">user</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-961923">
			January 20, 2012 at 9:13 am</a>		</div>

		<p>I hope IE guys read your blog.</p>
<p>As I&#39;m writing this there ar three iexplorer processes on my machine consuming 48, 7 and 32 mb of memory for keeping 4 tabs open, 3 from your weblog and one for that amazon thing, let&#39;s close that amazon tab &#8230; hmm the first process releases 4mb of memory, let&#39;s close a tab from your weblog &#8230; another 8 mb released. now IE is consuming almost 75 mb of memory just to display two pages of your blog.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962123">
				<div id="div-comment-962123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">640k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-962123">
			January 21, 2012 at 2:53 am</a>		</div>

		<p>2 refrigerators is enough for everyone.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-962163">
				<div id="div-comment-962163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Hear</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-962163">
			January 21, 2012 at 12:10 pm</a>		</div>

		<p>It reminds me of a time I couldn&#39;t hear what someone was saying, so I came closer and told him to repeat, so he spoke again, but more silently (since I was closer).</p>
<p>I couldn&#39;t hear him again, so I got even closer&#8230; (guess what he did)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-962263">
				<div id="div-comment-962263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kirill</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20120118-00/?p=8513#comment-962263">
			January 23, 2012 at 4:51 am</a>		</div>

		<p>As long as my program is &quot;Program 10&quot;, I don&#39;t see what the problem is&#8230;</p>
<p>*trollface*</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

