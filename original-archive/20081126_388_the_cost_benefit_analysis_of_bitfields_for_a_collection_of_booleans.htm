<html>
<head>
<title>The cost-benefit analysis of bitfields for a collection of booleans</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The cost-benefit analysis of bitfields for a collection of booleans</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 26, 2008 / year-entry #389</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>68</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">How many of them are there?</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Consider a class with
a bunch of <code>BOOL</code> members:
</p>
<pre>
// no nitpicking over BOOL vs bool allowed
class Pear {
 ...
 BOOL m_peeled;
 BOOL m_sliced;
 BOOL m_pitted;
 BOOL m_rotten;
 ...
};
</pre>
<p>
You might be tempted to convert the <code>BOOL</code> fields
into bitfields:</p>
<pre>
class Pear {
 ...
 BOOL m_peeled:1;
 BOOL m_sliced:1;
 BOOL m_pitted:1;
 BOOL m_rotten:1;
 ...
};
</pre>
<p>
Since a <code>BOOL</code> is typedef'd as <i>INT</i> (which on
Windows platforms is a signed 32-bit integer),
this takes sixteen bytes and packs them into one.
That's a 93% savings!
Who could complain about that?
</p>
<p>
How much did that savings cost you, and how much did you save anyway?
</p>
<p>
Let's look at the cost of that savings.
Code that updated the plain <code>BOOL</code>
<code>m_sliced</code> member could do it by simply storing the result
into the member.
Since it was a normal field,
this could be accomplished directly:
</p>
<pre>
  mov [ebx+01Ch], eax ; m_sliced = sliced
</pre>
<p>
On the other hand, when it's a bitfield, updating it becomes trickier:
</p>
<pre>
  add eax, eax        ; shift "sliced" into the correct position
  xor eax, [ebx+01Ch] ; merge "sliced" with other bits
  and eax, 2
  xor [ebx+01Ch], eax ; store the new bitfield
</pre>
<p>
<b>Exercise</b>: Figure out how the above trick works.
</p>
<p>
Converting a <code>BOOL</code> to a single-bit field saved three bytes
of data but cost you eight bytes of code when the member is assigned
a non-constant value.
Similarly, extracting the value gets more expensive.
What used to be
</p>
<pre>
 push [ebx+01Ch]      ; m_sliced
 call _Something@4    ; Something(m_sliced);
</pre>
<p>
becomes
</p>
<pre>
 mov  ecx, [ebx+01Ch] ; load bitfield value
 shl  ecx, 30         ; put bit at top
 sar  ecx, 31         ; move down and sign extend
 push ecx
 call _Something@4    ; Something(m_sliced);
</pre>
<p>
The bitfield version is bigger by nine bytes.
</p>
<p>
Let's sit down and do some arithmetic.
Suppose each of these bitfielded fields is accessed six times
in your code, three times for writing and three times for reading.
The cost in code growth is approximately 100 bytes.
It won't be exactly 102 bytes because the optimizer may be able
to take advantage of values already in registers for some operations,
and the additional instructions may have hidden costs in terms of
reduced register flexibility.
The actual difference may be more, it may be less, but for a
back-of-the-envelope calculation let's call it 100.
Meanwhile,
the memory savings was 15 byte per class.
Therefore, the breakeven point is seven.
If your program creates fewer than seven instances of this class,
then the code cost exceeds the data savings: Your memory optimization
was a memory de-optimization.
</p>
<p>
Even if you manage to come out ahead in the accounting ledger,
it may be a win of just a few hundred bytes.
That's an awful lot of extra hassle to save a few hundred bytes.
All somebody has to do is add an icon to a dialog box and your
savings will vanish.
</p>
<p>
When I see people making these sorts of
<a HREF="http://blogs.msdn.com/tonyschr/archive/2006/01/24/517088.aspx">
micro-optimizations</a>,
sometimes I'll ask them,
"How many instances of this class does the program create?"
and sometimes the response will be,
"Oh, maybe a half dozen. Why do you ask?"
</p>
<p>
But wait, there's more.
Packing all these members into a bitfield has other costs.
You lose the ability to set a hardware write breakpoint on a specific bit,
since hardware breakpoints are done at the byte level (at a minimum).
You also lose atomicity:
An update to <code>m_sliced</code> will interfere with a simultaneous
update to <code>m_peeled</code> on another thread,
since the update process merges the two values and stores the result
non-atomically.
(Note that you also lose atomicity if you had used a byte-sized
<code>bool</code> instead of a 32-bit <code>BOOL</code> because some CPU
architectures such as the original Alpha AXP cannot access memory
in units smaller than a <code>DWORD</code>.)
</p>
<p>
These are just a few things to take into account when considering
whether you should change your fields to bitfields.
Sure, bitfields save data memory, but you have to balance it
against the cost in code size, debuggability, and reduced multithreading.
If your class is going to be instantiated only a few times
(and by "a few" I'm thinking less than a few thousand times),
then these costs most likely exceed the savings.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (68)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-nathan_works even thread-even depth-1" id="comment-687133">
				<div id="div-comment-687133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/nathan_works' rel='external nofollow' class='url'>nathan_works</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687133">
			November 26, 2008 at 10:14 am</a>		</div>

		<p>With the multi-threading and the second setup, no locking occurs unless the author codes in the locking ? Interesting. Wouldn&#8217;t have considered that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687143">
				<div id="div-comment-687143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687143">
			November 26, 2008 at 10:39 am</a>		</div>

		<p>A further problem is that this optimization might silently break your code.</p>
<p>If sliced is (say) 8 then &quot;m_sliced = sliced&quot; will correctly set m_sliced to TRUE in the first class, but will set m_sliced to FALSE in the bit field version.</p>
<p>In other words, you can&#8217;t reliably assign a BOOL to a bit field.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687153">
				<div id="div-comment-687153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687153">
			November 26, 2008 at 10:48 am</a>		</div>

		<p>Exercise: all but the second bit get set to 0 from the and instruction and then get set to the original bit values on the second xor. &nbsp;The second bit (m_sliced) gets set to ((sliced ^ m_sliced) ^ m_sliced) = sliced, since xor is associative and x^x = 0 for all x.</p>
<p>I would have implemented that taking the original value, and&#8217;ing by ~2, and or&#8217;ing by (sliced &lt;&lt; 1) &amp; 2, but then I realized that doing so would have required an extra register. &nbsp;Even if an extra register is available, I&#8217;m not convinced my code would be faster than yours.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687163">
				<div id="div-comment-687163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687163">
			November 26, 2008 at 10:54 am</a>		</div>

		<p>There&#8217;s simplier &#8220;micro-optimization&#8221;, with no major issue: Use 8-bits BYTE rather than 32-bits BOOL.</p>
<p>IMO, even for as few as 256 (very-frequently accessed) elements, it might be worth.</p>
<p>1 KiB istiny, but it might save enough L1 data cache to give a small performance boost.</p>
<p>For example: The EeePC has only 32KiB of L1 cache and maybe as small as 16KiB of data cache.</p>
<div class=post>[<i>I already called out a major issue of using BYTEs in the article: Not all CPU architectures are byte-addressible. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687173">
				<div id="div-comment-687173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frederik Slijkerman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687173">
			November 26, 2008 at 11:03 am</a>		</div>

		<p>I agree that usually bitfields aren&#8217;t worth the trouble, except perhaps when you need to store a huge amount of bits in an array.</p>
<p>You say &#8220;takes sixteen bytes and packs them into one&#8221; &#8212; shouldn&#8217;t this be 32, since there are 32 bits in BOOL?</p>
<div class=post>[<i>Actually we&#8217;re both wrong. It should be &#8220;packs 32 bytes into 4.&#8221; Math is hard&#8230; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687183">
				<div id="div-comment-687183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pierre B.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687183">
			November 26, 2008 at 11:16 am</a>		</div>

		<p>Another way you lose when using bit fields is that you can often simplify code by converting the discrete BOOL into an array which let you easily apply a given algorithm to each field in loops. No looping possible over bit fields.</p>
<p>(For example, you can have an array of UI elements corresponding to the array of BOOL and update all UI easily, of enable / disable UI based on BOOL, save the BOOL to persistent data, etc.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687193">
				<div id="div-comment-687193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687193">
			November 26, 2008 at 11:19 am</a>		</div>

		<p>@Frederik Slijkerman:</p>
<p>32 bits = 4 bytes.</p>
<p>4 bytes * 4 = 16 bytes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687203">
				<div id="div-comment-687203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687203">
			November 26, 2008 at 11:26 am</a>		</div>

		<p>I&#8217;ve never seen bit fields as a way to save data memory. Only time that I have used them (when its not because I&#8217;m just really tight on RAM) is when mapping to hardware; reading a stream of bytes into a struct with bit fields in order to be able to access individual bits, nibbles and even two- and three-bit values by logical names without using (manual) masks and shifts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687213">
				<div id="div-comment-687213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.pretentiousname.com' rel='external nofollow' class='url'>Leo Davidson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687213">
			November 26, 2008 at 11:33 am</a>		</div>

		<p>It&#8217;s also worth remembering that (simplifying things drastically) structures can &nbsp;add padding after their members that are not 32-bits wide so using smaller built-in types doesn&#8217;t always have much/any benefit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687223">
				<div id="div-comment-687223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">jondr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687223">
			November 26, 2008 at 12:02 pm</a>		</div>

		<p>&quot;Premature optimization is the root of all evil.&quot; &nbsp;&#8212; Donald Knuth</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687243">
				<div id="div-comment-687243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687243">
			November 26, 2008 at 12:28 pm</a>		</div>

		<p>laonianren: not if you use bool instead of BOOL. Or you can normalize the value to a C boolean (int with value 0 or 1) with the !! operator</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687253">
				<div id="div-comment-687253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Phill</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687253">
			November 26, 2008 at 12:30 pm</a>		</div>

		<p>The only time I&#8217;ve ever considered (and done) this was when writing a server for sending a file using UDP multicast to many recipients.</p>
<p>It seperated the file into packets and assigned each a sequence number. When a recipient acknowledged receipt of the packet it flipped a bit in a byte array.</p>
<p>It was faster and had a smaller footprint than using an array of booleans or ints, etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687263">
				<div id="div-comment-687263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687263">
			November 26, 2008 at 12:44 pm</a>		</div>

		<p>I&#8217;m currently working on optimizing a program that has to worry about such things as L1 and L2 caches. &nbsp;Packing data can have significant performance boosts when you find yourself (unfortunately) jumping all around memory. &nbsp;But fixing the original problem of jumping all around memory is probably the better way to improve performance. &nbsp;;)</p>
<p>I&#8217;ve also seen some very interesting optimizations. &nbsp;Consider the following code:</p>
<p>if (aFlag || bFlag) {}</p>
<p>When both of these bit packed flags end up in the same longword, the optimizer ends up fetching the longword once and then testing for both bits at the same time. &nbsp;Interesting, but to be perfectly honest, fragile since if you have a lot of bit fields, like we do, those two variables can easily end up crossing a longword boundary causing you to silently lose that optimization.</p>
<p>In the end, I have to agree with Raymond, in general, this is a bad thing to do. &nbsp;Then again, in the games industry, we commit all sorts of sins against programming for performance reasons.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687273">
				<div id="div-comment-687273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frederik Slijkerman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687273">
			November 26, 2008 at 12:46 pm</a>		</div>

		<p>@Raymond, superkoko:</p>
<p>Say you have 32 BOOLs, taking 32 * 4 = 128 bytes of space. You can fit them into 4 bytes with bitfields, so this is a saving of 128/4=32.</p>
<p>So it should be &#8220;packs 128 bytes into 4&#8221; &#8230;</p>
<div class=post>[<i>I told you math was hard&#8230; I think I should have just written &#8220;packs a bunch of stuff into less stuff.&#8221; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687293">
				<div id="div-comment-687293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://aiusepsi.co.uk' rel='external nofollow' class='url'>Andy Simpson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687293">
			November 26, 2008 at 1:05 pm</a>		</div>

		<p>This is interesting because I just wrote some code for a numerical modelling project &#8211; I have an n x m array, some points of which (most of them) get numerically simulated, while the others are held fixed, with a corresponding array of bools to store which is which.</p>
<p>Since I&#8217;m storing a really large number of bools (easily over 10,000 just at the moment, and the resolution of the simulation is only going up) I reckon this is still a memory win, and I don&#8217;t need multithreaded writes or individual bit debugging.</p>
<p>Hopefully this is another case where bitfields are OK&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687313">
				<div id="div-comment-687313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asymtote</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687313">
			November 26, 2008 at 1:08 pm</a>		</div>

		<p>In a few edge cases the improvement data cache hit rate can be worth the code bloat that bit fields incur to get a better data cache hit rate. They are truly edge cases however because the extra code typically causes a reduction in the instruction cache hit rate.</p>
<p>A lot of computer industry commentators bemoan the fact that too few students learn C any more but I think the real problem is that too few people learn assembly language programming, and almost nobody studies the code emitted by compilers. Randall Hyde&#8217;s Writing Great Code books are a good place to start for those interested in self-education as is Dr Paul Carter&#8217;s PC Assembly Language introduction to the x86 instruction set.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687323">
				<div id="div-comment-687323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687323">
			November 26, 2008 at 1:08 pm</a>		</div>

		<blockquote><p>
  Suppose each of these bitfielded fields is accessed six times in your code
</p></blockquote>
<p>Unless I&#8217;m mistaken (duh!), your calculation assumes just one of the fields accessed six times. The cost of accessing each of the four fields six times would have been about 400 bytes.</p>
<p>That said I generally agree with using bytes instead of INTs: realistically everything is x86/x64 now, and this architecture has excellent support for byte-sized stuff (same length opcodes). Besides, multithreaded simultaneous writes to the same class aren&#8217;t that common (and either way a performance disaster since each processor will be trashing the other&#8217;s cache &#8211; if you are going to have two threads writing at once, you better do it on different cachelines at least)</p>
<p>I&#8217;ve seen performance-and-footprint-minded portable code which goes one step further: it defines types such as FAST_U16, which basically means &quot;I need a fast integer which is at least 16-bit unsigned&quot;. If the target architecture would struggle with 16-bit sized stuff, it gets defined as a 32-bit one. Best of both worlds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687333">
				<div id="div-comment-687333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://madsoftware.blogspot.com' rel='external nofollow' class='url'>Mike Gibson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687333">
			November 26, 2008 at 1:09 pm</a>		</div>

		<p>@ Andy Simpson</p>
<p>Is memory really the factor you&#8217;re trying to minimize? &nbsp;If it&#8217;s numerical modelling, then isn&#8217;t it speed? &nbsp;Because that was one of Ray&#8217;s points. &nbsp;Not only are bitfields often not memory wins, but they&#8217;re a definite speed loss.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687353">
				<div id="div-comment-687353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.trikaliotis.net/' rel='external nofollow' class='url'>strik</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687353">
			November 26, 2008 at 1:26 pm</a>		</div>

		<p>Raymond, many of your points are valid. However, you also have to note that on some architectures, there are more efficient ways to handle bit fields. For example, x86 has BT, BTS and BTR for test, set and reset bits, respectively. The only drawback is that I do not know a compiler that actually emits these assembler instructions. So, in this sense, it is rather a limitation of the compiler.</p>
<p>Of course, I must admit that many of your points still remain valid. It depends upon what you/I have to achieve. For example, using a bitfield is more efficient if there are really many bits. If I need some hundreds of thousands of bits, this micro-optimisation perfectly suits my needs.</p>
<p>The issue you raised is similar to people using char variables instead of ints, as they want to save memory. They never check that in general, they do not save much data memory; however, the code footprint increases drastically, as the compiler will promote the char to an int and back multiple times. So, unless you have really many char variables, it is not worth the effort, and even counter-productive.</p>
<p>@Stalker:</p>
<p>&quot;I&#8217;ve never seen bit fields as a way to save data memory. Only time that I have used them (when its not because I&#8217;m just really tight on RAM) is when mapping to hardware;&quot;</p>
<p>If you do this, make sure you never have to change to another compiler, and your compiler writer never changes the way the bits are allocated in the bitfield. This is UB in C. If you ever had to change such code from a co-worker to work on another machine, you would never ever do this again.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687363">
				<div id="div-comment-687363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fredy Treboux</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687363">
			November 26, 2008 at 1:38 pm</a>		</div>

		<p>@Frederik</p>
<p>Wouldn&#8217;t it be 128 &quot;bits&quot; into 4??</p>
<p>math, hard, indeed, i know.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687373">
				<div id="div-comment-687373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stalker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687373">
			November 26, 2008 at 1:49 pm</a>		</div>

		<p>&quot;If you ever had to change such code from a co-worker to work on another machine, you would never ever do this again.&quot;</p>
<p>Actually, that is one of the reason we use it. This way the definitions can be the same for all platforms. (How bit fields are allocated is explicitly spelled out in the documentation for this compiler, which isn&#8217;t likely to change.) If we used masks and shifts then the definitions would have to be adapted to match that particular CPU&#8217;s native size.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687383">
				<div id="div-comment-687383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687383">
			November 26, 2008 at 1:54 pm</a>		</div>

		<p>Mike Gibson: If you have many thousands of bitfields, you are saving enough memory to use fewer pages of RAM. Since each page could mean a pagefault, this could be quite a substantial time savings. Additionally, if you access the bits in the right pattern, having the bits all fit in cache could prevent enough cache misses to provide a speed-up.</p>
<p>Keep in mind that this is the sort of situation that a SQL Server developer might be keenly aware of, but that most coders should never need to care about.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687393">
				<div id="div-comment-687393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687393">
			November 26, 2008 at 2:07 pm</a>		</div>

		<p>There&#8217;s yet another problem with &quot;BOOL f:1&quot;, which you may see as nitpicky or may not.</p>
<p>A signed integer of n bits is only guaranteed by the C or C++ standard to hold numbers from -2^(n-1) + 1 to 2^(n-1) &#8211; 1; e.g. you can only rely on a signed char to hold a number between -127 and 127. (This is so that C can be implemented on a machine that uses, e.g., sign-and-magnitude integer representations.)</p>
<p>A signed four-bit bitfield is only guaranteed to be able to hold numbers between -7 and 7. But note what this means for our signed one-bit bitfield: the only value that it&#8217;s guaranteed to be able to hold is 0!</p>
<p>In order to use a one-bit bitfield truly portably to any conforming C platform, you need to make it unsigned.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687403">
				<div id="div-comment-687403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aleko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687403">
			November 26, 2008 at 2:17 pm</a>		</div>

		<p>I would have used something like this:</p>
<p>enum FruitStatus {</p>
<p>Peeled = 0x0001,</p>
<p>Sliced = 0x0002,</p>
<p>Pitted = 0x0004,</p>
<p>Rotten = 0x0008</p>
<p>};</p>
<p>class Pear</p>
<p>{</p>
<p>public:</p>
<p>int status; // this is public just for simplicity</p>
<p>};</p>
<p>&#8230;</p>
<p>void main()</p>
<p>{</p>
<p>Pear* pear = FruitBowl::GetPear();</p>
<p>pear-&gt;status |= Sliced;</p>
<p>if(pear-&gt;status &amp; Rotten)</p>
<p>&nbsp;throw;</p>
<p>}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687413">
				<div id="div-comment-687413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sergey Vlasov</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687413">
			November 26, 2008 at 3:17 pm</a>		</div>

		<p>@strik: Bit manipulation instructions on x86 are slow, because they are implemented in microcode. They are useful mostly in cases when atomic bit modification is needed (with the LOCK prefix to ensure multiprocessor locking).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687423">
				<div id="div-comment-687423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Daniel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687423">
			November 26, 2008 at 3:32 pm</a>		</div>

		<p>I like reading these articles on programming real computers.</p>
<p>Sometimes I work on embedded systems where you have, say, 128 bytes of RAM, but these are bit-addressible and there are commands to manipulate a single bit in one instruction, so you can make the best use of the tiny memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687443">
				<div id="div-comment-687443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ton</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687443">
			November 26, 2008 at 3:56 pm</a>		</div>

		<p>@Frederik</p>
<p>I think everything else you said was correct in your last comment except for this sentence:</p>
<p>&quot;so this is a saving of 128/4=32.&quot;</p>
<p>It should be calculated as 128 &#8211; 4 = 124 to report the savings in memory I suspect.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687453">
				<div id="div-comment-687453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">someone</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687453">
			November 26, 2008 at 4:41 pm</a>		</div>

		<p>But 4 bits cann&#8217;t be stored, so the compiler uses 8, so the saving is 128 &#8211; 8 = 120 bits!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687463">
				<div id="div-comment-687463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687463">
			November 26, 2008 at 4:49 pm</a>		</div>

		<p>Even saving just 8 bits is suspect because of alignment issues. If your struct was just those four flags, it would almost certainly be given a full word (32 bits) by the compiler anyway. If you had another int member, it would almost certainly get 64 bits. Thus the savings would probably be more like 128-32 = 96 bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687483">
				<div id="div-comment-687483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687483">
			November 26, 2008 at 5:13 pm</a>		</div>

		<p>Another reason not to use C bit fields (or any obscure language feature) is they make you think something like &quot;Oh! Right, haven&#8217;t seen those since 92&#8230; how do they work again. Where&#8217;s my K+R?&quot;. Maintenance costs go up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687513">
				<div id="div-comment-687513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687513">
			November 26, 2008 at 7:02 pm</a>		</div>

		<p>@Frederik Slijkerman:</p>
<p>The original example contains only four BOOL members: m_peeled, m_sliced, m_pitted and m_rotten, so that 4 bits are packed into a byte and there&#8217;re 4 padding bits. Moreover, I suspect that some compilers may pack that in 4 bytes rather than 1 byte.</p>
<p>Anyway, as Raymond told us, math is hard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687523">
				<div id="div-comment-687523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kaenneth</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687523">
			November 26, 2008 at 7:05 pm</a>		</div>

		<p>I was an admin for a multidimensional database, it was 2 GB on disk, and the server had 256 megs of ram.</p>
<p>The database software would track block usage, so an entirly empty/zero block would just take a single index entry (like integer &#8216;-1&#8217;). a series of such blocks would also take just one entry (&#8216;-2&#8217; for 2 blocks, etc.)</p>
<p>The database was at first setup so the pattern of full/empty blocks was like {-1,7,-1,2,-1,4,-1,8} reordering the dimensions aligning the empty blocks changed it to to be like {7,2,4,8,-4}.</p>
<p>The database shrunk from 2 gigs to 500 megs, recalc times went from 2 hours to 10 minutes; and it stopped crashing everyday.</p>
<p>If you are tracking a large number of bools, you should consider the higher level structure of the data, it&#8217;s almost never &#8216;a bunch of bools&#8217; unless you are working with compression/crypto/rngs. Is there a bias in the values?, will there always be less trues than falses? do the values cluster/occur in runs?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687533">
				<div id="div-comment-687533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687533">
			November 26, 2008 at 8:16 pm</a>		</div>

		<p>Reasons to bit-pack:</p>
<p>Cache coherency. Very important on XBOX and PS3. The smaller your object size, the more likely it is to fit in a cacheline (or the more you can fit in a cache line..)</p>
<p>Reasons not to bit pack that you haven&#8217;t covered:</p>
<p>GCC will happily merge bitfields across class boundaries. eg:</p>
<p>class A {</p>
<p>&nbsp; BYTE mydata : 5;</p>
<p>}</p>
<p>class B : public A {</p>
<p>&nbsp; BYTE moreData : 3;</p>
<p>}</p>
<p>sizeof (B) = 1 byte, as in memory, the bits from B are merged into the bits from A. And it&#8217;ll do this with char data too on byte boundaries when they nestle up against bitfields.</p>
<p>Talk about scary behavior.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687543">
				<div id="div-comment-687543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Robert</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687543">
			November 26, 2008 at 8:31 pm</a>		</div>

		<p>1) If it was a universally good idea, compilers would pack the structs for you unless you specified some kind of portable struct.</p>
<p>2) I work with GIS. &nbsp;My current data set is 18.3 billion records. &nbsp;This can save a LOT of space in data files, and disk IO&#8217;s are not cheap..</p>
<p>Pick the right tools..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687283">
				<div id="div-comment-687283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://K.Hagan@thermoteknix.com' rel='external nofollow' class='url'>Ken Hagan</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687283">
			November 26, 2008 at 1:03 pm</a>		</div>

		<p>If your processors have a weakly ordered memory model, multi-threaded writes to BOOL aren&#8217;t safe either, but on Windows one can at least use InterlockedXxx() functions on BOOL-sized data. That apart, bool is a fairer comparison in C++ and char probably fairer for C. There *are* machines which can&#8217;t address bytes efficiently, but most of us will never write code for one and there are other machines that can address bits efficiently that &quot;we&quot; will never use either so using an int &quot;for efficiency&quot; strikes me as a premature optimisation in its own right!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687303">
				<div id="div-comment-687303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://madsoftware.blogspot.com' rel='external nofollow' class='url'>Mike Gibson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687303">
			November 26, 2008 at 1:06 pm</a>		</div>

		<p>@Tim Smith</p>
<p>If you need performance, and you have to violate some rules of programming to do it, fine. &nbsp;That rule applies anywhere, not just in games. &nbsp;What people fail to understand is that you should use a profiler or other *real-world* results to figure out what you should be optimizing, not just doing it wily-nily.</p>
<p>But I think that was your point anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687553">
				<div id="div-comment-687553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nuno Lucas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687553">
			November 26, 2008 at 10:48 pm</a>		</div>

		<p>I almost never use the bit struct feature, but it&#8217;s a common technique to pack a bunch of flags in an (unsigned) int.</p>
<p>Things like</p>
<p>flags |= FLG_1 | FLG_2;</p>
<p>flags &amp;= ~(FLG_3 | FLG2);</p>
<p>etc. are really handy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687563">
				<div id="div-comment-687563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687563">
			November 26, 2008 at 11:25 pm</a>		</div>

		<p>Bitfields are almost always a bad idea. &nbsp;People often try to use them to model fields in a network packet or hardware register, but the problem with that is that the ordering, alignment and some of the packing behavior of bits fields is largely left as &#8216;implementation defined&#8217; in the standard, so your code ends up being fragile and completely non-portable.</p>
<p>If you need to actually model bitfields in a network packet, file format, or hardware register &#8211; please just define constants and inline functions (or simple macros if you must) to mask, extract, and set the fields.</p>
<p>Everyone will be much happier in the long run.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687573">
				<div id="div-comment-687573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687573">
			November 26, 2008 at 11:27 pm</a>		</div>

		<p>From memory way back when I seem to remember something along the lines of bitmasks being optimum only when they were the same size as the data bus, data was padded if it was smaller meaning that if you sent 4 bits over an 8 bit bus, all 8 bits were used.</p>
<p>One can use bitwise operations on the decimal values to test for each bit eg. &nbsp;(flag &amp; 3) would equate to true if bits 0 and 1 where turned on.</p>
<p>In assembler would this statement not equate to something like?</p>
<p>(assuming 1=peeled, 2=sliced, 4=pitted, 8=&#8230;)</p>
<p>&nbsp; and ah,al &nbsp;; assume AH is flag and al is 3</p>
<p>&nbsp; cmp ah,al &nbsp;</p>
<p>&nbsp; je peeledAndSliced &nbsp;</p>
<p>So I guess the optimium number of bits one can use is dependent on the default register size for the processor mode. &nbsp;On a 32bit wintel boxes I suspect much padding is performed when bitmasks are used. Could not the spare space be filled with data for another operation?</p>
<p>[I have not written assembler for over 20 years, so a bit rusty].</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687433">
				<div id="div-comment-687433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Karellen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687433">
			November 26, 2008 at 3:43 pm</a>		</div>

		<p>I think I&#8217;d still go for the packed representation, on the very basis that you should ignore micro-optimisations most of the time.</p>
<p>The point is that a 32x memory reduction is not a micro-optimisation. A 32x memory reduction (or even a 93% reduction) is a *huge* win.</p>
<p>The natural way to implement a field that holds a single bit of data should be with a data element that holds a single bit of data. If you&#8217;re writing a program and you want a single bit, you should get/be in the habit of using a single bit to represent it.</p>
<p>If you later find out that you can save 100 bytes by using 32 bits per bool because you only create one of these structs and it&#8217;s only got 4 bit fields anyway, *that&#8217;s* a micro-optimisation. If you later find out that you can save 3 instructions per write and that really helps because it turns out you&#8217;re doing a lot of writes to one of these things in your inner loop, *that&#8217;s* a micro-optimisation.</p>
<p>Using a single bit instead of 4 bytes to store a single bit is *not* a micro-optimisation. It&#8217;s what you *should* *be* *doing*.</p>
<div class=post>[<i>A 32x memory reduction is impressive when the starting point was 2MB. But if your starting point is 100 bytes, a 32x memory reduction is noise. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687473">
				<div id="div-comment-687473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.asvguy.com' rel='external nofollow' class='url'>Burak KALAYCI</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687473">
			November 26, 2008 at 4:52 pm</a>		</div>

		<p>&gt; Using a single bit instead of 4 bytes to store a single bit is *not* a micro-optimisation. It&#8217;s what you *should* *be* *doing*.</p>
<p>I can&#8217;t agree more.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687493">
				<div id="div-comment-687493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687493">
			November 26, 2008 at 5:33 pm</a>		</div>

		<p>@Karellen</p>
<p>&gt; Using a single bit instead of 4 bytes to store a single bit is *not* a micro-optimisation</p>
<p>As this is semantic aspect of the question, you should program in something higher level with a &#8216;bool&#8217; type, but not in C with bit fields.</p>
<p>Using bit fields is not a about the nature &#8216;types&#8217;, but matching some memory layout for embedded system, or memory saving when you know how the machine works. &nbsp;Here&#8217;s the problem: bit fields are not something that&#8217;s native to the CPU, they are not made to deal with them. &nbsp;They deal with bytes and DWORDS. Bit fields have all the problems listed here, including being slow to access and having problems with threads.</p>
<p>If you want to &#8216;say&#8217; something in your code about saving &#8216;a bit&#8217;, use the higher-level &#8216;bool&#8217; type, and ignore the implementation. &nbsp;Bit fields are not about semantics, they&#8217;re about choosing an implementation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687593">
				<div id="div-comment-687593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687593">
			November 27, 2008 at 1:47 am</a>		</div>

		<p>The first time I saw bitfields was in a header file defining hardware. I certainly hated it as I couldn&#8217;t figure out the ordering of the bits &#8230; (I need to set bit 21&#8230; which one was that?). And if someone forgot to union it with unsigned ints, then setting them en masse was a bit more difficult, involving interesting casts.</p>
<p>Nowadays people use macros &#8211; more readable! And portable, and the bits are more obvious.</p>
<p>The other time I dealt with bitfields was really fun &#8211; had a packed bitfield (no choice &#8211; all the elements had to fit in 15 bytes due to hardware), but my destination machine was big-endian. My build machine was little. Was quite interesting exploring how the bits got set where, and writing a set of mask-shifts to rearrange the bits properly for big endian.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687613">
				<div id="div-comment-687613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">cthulhu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687613">
			November 27, 2008 at 4:55 am</a>		</div>

		<p>class Pear {</p>
<p>&#8230;</p>
<p>BOOL pld;</p>
<p>BOOL sld;</p>
<p>BOOL ptd;</p>
<p>BOOL rtn;</p>
<p>&#8230;</p>
<p>};</p>
<p>fixed it for you, now the variables take up half as much space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687623">
				<div id="div-comment-687623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.trikaliotis.net/' rel='external nofollow' class='url'>strik</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687623">
			November 27, 2008 at 6:01 am</a>		</div>

		<p>@Sergey Vlasov:</p>
<p>Yes, I know that the bit instructions are slow like hell. I never spoke about running time. ;)</p>
<p>Here, it is a matter of what is more important, memory or speed. There can be reasons to try to optimise for memory. Then, these instructions come in handy.</p>
<p>@Stalker:</p>
<p>&quot;Actually, that is one of the reason we use it. This way the definitions can be the same for all platforms.&quot;</p>
<p>No, they cannot be the same for all platforms. You must implement at least two versions, one for a left-to-right compiler, one for a right-to-left compiler. Then, you must determine for each platform if it belongs to the one or the other group.</p>
<p>Also note that as far as I remember &#8211; but I must admit, I have not checked -, C does not even guarantee that the compiler does not add padding to the bit field. Thus, the compiler could even use only &quot;half of the bits&quot; in the structure. For example, a bit field of two one bit elements could be generated with the corresponding bits being 0x80 and 0x08, or similar.</p>
<p>Furthermore: You cannot guarantee that accessing some a.f field, that no other fields are accessed, too. Take, for example, a bit field of 12 bit: Will the compiler access 3 byte, 4 byte, 8 byte, or whatever on access? This can make a difference for hardware (bits might get cleared on read or write, and so on).</p>
<p>Thus, you loose the control over what you are doing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687633">
				<div id="div-comment-687633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Memet</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687633">
			November 27, 2008 at 7:54 am</a>		</div>

		<p>Is that compiler code or did you write it up yourself?</p>
<p>I hadn&#8217;t seen the add eax, eax to accomplish a rol operation.</p>
<p>I must say: assembly language has no code of honor. Anything goes so long as it works.</p>
<div class=post>[<i>the add instruction can execute in either the u-pipe or the v-pipe, whereas rol executes only in the u-pipe. -Raymond]</i></div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687583">
				<div id="div-comment-687583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687583">
			November 27, 2008 at 12:02 am</a>		</div>

		<p>Good points Raymond as I am currently working on something just like that.</p>
<p>But let me flip your problem on end. &nbsp;What if the code is running out of a rom or flash memory. &nbsp;Then your heap and stack need to run in a small confined area? &nbsp;You are memory constrained not &#8216;disk&#8217; constrained.</p>
<p>If you have plenty of flash space yet not enough memory what you are doing is a *good* idea. &nbsp;If both are being loaded into normal memory then it is like you said a speed and space deoptimization.</p>
<p>Remember optimization is not always about speed. &nbsp;You may be optimizing to a different constraint. &nbsp;In my case a small memory area with plenty of flash area mapped into memory. &nbsp;I am trading speed for memory. &nbsp;In this case a slow down for more memory.</p>
<p>Also another thing you may want to consider (and it doesnt work on all platforms) is the packing of a struct. &nbsp;You can bloat code quickly by messing with the default packing. &nbsp;As the compiler will emit extra instructions to get at the missaligned data.</p>
<p>I am totaly with you though. &nbsp;When you optimize make sure you are doing the right thing. &nbsp;In windows what you said would probably be a bad thing to do.</p>
<p>When you have 2 gig of memory saving 20k of memory is not that big of deal. &nbsp;When you only have 64k of memory 2k can be a big deal.</p>
<div class=post>[<i>It&#8217;s a cost-benefit analysis. Sometimes the benefit is worth the cost; sometimes it isn&#8217;t. If you&#8217;re in some special case like embedded programming, then of course my general discussion does not apply. My point is that the benefit comes at a cost. It&#8217;s not free. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687643">
				<div id="div-comment-687643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Bateman</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687643">
			November 27, 2008 at 8:33 am</a>		</div>

		<p>It&#8217;s true that storing each field in a byte results in fewer instructions, but if you look at it from an aggregate standpoint, using a smaller bit-based data structure will result in less cache pressure. &nbsp;Depending on the large-scale access pattern, the benefit of fewer cache misses can outweigh the cost of more instructions.</p>
<div class=post>[<i>True in the general case, but here we have only six copies of the object. How much cache pressure is there from just 6 objects? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687663">
				<div id="div-comment-687663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">meh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687663">
			November 27, 2008 at 10:09 am</a>		</div>

		<p>Then again, if your file format and application memory requirement balloons to 2 times its size as you port your application to a 64 bit architecture, your customers might be rightly upset.</p>
<p>A lot of companies do not apparently care; they say it&#8217;s not worth saving those bytes if it costs them a days work. Oh well, once the customers start to notice its their time and money being wasted, most companies will wise up. Vista anyone?</p>
<div class=post>[<i>If there are only six copies of the object, the memory savings in data is overcome by the memory cost in code. So packing the data makes your program consume more memory. (Did you not read the article?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687723">
				<div id="div-comment-687723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Me</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687723">
			November 27, 2008 at 12:02 pm</a>		</div>

		<p>Yes I read the article. Obviously there is no memory saving if you only have 1 copy of the data. Often though, you have tons of copies of the data, and only a few copies of the code. Besides, even if you are wasting a few bytes, it&#8217;ll never automatically become a huge amount, just because the user had more data than you expected.</p>
<p>There is a reason why in algorithms you choose the algorithm that has the lower complexity class, even though it may be slower for small numbers. It&#8217;s the large numbers that are important anyway.</p>
<p>Nobody cares if you overoptimize and lose 50 bytes. People care if you underoptimize and waste 500 megabytes.</p>
<p>That&#8217;s not to say that using bitfields is always the solution though. There needs to be a compromise, looking at what features you need (atomic access, really fast access) and what they cost (memory, debuggability).</p>
<div class=post>[<i>The article was about the case where you have only a half dozen copies. Obviously if you have 100,000 copies, then the cost/benefit analysis tips the other way. I&#8217;m sorry you read my conclusions out of context. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687773">
				<div id="div-comment-687773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xix</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687773">
			November 27, 2008 at 2:24 pm</a>		</div>

		<p>But will you always know how many copies might be in use?</p>
<p>I was reminded of this post: <a rel="nofollow" target="_new" href="http://blogs.msdn.com/larryosterman/archive/2005/10/14/481137.aspx" rel="nofollow">http://blogs.msdn.com/larryosterman/archive/2005/10/14/481137.aspx</a></p>
<p>The final lesson is qualified as when writing code for a system library. &nbsp;But if you&#8217;re writing userland app code that today might be invoked in a half dozen copies, it still could be invoked in a half million a month later when you weren&#8217;t involved. &nbsp;I guess the lesson is to check those corners.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687823">
				<div id="div-comment-687823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687823">
			November 27, 2008 at 5:29 pm</a>		</div>

		<p>@strik: BTS, BT and BTR will LOOSE code space compared to AND or TEST on the relevant byte. They save space when the bit position is dynamic.</p>
<p>Example:</p>
<p>mystruct.bit = 1;</p>
<p>may generate (if the bit is at position 2 in a DWORD):</p>
<p>AND byte ptr [mem], FCh ; hexa: 80 Mod/RM (SIB) FC ; 3 or 4 bytes</p>
<p>or:</p>
<p>BTS dword ptr [mem], 2 ; hexa: 0F BA Mod/RM (SIB) 02 ; 4 or 5 bytes</p>
<p>Fetching the value:</p>
<p>mystruct.bit</p>
<p>TEST byte ptr [mem], FCh ; hexa: F6 Mod/RM (SIB) FC ; 3 or 4 bytes</p>
<p>BT dword ptr [mem], 2 ; hexa: 0F BA Mod/RM (SIB) 02 ; 4 or 5 bytes</p>
<p>With dynamic bit values, that&#8217;s even worse: A conditionnal jump has to be used for BTS/BTR, while a simple SHL+AND can do the job.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687863">
				<div id="div-comment-687863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.ericpreisz.com' rel='external nofollow' class='url'>Eric Preisz</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687863">
			November 27, 2008 at 10:15 pm</a>		</div>

		<p>In my opinion, I think you would have a hard time making any perfomance claims about this code across many different processors. &nbsp;</p>
<p>I still have a lot to learn about micro optimizations, can someone speak on the point of the extra assembly and how instruction level parallelism affects it? &nbsp;</p>
<p>Isn&#8217;t throughput really the way we make code faster today?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687803">
				<div id="div-comment-687803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pc486</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687803">
			November 27, 2008 at 4:24 pm</a>		</div>

		<p>In regards to the people who claim embedded environments would justify the cost, Raymond still makes a *very* valid point. I professionally work in the embedded realm and there is often no justification for bitfields in the name of saving space. The big-name compiler I use for the 68HC11 (which shall rename nameless to protect the guilty) has a hard time optimizing for bitfields. Using the native ALU width is the better way to go. 64k of memory means there is no such thing as 100+ structures, so the code generation cost isn&#8217;t worth the effort. Bitmapped structures are useful for register access so it&#8217;s not like this stuff is totally useless.</p>
<p>Honestly my only complaint in Raymond&#8217;s article is the comment about threading. C makes no guarantees about atomic access to any type of variable except for sig_atomic_t. You, the programmer, must lock that access or use a lockless structure/access protocol. Anything else should be considered a hack and not portable or maintainable. Besides, both classes in Raymond&#8217;s example would need to be marked volatile. No volatile means no threading support, period. And what if we add the volatile keyword? More code generation! Ouch!</p>
<div class=post>[<i>Win32 makes guarantees above and beyond what C guarantees. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687873">
				<div id="div-comment-687873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dinev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687873">
			November 28, 2008 at 1:48 am</a>		</div>

		<p>@Adam:</p>
<p>How does this require an extra register to Raymond&#8217;s version?</p>
<p>add eax, eax</p>
<p>and dword ptr [ebx+01Ch],-3</p>
<p>or &nbsp;dword ptr [ebx+01Ch],eax</p>
<p>Only if you want to help modern cpus by using register renaming, I guess that another register is necessary. </p>
<div class=post>[<i>(You also need to put an &#8220;and eax, 1&#8221; at the start.) This version reads the memory twice and writes it twice. It also leaves a window where the value of the bit is 0 even if it used to be 1 and you&#8217;re setting it to 1. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687883">
				<div id="div-comment-687883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joseph Koss</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687883">
			November 28, 2008 at 2:51 am</a>		</div>

		<p>Finding one aspect of something to be under-performant is no reason to abandon it. The example is essentialy the worst-case in at least four ways.</p>
<p>First is that there exists only a few fields.</p>
<p>Second is that there exists only a few instances.</p>
<p>Third is that the existing state of the field is unknown to the compiler within that code block.</p>
<p>Fourth is that the new state of the field is unknown to the compiler within that code block.</p>
<p>The last two are important because its actualy rare for the compiler to be put in that situation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687913">
				<div id="div-comment-687913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">peterchen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687913">
			November 28, 2008 at 7:16 am</a>		</div>

		<p>@Joseph, I think the point is just behind what you say. Of course it is a bad example for using bit fields.</p>
<p>A simple-minded student would see the lesson: &quot;don&#8217;t use bit fields&quot;.</p>
<p>A good student would say &quot;don&#8217;t use bit fields, when the additional code exceeds the storage savings&quot;. And would probbly receive an A for that.</p>
<p>A students who prefers to think in abstractions would learn: &quot;When making an optimization, take all tradeoffs into account.&quot; He did learn a valuable lesson indeed &#8211; maybe the most valuable of the three &#8211; but one that isn&#8217;t easily applicable, and it doesn&#8217;t help the other students.</p>
<p>Somewhere, there is even a lesson in it that will enlighten all three students, help them natively understand a similar situation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-687933">
				<div id="div-comment-687933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://lisaem.sunder.net' rel='external nofollow' class='url'>Ray Arachelian</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687933">
			November 28, 2008 at 10:34 am</a>		</div>

		<p>There are times when bitfields are useful. &nbsp;This obviously isn&#8217;t one of them.</p>
<p>Examples of useful ones: accessing an I/O device when writing device drivers (or in my case emulators.) &nbsp;You can map out a structure (not a class) that maps out to the bits in an I/O device and this allows you access to the individual lines.</p>
<p>There are issues with this too. &nbsp;Endian issues, but now you&#8217;re dealing with bitwise endian issues where on one architecture (or compiler) the order that the bits are stored in are different from another. &nbsp;So you need to be careful there too.</p>
<p>Otherwise, yes, if you just want a bunch of booleans, it&#8217;s not worth the trouble.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-687983">
				<div id="div-comment-687983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">code taxing</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-687983">
			November 28, 2008 at 2:20 pm</a>		</div>

		<blockquote><p>
  peterchen:</p>
<p>  Simple-minded student vs good student vs abstract student:
</p></blockquote>
<p>What you propose are 3 code taxes. The last tax is heavy, the first tax is lightweight.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-688053">
				<div id="div-comment-688053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://ashleigh.id.au' rel='external nofollow' class='url'>ashleigh</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688053">
			November 29, 2008 at 12:23 am</a>		</div>

		<p>Using bitfields like this makes sense on embedded systems where RAM can be limited and expensive (eg a processor upgrade to a more expensive version to get more RAM).</p>
<p>But generally when you have a big OS and lots of memory, micro-optimisations like this are a waste of time and make the program run slower.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-688093">
				<div id="div-comment-688093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">1bit=1bit</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688093">
			November 29, 2008 at 10:12 am</a>		</div>

		<blockquote><p>
  But generally when you have a big OS and lots of memory, micro-optimisations like this are a waste of time and make the program run slower.
</p></blockquote>
<p>Ofcourse, who doesn&#8217;t agree to that? But the actual micro-optimisations in this case is to use 32 bits instead of 1 bit to store 1 bit.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-688113">
				<div id="div-comment-688113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://forum.torrents.ro/dezvoltare/5611-oop-php-vs-non-oop.html#post88361' rel='external nofollow' class='url'>OOP PHP vs non-OOP - TORRENTs.RO</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688113">
			November 29, 2008 at 12:14 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://forum.torrents.ro/dezvoltare/5611-oop-php-vs-non-oop.html#post88361" rel="nofollow">http://forum.torrents.ro/dezvoltare/5611-oop-php-vs-non-oop.html#post88361</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-688213">
				<div id="div-comment-688213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688213">
			November 30, 2008 at 3:16 am</a>		</div>

		<p>There is a something that has been bugging me for quite some time &#8212; compilers and language standards.</p>
<p>Namely, bitfield ordering is &quot;implementation specific&quot; as noted in C standard.</p>
<p>I must admit I do not quite understand how can we call something (in this case the C/C++ Standard) a standard when it doesn&#8217;t define precise rules for every situation? How can a rule still be considered a rule when all it says is &quot;behavior is undefined and implementation specific&quot;? It is the same as if they said &quot;rule is that there are no rules&quot;.</p>
<p>For example, the execution of your code is guaranteed to happen in the right order regardless of the compiler optimizations, but the standard doesn&#8217;t guarantee that your variables will be created on the stack in the same order you listed them in your code (unless of course they are part of a structure). Can you say double &quot;standard&quot;? How about other &quot;implementation specific&quot; details such as vtable layout, etc?</p>
<p>Furthermore, languages are not evolving with hardware. An example of this would be the inability of new[] to return __m128 aligned memory pointer unless overriden using placement new[], and even then it may fail depending on where and how the compiler stores the number of elements to delete[] later.</p>
<p>Finally, I wonder if someone from Microsoft knows the reason why BOOL was never defined as an unsigned int instead? That would avoid sign extension on bit extraction from a bitfield.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-688273">
				<div id="div-comment-688273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688273">
			November 30, 2008 at 11:43 am</a>		</div>

		<blockquote><p>
  I must admit I do not quite understand how can we call something (in this case the C/C++ Standard) a standard when it doesn&#8217;t define precise rules for every situation?
</p></blockquote>
<p>Because there are things that are best handled by platform-specific specifications. Namely: ABI.</p>
<p>Would you want int to be 16 bits (as most int were in 1990) FOREVER?</p>
<blockquote><p>
  but the standard doesn&#8217;t guarantee that your variables will be created on the stack in the same order you listed them in your code
</p></blockquote>
<p>Specifying that would forbid major optimizations such as storing variables in registers, using &quot;holes&quot; for alignment issues (x86 is one of the very rare platform to support unaligned data), or packing small data together.</p>
<p>What about platforms where the stack grows up compared to platforms where the stack grows down?</p>
<p>What would you do for IA-64 where there&#8217;re MORE than one stack?</p>
<p>What about platforms where the &quot;hardware&quot; stack is too small (e.g. 6502 has 256 bytes of stack) and compilers want to use a larger &quot;software&quot; stack?</p>
<p>What would be the benefit of specifying these details? It would allow brain damaged code performing mad pointer arithmetic, and would either break debugging tools or make them useless.</p>
<p>If you wish to exactly control code generation, use MASM or HLA, not C.</p>
<p>If you wish to know your binary interface, simply read the ABI specification for your platform. Unfortunately, Win32 has no such ABI. All other platforms I&#8217;m aware of, have one.</p>
<p>Similarly, vtable layout will depends on object format (ELF vs A.OUT vs COFF) and are best specified by a separate ABI.</p>
<p>Without undefined behavior, C everything would&#8217;ve to check everything&#8230; That would be huge overhead. Pointers would&#8217;ve to check memory bounds, which would make sizeof(void*) much higher.</p>
<blockquote><p>
  An example of this would be the inability of new[] to return __m128 aligned
</p></blockquote>
<p>Compilers are required to return 128-bits aligned memory on platforms where some builtin data types require this alignment. This is enough for pure C90 code.</p>
<p>If you need another alignment for a platform-specific reason, then, use a platform-specific function: e.g. posix_memalign on POSIX systems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-688613">
				<div id="div-comment-688613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688613">
			December 1, 2008 at 5:45 pm</a>		</div>

		<blockquote><p>
  &gt;Would you want int to be 16 bits (as most int were in 1990) FOREVER?&lt;&lt;
</p></blockquote>
<p>Changing size of an integer is not what I would do.</p>
<p>I would rather standardize it and call it int8, int16, int32, etc. That would make developers more aware of the data size and make them chose more carefully which type to use.</p>
<p>Having char (which backfired with unicode making it !char), short and long (and long long!) is extremely stupid. And __int64 is even more stupid, and I cringe everytime I have to type:</p>
<p>unsigned __int64 crap;</p>
<p>I mean what those two underscores mean to ME?!? What is the point in making it harder to type when the compiler doesn&#8217;t give a damn?</p>
<blockquote><p>
  &gt;Specifying that would forbid major optimizations such as storing variables in registers&#8230;&lt;&lt;
</p></blockquote>
<p>I never said it should keep all the variables on the stack, just that they should appear in written order, and if I chose so I can always add the volatile keyword to prevent some of them from being kept in registers.</p>
<p>As for the other types of stack I simply don&#8217;t care. How many people today use C on 6502 or IA64 compared to C on Core 2 Duo or Athlon 64?</p>
<blockquote><p>
  &gt;&#8230;or packing small data together.&lt;&lt;
</p></blockquote>
<p>I simply do not want the compiler doing layout and space optimizations on my variables (as opposed to &quot;on my code&quot;) because I wasn&#8217;t explicitly asking for those.</p>
<blockquote><p>
  &gt;Without undefined behavior, C everything would&#8217;ve to check everything&lt;&lt;
</p></blockquote>
<p>I am not asking C for 6502 to support all the features of C for Win32 &#8212; what I want is a C which is at least standardized across the platform (in this case x86).</p>
<blockquote><p>
  &gt;Compilers are required to return 128-bits aligned memory on platforms where some builtin data types require this alignment.&lt;&lt;
</p></blockquote>
<p>Geee&#8230; I wonder what that datatype would be for x86 and x64? Could it be a 128-bit SIMD register with its 16 byte alignment requirement? Wait, that data type is builtin since Pentium III era, but obviously only into the CPU, not into the compiler!</p>
<p>But that has been a problem only since 1999, I guess it takes more time than <strong><em>9 years</em></strong> for C/C++ Standard Committee to move their lazy arses into high gear and finally add some support for it.</p>
<blockquote><p>
  &gt;If you need another alignment for a platform-specific reason, then, use a platform-specific function: e.g. posix_memalign on POSIX systems.&lt;&lt;
</p></blockquote>
<p>And how do you advise using those platform-specific functions for returning an array of initialized C++ objects like new[] does?</p>
<p>True, I could use placement new[] but I won&#8217;t. Why would I want to litter my projects with those, when they could just add another new[] prototype with alignment parameter to the standard?</p>
<p>Apart from being much better at code optimization today (and at the same time making it harder to find the compiler induced bugs, and believe me those exist!), compilers and the C/C++ language have been stagnant over the last 10 years if not even longer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-688643">
				<div id="div-comment-688643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SuperKoko</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688643">
			December 1, 2008 at 6:49 pm</a>		</div>

		<blockquote><p>
  How many people today use C on 6502 or IA64 compared to C on Core 2 Duo or Athlon 64?
</p></blockquote>
<p>You seem not to understand that, if you don&#8217;t need portability, you are allowed to use platform-specific things.</p>
<p>But, the C standard is designed to be adopted on every platform, including the most recent IA-64 and ARM CPU.</p>
<blockquote><p>
  That would make developers more aware of the data size and make them chose more carefully which type to use.
</p></blockquote>
<p>On the other hand, that would give the Win32 fixed-type-sizes fiasco on every platform. Most ILP32 UNIX platforms have been cleanly moved to LP64, benefitting from easy-to-use clean 64 bits file pointers with the good old C90 and POSIX file interfaces.</p>
<p>Your view seems to be biaised towards the Win32 platform (which, unfortunately, has so poor C &amp; C++ implementations, without proper ABI).</p>
<blockquote><p>
  Having char (which backfired with unicode making it !char), short and long (and long long!) is extremely stupid.
</p></blockquote>
<p>long long is brain damaged, right. It seems to have been adopted by the C standard because bad programmers (mainly Win32 programmers) are too stupid to think that long might, someday, be longer than 32 bits, and so rely so heavily on it that the Windows C implementations cannot change its size anymore.</p>
<p>Any proper platform make long the widest integer type available so that sizeof(long long)==sizeof(long) in C99 mode, otherwise the compiler would break C90 compatibility by making some conversions such as &quot;unsigned long-&gt;size_t&quot; lossy.</p>
<p>In the end, specifying fixed types might be the only way to go in a world where programmers don&#8217;t care about future.</p>
<p>(If you&#8217;re a C99 user, you can right now use them).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-688693">
				<div id="div-comment-688693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.eriknovales.com/blog/index.php/2008/12/01/optimization-tradeoffs/' rel='external nofollow' class='url'>Optimization Tradeoffs</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-688693">
			December 1, 2008 at 9:40 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.eriknovales.com/blog/index.php/2008/12/01/optimization-tradeoffs/" rel="nofollow">http://www.eriknovales.com/blog/index.php/2008/12/01/optimization-tradeoffs/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-689263">
				<div id="div-comment-689263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20081126-00/?p=20073#comment-689263">
			December 3, 2008 at 7:28 am</a>		</div>

		<p>&quot;The C standard should specify everything&quot; is the same thinking as &quot;640K is enough for everybody&quot;. Because the C standard should obviously then specify at which point malloc() would fail. I never expected Igor Levicki to share that view.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

