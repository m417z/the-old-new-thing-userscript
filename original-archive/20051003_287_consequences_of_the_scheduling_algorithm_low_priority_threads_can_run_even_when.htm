<html>
<head>
<title>Consequences of the scheduling algorithm: Low priority threads can run even when higher priority threads are running</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Consequences of the scheduling algorithm: Low priority threads can run even when higher priority threads are running</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 3, 2005 / year-entry #288</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>31</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Just because you have a thread running at a higher priority level doesn't mean that no threads of lower priority will ever run. Occasionally, I see people write multi-threaded code and put one thread's priority higher than the other, assuming that this will prevent the lower-priority thread from interfering with the operation of the higher-priority...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Just because you have a thread running at a higher priority
level doesn't mean that no threads of lower priority will ever run.
</p>
<p>
Occasionally, I see people write multi-threaded code and put
one thread's priority higher than the other, assuming that
this will prevent the lower-priority thread from interfering
with the operation of the higher-priority thread
so that they don't need to do any explicit synchronization.
</p>
<pre>
BOOL g_fReady;
int g_iResult;
// high priority thread
SetResult(int iResult)
{
 g_fReady = TRUE;
 g_iResult = iResult;
}

// low priority thread
if (g_fReady)
{
 UseResult(g_iResult);
}
</pre>
<p>
Let's ignore the cache coherency elephant in the room.
If there were a guarantee that the low priority thread will never
ever run while the high priority thread is running, this code looks
okay.  Even if the high priority thread interrupts and sets
the result after the low priority thread has checked the ready flag,
all that happens is that the low priority thread misses out on the result.
(This is hardly a new issue, since
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2004/09/03/225238.aspx">
the principle of relativity of simultaneity</a>
says that this was a possibility anyway.)
</p>
<p>
However, there is no guarantee that the low priority thread can't
interfere with the high priority thread.
</p>
<p>
The scheduler's rule is to look for the thread with the highest
priority that is "runnable", i.e., ready to run,
and assign it to a CPU for execution.
To be ready to run, a thread cannot be blocked on anything,
and it can't already be running on another CPU.
If there is a tie among runnable threads for the highest priority,
then the scheduler shares the CPU among them roughly equally.
</p>
<p>
You might think that, given these rules,
as long as there is a high priority thread that is runnable,
then no lower-priority thread will run.
But that's not true.
</p>
<p>
Consider the case of a multi-processor system
(and with the advent of hyperthreading, this is
becoming more and more prevalent),
where there are two runnable threads, one with higher priority
than the other.
The scheduler will first assign the high-priority thread
to one of the processors.
But it still has a spare CPU to burn,
so the low-priority thread will be assigned to the second CPU.
You now have a lower priority thread running simultaneously
as a higher priority thread.
</p>
<p>
Of course, another way a lower priority thread can run even
though there are higher priority threads in the system is
simply that all the higher priority threads are blocked.
In addition to the cases you might expect, namely
waiting on a synchronization object such as a semaphore
or a critical section,
a thread can also block for I/O or for paging.
Paging is the wildcard here, since you don't have any
control over when the system might decide to page out
the memory you were using due to memory pressure
elsewhere in the system.
</p>
<p>
The moral of the story is that thread priorities are not
a substitute for proper synchronization.
</p>
<p>
Next time, a reversal of this fallacy.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (31)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-310303">
				<div id="div-comment-310303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jamessummerlin.blogspot.com' rel='external nofollow' class='url'>James Summerlin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310303">
			October 3, 2005 at 11:12 am</a>		</div>

		<p>The short cuts people take never cease to amaze me.</p>
<p>Raymond, how do you maintain your sanity when faced with all of this, especially since you have to write code in Windows much of the time to deal with such horror?</p>
<p>James</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310313">
				<div id="div-comment-310313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310313">
			October 3, 2005 at 11:20 am</a>		</div>

		<p>So is it fair to say that, with the Windows scheduler, you&#8217;ll never end up in a deadlock due to a priority inversion?</p>
<p>In the embedded systems I&#8217;ve worked on, you can deadlock if a high-priority thread is waiting for a synchronization object held by a low-priority thread because those systems don&#8217;t let the lower priority thread run at all as long as a higher priority one exists.</p>
<p>It seems, with Windows, a priority inversion like this might degrade performance, but it shouldn&#8217;t deadlock, because the scheduler will let the lower priority thread run at least until it releases the resource the higher priority thread is waiting for.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310323">
				<div id="div-comment-310323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Manip</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310323">
			October 3, 2005 at 11:24 am</a>		</div>

		<p>This should work Ok, whatever the thread priority (but isn&#8217;t very efficient):</p>
<p>BOOL g_fReady = FALSE;<br />
<br />int g_iResult = 0;<br />
<br />// high priority thread<br />
<br />SetResult(int iResult)<br />
<br />{<br />
<br /> g_iResult = iResult;<br />
<br /> g_fReady = TRUE;<br />
<br />}</p>
<p>// low priority thread<br />
<br />while (!g_fReady)<br />
<br />{<br />
<br /> Sleep(500);<br />
<br />}<br />
<br />UseResult(g_iResult);</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310333">
				<div id="div-comment-310333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Manip</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310333">
			October 3, 2005 at 11:28 am</a>		</div>

		<p>Re: &quot;because those systems don&#8217;t let the lower priority thread run at all as long as a higher priority one exists. &quot; </p>
<p>WOW, just wow&#8230; I can&#8217;t believe anyone would implement such a system; I mean even on paper that is going to cause deadlocks though starvation&#8230; Why WOULDN&#8217;T it push the low priority thread in that situation? Crazy&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310343">
				<div id="div-comment-310343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://jenk.livejournal.com' rel='external nofollow' class='url'>JenK</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310343">
			October 3, 2005 at 11:37 am</a>		</div>

		<p>From a tester&#8217;s point of view, this is a terrific example of bugs that are a holy bitch to find and track down via black-box testing that are (relatively) easy to find during code review or white-box testing.</p>
<p>Of course, code review and white-box testing are more expensive than a lot of ISVs want to pay&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-310353">
				<div id="div-comment-310353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310353">
			October 3, 2005 at 11:40 am</a>		</div>

		<p>Manip: The code is still buggy but for a different reason. Now you get to learn about memory models and cache coherency.</p>
<p>Adrian: You can still run into inversion problems. Add a thread thread of medium priority that is CPU-intensive.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310363">
				<div id="div-comment-310363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310363">
			October 3, 2005 at 11:42 am</a>		</div>

		<p>I decided a long time ago that very few programmers understand multi-threading and the difficulties in making sure you don&#8217;t have any synchronization issues.</p>
<p>Multiprocessing just adds another complex dimension to a task that they are already having difficulty performing, and that generally puts the task beyond their ability to complete correctly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310413">
				<div id="div-comment-310413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spacebunny.xepher.net/' rel='external nofollow' class='url'>KJK::Hyperion</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310413">
			October 3, 2005 at 12:09 pm</a>		</div>

		<p>Manip: yep, the algorithm is traditionally &#8211; and a bit improperly &#8211; called &quot;FIFO&quot; in the literature (the family of algorithms to which the Windows one belongs is &quot;FIFO with thread quantums&quot;, traditionally called &quot;round-robin&quot; or &quot;RR&quot;), it&#8217;s in the POSIX standard and it&#8217;s &quot;standard issue&quot; on real-time embedded operating systems, such as QNX (but the QNX developer manual explains very accurately how to avoid priority inversion with a proper use of message queues).</p>
<p>If you aren&#8217;t horrified enough yet, consider that such operating systems often let you do much worse, e.g. with APIs that let you install interrupt handlers (and Microsoft&#8217;s very own Windows CE is no exception)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310423">
				<div id="div-comment-310423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310423">
			October 3, 2005 at 12:56 pm</a>		</div>

		<p>Manip: perhaps I&#8217;m missing something, but I don&#8217;t see how your code does anything but slightly change the parameters of the race condition. </p>
<p>You can still have the low pri thread come out of a sleep just before the high pri thread decides to run and then the code is effectively exactly identical to Raymond&#8217;s. </p>
<p>Besides, the most immediate problem is multi-processing rather than thread scheduling.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310443">
				<div id="div-comment-310443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.guyswithtowels.com' rel='external nofollow' class='url'>Tim</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310443">
			October 3, 2005 at 1:40 pm</a>		</div>

		<p>Raymond &#8211; I&#8217;m not going to give you too much of a hard time about this, as it&#8217;s just your blog, you&#8217;re probably busy, plus I liked your &quot;It turns out I can do nothing really fast!&quot; comment at PDC, but comments like &quot;The code is still buggy but for a different reason. Now you get to learn about memory models and cache coherency.&quot; would be way more helpful with a little more explanation or a link or something.</p>
<p>I agree the initial code is pretty insane, even though I haven&#8217;t done much multi-threading stuff myself, but I&#8217;m not sure what cache coherency problems would result from Manip&#8217;s version.  One thing I noticed is that the shared &#8216;ready&#8217; flag should be declared volatile otherwise in release builds the client will just sit in an infinite loop (I&#8217;ve seen that happen).  But otherwise, I&#8217;ve used trailing/rising edge detection like this in my own multi-threaded code and not found a problem (I accept this is not proof!) &#8211; what exactly can go wrong?  Will separate CPUs in a multi-core system actually see different memory contents due to separate caches? Forever, or for a small time period?  I&#8217;d always assumed x86 machines managed to handle the cache coherency issues&#8230;I guess from your comment that they don&#8217;t.  So now I&#8217;m curious :)</p>
<p>(It&#8217;s a bit like your &quot;How do we get developers to pay their taxes?&quot; question.  The first jobs there are (1) Letting people know about the taxes, and (2) Letting people know how to pay the taxes.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310453">
				<div id="div-comment-310453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310453">
			October 3, 2005 at 1:45 pm</a>		</div>

		<p>&quot;Manip: perhaps I&#8217;m missing something, but I don&#8217;t see how your code does anything but slightly change the parameters of the race condition. &quot;</p>
<p>Oh, I just noticed that you switched the order of operations on the high-pri thread. That will help, but you&#8217;re still assuming that the high-pri thread is only going to run once, which is a fairly rare way for things to happen in practice.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-310463">
				<div id="div-comment-310463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310463">
			October 3, 2005 at 1:50 pm</a>		</div>

		<p>Sorry, Tim &#8211; I try to have only one topic per day. Going into cache coherency and weak memory models would have meant several more days&#8217; research and I simply can&#8217;t get excited about something that requires days of research. You can search the web for &quot;double check locking&quot; and that&#8217;ll get you started.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310473">
				<div id="div-comment-310473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Dunn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310473">
			October 3, 2005 at 2:00 pm</a>		</div>

		<p>There&#8217;s another factor you might not realize &#8211; the thread scheduler has a special case where if a thread hasn&#8217;t run at all for 3 seconds, it gets bumped up to priority 15 and then decays back down to its original level. So your low-priority sleeping thread might suddenly wake up and preempt a LOT of other threads.<br />
<br />(I might have the bump-up details wrong, I&#8217;m going by memory from the Windows Internals PDC talk, but you get the drift.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310503">
				<div id="div-comment-310503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Moasat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310503">
			October 3, 2005 at 2:35 pm</a>		</div>

		<p>I also thought Windows would use Priority boosting so in the following case, the normal rprioty thread would not starve the high priority thread:</p>
<p>Low thread owns an object.<br />
<br />High thread is waiting for the object.<br />
<br />Normal thread is running full speed.</p>
<p>Normally, the normal thread would prevent the low thread from running, but since the high thread needs the object, Windows would boost the priority of the low thread so that it could run and (hopefully) release the object.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310513">
				<div id="div-comment-310513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">kbiel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310513">
			October 3, 2005 at 2:43 pm</a>		</div>

		<p>Manip: The problem with your code is that it assumes that your assignment to g_iResult will be placed in main memory before the low priority thread becomes aware that your g_fReady flag has been set.  That&#8217;s a bad assumption because the compiler might optimize g_iResult causing your result to be in a register and not copied out to main memory before your low priority thread tries to access it if the threads are running on separate processors.  That&#8217;s why mutexes were invented.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-310523">
				<div id="div-comment-310523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310523">
			October 3, 2005 at 2:52 pm</a>		</div>

		<p>Moasat: This assumes that the OS can tell that the object is &quot;owned&quot; by the low priority thread. The most popular synchronization objects (events, semaphores) don&#8217;t have owners.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310533">
				<div id="div-comment-310533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Manip</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310533">
			October 3, 2005 at 3:24 pm</a>		</div>

		<p>re: &quot;The problem with your code is that it assumes that your assignment to g_iResult will be placed in main memory before the low priority thread becomes aware that your g_fReady flag has been set.&quot; </p>
<p>That is a fair comment. I don&#8217;t know much about cross-thread cache problems I admit, and didn&#8217;t consider it when I wrote my short little example. :) </p>
<p>It wasn&#8217;t supposed to be the final example code anyway, there are all sorts of ways to improve on my quick re-write; just to name one, I could put the low priority thread in a waiting state and then awake all waiting threads when the g_fReady is set. Save on the constant context switching when the low priority awakes every 500ms.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310553">
				<div id="div-comment-310553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lorenzo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310553">
			October 3, 2005 at 6:31 pm</a>		</div>

		<p>KJK::Hyperion: it&#8217;s nice to see Italia people from the ReactOS project!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310383">
				<div id="div-comment-310383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spaces.msn.com/members/jvert/' rel='external nofollow' class='url'>John Vert</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310383">
			October 3, 2005 at 11:56 am</a>		</div>

		<p>Raymond says &#8216;The scheduler&#8217;s rule is to look for the thread with the highest priority that is &quot;runnable&quot;, i.e., ready to run, and assign it to a CPU for execution.&#8217; This is more of a guideline than a rule in the presence of multiple CPUs. The scheduler also goes to great effort to run a thread on the same CPU it ran on previously to prevent cache thrashing.</p>
<p>So you might think Raymond&#8217;s statement implies that on an N-CPU machine, the N highest-priority runnable threads are scheduled. In fact, Back In The Day (pre NT4 I think), this was true. It is no longer true. The only rule in this case is that *THE* highest priority thread is scheduled. </p>
<p>Consider three threads, priority High, Medium, and Low. High and Medium have recently run on CPU 1, while Low has recently run on CPU 2. In this case, the scheduler will run High on CPU 1, Low on CPU 2, and Medium will not be running. </p>
<p>Of course at some point the scheduler may give up and decide Medium has waited long enough and might as well preempt Low and migrate to CPU 2.</p>
<p>All these heuristics are subtle and change in every release as the underlying hardware and software changes its behavior. In fact they may even change between different SKUs of the same release. So Raymond&#8217;s right as always &#8211; if you are even thinking about priority affecting a synchronization issue, then you almost certainly have a bug. (Or will have a bug in the future)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310393">
				<div id="div-comment-310393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310393">
			October 3, 2005 at 11:57 am</a>		</div>

		<p>Where I work we are now getting into multithreading.  It scares me everytime I look at the code and see race conditions out the ****.</p>
<p>I&#8217;ve been doing multithreaded/distributed programming for 20 years.  The only important thing I have learned is that I don&#8217;t know anything beyond the basics.  It helps to keep me very safe. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310593">
				<div id="div-comment-310593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310593">
			October 3, 2005 at 11:48 pm</a>		</div>

		<p>Monday, October 03, 2005 11:20 AM by Adrian<br />
<br />&gt; It seems, with Windows, a priority inversion<br />
<br />&gt; like this might degrade performance, but it<br />
<br />&gt; shouldn&#8217;t deadlock, because the scheduler<br />
<br />&gt; will let the lower priority thread run at<br />
<br />&gt; least until it releases the resource the<br />
<br />&gt; higher priority thread is waiting for.</p>
<p>According to an MSDN document, Windows 9x did exactly that, but the NT series assigns random temporary jumps in priority instead.  It seems to me that this is 1 of approximately 2 things where the manufacturer of Windows 9x has something they could teach to the manufacturer of the NT family.</p>
<p>Mossat said approximately the same thing as Adrian, but gave the same example that MSDN gave.</p>
<p>Monday, October 03, 2005 2:52 PM by oldnewthing<br />
<br />&gt; Moasat: This assumes that the OS can tell<br />
<br />&gt; that the object is &quot;owned&quot; by the low<br />
<br />&gt; priority thread. The most popular<br />
<br />&gt; synchronization objects (events, semaphores)<br />
<br />&gt; don&#8217;t have owners.</p>
<p>You mean MSDN lied?  I wonder why I&#8217;m not shocked by that possibility.  But theoretically it would be possible to detect ownership of some kinds of shared objects and handle priority inversions on them.  I see how that wouldn&#8217;t be possible for events.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310643">
				<div id="div-comment-310643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Moasat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310643">
			October 4, 2005 at 9:13 am</a>		</div>

		<blockquote><p>
  Moasat: This assumes that the OS can tell that<br />
  <br />&gt; the object is &quot;owned&quot; by the low priority<br />
  <br />&gt; thread. The most popular synchronization<br />
  <br />&gt; objects (events, semaphores) don&#8217;t have owners.</p>
<p>True enough.  These objects aren&#8217;t really &quot;owned&quot; in the sense as a CRITICAL_SECTION or Mutex, but then again, how often are these used to synchronize access to shared resources?  I understand events and semas triggering when data is available, but that assumes a higher level of &quot;intelligence&quot; on the programmer&#8217;s level to synchronize access to the shared resources instead of a more random access method, say the refcnt of a COM object.</p>
<p>Norman: Maybe MSDN didn&#8217;t &quot;lie&quot;, it just doesn&#8217;t track owners of events and semaphores because they&#8217;re not typically used for shared resource access like a CS or a mutex would be.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310663">
				<div id="div-comment-310663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">nfinite loop</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310663">
			October 4, 2005 at 10:05 am</a>		</div>

		<p>Is it possible to schedule 2 threads where one uses 60% cpu and the other 40% (both doing while(true); ) on a 1 cpu system?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-310873">
				<div id="div-comment-310873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Solid</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310873">
			October 4, 2005 at 3:10 pm</a>		</div>

		<p>After reading some research on &quot;double check&quot;, </p>
<p>I still do not see the flaw in manip&#8217;s code, except putting &quot;volatile&quot; to both global variables.</p>
<p>g_fReady = TRUE is an atomic operation.</p>
<p>It&#8217;s just not efficient, since it reads from memory instead of the much faster cache.</p>
<p>Please advise.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-310993">
				<div id="div-comment-310993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-310993">
			October 5, 2005 at 5:45 am</a>		</div>

		<p>To Solid: I think Raymond meant something like the article: &quot;C++ in Theory: Why the Double Check Lock Pattern Isn`t 100% Thread Safe&quot;.</p>
<p>There you can find:<br />
<br />&quot;This problem could be solved If we could be guaranteed of the ordering of instructions, but the C and C++ standards are not strict enough in this case. The standards allow a compiler to reorder the instructions as long as the observable behavior remains the same (!).&quot;</p>
<p>In our sample, ocne we declare the variables volatile, the critical is the possible reordering of:<br />
<br />g_iResult = iResult;<br />
<br />g_fReady = TRUE; </p>
<p>Then, &quot;volatile&quot; guarantees only that the access to the location would not be optimized away, not that any access wouldn&#8217;t be reordered, if I understood everything correctly.</p>
<p>I think one easy way to avoid reordering is to introduce the function:</p>
<p>ChangeGResult();<br />
<br />g_fReady = TRUE; </p>
<p>Then, if the compiler doesn&#8217;t have any assumption about what the function does, it looks safe to me. But if the function is inline or if global optimizations are activated (allowing the compiler to look inside of the functions), there&#8217;s still a potential problem. So this method is still potentially dependent on compiler settings.</p>
<p>Thank you for asking Raymond for clarification, I admit I also didn&#8217;t think about reordering.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-311003">
				<div id="div-comment-311003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">AC</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-311003">
			October 5, 2005 at 6:10 am</a>		</div>

		<p>The another direct reference to cache synchronization problems may be &quot;The Java Memory Model is Fatally Flawed&quot; which describes &quot;weak memory model&quot;, present in Itanium architecture, where each processor has its own cache. It seems that there only some from all modifications can be flushed from the cache, unless the flush is forced.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-311163">
				<div id="div-comment-311163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-311163">
			October 5, 2005 at 12:09 pm</a>		</div>

		<p>I was talking about weak memory models, not compiler reordering. Marking your memory access as volatile doesn&#8217;t help if the reordering happens inside the CPU itself. I mentioned this in an earlier entry on the x86 being the weirdo. <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2004/09/14/229387.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2004/09/14/229387.aspx</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-311263">
				<div id="div-comment-311263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Solid</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-311263">
			October 5, 2005 at 2:51 pm</a>		</div>

		<p>Thank you, AC and Ray.</p>
<p>So, both compiler and cpu reordering will cause trouble in this case.</p>
<p>Well, the easiest to fix will be:<br />
<br />g_fReady = g_iResult &lt;&lt; 1 + 1;</p>
<p>There should be no re-ordering then.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-311273">
				<div id="div-comment-311273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-311273">
			October 5, 2005 at 3:14 pm</a>		</div>

		<p>Solid: I fail to see how this has any effect on the CPU. Litmus Test 4 (5.6.2.4) from the Alpha Architecture Reference Manual explicitly permits</p>
<p>initial values:<br />
<br /> x = 1<br />
<br /> y = 1</p>
<p>Thread1:<br />
<br /> store 2 to x<br />
<br /> store 2 to y</p>
<p>Thread2:<br />
<br /> read from y yields 1<br />
<br /> read from x yields 2</p>
<p>In our case, let x be g_iResult and y be g_fReady.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-311403">
				<div id="div-comment-311403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Solid</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-311403">
			October 5, 2005 at 9:57 pm</a>		</div>

		<p>Thanks, Ray.</p>
<p>I&#8217;m surprised (and very glad) you reply to me.</p>
<p>My idea is that, by doing:</p>
<p>g_fReady = g_iResult &lt;&lt; 1 + 1;</p>
<p>g_fReady has to be calculated after g_iResult got calculated, otherwise, the result is wrong.</p>
<p>Thread 1<br />
<br />g_iResult = -1;<br />
<br />&#8230;<br />
<br />g_iResult = final result, say 1;   &lt;&lt;&#8212;&#8211;1<br />
<br />g_fReady = g_iResult &lt;&lt; 1 + 1;     &lt;&lt;&#8212;2</p>
<p>2 should not be executed b4 1.</p>
<p>Even 2 is not atomic, but that does not matter in this case.</p>
<p>Thanks. </p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even thread-even depth-1" id="comment-311453">
				<div id="div-comment-311453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20051003-08/?p=33943#comment-311453">
			October 6, 2005 at 1:15 am</a>		</div>

		<p>Certainly 2 is executed after 1, but that doesn&#8217;t mean that all processors will see the resulting memory changes in the same order.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

