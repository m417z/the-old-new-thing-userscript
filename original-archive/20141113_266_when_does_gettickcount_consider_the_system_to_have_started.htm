<html>
<head>
<title>When does GetTickCount consider the system to have started?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>When does GetTickCount consider the system to have started?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>November 13, 2014 / year-entry #267</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>45</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The Get­Tick­Count and Get­Tick­Count­64 functions return "the number of milliseconds that have elapsed since the system was started." (The 32-bit version wraps around after around 50 days.) But when exactly is the system considered to have started? Is it when power is applied to the computer? When the BIOS completes POST? When the user picks...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>The <code>Get&shy;Tick&shy;Count</code> and <code>Get&shy;Tick&shy;Count&shy;64</code> functions return "the number of milliseconds that have elapsed since the system was started." (The 32-bit version wraps around after around 50 days.) But when exactly is the system considered to have started? Is it when power is applied to the computer? When the BIOS completes POST? When the user picks the operating system from the boot menu? When the kernel switches to protected mode?</p>
<p> It isn't defined exactly when the timer starts. Because that's not its purpose. </p>
<p> The purpose of <code>Get&shy;Tick&shy;Count</code> is to let you measure intervals of time. It provides a common clock source so that multiple components can coordinate their actions. It also allows you to retrieve the tick count at one point, then retrieve the tick count at another point, subtract them, and conclude how much time has elapsed between those two points. The absolute value of the tick count is not meaningful. The only way to extract meaning from it is to subtract it from another tick count to get the delta. </p>
<p> In fact, on debugging builds of Windows, the kernel artificially sets the <code>Get&shy;Tick&shy;Count</code> counter to "one hour before 32-bit timer tick rollover"; it effectively backdates the boot time by around 50 days. This is done to help identify bugs related to timer tick rollover. </p>
<p> If your goal is to measure operating system boot time from the application of power to the computer, then <code>Get&shy;Tick&shy;Count</code> is not going to be useful. After all, Windows isn't even running at the moment you apply power to the computer. The BIOS does its work without any operating system all, so Windows has no idea how long the BIOS took to POST. The text in MSDN could be a bit more explicit and say "elapsed since Windows started", or it could be pointlessly nitpicky and say "elapsed since the Windows HAL initialized the programmable interval timer." </p>
<p> Better would be if it simply described how the timer is intended to be used. "<code>Get&shy;Tick&shy;Count</code> returns a value which increases at a rate of 1000 per second." Perhaps with some clarifying text: "By convention, the zero point of the <code>Get&shy;Tick&shy;Count</code> counter is the approximate time the system booted. Note, however, that this convention is violated on occasion (such as on a checked build of Windows), so applications should not ascribe any meaning to the zero point of the tick counter." </p>
<p> If you want to know how much time elapsed since the application of power, you need to use a stopwatch. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (45)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1161703">
				<div id="div-comment-1161703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Xv8</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161703">
			November 13, 2014 at 7:09 am</a>		</div>

		<p>There are only 4 unsolved problems in programming.</p>
<p>Naming Things, Cache Invalidation, Address Validation and Time.</p>
<p>And the first 2 seem solvable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161723">
				<div id="div-comment-1161723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161723">
			November 13, 2014 at 8:17 am</a>		</div>

		<p>@Joker_vD: I just use the subtract between two returns of GetTickCount (I always know which one was earlier so integer rollover does the right thing!). Never had a problem where the 49.X days would come up because my distances were measured in seconds at worst.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161743">
				<div id="div-comment-1161743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161743">
			November 13, 2014 at 8:40 am</a>		</div>

		<p>Who cares whether the tick count is from when the computer is turned on versus when Windows started running?</p>
<p>I&#39;m more interested in how the tick count is affected by sleeping and hibernating. If the system is asleep or hibernating for a day, does GetTickCount consider the system to have started a day later?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161753">
				<div id="div-comment-1161753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161753">
			November 13, 2014 at 9:15 am</a>		</div>

		<p>Joker_vD: you measure periodically at intervals of less than 20 days, and add them up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161763">
				<div id="div-comment-1161763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Innocent Bystander</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161763">
			November 13, 2014 at 9:27 am</a>		</div>

		<p>GetTickCount() is a massive pain due to the 49.7 day roll-over bugs that have plagued the universe since its inception. The windows debug setting should have been the standard build setting so that developers found these issues in development not production! How many testing shops use windows debug builds? How many run tests for &gt; 50 days? Not many I&#39;d wager, and so the fragility is passed on to the end user. More could have been done here to improve the reliability of all apps everywhere. Seriously, why was the 1 hour after start roll over not added as the default? (I know that there are ways to test this situation, but surely setting this as the default would have made this situation much less of an issue).</p>
<div class="post">[<em>In 1983, nobody left their computer on 24 hours a day. 49 days was ridiculously long. Also: It&#39;s hard to do 64-bit math on a 16-bit machine. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161803">
				<div id="div-comment-1161803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Innocent Bystander</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161803">
			November 13, 2014 at 10:30 am</a>		</div>

		<p>@Raymond &nbsp;</p>
<p>Perhaps no one ran a Windows type PC for 50 straight days in 1983, but by the early 90&#39;s they certainly did. There was still plenty of time to change this default or provide an easy way (and recommend it) for developers/testers to do so in order to test.</p>
<p>@Ken Hagan</p>
<p>How about a compromise? 24 hours. 24 hours is enough that most testing shops will pick it up, and infrequent enough that most users will at least not blame windows.</p>
<div class="post">[<em>As noted by another commenter: Once you change the default, you break apps. &quot;Don&#39;t upgrade to Windows 2.0. Apps crash after 24 hours.&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161813">
				<div id="div-comment-1161813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161813">
			November 13, 2014 at 10:31 am</a>		</div>

		<p>I work for Contoso and we&#39;re having a problem I am hoping someone can help solve. If I start our program soon after boot, it crashes about an hour later, but after that it runs fine. Can anyone help?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161823">
				<div id="div-comment-1161823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Innocent Bystander</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161823">
			November 13, 2014 at 10:43 am</a>		</div>

		<p>@Evan</p>
<p>You likely have a bug involving GetÂ­TickÂ­Count(). Allow me to point you to this relevant documentation &#8230; on resolving your issue (or contact the software provider). At 50 days you don&#39;t get bug reports saying &quot;this app crashes after 50 days&quot; you get a variety of reports, none of them reproducible, saying: &quot;the app randomly crashes every once in a blue moon&quot;. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161833">
				<div id="div-comment-1161833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161833">
			November 13, 2014 at 10:56 am</a>		</div>

		<p>@Evan</p>
<p>If this is only on some machines, check to make sure no one has changed the default GetTickCount() value to just before the rollover on those machines in HKLMSoftwareMicrosoftWindows NTCurrentVersionThingsAddedByRequestOfInnocentBystanderGetTickCountValue. You shouldn&#39;t worry about this being a problem in &nbsp;production, since that value doesn&#39;t normally roll over for 50 days, and no one runs a Windows machine for that long without rebooting.</p>
<p>Signed,</p>
<p>Highly Upvoted Anonymous StackOverflow Answer</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161843">
				<div id="div-comment-1161843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161843">
			November 13, 2014 at 11:13 am</a>		</div>

		<p>Regarding this huge rollover problem&#8230; </p>
<p>I have come up with this great idea that could be useful: If t1 is immediately before the rollover, and t2 is shortly after, rather than doing a subtraction, we could add the distance from t1 to the rollover and t2 from the rollover. Since the rollover is at 000&#8230;0000, the second value is given directly by the t2 value, the problem is the t1-to-rollover. But we can obtain it by calculating 0-t1, which can be done by a neat little trick: Flip all bits over to their opposite values, and then adding 1 to the value (some people call this the &quot;2-complement&quot;). Using this little trick, the two distances from the rollover point is calculated by t2 + ( 0 &#8211; t1 ), which is equal to t2 &#8211; t1, if you use this &quot;2-complement&quot; trick. Neat, isn&#39;t it?</p>
<p>Now then, how many instructions do you need for that? I really wonder how t2 &#8211; t1 would be handled by an ordinary simple subtraction instruction on a 2-complement machine. Maybe it wouldn&#39;t be THAT much different&#8230;. :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161853">
				<div id="div-comment-1161853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161853">
			November 13, 2014 at 11:16 am</a>		</div>

		<p>There is a perfectly acceptable way to determine a time interval: poll the system clock. Unix timestamps won&#39;t roll over until 2038. If you use a mechanism which uses a 64-bit number by the time it&#39;s a problem you&#39;ll be long dead (.NET goes until the end of the year 9999).</p>
<p>Sure it&#39;s not as accurate, but if you have to record a large enough time interval that tick count is overflowing, somehow I doubt the precision is that important. Not to mention it&#39;s likely the user will have rebooted long before it overflows, in most cases (Patch Tuesday is once a month, if nothing else). Having a server sorta invalidates that assumption but my &quot;precision&quot; argument still stands&#8230;</p>
<p>Side note: I remember when my Windows XP tick count rolled over, once. That was when I knew for sure we had entered the era of the stable Windows OS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161863">
				<div id="div-comment-1161863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andreas Rejbrand</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161863">
			November 13, 2014 at 11:23 am</a>		</div>

		<p>My main computer is always on, but in practice the uptime never exceeds a month or so, because of Windows Update demanding reboots.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161873">
				<div id="div-comment-1161873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aaron</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161873">
			November 13, 2014 at 11:44 am</a>		</div>

		<p>Other than a stop-watch, there must be a good way to measure computer boot-up speed.</p>
<p>Boot speed has frequently been a competitive selling point for laptops, and measured down to the fraction of a second.</p>
<p>From an electrical circuit point of view, its not hard to imagine a hardware clock that starts at zero, and counts as long as it has power, regardless of BIOS, POST, OS, drivers, or anything else.</p>
<p>I think a 555 circuit is essentially this.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161883">
				<div id="div-comment-1161883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161883">
			November 13, 2014 at 11:46 am</a>		</div>

		<p>A certain piece of build automation software used at a company I used to work for had a bug in it where we&#39;d get a build failure if a build happened to be running when GetTickCount() rolled over. &nbsp;IIRC, the stack traces and debugging info from the error logs it produced indicated that a C# checked arithmetic exception was getting thrown a few instructions after a call to GetTickCount().</p>
<p>I figured this out and predicted another build failure to the minute (2^32 seconds later) and wowed by coworkers with my psychic powers (although to be correct, a build had to be running at the time, and builds were probably running maybe 50% of the time during business hours).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161893">
				<div id="div-comment-1161893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161893">
			November 13, 2014 at 11:49 am</a>		</div>

		<p>@The MAZZTer: About that &quot;poll the system clock&quot; â what about NTP?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161903">
				<div id="div-comment-1161903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161903">
			November 13, 2014 at 11:53 am</a>		</div>

		<p>[Also: It&#39;s hard to do 64-bit math on a 16-bit machine. -Raymond]</p>
<p>No harder than 32 bit math. The only &quot;hard&quot; op is division, and it&#39;s a library op even for 32 bit. The actual problem is long long int hadn&#39;t been invented yet.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161913">
				<div id="div-comment-1161913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161913">
			November 13, 2014 at 12:37 pm</a>		</div>

		<p>Joshua: hard in the sense that you generally only have one 32-bit register to do stuff with (dx:ax) without saving stuff to the stack. If you have to add two 64-bit numbers, you&#39;re going to have to do that in memory. Not to mention the fact that the library for doing 64-bit division with 16-bit stores is not small.</p>
<div class="post">]<em>Mostly because no 16-bit compiler supports 64-bit integers. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161923">
				<div id="div-comment-1161923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JJJ</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161923">
			November 13, 2014 at 12:49 pm</a>		</div>

		<p>Even if the counter started counting the instant the computer received power, it still wouldn&#39;t be accurate. &nbsp;Clocks drift and by the time it&#39;s ready to roll over at 50 days anyway it&#39;s going to be off by several seconds.</p>
<p>Regarding automated boot-up time measurements, I would do it using an external PC, an ethernet-connected power switch, and an idle-time task program from yesterday. &nbsp;The external PC powers on the computer and listens on a socket. &nbsp;The idle-time task connects to the socket to signal that it&#39;s done booting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kirbyfcf2 even thread-even depth-1" id="comment-1161933">
				<div id="div-comment-1161933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Kirby+FC' rel='external nofollow' class='url'>Kirby FC</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161933">
			November 13, 2014 at 1:51 pm</a>		</div>

		<p>Although it is true that there is no way to determine how long it has been since the &#39;system&#39; was started, In Windows 7 (and probably other versions as well) if you go into Task Manager and select the &#39;Processes&#39; tab there is an item at the bottom titled &#39;Up Time&#39;. &nbsp;</p>
<p>Mine currently says 0:09:30:04 so obviously someone on the Windows team feels it is necessary, and possible, to keep track of how long it has been since Windows started.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161943">
				<div id="div-comment-1161943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161943">
			November 13, 2014 at 2:06 pm</a>		</div>

		<p>@The MAZZTer: the system clock is not monotonic; it can go backwards, either because the user changed the system time or because a NTP daemon decided that the clock was wrong. It can also have large discontinuities for the same reason. What you want is a monotonic clock (CLOCK_MONOTONIC on Unix, I don&#39;t know the equivalent on Windows).</p>
<p>@Raymond: actually, on UEFI it seems to be possible to know how long the firmware took to POST. On Linux, systemd-analyze can show you that information, as long as you use the correct bootloader; said bootloader also tells systemd how long it took within the bootloader itself.</p>
<p>And on a related trivia, the Linux kernel also does the &quot;start the time just before rollover&quot; trick (starting at -300 seconds), for the same reasons. Only that the relevant timer (jiffies) is not exported to userspace, and there&#39;s no ABI guarantee for drivers on Linux, so there were no compatibility concerns and it&#39;s always done.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161963">
				<div id="div-comment-1161963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xor88</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161963">
			November 13, 2014 at 2:57 pm</a>		</div>

		<p>The debug build trick seems to not have helped the CLR team. The .NET Framework is full of unsafe uses of TickCount (which I know from Reflector). Every 50 days all kinds of timeouts suddenly trigger. Really scary stuff, especially in server apps.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161713">
				<div id="div-comment-1161713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161713">
			November 13, 2014 at 8:11 am</a>		</div>

		<p>By the way, sometimes you also want to compare TickCounts to detemine which event happened earlier. How does one then work around the &quot;timer tick rollover bugs&quot;? I can think only of two workarounds: either use GetTickCount64, or call GetTickCount() at the program start, and then use deltas based on that value (so that if you start an minute before the rollover, and an event happens two minutes after the rollover, you subtract (MAX_DWORD &#8211; 60*1000 + 1) from 120 * 1000 and get 180 * 1000, three minutes, which is the correct answer. But it still limits the window of events you can track as 50 days big, which sometimes can be limiting :(</p>
<div class="post">[<em>Obviously, if you need to track durations longer than 50 days, you cannot use GetTickCount, because you have no way to tell the difference between a tick count of X and a tick count of X + 2^32. (And assuming you don&#39;t have to deal with intervals of more than 20 days, handling rollover is <a href="http://blogs.msdn.com/b/oldnewthing/archive/2005/05/31/423407.aspx" rel="nofollow">much easier than you describe</a>.) -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161973">
				<div id="div-comment-1161973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">foo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161973">
			November 13, 2014 at 5:03 pm</a>		</div>

		<p>Dealing with rollover and epoch tracking was ever-present in GPS land which has (or at least had) a 1024 week rollover for its timestamps. And the computers at the time ran Windows 3.1. Anyways for intervals using MSVC/Win32/x86 I&#39;ve always just subtracted the finish &#8211; start if both variables are a DWORD and the result is a long. If the result is also a DWORD then do a labs() or cast a subtracted variable to a long.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1161793">
				<div id="div-comment-1161793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Hagan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161793">
			November 13, 2014 at 9:53 am</a>		</div>

		<p>&quot;Seriously, why was the 1 hour after start roll over not added as the default?&quot;</p>
<p>I&#39;m guessing, but I would guess that it wasn&#39;t the default *in 1983* because programmers were smarter then and it hasn&#39;t subsequently *become* the default because of the usual argument that Microsoft prefer to side with end-users rather than developers. (Once there are applications &quot;out there&quot; that mis-behave, the most helpful initial value for the ticker is the one that puts off the bug for as long as possible, rather than one that waits for you to get an hour&#39;s work done and then crashes.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1161983">
				<div id="div-comment-1161983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1161983">
			November 13, 2014 at 5:58 pm</a>		</div>

		<p>Hmm my Windows uptime check was GetTickCount64. Obviously no good in checked builds but I never used it for anything important. I wonder what Task Manager uses. Start time of the System process should do it assuming you can see it (permissions).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1162003">
				<div id="div-comment-1162003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Azarien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162003">
			November 14, 2014 at 1:26 am</a>		</div>

		<p>&quot;Mostly because no 16-bit compiler supports 64-bit integers. -Raymond&quot;</p>
<p>Open Watcom does. But I doubt it did back in 1983..</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162013">
				<div id="div-comment-1162013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Innocent Bystander</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162013">
			November 14, 2014 at 1:42 am</a>		</div>

		<p>@xor88</p>
<p>That is a depressing story. GetTickCount64 should sort these issues out eventually, but you would have thought that Microsoft could keep their own house in order. Perhaps they don&#39;t use the windows checked builds either. </p>
<p>GetTickCount is an example of a method that will inevitably lead to issues as it can&#39;t be easily tested. The Windows api is full of such things. In magical unicorn land I&#39;d like special test version of the windows api where I could inject errors for testing. Please.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1162023">
				<div id="div-comment-1162023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DebugErr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162023">
			November 14, 2014 at 3:25 am</a>		</div>

		<p>Can I enable this 50 days &#8211; 1 hour debug setting in unchecked version of Windows too? I&#39;d like to test my applications against it &#8211; and I&#39;m also curious if other applications handle it correctly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162033">
				<div id="div-comment-1162033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tomashu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162033">
			November 14, 2014 at 4:30 am</a>		</div>

		<p>@DebugErr</p>
<p>What about Application Verifier, it has option called &quot;TimeRollOver&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman odd alt thread-odd thread-alt depth-1" id="comment-1162063">
				<div id="div-comment-1162063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162063">
			November 14, 2014 at 6:13 am</a>		</div>

		<p>@Aaron &#8211; a 555 circuit doesn&#39;t count anything. It is simply a pulse generator. You actually need something more to do the counting.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman even thread-even depth-1" id="comment-1162073">
				<div id="div-comment-1162073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162073">
			November 14, 2014 at 6:18 am</a>		</div>

		<p>[Mostly because no 16-bit compiler supports 64-bit integers. -Raymond]</p>
<p>Surely you meant 16-bit Windows compilers (of that era). Because my 16-bit MPS430 compiler surely supports 64-bit integers today.</p>
<p>And by support, you meant natively supports. Because you could just make a struct of four 16-bit words (which in memory looks an awful lot like a native 64-bit number if you mind your endianess) and create your own library for simple operations on pairs of those structs.</p>
<div class="post">[<em>Problem: &quot;I want to measure how much time has elapsed between two events.&quot; Solution 1: &quot;Wait 30 years, and then there will be a compiler that will support this.&quot; Solution 2: &quot;Here&#39;s a structure, go do multiprecision arithmetic. (Good luck getting carry to work in C.)&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1162093">
				<div id="div-comment-1162093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">laonianren</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162093">
			November 14, 2014 at 8:47 am</a>		</div>

		<p>@Joshua I guess Task Manager&#39;s &quot;Up Time&quot; comes from HKEY_PERFORMANCE_DATA&#39;s &quot;SystemSystem Up Time&quot; counter. &nbsp;This shows the time the system has actually been awake since boot; the elapsed time of the System process (which is just the start time in disguise) also includes time spent asleep since boot.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162123">
				<div id="div-comment-1162123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162123">
			November 14, 2014 at 10:33 am</a>		</div>

		<p>Solution 3: Library function in kernel.dll takes two structures in and spits double out.</p>
<div class="post">[<em>You&#39;re telling me I have to link in a 30KB floating point emulator library just to calculate elapsed time? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1162133">
				<div id="div-comment-1162133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162133">
			November 14, 2014 at 12:01 pm</a>		</div>

		<p>[You&#39;re telling me I have to link in a 30KB floating point emulator library just to calculate elapsed time? -Raymond]</p>
<p>Every 16 bit Windows deployment I looked at would have consumed less RAM and disk if there was one master copy in the system libraries.</p>
<div class="post">[<em>Okay, then, &quot;Why is Windows using 10% of my RAM for floating point emulation?&quot; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162153">
				<div id="div-comment-1162153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162153">
			November 14, 2014 at 8:17 pm</a>		</div>

		<p>@xor88: The debug build trick didn&#39;t help the CLR because the test team for .NET evidently doesn&#39;t use debug or checked builds. &nbsp;I installed a checked build once, with a kernel debugger attached, and WinForms was triggering &quot;invalid argument&quot; type messages from the enhanced system API argument validation constantly. &nbsp;I reported some on Connect, nobody cared that Reflector showed the code was really and truly violating MSDN requirements; they fixated on can&#39;t repro, because their repro environment didn&#39;t have checked builds.</p>
<p>see <a rel="nofollow" target="_new" href="https://connect.microsoft.com/VisualStudio/Feedback/Details/306816">connect.microsoft.com/&#8230;/306816</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1162163">
				<div id="div-comment-1162163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162163">
			November 14, 2014 at 8:25 pm</a>		</div>

		<p>Oh by the way, to tie back into Raymond&#39;s blog, WM_PAINT handling in both scratch programs (C and C++ versions) has that bug.</p>
<p>By now there&#39;s probably an AppCompat shim for &quot;illegally calls BeginPaint with an empty update region&quot;</p>
<div class="post">[<em>Not sure what you&#39;re talking about. And besides, it&#39;s legal to call BeginPaint even when the update region is empty. Indeed, how do you even know whether the update region is empty except by calling BeginPaint and then checking the rectangle it returns? -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162183">
				<div id="div-comment-1162183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162183">
			November 15, 2014 at 8:58 am</a>		</div>

		<p>Raymond: The problem is not checking for BeginPaint returning NULL.</p>
<div class="post">[<em>Then the code operates on a null DC, which paints nothing. Lots of invalid parameter errors, but the failure mode is safe. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1162203">
				<div id="div-comment-1162203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162203">
			November 16, 2014 at 7:41 pm</a>		</div>

		<p>Actually 8087 did offer 64-bit integer addition. Just that most systems didn&#39;t equip with x87 coprocessor and you can&#39;t be sure about it&#39;s existence before 486 series of CPUs gone out of market. (And it&#39;s not quite enough if you count the non-widely-used Nx586 in to support pool)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162223">
				<div id="div-comment-1162223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ZLB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162223">
			November 17, 2014 at 4:09 am</a>		</div>

		<p>Surely GetTickCount64() solves any issues that may be cause by wrap-araound and uptimes of more than 51 days?</p>
<p>Ok, it&#39;s still a problem for older software or if you need to support WinXP still though, but for new software, it shouldn&#39;t still be a problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1162383">
				<div id="div-comment-1162383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Marc K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162383">
			November 18, 2014 at 5:32 am</a>		</div>

		<p>I don&#39;t understand all the drama over the 50 day rollover. Common practice has been to subtract two values from GetTickCount() using DWORDs (unsigned 32 bit ints). The underflow will ensure you get the correct delta. The problem with the rollover comes into play if you try to do comparisons, which you shouldn&#39;t be doing. (e.g. if (currentValue &lt; lastValue) LaunchNuclearStrike();)</p>
<div class="post">[<em>You&#39;d be surprised how many people are not familiar with the common practice. Even in this thread, people suggest alternatives. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162483">
				<div id="div-comment-1162483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim Mischel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162483">
			November 18, 2014 at 10:30 am</a>		</div>

		<p>If you want to test your programs against the rollover problem, there&#39;s no need to get the debug build that starts the clock at rollover &#8211; 300 seconds. In C, simply redefine GetTickCount() in your debug builds so that it goes to your own function, which gets the tick count and adds (UINTMAX-300000) to it. You can do similar things in other languages.</p>
<div class="post">[<em>Don&#39;t forget to inject code into your TIMERPROCs and window hooks to adjust the time there. And redefine functions like GetMessage (which accept or return timestamps). Uh-oh, but you don&#39;t control all callers of GetMessage. And if you need to marshal that timestamp to another process&#8230; -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-1162573">
				<div id="div-comment-1162573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162573">
			November 18, 2014 at 6:16 pm</a>		</div>

		<p>Marc K: Relying on underflow isn&#39;t good either. wait until the clock ticks run over 99 days.</p>
<p>(Hint: My boss in summer job have had Novell servers that aren&#39;t rebooted over 5 years, since the age of HKT, and still in good condition at that time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162533">
				<div id="div-comment-1162533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162533">
			November 18, 2014 at 4:23 pm</a>		</div>

		<p>Raymond, that&#39;s not what MSDN documentation for WM_PAINT (<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd145213%28v=vs.85%29.aspx" target="_new" rel="nofollow">msdn.microsoft.com/&#8230;/dd145213%28v=vs.85%29.aspx</a>) says:</p>
<p>&quot;An application should call the GetUpdateRect function to determine whether the window has an update region. If GetUpdateRect returns zero, the application should not call the BeginPaint and EndPaint functions.&quot;</p>
<p>Perhaps it is *legal* to do things that MSDN says &quot;should not&quot;, but the resulting failure cascade is not the result I like to have from the framework I use to build applications.</p>
<div class="post">[<em>This is in a paragraph that is providing guidance on handling RDW_INTERNALPAINT; not guidance on BeginPaint in general. I&#39;ll see what I can do to have the documentation clarified. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1162733">
				<div id="div-comment-1162733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162733">
			November 19, 2014 at 9:10 am</a>		</div>

		<p>@Raymond: Besides, I don&#39;t think it is safe for the .NET Framework to assume that an application never calls RedrawWindow with RDW_INTERNALPAINT. &nbsp;Of course, the assumption IS valid for your scratch program.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1162713">
				<div id="div-comment-1162713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141113-00/?p=43623#comment-1162713">
			November 19, 2014 at 9:03 am</a>		</div>

		<p>@Raymond: My interpretation of the documentation was:</p>
<p>1. WM_PAINT can arrive even though the update region is empty.</p>
<p>2. RDW_INTERNALPAINT is one of the things that sends WM_PAINT even when the update region is empty.</p>
<p>3. To make your WM_PAINT handler work properly when the update region is empty, call GetUpdateRect first and only call BeginPaint if the update region is not empty.</p>
<p>Specifically, I interpret that you are supposed to skip BeginPaint *any* time the update region is empty, whether or not RDW_INTERNALPAINT was involved.</p>
<div class="post">[<em>The documentation is misusing the word &quot;should&quot; (how timely given <a href="http://blogs.msdn.com/b/oldnewthing/archive/2014/11/19/10574048.aspx" rel="nofollow">a topic a few days later</a>. The &quot;should&quot; here is saying &quot;If you want to avoid null updates, you should&#8230;&quot; The discussion is in the context of detecting null update regions. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

