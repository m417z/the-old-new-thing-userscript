<html>
<head>
<title>How do I get a radio button control to render its text transparently?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How do I get a radio button control to render its text transparently?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 28, 2010 / year-entry #186</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>20</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Commenter Andrei asks via the Suggestion Box for help with making the text transparent using WM_CTL­COLOR­STATIC. "Instead of the radio button now there's a black background." Let's look at this problem in stages. First, let's ignore the transparent part and figure out how to render text without a black background. The background color of the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Commenter
<a HREF="http://www.hardcode.ro">Andrei</a>
asks via the Suggestion Box
for help with
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2007/05/23/407234.aspx#1520893">
making the text transparent using
<code>WM_<wbr>CTL&shy;COLOR&shy;STATIC</wbr></code></a>.
"Instead of the radio button now there's a black background."
</p>
<p>
Let's look at this problem in stages.
First, let's ignore the transparent part and figure out
how to render text without a black background.
The background color of the text comes from the color you
selected into the DC when handling the
<code>WM_<wbr>CTL&shy;COLOR&shy;STATIC</wbr></code>
message.
And if you forget to set a background color,
then you get whatever color is lying around in the DC,
which might very well be black.
Start with
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2003/07/23/54576.aspx">
the scratch program</a>
and make these changes, which I'm going to write in the way
I think Andrei wrote it,
even though it doesn't fit the style of the rest of the
scratch program.
</p>
<pre>
<font COLOR=blue>HBRUSH g_hbr;</font>
BOOL
OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{
<font COLOR=blue>    g_hwndChild = CreateWindow(TEXT("button"), TEXT("Bingo"),
        WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON,
        0, 0, 0, 0, hwnd, (HMENU)1, g_hinst, 0);
    g_hbr = CreateSolidBrush(RGB(0xFF, 0x00, 0xFF)); // hot pink</font>
    return TRUE;
}

void
OnDestroy(HWND hwnd)
{
    <font COLOR=blue>if (g_hbr) DeleteObject(g_hbr);</font>
    PostQuitMessage(0);
}

// add to WndProc

<font COLOR=blue>  case WM_CTLCOLORSTATIC:
    if (GetDlgCtrlID(
             GET_WM_CTLCOLOR_HWND(wParam, lParam, uiMsg)) == 1) {
      return (LRESULT)g_hbr; // override default background color
    }
    break;</font>
</pre>
<p>
If you run this program, the radio button's background is indeed
hot pink, well except for the text, where the color is,
I dunno, it's white on my machine, but who knows what it is on yours.
Since we didn't specify a color, the result is undefined.
The bug here is that we handled the
<code>WM_<wbr>CTL&shy;COLOR&shy;STATIC</wbr></code>
message incompletely.
The <code>WM_<wbr>CTL&shy;COLOR</wbr></code> family of messages requires that
the message handler do three things:
</p>
<ol>
<li>Set the DC text color.
</li>
<li>Set the DC background color.
</li>
<li>Return a background brush.
</li>
</ol>
<p>
We got so excited about the background brush that we forgot the other
two steps. Let's fix that.
</p>
<pre>
case WM_CTLCOLORSTATIC:
    if (GetDlgCtrlID(
             GET_WM_CTLCOLOR_HWND(wParam, lParam, uiMsg)) == 1) {
      <font COLOR=blue>HDC hdc = GET_WM_CTLCOLOR_HDC(wParam, lParam, uiMsg);
      SetTextColor(hdc, RGB(0xFF, 0xFF, 0x00)); // yellow
      SetBkColor(hdc, RGB(0xFF, 0x00, 0xFF)); // hot pink</font>
      return (LRESULT)g_hbr; // override default background color
    }
    break;
</pre>
<p>
(Just for fun, I chose yellow as the text color.)
Now that we specified the text color and the background color,
the text appears in the correct colors.
</p>
<p>
Note that we didn't actually do anything transparently here.
We just made sure that the background color we told the control
to use for text matches the color we told the control
to use for erasing the background.
The effect looks transparent since the two colors match.
</p>
<p>
But what if you really wanted transparency instead of fake
transparency?
To illustrate, let's give the control a background that is not
a solid color:
</p>
<pre>
BOOL
OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{
    g_hwndChild = CreateWindow(TEXT("button"), TEXT("Bingo"),
        WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON,
        0, 0, 0, 0, hwnd, (HMENU)1, g_hinst, 0);
    <font COLOR=blue>g_hbr = <a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2003/10/09/55243.aspx">CreatePatternBrushFromFile</a>(
                          TEXT("C:\\Windows\\Gone Fishing.bmp"));</font>
    return TRUE;
}
</pre>
<p>
When you run this version of the program, the radio button background
consists of the Gone Fishing bitmap.
(Of course, if you don't have that bitmap, then feel free to substitute
another bitmap.
I can't believe I had to write that.)
But the text is still yellow on pink.
How do we get it to be yellow on the complex background?
</p>
<p>
By setting the background mix mode to <code>TRANSPARENT</code>.
</p>
<pre>
case WM_CTLCOLORSTATIC:
    if (GetDlgCtrlID(
             GET_WM_CTLCOLOR_HWND(wParam, lParam, uiMsg)) == 1) {
      HDC hdc = GET_WM_CTLCOLOR_HDC(wParam, lParam, uiMsg);
      SetTextColor(hdc, RGB(0xFF, 0xFF, 0x00)); // yellow
      SetBkColor(hdc, RGB(0xFF, 0x00, 0xFF)); // hot pink
      <font COLOR=blue>SetBkMode(hdc, TRANSPARENT);</font>
      return (LRESULT)g_hbr; // override default background color
    }
    break;
</pre>
<p>
According to the documentation, the background mix mode
"is used with text, hatched brushes,
and pen styles that are not solid lines."
It's the text part we care about here.
When the control does its <code>Text&shy;Out</code> 
to draw the control text, the background mix mode
causes the text to be rendered transparently.
</p>
<p>
<b>Exercise</b>:
There's actually one more thing you need to do,
but I conveniently arranged the program so you didn't notice.
What other step did I forget?</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (20)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-843033">
				<div id="div-comment-843033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lonnie McCullough</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843033">
			June 28, 2010 at 7:20 am</a>		</div>

		<p>You still need to translate the brush origin with a call to SetBrushOrgEx. &nbsp;Because the radio button is located at (0,0) this happened to be unnessecary in your sample, but it will look horrible if the radio button is located anywhere but at (0,0).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843043">
				<div id="div-comment-843043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://wizou.fr' rel='external nofollow' class='url'>Wizou</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843043">
			June 28, 2010 at 7:23 am</a>		</div>

		<p>Why did you use WM_CTLCOLORSTATIC rather than WM_CTLCOLORBTN for handling the color of a &quot;button&quot; ?</p>
<p>(Maybe that&#39;s the point of the exercise)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843053">
				<div id="div-comment-843053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://wizou.fr' rel='external nofollow' class='url'>Wizou</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843053">
			June 28, 2010 at 7:26 am</a>		</div>

		<p>replying to myself: <a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/130952" rel="nofollow">support.microsoft.com/&#8230;/130952</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843103">
				<div id="div-comment-843103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843103">
			June 28, 2010 at 9:10 am</a>		</div>

		<p>I&#39;m going to feel stupid im sure when I see the actual missing step. My potential missing steps are: Didn&#39;t set the brush as the window&#39;s background brush? Didn&#39;t add the manifestdependency to use xp-themed controls? Didn&#39;t provide the code for CreatePatternBrushFromFile? The radio button also has a zero width and height. All easy to fix. Damnit I actually compiled and ran this, and thats all I did.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843163">
				<div id="div-comment-843163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sebastian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843163">
			June 28, 2010 at 10:05 am</a>		</div>

		<p>Would it be possible to just return a handle to the NULL_BRUSH?</p>
<p>return (LRESULT)g_hbr = GetStockObject(NULL_BRUSH);</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843213">
				<div id="div-comment-843213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843213">
			June 28, 2010 at 12:29 pm</a>		</div>

		<p>No &#8211; passing a NULL brush looks ok, until the window is invalidated. Then the area of the control is simply not repainted leading to ugly artifacts.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843223">
				<div id="div-comment-843223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843223">
			June 28, 2010 at 1:11 pm</a>		</div>

		<p>Actually, this is not at all close to how you should do this. You can run into all kinds of problems, especially when in your current style the background is not uniform.</p>
<p>You must have the parent control help your radio button erase its background. If you do it any other way you end up in well known anti-pattern: whitelist programming (so called because for every combination of situations you encounter you implement a fix, adding it as it were to the âwhitelistâ, hoping that eventually you&#39;ll have covered every eventuality).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843233">
				<div id="div-comment-843233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lonnie McCullough</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843233">
			June 28, 2010 at 1:23 pm</a>		</div>

		<p>The code to call SetBrushOrgEx looks something like this:</p>
<p>POINT ptChild = { 0, 0 };</p>
<p>MapWindowPoints( g_hwndChild, hwnd, &amp;ptChild, 1 );</p>
<p>SetBrushOrgEx( hdc, ptChild.x, prChild.y, NULL );</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843243">
				<div id="div-comment-843243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sebastian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843243">
			June 28, 2010 at 2:58 pm</a>		</div>

		<p>Now let&#39;s assume I have the radio button in a themed tab control. The tab control is painted with using DrawThemeBackground. This has a gradient in Windows XP.</p>
<p>I often see code that paints the background of the radio button using DrawThemeParentBackground inside the WM_CTLCOLORSTATIC message and then returns the NULL_BRUSH. That is why I was asking about returning the NULL_BRUSH. That code appears to work, but painting inside WM_CTLCOLORSTATIC doesn&#39;t feel quite right. I suppose I would have to return a brush that paints the parent background. But I don&#39;t have a brush, because the parent is painted using DrawThemeBackground without using a brush. How do I get the brush that paints the background correctly?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843273">
				<div id="div-comment-843273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843273">
			June 29, 2010 at 12:23 am</a>		</div>

		<p>This is why I brought the xp-theming up. I havn&#39;t found any documentation, but it appears that when common controls 6 are applying xp theming, the rules for handling WM_CTLCOLORxxx change: I have a dialog handler that looks a lot like this :-</p>
<p>&nbsp;HDC hdc;</p>
<p>&nbsp;case WM_CTLCOLORSTATIC:</p>
<p>&nbsp; &nbsp;hdc = (HDC)wParam;</p>
<p>&nbsp; &nbsp;SetTextColor(hdc,RGB(0xff,00,00));</p>
<p>&nbsp; &nbsp;SetBkMode(hdc,TRANSPARENT);</p>
<p>&nbsp; &nbsp;if(IsAppThemed() &amp;&amp; IsComctl6InManifest())</p>
<p>&nbsp; &nbsp; &nbsp;return FALSE;</p>
<p>&nbsp; &nbsp;return (BOOL)GetSysColorBrush(COLOR_BTNFACE);</p>
<p>returning FALSE means that DefDlgProc should pass the message on to DefWindowProc() &#8211; comctl6 seems to ensure that the bk mode and text color in the HDC are preserved rather than reset in the case of a NULL HBRUSH return. I&#39;m not happy with this code without any official note confirming it &#8211; but its way better than returning NULL_BRUSH.</p>
<div class="post">[<i>&quot;returning FALSE means that DefDlgProc should pass the message on to DefWindowProc&quot; &#8211; true in general but not true for WM_CTLCOLORSTATIC, which is on the <a href="http://msdn.microsoft.com/en-us/library/ms645469(v=VS.85).aspx" rel="nofollow">special exceptions list</a>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843373">
				<div id="div-comment-843373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Limited_Atonement</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843373">
			June 29, 2010 at 9:00 am</a>		</div>

		<p>I looked for a post on which I could comment where this would be more relevant, but couldn&#39;t find it. &nbsp;So, now you can delete this off-topic question.</p>
<p>&nbsp;Every time I&#39;m confronted with a resizeable window in MS Windows (the new open file dialog), I breathe a small sigh of, well, I guess it&#39;s not relief, but it&#39;s happiness of some sort. &nbsp;Why aren&#39;t all Windows windows resizeable by default? &nbsp;By this I mean that most windows ought to be resizeable unless there&#39;s a good reason not to. &nbsp;And I don&#39;t mean to just make the border resizeable with no extra logic, I can do that. &nbsp;For instance, Visual Studio 2008 Tools &gt; Options window. &nbsp;How hard would it have been to write a little extra code for resizing those panels in there? &nbsp;Especially windows with humongous listboxes like the one in General &gt; Keyboard which, on my screen, only shows about 3.8 items on it, but it contains &#8230; upwards of two hundred?? &nbsp;I&#39;m sure people have complained about this particular dialog before, but I can&#39;t find that dialogue.</p>
<p>&nbsp;What are your thoughts?</p>
<div class="post">[<i>Somebody who says &quot;How hard would it have been to write a little extra code for resizing those panels in there?&quot; has never tried writing that little extra code for resizing panels. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843443">
				<div id="div-comment-843443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843443">
			June 29, 2010 at 7:01 pm</a>		</div>

		<p>According to the docs for WM_CTLCOLORSTATIC:</p>
<p>If a dialogue box procedure handles this message, it should cast the desired return value to a INT_PTR and return the value directly. If the dialogue box procedure returns FALSE, then default message handling is performed. The DWL_MSGRESULT value set by the SetWindowLong function is ignored.</p>
<p>Regarding the resizeable dialogues discussion:</p>
<p>By the early nineties other operating systems / window managers, as well as user interface tool-kits, generally supported this. And it was sorely needed &#8211; I still remember the pain of trying to access bits of Windows 98 dialogues that were hidden from view even though the resolution was normally set from within Windows; not even a scrollbar to help me out. And conversely I still bump into dialogues that have tiny lists to accommodate small screens / low resolutions. Resizing dialogues were added to Windows proper in 2006 or so, but only for Dotnet, not for native applications.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843503">
				<div id="div-comment-843503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843503">
			June 30, 2010 at 1:19 am</a>		</div>

		<p>@The resizable dialog discussion:</p>
<p>Waving Spy++ over various windows dialogs that show &quot;neat&quot; resizing behaviours &#8211; the Windows XP fast user switching screen, various parts of explorer (including some control panel views) use a window class called DirectUI to get some kind of subset of &quot;Easy layout &amp; animation&quot; to non-managed win32 apps. [2x size AA Sarcastic statements blaming Raymond personally for Microsoft not making some internal technology available to developers not included].</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843453">
				<div id="div-comment-843453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">steveg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843453">
			June 29, 2010 at 7:01 pm</a>		</div>

		<p>@Limited Atonement: Like Raymond says it&#39;s just not that easy using the Win32 API, you have manually recalculate the positions of all your sub controls (and sub-sub controls), move them, repaint them, deal with flickering, bounds checking, inevitable &quot;off by 1&quot; errors, minimum size, maximum size etc&#8230; It&#39;s really quite involved. Other windows UI frameworks (built on top of Win32 at somepoint) do provide resizing functionality for free.</p>
<p>What I do when I *really* hate a dialog box is to edit the dialog template in the DLL or EXE that it resides. Sometimes this isn&#39;t possible because the application uses its own template system (hello MS Office), but quite often you can make those list boxes bigger.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843533">
				<div id="div-comment-843533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mdw</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843533">
			June 30, 2010 at 6:26 am</a>		</div>

		<p>Resizing dialog(ue)s&#8230;</p>
<p>The fundamental problem here is that, unless you do a bunch of work yourself, Windows dialogues are just bunches of controls with specified positions and sizes. &nbsp;There&#39;s no structure there to tell anything how controls should move and/or resize when you resize the dialogue.</p>
<p>Resizing dialogues (called `geometry management&#39;) has been a standard part of user interface toolkits for the X Window System for many years. &nbsp;Good ol&#39; Xt has a notion of container widgets which manage their children. &nbsp;Other toolkits follow the tradition: Tk, Gtk, Qt, Wx, and even Java.</p>
<p>There&#39;s a tradeoff here. &nbsp;Absolute positioning of controls makes design simple, and you can get exactly the result you wanted. &nbsp;Building hierarchies of container widgets is more complicated, and it can be tricky (or even impossible) to get the precise layout you want.</p>
<p>On the other hand, the more abstract, structured layout usually only needs doing once. &nbsp;You can change the text in label widgets and the geometry management will magically arrange everything more-or-less sensibly. &nbsp;More modern toolkits have notions of both physical directions (left, right, above, below) and reading directions (before, after), so you don&#39;t even need to worry about that.</p>
<p>If you redesign your absolutely positioned dialogue for each language, you can lay them out differently, e.g., if some label is annoyingly long in German. &nbsp;Doing this sort of thing with managed geometry is messy: unless you have very sophisticated (read: hard to configure) geometry managers, you&#39;ll end up writing custom geometry management code, building different designs for different languages anyway, or (most likely) compromising the aesthetics of some translations for the benefit of having an easy life.</p>
<p>Of course, as Raymond described years ago, Windows doesn&#39;t have simple absolute positioning: it uses `dialog units&#39; which scale with the font in use, so this is a compromise position between simple absolute positioning and pure managed geometry.</p>
<p>You don&#39;t have to redesign for every typeface and every size, but you do have to redesign for different languages.</p>
<p>I&#39;m sure Raymond would argue that this was good compromise in the context of 1980mumble when it was first dreamt up, or even in 1990mumble when NT was being built; I think I&#39;d agree for 198x, probably not for 199x. &nbsp;Times are certainly different now, though, and I think the X11 tradition of managed geometry is the right answer.</p>
<p>When I looked at SWF&#39;s geometry management (a couple of years ago now) it looked pretty poor compared to Gtk, but it was certainly a move in the right direction. &nbsp;I&#39;m sure things are better now.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843703">
				<div id="div-comment-843703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Becke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843703">
			June 30, 2010 at 2:04 pm</a>		</div>

		<p>hmmm. Just as an aside, you can&#39;t render the background of a radio button with commctl 6 at all. WM_CTLCOLORSTATIC messages are sent, but seem to be ignored.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843903">
				<div id="div-comment-843903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843903">
			July 1, 2010 at 10:32 am</a>		</div>

		<p>Chris, I&#39;m not exactly sure what you were trying to do, let alone how, but you can draw arbitrary stuff behind radio buttons, at least in VB4, even with modern, styled controls. I know this because I had to work around a deficiency in the run-time library once, where radio buttons looked odd in tabs. I&#39;m pretty sure that I handled WM_ERASEBKGND (= 20) to solve the problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843913">
				<div id="div-comment-843913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">LR</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843913">
			July 1, 2010 at 11:13 am</a>		</div>

		<p>In .NET and in Delphi, you can use the &quot;Anchors&quot; and the &quot;Dock&quot; (.NET) respective &quot;Anchors&quot; and &quot;Align&quot; (Delphi) properties of the visual controls to manage simple resizing without writing any code. By using Panels and similar container controls to cover the various areas on the form, you can also design more complicated scenarios.</p>
<p>It&#39;s a really powerful and easy-to-understand concept.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-843893">
				<div id="div-comment-843893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Limited_Atonement</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-843893">
			July 1, 2010 at 10:27 am</a>		</div>

		<p>Thanks for entertaining my question!</p>
<p>&gt;&gt;unless you do a bunch of work yourself&#8230;</p>
<p>and the Moderator:</p>
<p>&gt;&gt;has never tried writing that little extra code</p>
<p>I write in C# (.Net) (perhaps 90% of my would be readers stop here&#8230;) and try to make all my forms resizable, and after doing about ten or twenty of them, the geometry involved becomes quite intuitive, even for very complex panels (like the ones I referenced in my article). &nbsp;For instance, if you want a form with two listboxes, side-by-size, overriding the OnResize event of the System.Windows.Forms.Control of your Form with the following works well:</p>
<p>const int big_break = 10, small_break = 3;</p>
<p>&#8230;</p>
<p>lst1.Size = lst2.Size = new Size((this.ClientSize.Width &#8211; big_break*2 &#8211; small_break)/2, this.ClientSize.Height &#8211; big_break*2);</p>
<p>lst1.Location = new Point(big_break, big_break);</p>
<p>lst2.Location = new Point(lst1.Right + small_break, lst1.Top);</p>
<p>Like I said, I use .Net almost exclusively, and I don&#39;t know the gyrations that are necessary for doing something like this in Win32, but I suppose that people like the Moderator who are accustomed to Win32 ought to find it straightforward.</p>
<p>I am familiar with the tools in Java (SpringLayout, GridBagLayout, etc.) for UI design that seem somewhat magical, but haven&#39;t found any (or created any that I&#39;m proud of) for my own use.</p>
<p>Am I way off in assuming that it is comparable in C++? &nbsp;What am I missing?</p>
<div class="post">[<i>Imagine a dialog with 50 controls. Oh, and what if the localizers want to change the dialog box layout? Now they have to modify your OnResize method and recompile? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-844123">
				<div id="div-comment-844123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20100628-00/?p=13593#comment-844123">
			July 2, 2010 at 8:45 am</a>		</div>

		<p>&gt;Imagine a dialog with 50 controls.</p>
<p>There have been many systems mentioned in this thread that have no problem dealing with this scenario.</p>
<p>&gt;Oh, and what if the localizers want to change the dialog box layout? Now they have to modify your OnResize method and recompile?</p>
<p>It is common practice to use a dialogue designer to generate the necessary code, so this is not an issue. Besides, we&#39;re talking about Windows&#39; support for this, so Microsoft could have simply added the necessary support to the dialogue resource format.</p>
<p>This whole discussion is so nineties.</p>
<div class="post">[<i>Yes, there are many systems which have no problem dealing with this scenario, <span style="text-decoration:underline;">so use one of those systems</span>. Remember, <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/01/21/9951193.aspx" rel="nofollow">Windows historically didn&#39;t provide functions for things you can already do yourself</a>. No single resizable dialog system will work for everybody, so you are given the freedom to choose the one that works for you. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

