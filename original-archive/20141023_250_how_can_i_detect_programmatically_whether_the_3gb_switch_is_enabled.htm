<html>
<head>
<title>How can I detect programmatically whether the /3GB switch is enabled?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How can I detect programmatically whether the /3GB switch is enabled?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>October 23, 2014 / year-entry #251</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>42</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer was doing some diagnostic work and wanted a way to detect whether the /3GB switch was enabled. (Remember that the /3GB switch is meaningful only for 32-bit versions of Windows.) The way to detect the setting is to call Get­System­Info and look at the lp­Maximum­Application­Address. #include <windows.h> #include <stdio.h> int __cdecl main(int, char...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
A customer was doing some diagnostic work and wanted a way to detect
whether the
<code>/3GB</code> switch was enabled.
(Remember that the <code>/3GB</code> switch is
meaningful only for 32-bit versions of Windows.)
</p>
<p>
The way to detect the setting is to call
<code>Get&shy;System&shy;Info</code> and look at the
<code>lp&shy;Maximum&shy;Application&shy;Address</code>.
</p>
<pre>
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int __cdecl main(int, char **)
{
 SYSTEM_INFO si;
 GetSystemInfo(&amp;si);
 printf("%p", si.lpMaximumApplicationAddress);
 return 0;
}
</pre>
<p>
Compile this <i>as a 32-bit program</i>
and run it.
</p>
<table BORDER=1 BORDERCOLOR=black CELLSPACING=0 CELLPADDING=3
    STYLE="border-collapse: collapse">
<tr>
<th>Configuration</th>
<th>LARGE&shy;ADDRESS&shy;AWARE?</th>
<th>Result</th>
<th>Meaning</th>
</tr>
<tr>
<td>32-bit Windows, standard configuration</td>
<td>Any</td>
<td>7FFEFFFF</td>
<td>2<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/11/9725386.aspx">GB</a>
    <a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2003/10/08/55239.aspx">
    minus 64KB</a></td>
</tr>
<tr>
<td>32-bit Windows, /3GB</td>
<td>Any</td>
<td>BFFFFFFF</td>
<td>3GB</td>
</tr>
<tr>
<td>32-bit Windows,
    <a HREF="http://msdn.microsoft.com/en-us/library/windows/hardware/ff542202(v=vs.85).aspx">increaseuserva</a> = 2995</td>
<td>Any</td>
<td>BB3EFFFF</td>
<td>2995 MB</td>
</tr>
<tr>
<td>64-bit Windows</td>
<td>No</td>
<td>7FFEFFFF</td>
<td>2GB minus 64KB</td>
</tr>
<tr>
<td>64-bit Windows</td>
<td><a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2005/06/01/423817.aspx">
    Yes</a></td>
<td>FFFEFFFF</td>
<td>4GB <a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/11/9725386.aspx">minus 64KB</a></td>
</tr>
</table>
<p>
On 32-bit systems, this reports the system-wide setting that
specifies the maximum user-mode address space,
regardless of how your application is marked.
Note, however, that your application must be marked
<code>LARGE&shy;ADDRESS&shy;AWARE</code>
in order to take advantage of the space above 2GB.
</p>
<p>
On the other hand,
when you run a 32-bit application on 64-bit Windows,
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2008/12/22/9244582.aspx">
it runs the application in an emulation layer</a>.
Therefore, 64-bit Windows can give each application a different view of
the system.
In particular, depending on how your application is marked,
Windows can emulate a 32-bit system with or without the
<code>/3GB</code> switch enabled,
based on what the application prefers.
</p>
<p>
Armed with this knowledge, perhaps you can help this customer.
Remember, you sometimes need to
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2013/06/20/10427187.aspx">
go beyond simply answering the question
and actually solve the customer's problem</a>.
</p>
<blockquote CLASS=m>
<p>
We would like to know how to detect from our 32-bit application
whether the host operating system is 64-bit or 32-bit.
</p>
<p>
We need to know this because our program does some data processing,
and we have to choose an appropriate algorithm.
We have written one algorithm that is faster but uses
1&frac12;<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/11/9725386.aspx">GB</a>
of address space,
and we have also written
a fallback algorithm that is slower but does not
use anywhere near as much address space.
When running on a native 32-bit system,
there is typically not 1&frac12;GB of address space available,
so we have to use the slow algorithm.
But when running on a native 64-bit system
(or a native 32-bit system with the <code>/3GB</code> switch enabled),
our program can use the fast algorithm.
Therefore, we would like to detect
whether the native operating system
is 64-bit so that we can decide whether to use the fast or slow algorithm.
</p>
</blockquote>
<p>
Here's another customer question you can now answer:
</p>
<blockquote CLASS=m>
<p>
We have a 64-bit program, and since we know that Windows currently
<a HREF="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366778(v=vs.85).aspx#memory_limits">
does not use the full 64-bit address space</a>,
we would like to
steal the upper bits of the pointer to hold additional information:
If there are at least 8 bits available, we can use a more efficient
data format.
Otherwise, we fall back to a less efficient format.
How can we detect whether the upper 8 bits are being used for
addressing?
</p>
</blockquote>
<p>
<b>Update</b>: Clarified the table based on misunderstanding
in comments.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1157093">
				<div id="div-comment-1157093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">VinDuv</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157093">
			October 23, 2014 at 7:07 am</a>		</div>

		<p>Donâ€™t applications also need to be marked LARGEÂ­ADDRESSÂ­AWARE on 32-bit Windows with /3GB to get 3GB of address space?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157103">
				<div id="div-comment-1157103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157103">
			October 23, 2014 at 7:09 am</a>		</div>

		<p>VinDuv: yes, &quot;Note, however, that your application must be marked LARGEÂ­ADDRESSÂ­AWARE in order to take advantage of the space above 2GB.&quot; The &quot;marked LARGEÂ­ADDRESSÂ­AWARE&quot; in the table is only to distinguish the two 64-bit scenarios, not an exhaustive list of executable attributes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157113">
				<div id="div-comment-1157113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157113">
			October 23, 2014 at 7:10 am</a>		</div>

		<p>Writing 32 bit programs that use &gt; 4GB RAM gets interesting. It&#39;s not clear what happens with AWE calls on 64 bit processors. Anyway, there&#39;s other ways.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157123">
				<div id="div-comment-1157123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157123">
			October 23, 2014 at 7:11 am</a>		</div>

		<p>If you like, read &quot;standard configuration&quot; as &quot;standard configuration or application not marked LARGEÂ­ADDRESSÂ­AWARE&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157133">
				<div id="div-comment-1157133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Henke37</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157133">
			October 23, 2014 at 7:19 am</a>		</div>

		<p>The first one shouldn&#39;t check for large address space, just available memory.</p>
<p>The second one should use a struct that contains a based pointer and the additional data they want to store.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157143">
				<div id="div-comment-1157143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157143">
			October 23, 2014 at 7:23 am</a>		</div>

		<p>The correct solution is to use VirtualAlloc to request the 1.5Gb you want. &nbsp;If you get it, &nbsp;use it. &nbsp;If you don&#39;t, &nbsp;use the fallback algorithm.</p>
<p>Easier than faffing about with system configuration and O/S detection.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157153">
				<div id="div-comment-1157153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157153">
			October 23, 2014 at 7:25 am</a>		</div>

		<p>This generation of processors use 48-bits of the 64 available. So you have a short&#39;s worth to use. &nbsp; You have to put the bits back though &#8211; the CPU may not use them, &nbsp;but it checks them. &nbsp;If the pointer isn&#39;t canonical it will raise an exception.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157163">
				<div id="div-comment-1157163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul Z</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157163">
			October 23, 2014 at 7:43 am</a>		</div>

		<p>I&#39;m pretty sure the answers to these questions are 1) &quot;Just ask for your 1.5GB. If you got it, you can use it. Otherwise, probably you shouldn&#39;t.&quot; (as per Jon above) and 2) &quot;You are a terrible person for trying to do this. Even if Windows doesn&#39;t use these bits right now, it will almost certainly want to use them one day. Please stop before you make Raymond Chen cry.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157173">
				<div id="div-comment-1157173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Eric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157173">
			October 23, 2014 at 8:11 am</a>		</div>

		<p>@Paul Z: &nbsp;I think we need a &quot;Keep your code sane&quot; PSA in the style of <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Keep_America_Beautiful">en.wikipedia.org/&#8230;/Keep_America_Beautiful</a>, with a picture of Raymond crying.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157183">
				<div id="div-comment-1157183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dan Bugglin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157183">
			October 23, 2014 at 8:20 am</a>		</div>

		<p>Wouldn&#39;t a single 1.5gb allocation try for a single, huge block? Or am I mistaken? This may fail even if enough total memory is available. If the algorithm doesn&#39;t need a single contiguous block it shouldn&#39;t ask for one. It should allocate all its memory up front, though, and deallocate if it is failing before it finishes.</p>
<p>@Jon that will work great until a customer uses a brand new processor that uses all 64-bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157193">
				<div id="div-comment-1157193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157193">
			October 23, 2014 at 8:27 am</a>		</div>

		<p>For the second person, simply set your alignment to 256 bytes and voila! You have 8 bits that you can steal for pointers! ;-) Honestly though, storing things in unused pointer bits seems like a recipe for bad things happening, regardless of where you are putting the extra data.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1157203">
				<div id="div-comment-1157203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157203">
			October 23, 2014 at 8:30 am</a>		</div>

		<p>&gt;This generation of processors use 48-bits of the 64 available.</p>
<p>Of physical address. The question was about virtual address.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157213">
				<div id="div-comment-1157213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157213">
			October 23, 2014 at 8:44 am</a>		</div>

		<p>Paul Z: Read the question more closely. They want to detect how many bits Windows isn&#39;t using so that they can use the otherwise-unused ones. If Windows starts using those top 8 bits, they will simply use a less-efficient storage mechanism.</p>
<p>The problem with their plan isn&#39;t that it will cause them to trample on valid bits; it&#39;s that they will have code that won&#39;t run in production (and hence won&#39;t be fully tested) until the day CPUs start supporting more bits of virtual address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-hikari odd alt thread-odd thread-alt depth-1" id="comment-1157223">
				<div id="div-comment-1157223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Chris+Crowther' rel='external nofollow' class='url'>Chris Crowther</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157223">
			October 23, 2014 at 8:54 am</a>		</div>

		<p>I&#39;m going to echo the &quot;just ask for the 1.5GiB of memory and make your choice accordingly&quot; and &quot;why the hell are you even thinking about doing that?&quot;</p>
<p>The second one sounds like a really terrible idea and inviting a whole world of future pain.</p>
<p>The MAZZTer: A virtual memory allocation may not map to a contiguous set of physical memory pages.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157233">
				<div id="div-comment-1157233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ZLB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157233">
			October 23, 2014 at 9:20 am</a>		</div>

		<p>Answer to customer 1:</p>
<p>Use VirtualAlloc() to try to reserve (not commit) 1.5Gb of address space. If the alloc is ok, use it and do the fast algoritm. If you want 1.5Gb of address space, just ask for it!</p>
<p>Answer to customer 2:</p>
<p>Do you really have to do that? Tricks like that are just asking for trouble! (and future compatibility issues, and porting issues!)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157243">
				<div id="div-comment-1157243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ZLB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157243">
			October 23, 2014 at 9:23 am</a>		</div>

		<p>An extension to my previous answer to customer 1: It may be appropiate to just alloc the 1.5Gb of address space as early as possible when the program starts if the problem is address space fragmentation rather then address space exhaustion!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157253">
				<div id="div-comment-1157253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KyleJ61782</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157253">
			October 23, 2014 at 9:23 am</a>		</div>

		<p>@Chris Crowther &#8211;</p>
<p>Re your comment @The MAZZTer:</p>
<p>The contiguous set of physical memory pages isn&#39;t the issue. &nbsp;The issue is one of whether or not there&#39;s a large enough contiguous virtual memory span. &nbsp;A single 1.5GiB allocation needs contiguous VM address space within the process, which may not be available.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157263">
				<div id="div-comment-1157263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KyleJ61782</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157263">
			October 23, 2014 at 9:26 am</a>		</div>

		<p>RE customer 2&#39;s idea:</p>
<p>This is an issue that I&#39;m running into currently. &nbsp;An expression evaluator that my software is moving away from (to one that I just wrote in house) actually uses the top bit of pointers for some reason. &nbsp;Oh the fun of random access violations occurring in a 3rd party DLL when /3GB is enabled.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157273">
				<div id="div-comment-1157273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157273">
			October 23, 2014 at 10:14 am</a>		</div>

		<p>@alegr1 </p>
<p>&gt;&gt;This generation of processors use 48-bits of the 64 available.</p>
<p>&gt;Of physical address. The question was about virtual address.</p>
<p>Only 48 bits are used for virtual addresses too. &nbsp;Bits 48-&gt;63 must be the same as bit 47 or the processor will raise #GP when the pointer is used</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157283">
				<div id="div-comment-1157283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157283">
			October 23, 2014 at 10:23 am</a>		</div>

		<p>I generally agree with the strategy of trying the allocation and then falling back if you don&#39;t get it.</p>
<p>But you should also consider the circumstances. &nbsp;If your calculation is in a library and it will be run in a separate thread, then you might want to think about leaving significant memory for the other threads. &nbsp;The point of using more memory here is to do something faster. &nbsp;If your 1.5 GB allocation leaves very little VM for other threads, you might just be slowing everything down. &nbsp;So the broader context may still be a relevant factor in your decision, especially if it was a more borderline case, e.g., using 1 GB on a 3GB system is more plausible than 1 GB on a 2 GB system.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157293">
				<div id="div-comment-1157293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Don't Do That!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157293">
			October 23, 2014 at 11:19 am</a>		</div>

		<p>&gt; We have a 64-bit program, and since we know that Windows currently does not use the full 64-bit address space, we would like to steal the upper bits of the pointer to hold additional information: If there are at least 8 bits available, we can use a more efficient data format. Otherwise, we fall back to a less efficient format. How can we detect whether the upper 8 bits are being used for addressing?</p>
<p>&gt; Only 48 bits are used for virtual addresses too. &nbsp;Bits 48-&gt;63 must be the same as bit 47 or the processor will raise #GP when the pointer is used</p>
<p>Does it strike you that the AMD64 designers were intentionally seeking to break harebrained schemes such as Customer #2&#39;s when they came up with the &#39;canonical pointers&#39; concept?</p>
<div class="post">[<em>This scheme is quite common in implementations of Scheme. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157303">
				<div id="div-comment-1157303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Justin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157303">
			October 23, 2014 at 12:39 pm</a>		</div>

		<p>Apple did the latter, in the days of the 68k macs, using the top 8 bits for flags. &nbsp;This obviously caused problems when the 68020 chips were used, which had 32 address lines (early ones had 24 lines). &nbsp;This led to the development of the &quot;32-bit clean&quot; OS moniker. &nbsp;(See <a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Mac_OS_memory_management#32-bit_clean">en.wikipedia.org/&#8230;/Mac_OS_memory_management</a> for more details).</p>
<p>In short: Don&#39;t do it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157313">
				<div id="div-comment-1157313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157313">
			October 23, 2014 at 12:56 pm</a>		</div>

		<p>Given you are working on a 64 bit platform, it is reasonably safe to assume that you want to multiplex your data in the upper bits of the pointers for (dubious) convenience rather than space savings. &nbsp;The BSTR storage scheme sounds like a better choice &#8212; just allocate a few extra bytes and put your extra data in the first few bytes of the allocation, then increment the pointer by a few bytes and use that pointer (subject to alignment requirements, of course)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157323">
				<div id="div-comment-1157323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Don't Do That!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157323">
			October 23, 2014 at 1:18 pm</a>		</div>

		<p>&gt; [This scheme is quite common in implementations of Scheme. -Raymond]</p>
<p>Yes, I know about tagged pointer types and their long history: it doesn&#39;t mean that they&#39;re a good idea, especially stuffing tags into the high bits of the pointer itself. &nbsp;On the other hand, if you only need a few tag bits, encoding them into the lowest-order bits and masking on access is much less boneheaded, considering that the CPU implementation is much less likely to steal the low order bits for its own purposes.</p>
<p>&gt; The BSTR storage scheme sounds like a better choice &#8212; just allocate a few extra bytes and put your extra data in the first few bytes of the allocation, then increment the pointer by a few bytes and use that pointer (subject to alignment requirements, of course)</p>
<p>This is the way I would do type-tagged data; it also means you can&#39;t get into an inconsistent situation where you have a (object, type-a) and an (object, type-b) tagged-reference pointing at the same object, unlike tagged pointers/references.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157343">
				<div id="div-comment-1157343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157343">
			October 23, 2014 at 2:40 pm</a>		</div>

		<p>The MAZZTer, DLLs with fixed load addresses and other fixed addresses within the program&#39;s address space mean that you might want to expect an unacceptable failure rate for contiguous requests for more than around 1.2 gigabytes on 32 bit Windows. That&#39;s the threshold that MySQL uses to switch from contiguous to split requests for its main large allocation on 32 bit Windows. You probably wouldn&#39;t want to get into discussions about rebasing DLLs to free up a larger contiguous address space.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157353">
				<div id="div-comment-1157353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John Doe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157353">
			October 23, 2014 at 2:54 pm</a>		</div>

		<p>@Don&#39;t Do That!, don&#39;t do that!</p>
<p>Seriously, think about the garbage collector: how can it tell, on the stack or otherwise, which is a pointer and which is a number? &nbsp;You can&#39;t feasibly generalize with tagging on the object&#39;s memory location. &nbsp;You may, but complementary to some tagging on the value/pointer.</p>
<p>Or, are you suggesting that value types should be objects? &nbsp;That will make any computer look like a primitive crank gear machine.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157363">
				<div id="div-comment-1157363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mikeb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157363">
			October 23, 2014 at 4:22 pm</a>		</div>

		<p>&quot;increaseuserva = 2995&quot;</p>
<p>The BCDEdit docs say that the value can be as high as 3072, so your table raises the question of: why 2995?</p>
<div class="post">[<em>Because it&#39;s not 3072. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157373">
				<div id="div-comment-1157373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157373">
			October 23, 2014 at 4:28 pm</a>		</div>

		<p>Windows 8.1 already increased the 64-bit user-mode address space by 4 bits versus Windows 8 &#8211; any programs that assumed that Windows wouldn&#39;t use address bits 43-46 in user mode surely broke with Windows 8.1.</p>
<p>Incidentally, the reason Windows 8.1 was able to increase the 64-bit address space is because Windows 8.1 x64 won&#39;t run on CPUs that don&#39;t have cmpxchg16b.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157383">
				<div id="div-comment-1157383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Silly</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157383">
			October 23, 2014 at 9:50 pm</a>		</div>

		<p>For customer number one, MessageBox is your friend. Just ask before running the step. Or if the step runs unattended then add a checkbox to the appropriate sub-tab in the config UI Options area, or an entry in the appropriate xml/ini/custom config file (and remember to seed the value with an invalid option so as to abort the application with a numerical error code if the user hasn&#39;t explicitly chosen an algo. And also optionally reprint and distribute new &nbsp;error index lookup cards).</p>
<p>MB Title: Choose an appropriate algorithm. Text: We have written one algorithm that is faster but uses 1Â½GB of address space&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157393">
				<div id="div-comment-1157393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cody Gray</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157393">
			October 24, 2014 at 12:01 am</a>		</div>

		<p>RE: Silly</p>
<p>A message box? Surely you&#39;re joking. Raymond already covered this silliness several years ago: <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/04/26/120193.aspx">blogs.msdn.com/&#8230;/120193.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157403">
				<div id="div-comment-1157403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ZLB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157403">
			October 24, 2014 at 2:33 am</a>		</div>

		<p>I was reading about a how another OS on 64bit systems uses the top 9 bits of certain types of pointer to store the Retain/Release count for an object.</p>
<p>Of course, it all falls down if the retain count is higher than 511!!!!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157413">
				<div id="div-comment-1157413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JGG</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157413">
			October 24, 2014 at 6:21 am</a>		</div>

		<p>For question 1, &quot;just trying the allocation&quot; is a bad approach IMO. First, it has never been mentioned if they&#39;re using a contiguous buffer or not. If it is the case, just because the allocation succeeds doesn&#39;t mean it won&#39;t cause other problems later on, such as leaving too little space for the rest of the program to run with. A random allocation might end up failing with OoM exception or null pointer later down the line, and it will be very annoying to deal with. Also, depending on the nature of the program, the condition for the allocation success may also be random, which makes it even more annoying to debug or understand. If it&#39;s not contiguous, then it will fail in the middle of the algorithm with some of the allocations done, where backing out on OoM will be just as annoying.</p>
<p>I think it is much better to use your upfront knowledge of the matter and do as they suggest, detect the &gt;= 3GB addressing space and branch according on that. So checking if lpMaximumApplicationAddress &gt;= 0xB0000000 (you could always go with the exact values but it wouldn&#39;t really matter) should be fine.</p>
<p>For question 2, it seems a lot of people in the comments have not had to do hardcore optimizations on very low-level code or limited hardware, as it is a very useful trick to use in these conditions, and can cause significant speed-ups for example. Just because it is potentially dangerous if used wrong does not mean you should just blindly dismiss it altogether when the right circumstance shows up.</p>
<p>And in this context, it is actually perfectly safe to use. For example, I ran Raymond&#39;s code in 64 bit, and I obtain 0x000007FFFFFEFFFF, which means you can count the number of 0 upper bits at runtime, and thus safely assume they will never be used because Windows just told you it won&#39;t use them. If you have enough, then you can use the faster branch, otherwise you stick to the slow branch. Doing so is entirely forward compatible as you make no hardcoded assumptions, you just query Windows itself for the number of free bits.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157423">
				<div id="div-comment-1157423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157423">
			October 24, 2014 at 6:43 am</a>		</div>

		<p>@JGG</p>
<p>You mean unless Windows is lying to your app, which happens frequently. Maybe you&#39;re in WINE. Maybe you&#39;re in some compatibility mode.</p>
<p>What happens when you write wildly popular Enterprise code which requires seven free bits, then the next version of Windows &nbsp;eats three of them? Microsoft ruins everyone else&#39;s day by limiting OS capabilities after testing and discovering that Massive Customers X, Y, and Z are all using your software and refuse to upgrade their systems if it no longer works.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157433">
				<div id="div-comment-1157433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JGG</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157433">
			October 24, 2014 at 6:55 am</a>		</div>

		<p>@Anon</p>
<p>What happens if the next Windows version uses more bits? You fallback to the slow version of the algorithm. You can detect this at runtime, as I mentioned.</p>
<p>The whole &quot;but Windows can lie to you&quot; argument is a slippery slope that just won&#39;t end. You have to trust something at some point. I would rather go with the innocent until proven guilty road, rather than assuming any API call can potentially lie to me or be bugged. Because the vast majority is working just fine and as intended.</p>
<p>And if you run production apps on WINE, well you&#39;re asking for a whole bunch of troubles I won&#39;t get into. You&#39;re worrying about the reliability of a software running on a vastly more unreliable emulation layer&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157463">
				<div id="div-comment-1157463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157463">
			October 24, 2014 at 7:17 am</a>		</div>

		<p>@JGG &#8212; the problem with your take on #1 &#8212; there still is no guarantee that 1.5GB of RAM is available, even if the /3GB switch is on &#8212; so you still have to deal with falling back to the slow algorithm if you cannot allocate memory. Since you have to do the one anyway, why bother with the other? Also what if you happen to get lucky on a machine without /3GB and can get your 1.5GB? Why not let the fast algorithm run?</p>
<p>Now the contiguous memory question is valid &#8212; if the algorithm doesn&#39;t require contiguous memory then you may be doing a disservice to your application to try and get a 1.5GB contiguous block. However, you could just spread that out over multiple VirtualAlloc calls.</p>
<p>As to the problem #2 &#8212; You call out &quot;hardcore optimizations on very low-level code or limited hardware&quot;. It is safe to say that an app that requires a 64 bit desktop machine is not running on &quot;limited hardware&quot;. This brings us back to optimizing low-level code. Since this is discussed in the context of an application and not the OS kernel or driver, we can assume that this would refer to needing to optimize code for speed. At that point, we would need to measure whether the extra memory/cache footprint required for something like the BSTR allocation scheme exceeds the cost of always having to mask off the extra bits whenever you deference the pointer. It is far from clear to me which would be faster.</p>
<div class="post">[<em>In the case of #2, it is a scientific data processing application, which explains why it&#39;s a 64-bit application: They are processing huge quantities of data. The tight packing lets them operate on large datasets without thrashing. This can make the difference between a run take minutes instead of hours.-Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157473">
				<div id="div-comment-1157473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157473">
			October 24, 2014 at 7:33 am</a>		</div>

		<p>@JGG</p>
<p>An API lying to you doesn&#39;t mean there&#39;s anything wrong with the API. In nearly all cases, Windows APIs which are lying to you are lying to you on purpose, due to precisely what I was saying.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-bboorman even thread-even depth-1" id="comment-1157533">
				<div id="div-comment-1157533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Brian_EE' rel='external nofollow' class='url'>Brian_EE</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157533">
			October 24, 2014 at 8:38 am</a>		</div>

		<p>Raymond, How appropriate the timing on this article. I&#39;ve been off work on a medical leave and decided to start from the beginning of your blog earlier this week (I came upon this about 2012-ish). I just read about 2-weeks worth of /3GB switch article from the June 2004 archive the other night.</p>
<p>During that series though, you had a lot of complaint comments of the variety &quot;enough of the /3GB articles already!&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157563">
				<div id="div-comment-1157563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">j b</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157563">
			October 24, 2014 at 9:41 am</a>		</div>

		<p>Re. problem #2:</p>
<p>&quot;64 kbytes should be enough for everyone&#8230;&quot;</p>
<p>In the 1970s, there was a Lisp interpreter for the 16 bit Nord-1 mini. The developers could not in their wildest dreams imagine than any machine would have more than 32K 16-bit words, so they used the upper address bit as a flag: One more level of indrection, please!</p>
<p>The next machine generation, Nord-10, came with a fancy memory management system (for its time and machine class), interpreting all 16 bits. The Lisp interpreter was never ported to the new generation&#8230;.</p>
<p>A closely related note: The Univac 1108 mainframe had a similar addressing mode which was supported by hardware: If the top address bit (of 36) was set, the addressing hardware would indirect one level more. You could make the world&#39;s tightest infinite loop by setting a pointer (with this bit set) to point to itself. All that was require for the machine to lock up was an operand fetch &#8211; not a single instruction was executed! And there was more: On the 1108, an operand fetch was uninterruptible. (At my university, they did everything to keep this secret; the majority of reboots of that huge mainframe was caused by students who wanted to try out if it really was true that you could block the machine completely with a single, unprivileged machine instruction. You could.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157573">
				<div id="div-comment-1157573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Evan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157573">
			October 24, 2014 at 9:47 am</a>		</div>

		<p>@jb: &quot;All that was require for the machine to lock up was an operand fetch &#8211; not a single instruction was executed!&quot;</p>
<p>It is possible to do arbitrary computation on the x86 MMU: you can get the equivalent of a &quot;decrement and brannch if less than&quot; or something, which is sufficient for turing completeness: <a href="http://www.youtube.com/watch?v=NGXvJ1GKBKM" rel="nofollow">http://www.youtube.com/watch?v=NGXvJ1GKBKM</a></p>
<p>(That&#39;s a long video [hopefully the link is right], but you can skip about 25 minutes of it if you&#39;re familiar with, e.g., how the PaX NX-bit emulation works.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157543">
				<div id="div-comment-1157543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">JGG</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157543">
			October 24, 2014 at 8:43 am</a>		</div>

		<p>@SimonRev : I am assuming they are already able to run the full program well within 2GB, otherwise the 3GB would have been a requirement and the question would be irrelevant. I am also assuming they are using enough memory that 1.5gb allocation is likely to fail, otherwise they would probably not ask either. Sure, there is no hard guarantee the alloc won&#39;t fail with 3GB, but in any case, it&#39;s far more likely to succeed than in 2GB.</p>
<p>I have already explained why I don&#39;t like just &quot;trying the alloc&quot;. In most cases it is unlikely a contiguous buffer, or everything being allocated upfront, making error handling quite difficult. Even if you end up being lucky, it can cause other, more insidious OoM on seemingly harmless allocations (say, 1MB) since you will be running low on memory in a 2GB addressing space. Given it can be very hard to recover from OoM scenarios, most cases usually ending up in crashes and thus data losses, I would prefer erring on the careful side for the sake of the application&#39;s user.</p>
<p>Raymond has already provided a good answer for #2. Of course, you always need to profile this kind of optimization in the appropriate context, as it is very difficult to predict. But there *are* cases where it is significantly better, so the question remains valid. Given we do not have enough information, we have to assume they did their profiling well, and the optimization is justified, they just want to have a safe way to apply it. Answering them that they should not do this anyway, without further information or context, is kind of disrespectful of their work, and does not help.</p>
<p>@Anon : If they are lying to you on purpose to preserve backward compatibility, then it is equally safe to assume they will also properly emulate memory allocation to respect the given memory addressing range of the query. Otherwise the problem is in the inconsistency of the emulation layer, not you relying on that information to make an algorithm decision.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1157553">
				<div id="div-comment-1157553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Don't Do That!</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157553">
			October 24, 2014 at 9:11 am</a>		</div>

		<p>&gt; Seriously, think about the garbage collector: how can it tell, on the stack or otherwise, which is a pointer and which is a number? &nbsp;You can&#39;t feasibly generalize with tagging on the object&#39;s memory location. &nbsp;You may, but complementary to some tagging on the value/pointer.</p>
<p>Tagging in the least significant bits is sufficient to do this; the best part is you can do that transparently to the memory access mechanism (0 in the tag field denotes a pointer/reference, non-zero a primitive type)</p>
<p>&gt; Or, are you suggesting that value types should be objects? &nbsp;That will make any computer look like a primitive crank gear machine.</p>
<p>Ask the Java folks. &nbsp;*chuckles* &nbsp;(FWIW, I agree with you that giving everything reference semantics is boneheaded.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1157643">
				<div id="div-comment-1157643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Silly</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20141023-00/?p=43783#comment-1157643">
			October 25, 2014 at 7:05 pm</a>		</div>

		<p>@Cody. Well of course.the message box would use MB_ICONQUESTION to clearly indicate its intent. And the error index cards would be *laminated*.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

