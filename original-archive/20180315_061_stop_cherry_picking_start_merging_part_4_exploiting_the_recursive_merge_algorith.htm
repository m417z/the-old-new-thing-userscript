<html>
<head>
<title>Stop cherry-picking, start merging, Part 4: Exploiting the recursive merge algorithm</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Stop cherry-picking, start merging, Part 4: Exploiting the recursive merge algorithm</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 15, 2018 / year-entry #61</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>4</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Recursive merging for fun and profit.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
The last few days have looked at the dangers of cherry-picking,
both in terms of
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20180312-00/?p=98215">
latent merge conflicts</a>
and (even worse)
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20180313-00/?p=98225">
<i>missing</i> merge conflicts</a>,
and last time, I proposed
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20180314-00/?p=98235">
the alternative to cherry-picking</a>:
Merging from a common branch.
</p>
</p>
<p>Before we can explore further, we need to understand the recursive
merge algorithm.
</p>
<p>
Instead of trying to explain it,
I will defer to
<a HREF="http://blog.plasticscm.com/2011/09/merge-recursive-strategy.html">
this explanation of the recursive merge algorithm</a>.
Go read it, and then we can talk about its consequences.
</p>
<p>
Hi, thanks for coming back.
Our simple example last time did not require the
full power of the recursive merge because there is still a single
best common ancestor.
But knowing how the recursive merge works helps you answer some
common follow-up questions.
</p>
<p>
<b>How do I find the correct merge base?</b>
</p>
<p>
The <code>git merge-base master feature</code> command will find
a merge base.
You can use that as the basis for your patch branch.
You can also say
<code>git merge-base -a master feature</code> to show
<i>all</i> merge bases, and you can choose the one that
best describes your intent.
</p>
<p>
<b>How do I know which best describes my intent?</b>
</p>
<p>
That's really up to you to decide.
For example, maybe one of the merge bases is a patch branch,
and the other is a regularly-scheduled merge between the master
and feature branch.
If your patch is intended to build on top of the previous patch,
then using the previous patch branch describes your intent better.
But if your patch is independent of the previous patch,
then using the regularly-scheduled merge describes your intent better.
</p>
<p>
<b>What if I pick the wrong merge base, and instead pick a merge base
that is not a common ancestor?</b>
</p>
<p>
If you choose a merge base that isn't actually a common ancestor,
then when you prepare the merges from the patch branch
into the master and feature branches,
one or the other merge will encompass more than
just the single commit you are trying to patch.
</p>
<p>
Let's go back to the diagram we had at the start of yesterday's
discussion:
</p>
<svg width="0" height="0">
 <defs>
  <marker id="arrowhead" markerWidth="5" markerHeight="5" refX="-2" refY="0"
    viewBox="-6 -6 12 12" orient="auto">
    <polygon points="-2,0 -5,5 5,0 -5,-5" fill="black" stroke="black"
      stroke-dasharray="1 0" />
  </marker>
  <path id="larr" d="M20,10 L3,10" stroke="black"
   marker-end="url(#arrowhead)" />
  <path id="larr3" d="M98,10 L3,10" stroke="black"
   marker-end="url(#arrowhead)" />
  <path id="nwarr" d="M20,20 L3,3" stroke="black"
   marker-end="url(#arrowhead)" />
  <path id="swarr" d="M20,2 L3,17" stroke="black"
   marker-end="url(#arrowhead)" />
  <path id="swarr3" d="M98,2 L6,57" stroke="black"
   marker-end="url(#arrowhead)" />
 </defs>
</svg>
<table CELLSPACING=1 STYLE="text-align: center" TITLE="Described in text.">
<tr>
<td>apple</td>
<td>&nbsp;</td>
<td>apple</td>
</tr>
<tr>
    <!-- note that the foreignObject doesn't display because it has no
         height or width. It exists so that RSS readers which strip out SVG
         will still leave something behind. We would normally just have
         raw text in SVG (because SVG ignores raw text), but the blog system's
         auto-emojifier will convert it to an <img>, which does show up -->
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">A</td>
<td>
<svg width="20" height="20"><foreignObject>&larr;</foreignObject><use href="#larr"/></svg>
</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">M1</td>
<td>&nbsp;</td>
<td>master</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2196;&#xfe0e;</foreignObject><use href="#nwarr"/></svg>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">F1</td>
<td>&nbsp;</td>
<td>feature</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>apple</td>
</tr>
</table>
<p>
From a common ancestor A,
commit F1 happens on the feature branch,
and commit M1 happens on the master branch.
Now you realize that you need to apply a fix to both branches.
But instead of creating your patch branch from commit A (the
common ancestor),
you mistakenly create it from F1.
</p>
<table CELLSPACING=1 STYLE="text-align: center" TITLE="Described in text.">
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>apple</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>berry</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">M1</td>
<td COLSPAN=3>
<svg width="98" height="20"><foreignObject>&larr; &larr; &larr;</foreignObject><use href="#larr3"/></svg>
</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">M2</td>
<td>&nbsp;</td>
<td>master</td>
</tr>
<tr>
<td>apple</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject><use href="#swarr"/></svg>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>berry</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject><use href="#swarr"/></svg>
</td>
</tr>
<tr>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">A</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">P</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>patch</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2196;&#xfe0e;</foreignObject><use href="#nwarr"/></svg>
</td>
<td>&nbsp;</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject><use href="#swarr"/></svg>
</td>
<td>&nbsp;</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2196;&#xfe0e;</foreignObject><use href="#nwarr"/></svg>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">F1</td>
<td COLSPAN=3>
<svg width="98" height="20"><foreignObject>&larr; &larr; &larr;</foreignObject><use href="#larr3"/></svg>
</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">F2</td>
<td>&nbsp;</td>
<td>feature</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>apple</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>berry</td>
</tr>
</table>
<p>
From commit F1, you create a patch branch and apply a commit P to it,
which contains the desired fix.
This branch is then merged into the master branch (creating commit M2)
and into the feature branch (creating commit F2).
</p>
<p>
This diagram is identical to the second diagram from last time,
except that the patch commit P is based off commit F1 rather
than commit A.
</p>
<p>
What happens?
</p>
<p>
What happens is that the merge into the master branch includes
commit F1,
which is not what you intended.
</p>
<p>
If you're using a pull request, then the list of encompassed commits
in the pull request will be longer than just one commit,
and the diff of the pull request will show unwanted changes.
That is your signal that something funny is going on.
If you're doing straight merges from the command line,
you'll find that the history for the merge into the master branch
pulled in more than just one change,
and the diff of the merge shows that the merge into the master
branch contained both the desired changes from commit P as well
as some unwanted changes from commit F1.
</p>
<p>
You can protect against this by doing
</p>
<pre>
git log master..patch
git log feature..patch
</pre>
<p>
and verifying that only one commit (namely, your patch) comes out
of each log query.
</p>
<p>
<b>What if I pick the wrong merge base, and instead pick a merge base
that is a common ancestor, but not the most recent one?</b>
</p>
<p>
Suppose that instead of choosing the most recent common ancestor,
you choose an older one.
</p>
<table CELLSPACING=1 STYLE="text-align: center" TITLE="Described in text.">
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>apple</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>berry</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">M1</td>
<td COLSPAN=3>
<svg width="98" height="20"><foreignObject>&larr; &larr; &larr;</foreignObject><use href="#larr3"/></svg>
</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">M2</td>
<td>&nbsp;</td>
<td>master</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>apple</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject><use href="#swarr"/></svg>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>berry</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject><use href="#swarr"/></svg>
</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">A</td>
<td>&nbsp;</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject></svg>
</td>
<td>
<svg width="20" height="20"><foreignObject>&larr;</foreignObject></svg>
</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">P</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>patch</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject><use href="#swarr"/></svg>
</td>
<td>
<svg width="50" height="20" style="overflow: visible">
     <path d="M138,-15 L-17,27" fill="transparent" stroke="black" marker-end="url(#arrowhead)" />
    </svg>
</td>
<td>
<svg width="20" height="20"><foreignObject>&#x292a;&#xfe0e;</foreignObject><use href="#nwarr"/></svg>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2196;&#xfe0e;</foreignObject><use href="#nwarr"/></svg>
</td>
</tr>
<tr>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">B</td>
<td>
<svg width="20" height="20"><foreignObject>&larr;</foreignObject></svg>
</td>
<td>
<svg width="20" height="20"><foreignObject>&#x2199;&#xfe0e;</foreignObject></svg>
</td>
<td>&nbsp;</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">F1</td>
<td COLSPAN=3>
<svg width="98" height="20"><foreignObject>&larr; &larr; &larr;</foreignObject><use href="#larr3"/></svg>
</td>
<td STYLE="border: solid 1px black; width: 50px; font-size: 120%">F2</td>
<td>&nbsp;</td>
<td>feature</td>
</tr>
<tr>
<td>apple</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>apple</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>berry</td>
</tr>
</table>
<p>
From a common ancestor A,
commit F1 happens on the feature branch,
and commit M1 happens on the master branch.
We create a patch branch not from commit A,
but from an even older commit B that is an ancestor of commit A.
We then merge that patch branch into the master and feature branches.
</p>
<p>
What happens is that the eventual merge of the master
and feature branch will have multiple best common ancestors.
One is the merge base that would have been selected if you had never
created a patch branch (A).
The other is the patch branch that you created (P).
The recursive merge algorithm will merge these two branches together,
the result of which is... surprise!
the version of the patch branch you would have gotten if you had
created it from the correct merge base in the first place.
</p>
<p>
In other words, it doesn't matter which common ancestor you pick,
as long as you don't pick one so far back that the merge with the
most recent common ancestor will encounter a merge conflict.
But you're unlikely to do that because that would mean that the
merges into the current heads of the master and feature branches
would also encounter merge conflicts, and that would tell you that
something is wrong.
</p>
<p>
The above result is an important one, because it means that you
could choose as your common ancestor not the most recent common
ancestor, but in fact the <i>oldest</i> common ancestor that the
patch still applies to.
In other words, go back to the commit that introduced the code
you want to change.
That commit is in both the master and feature branches by virtue
of the fact that the problem exists in both branches.
Apply your patch to that commit, and then merge the patch into the
master and feature branches.
From the graph, it looks like you had a side branch that immediately
fixed the problem, but you merely took a long time before deciding
to merge that fix back into the master and feature branches.
</p>
<p>
Having a patch branch ready with the fix is handy when we get to
the next question.
</p>
<p>
Note that you might choose an older common ancestor <i>on purpose</i>,
if it better describes your intent.
For example, in the above diagram, commit A might be a commit from a
patch branch,
whereas commit B is a regularly-scheduled merge between the master
and feature branches.
As with the case of multiple merge bases,
you can choose the commit that best expresses what you're trying to do
with your patch.
If your patch builds on top of the work in commit A, then creating
your patch branch from commit A describes your intent best.
On the other hand, if your patch is independent of the previous patch,
then creating your patch branch from commit B makes it clearer
that your patch is unrelated to the previous one.
</p>
<p>
<b>What if I have multiple branches that I need to fix?</b>
</p>
<p>
As we discovered in the previous question,
it doesn't matter which common ancestor you use, as long as it's
a common ancestor.
So create a patch branch that is based on an old common ancestor,
old enough to be in all the branches you want to apply the fix to.
Say, the commit that introduced the line of code you want to modify
with the patch.
Tell anyone who wants to pick up the fix,
"Merge the patch branch into your branch."
</p>
<p>
Instead of telling everybody to cherry-pick the fix,
tell them to merge the patch branch.
This is a branch specially crafted so that merging it picks up
exactly one commit, namely the fix.
</p>
<p>
And if everybody merges the same patch branch, then they won't
encounter conflicts when they merge with each other.
</p>
<p>
<b>What if I need to share multiple changes between the branches?</b>
</p>
<p>
Maybe you need multiple changes rather than a single change.
For example, you created a patch branch with the fix,
then discovered a problem with the fix, so you have another commit
that fixes the fix.
</p>
<p>
No problem.
In your patch branch, put all the changes you want to share.
Once you have your entire payload sitting in the patch branch,
you can merge it into the master and feature branches.
</p>
<p>
<b>What if I later realize I need to merge another fix?</b>
</p>
<p>
What if you're having a really bad day,
and after you merge the patch branch into the master and feature branches,
you discover another problem that forces you to disable a different
part of the feature.
Is it safe to create a second patch branch and follow the same
exercise?
Does the second patch branch have to be based on the first patch branch?
</p>
<p>
Again, through the magic of the recursive merge algorithm,
it doesn't matter which way you do it.
Whether your second patch branch is based on the first patch branch
or whether it's an independent branch turns out to be irrelevant,
because the recursive merge algorithm will merge all the patch branches
together anyway.
The decision to base it on the previous patch branch should be based
on what is easier for others to understand.
</p>
<p>
Okay, those are the follow-up questions that can be answered
by applying your understanding of the recursive merge algorithm.
Next time, we'll look at follow-up questions that can be answered
by applying your understanding of the three-way merge algorithm.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (4)	</div>

		<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title"> <small><a rel="nofollow" id="cancel-comment-reply-link" href="/oldnewthing/20180315-00/?p=98245#respond" style="display:none;">Cancel reply</a></small></h3>			<form action="https://blogs.msdn.microsoft.com/oldnewthing/wp-comments-post.php" method="post" id="commentform" class="comment-form">
				<p class="comment-form-comment"><textarea id="comment" name="comment" cols="45" rows="4" aria-required="true"></textarea></p><p class="comment-form-author"><label for="author">Name <span class="required">*</span></label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" aria-required='true' required='required' /></p>
<p class="comment-form-email"><label for="email">Email <span class="required">*</span></label> <input id="email" name="email" type="text" value="" size="30" maxlength="100" aria-describedby="email-notes" aria-required='true' required='required' /></p>
<p class="comment-form-url"><label for="url">Website</label> <input id="url" name="url" type="text" value="" size="30" maxlength="200" /></p>
<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit btn btn-default" value="Post Comment" /> <input type='hidden' name='comment_post_ID' value='98245' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p><p style="display: none;"><input type="hidden" id="akismet_comment_nonce" name="akismet_comment_nonce" value="ce73f89987" /></p><p style="display: none;"><input type="hidden" id="ak_js" name="ak_js" value="54"/></p>			</form>
			</div><!-- #respond -->
	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-mngoldeneagle even thread-even depth-1 parent" id="comment-1329705">
				<div id="div-comment-1329705" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/MNGoldenEagle' rel='external nofollow' class='url'>MNGoldenEagle</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245#comment-1329705">
			March 15, 2018 at 9:39 am</a>		</div>

		<p>Does this differ in any way if you only have fast-forward merges enabled on your repo?</p>

		<div class="reply"><a rel='nofollow' class='comment-reply-link' href='https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245&#038;replytocom=1329705#respond' onclick='return addComment.moveForm( "div-comment-1329705", "1329705", "respond", "98245" )' aria-label='Reply to MNGoldenEagle'>Reply</a></div>
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor odd alt depth-2" id="comment-1329715">
				<div id="div-comment-1329715" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245#comment-1329715">
			March 15, 2018 at 10:07 am</a>		</div>

		<p>Not really. Fast-forward merges create one fewer box, but the topology is the same.</p>

		<div class="reply"><a rel='nofollow' class='comment-reply-link' href='https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245&#038;replytocom=1329715#respond' onclick='return addComment.moveForm( "div-comment-1329715", "1329715", "respond", "98245" )' aria-label='Reply to Raymond Chen - MSFT'>Reply</a></div>
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1" id="comment-1329755">
				<div id="div-comment-1329755" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245#comment-1329755">
			March 16, 2018 at 2:54 am</a>		</div>

		<p>Thank you for this series! I&#8217;ve learnt more about git in the last four days than I have in three years of using it.</p>

		<div class="reply"><a rel='nofollow' class='comment-reply-link' href='https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245&#038;replytocom=1329755#respond' onclick='return addComment.moveForm( "div-comment-1329755", "1329755", "respond", "98245" )' aria-label='Reply to Adrian'>Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1329765">
				<div id="div-comment-1329765" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245#comment-1329765">
			March 16, 2018 at 3:39 am</a>		</div>

		<p>You know you&#8217;ve done something wrong when you get merge conflicts in the virtual merge ancestor. (I don&#8217;t know whether it was because I didn&#8217;t have a merge tool configured but git then proceeded to merge the result including conflict markers with the original commits, creating further conflicts. Not readable! Fortunately I was merging the wrong commit anyway.)</p>
<p>(As mentioned in the second post on recursive merging, the linked blog like to show merges with arrows in the other directions to regular commits. Personally I prefer Raymond&#8217;s diagrams.)</p>

		<div class="reply"><a rel='nofollow' class='comment-reply-link' href='https://blogs.msdn.microsoft.com/oldnewthing/20180315-00/?p=98245&#038;replytocom=1329765#respond' onclick='return addComment.moveForm( "div-comment-1329765", "1329765", "respond", "98245" )' aria-label='Reply to Neil'>Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

