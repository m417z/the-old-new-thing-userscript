<html>
<head>
<title>Allocating and freeing memory across module boundaries</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Allocating and freeing memory across module boundaries</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>September 15, 2006 / year-entry #314</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>55</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">I'm sure it's been drilled into your head by now that you have to free memory with the same allocator that allocated it. LocalAlloc matches LocalFree, GlobalAlloc matches GlobalFree, new[] matches delete[]. But this rule goes deeper. If you have a function that allocates and returns some data, the caller must know how to free...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>I'm sure it's been drilled into your head by now that you have to free memory with the same allocator that allocated it. <code>LocalAlloc</code> matches <code>LocalFree</code>, <code>GlobalAlloc</code> matches <code>GlobalFree</code>, <code>new[]</code> matches <code>delete[]</code>. But this rule goes deeper.</p>
<p> If you have a function that allocates and returns some data, the caller must know how to free that memory. You have a variety of ways of accomplishing this. One is to state explicitly how the memory should be freed. For example, <a href="http://msdn.microsoft.com/library/en-us/debug/base/formatmessage.asp"> the <code>FormatMessage</code> documentation</a> explicitly states that you should use the <code>LocalFree</code> function to free the buffer that is allocated if you pass the <code>FORMAT_MESSAGE_ALLOCATE_BUFFER</code> flag. All <code>BSTR</code>s must be freed with <code>SysFreeString</code>. And all memory returned across COM interface boundaries must be allocated and freed with the COM task allocator. </p>
<p> Note, however, that if you decide that a block of memory should be freed with the C runtime, such as with <code>free</code>, or with the C++ runtime via <code>delete</code> or <code>delete[]</code>, you have a new problem: Which runtime? </p>
<p> If you choose to link with the static runtime library, then your module has its own private copy of the C/C++ runtime. When your module calls <code>new</code> or <code>malloc</code>, the memory can only be freed by your module calling <code>delete</code> or <code>free</code>. If another module calls <code>delete</code> or <code>free</code>, that will use the C/C++ runtime of <strong>that other module</strong> which is not the same as yours. Indeed, even if you choose to link with the DLL version of the C/C++ runtime library, you still have to agree which version of the C/C++ runtime to use. If your DLL uses <code>MSVCRT20.DLL</code> to allocate memory, then anybody who wants to free that memory must also use <code>MSVCRT20.DLL</code>. </p>
<p> If you're paying close attention, you might spot a looming problem. Requiring all your clients to use a particular version of the C/C++ runtime might seem reasonable if you control all of the clients and are willing to recompile all of them each time the compiler changes. But in real life, people often don't want to take that risk. "If it ain't broke, don't fix it." Switching to a new compiler risks exposing a subtle bug, say, forgetting to declare a variable as volatile or inadvertently relying on temporaries having a particular lifetime. </p>
<p> In practice, you may wish to convert only part of your program to a new compiler while leaving old modules alone. (For example, you may want to take advantage of new language features such as templates, which are available only in the new compiler.) But if you do that, then you lose the ability to free memory that was allocated by the old DLL, since that DLL expects you to use <code>MSVCRT20.DLL</code>, whereas the new compiler uses <code>MSVCR71.DLL</code>. </p>
<p> The solution to this requires planning ahead. One option is to use a fixed external allocator such as <code>LocalAlloc</code> or <code>CoTaskMemAlloc</code>. These are allocators that are universally available and don't depend on which version of the compiler you're using. </p>
<p> Another option is to wrap your preferred allocator inside exported functions that manage the allocation. This is the mechanism used by the <code>NetApi</code> family of functions. For example, the <code>NetGroupEnum</code> function allocates memory and returns it through the <code>bufptr</code> parameter. When the caller is finished with the memory, it frees it with the <code>NetApiBufferFree</code> function. In this manner, the memory allocation method is isolated from the caller. Internally, the <code>NetApi</code> functions might be using <code>LocalAlloc</code> or <code>HeapAllocate</code> or possibly even <code>new</code> and <code>free</code>. It doesn't matter; as long as <code>NetApiBufferFree</code> frees the memory with the same allocator that <code>NetGroupEnum</code> used to allocate the memory in the first place. </p>
<p> Although I personally prefer using a fixed external allocator, many people find it more convenient to use the wrapper technique. That way, they can use their favorite allocator throughout their module. Either way works. The point is that when memory leaves your DLL, the code you gave the memory to must know how to free it, even if it's using a different compiler from the one that was used to build your DLL. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (55)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-420723">
				<div id="div-comment-420723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carrie</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420723">
			September 15, 2006 at 10:56 am</a>		</div>

		<p>This is the main problem when building plugins for 3dstudio max &#8211; you must use the same version of visual studio or rely on almost-working wrappers to alloc/free memory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-420773">
				<div id="div-comment-420773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420773">
			September 15, 2006 at 11:35 am</a>		</div>

		<p>I suppose I should point out how ac&#8217;s example of using FILE from the C standard library has the same problem as using malloc/free. If I write a program with MSVC and link to a module compiled with Borland C, there&#8217;s no guarantee that the linked module&#8217;s idea of a FILE will be the same as mine.</p>
<p>The solution to this is to export fprintf() and fclose() functions, or simply pass around OS file handles.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-larryosterman even thread-even depth-1" id="comment-420783">
				<div id="div-comment-420783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Larry+Osterman+%5BMSFT%5D' rel='external nofollow' class='url'>Larry Osterman [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420783">
			September 15, 2006 at 12:18 pm</a>		</div>

		<p>Btw, the strongest reason for using the wrapper technique is that the wrapper technique allows for finer grained control over the memory allocations. &nbsp;For instance you might decide that due to heap fragmentation issues, you need to drop in a fixed size allocator at some point in the future. &nbsp;</p>
<p>Or you might decide you need to use a private heap (like the low fragmentation heap). &nbsp;If you use a wrapper, you can change these behaviors without breaking clients.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-420803">
				<div id="div-comment-420803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ac</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420803">
			September 15, 2006 at 12:42 pm</a>		</div>

		<p>To Gabe:<br />
<br />Well I thought we were talking about how to develop a set of our own functions, which are to be used in our applications or applications of somebody else, and make sure that they are &quot;consistent&quot; to the rest of the world. I gave &quot;fopen, fclose&quot; just as the example of the method.<br />
<br />So if you make such functions, in &quot;fopen, fclose&quot; style, you have to export them if others are supposed to use them. Of course, if you let everybody in your project to compile his own instance of the body of your functions , you&#8217;ll have more things to worry.<br />
<br />But as you said, once they are exported, then our fclose equivalent is always the one that matches our fopen.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-ryanbemrose even thread-even depth-1" id="comment-420823">
				<div id="div-comment-420823" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Ryan+Bemrose' rel='external nofollow' class='url'>Ryan Bemrose</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420823">
			September 15, 2006 at 1:03 pm</a>		</div>

		<p>I think this whole series is leading up to a rule that I put in place for my own projects long ago.</p>
<p>&lt;b&gt;Memory should be deallocated as closely in scope as possible to the place that it was allocated.&lt;/b&gt; &nbsp;This means the same function where you can get away with it. &nbsp;If not, then same class, or at the very broadest, same module.</p>
<p>This neatly avoids all of the issues that Raymond has brought up about selection of compiler, API, and instance, and as well guarantees that when the allocator suffers a maintenance change, the deallocator can easily be changed simultaneously.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-benkaras odd alt thread-odd thread-alt depth-1" id="comment-420833">
				<div id="div-comment-420833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">benkaras</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420833">
			September 15, 2006 at 1:53 pm</a>		</div>

		<p>Another execption to the rule about using CoTaskMemFree across COM boundaries is that pointers embedded inside [in,out] parameters must be allocated using MIDL_user_allocate/MIDL_user_free in the server. &nbsp;See <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/rpc/rpc/embedded_out_only_reference_pointers.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/rpc/rpc/embedded_out_only_reference_pointers.asp</a> for details.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-420843">
				<div id="div-comment-420843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sebastian Redl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420843">
			September 15, 2006 at 1:56 pm</a>		</div>

		<p>This is one of the reasons why the Boost shared_ptr always carries its own deallocator around. No matter which module allocated the shared_ptr, no matter which module destructs the last shared_ptr, you&#8217;re guaranteed that the correct deallocation function is called, even across module boundaries.</p>
<p>Of course this comes with an overhead, but I believe it is worth it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-420883">
				<div id="div-comment-420883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://staringatemptypages.blogspot.com/' rel='external nofollow' class='url'>Barry Leiba</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420883">
			September 15, 2006 at 3:28 pm</a>		</div>

		<p>Mm&#8230;<br />
<br />Or you can use Java.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-420683">
				<div id="div-comment-420683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420683">
			September 15, 2006 at 10:23 am</a>		</div>

		<p>&gt; Switching to a new compiler risks exposing a subtle bug, say, forgetting to declare a variable as volatile or inadvertently relying on temporaries having a particular lifetime.</p>
<p>That is true. &nbsp;However, there is another pitfall: switching to another compiler also (at times) introduces bugs that didn&#8217;t exist in the source, due to bugs in the compiler. &nbsp;Some versions of Red Hat-patched gcc come to mind (broken inline assembly in obscure cases), as do some recent versions of VC++ (broken loop optimization for abnormal but legal loops is what I *think* it was).</p>
<p>This whole concept is another of those things that make it hard to port some Unix/Linux libraries to Windows. &nbsp;For instance, libpcap has a couple functions that allocate and return memory. &nbsp;The libpcap docs basically say &quot;free() this memory&quot;. &nbsp;When libpcap was ported to Windows (WinPcap), they used the C library malloc(), so that callers could continue to use free(). &nbsp;But since there&#8217;s only one C library on Linux, and there are many on Windows, they ran into problems when people tried to free the memory (these people were linking to different C libraries than the WinPcap DLL linked to).</p>
<p>I don&#8217;t know whether they&#8217;ve fixed that or not, or how they fixed it if they have. &nbsp;It would be nice to have Only One C Library on Windows, but I don&#8217;t know how possible that even is. &nbsp;(Given how much software is distributed as binaries, probably not very&#8230;)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-420753">
				<div id="div-comment-420753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ac</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420753">
			September 15, 2006 at 11:23 am</a>		</div>

		<p>For me, the C standard library f* functions are a classic example of how complex things can be kept simple. Sadly, a lot of programmers didn&#8217;t learn from this, so often there were popularized so many supposedly &quot;cooler&quot; things.</p>
<p>So, you have to work with a pointer to something (here, file, since in the original Unix everything was supposed to be a file):</p>
<p>FILE* f;</p>
<p>You get a pointer to the file by opening it:</p>
<p>f = fopen( &quot;somefilename&quot;, &quot;a+&quot; );</p>
<p>You don&#8217;t care who allocated it, or if the library even took a preallocated object. You just have it, and can use it.</p>
<p>First, error handling: was the &quot;construction&quot; successful? Instead of horrible but &quot;oh so modern&quot; trying and catching, you just check for success:</p>
<p>if ( !f ) {<br />
<br /> &nbsp; return;<br />
<br />}</p>
<p>Then you can use it&#8230;</p>
<p>fprintf( f, &quot;%.2fn&quot;, 2 * r * pi );</p>
<p>And finally &quot;release it&quot;:</p>
<p>fclose( f );</p>
<p>What is used to delete f? Maybe the same memory behind f can be reused for the next opened file. You don&#8217;t care, fclose knows what to do.</p>
<p>&quot;Those who do not learn from the past are doomed to use much worse than the past solutions&quot;. In 2006 we have to learn people to avoid the hype and look to something made in 1973, to prevent them shooting themself (and many affected by their programming) too much in the feet.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-421003">
				<div id="div-comment-421003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421003">
			September 15, 2006 at 6:47 pm</a>		</div>

		<p>BryanK: One CRT to rule them all? Microsoft tried it. From Visual C++ 4.2 through to 6.0, the same DLL name was used: MSVCRT.DLL. The result? DLL hell. Some applications couldn&#8217;t cope with changes in the new DLL, and some older installers erroneously installed an old version over a new version, breaking new applications.</p>
<p>Windows 2000 put MSVCRT.DLL under Windows File Protection (although I think this is mostly because WordPad and Microsoft Management Console were written with MFC and hence used MSVCRT.DLL) and this is still true in Windows XP and Server 2003. Windows Vista still ships MSVCRT.DLL (with a shiny new version number) and now it cannot be written to by any process except for an OS update.</p>
<p>Before someone brings up the versioning inherent in *nix dynamic library linking, let me point out that simply changing the name of the DLL has pretty much the same effect in Windows &#8211; which is of course what Microsoft have done. This still doesn&#8217;t solve DLL Hell problems between different minor versions of the same major-version DLL, on either OS. That&#8217;s what Win32 Side-By-Side (SXS) assemblies are for. All subsequent versions of the CRT (7.0, 7.1, 8.0) so far have included a manifest and been installed to the side-by-side folders for explicit binding on OSs which support it (XP, 2003 and later).</p>
<p>I don&#8217;t think it&#8217;s possible for two side-by-side versions of the same DLL to be loaded into the same process &#8211; I believe the choice is governed by the EXE&#8217;s manifest. If it is possible that would even cause problems with assuming that you can use &#8216;delete&#8217; from a module with the same name as the one you called &#8216;new&#8217; from! Windows will allow you to load DLLs with the same name from different paths, of course.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-420813">
				<div id="div-comment-420813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://bogol.blogspot.com' rel='external nofollow' class='url'>Grover Kluson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420813">
			September 15, 2006 at 1:02 pm</a>		</div>

		<p>&#8220;&#8230;all memory returned across COM interface boundaries must be allocated and freed with the COM task allocator.&#8221; </p>
<p>Does this mean that SysAllocString() uses that allocator? I can&#8217;t find any specifics in MSDN. </p>
<p>Obviously, we should put this out of our minds when actually *using* BSTRs. </p>
<div CLASS=post>[<i>Liberally insert the phrase &#8220;as a general rule, but there may be exceptions&#8221; into all of my posts. All memory returned across COM interfaces must be allocated and freed with the COM task allocator <u>unless there are special rules that override this ground rule</u>. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421023">
				<div id="div-comment-421023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Brian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421023">
			September 15, 2006 at 11:02 pm</a>		</div>

		<p>Why is it that these external allocators are more stable than malloc? Are the maintainers of those routines more meticulous than the vcrt maintainers? Also, what exactly does &#8220;external&#8221; mean here? Perhaps the answer to that question answers the rest.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421033">
				<div id="div-comment-421033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421033">
			September 15, 2006 at 11:35 pm</a>		</div>

		<p>Brian, think of it this way.</p>
<p>You have a EXE statically linked to CRTL and a DLL statically linked to CRTL. &nbsp;This means that the EXE and DLL not only don&#8217;t share the same malloc and free code, but they don&#8217;t share the same data structures used to support these routines. &nbsp;</p>
<p>Let us assume that malloc and free are just wrappers around HeapAlloc where CRTL uses a private heap. &nbsp;In that case, if you allocated memory in the DLL, one heap would be used. &nbsp;If you tried to free that memory in the EXE, then it would try to free that memory to a DIFFERENT heap. &nbsp;Thus bad things start to happen.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421043">
				<div id="div-comment-421043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421043">
			September 15, 2006 at 11:37 pm</a>		</div>

		<p>External basically means an allocator that isn&#8217;t part of the programmer&#8217;s EXE or DLL. &nbsp;For example, CoTaskMemAlloc is a external allocator that just lives in another DLL that will be shared between the EXE and all the DLLs. &nbsp;So you avoid the whole multiple malloc/free issue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-420923">
				<div id="div-comment-420923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-420923">
			September 15, 2006 at 5:00 pm</a>		</div>

		<p>And then what happens when your Java code has to use JINI to call a native function, because Sun didn&#8217;t give you whatever you need to get at in the JRE? &nbsp;How do you free memory that that function may have allocated?</p>
<p>(In other words: &nbsp;This is a problem in *any* language that allows the programmer to call into native OS DLLs. &nbsp;Even languages with full GC.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421013">
				<div id="div-comment-421013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bmm6o</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421013">
			September 15, 2006 at 8:17 pm</a>		</div>

		<p>BryanK: (re: JNI allocation) &quot;How do you free memory that that function may have allocated?&quot;</p>
<p>It&#8217;s actually less complicated in a Java/JNI case. &nbsp;You are *forced* to also export a deallocation function, since it&#8217;s simply not possible to otherwise free the memory. &nbsp;That is, there&#8217;s never any danger of the user calling the *wrong* deallocation function; the only possible danger is that the user won&#8217;t call any at all (which is easily avoided via dispose/finalize).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421113">
				<div id="div-comment-421113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">-</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421113">
			September 16, 2006 at 8:04 pm</a>		</div>

		<p>Uhh&#8230; A pretty dumb question: if all of those allocators run inside the same process, how do they manage not to hurt each other, so to speak? Who keeps track of what parts of the VM space are in use? How do they manage not to collide, and leave enough space for the others (if they need continuous space)? How do they request/release memory from the OS?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421163">
				<div id="div-comment-421163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Arno Schoedl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421163">
			September 17, 2006 at 3:53 am</a>		</div>

		<p>At the end, all allocators get their memory from the OS via VirtualAlloc, and then divide up these larger pages to satisfy requests from the caller. No magic involved.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421173">
				<div id="div-comment-421173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Leif</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421173">
			September 17, 2006 at 5:41 am</a>		</div>

		<p>To go off on a slight tangent: I&#8217;ve always thought the *six* versions of libc offered by VC++ is a bit gratuitous (libc, libcd, libcmt, libcmtd, mscrt, msvcrtd). &nbsp;This seems like bad design. &nbsp;Design is all about making decisions and accepting the relevant tradeoffs. &nbsp;I think &#8216;msvcrt&#8217; (multithreaded DLL) should have been the only option. &nbsp;But instead, VC++ punts: &nbsp;they refuse to make a decision, and thereby force the issue on the user as &#8220;options&#8221;.</p>
<p>Four of the options &#8212; libc(mt)(d) &#8212; don&#8217;t even make sense. &nbsp;Is an application ever really &#8220;single-threaded&#8221; on Windows? &nbsp;You press Control-C, and Windows creates a thread. &nbsp;Does &#8220;static linking&#8221; have any meaning on Windows? &nbsp;On Unix, it means creating an executable which is *completely* self contained. &nbsp;But on Windows, you will still depend upon kernel32.dll at a minimum&#8230; in other words, by using a static version of libc, you have avoided your &#8220;DLL hell&#8221;/versioning problem only for that *one* library: libc.</p>
<p>I&#8217;ve seen this cause problems for users again and again. &nbsp;Forget about binary compability and versioning issues&#8230; because of the 6 versions of libc, it is possible to get conflicts when *building everything from source*. &nbsp;Poll: how many times have you downloaded &amp; built a third party (static) library, and discovered at link time that it uses /ML(d)/MT(d)/MD(d) flags that are incompatible with the rest of your sub-projects? &nbsp;I&#8217;ve seen people who don&#8217;t know any better use /nodefaultlib and /force to jam an EXE togther in this scenario&#8230; in once case, someone managed to get a static copy of free() and a DLL-imported malloc() in the same EXE, resulting in a self-contained malloc/free conflict. &nbsp;Of course, you routinely get conflicts when going across DLL boundaries, with no linker kludgery whatsoever.</p>
<p>When programming on *nix, &#8220;Which flavor of libc should I use?&#8221; isn&#8217;t a decison I have to make, and I feel much better off.</p>
<div CLASS=post>[<i>Thus is the paradox of design. Give people no choice and they demand one. Give people a choice and they complain that you should have decided for them. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421193">
				<div id="div-comment-421193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421193">
			September 17, 2006 at 12:48 pm</a>		</div>

		<p>The problem with free and malloc having multiple versions isn&#8217;t an issue with just Windows, it is an issue with any operating system where free and malloc isn&#8217;t an external allocator, is versioned or isn&#8217;t the standard allocator. &nbsp;</p>
<p>DOS, CP/M, VMS, Windows, etc all have issues with memory allocation. &nbsp;Even with VMS where the CRTL was a DLL, you have to be careful when allocating memory in a C module and then expecting a Fortran module to be able to free it. &nbsp;Oh, and VAX Fortran doesn&#8217;t really support memory allocation or pointers directly. You have to trick it into handling pointers.</p>
<p>Even the grand old Unix/Linux would have the same problem if you were using a NON C language that used memory allocation that either didn&#8217;t use malloc/free or augmented then in some way. &nbsp;(The same way that most Window&#8217;s mallocs/frees use gross allocations from the operating system and then subdivide them.)</p>
<p>So basically, to say that Unix/Linux doesn&#8217;t have this problem shows a simplistic understanding of the issue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421223">
				<div id="div-comment-421223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.explorewindows.com/Blogs' rel='external nofollow' class='url'>Vipin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421223">
			September 17, 2006 at 2:13 pm</a>		</div>

		<p>The important thing Raymond missed out in the post is the fact that cross module allocation/deallocation done wrongly would lead to memory leaks/subtle bugs or even crashes is due to the fact Tim mentioned earlier in one of his posts, that is there is a per module heap and the malloc/free happens on the module heap from within which the calls were made.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421243">
				<div id="div-comment-421243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GregM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421243">
			September 17, 2006 at 3:55 pm</a>		</div>

		<p>Leif, I&#8217;m VERY glad you weren&#8217;t the one making the decisions then.</p>
<p>You have basically the same options on *nix: linking against libc.a (static single-threaded), libc.so (dynamic single-threaded), libc_r.so (dynamic thread-safe).</p>
<p>The other 3 versions are the debug versions that add extra error checking and such for helping the developer find and debug errors in their programs.</p>
<p>As for Windows not having true static applications, do you really think that you can take a linux binary and run it on a PC without linux installed on it? &nbsp;The application has to be run on an OS. &nbsp;The kernel is part of that OS.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421253">
				<div id="div-comment-421253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421253">
			September 17, 2006 at 4:45 pm</a>		</div>

		<blockquote><p>
  Maybe the same memory behind f can be reused for the next opened file. You don&#8217;t care, fclose knows what to do. </p>
<p>And then because fopen() and fclose() aren&#8217;t mystical sentient spirits in heaven but instead are actually functions implemented in code that has to be stored somewhere, if you use fopen() in one DLL and return the result acrss a DLL boundary, you don&#8217;t know which fclose() to call, becaus if you call the wrong one, then it will not work correctly.</p>
<p>&gt; In 2006 we have to learn people to avoid the hype and look to something made in 1973, to prevent them shooting themself (and many affected by their programming) too much in the feet. </p>
<p>However, I&#8217;m more worried about the rocket launcher you&#8217;re planning to use to blow off every leg in the building in a misguided and doomed attempt to save a single foot.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421283">
				<div id="div-comment-421283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Craig</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421283">
			September 18, 2006 at 2:40 am</a>		</div>

		<p>&quot;Even the grand old Unix/Linux would have the same problem if you were using a NON C language that used memory allocation that either didn&#8217;t use malloc/free or augmented then in some way.&quot;</p>
<p>Yep. You also see the problem in C language libraries that for whatever reason need to implement their own malloc() . It&#8217;s much less common and much less useful now that most system malloc implementations are much better, but it was once common and frequently necessary. It can also happen if an executable uses different versions of libstdc++ (same issue as the CRT problem in win32) with the <code>new' and</code>delete&#8217; operators.</p>
<p>In general, though, it&#8217;s much less problematic than on win32. This means that most *nix apps and especially apps with plugin interfaces tend to ignore the issue completely, resulting in incredible frustration when moving to win32.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421293">
				<div id="div-comment-421293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Lindows</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421293">
			September 18, 2006 at 2:43 am</a>		</div>

		<p>The problems with memory (de)allocating and dll-hell is much more prominent on windows than other os, can&#8217;t deny that. It does however exist on other os but usually isn&#8217;t a concernable problem at all there. Can not expect sloppy BASIC programmers on Windows to be attentive to low level stuff.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421403">
				<div id="div-comment-421403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">bmm6o</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421403">
			September 18, 2006 at 11:15 am</a>		</div>

		<blockquote><p>
  Whoa&#8230; so you&#8217;re telling me that I can call FindMimeFromData from Java, using JNI (or whatever it&#8217;s called), and somebody will have magically created a deallocation function for me to use?</p>
<p>Of course not. &nbsp;The author of the JNI code is responsible for matching allocation and deallocation functions. &nbsp;But the problem that is the topic of Raymond&#8217;s post (&quot;Allocating and freeing memory across module boundaries&quot;) is not an issue, as the allocation and deallocation do not occur in different modules. &nbsp;Coding in a language with GC doesn&#8217;t magically make the whole OS process garbage collected, and I don&#8217;t think that was anybody&#8217;s claim. &nbsp;But it is true that some problems (like the one that is the subject of this post) would not occur.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421313">
				<div id="div-comment-421313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel Salters</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421313">
			September 18, 2006 at 6:24 am</a>		</div>

		<p>C often is just glorified assembler, which is how the problem can exist. If Microsoft had decided to use C++-style name-mangling on their DLLs, their FILE* could have been a _MS_CRT_20_FILE*. Obviously you can&#8217;t pass that to Borland&#8217;s fclose(FILE*). The competition doesn&#8217;t need to compete. </p>
<p>Even better, if VCx+1 was really compatible for these functions, you could keep the same names for these types and functions. Versioning can then be decided at function level. You can even have two fclose(FILE*) implementations in a single DLL, if needed &#8211; one for each FILE* flavour.</p>
<p>IIRC, VC8 fixed the multiple-heap problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421323">
				<div id="div-comment-421323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michiel Salters</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421323">
			September 18, 2006 at 6:26 am</a>		</div>

		<p>C often is just glorified assembler, which is how the problem can exist. If Microsoft had decided to use C++-style name-mangling on their DLLs, their FILE* could have been a _MS_CRT_20_FILE*. Obviously you can&#8217;t pass that to Borland&#8217;s fclose(FILE*). The competition doesn&#8217;t need to cooperate for this to work. And it&#8217;s backwards-incompatible, too! (as intended)</p>
<p>Even better, if VCx+1 was really compatible for these functions, you could keep the same names for these types and functions. Versioning can then be decided at function level. You can even have two fclose(FILE*) implementations in a single DLL, if needed &#8211; one for each FILE* flavour.</p>
<p>IIRC, VC8 fixed the multiple-heap problem.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421333">
				<div id="div-comment-421333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">OrsoYoghi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421333">
			September 18, 2006 at 7:15 am</a>		</div>

		<p>&gt;&gt; But on Windows, you will still depend upon kernel32.dll at a minimum&#8230; in other words, by using a static version of libc, you have avoided your &quot;DLL hell&quot;/versioning problem only for that *one* library: libc. </p>
<p>Nonsense. You can easily code for the lowest common kernel32.dll you want to support and it&#8217;s easy to keep compatibility with Windows95 that way. And really there is no versioning to be worried about.</p>
<p>But if the system you&#8217;re running your program on doesn&#8217;t have msvcr71.dll you&#8217;re screwed. </p>
<p>If you want to build an application of a single exe file in C++ you have to use static linking.</p>
<p>OH! and you don&#8217;t have to use the multithreaded libc version as long as your threads do not use any libc function. It&#8217;s lighter and faster than the mt one (nowadays is probably insignificant but it can have its uses).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421363">
				<div id="div-comment-421363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421363">
			September 18, 2006 at 8:29 am</a>		</div>

		<p>&gt; BryanK: (re: JNI allocation) &quot;How do you free memory that that function may have allocated?&quot;</p>
<p>&gt; It&#8217;s actually less complicated in a Java/JNI case. &nbsp;You are *forced* to also export a deallocation function, since it&#8217;s simply not possible to otherwise free the memory.</p>
<p>Whoa&#8230; so you&#8217;re telling me that I can call FindMimeFromData from Java, using JNI (or whatever it&#8217;s called), and somebody will have magically created a deallocation function for me to use? &nbsp;Even though FindMimeFromData uses its own internal allocator, and there *IS* no deallocation function, even if you&#8217;re calling it from C? &nbsp;(See <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/09/07/744430.aspx" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/09/07/744430.aspx</a> for some of the details of that one.)</p>
<p>&gt; the only possible danger is that the user won&#8217;t call any at all (which is easily avoided via dispose/finalize).</p>
<p>I&#8217;m not talking about writing a full Java object to wrap an API. &nbsp;I&#8217;m talking about just the act of calling that API, from *any* code. &nbsp;If there is no deallocator, you can&#8217;t free the memory, GC or no. &nbsp;Or if you use the wrong deallocator in your wrapper, you&#8217;re not going to get the right result, GC or no. &nbsp;Java is not a magic bullet. &nbsp;(Neither is any other language, of course.)</p>
<p>&gt; [Thus is the paradox of design. Give people no choice and they demand one. Give people a choice and they complain that you should have decided for them. -Raymond]</p>
<p>Now, I haven&#8217;t talked to a majority of Linux programmers. &nbsp;But I&#8217;ve never heard *anyone* complaining that there&#8217;s no choice in Linux C libraries. &nbsp;Everyone&#8217;s happy enough with glibc that they at least don&#8217;t try to distribute their own copy of it, to &quot;preserve compatibility&quot; or some such hogwash.</p>
<p>Of course, it helps that glibc has versioned symbols, so if you asked for an old version of a function when your code was compiled, you&#8217;ll get it when your code runs. &nbsp;So you have full backward compatibility by default. &nbsp;And it helps that the kernel never breaks backward compatibility at the syscall level, so even if you did distribute your own glibc for some crazy reason (or you skip glibc and make system calls directly, which is more common), it&#8217;d work.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421493">
				<div id="div-comment-421493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421493">
			September 18, 2006 at 4:01 pm</a>		</div>

		<p>And if the programmer that mismatched allocate and free is the same programmer that wrote JNI code instead, the situation is no better. &nbsp;They&#8217;ll still use the wrong deallocator for the allocator they used, because they&#8217;ll still go through the same thought processes when they decide which deallocator they need.</p>
<p>In other words, if your JNI code calls FindMimeFromData, then calls the C library free() on the resulting buffer, Java didn&#8217;t actually help. &nbsp;Or if you call whichever winpcap function allocates the list, then try to free() that list with a different C library, Java still didn&#8217;t help. &nbsp;You&#8217;re still using the wrong deallocator in both cases.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421583">
				<div id="div-comment-421583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Leif</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421583">
			September 18, 2006 at 9:04 pm</a>		</div>

		<p>&gt; you have to be careful when allocating memory in a C module and then expecting a Fortran module to be able to free it</p>
<p>Don&#8217;t even get me started on Fortran ;-) I don&#8217;t think &nbsp;the mixed-language argument detracts from my point, though: &nbsp;in VC++, if you build a bunch a DLLs &#8212; all written in the same language and built with the same version of the same compiler &#8212; with the default options, you get broken, non-intuitive behavior: &nbsp;crash at runtime when passing heap blocks, STL strings, C++ exceptions, etc. across DLL boundaries.</p>
<p>&gt; You have basically the same options on *nix: linking against libc.a (static single-threaded), libc.so (dynamic single-threaded), libc_r.so (dynamic thread-safe).</p>
<p>This is true, I admit. &nbsp;(In fact, on Linux at least, there is no threaded/non-threaded choice: threads are handled in a sneaky way.)</p>
<p>But in any case, the effect of having a choice on Unix is not as disastrous as it is on Windows. &nbsp;Since Unix uses a global symbol namespace, only one malloc() implementation will prevail: &nbsp;if I choose to link my &nbsp;main executable against libc.a, everyone in my process space will be forced use libc.a&#8217;s malloc(), as there can be only one. &nbsp;On Unix, is not easy to get the kind of malloc/free conflict which Raymond describes. &nbsp;On Windows, it is easy to get it by accident.</p>
<p>Not that I think a single, shared global symbol namespace is a good idea, mind you. &nbsp;It can be a disaster (esp. with respect to libstc++ &#8212; just ask the Autopackage folks). &nbsp;Windows DLLs are much closer to the &quot;right way&quot; to do dynamic linking. &nbsp;But given the Windows DLL model, a single libc DLL should *at least* be the default, and in my opinion, the only option.</p>
<p>&gt; The other 3 versions are the debug versions</p>
<p>If I were making the decisions, the debug version would be a runtime option. &nbsp;It is trivial to swap-in a different DLL with a matching interface at runtime (although the NT loader&#8217;s &quot;KnownDLLs&quot; mechanism complicates this for a subset of system DLLs). &nbsp;Or, you could do it like kernel32.dll does it: &nbsp;the debugging features are dynamically activated when running under a debugger.</p>
<p>&gt; do you really think that you can take a linux binary and run it on a PC without linux installed on it?</p>
<p>Yeah, that&#8217;s what I think. &nbsp;You mean you can&#8217;t? :-)</p>
<p>&gt; Nonsense. You can easily code for the lowest common kernel32.dll you want to support and it&#8217;s easy to keep compatibility with Windows95 that way. And really there is no versioning to be worried about.</p>
<p>I said you&#8217;d depend upon kernel32.dll *at a minimum*. &nbsp;Any non-trivial Windows app depends upon lots of DLLs, not just kernel32. &nbsp;On Unix, you have side-by-side static and non-static versions of most libraries. &nbsp;Static linking *makes sense* on Unix. &nbsp;As I said, on Unix, static linking enables you to create a self-contained executable &#8212; i.e., one that depends only on the kernel and has no dynamic dependencies. &nbsp;On Windows, what sense does static linking make? &nbsp;All of the Windows system libraries are DLL-only &#8212; and rightly so, because of the way the dynamic linker works (*). &nbsp;By statically linking libc &#8212; just &nbsp;*one* library &#8212; what problem is solved? &nbsp;Great &#8212; I don&#8217;t have to worry about &quot;DLL hell&quot; for msvcrt&#8230; but I still have to worry about it for comctl32 and everything else. :-/ &nbsp;You&#8217;ve only solved one instance of a much more general problem.</p>
<p>&#8211;Leif</p>
<p>(*) Imagine the disaster if Microsoft decided to give developers the &quot;option&quot; of linking against a static kernel32.lib. &nbsp;(Funny how no one ever complains about not having a static version of kernel32&#8230;) &nbsp;&quot;Free memory allocated using LocalAlloc() by calling LocalFree()&#8230; oh, and by the way, if you statically linked against kernel32, you must call LocalFree() from the same EXE/DLL from which you allocated the memory.&quot; &nbsp;In order for static linking to make sense in general, your runtime linker must have a global namespace (like Unix). &nbsp;On Windows, the sane approach is to force users to use DLLs &#8212; *especially* if the library in question controls a &quot;global&quot; resource &#8212; in this case, the heap. &nbsp;I think the Win32 team realized this, but the VC++ team did not&#8230; or at least, they didn&#8217;t give it nearly enough weight.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-421653">
				<div id="div-comment-421653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">OrsoYoghi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421653">
			September 19, 2006 at 5:02 am</a>		</div>

		<blockquote><p>
  &gt; &nbsp;Great &#8212; I don&#8217;t have to worry about &quot;DLL hell&quot; for msvcrt&#8230; but I still have to worry about it for comctl32 and everything else. :-/ &nbsp;You&#8217;ve only solved one instance of a much more general problem. </p>
<p>Wrong. You don&#8217;t link statically to avoid dll hell. You link statically to avoid yet another resitributing burden.</p>
<p>Let&#8217;s say you offer a demo of something on the internet. I can guess that more people will download your demo if :<br />
  <br />1) runs without installing<br />
  <br />2) doesn&#8217;t require other redist to be installed<br />
  <br />3) it&#8217;s a single exe file.</p>
<p>You said comctl32. Why you decided that the program has a GUI ? It might be a small 3dgame. Or a screen saver. Or a console app. Or a small puzzle game &quot;winmine&quot; style. Or a GUI using the subset of COMCTL32 available in Win95. Or an installer. A self extractor. </p>
<p>You find a feature useless and so you scream you want it to be removed. Quite egocentrist
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-421663">
				<div id="div-comment-421663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Harris</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-421663">
			September 19, 2006 at 6:26 am</a>		</div>

		<p>Raymond wrote:<br />
<br />&gt;&gt; many people find it more convenient to use<br />
<br />&gt;&gt; the wrapper technique.</p>
<p>Ac&#8217;s fclose( f ) example illustrates a reason why: the function that deallocates memory can also do other stuff, in this case close the OS file handle. It&#8217;s a higher level, more object oriented approach.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-422123">
				<div id="div-comment-422123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-422123">
			September 19, 2006 at 8:10 pm</a>		</div>

		<p>Am I the only one here who thinks that DLLs have been used in the wrong way?<br />
<br />Everyone has been talking about reusable code for quite some time but what exactly is reusable? Applications are getting bigger and bigger with more and more DLLs.<br />
<br />Instead of using one system DLL we now have dozens of applications each using their own version of the same thing.<br />
<br />That leads to users having to depend on each application vendor to update their version of a DLL to get bugfixes, improved functionality or speed boost.</p>
<p>On a side note, has anyone notice how each and every application has their own copy of strlen(), strcpy(), malloc(), free()?</p>
<p>I mean why is it so hard to use VirtualAlloc()?!? It pisses me off every time I see malloc() because I know that the memory is not properly aligned for any SIMD operations.</p>
<p>What I would do in next C runtime header update would be this:</p>
<p>#define malloc(size)    VirtualAlloc(NULL, (size), MEM_COMMIT, PAGE_READWRITE)<br />
<br />#define free(mem)   VirtualFree(mem, 0, MEM_RELEASE)</p>
<p>That is what I am using all the time anyway.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-422133">
				<div id="div-comment-422133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Leif</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-422133">
			September 19, 2006 at 8:40 pm</a>		</div>

		<blockquote>
<h1>define malloc(size) VirtualAlloc(NULL, (size), MEM_COMMIT, PAGE_READWRITE)</h1>
<p>Oh boy. &nbsp;That&#8217;s the last time I click the &#8220;Comments&#8221; link.</p>
<p>[Leif sadly walks away as the virtual address space is exhausted in 64K increments, and the available I.Q. shown in the Task Manager slowly drops&#8230;]</p>
<div CLASS=post>[<i>Good thing you stopped before you read the definition of &#8220;free&#8221;. -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-422033">
				<div id="div-comment-422033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">timeless</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-422033">
			September 19, 2006 at 2:43 pm</a>		</div>

		<p>&gt; possibly even new and free.</p>
<p>i hope no one takes the original article seriously in this example :)</p>
<p>&#8212;<br />
<br />as for libcs on unix, there&#8217;s a ulibc floating around, and there *are* problems w/ glibc, specifically the transition from libc5 to libc6 (glibc) which actually resulted in lots of classic binary apps just not running anywhere.</p>
<p>in a certain way, the engineers would have been *better* off statically linking with libc5 because it would mean that the apps would run on modern linuxes (they don&#8217;t, and i believe there are some linuxes which don&#8217;t even bother providing a way for the user to easily install a libc5 &#8212; yes, you can rebuild libc5 yourself, but an average end user can not do that). &#8212; and yes, i&#8217;m talking about a closed source product which is no longer being rebuilt, but which is still better than certain other alternatives (certainly it&#8217;s a lot more stable).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-422413">
				<div id="div-comment-422413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zhifeng Yang</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-422413">
			September 21, 2006 at 2:44 am</a>		</div>

		<blockquote><p>
  Although I personally prefer using a fixed external allocator, many people find it more convenient to use the wrapper technique. That way, they can use their favorite allocator throughout their module. Either way works.</p>
<p>In the C++ world, even a wrapper can still mess things up. If the wrapper function that is supposed to free memory is an inline one, it will call memory routines (e.g. free or delete) of the caller module, not the routines in the dll. So, if you&#8217;re developing such a wrapper in C++, you must not make it inline explictly or implicitly.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-422483">
				<div id="div-comment-422483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-422483">
			September 21, 2006 at 8:35 am</a>		</div>

		<p>Well, even C has inline functions. &nbsp;(Or at least, GCC does. &nbsp;I suppose I shouldn&#8217;t say that C does, because I don&#8217;t know for sure.) &nbsp;So that could still be a problem in C.</p>
<p>But if you&#8217;re providing a library, you should be explicitly exporting your functions anyway (using a .def file); see some of Raymond&#8217;s previous posts on the subject of name mangling, etc.</p>
<p>I would hope that the compiler/linker would be smart enough to *not* inline functions that are marked for export. &nbsp;Or, basically, to use gcc&#8217;s &quot;extern inline&quot; mode (&quot;inline this if possible, but if not, call the extern, non-inlined version that I have defined somewhere else&quot;).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-423463">
				<div id="div-comment-423463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-423463">
			September 23, 2006 at 8:59 pm</a>		</div>

		<blockquote><p>
  Leif sadly walks away as the virtual address <br />&gt;space is exhausted in 64K increments, and the <br />&gt;available I.Q. shown in the Task Manager slowly <br />&gt;drops&#8230; </p>
<p>Hahahah&#8230; seriously, &#8220;in 64K increments&#8221;! :) </p>
<p>Even though page size on most machines is 4K? </p>
<p>Or you think I am calling VirtualAlloc() in a loop for some reason? </p>
<p>No, wait&#8230; you think that C/C++ runtime allocator (malloc, new, etc) use some psychic memory access which somehow evades paging and virtualization services provided by OS? </p>
<p>Anyway, the stack trace of a windows console application named some.exe compiled with Visual C++ which uses malloc() would look something like this: </p>
<p>some.exe!__heap_init() <br />kernel32.dll!HeapCreate() <br />&nbsp;ntdll.dll!RtlCreateHeap() <br />&nbsp; ntdll.dll!NtAllocateVirtualMemory() <br />some.exe!__mtinit() <br />some.exe!__ioinit() <br />kernel32.dll!GetCommandLine() <br />some.exe!___crtGetEnvironmentStrings() <br />some.exe!__setargv() <br />some.exe!__setenvp() <br />some.exe!__cinit() <br />some.exe!_main() <br />some.exe!malloc() <br />&nbsp;kernel32.dll!HeapAlloc() <br />&nbsp; ntdll.dll!RtlAllocateHeap() </p>
<p>And Windows GUI application stack trace would probably look the same save for the _WinMain() instead of _main(). </p>
<p>So, the mother of all allocators in user space is kernel32!VirtualAlloc() which is just a wrapper around ntdll.dll!NtAllocateVirtualMemory(). </p>
<p>If you need high performance in your application then I advise you to use VirtualAlloc() (optionally followed by VirtualLock() if you bothered to adjust your process working set) instead of malloc() when possible. </p>
<p>malloc() has higher overhead, doesn&#8217;t return aligned memory needed for SIMD operations and you have to worry which free() to call. </p>
<div CLASS=post>[<i>It&#8217;s one thing to use <code>VirtualAlloc</code> to grab large chunks of memory; it&#8217;s another to use it as a <code>malloc</code> replacement. Using <code>VirtualAlloc</code> to allocate the memory for a <code>strdup(&#8220;hello&#8221;)</code> is probably overkill, allocating 4KB of memory (and reserving 64KB of address space) when you only needed six bytes. (And I assume you&#8217;ll fix the memory leak in your <code>free</code> macro.) -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-423523">
				<div id="div-comment-423523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-423523">
			September 24, 2006 at 5:10 pm</a>		</div>

		<blockquote><p>
  It&#8217;s one thing to use VirtualAlloc to grab<br />
  <br />&gt;large chunks of memory; it&#8217;s another to use<br />
  <br />&gt;it as a malloc replacement.</p>
<p>I agree. But I am always using large chunks.</p>
<p>&gt;Using VirtualAlloc to allocate the memory<br />
  <br />&gt;for a strdup(&#8220;hello&#8221;) is probably overkill</p>
<p>I was convinced that strdup() allocates its own memory.</p>
<p>&gt;(And I assume you&#8217;ll fix the memory leak in<br />
  <br />&gt;your free macro.)</p>
<p>I will Raymond but only if you tell me where it is :)</p>
<p>Seriously, from MSDN:</p>
<p>dwSize<br />
  <br />[in] The size of the region of memory to be freed, in bytes. </p>
<p>If the dwFreeType parameter is MEM_RELEASE, this parameter must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to VirtualAlloc.</p>
<p>So what is wrong there? Has the API changed?</p>
<div CLASS=post>[<i>Sorry, I missed the MEM_RELEASE part. If you&#8217;re using it only for large allocations, that&#8217;s fine, but lots of people use malloc for small allocations, in which case your version is extremely wasteful. My remark about strdup was merely one example where people use malloc() to allocate small amounts of memory. -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-423563">
				<div id="div-comment-423563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-423563">
			September 24, 2006 at 8:31 pm</a>		</div>

		<blockquote><p>
  Sorry, I missed the MEM_RELEASE part.</p>
<p>No problem, except that you got me worried that something in the API has changed.</p>
<p>I completely agree that using VirtualAlloc() for small allocations is wastefull.</p>
<p>I only use it for large datasets when I do not know the size of the dataset in advance and when I have to make multiple passes over the data.</p>
<p>However, when I need to load the dataset into the memory for one-shot processing I prefer not to allocate memory at all but to use CreateFileMapping()/MapViewOfFile() instead.</p>
<p>OS is hell of a lot better in managing memory resources than I am, especially if the dataset doesn&#8217;t fit in available RAM and in many cases it is much simpler to access the data this way instead of using memory allocating and file reading/writing APIs.</p>
<p>Finally, if something is small enough like that string you mentioned it would be better off using some dedicated C++ or STL string class which will offer superior performance and save you from reinventing the wheel.</p>
<p>I am surprised how many Windows programmers (or should I say &quot;developers&quot;?) don&#8217;t know how to use basic Win32 APIs and still stick to C runtime for everything they need. No wonder software is so slow and bloated when so much wrappers and levels of indirection exist.<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424593">
				<div id="div-comment-424593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-424593">
			September 27, 2006 at 1:20 am</a>		</div>

		<p>And we forgot that using malloc() and free() to allocate structures in C++ is a bad thing because if you later add say CString to a structure and allocate an array of structures malloc() won&#8217;t call CString constructor resulting in garbage/crash nor will free() call CString destructor resulting in a memory leak.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424623">
				<div id="div-comment-424623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">schabi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-424623">
			September 27, 2006 at 7:40 am</a>		</div>

		<p>wr/t <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx#758832" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx#758832</a> :</p>
<p>In fact, you have the choice between different libc implementations on some unices ( e. G. libc5, libc6, dietlibc, klibc for Linux), but they&#8217;Re different major versions or libc vendors, and currently, the glibc is the one that&#8217;s wildly used, the other ones are for special purpose. So, in rality, you&#8217;re view is correct.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424633">
				<div id="div-comment-424633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">schabi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-424633">
			September 27, 2006 at 7:40 am</a>		</div>

		<p>wr/t <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx#758832" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx#758832</a> :</p>
<p>In fact, you have the choice between different libc implementations on some unices ( e. G. libc5, libc6, dietlibc, klibc for Linux), but they&#8217;Re different major versions or libc vendors, and currently, the glibc is the one that&#8217;s wildly used, the other ones are for special purpose. So, in practice, you&#8217;re view is correct.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424643">
				<div id="div-comment-424643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">schabi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-424643">
			September 27, 2006 at 7:55 am</a>		</div>

		<p>wr/t <a rel="nofollow" target="_new" href="http://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx#760640" rel="nofollow">http://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx#760640</a> :</p>
<p>&gt;&gt; Everyone&#8217;s happy enough with glibc that they at least don&#8217;t try to distribute their own copy of it, to &quot;preserve compatibility&quot; or some such hogwash.&lt;&lt;</p>
<p>Not everyone&#8217;s happy with glibc. But most of those unhappy with glibc write their own replacement (like dietlibc), instead of distributing their own copy.</p>
<p>And you&#8217;ve got one big advantage (as distributor, as well as developer): You&#8217;ve got the source of virtually everything, so you can compile it against the same versions of libs with the same toolchain (minus fixing some bugs).</p>
<p>Whenever some binary only software comes in, Hell breaks loose.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-425263">
				<div id="div-comment-425263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://support.microsoft.com/kb/867855/en-us' rel='external nofollow' class='url'>Norman Diamond</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-425263">
			September 28, 2006 at 3:00 am</a>		</div>

		<p>It is good to see Microsoft release a fix when they make the same mistake.</p>
<p><a rel="nofollow" target="_new" href="http://support.microsoft.com/kb/867855/en-us" rel="nofollow">http://support.microsoft.com/kb/867855/en-us</a></p>
<p>&gt; A previous update implements a new memory<br />
<br />&gt; heap in NDIS and then calls a new allocator<br />
<br />&gt; function. However, this previous update does<br />
<br />&gt; not use the matching de-allocator.<br />
<br />&gt; Therefore, a free is requested for the wrong<br />
<br />&gt; memory pool.</p>
<p>I think end users can download a package that includes this hotfix, but end users can&#8217;t install it. &nbsp;Someone has to persuade vendors to provide flashable firmware.</p>
<div CLASS=post>[<i>As I already noted, <a href="http://blogs.msdn.com/oldnewthing/archive/2006/07/13/664448.aspx" rel="nofollow">Microsoft software is hardly immune to issues I raise</a>. What&#8217;s your point? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-425543">
				<div id="div-comment-425543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-425543">
			September 28, 2006 at 9:09 pm</a>		</div>

		<blockquote><p>
  What&#8217;s your point?</p>
<p>(1):<br />
  <br />&gt;&gt; It is good to see Microsoft release a<br />
  <br />&gt;&gt; fix when they make the same mistake.</p>
<p>That is in contrast to the enormous number of times when your company refuses to release a fix. &nbsp;It was good to see this one.</p>
<p>(2):<br />
  <br />&gt;&gt; Someone has to persuade vendors to<br />
  <br />&gt;&gt; provide flashable firmware.</p>
<p>As you already noted&#8230;. &nbsp;Network Attached Storage devices aren&#8217;t the only ones that need flashable firmware. &nbsp;I do hope vendors can be persuaded some day to let customers make needed updates.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-470083">
				<div id="div-comment-470083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://agassi.wordpress.com/2007/02/06/%e7%bc%96%e7%a8%8b%e7%82%b9%e6%bb%b41/' rel='external nofollow' class='url'>????????????(1) &laquo; Kernel Space</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-470083">
			February 7, 2007 at 2:24 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://agassi.wordpress.com/2007/02/06/%e7%bc%96%e7%a8%8b%e7%82%b9%e6%bb%b41/" rel="nofollow">http://agassi.wordpress.com/2007/02/06/%e7%bc%96%e7%a8%8b%e7%82%b9%e6%bb%b41/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-471233">
				<div id="div-comment-471233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/nikolad/archive/2007/02/09/q-a-on-adapting-vs2005-sp1-to-build-your-applications.aspx' rel='external nofollow' class='url'>Nikola Dudar's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-471233">
			February 9, 2007 at 9:18 pm</a>		</div>

		<p>When VS2005 SP1 has been released because of manifests it become more visible what version of VC++ DLLs</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-479023">
				<div id="div-comment-479023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://blogs.msdn.com:443/nikolad/archive/2007/02/09/q-a-on-adapting-vs2005-sp1-to-build-your-applications.aspx' rel='external nofollow' class='url'>Nikola Dudar's WebLog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-479023">
			March 2, 2007 at 3:33 pm</a>		</div>

		<p>When VS2005 SP1 has been released, because of manifests it become more visible what version of VC++ DLLs</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-483183">
				<div id="div-comment-483183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mykernelspace.com/?p=18' rel='external nofollow' class='url'>????????????(1) &raquo; www.mykernelspace.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-483183">
			March 16, 2007 at 3:25 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://mykernelspace.com/?p=18" rel="nofollow">http://mykernelspace.com/?p=18</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-508353">
				<div id="div-comment-508353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://lunglet.net/2007/05/25/memory-allocation-in-windows-programs/' rel='external nofollow' class='url'>lunglet.net &raquo; Blog Archive &raquo; Memory allocation in Windows programs</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-508353">
			May 25, 2007 at 12:21 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://lunglet.net/2007/05/25/memory-allocation-in-windows-programs/" rel="nofollow">http://lunglet.net/2007/05/25/memory-allocation-in-windows-programs/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-586033">
				<div id="div-comment-586033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.deez.info/sengelha/blog/2008/01/04/stl-objects-and-module-boundaries/' rel='external nofollow' class='url'>Steven Engelhardt &raquo; Blog Archive &raquo; STL objects and module boundaries</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060915-04/?p=29723#comment-586033">
			January 4, 2008 at 5:27 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://www.deez.info/sengelha/blog/2008/01/04/stl-objects-and-module-boundaries/" rel="nofollow">http://www.deez.info/sengelha/blog/2008/01/04/stl-objects-and-module-boundaries/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

