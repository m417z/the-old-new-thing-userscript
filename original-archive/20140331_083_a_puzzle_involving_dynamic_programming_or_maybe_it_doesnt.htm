<html>
<head>
<title>A puzzle involving dynamic programming, or maybe it doesn't</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>A puzzle involving dynamic programming, or maybe it doesn&#8217;t</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 31, 2014 / year-entry #84</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>25</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Here's a programming challenge: Evaluate the following recurrence relation efficiently for a given array [x0, &hellip;, xn&minus;1] and integer k. f&thinsp;([x0, x1],  k) =  (x0 + x1) / 2  for all k, n = 2.  f&thinsp;([x0, &hellip;, xn&minus;1],  k) =  (x0 + xn&minus;1) / 2 +  f&thinsp;([x0, &hellip;, xn&minus;2], k + 1) / 2 + ...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Here's a programming challenge:
</p>
<blockquote CLASS=q>
<p>
Evaluate the following recurrence relation efficiently
for a given array
<span TITLE="x sub 0 to x sub (n-1)">
[<var>x</var><sub>0</sub>, &hellip;, <var>x</var><sub><var>n</var>&minus;1</sub>]
</span>
and integer
<span TITLE="k"><var>k</var></span>.
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%">
<tr TITLE="f([x sub 0, x sub 1], k) = (x sub 0 + x sub 1) / 2 for all k">
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, <var>x</var><sub>1</sub>],&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>k</var>) =<sub>&nbsp;</sub>
    </td>
<td NOWRAP VALIGN=baseline>
    (<var>x</var><sub>0</sub> + <var>x</var><sub>1</sub>) / 2&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    </td>
<td NOWRAP VALIGN=baseline>
    </td>
<td NOWRAP VALIGN=baseline>
    for all <var>k</var>, <var>n</var> = 2.<sub>&nbsp;</sub>
    </td>
</tr>
<tr TITLE="f([x sub 0, ..., x sub (n-1)], k) = (x sub 0 + x sub (n-1)) / 2 + f([x sub 0, ... x sub (n-2)], k + 1) / 2 + f([x sub 1, ... x sub (n-1)], k + 1) / 2 for even k, n >= 3"></p>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, &hellip;,
               <var>x</var><sub><var>n</var>&minus;1</sub>],&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>k</var>) =<sub>&nbsp;</sub>
    </td>
<td NOWRAP VALIGN=baseline>
    (<var>x</var><sub>0</sub> + <var>x</var><sub><var>n</var>&minus;1</sub>) / 2 +&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, &hellip;, <var>x</var><sub><var>n</var>&minus;2</sub>], <var>k</var> + 1) / 2 +&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>1</sub>, &hellip;, <var>x</var><sub><var>n</var>&minus;1</sub>], <var>k</var> + 1) / 2&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    for even <var>k</var>, <var>n</var> &ge; 3.<sub>&nbsp;</sub>
    </td>
</tr>
<tr TITLE="f([x sub 0, ..., x sub (n-1)], k) = f([x sub 0, ... x sub (n-2)], k + 1) / 2 + f([x sub 1, ... x sub (n-1)], k + 1) / 2 for odd k, n >= 3"></p>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, &hellip;,
               <var>x</var><sub><var>n</var>&minus;1</sub>],&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>k</var>) =<sub>&nbsp;</sub>
    </td>
<td NOWRAP VALIGN=baseline>
    &nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, &hellip;, <var>x</var><sub><var>n</var>&minus;2</sub>], <var>k</var> + 1) / 2 +&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>1</sub>, &hellip;, <var>x</var><sub><var>n</var>&minus;1</sub>], <var>k</var> + 1) / 2&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    for odd <var>k</var>, <var>n</var> &ge; 3.<sub>&nbsp;</sub>
    </td>
</tr>
</table>
<p>
Hint: Use dynamic programming.
</p>
</blockquote>
<p>
In words:
</p>
<ul>
<li>If the array has only two elements, then the result is the average
    of the two elements.</p>
<li>If the array has more than two elements, then
    then the result is the sum of the following:</p>
<ul>
<li>Half the value of the function evaluated on the array with the
        <i>first</i> element deleted
        and the second parameter incremented by one.</p>
<li>Half the value of the function evaluated on the array with the
        <i>last</i> element deleted
        and the second parameter incremented by one.</p>
<li>If the second parameter is even,
        then also add the average of the first and last elements
        of the original array.
    </ul>
</ul>
<p>
The traditional approach with dynamic programming is to cache intermediate
results in anticipation that the values will be needed again later.
The na&iuml;ve solution, therefore, would have a cache keyed by
the vector and
<var>k</var>.
</p>
<p>
My habit when trying to solve these sorts of recurrence relations
is to solve the first few low-valued cases by hand.
That gives me a better insight into the problem
and may reveal some patterns or tricks.
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%"
    TITLE="f([x sub 0, x sub 1, x sub 2], k) = ...">
<tr>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>,
               <var>x</var><sub>1</sub>,
               <var>x</var><sub>2</sub>], <var>k</var><sub>even</sub>)&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    = (<var>x</var><sub>0</sub> + <var>x</var><sub>2</sub>) / 2 +
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, <var>x</var><sub>1</sub>], <var>k</var><sub>even</sub> + 1) / 2 +
    <var>f</var>&thinsp;([<var>x</var><sub>1</sub>, <var>x</var><sub>2</sub>], <var>k</var><sub>even</sub> + 1) / 2
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = (<var>x</var><sub>0</sub> + <var>x</var><sub>2</sub>) / 2 +
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, <var>x</var><sub>1</sub>], <var>k</var><sub>odd</sub>) / 2 +
    <var>f</var>&thinsp;([<var>x</var><sub>1</sub>, <var>x</var><sub>2</sub>], <var>k</var><sub>odd</sub>) / 2
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = (<var>x</var><sub>0</sub> + <var>x</var><sub>2</sub>) / 2 +
      (<var>x</var><sub>0</sub> + <var>x</var><sub>1</sub>) / 4 +
      (<var>x</var><sub>1</sub> + <var>x</var><sub>2</sub>) / 4
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &frac34;<var>x</var><sub>0</sub> +
      &frac12;<var>x</var><sub>1</sub> +
      &frac34;<var>x</var><sub>2</sub>
    </td>
</tr>
</table>
<p>
Even just doing this one computation, we learned a lot.
(Each of which can be proved by induction if you are new to this sort of
thing, or which is evident by inspection if you're handy with math.)
</p>
<p>
First observation:
The function is linear in the array elements.
In other words,
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%">
<tr TITLE="f(x + y, k) = f(x, k) + f(y,k)">
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(<var><b>x</b></var> + <var><b>y</b></var>,&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>k</var>)&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    =&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(<var><b>x</b></var>, <var>k</var>) +
    <var>f</var>&thinsp;(<var><b>y</b></var>, <var>k</var>),
    </td>
</tr>
<tr TITLE="f(ax, k) = af(x, k)">
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(<var>a</var><var><b>x</b></var>,&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    <var>k</var>)&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    = <var>a</var>
    </td>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(<var><b>x</b></var>, <var>k</var>).
    </td>
</tr>
</table>
<p>
To save space and improve readability, I'm using vector notation,
where
adding two vectors adds the elements componentwise,
and multiplying a vector by a constant multiples each component.
The long-form version of the first of the above equations would be
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%"
    TITLE="f([x sub 0 + y sub 0, ..., x sub (n-1) + y sub (n-1)], k) = f([x sub 0, ... x sub (n-1)], k) + f([y sub 0, ... y sub (n-1)], k)">
<tr>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub> + <var>y</var><sub>0</sub>,
    &hellip;, <var>x</var><sub><var>n</var>&minus;1</sub> +
              <var>y</var><sub><var>n</var>&minus;1</sub>], <var>k</var>) =
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, &hellip;, <var>x</var><sub><var>n</var>&minus;1</sub>], <var>k</var>) +
    <var>f</var>&thinsp;([<var>y</var><sub>0</sub>, &hellip;, <var>y</var><sub><var>n</var>&minus;1</sub>], <var>k</var>)
    </td>
</tr>
</table>
<p>
Since the result is a linear combination
of the vector elements,
we can work just with the coefficients and save ourselves some
typing.
("Move to the dual space.")
For notational convenience, we will write
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%">
<tr>
<td NOWRAP VALIGN=baseline>
    &#x27E8;<var>a</var><sub>0</sub>, &hellip;
          <var>a</var><sub><var>n</var>&minus;1</sub>&#x27E9; =
    <var>a</var><sub>0</sub> <var>x</var><sub>0</sub> +
    &#x22ef; +
    <var>a</var><sub><var>n</var>&minus;1</sub> <var>x</var><sub><var>n</var>&minus;1</sub>
    </td>
</tr>
</table>
<p>
Second observation:
The specific value of
<var>k</var> is not important.
All that matters is whether it is even or odd,
and each time we recurse to the next level,
the parity flips.
So the second parameter is really just a boolean.
That greatly reduces the amount of stuff we need to cache,
as well as increasing the likelihood of a cache hit.
(The na&iuml;ve version would not have realized that
<span TITLE="f(x, k)"><var>f</var>&thinsp;(<var><b>x</b></var>, <var>k</var>)</span>
can steal the cached result from
<span TITLE="f(x, k+2)"><var>f</var>&thinsp;(<var><b>x</b></var>, <var>k</var> + 2)</span>.)
</p>
<p>
Our previous hand computation can now be written as
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%"
    TITLE="f([x sub 0, x sub 1, x sub 2], k) = ...">
<tr>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>,
               <var>x</var><sub>1</sub>,
               <var>x</var><sub>2</sub>], even)&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&frac12, 0, &frac12;&#x27E9; +
    <var>f</var>&thinsp;([<var>x</var><sub>0</sub>, <var>x</var><sub>1</sub>], odd) / 2 +
    <var>f</var>&thinsp;([<var>x</var><sub>1</sub>, <var>x</var><sub>2</sub>], odd) / 2
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&frac12;, 0, &frac12;&#x27E9; +
    &#x27E8;&frac12;, &frac12;, 0&#x27E9; / 2 +
    &#x27E8;0, &frac12;, &frac12;&#x27E9; / 2
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&frac12;, 0, &frac12;&#x27E9; +
    &#x27E8;&frac14;, &frac14;, 0&#x27E9; +
    &#x27E8;0, &frac14;, &frac14;&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&frac34;, &frac12;, &frac34;&#x27E9;
    </td>
</tr>
</table>
<p>
Now that we are working with coefficients, we don't need
to deal with
<var><b>x</b></var> any more!
All that matters is the length of the vector.
This makes our recurrences much simpler:
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%">
<tr TITLE="f(2, k) = {half, half} for all k">
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(2,&nbsp;
    </td>
<td><var>k</var>)&nbsp;
    </td>
<td>
    =&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    &#x27E8;&frac12;, &frac12;&#x27E9;&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    </td>
<td NOWRAP VALIGN=baseline>
    </td>
<td NOWRAP VALIGN=baseline>
    for all <var>k</var>.
    </td>
</tr>
<tr TITLE="f(n, even) = {1/2, 0, ..., 0, 1/2} + { f(n-1, odd) / 2, 0} + {0, f(n-1, odd) / 2} for n &gt;= 3">
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(<var>n</var>,&nbsp;
    </td>
<td>
    even)&nbsp;
    </td>
<td>=&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    &#x27E8;&frac12;, 0, &hellip;, 0, &frac12;&#x27E9; +&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    &#x27E8;<var>f</var>&thinsp;(<var>n</var>&minus;1, odd) / 2, 0&#x27E9; +&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    &#x27E8;0, <var>f</var>&thinsp;(<var>n</var>&minus;1, odd) / 2&#x27E9;&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    for <var>n</var> &ge; 3.
    </td>
</tr>
<tr TITLE="f(n, odd) = { f(n-1, even) / 2, 0} + {0, f(n-1, even) / 2} for n &gt;= 3">
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(<var>n</var>,&nbsp;
    </td>
<td>
    odd)&nbsp;
    </td>
<td>=&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    &nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    &#x27E8;<var>f</var>&thinsp;(<var>n</var>&minus;1, even) / 2, 0&#x27E9; +&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    &#x27E8;0, <var>f</var>&thinsp;(<var>n</var>&minus;1, even) / 2&#x27E9;&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    for <var>n</var> &ge; 3.
    </td>
</tr>
</table>
<p>
Now we can carry out a few more hand computations.
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%"
    TITLE="f(3, odd) = {f(2, even)/2, 0} + {0, f(2, even)/2} = {&frac14;, &frac12;, &frac14;}">
<tr>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(3, odd)&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    =
    &#x27E8;<var>f</var>&thinsp;(2, even) / 2, 0&#x27E9; +
    &#x27E8;0, <var>f</var>&thinsp;(2, even) / 2&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    =
    &#x27E8;&frac14;, &frac14;, 0&#x27E9; +
    &#x27E8;0, &frac14;, &frac14;&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&frac14;, &frac12;, &frac14;&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(4, even)&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&frac12;, 0, 0, &frac12;&#x27E9; +
    &#x27E8;<var>f</var>&thinsp;(3, odd) / 2, 0&#x27E9; +
    &#x27E8;0, <var>f</var>&thinsp;(3, odd) / 2&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&frac12;, 0, 0, &frac12;&#x27E9; +
    &#x27E8;&#x215b;, &frac14;, &#x215b;, 0&#x27E9; +
    &#x27E8;0, &#x215b;, &frac14;, &#x215b;&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&#x215d;, &#x215c;, &#x215c;, &#x215d;&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>
    <var>f</var>&thinsp;(4, odd)&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    =
    &#x27E8;<var>f</var>&thinsp;(3, even) / 2, 0&#x27E9; +
    &#x27E8;0, <var>f</var>&thinsp;(3, even) / 2&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    =
    &#x27E8;&#x215c;, &frac14;, &#x215c;, 0&#x27E9; +
    &#x27E8;0, &#x215c;, &frac14;, &#x215c;&#x27E9;
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline>&nbsp;</td>
<td NOWRAP VALIGN=baseline>
    = &#x27E8;&#x215c;, &#x215d;, &#x215d;, &#x215c;&#x27E9;
    </td>
</tr>
</table>
<p>
The interesting thing to observe here is that the recursion
does not branch.
When we reduce the size of the vector by one element,
the recursive calls are basically identical.
We have to shift the coefficients differently in order
to build up the results,
but the recursive call itself is unchanged.
This means that we need to perform only
<var>n</var>&minus;2
recursive steps to compute
<span TITLE="f(n, k)"><var>f</var>&thinsp;(<var>n</var>, <var>k</var>)</span>.
</p>
<p>
Okay, now that we've studied the problem a bit,
we can write the code.
I'll write three versions of the function.
The first computes according to the recurrence relation
as originally written.
We use this to verify our calculations.
</p>
<pre>
function f1(x, k) {
 if (x.length == 2) {
  return (x[0] + x[1]) / 2;
 }
 var term = 0;
 if (k % 2 == 0) {
  term = (x[0] + x[x.length - 1]) / 2;
 }
 return term +
        f1(x.slice(0,-1), k + 1) / 2 +
        f1(x.slice(1), k + 1) / 2;
}

Immediate window:

f1([1,2,3], 0)
= 4.0
</pre>
<p>
Okay, that matches our hand calculations,
&frac34;&middot;1 + &frac12;&middot;2 + &frac34;&middot;3 = 4.
</p>
<p>
Now let's do the straight recursive version.
</p>
<pre>
function dotproduct(a, x)
{
 var total = 0;
 for (var i = 0; i &lt; a.length; i++) total += a[i] * x[i];
 return total;
}

function f2a(n, k)
{
 if (n == 2) return [1/2, 1/2];

 var c = new Array(n);
 for (var i = 0; i &lt; n; i++) c[i] = 0;

 if (k % 2 == 0) {
  c[0] = 1/2;
  c[n-1] = 1/2;
 }

 var inner = f2a(n-1, k+1);
 for (var i = 0; i &lt; n - 1; i++) {
  c[i] += inner[i] / 2;
  c[i+1] += inner[i] / 2;
 }

 return c;
}

function f2(x, k)
{
 return dotproduct(f2a(x.length, k), x);
}

Immediate window:

f2([1,2,3], 0)
= 4.0
</pre>
<p>
Notice that there is no dynamic programming involved.
<b>The hint in the problem statement was a red herring!</b>
</p>
<p>
Finally, we can eliminate the recursion by iterating
<code>n</code> up from 2.
</p>
<pre>
function f3(x, k)
{
 var c = new Array(x.length);
 for (var i = 0; i &lt; x.length; i++) c[i] = 0;
 c[0] = 1/2;
 c[1] = 1/2;

 for (var n = 3; n &lt;= x.length; n++) {
  var carry = 0;
  for (var i = 0; i &lt; n; i++) {
   var nextcarry = c[i];
   c[i] = (carry + c[i]) / 2;
   carry = nextcarry;
  }
  if ((k + n + x.length) % 2 == 0) {
   c[0] += 1/2;
   c[n-1] += 1/2;
  }
 }
 return dotproduct(c, x);
}
</pre>
<p>
I pulled a sneaky trick here in the place we test whether
we are in the even or odd case.
Officially, the test should be
</p>
<pre>
  if ((k + (x.length - n)) % 2 == 0) {
</pre>
<p>
but since we are interested only in whether the result is
even or odd,
we can just add the components together,
because subtraction and addition have the same effect
on even-ness and odd-ness.
(If I really felt like micro-optimizing,
I could fold <code>x.length</code> into <code>k</code>.)
</p>
<p>
Okay, now that we have our code,
let's interpret the original problem.
</p>
<p>
The expression
<span TITLE="{f(n,k)/2, 0} + {0, f(n,k)/2}">
&#x27E8;<var>f</var>&thinsp;(<var>n</var>, <var>k</var>) / 2, 0&#x27E9; +
&#x27E8;0, <var>f</var>&thinsp;(<var>n</var>, <var>k</var>) / 2&#x27E9;</span>
takes the vector
<span TITLE="f(n,k)">
<var>f</var>&thinsp;(<var>n</var>, <var>k</var>)</span>
and averages it against a shifted copy of itself.
(The word <i>convolution</i> could be invoked here.)
If you think of the coefficients as describing the distribution
of a chemical,
the expression calculates the effect of diffusion after one
time step according to the simple model
"At each time step, each molecule has a 50% chance of moving
to the left and a 50% chance of moving to the right."
(Since the length of the vector varies with
<var>n</var>,
I'll visualize the vector drawn with center-alignment.)
</p>
<p>
The base case
&#x27E8;&frac12;, &frac12;&#x27E9;
describes the initial conditions of the diffusion,
where half of the chemicals are on the left and half are
on the right.
This is one time step after one unit of the chemical
was placed in the center.
Let's get rid of the extra term in the recurrence and focus
just on the diffusion aspect:
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%">
<tr TITLE="d(2) = {half, half}">
<td NOWRAP VALIGN=baseline>
    <var>d</var>(2) =
    &#x27E8;&frac12;, &frac12;&#x27E9;&nbsp;
    </td>
</tr>
<tr TITLE="d(n) = &#x27E8; d(n-1) / 2, 0&#x27E9; + &#x27E8;0, d(n-1) / 2&#x27E9; for n >= 3"></p>
<td NOWRAP VALIGN=baseline>
    <var>d</var>(<var>n</var>) =
    &#x27E8;<var>d</var>(<var>n</var>&minus;1) / 2, 0&#x27E9; +
    &#x27E8;0, <var>d</var>(<var>n</var>&minus;1) / 2&#x27E9;&nbsp;
    </td>
<td NOWRAP VALIGN=baseline>
    for <var>n</var> &ge; 3.
    </td>
</tr>
</table>
<p>
If you compute these values, you'll see that the results are
awfully familiar.
I've pulled out the common denominator to avoid the ugly fractions.
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%">
<tr>
<td NOWRAP VALIGN=baseline ALIGN=center>
    1 1
    </td>
<td NOWRAP VALIGN=baseline ALIGN=center>
    entire row divided by 2
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline ALIGN=center>
    1 2 1
    </td>
<td NOWRAP VALIGN=baseline ALIGN=center>
    entire row divided by 4
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline ALIGN=center>
    1 3 3 1
    </td>
<td NOWRAP VALIGN=baseline ALIGN=center>
    entire row divided by 8
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline ALIGN=center>
    1 4 6 4 1
    </td>
<td NOWRAP VALIGN=baseline ALIGN=center>
    entire row divided by 16
    </td>
</tr>
<tr>
<td NOWRAP VALIGN=baseline ALIGN=center>
    1 5 10 10 5 1&nbsp;&nbsp;
    </td>
<td NOWRAP VALIGN=baseline ALIGN=center>
    entire row divided by 32
    </td>
</tr>
</table>
<p>
Yup, it's Pascal's Triangle.
</p>
<p>
Notice that the sum across the row equals the amount we are dividing by,
so that the sum of the row is always 1.
(This is easy to see from the recurrence relation, since the base
case establishes the property that the sum of the coordinates is 1,
and the recurrence preserves it.)
</p>
<p>
This means that
we can calculate the coefficients of
<var>d</var>(<var>n</var>)
for any value of
<var>n</var> directly,
without having to calculate any of coefficients for smaller values
of
<var>n</var>.
The coefficients are just row
<var>n</var> of Pascal's triangle,
<!-- Mathematical formulas are designed to be pretty, not to be suitable for computation -->
which we know how to compute in
<var>O</var>(<var>n</var>)</a> time</a>.
</p>
<p>
Now we can also interpret the extra term we removed at the even steps.
That term of the recurrence
simulates adding a unit of chemical to the solution
at every other time step,
half a unit at the left edge and half at the right edge.
And we can calculate these directly in the same way that
we calculated the diffusion coefficients,
since they basically <i>are</i> the diffusion coefficients,
just with a time and location adjustment.
</p>
<p>
I pulled a fast one here.
Maybe you didn't pick up on it:
I'm assuming that the two parts of the recurrence
unrelated to the diffusion behavior
(the base condition and the extra term at the even steps)
are independent and can simply be added together.
You can show this by noting that given the generalized recurrence
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 200%">
<tr TITLE="f sub G(2, k) = G(2) for all k">
<td NOWRAP VALIGN=baseline>
    <var>f</var><sub><var>G</var></sub>(2, <var>k</var>)
    = <var>G</var>(2, <var>k</var>)
    </td>
</tr>
<tr TITLE="f sub G(n, k) = G(n, k) + { f sub G(n-1, k + 1) / 2, 0} + {0, f sub G(n-1, k + 1) / 2} for n &gt;= 3">
<td NOWRAP VALIGN=baseline>
    <var>f</var><sub><var>G</var></sub>(<var>n</var>, <var>k</var>)
    =
    <var>G</var>(<var>n</var>, <var>k</var>)
    +
    &#x27E8;<var>f</var><sub><var>G</var></sub>(<var>n</var>&minus;1, <var>k</var> + 1) / 2, 0&#x27E9; +
    &#x27E8;0, <var>f</var><sub><var>G</var></sub>(<var>n</var>&minus;1, <var>k</var> + 1) / 2&#x27E9;
    for <var>n</var> &ge; 3.
    </td>
</tr>
</table>
<p>
then
<span TITLE="f sub (G+H) = f sub G + f sub H">
<var>f</var><sub><var>G</var>+<var>H</var></sub>
=
<var>f</var><sub><var>G</var></sub> +
<var>f</var><sub><var>H</var></sub></span>.
(As before, induct on the recurrence relations.)
Therefore, we can solve each of the pieces separately
and just add the results together.
</p>
<p>
If I had the time and inclination,
I could work out the solution for
</p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0
    STYLE="line-height: 400%">
<tr TITLE="C(n,i) + sum for k even, 2 &lt; k &le; n of C(k, i)/2^k">
<td NOWRAP VALIGN=baseline>
<var>C</var>(<var>n</var>, <var>i</var>) +
<font SIZE=+3><var STYLe="font-style: normal">&Sigma;</var></font><sub><var>k</var> even, 2 &lt; <var>k</var> &le; n</sub>
<var>C</var>(<var>k</var>, <var>i</var>) / 2<sup><var>k</var></sup>
    </td>
</tr>
</table>
<p>
or something similar to that.
Like I said, I ran out of time and inclination.
But if I could come up with an efficient way to compute that
value for all values of
<var>i</var>
for fixed
<var>n</var>
(and I believe there is, I'm just too lazy to work it out),
then I would have an
<var>O</var>(<var>n</var>)</a> solution
to the original recurrence.
</p>
<p>
(Okay, so the "If I had the time" bit is a cop-out, but
I sort of lost interest in the problem.)</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (25)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1116383">
				<div id="div-comment-1116383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mungo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116383">
			March 31, 2014 at 7:42 am</a>		</div>

		<p>Should I consider a career change if I fall asleep after reading the first few lines?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116393">
				<div id="div-comment-1116393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116393">
			March 31, 2014 at 8:06 am</a>		</div>

		<p>@Mungo:</p>
<p>If you were like me and started feeling drowsy, but able to understand what was going on, then don&#39;t worry about it. Mathematics does it to me all the time.</p>
<p>If on the other hand you don&#39;t understand, then the I would urge you at the very least to learn. While you can get things done as a programmer by throwing code together, this post is all about gaining optimisation opportunities through understanding mathematically what is going on. It is surprising how much mathematics is involved with computing, which is why all of the decent computer science degree courses I know involve discrete mathematics, complexity and automata as modules. Having a pretty decent foundation in other areas is also rather important.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116413">
				<div id="div-comment-1116413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Smithers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116413">
			March 31, 2014 at 9:00 am</a>		</div>

		<p>(In the f3() solution)</p>
<p>What do you actually gain by the &quot;sneaky trick&quot; of using (k + n + x.length) instead of (k + (x.length &#8211; n))? Is subtraction somehow less efficient than addition?</p>
<p>Also, I would have instinctively removed the need for carry and nextcarry in this section</p>
<p>&nbsp;var carry = 0;</p>
<p>&nbsp;for (var i = 0; i &lt; n; i++) {</p>
<p>&nbsp; var nextcarry = c[i];</p>
<p>&nbsp; c[i] = (carry + c[i]) / 2;</p>
<p>&nbsp; carry = nextcarry;</p>
<p>&nbsp;}</p>
<p>by going through the list in reverse order:</p>
<p>&nbsp;for (var i = n-1; i &gt; 0; i++) {</p>
<p>&nbsp; c[i] = (c[i] + c[i-1]) / 2;</p>
<p>&nbsp;}</p>
<p>&nbsp;c[0] /= 2;</p>
<div class="post">[<em>As a mathematician, I perform the sneaky trick instinctively. It eliminates parentheses, and since addition is commutative, it opens future opportunities for simplification. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116423">
				<div id="div-comment-1116423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Smithers</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116423">
			March 31, 2014 at 9:04 am</a>		</div>

		<p>Except that obviously that should be i&#8211; in my version of the loop. I always get that wrong the first time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116433">
				<div id="div-comment-1116433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116433">
			March 31, 2014 at 9:06 am</a>		</div>

		<p>@Crescens2k</p>
<p>People often say these things, but don&#39;t provide concrete examples outside of gaming, data analysis, and specialised scientific/mathematics/development (e.g. writing my own compiler) applications.</p>
<p>The core question is &quot;What relevance is the conceptual example given, specifically, going to have to my software development career? I can only learn so many things, so why should I spend my time on Thing X rather than Thing Y?&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116443">
				<div id="div-comment-1116443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anon</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116443">
			March 31, 2014 at 9:08 am</a>		</div>

		<p>@Anon</p>
<p>I should add that the example may have no relevance at all, and simply be trivia or a brainteaser &#8212; in which case, the question is irrelevant.</p>
<p>But for my comment, assume the larger issue of &quot;Why do people ask &#39;Why do I need to know this?&#39;&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116453">
				<div id="div-comment-1116453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116453">
			March 31, 2014 at 10:34 am</a>		</div>

		<p>Here&#39;s a cute one someone taught me years ago: Simplify the following expression:</p>
<p>(x-a)(x-b)(x-c)&#8230;(x-z)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116463">
				<div id="div-comment-1116463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116463">
			March 31, 2014 at 10:39 am</a>		</div>

		<p>Myria: am I right in thinking you want the answer 0?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116473">
				<div id="div-comment-1116473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116473">
			March 31, 2014 at 10:43 am</a>		</div>

		<p>@Smithers: &quot;Is subtraction somehow less efficient than addition?&quot;</p>
<p>Actually, yes, sometimes it is. &nbsp;The x86 &quot;lea&quot; instruction is often used to do three-operand addition. &nbsp;The x86 can&#39;t normally do three-operand anything, but lea lets you use the specialized addressing modes. &nbsp;However, the x86 doesn&#39;t have subtraction in its addressing modes &#8211; only addition and optional multiplication by 2, 4, and 8.</p>
<div class="post">[<em>Also, x86 and x64 do not have a reverse-subtraction opcode. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116483">
				<div id="div-comment-1116483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Myria</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116483">
			March 31, 2014 at 10:50 am</a>		</div>

		<p>@Mark: =^-^=</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116493">
				<div id="div-comment-1116493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Crescens2k</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116493">
			March 31, 2014 at 11:29 am</a>		</div>

		<p>@Anon:</p>
<p>One example is if you are comparing two lists of strings.</p>
<p>If the lists are unsorted, how long would it take to compare? For both lists being unsorted for every item in one list you would have to start from the beginning of the other. You can stop early if you find the item you are looking for, but you can&#39;t stop early in any other case. For the string itself, again, you can compare as far as needed in the string but it is hard to do more than that.</p>
<p>What happens if both lists are sorted? You can start after the start of one list if you have found an item already, you know that any item in the list you are comparing against will always come after the one you found. You are also able to make other optimisations, like only comparing as many letters as needed until you find a difference, even skipping blocks of the array by first letter comparison alone.</p>
<p>While there are many things that be commented on in this example, the fact is that this kind of runtime analysis for even regular functions is in the area of complexity. Of course it is possible to make this kind of reasoning regardless, but learning the mathematics behind it not only formalises the knowledge, but as I often find, you start doing these things implicitly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn odd alt thread-odd thread-alt depth-1" id="comment-1116513">
				<div id="div-comment-1116513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116513">
			March 31, 2014 at 12:19 pm</a>		</div>

		<p> This reminds me how few years ago I participated in a contest for young programmers. One of the tasks was to efficiently calculate 1+2+3+â¦+1978 in as many high-level programming languages as possible. This was my special hobby these days, so I quickly wrote the simple for loop in 20+ languages, ranging from COBOL to Lisp (have I mentioned that the year was 1978?). To my shame, this solution was rated second after the one that simply printed 1957231.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116523">
				<div id="div-comment-1116523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy O'Neal</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116523">
			March 31, 2014 at 12:27 pm</a>		</div>

		<p>To my understanding, your &quot;iterating up from 2&quot; example is dynamic programming; you are computing the result bottom up with a cache that lets you reuse previous results. This is no different than the first example usually given for dynamic programming the Fibonacci number N; which is O(2^N) for the recursive formulation:</p>
<p>int f(int n)</p>
<p>{</p>
<p>&nbsp; &nbsp;if (n == 0 || n == 1) { return 1; }</p>
<p>&nbsp; &nbsp;return f(n &#8211; 2) + f(n &#8211; 1);</p>
<p>}</p>
<p>but O(N) for the dynamic programming version:</p>
<p>int f(int n)</p>
<p>{</p>
<p>&nbsp; &nbsp;int nMinusTwo = 1;</p>
<p>&nbsp; &nbsp;int nMinusOne = 1; // This is the &quot;cache&quot; of dynamic programming</p>
<p>&nbsp; &nbsp;for (int idx = 2; idx &lt;= n; ++idx)</p>
<p>&nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;int currentN = nMinusTwo + nMinusOne;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;nMinusTwo = nMinusOne;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;nMinusOne = currentN;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;return nMinusOne;</p>
<p>}</p>
<p>(Your recursive version indeed uses no dynamic programming and that&#39;s the point of the article; but people may be confused after seeing the second which does have it)</p>
<div class="post">[<em>It&#39;s a cache in the sense that any variable can be viewed as a cache. (&quot;I&#39;m caching the &#39;largest value seen in elements 0 through i&#39;.&quot;) The value is immediately consumed by the next iteration, so it&#39;s really just an accumulator. Dynamic programming usually means employing a general-purpose cache rather than an accumulator.<br /> <code>int f(int n) {<br /> &nbsp; &nbsp; cache[0] = cache[1] = 1; <br /> &nbsp; &nbsp; for (int idx = 2; idx &lt;= n; ++idx) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; cache[idx] = cache[idx - 2] + cache[idx - 1];<br /> &nbsp; &nbsp; }<br /> &nbsp;&nbsp; return cache[n]; }</code> -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116533">
				<div id="div-comment-1116533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joker_vD</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116533">
			March 31, 2014 at 2:39 pm</a>		</div>

		<p>Wait. You&#39;re just numerically solving an initial-boundary value problem for the one-dimensional heat equation, aren&#39;t you? Or am I just seeing things at 2 AM?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-gregm even thread-even depth-1" id="comment-1116543">
				<div id="div-comment-1116543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/GregM' rel='external nofollow' class='url'>GregM</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116543">
			March 31, 2014 at 5:23 pm</a>		</div>

		<p>&quot;To my shame, this solution was rated second after the one that simply printed 1957231.&quot;</p>
<p>I would not have rated it second to that, but I would have rated it second to 1978 * (1978 + 1) / 2, assuming that the assignment was in fact &quot;calculate the answer to&quot; and not simply &quot;print the answer to&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-rat odd alt thread-odd thread-alt depth-1" id="comment-1116503">
				<div id="div-comment-1116503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/hacksoncode' rel='external nofollow' class='url'>hacksoncode</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116503">
			March 31, 2014 at 11:48 am</a>		</div>

		<p>@Anon: This question is exactly analogous to &quot;People tell me I should lift weights, but what relevance does this have, specifically, to my career?&quot;. </p>
<p>The reason you solve problems like this is that mental exercise builds mental muscles just like physical exercise builds physical muscles. </p>
<p>You&#39;re not going to find yourself needing to lift a barbell in (nearly) any career, either. But you will need to do *analogous* things if you have a career where upper-body strength is important. Additionally, it will improve your general physical fitness, which will have beneficial effects on your overall well-being. </p>
<p>Programming is a career where this kind of mental strength is extremely useful, if not actually absolutely vital. And it will improve your general mental fitness, which will have beneficial effects on your overall well-being. </p>
<p>This problem is probably more complicated (mathematically) than most you will encounter in day-to-day programming, this is true. But you want those problems you do encounter to be *easy* for you to solve, not a huge struggle. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116553">
				<div id="div-comment-1116553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BOFH</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116553">
			March 31, 2014 at 8:12 pm</a>		</div>

		<p>Either way, it&#39;s just a oneliner:</p>
<p>perl -le &quot;$i += $_ and print $i for 1 .. 1978&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116563">
				<div id="div-comment-1116563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Drak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116563">
			March 31, 2014 at 10:23 pm</a>		</div>

		<p>@BOFH:</p>
<p>And now in as may high-level programming languages as possible&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn even thread-even depth-1" id="comment-1116573">
				<div id="div-comment-1116573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116573">
			April 1, 2014 at 12:41 am</a>		</div>

		<p>@GregM: you are right, now I remember that the actual prize-winner did exactly as you said, writeln(1978*(1978+1)/2).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1116583">
				<div id="div-comment-1116583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116583">
			April 1, 2014 at 4:13 am</a>		</div>

		<p>I would have thought that merely printing &quot;1957231&quot; should be disqualified for a) the inefficiency in having the programmer calculate the result instead of the computer and/or b) not including the algorithm used to calculate the result as part of the submission. (I would accept a solution that moved the computation from the executable to the compiler or optimiser.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116593">
				<div id="div-comment-1116593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrei</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116593">
			April 1, 2014 at 4:14 am</a>		</div>

		<p>Finally, one that is correctly rendered using Internet Explorer, but not using Chrome</p>
<div class="post">[<em>Looks fine to me aside from Chrome&#39;s problem with U+27E8 and U+27E9. Maybe your window isn&#39;t wide enough. Let me see if I can try to fix that. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1116653">
				<div id="div-comment-1116653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116653">
			April 1, 2014 at 10:26 am</a>		</div>

		<p>This article should be re-named &quot;The dangers of buffering up posted messages and then reposting them later&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1116673">
				<div id="div-comment-1116673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mark</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116673">
			April 1, 2014 at 11:56 am</a>		</div>

		<p>alegr1: itym articles</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alexcohn odd alt thread-odd thread-alt depth-1" id="comment-1116713">
				<div id="div-comment-1116713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Alex+Cohn' rel='external nofollow' class='url'>Alex Cohn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1116713">
			April 1, 2014 at 9:26 pm</a>		</div>

		<p>Chrome fixed, many thanks from my Android device!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1117643">
				<div id="div-comment-1117643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Rahul Ramadas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20140331-00/?p=1363#comment-1117643">
			April 6, 2014 at 7:06 pm</a>		</div>

		<p>This is still dynamic programming. You are computing values in a table and updating it (as a function of pre-existing values in the table) and arriving at the answer: dynamic programming. You did it bottom-up instead of top-down with memoization, that&#39;s all.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

