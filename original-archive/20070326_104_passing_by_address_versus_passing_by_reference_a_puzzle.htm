<html>
<head>
<title>Passing by address versus passing by reference, a puzzle</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Passing by address versus passing by reference, a puzzle</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>March 26, 2007 / year-entry #105</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>29</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Commenter Mike Petry asked via the Suggestion Box: Why can you dereference a COM interface pointer and pass it to a function with a Com interface reference. The call. OutputDebugString(_T("IntfByRef::Execute - Begin\n")); BadBoy badone; CComPtr<IDoer> Doer; Doer.CoCreateInstance(CLSID_Doer, NULL, CLSCTX_INPROC_SERVER); // created a raw pointer - maybe the // smart pointer was effecting it some how....</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
<a HREF="http://blogs.msdn.com/oldnewthing/pages/407234.aspx#410239">
Commenter Mike Petry asked</a> via the Suggestion Box:
</p>
<blockquote CLASS=q>
<p>
Why can you dereference a COM interface pointer and pass it
to a function with a Com interface reference.
</p>
<p>
The call.
</p>
<pre>
OutputDebugString(_T("IntfByRef::Execute - Begin\n"));
BadBoy badone;
CComPtr&lt;IDoer&gt; Doer;
Doer.CoCreateInstance(CLSID_Doer, NULL, CLSCTX_INPROC_SERVER);

// created a raw pointer - maybe the
// smart pointer was effecting it some how.
IDoer* Doer2;
Doer.CopyTo(&amp;Doer2);

badone.stupid_method(*Doer2);
Doer2-&gt;Release();
// no still works.
</pre>
<p>
The function called.
</p>
<pre>
void stupid_method(IDoer&amp; IDoerRef)
{
 IDoerRef.Do();
 CComQIPtr&lt;IDispatch&gt; WatchIt(&amp;IDoerRef);

 if( WatchIt )
  OutputDebugString(_T("QI the address of the ")
                    _T("ref works - this is weird\n"));
 else
  OutputDebugString(_T("At least trying to QI the ")
                    _T("address of the ref fails\n"));
}
</pre>
<p>
I found some code written like this during a code review.
It is wrong but it seems to work.
</p>
</blockquote>
<p>
You already know the answer to this question.
You merely got distracted by the use of a COM interface.
Let me rephrase the question, using an abstract C++ class
instead of a COM interface.
(The virtualness isn't important to the discussion.)
Given this code:
</p>
<pre>
class Doer {
 public: virtual void Do() = 0;
};

void caller(Doer *p)
{
 stupid_method(*p);
}

void stupid_method(Doer&amp; ref)
{
 ref.Do();
}
</pre>
<p>
How is this different from the pointer version?
</p>
<pre>
void caller2(Doer *p)
{
 stupid_method2(p);
}

void stupid_method2(Doer *p)
{
 p-&gt;Do();
}
</pre>
<p>
The answer:
From the compiler's point of view, it's the same.
I could prove this by going into what references mean,
but you'd just find that boring,
but instead I'll show you the generated code.
First, the version that passes by reference:
</p>
<pre>
; void caller(Doer *p) { stupid_method(*p); }

  00000 55               push    ebp
  00001 8b ec            mov     ebp, esp
  00003 ff 75 08         push    DWORD PTR _p$[ebp]
  00006 e8 00 00 00 00   call    stupid_method
  0000b 5d               pop     ebp
  0000c c2 04 00         ret     4

; void stupid_method(Doer& ref) { ref.Do(); }

  00000 55               push    ebp
  00001 8b ec            mov     ebp, esp
  00003 8b 4d 08         mov     ecx, DWORD PTR _ref$[ebp]
  00006 8b 01            mov     eax, DWORD PTR [ecx]
  00008 ff 10            call    DWORD PTR [eax]
  0000a 5d               pop     ebp
  0000b c2 04 00         ret     4
</pre>
<p>
Now the version that passes by address:
</p>
<pre>
; void caller2(Doer *p) { stupid_method2(p); }

  00000 55               push    ebp
  00001 8b ec            mov     ebp, esp
  00003 ff 75 08         push    DWORD PTR _p$[ebp]
  00006 e8 00 00 00 00   call    stupid_method2
  0000b 5d               pop     ebp
  0000c c2 04 00         ret     4

; void stupid_method2(Doer *p) { p->Do(); }

  00000 55               push    ebp
  00001 8b ec            mov     ebp, esp
  00003 8b 4d 08         mov     ecx, DWORD PTR _p$[ebp]
  00006 8b 01            mov     eax, DWORD PTR [ecx]
  00008 ff 10            call    DWORD PTR [eax]
  0000a 5d               pop     ebp
  0000b c2 04 00         ret     4
</pre>
<p>
Notice that the code generation is identical.
</p>
<p>
If you're still baffled, go ask your local C++ expert.
</p>
<p>
Mind you, dereferencing an abstract object is highly unusual
and will probably cause the people who read your code to
scratch their heads, but it is nevertheless technically legal,
in the same way it is technically legal to give a function
that deletes an item the name <code>add_item</code>.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (29)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-485683">
				<div id="div-comment-485683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stewart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485683">
			March 26, 2007 at 10:26 am</a>		</div>

		<p>I use exactly this technique with C++ abstract classes all the time. This is because, to me and my team at least, passing by reference in this way does not imply a transfer of ownership, whereas passing by pointer typically does. This leaves the reader in no doubt that the method call will not delete the object. This is reinforced by the fact that &quot;delete &amp;ref&quot; just looks wrong, so hopefully no-one would do it.</p>
<p>I would never do it with COM interfaces though, although the same logic could be used.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-485713">
				<div id="div-comment-485713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485713">
			March 26, 2007 at 12:00 pm</a>		</div>

		<p>To Stewart:</p>
<p>Transferring ownership using a &quot;raw&quot; pointer is normally a bug; to correctly transfer ownership, pass a &quot;smart pointer object&quot;.</p>
<p>To me, the decision between pointer and reference should be based on the question whether NULL should be able to be passed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-485723">
				<div id="div-comment-485723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485723">
			March 26, 2007 at 12:19 pm</a>		</div>

		<p>I&#8217;ve argued with a number of people (including instructors) who somehow think that references are not pointers but rather just introduce another name for an object. &nbsp;:(</p>
<p>Meanwhile, even though this produces exactly the same code in both cases (here and in probably every other implementation), I believe it&#8217;s technically not guaranteed to work in C++ if the pointer is null. &nbsp;(and I don&#8217;t just mean this particular example&#8230; &nbsp;If stupid_method did not even touch its arguments, this would still be true.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-485743">
				<div id="div-comment-485743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Thomas</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485743">
			March 26, 2007 at 12:42 pm</a>		</div>

		<p>My argument is not just technical.</p>
<p>Using a pointer signals to the humnan reader that NULL may be passed. Using a reference signals her that NULL is not going to be passed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-485773">
				<div id="div-comment-485773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KristofU</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485773">
			March 26, 2007 at 2:06 pm</a>		</div>

		<p>I don&#8217;t think dereferencing an abstract object is weird. Polymorphism works on pointers and on references. So why should this be a problem?</p>
<p>It&#8217;s just that the C++ syntax forces you to write &nbsp;&#8216;*pPointer&#8217; to pass the object as a reference.</p>
<p>References are just a way to introduce object semantics instead of value semantics, without using a pointer.</p>
<p>And yes you can also do this on null pointers, which of course can result in disaster.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-485793">
				<div id="div-comment-485793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SamK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485793">
			March 26, 2007 at 3:51 pm</a>		</div>

		<p>I&#8217;ll also put my vote in the &quot;not weird&quot; camp. &nbsp;I think that using references in this context is often semantically superior, mostly due to the reasons already cited.</p>
<p>I think Ray Trent&#8217;s comments, about the functions &quot;contract&quot; with the caller, are key. &nbsp;Putting a burden on the caller, explicitly, is very useful.</p>
<p>In complex environments, it may be hard to tell if a pointer has already been vetted. &nbsp;This is so because there&#8217;s no way to contractually communicate to a callee that a pointer has been vetted. &nbsp;This typically leads to duplicate checks for NULL, etc., throughout a call chain. &nbsp;If using references, the caller is contractually obligated to provide valid data. &nbsp;This removes the need for pointer checks in the callee.</p>
<p>I&#8217;m also a big fan of explicit ownership/responsibility in function contracts. &nbsp;References, like the &quot;const&quot; keyword, tighten up the contract, and I use both judiciously.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-485733">
				<div id="div-comment-485733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sebastian Redl</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485733">
			March 26, 2007 at 12:32 pm</a>		</div>

		<p>&gt; I&#8217;ve argued with a number of people (including instructors) who somehow think that references are not pointers but rather just introduce another name for an object.</p>
<p>Conceptually, these people are right. Technically, of course, references are always implemented as pointers.</p>
<p>&gt; I believe it&#8217;s technically not guaranteed to work in C++ if the pointer is null.</p>
<p>Indeed.</p>
<p>int *p = 0;</p>
<p>int &amp;r = *p;</p>
<p>This is undefined behaviour according to the standard. The case is even explicitly mentioned somewhere.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-485763">
				<div id="div-comment-485763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485763">
			March 26, 2007 at 1:27 pm</a>		</div>

		<p>To amplify that last slightly: Using a reference signals that, absent a compiler bug, stack overflow, etc., NULL *cannot* be passed.</p>
<p>In fact, it also signals that (absent those conditions again) the reference will always &quot;point to&quot; a *valid* object (at the time of the call). </p>
<p>Pointers have none of those guarantees, and thus are easier to misuse, but passing NULL is a valuable signal to a function that an object is not applicable or invalid. Of course you could always override the function with one fewer parameters and have the two functions call a private pointer-taking function, and at least get a guarantee that the pointer will *either* be NULL or valid).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-485873">
				<div id="div-comment-485873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.levicki.net/' rel='external nofollow' class='url'>Igor</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485873">
			March 26, 2007 at 9:03 pm</a>		</div>

		<p>^ Jesus&#8230; what people do and get paid, are there no quality standards today?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-485933">
				<div id="div-comment-485933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anony Moose</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485933">
			March 26, 2007 at 10:29 pm</a>		</div>

		<p>I agree. Anyone who can&#8217;t tell the difference between a &quot;null&quot; reference and a reference to an object located at address zero has no standards at all. &nbsp;;)</p>
<p>&quot;Null reference&quot; and &quot;pointer to object at address zero&quot; are not synonyms, and there are machines where an object at address 0 is valid and usable.</p>
<p>But the typical use of that idea in code designed for an x86 machine and used to indicate a reference to an object that the developer knows is not valid is still a really bad idea.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-485803">
				<div id="div-comment-485803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">GregM</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485803">
			March 26, 2007 at 4:38 pm</a>		</div>

		<p>Yeah, references should NEVER be NULL. &nbsp;I scream inside each time I see the code like this in one of the components we use:</p>
<p>extern void DoStuff(int a, int b, int c = 0, object &amp;r = *(object *)NULL);</p>
<p>No, I am not kidding. &nbsp;They apparently REALLY wanted to add reference parameters to functions which already had optional parameters. &nbsp;This then requires that they check the address of the parameter later to see if it&#8217;s NULL.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-485973">
				<div id="div-comment-485973" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485973">
			March 27, 2007 at 1:01 am</a>		</div>

		<p>&quot;Conceptually, these people are right.&quot;</p>
<p>It may be a valid way to think about references in some contexts, but I think it&#8217;s dangerous. &nbsp;I could easily see it biting someone who doesn&#8217;t completely understand object lifetimes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-485983">
				<div id="div-comment-485983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael Fitzpatrick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-485983">
			March 27, 2007 at 1:02 am</a>		</div>

		<p>You forgot one very important and subtle difference:</p>
<p>void stupid_method2(Doer * const p)</p>
<p>{</p>
<p>p-&gt;Do();</p>
<p>}</p>
<p>Using a ref denies the called routine from modifying the pointer</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-486023">
				<div id="div-comment-486023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Csaboka</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486023">
			March 27, 2007 at 3:55 am</a>		</div>

		<p>Anony Moose:</p>
<p>Bjarne Stroustrup doesn&#8217;t agree with you in his FAQ (<a rel="nofollow" target="_new" href="http://www.research.att.com/~bs/bs_faq2.html#null" rel="nofollow">http://www.research.att.com/~bs/bs_faq2.html#null</a>)</p>
<p>&quot;Should I use NULL or 0?</p>
<p>In C++, the definition of NULL is 0, so there is only an aesthetic difference.&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-486043">
				<div id="div-comment-486043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486043">
			March 27, 2007 at 4:22 am</a>		</div>

		<p>josh:</p>
<p>&quot;It may be a valid way to think about references in some contexts, but I think it&#8217;s dangerous. &nbsp;I could easily see it biting someone who doesn&#8217;t completely understand object lifetimes.&quot;</p>
<p>I disagree. Dangling pointer vs. dangling reference &lt;=&gt; potato vs. potato. Are you saying that someone will think that holding a reference will make underlying object alive? Well, that someone must know it&#8217;s craft. No excuse for that in my book ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-486093">
				<div id="div-comment-486093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stewart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486093">
			March 27, 2007 at 10:20 am</a>		</div>

		<p>To Thomas,</p>
<p>Good point, and in an ideal world one would use a smart pointer for this. Sadly, the question of which is the hard part.</p>
<p>Of the boost ones, only boost::shared_ptr allows transfer of ownership, and thats a big fat smart pointer for simple cases.</p>
<p>Of the SCL ones, std::auto_ptr would be perfect if it wasn&#8217;t for the fact that it is useful for very little else. I have seen junior engineers copy its usage because it was used in this case and get it VERY wrong. Simply having it in the code can be dangerous if the uninitiated (most C++ programmers sadly) copy it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-486013">
				<div id="div-comment-486013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">IMil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486013">
			March 27, 2007 at 3:54 am</a>		</div>

		<p>To Michael Fitzpatrick:</p>
<p>The same const modifier may be applied to pointer. There is indeed a subtle and somewhat confusing difference. If you write</p>
<p>void ptr_method(const class SomeClass* c)</p>
<p>you may not modify the object:</p>
<p>c-&gt;ChangeMe(); //illegal</p>
<p>c = someOtherPointer; //OK</p>
<p>But</p>
<p>void ptr_method(class SomeClass* const c)</p>
<p>means that you may not modify the pointer:</p>
<p>c-&gt;ChangeMe(); //OK</p>
<p>c = someOtherPointer; //illegal</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-486033">
				<div id="div-comment-486033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Goran</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486033">
			March 27, 2007 at 4:10 am</a>		</div>

		<p>+1 in &quot;not weird&quot; camp.</p>
<p>I&#8217;d say that &quot;Dereferencing an abstract object&quot; question shouldn&#8217;t even be asked. If it&#8217;s abstract, and *p was assigned to an actual object, a constructor must be called, at which point compiler will bark at abstract members. If *p goes to a reference, it shouldn&#8217;t matter, to a well-versed C++-er, if it&#8217;s abstract.</p>
<p>Are you underestimating your audience, huh? I am collectively hurt! ;-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-486253">
				<div id="div-comment-486253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486253">
			March 27, 2007 at 1:10 pm</a>		</div>

		<p>The token &quot;0&quot; is null, but it&#8217;s not necessarily a representation of address zero. &nbsp;I don&#8217;t think the language even defines how absolute address values relate to pointers at all. &nbsp;I&#8217;m not sure why Anony Moose is talking about address zero though.</p>
<p>&quot;Dangling pointer vs. dangling reference &lt;=&gt; potato vs. potato.&quot;</p>
<p>Yes, exactly. &nbsp;If you thought a reference is just another name for the object, you may not see that.</p>
<p>&quot;Are you saying that someone will think that holding a reference will make underlying object alive?&quot;</p>
<p>If they need a crutch to understand references because they don&#8217;t get pointers, I would not be surprised to see that happening.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-486063">
				<div id="div-comment-486063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486063">
			March 27, 2007 at 9:27 am</a>		</div>

		<p>Csaboka: &nbsp;It&#8217;s not just Bjarne that thinks that way. &nbsp;The C virtual machine (yes, there is one, it&#8217;s just *very* similar to the underlying hardware most of the time) specifies that an all-bits-zero pointer is equivalent to NULL. &nbsp;NULL in C is *ALWAYS* zero.</p>
<p>See the comp.lang.c FAQ, questions 5.5 and 5.13 (and others in section 5):</p>
<p><a rel="nofollow" target="_new" href="http://c-faq.com/null/machnon0.html" rel="nofollow">http://c-faq.com/null/machnon0.html</a></p>
<p><a rel="nofollow" target="_new" href="http://c-faq.com/null/varieties.html" rel="nofollow">http://c-faq.com/null/varieties.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-486303">
				<div id="div-comment-486303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486303">
			March 27, 2007 at 2:57 pm</a>		</div>

		<p>A &quot;null pointer constant&quot; is any constant integral expression that evaluates to 0. Any null pointer constant when converted (except via reinterpret_cast) to a pointer type yields the &quot;null pointer value&quot; of that type (i.e. what most people usually mean when they say NULL).</p>
<p>What Anony Moose is talking about is the object representation of the pointer (which roughly means what address the pointer points to). The null pointer value isn&#8217;t guaranteed to point to address 0. So:</p>
<p>reinterpret_cast&lt;T*&gt;(0)</p>
<p>can do anything, but:</p>
<p>static_cast&lt;T*&gt;(0)</p>
<p>is guaranteed to evaluate to the null pointer value of type T* (and yes, the null pointer value for each pointer type isn&#8217;t guaranteed to point to the same address either).</p>
<p>Note: before you tell me I&#8217;m wrong because the standard explicitly says reinterpret_cast&lt;T*&gt;(0) results in the null pointer value, that was an obvious defect: <a rel="nofollow" target="_new" href="http://www.open-std.org/JTC1/sc22/wg21/docs/cwg_defects.html#463" rel="nofollow">http://www.open-std.org/JTC1/sc22/wg21/docs/cwg_defects.html#463</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-486463">
				<div id="div-comment-486463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486463">
			March 27, 2007 at 9:56 pm</a>		</div>

		<p>Tuesday, March 27, 2007 9:27 AM by BryanK </p>
<p>&gt; The C virtual machine (yes, there is one,</p>
<p>&gt; it&#8217;s just *very* similar to the underlying</p>
<p>&gt; hardware most of the time) specifies that an</p>
<p>&gt; all-bits-zero pointer is equivalent to NULL.</p>
<p>&gt; NULL in C is *ALWAYS* zero.</p>
<p>Wrong. &nbsp;BryanK, see AND READ the comp.lang.c FAQ, questions 5.5 and 5.13, particularly 5.13:</p>
<p><a rel="nofollow" target="_new" href="http://c-faq.com/null/machnon0.html" rel="nofollow">http://c-faq.com/null/machnon0.html</a></p>
<p><a rel="nofollow" target="_new" href="http://c-faq.com/null/varieties.html" rel="nofollow">http://c-faq.com/null/varieties.html</a></p>
<p>0 in a source program&#8217;s syntax turns into a null pointer constant at compile time, which can turn into null pointers as needed at compile time. &nbsp;The representations of null pointers in the execution environment don&#8217;t have to be all-bits-zero.</p>
<p>In fact some computer architectures (e.g. Intel) can provide hardware assistance to debug some fraction of unintended attempts to dereference null pointers (e.g. a scalar object of length 2 or more bytes) if a null pointer is represented by all-bits-one.</p>
<p>For practical purposes this fight was lost long ago, because only antisocial weirdo thermonuclear geeks were willing to learn that a 0 in syntax didn&#8217;t have to be all-bits-zero at execution time.</p>
<p>By the way the title of this thread would have been better as &quot;Passing by pointer versus passing by reference, a puzzle&quot;. &nbsp;For practical purposes both pointers and references are &quot;usually&quot; addresses, but from the language&#8217;s point of view either or both could be represented differently.</p>
<p>Another difference also arises from a choice to use a pointer vs. a reference. &nbsp;In some cases use of a reference will automatically convert some argument to a temporary and use the temporary, but use of a pointer won&#8217;t.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-486563">
				<div id="div-comment-486563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486563">
			March 28, 2007 at 8:24 am</a>		</div>

		<p>Aw, crap. &nbsp;s/whose values is/whose value is/ &#8212; I hate it when I rewrite a sentence but don&#8217;t fix it properly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-486553">
				<div id="div-comment-486553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486553">
			March 28, 2007 at 8:20 am</a>		</div>

		<p>You probably got thrown off by the &quot;all-bits-zero&quot; part, and yes, that was poorly worded. &nbsp;I should have said &quot;a pointer whose values is the constant zero is equivalent to NULL.&quot;</p>
<p>The rest is right though &#8212; NULL in C (and by extension, C++) is *ALWAYS* zero. &nbsp;A NULL pointer will always compare equal to the constant zero (because in comparison context, the compiler can tell what kind of pointer it needs to use, so it can generate code that uses a nonzero bit pattern if it needs to), and assigning the constant value zero to a pointer will set its bits to whatever the real hardware uses for null pointers.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-486963">
				<div id="div-comment-486963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-486963">
			March 28, 2007 at 11:35 pm</a>		</div>

		<p>Wednesday, March 28, 2007 8:20 AM by BryanK </p>
<p>&gt; I should have said &quot;a pointer whose values is</p>
<p>&gt; the constant zero is equivalent to NULL.&quot;</p>
<p>The C and C++ standards only make that guarantee for certain specified forms and only when they&#8217;re known to be constant at compile time.</p>
<p>For example:</p>
<p>int *pf() = NULL; &nbsp;// OK</p>
<p>int *pf() = 0; &nbsp;// OK</p>
<p>int *pf() = 3.5 &#8211; 3.5; &nbsp;// compilers can decide</p>
<p>int *pf() = (void*) 0; &nbsp;// OK</p>
<p>int *pf() = (void*)(void*) 0; &nbsp;// prohibited</p>
<p>&gt; NULL in C (and by extension, C++) is *ALWAYS* zero.</p>
<p>If you mean at execution time, it is *NOT ALWAYS* (except when speaking practically as mentioned earlier, because of so many broken programs that have to be catered to). &nbsp;If you mean at compile time, then NULL is always something that the implementor knew would be equivalent to a compile-time zero of some sort, but that says nothing about its execution-time representation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-487033">
				<div id="div-comment-487033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-487033">
			March 29, 2007 at 8:19 am</a>		</div>

		<p>No, I didn&#8217;t mean at execution time, that was basically what I was trying to say in my previous post.</p>
<p>A pointer variable which is currently holding a null pointer will always compare equal to an unadorned constant zero, because the constant zero is interpreted in a pointer context (because it&#8217;s being compared to a pointer). &nbsp;But the actual bits of the pointer variable may not all be zero (if you print out an expression like *((int *)(&amp;ptr)), or maybe even (int)ptr, you may not get zero).</p>
<p>So in that sense, you&#8217;re right, it&#8217;s not &quot;always&quot; zero. &nbsp;But if the programmer compares the pointer-variable-containing-a-null-pointer to a constant zero, the comparison will always succeed.</p>
<p>(I&#8217;m not sure why the &quot;(void *)(void *) 0&quot; expression is prohibited: Is it just because you&#8217;re doing a double-cast to the same type?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-487283">
				<div id="div-comment-487283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-487283">
			March 29, 2007 at 10:25 pm</a>		</div>

		<p>Thursday, March 29, 2007 8:19 AM by BryanK</p>
<p>&gt; (I&#8217;m not sure why the &quot;(void *)(void *) 0&quot;</p>
<p>&gt; expression is prohibited: Is it just because</p>
<p>&gt; you&#8217;re doing a double-cast to the same type?)</p>
<p>The redundant cast is perfectly legal. &nbsp;The standard doesn&#8217;t even mention the redundancy, there&#8217;s no problem with that.</p>
<p>The result is a value which is a null pointer, which is a constant, and which has type (void*). &nbsp;But that isn&#8217;t enough for the hypothetical usage which I put it to. &nbsp;My examples require null pointer constants. &nbsp;A null pointer constant has some magic features besides simply being a null pointer and constant.</p>
<p>For comparison again:</p>
<p>int *pi = (void*)(void*) 0; &nbsp;// legal in C</p>
<p>int *pf() = (void*)(void*) 0; &nbsp;// illegal in C</p>
<p>// (both are illegal in C++, I think)</p>
<p>Around 10 years ago I posted in comp.std.c about (void*)(void*) 0 not being a null pointer. &nbsp;dmr posted a followup saying he was planning to write something about nasal daemons, but he double-checked the standard before writing and he agreed.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-487413">
				<div id="div-comment-487413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-487413">
			March 30, 2007 at 6:17 am</a>		</div>

		<p>Friday, March 30, 2007 4:49 AM by Norman Diamond</p>
<blockquote><p>
  Idiot.
</p></blockquote>
<p>You know you&#8217;re mad when you start talking to yourself. &nbsp;Well let me assure you, you were right to be mad.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-487383">
				<div id="div-comment-487383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20070326-00/?p=27503#comment-487383">
			March 30, 2007 at 4:49 am</a>		</div>

		<p>Thursday, March 29, 2007 10:25 PM by Norman Diamond</p>
<p>&gt; Around 10 years ago I posted in comp.std.c</p>
<p>&gt; about (void*)(void*) 0 not being a null</p>
<p>&gt; pointer.</p>
<p>Idiot. &nbsp;You just finished explaining the difference between a value which only happens to be a null pointer and a constant, and a value which has the additional magic property of being a null pointer constant. &nbsp;And then here you screwed it up already.</p>
<p>Now get this. &nbsp;(void*)(void*) 0 IS a _null_pointer_. &nbsp;And it&#8217;s constant. &nbsp;What it isn&#8217;t, is that it isn&#8217;t a _null_pointer_constant_. &nbsp;That&#8217;s why dmr agreed with you.</p>
<p>Now we can only wonder why no one else tore you to shreds on this before I did. &nbsp;You sure deserve it.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

