<html>
<head>
<title>Appearing to succeed is a valid form of undefined behavior, but it's still undefined</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Appearing to succeed is a valid form of undefined behavior, but it&#8217;s still undefined</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>September 29, 2011 / year-entry #233</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>35</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">A customer requested a clarification on the MSDN documentation for the HeapFree function. The MSDN documentation says that if the lpMem parameter is NULL, then the behavior is undefined. Is this true? As explicitly stated in MSDN, the behavior is undefined. Observe that the annotation on the lpMem parameter is __in, which means that the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
A customer requested a clarification on
<a HREF="http://msdn.microsoft.com/library/aa366701.aspx">
the MSDN documentation
for the <code>HeapFree</code> function</a>.
</p>
<blockquote CLASS=q><p>
The MSDN documentation says that if the <code>lpMem</code>
parameter is <code>NULL</code>, then the behavior is undefined.
Is this true?
</p>
</blockquote>
<p>
As explicitly stated in MSDN, the behavior is undefined.
Observe that
<a HREF="http://msdn.microsoft.com/library/aa383701.aspx">
the annotation</a>
on the <code>lpMem</code>
parameter is <code>__in</code>,
which means that the parameter must be a non-<code>NULL</code>
value provided by the caller.
(If <code>NULL</code> were permitted, the annotation would have
been <code>__in_opt</code>.)
</p>
<p>
Undefined behavior means that <i>anything can happen</i>.
The program might crash immediately.
It might crash five minutes later.
It might send email to your boss saying that you screwed up
and then read you Vogon poetry.
Or maybe not.
</p>
<p>
MSDN says don't do it, so don't do it.
</p>
<p>
The customer explained why they were interested in knowing
more information about undefined behavior:
</p>
<blockquote CLASS=q><p>
We were interested because there is a mismatch between
the semantics of a function we are implementing
(where <code>NULL</code> is valid and ignored)
and the function <code>HeapFree</code> we are using
as the implementation.
It looks like Windows Vista returns <code>TRUE</code> if
you pass <code>NULL</code>.
</p>
</blockquote>
<p>
If there is a mismatch in semantics
between the function you are implementing
and the function you are calling,
it is your responsibility as the programmer to bridge
the gap.
The customer didn't say what function they were implementing,
but I'm guessing it was something like
<code>operator delete</code>.
Since your function accepts <code>NULL</code> but
<code>HeapFree</code> doesn't,
it is your responsibility to filter out <code>NULL</code> parameters.
</p>
<pre>
void operator delete(void* ptr) throw ()
{
 <font COLOR=blue>if (ptr != NULL)</font>
  HeapFree(CustomHeap, 0, ptr);
}
</pre>
<p>
This concept goes by the fancy name of
<a HREF="http://en.wikipedia.org/wiki/Adapter_pattern">
the Adapter Pattern</a>.
The less fancy name is
<a HREF="http://en.wikipedia.org/wiki/Wrapper_function">
wrapper function</a>.
</p>
<p>
And the value returned by <code>HeapFree</code> on Windows Vista
is irrelevant.
Pretending to succeed is a valid form of undefined behavior,
because
<i>anything</i> qualifies as undefined behavior.
</p>
<p>
(Of course,
you can't assume that returning <code>TRUE</code> will always be
the result of triggering undefined behavior.
After all, if you could rely on it, then it wouldn't be undefined any
more!)</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (35)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-937853">
				<div id="div-comment-937853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937853">
			September 29, 2011 at 7:34 am</a>		</div>

		<p>Uggh, I really wish more people understood this concept properly. &nbsp;I don&#39;t know how often I see code that is undefined but happens to work and how hard it is to convince folks that they cannot rely on that.</p>
<p>My personal favorite is an intern who once said: &nbsp;&quot;Look, printf will malloc memory for me!&quot; &nbsp;Just because this code happened to not crash:</p>
<p>char *buffer</p>
<p>sprintf(buffer, &quot;%d&quot;, intValue);</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-937873">
				<div id="div-comment-937873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">woodswan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937873">
			September 29, 2011 at 8:14 am</a>		</div>

		<p>I can still remember my first time seeing the meaning of &quot;undefined behavior&quot; from the C programming manual, which impressed me so much.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-937883">
				<div id="div-comment-937883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937883">
			September 29, 2011 at 8:16 am</a>		</div>

		<p>@SimonRev: I know your pain.</p>
<p>Incidentally, the world is slowly moving to freeing NULL is a noop. There was a discussion on LKML about changing the code inside kfree from if (unlikely(p == NULL)) return ; to if (likely(p == NULL)) return ; (unlikely and likely are macros that generate compiler hints that generate CPU hints).</p>
<p>Definitely continue to document do not pass null to this function. It&#39;s no longer expected that is the case.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-937893">
				<div id="div-comment-937893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tobi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937893">
			September 29, 2011 at 8:21 am</a>		</div>

		<p>People don&#39;t understand contracts in general.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-937903">
				<div id="div-comment-937903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937903">
			September 29, 2011 at 8:33 am</a>		</div>

		<p>Why does HeapFree not just define its semantics so that passing it a null pointer results in a no-op? &nbsp;Surely the performance cost &quot;if(lpMem == NULL) return TRUE;&quot; is negligible compared to the cost of actually deallocating the memory back to the heap, as well as the cost of checking if (dwFlags &amp; HEAP_NO_SERIALIZE) followed by optionally locking a critical section.</p>
<p>In fact, stepping through the disassembly for HeapFree in the VS 2008 runtime on Windows 7, it does in fact check if(lpMem == NULL). &nbsp;Surely people have already written and shipped software that relies on that fact. &nbsp;If you take it out for performance, you&#39;re just going to have to put it back in in a compatibility shim, so why not just make it part of the contract? &nbsp;free(), operator delete, and LocalFree() all do (though GlobalFree() is oddly silent on this point).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-937913">
				<div id="div-comment-937913" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937913">
			September 29, 2011 at 8:37 am</a>		</div>

		<p>I&#39;d prefer to say that &quot;[t]his concept goes by the fancy name of Common Sense.&quot;</p>
<p>(On the other hand, I do get driven crazy by people checking for a null pointer before a delete since delete a null pointer is defined behavior.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-937923">
				<div id="div-comment-937923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937923">
			September 29, 2011 at 8:47 am</a>		</div>

		<p>I guess the real question is why is this undefined behavior? &nbsp;If there is special handling for NULL, why not just document it? &nbsp;If there is not special handling for NULL, why specifically call it out? &nbsp;Wouldn&#39;t it just fail with the same error code as any other invalid pointer?</p>
<div class="post">[<i>It does fail with the same error code as any other invalid pointer: Passing an invalid pointer invokes undefined behavior! -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-937933">
				<div id="div-comment-937933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937933">
			September 29, 2011 at 9:02 am</a>		</div>

		<p>Now, I do agree the previous posters &#8212; free(NULL) is defined behavior, delete NULL is defined behavior as well, so it is non-intuitive that HeapFree would not be. &nbsp;In particular Adam makes a compelling argument to update the documentation to reflect the actual behavior.</p>
<div class="post">[<i>Um, API documentation does not describe actual behavior. API documentation describes <span style="text-decoration:underline;">contractual</span> behavior. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-937953">
				<div id="div-comment-937953" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937953">
			September 29, 2011 at 10:13 am</a>		</div>

		<p>This is the common feature in the Computer sort of culture. There is no undocumented behavior, there is only undocumented feature. The road warrior should go and find all of them!!!!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-937983">
				<div id="div-comment-937983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kevin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937983">
			September 29, 2011 at 11:27 am</a>		</div>

		<blockquote><p>
  char *buffer</p>
<p>  sprintf(buffer, &quot;%d&quot;, intValue);
</p></blockquote>
<p>IIRC LLVM will recognize that this is undefined behavior, assume it&#39;s dead code, and optimize it to a no-op.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938003">
				<div id="div-comment-938003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">John</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938003">
			September 29, 2011 at 12:37 pm</a>		</div>

		<p>[It does fail with the same error code as any other invalid pointer: Passing an invalid pointer invokes undefined behavior! -Raymond]</p>
<p>I don&#39;t understand how returning a consistent error code is &quot;undefined behavior&quot;, but I digress. &nbsp;My point is that the documentation explicitly calls out NULL as invoking undefined behavior, when in reality ANY invalid pointer invokes undefined behavior. &nbsp;I understand NULL has a somewhat special status, but from the perspective of this particular contract NULL is not treated any differently from any other invalid pointer. &nbsp;I would prefer the documentation said something like &quot;Invalid pointers invoke undefined behavior&quot; rather than &quot;NULL invokes undefined behavior&quot;, though I suppose by the very nature of taking a pointer it is implied to be a valid pointer. &nbsp;Maybe I&#39;m just hanging on the semantics too much.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938013">
				<div id="div-comment-938013" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938013">
			September 29, 2011 at 12:38 pm</a>		</div>

		<blockquote><p>
  There may be consequences of changing the contract after it has been written. For example, people who detour the heap APIs (e.g., for diagnostic purposes) will implement the old contract, not the new one.
</p></blockquote>
<p>This implies another sort of contract, a &quot;meta-contract&quot;, about how the contract could change.</p>
<p>Here, @SimonRev is believing the meta-contract says you can always tighten the contract (turning undefined behavior into defined behavior). What you are saying implies the meta-contract says the contract is effectively set into stone (you can never turn undefined behavior into defined behavior, at least for this function). But is it really the case, or is it just catering to people who abuse the API? Is the &quot;meta-contract&quot; written down anywhere? If not, should it be?</p>
<p>Going too far into that direction would mean, for instance, that you can never add a new flag to a function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938023">
				<div id="div-comment-938023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cesar</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938023">
			September 29, 2011 at 12:41 pm</a>		</div>

		<p>@John: isn&#39;t NULL a valid null pointer? And even if it is not considered a valid pointer, you know people will still think of it differently (there are three kinds of pointers: valid, invalid, and null), so it is a good idea to always mention it explicitly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938033">
				<div id="div-comment-938033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938033">
			September 29, 2011 at 12:47 pm</a>		</div>

		<p>@Cesar: It is not always known at compile time whether or not NULL is a valid pointer. On some ancient systems, malloc() couldn&#39;t use NULL internally because the start of the heap might be NULL. GCC has a -fno-delete-null-pointer-checks for a reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938053">
				<div id="div-comment-938053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938053">
			September 29, 2011 at 1:15 pm</a>		</div>

		<p>@John: I think the reason it makes sense to point out NULL being undefined is because it is a very common mistake. While it is also true that passing invalid pointers is also undefined, it isn&#39;t as common of a mistake. The documentation isn&#39;t required to document all the undefined behavior of a function (Which I guess would be defined undefined behaviors?), but sometimes defining the most common mistakes can be helpful.</p>
<div class="post">[<i>Indeed. Because technically the documentation doesn&#39;t even need to say what happens when you pass NULL, because NULL is not a valid heap block and is therefore already an invalid parameter. Presumably somebody asked that the behavior of NULL be made explicit (because it is a common point of disagreement among emmory managers), so it was made explicit. On the other hand, memory managers are pretty much in agreement that it is a bad idea to pass a non-NULL pointer that does not represent a valid block, so that was never an issue. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938063">
				<div id="div-comment-938063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938063">
			September 29, 2011 at 1:18 pm</a>		</div>

		<p>@Joshua: No, NULL is defined by the language standard to be a macro that expands to &quot;an implementation-defined null pointer constant&quot;, which is not necessarily represented as all zero bits, and in C++, the integer 0 is required to be converted to a null pointer constant. &nbsp;On those esoteric systems where a null pointer is not represented by all zero bits, it&#39;s the compiler&#39;s job to translate between the integer 0 in source code (when being used as a pointer type) and the runtime null pointer representation.</p>
<p>As for systems where a null pointer is all zero bits and where address 0 can be potentially valid, those quite likely predate the ANSI C standard. &nbsp;Yes, GCC has an option for compiling code for them, but they&#39;re not standard C so all bets are off.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938073">
				<div id="div-comment-938073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938073">
			September 29, 2011 at 1:36 pm</a>		</div>

		<p>@Adam Rosenfield: Does MS-DOS 6 Predate ANSI C? I don&#39;t think so. In large memory model, NULL is a valid pointer to the interrupt vector table. Changing NULL to some non-zero value doesn&#39;t help here as all pointers are potentially valid (yes even FFFF:FFFF).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938083">
				<div id="div-comment-938083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mott555</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938083">
			September 29, 2011 at 1:43 pm</a>		</div>

		<p>Here&#39;s an idea for future versions of Windows. If you have functions with known &quot;undefined&quot; behavior and the caller passes in values that would cause undefined state/behavior, have it generate a random integer and cast it to a pointer of the return type, then return it. People will learn really quickly not to depend on undefined behavior.</p>
<div class="post">[<i>Who are these &quot;people&quot; you are trying to &quot;teach a lesson&quot;? Certainly not the customer, because the lesson the customer takes away is &quot;Don&#39;t upgrade to the next version of Windows. It breaks a lot of apps. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938093">
				<div id="div-comment-938093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938093">
			September 29, 2011 at 2:21 pm</a>		</div>

		<p>@Joshua: Fair point, but it just shows that MS-DOS 6 does not have an ANSI C-compliant implementation. &nbsp;C89 section 3.2.2.3 states that &quot;An integral constant expression with the value 0, or such an expression cast to type void * , is called a null pointer constant. [&#8230;] Such a pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.&quot;.</p>
<div class="post">[<i>It proves nothing, because the only way to generate such a &quot;valid NULL pointer&quot; is to invoke implementation-defined and/or undefined behavior. (malloc will never return a pointer to the interrupt table, and no C object can be allocated there, and dereferencing&nbsp;a NULL pointer results in undefined behavior.) In other words, in order to observe noncompliance, you must already be noncompliant. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938103">
				<div id="div-comment-938103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">thepaulpage</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938103">
			September 29, 2011 at 3:52 pm</a>		</div>

		<p>I enjoy Steve Yegge&#39;s analogy for undefined (of course it&#39;s long):</p>
<p><a rel="nofollow" target="_new" href="http://steve-yegge.blogspot.com/2008/12/programmers-view-of-universe-part-2.html" rel="nofollow">steve-yegge.blogspot.com/&#8230;/programmers-view-of-universe-part-2.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-joshuaganes even thread-even depth-1" id="comment-938113">
				<div id="div-comment-938113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Joshua+Ganes' rel='external nofollow' class='url'>Joshua Ganes</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938113">
			September 29, 2011 at 3:59 pm</a>		</div>

		<p>This is why I always pass the flags HEAP_NO_VOGON_POETRY, HEAP_NO_EMAIL, and HEAP_CROSS_YOUR_FINGERS when calling such a sensitive function.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938123">
				<div id="div-comment-938123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Deduplicator</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938123">
			September 29, 2011 at 4:32 pm</a>		</div>

		<p>@Raymond: Time for nitpicking:</p>
<p>3.14: &quot;object: region of data storage in the execution environment, the contents of which can represent values&quot;</p>
<p>So, if there is a &#39;region of data storage&#39; (Memory), which is part of &#39;the execution environment&#39; (Machine+Software), there IS most certainly a C object. And it obviously can represents &#39;values&#39; (Address of interrupt handler)</p>
<p>6.3.2.3 &quot;An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.&quot;</p>
<p>Well, I think we have our contradiction between any MS-DOS-Machine an the C standard right here.</p>
<p>But thats all realy academic and aside from language-lawyers, nobody should have to concern himself about that.</p>
<p>In modern Systems, there&#39;s virtual memory and enough address-space to make address 0 represent the null-pointer and blow up anyone trying to dereference it with a highly satisfying resounding boom.</p>
<p>@Joshua: Which header is that? ;-)</p>
<div class="post">[<i>The implementation does not include the interrupt table as part of its execution environment. Therefore 0 will never point to an object. If you manage to dereference 0, then the behavior is undefined. Undefined behavior includes &quot;accessing things that are not part of the execution environment.&quot; -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-937963">
				<div id="div-comment-937963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">SimonRev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-937963">
			September 29, 2011 at 10:27 am</a>		</div>

		<p>[Um, API documentation does not describe actual behavior. API documentation describes contractual behavior. -Raymond]</p>
<p>We know that Raymond, I don&#39;t think anyone here disagrees with that point. &nbsp;</p>
<p>Our point is that in this *specific* case the contractual behavior is odd (when compared to similar examples). &nbsp;Given that the actual behavior mimics the expected behavior, why not extend the contract to cover that common case &#8212; it brings the contractual behavior inline with the expected behavior and does require any changes to anyone&#39;s code.</p>
<p>I have no doubt that there are plenty of other examples of this phenomenon where everyone would have been lining up agreeing wholeheartedly with you.</p>
<div class="post">[<i>There may be consequences of changing the contract after it has been written. For example, people who detour the heap APIs (e.g., for diagnostic purposes) will implement the old contract, not the new one. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938163">
				<div id="div-comment-938163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian Boyd</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938163">
			September 29, 2011 at 7:58 pm</a>		</div>

		<p>Larry Osterman suggests also that passing NULL might format your hard-drive (<a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/larryosterman/archive/2011/02/11/the-case-of-the-inconsistent-right-shift-results.aspx" rel="nofollow">blogs.msdn.com/&#8230;/the-case-of-the-inconsistent-right-shift-results.aspx</a>)</p>
<p>Assuming you are running with administrative privileges.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938173">
				<div id="div-comment-938173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Silly</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938173">
			September 29, 2011 at 8:55 pm</a>		</div>

		<p>Quantum mechanics suggests that passing even a valid pointer as a limited user might result in a reformat your hard drive, though the chance is vanishly small.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938183">
				<div id="div-comment-938183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Klimax</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938183">
			September 29, 2011 at 9:43 pm</a>		</div>

		<p>@Silly: Hopefully you juts didn&#39;t called &quot;Norman Diamond&quot;&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938193">
				<div id="div-comment-938193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Drak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938193">
			September 29, 2011 at 10:48 pm</a>		</div>

		<p>&quot;And the value returned by HeapFree on Windows Vista is irrelevant. Pretending to succeed is a valid form of undefined behavior, because anything qualifies as undefined behavior&quot;</p>
<p>This sentence alone makes me think that suddenly saying that passing in NULL has a defined behaviour is a bad idea. What if the behaviour is really undefined on XP or Windows 7? It&#39;s all very nice that Vista appears to always return success but that doesn&#39;t mean all Windowses do that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-cheong odd alt thread-odd thread-alt depth-1" id="comment-938203">
				<div id="div-comment-938203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/cheong00' rel='external nofollow' class='url'>cheong00</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938203">
			September 29, 2011 at 11:58 pm</a>		</div>

		<blockquote><p>
  On the other hand, I do get driven crazy by people checking for a null pointer before a delete since delete a null pointer is defined behavior.
</p></blockquote>
<p>Actually, since my job have to concurrently work on different programming language that have diifferent rules on freeing objects, to play safe I always wrap these statements with a check for null.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938213">
				<div id="div-comment-938213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Worf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938213">
			September 30, 2011 at 12:11 am</a>		</div>

		<p>Even though passing NULL works safely, it&#39;s still an error. In debug mode freeing NULL can trigger a debug exception so the debugger can catch it.</p>
<p>Thus, the behavior is undefined. Because in release mode it&#39;s a no-op. But in debug mode, it generates a debugger exception. Maybe in checked mode it does something else. Etc.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938253">
				<div id="div-comment-938253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Wondering</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938253">
			September 30, 2011 at 6:56 am</a>		</div>

		<p>If the doc explicitly says &quot;NULL is not allowed&quot; then why wasting time to investigate this? Just write this one-line wrapper function, and move on. It&#39;s a very simple wrapper and you don&#39;t get any reasonable benefit by using HeapFree directly. So why bother?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf even thread-even depth-1" id="comment-938273">
				<div id="div-comment-938273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938273">
			September 30, 2011 at 7:43 am</a>		</div>

		<p>While I was swayed by Raymond&#39;s argument that it&#39;s too late to change the function&#39;s contract (I didn&#39;t anticipate someone &quot;reading it from the other side&quot;©), one has to admit that it&#39;s quite counter-intuitive not to define HeapFree(NULL) as a no-op in the first place.</p>
<p>HOWEVER, not even the C standard is consistent about this! While free(NULL) is a no-op, fclose(NULL) is an undefined behavior (that causes a crash via Invalid Parameter Handler if tried on Visual Studio&#39;s CRT)!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-fredericmagnyf odd alt thread-odd thread-alt depth-1" id="comment-938293">
				<div id="div-comment-938293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Medinoc' rel='external nofollow' class='url'>Medinoc</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938293">
			September 30, 2011 at 8:58 am</a>		</div>

		<p>PS: The link about the right shifting makes me glad the C# folks actually defined the behavior.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938303">
				<div id="div-comment-938303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938303">
			September 30, 2011 at 9:41 am</a>		</div>

		<p>@Medinoc: You do know that free(NULL) wasn&#39;t always defined, right?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-938313">
				<div id="div-comment-938313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938313">
			September 30, 2011 at 9:54 am</a>		</div>

		<p>@John: &quot;I don&#39;t understand how returning a consistent error code is &quot;undefined behavior&quot;&#8230;&quot; &nbsp;</p>
<p>Are you talking about observed behavior or contractual behavior when you say &quot;consistent&quot;? &nbsp;In practice, one version of one compiler will probably always do the same thing in the same circumstances, but that doesn&#39;t make it defined behavior.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-938373">
				<div id="div-comment-938373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">ErikF</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20110929-00/?p=9523#comment-938373">
			October 1, 2011 at 11:06 am</a>		</div>

		<p>@Original customer from the post: Consistently giving the same error code to me seems about as undefined as consistently crashing (or any other action, really): because the results are undefined, you&#39;re not supposed to rely on the outcome. Actually, you&#39;re not supposed to be intentionally invoking undefined behaviour because it&#39;s going to give Raymond and co. massive support headaches later on. Don&#39;t contribute to the compatibility messes that already exist! If you want examples, look through the archives!</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

