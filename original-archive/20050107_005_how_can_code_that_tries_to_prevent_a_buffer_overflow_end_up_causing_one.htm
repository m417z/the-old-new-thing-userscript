<html>
<head>
<title>How can code that tries to prevent a buffer overflow end up causing one?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>How can code that tries to prevent a buffer overflow end up causing one?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>January 7, 2005 / year-entry #6</td></tr>
<tr><td><b>Tags:</b></td><td>code;history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>65</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">If you read your language specification, you'll find that the ...ncpy functions have extremely strange semantics. The strncpy function copies the initial count characters of strSource to strDest and returns strDest. If count is less than or equal to the length of strSource, a null character is not appended automatically to the copied string. If...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>If you read your language specification, you'll find that <a href="http://msdn.microsoft.com/library/en-us/vclib/html/_crt_strncpy.2c_.wcsncpy.2c_._mbsncpy.asp"> the <code>...ncpy</code> functions have extremely strange semantics</a>.</p>
<blockquote class="q"><p> The <b>strncpy</b> function copies the initial count characters of <i>strSource</i> to <i>strDest</i> and returns <i>strDest</i>. If <i>count</i> is less than or equal to the length of <i>strSource</i>, a null character is not appended automatically to the copied string. If <i>count</i> is greater than the length of <i>strSource</i>, the destination string is padded with null characters up to length <i>count</i>.  </p>
</blockquote>
<p> In pictures, here's what happens in various string copying scenarios. </p>
<table>
<tr>
<td colspan="3">     <code>strncpy(strDest, strSrc, 5)</code>     </td>
</tr>
<tr>
<td><code>strSource</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">W</td>
<td style="border: solid black .75pt; width: 2em">e</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">c</td>
<td style="border: solid black .75pt; width: 2em">o</td>
<td style="border: solid black .75pt; width: 2em">m</td>
<td style="border: solid black .75pt; width: 2em">e</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><code>strDest</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">W</td>
<td style="border: solid black .75pt; width: 2em">e</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">c</td>
<td style="border: solid black .75pt; width: 2em">o</td>
</tr>
</table>
</td>
<td>observe no null terminator     </td>
</tr>
<tr>
<td colspan="3">&nbsp;</td>
</tr>
<tr>
<td colspan="3">     <code>strncpy(strDest, strSrc, 5)</code>     </td>
</tr>
<tr>
<td><code>strSource</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">H</td>
<td style="border: solid black .75pt; width: 2em">e</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">o</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><code>strDest</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">H</td>
<td style="border: solid black .75pt; width: 2em">e</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">o</td>
</tr>
</table>
</td>
<td>observe no null terminator     </td>
</tr>
<tr>
<td colspan="3">&nbsp;</td>
</tr>
<tr>
<td colspan="3">     <code>strncpy(strDest, strSrc, 5)</code>     </td>
</tr>
<tr>
<td><code>strSource</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">H</td>
<td style="border: solid black .75pt; width: 2em">i</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><code>strDest</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">H</td>
<td style="border: solid black .75pt; width: 2em">i</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
</tr>
</table>
</td>
<td>observe null padding to end of strDest     </td>
</tr>
</table>
<p> Why do these functions have such strange behavior? </p>
<p> Go back to the early days of UNIX. Personally, I only go back as far as System&nbsp;V. In System&nbsp;V, file names could be up to 14 characters long. Anything longer was truncated to 14.  And the field for storing the file name was exactly 14 characters. Not 15.  The null terminator was implied.  This saved one byte. </p>
<p> Here are some file names and their corresponding directory entries: </p>
<table>
<tr>
<td><code>passwd</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">p</td>
<td style="border: solid black .75pt; width: 2em">a</td>
<td style="border: solid black .75pt; width: 2em">s</td>
<td style="border: solid black .75pt; width: 2em">s</td>
<td style="border: solid black .75pt; width: 2em">w</td>
<td style="border: solid black .75pt; width: 2em">d</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
<td style="border: solid black .75pt; width: 2em">\0</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><code>newsgroups.old</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">n</td>
<td style="border: solid black .75pt; width: 2em">e</td>
<td style="border: solid black .75pt; width: 2em">w</td>
<td style="border: solid black .75pt; width: 2em">s</td>
<td style="border: solid black .75pt; width: 2em">g</td>
<td style="border: solid black .75pt; width: 2em">r</td>
<td style="border: solid black .75pt; width: 2em">o</td>
<td style="border: solid black .75pt; width: 2em">u</td>
<td style="border: solid black .75pt; width: 2em">p</td>
<td style="border: solid black .75pt; width: 2em">s</td>
<td style="border: solid black .75pt; width: 2em">.</td>
<td style="border: solid black .75pt; width: 2em">o</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">d</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><code>newsgroups.old.backup</code></td>
<td>
<table style="font-family: monospace; text-align: center" cellpadding="2">
<tr>
<td style="border: solid black .75pt; width: 2em">n</td>
<td style="border: solid black .75pt; width: 2em">e</td>
<td style="border: solid black .75pt; width: 2em">w</td>
<td style="border: solid black .75pt; width: 2em">s</td>
<td style="border: solid black .75pt; width: 2em">g</td>
<td style="border: solid black .75pt; width: 2em">r</td>
<td style="border: solid black .75pt; width: 2em">o</td>
<td style="border: solid black .75pt; width: 2em">u</td>
<td style="border: solid black .75pt; width: 2em">p</td>
<td style="border: solid black .75pt; width: 2em">s</td>
<td style="border: solid black .75pt; width: 2em">.</td>
<td style="border: solid black .75pt; width: 2em">o</td>
<td style="border: solid black .75pt; width: 2em">l</td>
<td style="border: solid black .75pt; width: 2em">d</td>
</tr>
</table>
</td>
</tr>
</table>
<p> Notice that <code>newsgroups.old</code> and <code>newsgroups.old.backup</code> are actually the same file name, due to truncation.  The too-long name was silently truncated; no error was raised.  This <a href="http://www.greatcircle.com/lists/majordomo-users/mhonarc/majordomo-users.199302/msg00037.html"> has historically been the source of unintended data loss bugs</a>. </p>
<p> The <code>strncpy</code> function was used by the file system to store the file name into the directory entry.  This explains one part of the odd behavior of <code>strcpy</code>, namely why it does not null-terminate when the destination fills. The null terminator was implied by the end of the array. (It also explains the silent file name truncation behavior.) </p>
<p> But why null-pad short file names? </p>
<p> Because that makes scanning for file names faster.  If you guarantee that all the "garbage bytes" are null, then you can use <code>memcmp</code> to compare them. </p>
<p> For compatibility reasons, the C language committee decided to carry forward this quirky behavior of <code>strncpy</code>. </p>
<p> So what about the title of this entry?  How did code that tried to prevent a buffer overflow end up causing one? </p>
<p> <a href="http://forums.belution.com/ja/vc/000/259/78.shtml"> Here's one example</a>.  (Sadly I don't read Japanese, so I am operating only from the code.)  Observe that it uses <code>_tcsncpy</code> to fill the <code>lpstrFile</code> and <code>lpstrFileTitle</code>, being careful not to overflow the buffers.  That's great, but it also leaves off the null terminator if the string is too long. The caller may very well copy the result out of that buffer to a second buffer.  But the <code>lstrFile</code> buffer lacks a proper null terminator and therefore exceeds the length the caller specified. Result: Second buffer overflows. </p>
<p> <a href="http://differentpla.net/node/view/253"> Here's another example</a>. Observe that the function uses <code>_tcsncpy</code> to copy the result into the output buffer.  This author was mindful of the quirky behavior of the <code>strncpy</code> family of functions and manually slapped a null terminator in at the end of the buffer. </p>
<p> But what if <code>ccTextMax</code> = 0?  Then the attempt to force a null terminator dereferences past the beginning of the array and corrupts a random character. </p>
<p> What's the conclusion of all this? Personally, my conclusion is simply to avoid <code>strncpy</code> and all its friends if you are dealing with null-terminated strings. Despite the "str" in the name, these functions do <strong>not</strong> produce null-terminated strings.  They convert a null-terminated string into a raw character buffer. Using them where a null-terminated string is expected as the second buffer is plain wrong.  Not only do you fail to get proper null termination if the source is too long, but if the source is short you get unnecessary null padding. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (65)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-240093">
				<div id="div-comment-240093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.differentpla.net/' rel='external nofollow' class='url'>Roger Lipscombe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240093">
			January 7, 2005 at 7:12 am</a>		</div>

		<p>Fair catch Raymond. Although, I have to say that I&#8217;ve never seen cchTextMax = 0.</p>
<p>/me wanders off to post an update to that code sample&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240113">
				<div id="div-comment-240113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240113">
			January 7, 2005 at 7:57 am</a>		</div>

		<p>What about zero-filling the buffer before using strncpy (and friends)?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240133">
				<div id="div-comment-240133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">NoInfo</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240133">
			January 7, 2005 at 7:59 am</a>		</div>

		<p>&lt;blockquote&gt;&lt;i&gt;Personally, my conclusion is simply to avoid strncpy and all its friends if you are dealing with null-terminated strings. Despite the &quot;str&quot; in the name, these functions do not produce null-terminated strings. They convert a null-terminated string into a raw character buffer. Using them where a null-terminated string is expected as the second buffer is plain wrong. Not only do you fail to get proper null termination if the source is too long, but if the source is short you get unnecessary null padding.&lt;/i&gt;&lt;/blockquote&gt;</p>
<p>Easy to say, but what do you encourage instead? </p>
<p>I think simply testing whether strncpy was able to copy the full amount is sufficient (and then null-terminate it). It&#8217;s more work, but that&#8217;s security for ya. </p>
<p>The extra null padding is never going to be a worry. (Or if you&#8217;ve been bitten by it, please elaborate.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240143">
				<div id="div-comment-240143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240143">
			January 7, 2005 at 8:14 am</a>		</div>

		<p>&quot;What about zero-filling the buffer before using strncpy (and friends)?&quot; Since strncpy always fills the buffer, you can paint the buffer neon yellow before calling strncpy, won&#8217;t make any difference. See the diagrams.</p>
<p>&quot;What do you encourage instead?&quot; Functions that operate on strings rather than buffers. lstrcpyn or the StrSafe.h functions, for example.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240153">
				<div id="div-comment-240153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ray Trent</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240153">
			January 7, 2005 at 8:22 am</a>		</div>

		<p>Another example of optimization screwing things up, if you ask me.</p>
<p>Just allocate a buffer of length N+1, set buff[n]=0, and always pass N to strncpy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240183">
				<div id="div-comment-240183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240183">
			January 7, 2005 at 8:25 am</a>		</div>

		<p>Just another example why nearly all of the standard C library should be avoided in production code.</p>
<p>String functions are unsafe.  Formatted input is unsafe.  File I/O is clumsy and error prone.  Steve Maguire does a great job skewering malloc and friends in <em>Writing Solid Code</em>.  Typical implementations of rand() are horrible.  setjmp()/longjmp() &#8212; yikes!  The floating point functions and assert() are about the only bits you can rely on.</p>
<p>If you&#8217;re writing a console application and trying to be portable, then wrap the standard library calls with safer interfaces.</p>
<p>But if you&#8217;re writing for Windows, consider avoiding the CRT altogether.  You can save a lot of headaches by using the Windows APIs instead (not to mention have a smaller, faster loading program with fewer DLL Hell headaches and deep understanding of the redistributable agreements.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240203">
				<div id="div-comment-240203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240203">
			January 7, 2005 at 8:27 am</a>		</div>

		<p>&quot; Another example of optimization screwing things up, if you ask me.</p>
<p>Just allocate a buffer of length N+1, set buff[n]=0, and always pass N to strncpy.&quot;</p>
<p>Why would this screw things up?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240213">
				<div id="div-comment-240213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240213">
			January 7, 2005 at 8:31 am</a>		</div>

		<p>&quot;Since strncpy always fills the buffer, you can paint the buffer neon yellow before calling strncpy, won&#8217;t make any difference. See the diagrams. &quot;</p>
<p>Strncpy won&#8217;t bother bytes beyond the limit you give it.. If you fill it to the end with 0 then your string will be null terminated, and there are no more problems&#8230; right?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240223">
				<div id="div-comment-240223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weatherley.net' rel='external nofollow' class='url'>JamesW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240223">
			January 7, 2005 at 8:31 am</a>		</div>

		<p>Hmm &#8211; my last paragraph could have been written better! I was wondering aloud what goes on inside Windows with regards to strings &#8211; not suggesting using the TOP SEKRIT stuff as a good C string library!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240233">
				<div id="div-comment-240233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.eluent.com/freeware.htm' rel='external nofollow' class='url'>Doug Harrison</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240233">
			January 7, 2005 at 8:39 am</a>		</div>

		<p>One warning about StrSafe.h: While the functions have length parameters and thus make you think about things, they don&#8217;t guarantee you&#8217;ll get those things right. For example, I&#8217;ve run across at least two examples in MSDN that do things like this:</p>
<p>   hres = StringCbCopy(lpszPath, sizeof(lpszPath), szGotPath);</p>
<p>instead of:</p>
<p>   hres = StringCbCopy(lpszPath, pathSize, szGotPath);</p>
<p>You might say, &quot;Well, that&#8217;s easily fixed,&quot; but then you look at the function this appears in and find that lpszPath is a parameter but pathSize is not, and there&#8217;s no documented minimum size for the buffer.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240243">
				<div id="div-comment-240243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240243">
			January 7, 2005 at 8:41 am</a>		</div>

		<p>&quot;If you fill it to the end with 0 then your string will be null terminated, and there are no more problems&#8230; right?&quot;  If you fill it to the end, strncpy will just fill it with stuff again. See the &quot;Welco&quot; example above. If you want to preserve that last zero you need to pass a shorter buffer size to strncpy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240253">
				<div id="div-comment-240253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">strlcpy boy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240253">
			January 7, 2005 at 8:45 am</a>		</div>

		<p>You really want to use strlcpy wherever possible, not strncpy. It has sane semantics. Better yet is to use a language without pointers, such as Ruby. If you&#8217;re not writing a kernel, you shouldn&#8217;t be using raw C/C++.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240263">
				<div id="div-comment-240263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Chris Boucher</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240263">
			January 7, 2005 at 8:46 am</a>		</div>

		<p>I always use strlcpy/strlcat now, see: <a target="_new" href="http://www.courtesan.com/todd/papers/strlcpy.html" rel="nofollow">http://www.courtesan.com/todd/papers/strlcpy.html</a></p>
<p>Using these instead of strcpy/strcat/strncpy/strncat saves a whole lot of potential grief.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240283">
				<div id="div-comment-240283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">your name</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240283">
			January 7, 2005 at 9:23 am</a>		</div>

		<p>Yeah, another voice here for strlcpy() and strlcat().  Guaranteed to be null-terminated, and with the same function signature as strncpy() so you can switch to it with a quick search/replace.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240293">
				<div id="div-comment-240293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240293">
			January 7, 2005 at 9:46 am</a>		</div>

		<p>&quot;If you fill it to the end, strncpy will just fill it with stuff again. See the &quot;Welco&quot; example above. If you want to preserve that last zero you need to pass a shorter buffer size to strncpy.&quot;</p>
<p>Yes&#8230; But, if you have the following:</p>
<p>char buf[6];<br />
<br />buf[6]=0;<br />
<br />strncpy(buf,&quot;welcome&quot;,5);</p>
<p>You get<br />
<br />[w][e][l][c][o][ ]</p>
<p>What&#8217;s the problem, exactly?<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240303">
				<div id="div-comment-240303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lowercase josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240303">
			January 7, 2005 at 9:46 am</a>		</div>

		<p>What&#8217;s worse, I&#8217;ve seen people recommend using strncat instead, only to get its parameters wrong as well.</p>
<p>And if all else fails, it&#8217;s not hard to write your own string functions that do what you expect.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240313">
				<div id="div-comment-240313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Enigma2e</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240313">
			January 7, 2005 at 9:46 am</a>		</div>

		<p>What about using lstrcpy() lstrlen() and the other lstr* functions? Do they have the same issues with them?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240323">
				<div id="div-comment-240323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240323">
			January 7, 2005 at 9:49 am</a>		</div>

		<p>buf[6]=0; </p>
<p>D&#8217;oh</p>
<p>buf[5]=0;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240333">
				<div id="div-comment-240333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240333">
			January 7, 2005 at 9:51 am</a>		</div>

		<p>Anonymous: Yes, but notice that you also changed the size of buf[] from 5 to 6. That&#8217;s a very important step.</p>
<p>Enigma2e: I believe the MSDN documentation for the lstr* functions already explains their behavior adequately.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240343">
				<div id="div-comment-240343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240343">
			January 7, 2005 at 10:11 am</a>		</div>

		<p>Translation of example one:</p>
<p>&gt;&gt; Could you tell me how to select a handle?<br />
<br />&gt;<br />
<br />&gt; Try to dbl click the handle and select OK but CDN_FILEOK comes<br />
<br />&gt; up.  To open the handle it can be selected from CDN_FOLDERCHANGE<br />
<br />&gt; but as a result of that selection, I cannot close the dialog.<br />
<br />&gt;<br />
<br />&gt; In any case I think it is for “file selection”</p>
<p>Self-Less.  (That is direct translation, I don’t understand it.)<br />
<br />It was possible by this way, however, I do not guarantee anything.<br />
<br />The following is MFC sample.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240353">
				<div id="div-comment-240353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://orcmid.com/BlunderDome/clueless/' rel='external nofollow' class='url'>orcmid</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240353">
			January 7, 2005 at 10:27 am</a>		</div>

		<p>Yes, I always fancy the pattern of </p>
<p>    char buf[N+1];<br />
<br />    buf[N] = 0&#8242;</p>
<p>    &#8230; strncpy(buf, src, N);</p>
<p>and having the reassurance that there is always a null terminator and it is never creamed by an edge case.</p>
<p>I hadn&#8217;t worried about the padding in the past, but I do like the simplicity of predictable values for the entire buffer.</p>
<p>I can see that </p>
<p>    &#8230; strlcpy(buf, src, N+1)</p>
<p>saves that part and is &quot;smoother&quot; in some sense.&amp;nbsp; When I am dealing with fixed-field parameters, though, I always prefer the strncpy technique anyhow, since the length maximum tends to be a well-known parameter.</p>
<p>Nice tip.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240363">
				<div id="div-comment-240363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">tomw</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240363">
			January 7, 2005 at 10:37 am</a>		</div>

		<p>Another look at str* gotchas here: <a target="_new" href="http://blogs.msdn.com/michael_howard/archive/2004/12/10/279639.aspx" rel="nofollow">http://blogs.msdn.com/michael_howard/archive/2004/12/10/279639.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240393">
				<div id="div-comment-240393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">TheDude</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240393">
			January 7, 2005 at 12:00 pm</a>		</div>

		<p>Here&#8217;s an example of where this can go wrong&#8230; Funny that you posted this today, we were observing a buffer overflow in the code linked to below. This bug shows up when the length of string in the string table was a multiple of 16, which is another bug entirely but, a symptom of misusing/misunderstanding the *ncopy functions in this case.</p>
<p><a target="_new" href="http://support.microsoft.com/default.aspx?scid=kb;en-us;200893" rel="nofollow">http://support.microsoft.com/default.aspx?scid=kb;en-us;200893</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240403">
				<div id="div-comment-240403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240403">
			January 7, 2005 at 12:10 pm</a>		</div>

		<p>&quot;&#8230; when they can choose from [string classes]&quot;</p>
<p>Even if you use a string class you still have to worry about buffers when interfacing with other code. Is there a way to convert a std::string to a std::wstring that doesn&#8217;t involve buffer manipulation?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240413">
				<div id="div-comment-240413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240413">
			January 7, 2005 at 12:24 pm</a>		</div>

		<p>string s = &quot;a narrow string&quot;;<br />
<br />std::wstring result;<br />
<br />result.reserve(s.length());<br />
<br />std::copy(s.begin(), s.end(), std::back_inserter(result));<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240423">
				<div id="div-comment-240423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240423">
			January 7, 2005 at 12:41 pm</a>		</div>

		<p>That doesn&#8217;t work if the std::string has any characters above 127 in it. What if it were</p>
<p>// This is Chinese for &quot;Chinese&quot;<br />
<br />// using the Big5 character set.<br />
<br />string s = &quot;xA4xA4xA4xE5&quot;;</p>
<p>and I want the result to be</p>
<p>wstring ws = L&quot;x4E2Dx6587&quot;;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240443">
				<div id="div-comment-240443" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240443">
			January 7, 2005 at 1:08 pm</a>		</div>

		<p>Adrian said &quot;File I/O is clumsy and error prone. Steve Maguire does a great job skewering malloc and friends in <em>Writing Solid Code</em>.&quot;</p>
<p>Okay.  What should we use instead?  I&#8217;m sure as hell not writing my own file i/o or dynamic memory allocation, because I have no choice but to do so in assempler.</p>
<p>Vorn</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240453">
				<div id="div-comment-240453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240453">
			January 7, 2005 at 1:41 pm</a>		</div>

		<p>I figured you&#8217;d reply saying something like that.  You&#8217;d have to call MultiByteToWideStr, which implies you have to access the physical buffer. Wrap it up in a function and add it to the personal toolbox.</p>
<p>Lack of decent strings is a language problem. But using string classes at least saves you the grief of cleanup and performing common operations without exposing yourself to unnecessary risk. Any decent string class should let you get to the internal string easily.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240463">
				<div id="div-comment-240463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://andyandy.sprayblogg.no' rel='external nofollow' class='url'>Andreas H&#228;ber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240463">
			January 7, 2005 at 1:41 pm</a>		</div>

		<p>Vorn: As suggested above, use the Win32 API instead. </p>
<p>File I/O: <a target="_new" href="http://msdn.microsoft.com/library/?url=/library/en-us/dnanchor/html/filesio.asp?frame=true" rel="nofollow">http://msdn.microsoft.com/library/?url=/library/en-us/dnanchor/html/filesio.asp?frame=true</a></p>
<p>Memory allocation: <a target="_new" href="http://msdn.microsoft.com/library/?url=/library/en-us/dnanchor/html/memoryank.asp?frame=true" rel="nofollow">http://msdn.microsoft.com/library/?url=/library/en-us/dnanchor/html/memoryank.asp?frame=true</a></p>
<p>[And of course some other stuff by Microsoft which shall not be discussed here (check subtitle for a hint) ;)]</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240483">
				<div id="div-comment-240483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240483">
			January 7, 2005 at 3:42 pm</a>		</div>

		<p>For REALLY useful wide to narrow character (and vice versa) stuff, look up CA2T, CT2A, CT2W, CA2W, CW2A, CW2T, CA2T, etc etc etc in ATL 7.0.</p>
<p>Wonderful little wrappers, all pre-done and tested for you.</p>
<p>If you&#8217;re not using WTL and ATL for your Windows development and you&#8217;re programming in C++, you should certainly consider taking it for a spin.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240123">
				<div id="div-comment-240123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Buchanan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240123">
			January 7, 2005 at 7:59 am</a>		</div>

		<p>The issue is well known to anyone who has read Michael Howard&#8217;s secure coding book.</p>
<p>The normal mitigation is indeed to slap the nul terminator on the end of the destination buffer.  The ccTextMax = 0 possibility, while valid, is a pretty exceptional case.  Generally it amounts to asking &#8216;After I copy a string into a zero-length buffer, will I cause problems by nul terminating it?&#8217;</p>
<p>The solution is that, when the length of the destination buffer is supplied to you, you should *always* ensure it is valid.  As long as you have basic sanity checks in place, strncpy + explicit nul-termination is fine.  Various safe coding libraries have functions and macros to make this easy.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240193">
				<div id="div-comment-240193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weatherley.net' rel='external nofollow' class='url'>JamesW</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240193">
			January 7, 2005 at 8:25 am</a>		</div>

		<p>@Raymond<br />
<br />Personally, my conclusion is simply to avoid strncpy and all its friends </p>
<p>@NoInfo<br />
<br />Easy to say, but what do you encourage instead? </p>
<p>I can&#8217;t answer for Raymond but I&#8217;d rather be using a string class whilst munging and copying strings about rather than raw char*s &#8211; take your pick: std::string, CString, NSString(!), &#8230; You can always retreive a char array once you&#8217;re done messing around and pass that on to APIs that require such things.</p>
<p>My examples are all for OO language&#8217;s but that&#8217;s not a requirement &#8211; you can find good string libraries in C &#8211; looking at ntdll.dll there seems to be a fair few Rtl*** string methods.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240503">
				<div id="div-comment-240503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Vorn</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240503">
			January 7, 2005 at 4:51 pm</a>		</div>

		<p>Win32 API doesn&#8217;t work on Slack or Mac. :)</p>
<p>Vorn</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240273">
				<div id="div-comment-240273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Schend</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240273">
			January 7, 2005 at 9:05 am</a>		</div>

		<p>The bstring library works in C and C++ and solves all of these issues gracefully:</p>
<p><a target="_new" href="http://bstring.sourceforge.net/" rel="nofollow">http://bstring.sourceforge.net/</a></p>
<p>My problem now is that I have a huge project in C that we&#8217;re converting to C++, and it has about 30,000 char* strings in it that I&#8217;d like to convert into std::string&#8230; yet those two datatypes aren&#8217;t even close to being compatible with each other.  bstring solves some of the problems of char*, but I&#8217;d like to move to std:string so that the program is &quot;pure&quot; C++.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240513">
				<div id="div-comment-240513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://andyandy.sprayblogg.no' rel='external nofollow' class='url'>Andreas H&#228;ber</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240513">
			January 7, 2005 at 5:43 pm</a>		</div>

		<p>That&#8217;s why Microsoft&#8217;s SSCLI/&quot;Rotor&quot; team created their PAL(Platform Abstraction Layer) [1].</p>
<p>Or you can of course use #if/#else all over your source code to make it a joy to maintain it :P.</p>
<p>Platform agnostic frameworks are also helpful :)</p>
<p>[1] <a target="_new" href="http://dotnet.di.unipi.it/Content/sscli/docs/doxygen/pal/index.html" rel="nofollow">http://dotnet.di.unipi.it/Content/sscli/docs/doxygen/pal/index.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240373">
				<div id="div-comment-240373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240373">
			January 7, 2005 at 10:45 am</a>		</div>

		<p>There are two things to remember when using strncpy (unless you&#8217;re using it to write something like lstrcpy):</p>
<p>1. If you use strncpy to write it, you have to make sure *everybody* using the buffer knows it may not be a NUL terminated string.<br />
<br />2. You can&#8217;t write code like:</p>
<p>if (s[n] == &#8216;r&#8217; &amp;&amp; s[n+1] == &#8216;n&#8217;) {}</p>
<p>because having a NUL terminated string gives you the property of having a 1 character look-ahead. If you wanted to do the above you would have to check if n+1 != length first. Sure it&#8217;s obvious here, but not when you&#8217;re writing s[n] as *s/s[0] and s[n+1] as *(s+1)/s[1] and advancing the ptr instead of using an index into it.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240383">
				<div id="div-comment-240383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240383">
			January 7, 2005 at 11:27 am</a>		</div>

		<p>Why do *application* programmers using C++ futz with the zillion different variations of str* functions when they can choose from std::string, CString, or a custom String class? It boggles my mind. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240533">
				<div id="div-comment-240533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240533">
			January 7, 2005 at 9:05 pm</a>		</div>

		<p>Vorn &#8211; while true, unfortunately, Slack and Mac don&#8217;t appear to be too interested in fixing the problems.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240553">
				<div id="div-comment-240553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240553">
			January 7, 2005 at 11:07 pm</a>		</div>

		<p>1/7/2005 8:27 AM Anonymous</p>
<p>&gt;&gt; &quot; Another example of optimization screwing<br />
<br />&gt;&gt; things up, if you ask me.<br />
<br />&gt;&gt;<br />
<br />&gt;&gt; Just allocate a buffer of length N+1, set<br />
<br />&gt;&gt; buff[n]=0, and always pass N to strncpy.&quot;<br />
<br />&gt;<br />
<br />&gt; Why would this screw things up? </p>
<p>It wouldn&#8217;t.  The &quot;Just allocate&quot; sentence is a solution to the screwup that was caused by an attempted optimization.  (The attempted optimization was saving a byte of memory.)</p>
<p>The same solution might be in use in code not visible in the Japanese article that Mr. Chen linked to.  The visible portion of the code uses a pointer, but we don&#8217;t see how much memory was actually allocated when the pointer was assigned.</p>
<p>The Japanese text in the article has the author first quoting her previously posted question asking for help on how to detect a folder change from a file selection, and then saying that she found the answer in an MFC sample.  I wonder if the portion of code not visible in the article might be in the MFC sample.  Does anyone recognize that MFC sample, and does it work reliably?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240573">
				<div id="div-comment-240573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">autist0r</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240573">
			January 8, 2005 at 12:35 am</a>		</div>

		<p>To solve this problem I designed a CString equivalent class that allocates the memory on a separate heap (this way, if heap corruption occurs, your strings remain safe, and vice versa). Plus, you get the benefits of all the checks win32 heap management offers (assert(HeapValidate()) is everywhere). It has got the disadvantage (? :p) of being a windows-only class though.</p>
<p>Otherwise for plain C code or for driver code (where I may not be able to use string safe functions for backward compatibility) I simply use a ripped (^^) OpenBSD&#8217;s strlcpy or I do as shown above : I have an extra byte for the NULL terminator (but it&#8217;s not very sound, is it ?).<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240583">
				<div id="div-comment-240583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anthony Wieser</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240583">
			January 8, 2005 at 12:36 am</a>		</div>

		<p>I always wrote it like this</p>
<p>char dest[N+1];<br />
<br />strncpy(dest, src, N)[N]=0</p>
<p>if I wanted it guaranteed to be null terminated</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240593">
				<div id="div-comment-240593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">igor1960</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240593">
			January 8, 2005 at 1:12 am</a>		</div>

		<p>I think that weird discussion you guys are having here is baseless. You probably have alot of free time on your hands.<br />
<br />Anyway, the reson I consider it baseless is the following:<br />
<br />And who said that strncpy is &quot;designed to prevent a buffer overflow&quot;? Just because you put that notion into the caption of that entry doesn&#8217;t meen it&#8217;s true.<br />
<br />Just my humble opinion: strnpy has nothing to do with &quot;buffer overflow/overrun&quot; protection &#8212; it&#8217;s just a convenient function for those who know how to use it.<br />
<br />In everything else I agree with an article &#8212; but conclusion is weird. It&#8217;s like making the following conclusion:<br />
<br />&quot;Don&#8217;t use &quot;strcpy&quot; an it&#8217;s friends because your destination buffer may not be big enough to hold the resultant length of bytes&quot;&#8230;<br />
<br />Looks, strange and obvious isn&#8217;t it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240603">
				<div id="div-comment-240603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240603">
			January 8, 2005 at 1:25 am</a>		</div>

		<blockquote><p>
  And who said that strncpy is &quot;designed to prevent a buffer overflow&quot;?</p>
<p>You did. I don&#8217;t know where you got that phrase from; its first appearance on this page is when you yourself wrote it.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240613">
				<div id="div-comment-240613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">autist0r</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240613">
			January 8, 2005 at 2:28 am</a>		</div>

		<p>The Holy MSDN says, at the strcpy entry :</p>
<p>Security Note : Because strcpy does not check for sufficient space in strDestination before copying strSource, it is a potential cause of buffer overruns. Consider using strncpy instead.</p>
<p>I think Raymond was referring to this when writing his article.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240623">
				<div id="div-comment-240623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/saurabhjain' rel='external nofollow' class='url'>Saurabh Jain</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240623">
			January 8, 2005 at 2:36 am</a>		</div>

		<p>Well, help from CRT is underway in Whidbey in from secure CRT (<a target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncode/html/secure03102004.asp" rel="nofollow">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncode/html/secure03102004.asp</a>). There are *_s (strcpy_s, strncpy_s) versions of the str functions that guarantee null termination. They also invoke error handlers when the parameters are incorrect (not enough buffer, source/destination not being null terminated, and so forth), which allows one to track these error more easily.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240643">
				<div id="div-comment-240643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frank</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240643">
			January 8, 2005 at 4:58 am</a>		</div>

		<p>@Anthony:</p>
<p>strncpy(dest, src, N)[N]=0</p>
<p>Why not simply:</p>
<p>strncpy(dest, src, N);<br />
<br />dest[N]=0;</p>
<p>Which i.m.o. does exactly the same and doesn&#8217;t confuse the code reviewers/maintainers!<br />
<br />I think people should stop inventing smart C constructions that save 5 characters of source code but make the code less readable. Unless of course when you&#8217;re trying to win a &quot;write the shortest C source that accomplishes this task&quot; contest :-)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240653">
				<div id="div-comment-240653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Beginner</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240653">
			January 8, 2005 at 7:12 am</a>		</div>

		<p>Microsoft recommends: For more secure string handling please use the StrSafe.h functions.<br />
<br />Well, I agree but, why should I have to download from that activex and badly designed site and install a massive Platform SDK in the first place? Please do not make life difficult for us by placing everything in a massive Platform SDK, which has to be downloaded in a very specific way and installed in a very specific way. I might just want to use a few Windows functions. I might want to download only the documentation, only download a header file like StrSafe.h, I might want to install them in any way I like. Why should I use a Platform SDK installer?<br />
<br />As things stand, developing for standard C is very easy, just get a free compiler. Learning and developing for Windows is very difficult for a beginner.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240663">
				<div id="div-comment-240663" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240663">
			January 8, 2005 at 8:04 am</a>		</div>

		<p>If you&#8217;re a beginner, why do you want to install something in a specific way?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240673">
				<div id="div-comment-240673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://insanity-infusion.blogspot.com' rel='external nofollow' class='url'>Insanity Infusion</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240673">
			January 8, 2005 at 8:13 am</a>		</div>

		<p>Wow, did this make my head entirely hurt!</p>
<p>/scrambles for aspirin.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240703">
				<div id="div-comment-240703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">igor1960</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240703">
			January 8, 2005 at 11:21 am</a>		</div>

		<blockquote><p>
  &gt; You did. I don&#8217;t know where you got that phrase from; its first appearance on this page </p>
<p>We are playing the game of who said what first.<br />
  <br />It doesn&#8217;t change the subject. OK, I was wrong.<br />
  <br />But you titled the thread &quot;How can code that tries to prevent a buffer overflow end up causing one?&quot;<br />
  <br />Show me the code you are talking about. From samples you are reffering to it&#8217;s not that obvious that strncpy (and derivatives) is used in a segment of the code that prevents from &quot;buffer overflow&quot;.<br />
  <br />Where is it? Am I missing something?</p>
<p>Now, for me strncpy is a convenient function of just copying string array bytes of known length. Nothing else and nothing more. Now, to screw up the buffers &#8212; you don&#8217;t need to use strncpy, in fact you can use any other str&#8230; function and just provide bad pointer and/or not long enough destination. So, what&#8217;s the point? Does that mean that we shouldn&#8217;t use str&#8230; functions.<br />
  <br />I completely agree that it&#8217;s better and safer to use data types other then just null terminated bytes array. But if you are using bytes array what&#8217;s wrong in having extra function that you could use or not it&#8217;s up to you. Now when you are claiming &quot;They convert a null-terminated string into a raw character buffer. Using them where a null-terminated string is expected as the second buffer is plain wrong&quot; &#8212; this is not true &#8212; they are not: They do it only if you made a mistake while using them.<br />
  <br />But if this is a case then you should make the following conclusion about just strcpy. Something like that: &quot;Don&#8217;t use strcpy, because if you pass bad dest pointer to it &#8212; your program may just crash&quot;&#8230;</p>
<p>We are talking about part of &quot;C Standard&quot; here as strncpy is in it. For me another advantage is readability of the code that uses strncpy. Meaning, I can send this code to others and will be understood. Also, in majority of cases strncpy if you have to read/debug somebodies code strncpy is very helpfull as it gives you a clue usually about dest buffer length. Now, in your ownd development feel free to use whaever function/method you prefer and sure about, but when you have to share your algorithms to the world &#8212; nothing is better then use functions provided by &quot;C Standard&quot; and strncpy is one of them&#8230;<br />
  
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240723">
				<div id="div-comment-240723" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ken Jackson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240723">
			January 8, 2005 at 3:52 pm</a>		</div>

		<p>I appreciate the Unix history.  I didn&#8217;t know.</p>
<p>This is the way I always code:</p>
<p>  char buf[100];<br />
<br />  strncpy(buf,src,sizeof(buf));<br />
<br />  buf[ sizeof(buf)-1 ] = 0;</p>
<p>Now I KNOW that buf is nul-terminated.<br />
<br />The string it contains may or may not be truncated.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240713">
				<div id="div-comment-240713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240713">
			January 8, 2005 at 1:14 pm</a>		</div>

		<p>The code samples I referenced were using strncpy (or its variants) to ensure that they didn&#8217;t overflow a string buffer. But they used it incorrectly and ended up overflowing a buffer when the previous code (that presumably used the unsafe &quot;strcpy&quot; function) didn&#8217;t.  That&#8217;s what I mean by &quot;code that tried to prevent a buffer overflow ends up causing one.&quot;</p>
<p>My point is that unlike the other &quot;str&quot; functions, strncpy does *not* produce null-terminated strings. Do not use it as if it did.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240733">
				<div id="div-comment-240733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.wieser-software.com' rel='external nofollow' class='url'>Anthony Wieser</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240733">
			January 9, 2005 at 12:08 am</a>		</div>

		<p>@FRANK</p>
<p>I write it thus:<br />
<br />strncpy(dest, src, N)[N]=0 </p>
<p>because dest may be expensive to evaluate, where a I know dest must be returned by the function itself.</p>
<p>Also, the compiler may be able to optimize the result, because dest is the return value.</p>
<p>Sure it&#8217;s a small optimization, and yes, it may not be immediately obvious, but it does become an idiom, which means I always write it that way, and therefore I never make the error of omission.</p>
<p>Anthony Wieser<br />
<br />Wieser Software Ltd</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240743">
				<div id="div-comment-240743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">autist0r</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240743">
			January 9, 2005 at 12:22 am</a>		</div>

		<p>I to it this way,</p>
<p>::strncpy(dest, src, N);<br />
<br />::ZeroMemory(dest, sizeof(dest));</p>
<p>This way I know my data is secure ! :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240763">
				<div id="div-comment-240763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240763">
			January 9, 2005 at 8:55 am</a>		</div>

		<blockquote><p>
  That is a big trap. Some day somebody will change the code to something like:</p>
<p>&gt; char *buf = malloc(100);<br />
  <br />&gt; strncpy(buf,src,sizeof(buf));<br />
  <br />&gt; buf[ sizeof(buf)-1 ] = 0; </p>
<p>If they do, they should be killed.  Not only have they introduced a bug into the code, but they have also added a threading sync point to the code.  Allocating memory is very expensive compared to adding 100 to ESP.  MT heap allocation is expensive.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-240773">
				<div id="div-comment-240773" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240773">
			January 9, 2005 at 9:08 am</a>		</div>

		<p>Tim,<br />
<br />  Allocating memory is cheap when compared to blowing the stack (and thus terminating the application).<br />
<br />  There are situations where it&#8217;s appropriate.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-240753">
				<div id="div-comment-240753" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael J</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-240753">
			January 9, 2005 at 7:24 am</a>		</div>

		<p>&gt; char buf[100];<br />
<br />&gt; strncpy(buf,src,sizeof(buf));<br />
<br />&gt; buf[ sizeof(buf)-1 ] = 0; </p>
<p>That is a big trap.  Some day somebody will change the code to something like:</p>
<p>    char *buf = malloc(100);<br />
<br />    strncpy(buf,src,sizeof(buf));<br />
<br />    buf[ sizeof(buf)-1 ] = 0; </p>
<p>and sizeof(buf) becomes &quot;4&quot;.</p>
<p>Better to do something like this:</p>
<p>    const int size=100;<br />
<br />    char buf[size];<br />
<br />    strncpy(buf,src,size);<br />
<br />    buf[ size-1 ] = 0; </p>
<p>I have always used a wrapper around strncpy to make sure that I never left off the nul.</p>
<p>char *safecpy(char *pDest, const char *pSrc, size_t len)<br />
<br />{<br />
<br />    strncpy(pDest, pSrc, len);<br />
<br />    pDest[len-1] = &#8216; &#8217;;<br />
<br />    return pDest;<br />
<br />}</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-241163">
				<div id="div-comment-241163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul C.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-241163">
			January 10, 2005 at 9:00 am</a>		</div>

		<p>I just looked over at the functions provided by strsafe.h, and couldn&#8217;t help but notice that there was no replacement for any of the scanf functions.  Is there anything in the Win32 API off the top of your head that replicates the fscanf functionality safely?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-241643">
				<div id="div-comment-241643" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">igor1960</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-241643">
			January 10, 2005 at 4:49 pm</a>		</div>

		<ol>
<li>Heap &quot;buffer overrun&quot; maybe as dangerouse as static(stack) &quot;buffer overrun&quot;:<br />
<br />2. Another error in your sample is sizeof(buf) is not 100 as you probably ment:<br />
<br />// That&#8217;s better solution:<br />
<br />char *buf = malloc(100);<br />
<br />buf[ 99 ] = 0;<br />
<br />strncpy(buf,src,100);<br />
<br />if(buf[ 99 ] != 0 )<br />
<br />{<br />
<br /> // Overflow&#8230;.<br />
<br />}</p>
<p>=====================<br />
<br />But I still disagree with considering strncpy more dangerous then any other str&#8230; functions.<br />
<br />Using the same token you could say that strcpy is dangerous and don&#8217;t use it as src in it maybe not NULL terminated string&#8230;</p>
</li>
</ol>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-241673">
				<div id="div-comment-241673" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/larryosterman' rel='external nofollow' class='url'>Larry Osterman</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-241673">
			January 10, 2005 at 5:51 pm</a>		</div>

		<p>igor1960: Umm.. strcpy is vastly more dangerous than strncpy &#8211; the difference is that strncpy allows you to THINK you&#8217;ve fixed a security hole when you haven&#8217;t.</p>
<p>Paul C: I don&#8217;t believe that there is a safe scanf.  I also don&#8217;t think it&#8217;s possible to write a safe scanf in C (it may be possible in C++, I&#8217;m not sure).</p>
<p>For scanf, you&#8217;re better off parsing it yourself, IMHO.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-241713">
				<div id="div-comment-241713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">igor1960</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-241713">
			January 10, 2005 at 7:05 pm</a>		</div>

		<p>Larry: Umm.. strcpy is vastly more dangerous than strncpy&#8230;</p>
<p>The problem is the guys here are pretty crazy about security &#8212; while in reality nothing in the discussions above realy relates to security. In fact the purpose of strncpy is not to protect or decrease probability of buffer overrun at all. It&#8217;s just a copying function. How you use it in secure content properly or not is a different issue. But could you please demonstrate me a case of buffer overrun using my above described sample:</p>
<p>char *buf = malloc(100);<br />
<br />buf[ 99 ] = 0;<br />
<br />strncpy(buf,src,100);<br />
<br />if(buf[ 99 ] != 0 )<br />
<br />{<br />
<br />// Overflow&#8230;.overrun &#8212; name it whatever you want<br />
<br />} </p>
<p>I think you agree with me that what I think is exactly what it is: security hole is fixed&#8230;</p>
<p></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-241733">
				<div id="div-comment-241733" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-241733">
			January 10, 2005 at 7:27 pm</a>		</div>

		<p>If &quot;src&quot; is longer than 99 characters, then &quot;buf&quot; has no null terminator. As many people have pointed out, you have to whack a null terminator in manually. If you forget, then you create an illegal string.</p>
<p>The strange behavior of the strn* functions is not well known; they are the exceptions to the general rule that &quot;str&quot; functions produce null-terminated strings. And strings that aren&#8217;t properly terminated lead to read errors at a minimum, and possibly write errors if the string is copied on the assumption that the function properly terminated the buffer.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-242353">
				<div id="div-comment-242353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Paul C.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-242353">
			January 11, 2005 at 2:23 pm</a>		</div>

		<p>Larry:  Actually, I gave it a little thought.  I could use fgets (which takes a size parameter, and null terminates) to safely pull an entire line out of the file, then use sscanf to parse the line.  While reading the line, if the line is bigger than my fgets buffer, I&#8217;ll know because the line returned by fgets will be the size of the buffer, the character before the null terminator will not be a newline, and I won&#8217;t be at EOF, so I&#8217;ll know to allocate a bigger buffer and read the rest of the line in (or give up because the line is too big and a giant binary mess :-) ).  I now know the max size of the line because I built it with fgets, no string in that line should be bigger than the line itself.  So, if all the temp string buffers I pass to sscanf are as large as the string I pass to sscanf to be parsed, I should be safe.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-242533">
				<div id="div-comment-242533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">encourage memcpy instead</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-242533">
			January 12, 2005 at 2:36 am</a>		</div>

		<p>Because of the unreliable behaviour of strncpy, I always use memcpy instead, which force me to terminate the destination buffer myself (if buf length&gt;0).</p>
<p>I didnt know of the null-padding which strncpy performs, and it&#8217;s always nice when Raymond present such information with an explaination of the underlying reason.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-246593">
				<div id="div-comment-246593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://bstring.sourceforge.net/' rel='external nofollow' class='url'>Paul Hsieh</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050107-00/?p=36773#comment-246593">
			January 18, 2005 at 11:25 pm</a>		</div>

		<p>Aha!  So this is where all that traffic came from!  :)</p>
<p>I am the author of &quot;The Better String Library&quot; (<a target="_new" href="http://bstring.sf.net/" rel="nofollow">http://bstring.sf.net/</a>).  This discussion about strncpy, strlcpy, etc is exactly what &quot;The Better String Library&quot; (Bstrlib) is all about.  The real problem is that in the C language, when you want to work with strings you are forced to think about buffers.  This becomes a source of problems, and the interesting weaknesses of strncpy and strlcpy (since both have to decide on some sort of compromise for situtations where the buffer is too small) highlight this problem.  The same generic problem exists for the equally important strcat and fgets functions as well of course.</p>
<p>This lesson has not been lost on the designers of just about every other programming language in existence.  The solution is to perform automatic buffer management with every string manipulation.  This frees the programmer to think about and deal with strings as just that &#8212; strings. This poses the question: can such automatic buffer management be implemented in a library for the C language?  Bstrlib is an answer to this question in the affirmative.  Bstrlib gives a complete string ADT which has a large superset of the functionality of the standard C library but because it hides all buffer management it avoids all of the typical string related buffer overflow problems.  In practice it is truly significantly safer and easier to use than standard &#8216; &#8217; terminated char * based strings.</p>
<p>Because I wanted to put Bstrlib forth as a complete substitute for string manipulation needs for C and C++ I also needed to solve a number of other problems:</p>
<p>1. Portability &#8212; its open source (BSD<br />
<br />   license, so even Microsoft can use<br />
<br />   it) and has been verified to compile<br />
<br />   with 16, 32 and 64 bit compilers on<br />
<br />   DOS, Windows and Linux.  (I am<br />
<br />   waiting for some feedback from the<br />
<br />   Mac OS X community, though I am<br />
<br />   almost sure that it will compile<br />
<br />   there with no issues on either gcc<br />
<br />   or Metrowerks.)</p>
<p>2. Speed &#8212; benchmarks I&#8217;ve written<br />
<br />   indicate that Bstrlib, despite its<br />
<br />   extra implicit buffer management<br />
<br />   code, actually *outperforms* the C<br />
<br />   library most of the time for most<br />
<br />   functions.</p>
<p>3. C++ API &#8212; This is where I got the<br />
<br />   most feedback from other developers<br />
<br />   who are more experienced with C++<br />
<br />   than I.  The result is a powerful<br />
<br />   C++ API that is comparable to both<br />
<br />   Microsoft&#8217;s MFC CString class as<br />
<br />   well as the STL&#8217;s std::string class<br />
<br />   in terms of functionality.  In terms<br />
<br />   of performance, Bstrlib&#8217;s C++ API<br />
<br />   leaves the competition in the dust.</p>
<p>4. Compatibility with &#8216; &#8217; terminated<br />
<br />   char * strings &#8212; the fact is that<br />
<br />   other precompiled libraries with<br />
<br />   typically stick to using the<br />
<br />   standard C string concepts.<br />
<br />   <a target="_new" href="http://www.pcre.org" rel="nofollow">http://www.pcre.org</a> is a prime<br />
<br />   example of a very valuable library<br />
<br />   that makes this assumption.  So it<br />
<br />   was very important to make sure<br />
<br />   Bstrlib supported backward<br />
<br />   compatibility modes with &#8216; &#8217;<br />
<br />   terminated char * strings very well,<br />
<br />   which it does.  Pointer addition<br />
<br />   tricks, for example, are emulated as<br />
<br />   a constant reference substring<br />
<br />   macro. Remember, as inline strings,<br />
<br />   the language itself only supports<br />
<br />   backslash-escape-interpreted symbols<br />
<br />   rammed between a pair of quotes.  So<br />
<br />   it doesn&#8217;t make sense to break off<br />
<br />   backward compatibility or to make it<br />
<br />   cumbersome.</p>
<p>5. Good IO support &#8212; I implemented a<br />
<br />   fully abstracted file IO interface<br />
<br />   which is integrated with Bstrlib.<br />
<br />   Because of the subtle difference<br />
<br />   between text mode and binary mode<br />
<br />   files, bstrings have to be able to<br />
<br />   hold binary content (specifically<br />
<br />   including the &#8216; &#8217; character as an<br />
<br />   ordinary character.)  Thus Bstrlib&#8217;s<br />
<br />   implicit buffer management<br />
<br />   capabilities can be leveraged in its<br />
<br />   IO routines as well.  A key example<br />
<br />   of this is the support for an<br />
<br />   arbitrary number of &quot;ungetc&quot;-like<br />
<br />   calls.</p>
<p>6. Functionality of other languages &#8212;<br />
<br />   The primary considerations here was<br />
<br />   to implement split/join,<br />
<br />   insert/delete, find+replace,<br />
<br />   functions as well as write<br />
<br />   protection and complete parameter<br />
<br />   aliasing safety.  This functionality<br />
<br />   can be found in other languages such<br />
<br />   as Python or Perl.</p>
<p>By delivering all this, I believe that Bstrlib is a far superior solution to anything else out there (for string manipulation).  I have a comparison table here: <a target="_new" href="http://bstring.sf.net/" rel="nofollow">http://bstring.sf.net/</a>features.html (though obviously you might find it a little biased.)</p>
<p>As to specific comments made in this thread, here are my thoughts:</p>
<p>&#8211; As to using Mac OS X/Slackware<br />
<br />  (Linux) obviously Bstrlib is a better<br />
<br />  solution than the Win32 or .NET API.<br />
<br />  Because Bstrlib is a platform neutral<br />
<br />  source library under active<br />
<br />  maintenace, enhancements, bugfixes<br />
<br />  and other updates will be equal for<br />
<br />  everyone &#8212; there is no risk of a Mac<br />
<br />  OS X version being &quot;orphaned&quot; because<br />
<br />  of its smaller community size, for<br />
<br />  example.</p>
<p>&#8211; Unicode/widechar support is beyond<br />
<br />  the scope of what Bstrlib solves.<br />
<br />  However, since Bstrlib is very<br />
<br />  interoperable with char * based<br />
<br />  strings, the conversion mechanisms<br />
<br />  for existing Unicode/widechar string<br />
<br />  library functionality should still be<br />
<br />  able to work with Bstrlib.</p>
<p>&#8211; Strsafe was a legitimate attempt by<br />
<br />  Microsoft to improve the safety of<br />
<br />  char * strings.  But since it makes<br />
<br />  no attempt to improve the upon the<br />
<br />  functionality of the C library and<br />
<br />  still leaves the problem of precise<br />
<br />  buffer management in the hands of the<br />
<br />  programmer, it falls far short of bar<br />
<br />  set by Bstrlib.  For C++ users MFC&#8217;s<br />
<br />  CString is a far superior solution<br />
<br />  which in turn is inferior to<br />
<br />  Bstrlib&#8217;s C++ API.</p>
<p>&#8211; scanf is a calamity of design errors.<br />
<br />  Its fairly rare to desire string<br />
<br />  input delimited by spaces.  Simply<br />
<br />  breaking down scanf into the<br />
<br />  functions fgets then sscanf is far<br />
<br />  superior, and the only mechanism I<br />
<br />  would recommend for basic parsing of<br />
<br />  strings using the C library<br />
<br />  facilities.  Of course you can use<br />
<br />  Bstrlib&#8217;s IO to read input even more<br />
<br />  safely, than parse things out with<br />
<br />  sscanf.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

