<html>
<head>
<title>Can I throw a C++ exception from a structured exception?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Can I throw a C++ exception from a structured exception?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 28, 2017 / year-entry #172</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>20</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Technically okay, but it's unusual and doesn't solve your problem.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
A customer wanted to know if it was okay to throw a C++ exception
from a structured exception.
</p>
<p>
They explained that they didn't want to compile their project with
<a HREF="https://msdn.microsoft.com/en-us/library/1deeycx5.aspx">
the <code>/EHa</code> switch</a>,
which instructs the compiler
to use the exception-handling model that catches both asynchronous (structured)
exceptions
as well as synchronous (C++) exceptions.
In other words, the <code>catch</code> statement
will catch both explicitly thrown C++ exceptions
(raised by the <code>throw</code> statement)
as well as exceptions generated by the operating system,
either due to notifications from the CPU
(such as an access violation or divide-by-zero)
or explicit calls to <code>Raise&shy;Exception</code>.
</p>
<p>
The customer explained that they didn't want to use
<code>/EHa</code> because doing so significantly impairs
compiler optimizations and results in larger code size.
But on the other hand, they do want to catch the
asynchronous (structured) exceptions.
</p>
<p>
So they had a fiendish plan.
</p>
<p>
Their fiendish plan is to install an unhandled exception
filter which turns around and throws the C++ exception.
That way, a structured exception will result in a
standard C++ exception,
but without the code generation penalties of the
<code>/EHa</code> compiler option.
</p>
<pre>
// This clever function is an exception filter that converts
// asynchronous exceptions (structured exception handling)
// to synchronous exceptions (C++ exceptions).

LONG WINAPI CleverConversion(
    EXCEPTION_POINTERS* ExceptionInfo)
{
    
    auto record = ExceptionInfo-&gt;ExceptionRecord;

    std::string message;
    ... build a message based on the exception code and
    other parameters ...

    throw std::exception(message.c_str());
}

int sample_function(int* p)
{
    try {
        printf("About to dereference the pointer %p\n", p);
        return *p;
    } catch (std::exception&amp; e) {
        Log(e.what());
    }
    return 0;
}

int __cdecl main(int argc, char **argv)
{
    SetUnhandledExceptionFilter(CleverConversion);

    return sample_function(nullptr);
}
</pre>
<p>
Neat trick, huh?
All the benefits of <code>/EHa</code> without the overhead!
</p>
<p>
Well, except that they found that it didn't always work.
</p>
<p>
In the example above, the <code>catch</code> did catch
the C++ exception,
but if they took out the <code>printf</code>,
then the exception was not caught.
</p>
<pre>
int sample_function(int* p)
{
    try {
        return *p;
    } catch (std::exception&amp; e) {
        Log(e.what());          // exception not caught!
    }
    return 0;
}
</pre>
<p>
The customer wanted to know why the second version didn't work.
</p>
<p>
Actually the first version isn't guaranteed to work either.
It happens to work because the compiler must consider the
possibility that
the <code>printf</code> function might throw a C++ exception.
The <code>printf</code> function is not marked
as <code>noexcept</code>,
so the possibility is in play.
(Not that you'd expect it to be marked as such, seeing as
it's a C function, and C doesn't have exceptions.)
When the access violation is raised as a structured exception,
the <code>Clever&shy;Conversion</code> function turns it into
a C++ exception and throws it,
at which point the <code>try</code> block catches it.
But the <code>try</code> block is not there for the
<code>Clever&shy;Conversion</code> exception.
It's there to catch any exceptions coming out of
<code>printf</code>,
and you just happened to be lucky that it caught your
exception too.
</p>
<p>
In the second example, there is no call to <code>printf</code>,
so the compiler says,
"Well, nothing inside this <code>try</code> block can
throw a C++ exception, so I can optimize out the <code>try/catch</code>."
You would also have observed this behavior if there were
function calls inside the <code>try</code> block,
if the function calls were all to functions that were marked
<code>noexcept</code> or if the compiler could prove that they
didn't throw any C++ exceptions (say, because the function is inlined).
</p>
<p>
This answers the question, but let's try to look at the whole story.
</p>
<ol>
<li>We want to use <code>/EHa</code>.</li>
<li>But the documentation says that <code>/EHa</code>
    results in less efficient code.
    We want more efficient code, not less.</li>
<li>Aha, we found this trick that lets us convert
    asynchronous exceptions to synchronous ones.
    Now we get all the benefits of <code>/EHa</code>
    without any of the costs!</li>
</ol>
<p>
It looks like you found some free money on the ground,
but is it really free money?
</p>
<p>
The customer seems to think that
the <code>/EHa</code> option results in
less efficient code
simply because the compiler team is a bunch of jerks
and secretly hates you.
</p>
<p>
No, that's not why the <code>/EHa</code> option results
in less efficient code.
The possibility that any memory access or arithmetic
operation could trigger
an exception significantly impairs optimization
opportunities.
It means that all variables must be stable at
the point memory accesses occur.
</p>
<p>
Consider the following code fragment:
</p>
<pre>
class Reminder
{
public:
    Reminder(char* message) : m_message(message) { }
    ~Reminder() { std::cout &lt;&lt; "don't forget to "
                            &lt;&lt; m_message &lt;&lt; std::endl; }

    void UpdateMessage(char* message) { m_message = message; }

private:
    char* m_message;
};

void NonThrowingFunction() noexcept;
void DoSomethingElse(); // might throw

void sample_function()
{
    try {
        Reminder reminder("turn off the lights");
        if (NonThrowingFunction()) {
            reminder.UpdateMessage("feed the cat");
        }
        DoSomethingElse();
    } catch (std::exception&amp; e) {
        Log(e.what());
    }
}
</pre>
<p>
If compiling without <code>/EHa</code>,
the compiler knows that the
<code>Non&shy;Throwing&shy;Function</code>
function cannot throw a C++ exception,
so it can delay the store of <code>reminder.</code><code>m_message</code>
to just before the call to
<code>Do&shy;Something&shy;Else</code>.
In fact, it is like to do so because it avoids a redundant store.
</p>
<p>
The pseudo-code for this function might look like this:
</p>
<pre>
    allocate 4 bytes in local frame for reminder

l1:
    call NonThrowingFunction
    if result is zero
        load r1 = "turn off the lights"
    else
        load r1 = "feed the cat"
    endif
    store r1 to reminder.m_message
    call DoSomethingElse
l2:
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; r1 &lt;&lt; std::endl;
l3:

    clean up local frame
    return

if exception occurs between l1 and l2
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; reminder.m_message &lt;&lt; std::endl;
    fall through

if exception occurs between l2 and l3
    if exception is std::exception
        Log(e.what())
        goto l3
    else
        continue exception search
    endif
</pre>
<p>
Notice that we optimized out a redundant store
by delaying the initialization of
<code>reminder</code>,
and we enregistered <code>reminder.</code><code>m_message</code>
in the common code path.
Delaying the initialization of <code>reminder</code>
is not an optimization available to
<code>/EHa</code> because of the possibility that
<code>Non&shy;Throwing&shy;Function</code> might raise
an asynchronous exception that gets converted to a synchronous one:
</p>
<pre>
    allocate 4 bytes in local frame for reminder

<font COLOR=blue>l0:
    // cannot delay initialization of reminder
    load r1 = "turn off the lights"
    store r1 to reminder.m_message</font>

l1:
    call NonThrowingFunction
    <font COLOR=blue>if result is nonzero
        load r1 = "feed the cat"
        store r1 to reminder.m_message
    endif</font>
    call DoSomethingElse
l2:
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; r1 &lt;&lt; std::endl;
l3:

    clean up local frame
    return

if exception occurs between l1 and l2
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; reminder.m_message &lt;&lt; std::endl;
    fall through

<font COLOR=blue>// and there is a new exception region</font>
if exception occurs between <font COLOR=blue>l0 and l1</font>, or between l2 and l3
    if exception is std::exception
        Log(e.what())
        goto l3
    else
        continue exception search
    endif
</pre>
<p>
The extra code is necessary in order to ensure that
the <code>reminder</code> variable is in a stable state
before calling <code>Non&shy;Throwing&shy;Function</code>.
In general, if you turn on <code>/EHa</code>,
the compiler must ensure that every object which is
accessed outside the <code>try</code> block
(either explicitly in code or implicitly via an unwind destructor)
is stable in memory before performing any operation
that could result in an asynchronous exception,
such as accessing memory.
</p>
<p>
This requirement that variables be stable in memory
comes at a high cost,
because it not only forces redundant stores to memory,
but it also prohibits various types of optimizations
based on out-of-order operations.
</p>
<p>
The
<code>Clever&shy;Conversion</code>
is basically a manual replication of what
<code>/EHa</code> does,
but lying to the compiler and saying,
"Um, yeah, don't worry about asynchronous exceptions."
</p>
<p>
Observe what happens if an asynchronous exception occurs
inside
<code>Non&shy;Throwing&shy;Function</code>
even though you compiled without the <code>/EHa</code> flag:
</p>
<p>
We destruct the <code>reminder</code> object,
which means printing the <code>m_message</code> to
<code>std::</code><code>cout</code>.
But the non-<code>/EHa</code> version did not ensure
that <code>reminder.</code><code>m_message</code> was stable.
Indeed, if an exception occurs inside
<code>Non&shy;Throwing&shy;Function</code>,
we will try to print
<code>reminder.</code><code>m_message</code> anyway,
even though it is an uninitialized variable.
</p>
<p>
Printing an uninitialized variable is probably
not what the program intended.
</p>
<p>
So a more complete answer to the scenario is
"Yes, it is technically possible to throw a C++ exception
from a structured exception handler,
but doing so requires that the program be compiled
with <code>/EHa</code> in order to avoid undefined behavior."
</p>
<p>
And given that avoiding the <code>/EHa</code> flag was the
whole purpose of the exercise,
the answer to the specific scenario is,
"No, this doesn't work.
Your program will behave in undefined ways."</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (20)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1304115">
				<div id="div-comment-1304115" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Damien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304115">
			July 28, 2017 at 7:08 am</a>		</div>

		<p>I always wonder at the thought process behind this sort of thing. If option X has a performance penalty and you believe that option Y can achieve exactly the same as option X but at a fraction of the cost, shouldn&#8217;t you be wondering <i>why option X isn&#8217;t implemented as option Y already</i>?</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1304116">
				<div id="div-comment-1304116" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304116">
			July 28, 2017 at 7:19 am</a>		</div>

		<p>It seems to me they don&#8217;t care too much about process memory corruption and just want to run catch blocks and dtors during unwind.</p>
<p>If not for their example being what it was I would think they don&#8217;t care about access exceptions from their own code but only ones from Windows.</p>
<p>Expected useless followup: can I call longjump() in a n unhandled exception filter.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2 parent" id="comment-1304125">
				<div id="div-comment-1304125" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Antonio Rodríguez</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304125">
			July 28, 2017 at 8:03 am</a>		</div>

		<p>[Mediocre] people tend to underestimate other people&#8217;s work. You have already hear it: &#8220;this application worked in Windows XP, but Microsoft purposely broke the API in Windows 7&#8221;. Or another one, more than 20 years old by now: &#8220;Microsoft has some dark agreement with memory makers; I know that because Windows 95 requires more memory than Windows 3.1&#8221;. It&#8217;s like Microsoft engineers have a magic wand that allows to make new versions of Windows which add features without breaking compatibility or using more resources; but they choose not to use it. (I talk about Microsoft because of this blog&#8217;s policy of not talking about other companies&#8217; products, but Microsoft isn&#8217;t alone here, of course).</p>
<p>Similarly, many programmers seem to think that compiler optimizations are black magic, not unlike the mentioned magic wand, and that all you have to do is to wave it, say &#8220;bibidi babidi boo&#8221;, and&#8230; voilà! Instant magic! And look, without any side effects at all! If it doesn&#8217;t work, it surely is that engineers are fool or perverse (or both!).</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip odd alt depth-3 parent" id="comment-1304136">
				<div id="div-comment-1304136" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304136">
			July 28, 2017 at 9:12 am</a>		</div>

		<p>I also find that many programmers don&#8217;t understand optimisations and what they do.<br />
There is still a lot of people who think that the optimiser just gives out a more optimised version of what you put in, but it does exactly the same thing. They don&#8217;t seem to understand that what you get out behaves exactly the same, but is not required to actually do exactly the same thing.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-4" id="comment-1304166">
				<div id="div-comment-1304166" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304166">
			July 28, 2017 at 11:30 am</a>		</div>

		<p>&gt; There is still a lot of people who think that the optimiser just gives out a more optimised version of what you put in, but it does exactly the same thing.</p>
<p>Because it was once true. Among the first useful optimizations was &#8220;suppress redundant reloads&#8221;; but when it was new there was a switch to turn it off in case somebody was abusing undefined behavior as this was also the first one that radically changed what undefined behavior did.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt depth-4" id="comment-1304196">
				<div id="div-comment-1304196" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://nbtparse.org' rel='external nofollow' class='url'>Kevin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304196">
			July 28, 2017 at 3:39 pm</a>		</div>

		<p>Wikipedia has a surprisingly thorough set of articles about individual compiler optimizations (strength reduction, loop unswitching, etc.).  They&#8217;re very useful for disabusing people of this notion.</p>
<p>Or at least, I imagine that they are.  I haven&#8217;t actually tried using them for that purpose.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even depth-3" id="comment-1304275">
				<div id="div-comment-1304275" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xcomcmdr</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304275">
			July 31, 2017 at 1:16 am</a>		</div>

		<p>Or people who think that anti-virus editors make viruses in order to sell anti-virus solutions.</p>
<p>Or people that did not at all study or code Windows, but are convinced that Windows 95 is only a GUI for DOS, and that Windows 7 still has DOS as a kernel.</p>
<p>&#8220;Those people&#8221;. Ugh ! They are so ridiculous !</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt depth-2" id="comment-1304235">
				<div id="div-comment-1304235" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Aged .Net Guy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304235">
			July 29, 2017 at 11:51 am</a>		</div>

		<p>The other mistaken thought process I&#8217;ve encountered many times over the years is &#8230;</p>
<p>Goofy programmer: &#8220;The compiler inserts all that bloat because it needs that to protect against extreme corner cases and such. My plain vanilla code doesn&#8217;t use [insert level of API or coding tech I don&#8217;t understand] so I won&#8217;t be triggering whatever that bloat might be needed for.&#8221;</p>
<p>Doesn&#8217;t matter if the goof thinks the bloat is there to protect when using COM, or multithreading, or lambdas, or ATL or whatever.  It&#8217;ll always be something that A) the goof doesn&#8217;t understand, and B) the goof isn&#8217;t directly using in the small part of the complete executable he&#8217;s actually thinking about.  All bets are off as to the rest of the complete execution environment; it may be chock full of that stuff but it&#8217;s invisible to him (very, very occasionally her).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1304127">
				<div id="div-comment-1304127" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Voigt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304127">
			July 28, 2017 at 8:27 am</a>		</div>

		<p>The problem is the mindset that C++ language exceptions are &#8220;synchronous&#8221;, which unfortunately Raymond is repeating.</p>
<p>C++ exceptions are synchronous when the `throw` statement is reached from the thread entry point, and asynchronous when the `throw` statement is called in asynchronous context.  Structured exception handlers are a Win32 example of asynchronous context (but not the only one, you can also have code that does SuspendThread and then messes with the instruction pointer &#8212; I believe that .NET Thread.Abort() is an example).  Signal handlers are a POSIX example.</p>
<p>Now that we see that &#8220;C++ language exceptions only&#8221; is not sufficient to exempt us from asynchronous exceptions, we also know it&#8217;s not sufficient for turning off /EHa.</p>
<p>Ultimately though, this still fails to identify all cases where /EHa is needed, because /EHa is *also* critical if throwing exceptions across module boundaries.  Probably there ought to be a separate flag for forcing the use of OS exceptions.  And if both /EHa and the hypothetical /EHos trigger the same compiler behavior, so be it.  In the future they might not (In particular, when using /EHs /EHos it might be possible for the compiler to eliminate handlers when a try block contains only in-module noexcept calls, while still using OS infrastructure and handlers when calling foreign functions).</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-koldude odd alt depth-2" id="comment-1304137">
				<div id="div-comment-1304137" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304137">
			July 28, 2017 at 9:45 am</a>		</div>

		<p>Nitpickers Corner: This actually gets a LOT more complicated when you bring in the concept of coroutines, which are extremely asynchronous and the exception may not even be &#8220;caught&#8221; on the same thread it was thrown.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even depth-2" id="comment-1304265">
				<div id="div-comment-1304265" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Harry Johnston</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304265">
			July 30, 2017 at 3:05 pm</a>		</div>

		<p>On the face of it, it doesn&#8217;t seem reasonable for the programmer to expect C++ exceptions to work in an asynchronous context.  Is there some reason I&#8217;m not aware of, e.g., is it mentioned in the C++ standard, or the POSIX standard, perhaps?</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-koldude odd alt thread-even depth-1 parent" id="comment-1304135">
				<div id="div-comment-1304135" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/kantos' rel='external nofollow' class='url'>kantos</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304135">
			July 28, 2017 at 8:30 am</a>		</div>

		<p>Honestly Clang and GCC treat any function from the Cstdlib as <code>noexcept</code> which the standard allows, I&#8217;m honestly surprised that the Visual C++ libraries team didn&#8217;t just use a macro to support C++ and C on that matter. Or just let the compiler figure it out.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-2 parent" id="comment-1304247">
				<div id="div-comment-1304247" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Doug</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304247">
			July 29, 2017 at 7:08 pm</a>		</div>

		<p>Why, what a clever idea. I wonder why the MSVC compiler guys never thought of that. They must be very silly indeed.</p>
<p>Oh, wait, what is this /EHc compiler switch? I wonder what it does.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-martin-baschnegger odd alt depth-3" id="comment-1304855">
				<div id="div-comment-1304855" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Martin+Ba.+_' rel='external nofollow' class='url'>Martin Ba. _</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304855">
			August 2, 2017 at 3:14 am</a>		</div>

		<p>@Doug: Yeah, except that /EHsc marks *all* extern &#8220;C&#8221; Functions as noexcept, not just the standard library. Quite the difference, if you ask me. Being able to use /EHs (w/o &#8216;c&#8217;) and still benefiting from the static knowledge that the myriad of cstdlib functions won&#8217;t ever throw a C++ exception could be a good thing &#8212; because you&#8217;r C-Interface libraries or other third party C-Api wrappers very well might.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1304176">
				<div id="div-comment-1304176" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andre</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304176">
			July 28, 2017 at 1:10 pm</a>		</div>

		<p>I seem to remember reading somewhere (the official docs, Raymond&#8217;s blog, not sure) that using /EHa is a bad idea. I&#8217;m not quite sure why, maybe because you can wrongly handle things like guard pages or because you catch things you should never catch at all, like access violations.</p>
<p>Do I remember this wrong or does anybody have details? Of course you could argue &#8220;if that were the case, surely this feature wouldn&#8217;t even exist&#8221;, but the answer to that is probably &#8220;compatibility&#8221;.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-2" id="comment-1304215">
				<div id="div-comment-1304215" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">M Hotchin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304215">
			July 29, 2017 at 12:48 am</a>		</div>

		<p>People using /EHa are tempted to use &#8216;catch (&#8230;)&#8217;.  This eats exceptions that are used by the OS for things like growing your stack.<br />
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20060927-07/?p=29563" rel="nofollow">https://blogs.msdn.microsoft.com/oldnewthing/20060927-07/?p=29563</a></p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1304205">
				<div id="div-comment-1304205" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ivan K</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304205">
			July 28, 2017 at 11:07 pm</a>		</div>

		<p>Hopefully  fancy logging api can capture and log those fancy exceptions shmexceptions for posterity.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-1304225">
				<div id="div-comment-1304225" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Neil</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304225">
			July 29, 2017 at 4:37 am</a>		</div>

		<p>The linked page says, &#8220;you can’t mix the SEH syntax with try, throw, and catch in the same function&#8221;. So can you not even &#8220;protect&#8221; against a structured exception from e.g. a call to a specific third-party library?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip even depth-2" id="comment-1304245">
				<div id="div-comment-1304245" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304245">
			July 29, 2017 at 6:30 pm</a>		</div>

		<p>You can, but since most SEH exceptions that you would catch with the try/except or try/finally syntax are going to be things like STATUS_ACCESS_VIOLATION or STATUS_GUARD_PAGE_VIOLATION. So the question is why would you want to handle those?<br />
If for some reason the third party library is using SEH to raise exceptions that you would want to catch, notice that it says in the same function? You can catch both types if you go through to different functions.<br />
But here is one thing to remember about C++ exceptions, besides bad libraries, they are used mostly in exceptional situations. So the majority of my exception handling is a try/catch block out not that far away from my main function. All it does is catch the error, log details and then exits the process. It is best to do this since you will be getting the exception closest to the error, and lets face it, if you are getting exceptions thrown about memory allocation failure, or bounds errors or other things like that, something has messed up with your application and you don&#8217;t want it to continue.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment odd alt thread-even depth-1" id="comment-1304257">
				<div id="div-comment-1304257" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20170728-00/?p=96706#comment-1304257">
			July 30, 2017 at 7:05 am</a>		</div>

		<p>BTW, there is special C function that intentially created to translate SEH to C++ exceptions: _set_se_translator<br />
I believe its better to be used for such purpose than plain SEH filter.<br />
However its documentation clearly requires using of /EHa that also should hint potential revolutionaries that SetUnhandledExceptionFilter may be not so good as they expect..</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

