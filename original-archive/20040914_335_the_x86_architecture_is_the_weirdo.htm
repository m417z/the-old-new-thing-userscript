<html>
<head>
<title>The x86 architecture is the weirdo</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>The x86 architecture is the weirdo</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>September 14, 2004 / year-entry #336</td></tr>
<tr><td><b>Tags:</b></td><td>other</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>67</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">The x86 architecture does things that almost no other modern architecture does, but due to its overwhelming popularity, people think that the x86 way is the normal way and that everybody else is weird. Let's get one thing straight: The x86 architecture is the weirdo. The x86 has a small number (8) of general-purpose registers;...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>The x86 architecture does things that almost no other modern architecture does, but due to its overwhelming popularity, people think that the x86 way is the normal way and that everybody else is weird.</p>
<p> Let's get one thing straight: The x86 architecture is the weirdo. </p>
<p> The x86 has a small number (8) of general-purpose registers; the other modern processors have far more. (PPC, MIPS, and Alpha each have 32; ia64 has 128.) </p>
<p> The x86 uses the stack to pass function parameters; the others use registers. </p>
<p> The x86 forgives access to unaligned data, silently fixing up the misalignment. The others raise a misalignment exception, which can optionally be emulated by the supervisor at an amazingly huge performance penalty. </p>
<p> The x86 has variable-sized instructions. The others use fixed-sized instructions. (PPC, MIPS, and Alpha each have fixed-sized 32-bit instructions; ia64 has fixed-sized 41-bit instructions.  Yes, 41-bit instructions.) </p>
<p> The x86 has a strict memory model, where external memory access matches the order in which memory accesses are issued by the code stream. The others have weak memory models, requiring explicit memory barriers to ensure that issues to the bus are made (and completed) in a specific order. </p>
<p> The x86 supports atomic load-modify-store operations. None of the others do. </p>
<p> The x86 passes function return addresses on the stack. The others use a link register. </p>
<p> Bear this in mind when you write what you think is portable code. Like many things, the culture you grow up with is the one that feels "normal" to you, even if, in the grand scheme of things, it is one of the more bizarre ones out there. </p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (67)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-210053">
				<div id="div-comment-210053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210053">
			September 14, 2004 at 8:22 am</a>		</div>

		<p>&quot;The x86 architecture does things that almost no other modern architecture does&quot;<br />
<br />x86 is not a modern architecture, though.  It should be compared to things like VAX and 68K.  Through a quirk of history it&#8217;s happened to live on, but it&#8217;s still not modern.  Its implementations might be, of course, but the ISA is prehistoric.</p>
<p>&quot;The x86 supports atomic load-modify-store operations. None of the others do. &quot;<br />
<br />What is fetchadd on Itanium?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210063">
				<div id="div-comment-210063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210063">
			September 14, 2004 at 8:23 am</a>		</div>

		<p>Very enlightening.  I wonder what the security implications of some of these differences are.  For example, if return addresses are in registers rather than on the stack, then would a buffer overflow bug be much harder to exploit?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210073">
				<div id="div-comment-210073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210073">
			September 14, 2004 at 8:27 am</a>		</div>

		<p>&quot;The x86 uses the stack to pass function parameters; the others use registers.&quot;<br />
<br />How would you pass more than 32 (less the number of registers you can&#8217;t use; there&#8217;s a zero register for instance) arguments to a function?</p>
<p>x86 spills to stack more often than other architectures (not enough architectural registers), but it&#8217;s not mandatory.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210083">
				<div id="div-comment-210083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210083">
			September 14, 2004 at 8:30 am</a>		</div>

		<p>Rats I missed fetchadd.</p>
<p>For the details on parameter passing, I refer readers to my earlier series on calling conventions. Typically, excess parameters are spilled onto the stack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210093">
				<div id="div-comment-210093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">blahblahblah</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210093">
			September 14, 2004 at 8:32 am</a>		</div>

		<p>&quot;How would you pass more than 32&#8230;arguments to a function?&quot;</p>
<p>Maybe one register could hold the starting location of the argument list and another holds the number of arguments&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210103">
				<div id="div-comment-210103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210103">
			September 14, 2004 at 8:32 am</a>		</div>

		<p>I was about to post about how some older processors I dealt with in my younger days supported the things you say that only x86 does, but DrPizza already did that.</p>
<p>Of course, the system I spent most of my time worrying about these kinds of things on &#8212; the Commodore 64 with a Motorola 6502 chip &#8212; was 8-bit anyway, so alignment was never much of a problem! It did (sort of) come up with indirect addressing, because then it needed a 16-bit value which IIRC couldn&#8217;t straddle a page boundry since the address would overflow and you&#8217;d end up with the value at the start of the current page rather than the next one. Indexed indirect made things even more interesting, because even if you were 16-bit aligned the index offset couldn&#8217;t cross a page boundary. (Apologies if I got any of this wrong. It&#8217;s been a long time since I&#8217;ve had to think about this stuff.)</p>
<p>These days I tend to stick to high-level languages (with an appropriate amount of concern for issues like alignment) so I don&#8217;t know a great deal about more modern CPUs, but it&#8217;s still interesting so it&#8217;s nice to hear from someone who does.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210113">
				<div id="div-comment-210113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.kernelmustard.com' rel='external nofollow' class='url'>Steve Dispensa</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210113">
			September 14, 2004 at 8:39 am</a>		</div>

		<p>There are situations on x86 where an explicit memory barrier of some sort is needed.</p>
<p><a target="_new" href="http://www.microsoft.com/whdc/driver/kernel/MPmem-barrier.mspx" rel="nofollow">http://www.microsoft.com/whdc/driver/kernel/MPmem-barrier.mspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210123">
				<div id="div-comment-210123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210123">
			September 14, 2004 at 8:43 am</a>		</div>

		<p>DrPizza: Calling conventions generally allow only 4-6 arguments to be passed in registers; beyond that, they&#8217;re placed on the stack.</p>
<p>Adrian: The return address may still have to be stored on the stack in a non-leaf function, since there is only one link register. However the link register and the abundance of registers which the return address can be moved to reduce the number of target functions somewhat.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210133">
				<div id="div-comment-210133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mailto:chrisc@meldstar.com' rel='external nofollow' class='url'>Christopher S. Charabaruk</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210133">
			September 14, 2004 at 8:44 am</a>		</div>

		<p>Ben: The 6502 was produced by MOS Technology/Commodore Semiconductor Group, not by Motorola. MOS was the company that made mask fixing commonplace.</p>
<p>I&#8217;ve written on both MOS and CBM on Everything2. Perhaps not the most accurate articles I&#8217;ve written, and not on the best site for info, but dead-tree information sources pretty much back me up.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210143">
				<div id="div-comment-210143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://mailto:chrisc@meldstar.com' rel='external nofollow' class='url'>Christopher S. Charabaruk</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210143">
			September 14, 2004 at 8:45 am</a>		</div>

		<p>BTW, that&#8217;s to Ben Cooke.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210173">
				<div id="div-comment-210173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.honestillusion.com' rel='external nofollow' class='url'>James Curran</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210173">
			September 14, 2004 at 9:32 am</a>		</div>

		<p>Though, many of the odd behaviors of the x86 are improvements over the even odder behaviors of even older machine which these &quot;modern&quot; chips are going back to.</p>
<p>IBM 360s passed parameters via registers and used a return link register because they just didn&#8217;t have a stack.  (Return link registers make nested calls tough, and recursive calls very tough)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210183">
				<div id="div-comment-210183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.accidentalscientist.com' rel='external nofollow' class='url'>Simon Cooke [exMSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210183">
			September 14, 2004 at 9:36 am</a>		</div>

		<p>Ben: are you sure that wasn&#8217;t the 6509 or the 6510? :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210193">
				<div id="div-comment-210193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cooney</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210193">
			September 14, 2004 at 9:43 am</a>		</div>

		<blockquote><p>
  Though, many of the odd behaviors of the x86 are improvements over the even odder behaviors of even older machine which these &quot;modern&quot; chips are going back to. </p>
<p>Also remember that the x86, with its myriad addressing modes, reflected a different philosophy to the other risc architectures. I seem to recall something about the relative speed of memory favoring CISC more heavily back when the x86 was first designed.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210203">
				<div id="div-comment-210203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210203">
			September 14, 2004 at 10:00 am</a>		</div>

		<p>Cooney: And now x86 assembly language turns out to be a reasonably good compact byte-code for a hardware JITter feeding a RISC-like core.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210213">
				<div id="div-comment-210213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210213">
			September 14, 2004 at 10:00 am</a>		</div>

		<p>(Uh, machine code, not assembly language.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210243">
				<div id="div-comment-210243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210243">
			September 14, 2004 at 10:43 am</a>		</div>

		<p>&quot;DrPizza: Calling conventions generally allow only 4-6 arguments to be passed in registers; beyond that, they&#8217;re placed on the stack. &quot;<br />
<br />Which makes them much like x86, then.</p>
<p>Spilling to the stack is used by pretty much all architectures.  And presumably the return value must be stored somewhere other than a register, because you want to make calls more than one function deep.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210253">
				<div id="div-comment-210253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">dce</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210253">
			September 14, 2004 at 10:58 am</a>		</div>

		<p>I don&#8217;t know how many are currently used, but back in the early days, MIPS machines passed the first 3 function arguments in registers, and all the rest were passed on the stack. I remember having to modify a number of Unix commands and libraries to handle varargs properly (well, &quot;properly&quot; isn&#8217;t really correct, since what the early MIPS compilers did was not ANSI standard).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210263">
				<div id="div-comment-210263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210263">
			September 14, 2004 at 11:02 am</a>		</div>

		<p>That&#8217;s the problem.  In pre-prototype (K&amp;R) C, all functions must be assumed to be varargs functions, and that&#8217;s hard if you don&#8217;t pass arguments in the stack.  Newer architectures have the benefit of prototypes, so can default to calling conventions that pass on the stack only when they have to (through spillage) or when using varargs.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210273">
				<div id="div-comment-210273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David the Formerly Irked</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210273">
			September 14, 2004 at 11:05 am</a>		</div>

		<p>DrPizza: It&#8217;s been forever and a day since I&#8217;ve done any asm, but that doesn&#8217;t seem like a problem to me. Since only one function is returning at any one time, all functions can store their return values in the same register without trouble.</p>
<p>I seem to recall that one common calling convention for real-mode x86 involves storing the return value in AX.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210283">
				<div id="div-comment-210283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lowercase josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210283">
			September 14, 2004 at 11:09 am</a>		</div>

		<p>How do you do locks without atomic load-modify-store?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210303">
				<div id="div-comment-210303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210303">
			September 14, 2004 at 11:22 am</a>		</div>

		<p>josh: There are two alternatives I know of.</p>
<p>The most common is the CAS (Compare And Set) instruction. Its parameters are a memory address, an expected value and a new value. It atomically loads from the memory address and then stores the new value if the current value matches the expected value. It sets a condition flag indicating what happened.</p>
<p>The other is LL/SC (Load Linked, Store Conditional). These are two separate instructions. LL atomically loads from a memory address and remembers the address. SC stores a new value to that address so long as it is known not to have been modified since the LL. (False positives are possible; the granularity of modification tracking is unspecified but is likely to match the cache line size.)</p>
<p>You can implement a generalised load-modify-store by looping through atomic-load, modify, CAS or LL, modify, SC until the CAS or SC succeeds.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210313">
				<div id="div-comment-210313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210313">
			September 14, 2004 at 12:07 pm</a>		</div>

		<p>Clearly everyone else has better memories than me. Writing Motorola was a brain fart since I was thinking at the same time about the 68000 series that DrPizza mentioned. I have here somewhere data sheets from Commodore Semiconductor Group about the CPU in the Commodore 64 although they&#8217;re buried somewhere in my big heap of old stuff in my attic.</p>
<p>Simon Cooke (too many similar names around here &#8211; I overlap with two people!) mentioned two other model numbers that I remember from somewhere, so now I&#8217;m left trying to remember what I remember each one from.</p>
<p>I know I&#8217;ve dealt with a 6502 and a 6510 at some point, but I can&#8217;t remember which numbers go with which things. (or maybe I&#8217;m confusing myself with non-CPU chip numbers from the same period)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210323">
				<div id="div-comment-210323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.rotd.org/' rel='external nofollow' class='url'>Andreas Magnusson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210323">
			September 14, 2004 at 12:30 pm</a>		</div>

		<p>Wasn&#8217;t 6510 used in the C64? And isn&#8217;t 6502 just an older version of it?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210333">
				<div id="div-comment-210333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">James Summerlin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210333">
			September 14, 2004 at 12:57 pm</a>		</div>

		<p>Raymond,</p>
<p>I would like to state that I think we are witnessing one of those moments where it is good to be the weirdo.</p>
<p>James</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210353">
				<div id="div-comment-210353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Isaac Lin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210353">
			September 14, 2004 at 1:39 pm</a>		</div>

		<p>6502 was used on VIC-20 (and Apple II, and<br />
<br />a number of others, as I recall). 6510 was<br />
<br />used on Commodore 64.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210363">
				<div id="div-comment-210363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://spacebunny.xepher.net/' rel='external nofollow' class='url'>KJK::Hyperion</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210363">
			September 14, 2004 at 1:50 pm</a>		</div>

		<p>Don&#8217;t forget SEH. On the x86, because of the unreliable unwinding, SEH requires registrations (small objects allocated on the stack and chained in a single-link list) to associate frame handlers. On all other architectures, there&#8217;s a single calling convention, so unwinding is always reliable and the system can get the frame handler simply by matching  the program counter against a table</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210373">
				<div id="div-comment-210373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Keith Moore [exmsft]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210373">
			September 14, 2004 at 2:20 pm</a>		</div>

		<p>Years ago I read a (DDJ? Byte?) magazine article in which the author referred to the x86 architecture as a &quot;code museum&quot; for its layers of &quot;architectural history&quot;.</p>
<p>I always liked this term.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210393">
				<div id="div-comment-210393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.codeproject.com/script/articles/list_articles.asp?userid=152' rel='external nofollow' class='url'>Mike Dunn</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210393">
			September 14, 2004 at 3:59 pm</a>		</div>

		<p>Don&#8217;t forget the 8502 in the C=128, with its fast mode.  &quot;Fast&quot; being a blazing 2 MHz. ;)`</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210153">
				<div id="div-comment-210153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">asdf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210153">
			September 14, 2004 at 9:14 am</a>		</div>

		<p>Don&#8217;t forget the FPU stack *shudder*.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210403">
				<div id="div-comment-210403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mpz</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210403">
			September 14, 2004 at 4:46 pm</a>		</div>

		<p>On the other hand, with x86-64 x86 is getting rid of some of the worst stuff. For example the low number of general purpose registers. Also, I remember reading that at least in Windows, usage of x87/MMX/3DNow! has been obsoleted in favor of SSE/SSE2 (only SSE registers are saved in context switches or something?) so assuming x86-64 programs become popular, x86 chip makers can decrease the amount of resources for obsolete specialty instructions in the future.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210413">
				<div id="div-comment-210413" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210413">
			September 14, 2004 at 5:47 pm</a>		</div>

		<p>&quot;DrPizza: It&#8217;s been forever and a day since I&#8217;ve done any asm, but that doesn&#8217;t seem like a problem to me. Since only one function is returning at any one time, all functions can store their return values in the same register without trouble. &quot;<br />
<br />But what do they put back into the register when they return?</p>
<p>Say you&#8217;re at 0x100 and you call a function foo at 0x200 and you have 4 byte instructions.  The return value will be presumably 0x104.  Say foo+0x08 then calls a function bar.  You duly set the return value register to 0x20c and execute bar.  bar returns to 0x20c.  Now what gets put into the return value register?  How does it know where to return to?</p>
<p>The caller&#8217;s return value must be preserved across function calls, which means it&#8217;s got to be put somewhere other than a register, and surely that place is the stack.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210423">
				<div id="div-comment-210423" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210423">
			September 14, 2004 at 5:50 pm</a>		</div>

		<p>DrPizza: I think you&#8217;re confusing return address and return value.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210293">
				<div id="div-comment-210293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steven C.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210293">
			September 14, 2004 at 11:16 am</a>		</div>

		<p>A nitpick:</p>
<p>* PPC  has variable length instructions (VLE &#8212; 2 byte instructions).<br />
<br />* MIPS is god&#8217;s revenge on  debuggers, as there are 16- 32- and 64- bit modes (although the latter is just a register issue and still has 32bit instructions). IIRC, functions can be either 16bit or 32bit ABI mode, and both can appear in the same compiled item.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210383">
				<div id="div-comment-210383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://hoogervorst.dyndns.org/~alfons/weblog/archives/2004_09.html#001319' rel='external nofollow' class='url'>Stuff That Breaks My Flow</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210383">
			September 14, 2004 at 6:38 pm</a>		</div>

		<p>Raymond Chen has a nice entry about the weird x86 architecture. Don&#8217;t miss the references to memory barriers in the feedback!&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210453">
				<div id="div-comment-210453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210453">
			September 14, 2004 at 6:52 pm</a>		</div>

		<blockquote><p>
  The x86 architecture is the weirdo.</p>
<p>Yes, but that&#8217;s because of 30 years of backwards compatibility to the days when micros were micros.  Single-chip or double-chip CPUs didn&#8217;t act as orthogonally as multi-board CPUs did, because 2-dimensional layouts didn&#8217;t yet allow hardware designers to do everything they wanted to do.</p>
<p>&gt; The x86 forgives access to unaligned data</p>
<p>Now that is actually a benefit which other architectures would do well to copy.  Architectures which require alignment are often slower.  When exceptions do not occur and do not need fixing up, it is because programs or compiler-generated code have called memcpy() to make aligned copies of operands and will call memcpy() again to copy the results to where they&#8217;re needed.</p>
<p>Until the day that internet packets automatically get their contents aligned differently depending on what kind of architecture is going to read them, and disk files get their contents realigned, and the layouts of .BMP and other structures get dynamic realignments, unaligned data will have to be worked with one way or another.  Hardware can do it faster.</p>
<p>By the way, mainframes also provided a limited amount of atomic operations in hardware before the x86 existed.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210483">
				<div id="div-comment-210483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tim Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210483">
			September 14, 2004 at 7:37 pm</a>		</div>

		<p>Norman,</p>
<p>I have run into very few applications where I needed to use memcpy deal with poorly aligned structures.  When the code is properly written, alignment is usually not an issue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210493">
				<div id="div-comment-210493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210493">
			September 14, 2004 at 8:30 pm</a>		</div>

		<p>Although Raymond&#8217;s description of the instruction set modern x86 processors accept is correct, it isn&#8217;t actually what the chips have.  For example the underlying hardware has quite a few more registers and is far more like a RISC chip.  The x86 instructions are converted into the &quot;RISC&quot; instructions.  Additionally by analysing register usage and data dependencies it is possible to make use of the extra registers.</p>
<p>There is an excellent talk by Bob Colwell that I highly recommend watching.  It is the 7th item on <a target="_new" href="http://www.stanford.edu/class/ee380/winter-schedule-20032004.html" rel="nofollow">http://www.stanford.edu/class/ee380/winter-schedule-20032004.html</a></p>
<p>(Click on the camera thingy on the right)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210513">
				<div id="div-comment-210513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox [MS]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210513">
			September 14, 2004 at 10:17 pm</a>		</div>

		<p>In response to some of the comments in favor of x86, in particular the observations that automatic alignment fixup is handy and that under the hood the x86 has a multi-register architecture I would make the following observation in reply:</p>
<p>Sure. But it wastes a ton of silicon making all that happen.</p>
<p>More modern architectures can have smaller dies for the same computing power, which means lower power consumption and less cooling requirements. If those processors were produced in the same quantities as x86&#8217;s they&#8217;d be cheaper too.</p>
<p>There is a reason that most embedded applications don&#8217;t use x86.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210533">
				<div id="div-comment-210533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous Coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210533">
			September 14, 2004 at 10:56 pm</a>		</div>

		<p>With every process shrink the amount of chip real estate devoted to the x86 decoder goes down as a proportion of the whole chip.  It also turns out that many of the modern RISC chips take a similar approach as well (they also have decades of legacy instructions) although it isn&#8217;t quite to the same degree.</p>
<p>As for power/cooling, it is perfectly possible to make cheaper chips that do x86 instructions and meet those targets.  See Via and Transmeta.  Intel just happen to optimise for performance and marketing at the expense of power and cooling.  (They spent $300m on the initial marketing for the Pentium 4 in 2001.)</p>
<p>Even looking at the ARM (a favourite in the embedded space), there are other design goals (eg code density with the thumb extensions).</p>
<p>For anyone who is interested in this low level chip stuff, I highly recommend the comp.arch newsgroup.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210563">
				<div id="div-comment-210563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Stokes</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210563">
			September 15, 2004 at 12:35 am</a>		</div>

		<p>James Curran: &quot;IBM 360s passed parameters via registers and used a return link register because they just didn&#8217;t have a stack. (Return link registers make nested calls tough, and recursive calls very tough)&quot; </p>
<p>&quot;Passed&quot;? 360 architecture is still alive and well, although it&#8217;s now called zArchitecture (via S/370 and ESA/390). You can still happily run OS/360 Programs on the latest z/OS, that&#8217;s compatibility that Windows programmers can only dream of. But it&#8217;s true there was no stack, until S/370 and all later generations. The stack however is a bit different to what most programmers expect, since you can&#8217;t allocate areas for local variables, parameter lists and so on, only hardware registers and return addresses are saved, and normally  instructions do not reference the stack. OTOH it has a few tricks up its sleeve like allowing subroutine linkage over calls which transfer control synchronously to code in other address spaces.</p>
<p>But we never had problems calling nested or recursive routines anyway since most programs use a simple call convention established by the OS.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210583">
				<div id="div-comment-210583" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Kyle Oppenheim</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210583">
			September 15, 2004 at 2:04 am</a>		</div>

		<p>In regards to Tony&#8217;s comment that a lot of silicon is wasted on alignment and register renaming, there is actually an interesting trade-off in x86&#8217;s favor.  Additional registers can be added to the micro-architecture without changing the ISA.  So, newer generation chips (when silicon real estate is cheaper) can reduce register contention w/o the need of recompiling any code.  Also, as pipeline depth, branch prediction, and other micro-architectural changes are made between chip generations, recompiles aren&#8217;t necessary to avoid register dependency conflicts.  The hardware can find more instruction level parallelism that the compiler could (since the compiler was years older).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210473">
				<div id="div-comment-210473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve P</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210473">
			September 14, 2004 at 7:27 pm</a>		</div>

		<p>DrPizza: Yes, you are right in that something needs to store the return address *somewhere*. That may be the stack, or you could have register windows.</p>
<p>Register windows give you access to only a certain number of registers at a time &#8211; say, 32 out of 512. When you enter a function you tell it you need &#8216;n&#8217; registers, and they get shifted to make room.</p>
<p>Eventually, you may spill out the other end, but the worst case for that is as bad as storing on the stack anyway.</p>
<p>Now, a disclaimer.</p>
<p>I don&#8217;t know whether any processor actually uses this technique &#8211; this is merely a vague recollection from my university days. But it sounds pretty clever. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210593">
				<div id="div-comment-210593" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DrPizza</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210593">
			September 15, 2004 at 2:27 am</a>		</div>

		<p>&quot;DrPizza: I think you&#8217;re confusing return address and return value. &quot;<br />
<br />No, I just miswrote &quot;value&quot; when I meant &quot;address&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210603">
				<div id="div-comment-210603" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210603">
			September 15, 2004 at 3:19 am</a>		</div>

		<p>KJK::Hyperion: the mixture of calling conventions on x86 isn&#8217;t a fundamental property of the architecture, it&#8217;s just how Windows does things (because back in the day, it increased performance). Modern Linux uses only one calling convention for instance, and has a table based exception dispatch ABI.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210613">
				<div id="div-comment-210613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210613">
			September 15, 2004 at 4:17 am</a>		</div>

		<p>Quote:<br />
<br />Until the day that internet packets automatically get their contents aligned differently depending on what kind of architecture is going to read them, and disk files get their contents realigned, and the layouts of .BMP and other structures get dynamic realignments, unaligned data will have to be worked with one way or another. Hardware can do it faster.</p>
<p>Even on an architecture without aligment fixups, it&#8217;s still possible to access unaligned structure members. The compiler might need an __unaligned qualifier or might do it automatically &#8211; you just end up with breaking an unaligned access into two aligned accesses and some shifts, which is probably as fast as hardware could do it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210503">
				<div id="div-comment-210503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom Kirby-Green</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210503">
			September 14, 2004 at 9:50 pm</a>		</div>

		<p>For all it&#8217;s uglyness x86 survives because as someone once put it: &quot;x86 *owns* the binary&quot;.</p>
<p>On a related note, anyone clocked this?</p>
<p>  <a target="_new" href="http://www.wired.com/news/technology/0,1282,64914,00.html" rel="nofollow">http://www.wired.com/news/technology/0,1282,64914,00.html</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210633">
				<div id="div-comment-210633" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Hutchings</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210633">
			September 15, 2004 at 6:42 am</a>		</div>

		<p>Steve P: Register windows aren&#8217;t just theoretical. SPARC has fixed-size register windows. IA64 has variable-size register windows, as described in <a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2004/01/13/58199.aspx" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2004/01/13/58199.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210683">
				<div id="div-comment-210683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DavidK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210683">
			September 15, 2004 at 7:54 am</a>		</div>

		<p>Greetings,</p>
<p>Quote:<br />
<br />Until the day that internet packets automatically get their contents aligned differently depending on what kind of architecture is going to read them, and disk files get their contents realigned, and the layouts of .BMP and other structures get dynamic realignments, unaligned data will have to be worked with one way or another. Hardware can do it faster.</p>
<p>&#8212;<br />
<br />&#8212; </p>
<p>I think internet datapackets is an orthogonal issue.</p>
<p>1) As far as I know, alignment issues are only for certain primitive data types, for example, integer. You can read a character on any alignment.</p>
<p>2) Packing of C structures are handled for you automatically. So if you have a structure with a 3 byte character array followed by an integer, the compiler will pad the structure so that the integer is placed on the proper alignment.</p>
<p>Therefore binary data that you write out to disk will be properly aligned when you read it back. </p>
<p>3) As far as I know, unaligned data access on x86 is slower than aligned access. So in fact, if your goal is speed, alignment is a good thing. As far as internet data packets, if you look at many of the low level TCP/IP sockets structures, they are padded with dummy bytes to make alignment work.</p>
<p>Also, when I do low level TCP/IP communications, as data is received on a socket, it gets copied into the approriate data structures. If it was a on machine that required alignment, since my structures are aligned for me, by the compiler, everything works.</p>
<p>Regards,</p>
<p>Dave</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210693">
				<div id="div-comment-210693" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://Davidk' rel='external nofollow' class='url'>DavidK</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210693">
			September 15, 2004 at 7:58 am</a>		</div>

		<p>Data Alignment, one more thing</p>
<p>I forgot to mention that the C library routine, malloc, also pads out any memory it returns so that you are guaranteed alignment.</p>
<p>If you request one byte, the chunk you get will be larger than one byte, it will be padded to the next alignment size. That is why lots of small malloc requests are inefficient.</p>
<p>Take a look at the back of the K&amp;R C book where it discusses malloc. Your requested memory chunk size is multiplied and rounded to ensure proper alignment.</p>
<p>Regards,</p>
<p>Dave</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210713">
				<div id="div-comment-210713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tony Cox [MS]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210713">
			September 15, 2004 at 10:17 am</a>		</div>

		<p>Also observe that the SSE extensions to x86 also have alignment restrictions and the instructions raise exceptions if used on unaligned data. There is a special unaligned move instruction if you really need it, but it&#8217;s slower than the regular aligned move instruction, and you have to explicitly choose to use it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210743">
				<div id="div-comment-210743" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">lowercase josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210743">
			September 15, 2004 at 10:35 am</a>		</div>

		<p>Ben Hutchings:  I was assuming CAS would count as load-modify-store, which apparently it doesn&#8217;t. :/  (I mean you&#8217;re loading a value, performing an arithmetic operation, and then potentially storing a different value back&#8230;)  LL/SC is an interesting concept that I was not aware of.  Thanks for the explanation.  :)</p>
<p>mpz:  I don&#8217;t know about SSE, but x87/MMX/3DNow! registers can be swapped on demand.  You can skip saving them on a context switch and only save when another thread actually tries to use them.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210623">
				<div id="div-comment-210623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ben Cooke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210623">
			September 15, 2004 at 4:34 am</a>		</div>

		<p>Isaac, Mike:</p>
<p>Ahh, the VIC-20. That would have been where I encountered the 6502. I&#8217;m glad there are lots of people with good memories around here to set me straight: I won&#8217;t make *that* mistake again! :)</p>
<p>I never had the pleasure of owning a C128, but I remember that they were quite nutty machines. Didn&#8217;t they also have a second processor inside for running CP/M or something? I remember a friend showing me how he could boot either the Commodore 128&#8217;s own kernel, the C64&#8217;s kernel (and presumably use some other hardware borrowed from the C64) and with the help of a floppy disk also boot CP/M and change into a high-resolution text mode to make it more usable. (40&#215;25 isn&#8217;t very much for a real command-line OS, of course.)</p>
<p>I jumped straight from C64 to Amiga, though, and aside from a small amount of tinkering I never did much &quot;real programming&quot; of the 68k chip in my A500. Instead, I learned a bunch of high-level languages enventually learning C for the first time. Those were the days. :)<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210793">
				<div id="div-comment-210793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Andrew</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210793">
			September 15, 2004 at 12:37 pm</a>		</div>

		<p>[QUOTE]<br />
<br />That may be the stack, or you could have register windows&#8230;  I don&#8217;t know whether any processor actually uses this technique.<br />
<br />[/QUOTE]</p>
<p>According to Raymond&#8217;s earlier entries on calling conventions, it sounds like IA-64 does something along those lines:</p>
<p><a target="_new" href="http://weblogs.asp.net/oldnewthing/archive/2004/01/13/58199.aspx" rel="nofollow">http://weblogs.asp.net/oldnewthing/archive/2004/01/13/58199.aspx</a></p>
<p>Regarding SSE instructions, Tony Cox already mentioned that they have alignment restrictions that are not fixed up by the hardware.  Specifically, the data needs to be 16-byte aligned.  I&#8217;ve found _aligned_malloc to be quite handy in this regard.  As far as favoring SSE due to context switching rules, I don&#8217;t know.  And since there&#8217;s been a lot of talk about register usage, I think the VC++ .NET compiler will make use of SSE registers to pass parameters if certain optimizations are enabled (not sure though).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210813">
				<div id="div-comment-210813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210813">
			September 15, 2004 at 1:08 pm</a>		</div>

		<p>SSE/2 registers need &#8216;special&#8217; operating system support to be saved across context switches (fxsave).  MMX overlaps with the floating point registers so anything that saves floating point states across context switches (fsave/fnsave) will automagically save MMX states.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210863">
				<div id="div-comment-210863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Fred</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210863">
			September 15, 2004 at 8:35 pm</a>		</div>

		<p>Just wanted to add: the 6502 was used in the original C64, the 6510 was used for the slightly revamped C64-C.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-210853">
				<div id="div-comment-210853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210853">
			September 15, 2004 at 7:26 pm</a>		</div>

		<p>A minor nit: a typical malloc implementation reserves extra memory if needed to ensure that the *next* request is correctly aligned.</p>
<p>It might be argued that on an architecture like x86 which allows unaligned memory access, a conforming malloc implementation could ignore alignment entirely. I&#8217;m not much of a language lawyer, but &quot;correctly aligned&quot; could be taken to mean &quot;aligned so as to be accessible without crashing&quot;. In practice, I&#8217;d be shocked to see a malloc implementation which imposes such a performance penalty.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-210983">
				<div id="div-comment-210983" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">js</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-210983">
			September 16, 2004 at 8:27 am</a>		</div>

		<p>Point of information: The PowerPC handles misaligned reads into and writes out of general purpose registers without exceptions (modulo page-crossing reads) but with some performance penalty.</p>
<p>Someone asked how you can implement atomic operations without load-modify-store; PowerPC uses &lt;a href=&quot;<a target="_new" href="http://www.go-ecs.com/ppc/ppctek1.htm&quot;&gt;the" rel="nofollow">http://www.go-ecs.com/ppc/ppctek1.htm&quot;&gt;the</a> reservation instructions&lt;/a&gt;, &lt;a href=&quot;<a target="_new" href="http://publibn.boulder.ibm.com/doc_link/en_US/a_doc_lib/aixassem/alangref/lwarx.htm&quot;&gt;lwarx" rel="nofollow">http://publibn.boulder.ibm.com/doc_link/en_US/a_doc_lib/aixassem/alangref/lwarx.htm&quot;&gt;lwarx</a> and stwcx&lt;/a&gt;.  The special store instruction only succeeds if nobody else modified the location since the special load instruction, and reports whether the store succeeded.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-211273">
				<div id="div-comment-211273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-211273">
			September 16, 2004 at 4:39 pm</a>		</div>

		<p>9/15/2004 7:26 PM David</p>
<p>&gt; It might be argued that on an architecture<br />
<br />&gt; like x86 which allows unaligned memory<br />
<br />&gt; access, a conforming malloc implementation<br />
<br />&gt; could ignore alignment entirely.</p>
<p>That is correct.  Furthermore the compiler can ignore alignment when generating object code.  The reason ordinary compilers do not ignore alignment is exactly as you said, ordinary compilers are written with at least some degree of respect for performance (execution efficiency), which is obtainable except for structure layouts that are imposed by external requirements.</p>
<p>Even on CPUs which impose alignment in hardware, compilers and their associated malloc&#8217;s would be free to ignore alignment in laying out data though of course they would have to provide fixups to copy the data to aligned locations when necessary.  In fact when external requirements impose layouts different from what the CPU requires, compilers and/or runtimes already have to provide fixups this way (or else C programs have to call memcpy() etc.).  This is the reason why it is often faster for fixups to be done in the CPU instead of in software.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-212163">
				<div id="div-comment-212163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://feldgendler.livejournal.com/' rel='external nofollow' class='url'>Alexey Feldgendler</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-212163">
			September 18, 2004 at 11:37 am</a>		</div>

		<p>What do you mean 41-bit instructions? How can an instruction span 5 bytes and an extra bit?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-212173">
				<div id="div-comment-212173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-212173">
			September 18, 2004 at 11:41 am</a>		</div>

		<p>The ia64 encodes 3 instructions in 128 bits. Subtract 5 bits of overhead and you get 41 bits per instruction.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-214173">
				<div id="div-comment-214173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jan_Klaassen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-214173">
			September 27, 2004 at 9:40 am</a>		</div>

		<blockquote><p>
  Just wanted to add: the 6502 was used in the<br />
  <br />&gt; original C64, the 6510 was used for the<br />
  <br />&gt; slightly revamped C64-C.</p>
<p>No, the difference between the two is that the 6510 has an I/O port at address 1 (with an associated data direction register at address 0). The C64 uses it for banking some memory areas and controlling the tape recorder (yes, I have a misspent child-hood and a rather musty smelling C64 reference guide to prove it).
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-216363">
				<div id="div-comment-216363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael J Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-216363">
			October 13, 2004 at 12:32 am</a>		</div>

		<p>I think we may have things backwards.</p>
<p>Parameter passing and return addresses are determined by the compiler, not the architecture.  Because the x86 processors have few registers, the compiler&#8217;s choices are restricted &#8211; but it is still up to the compiler.  If an IA64 compiler wants to pass parameters on the stack, there is nothing to stop it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-216543">
				<div id="div-comment-216543" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-216543">
			October 13, 2004 at 7:25 am</a>		</div>

		<p>The Win32 ABI specifies the valid calling conventions. You can&#8217;t just make up a new one &#8211; it has to play friendly with SEH.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-217113">
				<div id="div-comment-217113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael J Smith</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-217113">
			October 13, 2004 at 10:56 pm</a>		</div>

		<blockquote><p>
  The Win32 ABI specifies the valid calling<br />
  <br />&gt; conventions. You can&#8217;t just make up a new one &#8211;<br />
  <br />&gt; it has to play friendly with SEH.</p>
<p>Certainly, your calling convention has to be consistent with APIs, system calls and other things that you use &#8211; but none of this is imposed by the architecture.</p>
<p>When porting Windows to IA64, I&#8217;m sure nobody said &quot;well, its IA64 so we must use these conventions&quot;.  You (or your colleagues) would have chosen conventions that you believed would work well in the architecture.</p>
<p>Another compiler designer might decide on a different set of conventions.  They would then need to add some &quot;glue&quot; around the edges to interface with the rest of the OS, but it could be done.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-217123">
				<div id="div-comment-217123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/' rel='external nofollow' class='url'>Raymond Chen</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-217123">
			October 13, 2004 at 11:07 pm</a>		</div>

		<p>Note that causing an exception counts as &quot;interfacing with the rest of the OS&quot;, so anywhere that can raise an exception needs to have glue. In order for the OS to be able to unwind exception frames, there are very specific rules about function prologues and epilogues so that the OS&#8217;s exception dispatcher can unwind a partially-executed function properly.</p>
<p>Sure, you can &quot;glue&quot; it, but since every memory access can potentially result in an exception (STATUS_IN_PAGE_ERROR for example), you&#8217;re going to have to erect glue around every memory access. That&#8217;s an awful lot of glue.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-235333">
				<div id="div-comment-235333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://weblogs.asp.net/oldnewthing/archive/2004/12/17/323556.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-235333">
			December 17, 2004 at 10:00 am</a>		</div>

		<p>Instead of doing it en masse, Windows 95 did it incrementally.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-428323">
				<div id="div-comment-428323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/oldnewthing/archive/2006/10/06/796395.aspx' rel='external nofollow' class='url'>The Old New Thing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040914-00/?p=37873#comment-428323">
			October 6, 2006 at 10:00 am</a>		</div>

		<p>Belated answers to exercises and other questions.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

