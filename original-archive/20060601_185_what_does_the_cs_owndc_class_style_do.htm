<html>
<head>
<title>What does the CS_OWNDC class style do?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>What does the CS_OWNDC class style do?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 1, 2006 / year-entry #186</td></tr>
<tr><td><b>Tags:</b></td><td>code;history</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>34</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Recall that window DCs are most commonly used only temporarily. If you need to draw into a window, you call BeginPaint or, if outside of a paint cycle, GetDC, although painting outside of a paint cycle is generally to be avoided. The window manager produces a DC for the window and returns it. You use...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Recall that window DCs are most commonly used only temporarily.
If you need to draw into a window, you call
<code>BeginPaint</code>
or, if outside of a paint cycle, <code>GetDC</code>,
although painting outside of a paint cycle is generally to be avoided.
The window manager produces a DC for the window and returns it.
You use the DC, then restore it to its original state and return
it to the window manager with
<code>EndPaint</code> (or <code>ReleaseDC</code>).
Internally, the window manager keeps a small cache of DCs which it
dips into when people come asking for a window DC,
and when the DC is returned, it goes back into the cache.
Since window DCs are used only temporarily, the number of outstanding DCs
is typically not more than a handful, and a small cache is sufficient
to satisfy DC demands in a normally-running system.
</p>
<p>
If you register a window class and include the <code>CS_OWNDC</code>
flag in the class styles,
then the window manager creates a DC for the window and puts it into
the DC cache with a special tag that means
"Do not purge this DC from the DC cache
because it's the <code>CS_OWNDC</code> for this window."
If you call <code>BeginPaint</code> or <code>GetDC</code> to get
a DC for a <code>CS_OWNDC</code> window,
then that DC will always be found and returned
(since it was marked as "never purge").
The consequences of this are good, bad, and worse.
</p>
<p>
The good part is that since the DC has been created specially for
the window and is never purged,
you don't have to worry about "cleaning up the DC" before
returning it to the cache.
Whenever you call <code>BeginPaint</code> or <code>GetDC</code>
for a <code>CS_OWNDC</code> window,
you always get that special DC back.
Indeed, that's the whole point of <code>CS_OWNDC</code> windows:
You can create a <code>CS_OWNDC</code> window,
get its DC, set it up the way you like it
(selecting fonts, setting colors, <i>etc</i>.), and even if you
release the DC and get it again later, you will get that
same DC back and it will be just the way you left it.
</p>
<p>
The bad part is that you're taking something that was meant to be
used only temporarily (a window DC) and using it permanently.
Early versions of Windows had a very low limit for DCs (eight or so),
so it was crucial that DCs be released as soon as they weren't needed.
That limit has since been raised significantly, but the underlying
principle remains: DCs should not be allocated carelessly.
You may have noticed that the implementation of <code>CS_OWNDC</code>
still uses the DC cache; it's just that those DCs get a special marking
so the DC manager knows to treat them specially.
This means that a large number of <code>CS_OWNDC</code> DCs end up
"polluting" the DC cache, slowing down future calls to
functions like <code>BeginPaint</code> and <code>ReleaseDC</code>
that need to search through the DC cache.
</p>
<p>
(Why wasn't the DC manager optimized to handle the case of
a large number of <code>CS_OWNDC</code> DCs?
First, as I already noted, the original DC manager didn't have
to worry about the case of a large number of DCs since the system
simply couldn't even create that many in the first place.
Second, even after the limit on the number of DCs was raised,
there wasn't much point in rewriting the DC manager to optimize
the handling of <code>CS_OWNDC</code> DCs since programmers were
already told to use <code>CS_OWNDC</code> sparingly.
This is one of the practicalities of software engineering:
You can do only so much.
Everything you decide to do comes at the expense of something else.
It's hard to justify optimizing a scenario that programmers were told
to avoid and which they in fact were already avoiding.
You don't optimize for the case where somebody is abusing your system.
It's like spending time designing a car's engine so it maintained
good gas mileage when the car has no oil.)
</p>
<p>
The worse part is that most windowing framework libraries and
nearly all sample code
assume that your windows are not <code>CS_OWNDC</code> windows.
Consider the following code that draws text in two fonts,
using the first font to guide the placement of characters in the second.
It looks perfectly fine, doesn't it?
</p>
<pre>
void FunnyDraw(HWND hwnd, HFONT hf1, HFONT hf2)
{
 HDC hdc1 = GetDC(hwnd);
 HFONT hfPrev1 = SelectFont(hdc1, hf1);
 UINT taPrev1 = SetTextAlign(hdc1, TA_UPDATECP);
 MoveToEx(hdc1, 0, 0, NULL);
  
 HDC hdc2 = GetDC(hwnd);
 HFONT hfPrev2 = SelectFont(hdc2, hf2);
  
 for (LPTSTR psz = TEXT("Hello"); *psz; psz++) {
  POINT pt;
  GetCurrentPositionEx(hdc1, &amp;pt);
  TextOut(hdc2, pt.x, pt.y + 30, psz, 1);
  TextOut(hdc1, 0, 0, psz, 1);
 }
  
 SelectFont(hdc1, hfPrev1);
 SelectFont(hdc2, hfPrev2);
  
 SetTextAlign(hdc1, taPrev1);
  
 ReleaseDC(hwnd, hdc1);
 ReleaseDC(hwnd, hdc2);
}
</pre>
<p>
We get two DCs for the window.
In the first we select our first font; in the second, we select the second.
In the first DC, we also set the text alignment to <code>TA_UPDATECP</code>
which means that the coordinates passed to the <code>TextOut</code>
function will be ignored.
Instead the text will be drawn starting at the "current position"
and the "current position" will be updated to the end of the string,
so that the next call to <code>TextOut</code> will resume where the
previous one left off.
</p>
<p>
Once the two DCs are set up, we draw our string one character at a time.
We query the first DC for the current position and draw the character
in the second font at that same <i>x</i>-coordinate (but a bit lower),
then we draw the character in the first font (which also advances the
current position).
</p>
<p>
After the text drawing loop is done, we restore the states of the two
DCs as part of the standard bookkeeping.
</p>
<p>
The intent of the function is to draw something like this,
where the first font is bigger than the second.
</p>
<table CELLSPACING=0 CELLPADDING=0>
<tr STYLE="font-size: 200%">
<td>H</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
</tr>
<tr>
<td>H</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
</tr>
</table>
<p>
And if the window is not <code>CS_OWNDC</code> that's what you get.
You can try it out by calling it from our scratch program:
</p>
<pre>
HFONT g_hfBig;

BOOL
OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{
 LOGFONT lf;
 GetObject(GetStockFont(ANSI_VAR_FONT),
           sizeof(lf), &amp;lf);
 lf.lfHeight *= 2;
 g_hfBig = CreateFontIndirect(&amp;lf);
 return g_hfBig != NULL;
}

void
OnDestroy(HWND hwnd)
{
 if (g_hfBig) DeleteObject(g_hfBig);
 PostQuitMessage(0);
}

void
PaintContent(HWND hwnd, PAINTSTRUCT *pps)
{
 FunnyDraw(hwnd, g_hfBig,
                 GetStockFont(ANSI_VAR_FONT));
}
</pre>
<p>
But if the window is <code>CS_OWNDC</code>, then bad things happen.
Try it yourself by changing the line
<code>wc.style = 0;</code>
to
<code>wc.style = CS_OWNDC;</code>
You get the following unexpected output:
</p>
<table CELLSPACING=0 CELLPADDING=0>
<tr>
<td>HHeelllloo</td>
</tr>
</table>
<p>
Of course, if you understand how <code>CS_OWNDC</code> works,
this is hardly unexpected at all.
The key to understanding is remembering that when the window
is <code>CS_OWNDC</code> then <code>GetDC</code> just returns the
same DC back no matter how many times you call it.
Now all you have to do is walk through the
<code>FunnyDraw</code> function remembering that
<code>hdc1</code> and <code>hdc2</code> are in fact
<strong>the same thing</strong>.
</p>
<pre>
void FunnyDraw(HWND hwnd, HFONT hf1, HFONT hf2)
{
 HDC hdc1 = GetDC(hwnd);
 HFONT hfPrev1 = SelectFont(hdc1, hf1);
 UINT taPrev1 = SetTextAlign(hdc1, TA_UPDATECP);
 MoveToEx(hdc1, 0, 0, NULL);
</pre>
<p>
So far, execution of the function is pretty normal.
</p>
<pre>
 HDC hdc2 = GetDC(hwnd);
</pre>
<p>
Since the window is a <code>CS_OWNDC</code> window,
the DC that is returned in <code>hdc2</code> is the same
one that was returned in <code>hdc1</code>.
In other words, <code>hdc1 == hdc2</code>!
Now things get exciting.
</p>
<pre>
 HFONT hfPrev2 = SelectFont(hdc2, hf2);
</pre>
<p>
Since <code>hdc1 == hdc2</code>,
what this really does is deselect the font <code>hf1</code>
from the DC and select the font <code>hf2</code> instead.
</p>
<pre>
 for (LPTSTR psz = TEXT("Hello"); *psz; psz++) {
  POINT pt;
  GetCurrentPositionEx(hdc1, &amp;pt);
  TextOut(hdc2, pt.x, pt.y + 30, psz, 1);
  TextOut(hdc1, 0, 0, psz, 1);
 }
</pre>
<p>
Now this loop completely falls apart.
At the first iteration, we retrieve the current position from
the DC, which returns (0,&nbsp;0) since we haven't moved it yet.
We then draw the letter "H" at position (0,&nbsp;30) into the
second DC.
But since the second DC is the same as the first one, what
really happens is that we are calling <code>TextOut</code> into
a DC that is in <code>TA_UPDATECP</code> mode.
Thus, the coordinates are ignored, the letter "H" is displayed
(in the second font), and the current position is updated to
be after the "H".
Finally, we draw the "H" into the first DC (which is the same as
the second).
We think we're drawing it with the first font, but in fact
we're drawing with the second font.
We think we're drawing at (0,&nbsp;0), but in fact we're
drawing at (<i>x</i>,&nbsp;0), where <i>x</i> is the width of
the letter "H", 
because the call to <code>TextOut(hdc2,&nbsp;...)</code>
updated the current position.
</p>
<p>
Thus, each time through the loop, the next character in the
string is displayed twice, all in the second font.
</p>
<p>
But wait, the disaster isn't finished yet.
Look at our cleanup code:
</p>
<pre>
 SelectFont(hdc1, hfPrev1);
</pre>
<p>
This restores the original font into the DC.
</p>
<pre>
 SelectFont(hdc2, hfPrev2);
</pre>
<p>
This re-selects the first font!
We failed to restore the DC to its original state
and ended up putting a "corrupted" DC into the cache.
</p>
<p>
That's why I described <code>CS_OWNDC</code> as "worse".
It takes code that used to work and breaks it
by violating assumptions that most people make (usually
without realizing it) about DCs.
</p>
<p>
And you thought <code>CS_OWNDC</code> was bad.
Next time I'll talk about the disaster that is known as
<code>CS_CLASSDC</code>.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (34)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-387063">
				<div id="div-comment-387063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">mastmaker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387063">
			June 1, 2006 at 10:36 am</a>		</div>

		<p>Hey, I learnt something new today!</p>
<p>You can actually allocate TWO DCs for the same window at the same time? I always found ONE DC to be sufficient for me, no matter how complicated the drawing. But then, I am no Picasso!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387093">
				<div id="div-comment-387093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">whinger</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387093">
			June 1, 2006 at 11:36 am</a>		</div>

		<blockquote><p>
  It&#8217;s hard to justify optimizing a scenario that programmers were<br />
  told to avoid and which they in fact were already avoiding.</p>
<p>Except for us suckers trying to write OpenGL apps, eh?</p>
<div CLASS="post">[<i>I don&#8217;t follow. I was referring to intentional violating the<br />
  guidelines for how a particular feature should be used. Presumably,<br />
  OpenGL has similar guidelines on how it should and shouldn&#8217;t be used.<br />
  (Not being an OpenGL programmer I don&#8217;t know for sure. I&#8217;m thinking<br />
  guidelines like &#8220;Don&#8217;t allocate unnecessary XYZ&#8217;s.&#8221;) -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387123">
				<div id="div-comment-387123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Carlos</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387123">
			June 1, 2006 at 11:50 am</a>		</div>

		<p>I wondered if using two DCs would be quicker so I measured it. &nbsp;Using one DC (and repeatedly switching the font) the painting takes about 36% more time than using two DCs. &nbsp;YMMV.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387133">
				<div id="div-comment-387133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.divelements.co.uk' rel='external nofollow' class='url'>Tim Dawson</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387133">
			June 1, 2006 at 11:57 am</a>		</div>

		<p>It hadn&#8217;t occurred to me either that I could use two DCs for drawing at the same time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387163">
				<div id="div-comment-387163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Reinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387163">
			June 1, 2006 at 1:28 pm</a>		</div>

		<p>&#8220;We failed to restore the DC to its original state and ended up putting a &#8220;corrupted&#8221; DC into the cache&#8221; </p>
<p>Are<br />
you implying that doing this was, in old Windows versions, a way to do<br />
inter-process communication (in a really, really awkward way)? </p>
<p>[I<br />
would hope that, nowadays, the OS would always give programs a clean DC<br />
whenever they &nbsp;asked for one, or would at least maintain a<br />
separate cache per process]</p>
<div class="post">[<i>The cache is per-thread so all you&#8217;re corrupting is yourself. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-kjkhyperion odd alt thread-odd thread-alt depth-1" id="comment-387173">
				<div id="div-comment-387173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387173">
			June 1, 2006 at 1:45 pm</a>		</div>

		<p>Little bit of trivia: the only part of Windows that uses CS_OWNDC exclusively are the console windows (go on, have a look with Spy++), altough I&#8217;m not exactly sure why (I suppose to allow drawing from outside the window&#8217;s thread? or maybe for performance?). It&#8217;s one of the many ways console windows are &quot;special&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387183">
				<div id="div-comment-387183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Nick</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387183">
			June 1, 2006 at 4:23 pm</a>		</div>

		<p>Another standard Windows app which makes use of the class is Windows Media Player 10. Curious, I checked and the old WMP 6.4 (mplayer2.exe) also uses the class.</p>
<p>Would this be related to the video playback they do? I assume WMP 6.4 also uses DirectPlay for video playback; does using DirectX make a difference?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387193">
				<div id="div-comment-387193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sudsy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387193">
			June 1, 2006 at 5:19 pm</a>		</div>

		<p>&#8220;but the underlying principle remains: DCs should not be allocated carelessly&#8221; </p>
<p>(I don&#8217;t claim to know much about Windows API programming). </p>
<p>When I was first learning about how to program the Windows API on Win 3.1 I took this advice to heart and always freed my DCs as soon as possible. This made sense considering all the memory limits in Windows 3.1. </p>
<p>Now, Raymond, who clearly knows what he&#8217;s talking about, says &#8220;but the underlying principle remains: DCs should not be allocated carelessly&#8221;. In today&#8217;s virtual memory based Windows, why is this true? In other words, why are DCs, and the memory they require, more critical than any other kind of Windows API data structure? Why can&#8217;t they be allocated and managed dynamically? On a system with free memory why can&#8217;t you have a gazillion DCs? </p>
<p>(Again, I&#8217;m asking because I&#8217;d like to know. I&#8217;m not questioning anybody&#8217;s knowledge). </p>
<div class="post">[<i>You shouldn&#8217;t allocate <u>anything</u> carelessly. DCs are a subset of &#8220;anything&#8221;. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387073">
				<div id="div-comment-387073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Dave Behnke</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387073">
			June 1, 2006 at 10:57 am</a>		</div>

		<p>Interesting post Raymond.</p>
<p>I have never created more than one DC for a Window. &nbsp;Instead, I always end up selecting and deselecting the attributes that I need. &nbsp;It&#8217;s just the way I think.</p>
<p>Basically, I would end up selecting and deselecting the two different fonts within the for loop. &nbsp;Maybe there are side-effects to this?</p>
<p>It always seemed wasteful to use two DCs with different attributes. &nbsp;However, that&#8217;s *part* of what a DC is for right? &nbsp;</p>
<p>Perhaps the FunnyDraw function could use SaveDC/RestoreDC to operate properly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387083">
				<div id="div-comment-387083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387083">
			June 1, 2006 at 11:36 am</a>		</div>

		<p>Semi-off-topic (i.e. not the point you were aiming for) but there&#8217;s<br />
another good reason to *always* release resources in the opposite order<br />
you acquired them. Although it wouldn&#8217;t fix the printing problem, the<br />
DC would at least have been returned in it&#8217;s original state if the<br />
cleanup was written as:</p>
<p>SelectFont(hdc2, hfPrev2);<br />
<br />ReleaseDC(hwnd, hdc2);<br />
<br /> &nbsp;<br />
<br />SetTextAlign(hdc1, taPrev1);<br />
<br />SelectFont(hdc1, hfPrev1);<br />
<br />ReleaseDC(hwnd, hdc1);</p>
<div class="post">[<i>Actually I did that on purpose specifically because it caused<br />
the &#8220;dirty DC&#8221; problem. A naive reading would say that we did clean up<br />
in reverse order &#8211; if you look at it on a per-DC basis. (Well, okay, I<br />
restored text alignment out of order.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387233">
				<div id="div-comment-387233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jay B</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387233">
			June 1, 2006 at 7:14 pm</a>		</div>

		<p>Wow, like the others, I&#8217;m surprised by the ability to use multiple DC&#8217;s&#8230; That could have made life easier for sure.</p>
<p>SaveDC and RestoreDC were mentioned already&#8230; I&#8217;m surprised those aren&#8217;t more widely used as well. &nbsp;When I first found those, it was a hallelujah moment. &nbsp;Why bother keeping track of old objects yourself, making your code bulkier, more complex and potentially introduce bugs, when you can just reset it they way it was with one call before leaving a function. &nbsp;It&#8217;s stack-based too.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387243">
				<div id="div-comment-387243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://Whatacoincidence...' rel='external nofollow' class='url'>Jeremy Noring</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387243">
			June 1, 2006 at 7:20 pm</a>		</div>

		<p>&#8230;I was just reading this earlier today: </p>
<p><a href="http://www.flounder.com/badprogram.htm#Using%20GetDC" target="_new" rel="nofollow">http://www.flounder.com/badprogram.htm#Using%20GetDC</a> </p>
<p>I<br />
think one point Flounder makes that&#8217;s a good one: using CClientDC<br />
rather than GetDC. &nbsp;Obviously it&#8217;s a dumb mistake to not call<br />
ReleaseDC, but&#8230;.people make mistakes. &nbsp;I&#8217;d rather have scope<br />
handle the dirty work. &nbsp;Your posted &#8220;FunnyDraw&#8221; method would be a<br />
few lines shorter, and more resiliant to changes by People Who Don&#8217;t<br />
Know Better (TM). </p>
<p>If you didn&#8217;t want to use MFC, it&#8217;d be pretty trivial to make a small wrapper class that did the same thing as CClientDC</p>
<div CLASS=post>[<i>I think you missed the point of the article. CClientDC wouldn&#8217;t have helped any. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387143">
				<div id="div-comment-387143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Michael</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387143">
			June 1, 2006 at 12:28 pm</a>		</div>

		<p>So under what circumstances *would* it be appropriate to use CS_OWNDC?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387253">
				<div id="div-comment-387253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miral</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387253">
			June 1, 2006 at 8:03 pm</a>		</div>

		<p>Most sample code that I&#8217;ve seen doesn&#8217;t bother to restore the DC to its original state (bitmaps, pens, fonts, etc) prior to releasing it. &nbsp;They just assume that Windows will &quot;reset&quot; the DC when it&#8217;s no longer being used by anyone, just like everything else.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387263">
				<div id="div-comment-387263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeremy Noring</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387263">
			June 1, 2006 at 8:03 pm</a>		</div>

		<p>I didn&#8217;t miss the point of the article&#8211;I just think you should use CClientDC rather than GetDC. &nbsp;Sorry, it was a tangent.</p>
<div class="post">[<i>I already explained <a href="/oldnewthing/archive/2004/08/31/223271.aspx" rel="nofollow">multiple</a> <a href="/oldnewthing/archive/2004/12/29/343664.aspx" rel="nofollow">times</a><br />
why my samples do not use any class libraries. Plain C++ is the common<br />
language. If you want to use a particular dialect then more power to<br />
you. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387153">
				<div id="div-comment-387153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Washu</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387153">
			June 1, 2006 at 1:05 pm</a>		</div>

		<p>&gt;So under what circumstances *would* it be appropriate to use CS_OWNDC?</p>
<p>Typically OpenGL applications require CS_OWNDC. The general process would be to choose and set the pixel format of the DC, then bind the OpenGL Resource Context to the DC (using wglMakeCurrent).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387273">
				<div id="div-comment-387273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Shelley Fanboi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387273">
			June 1, 2006 at 8:19 pm</a>		</div>

		<p>The true history of Linux</p>
<p>shelleytherepublican.com/2006/05/22/a-true-history-of-linux.aspx</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387303">
				<div id="div-comment-387303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387303">
			June 1, 2006 at 10:53 pm</a>		</div>

		<p>&#8230;and then you can&#8217;t destroy hf1 because it&#8217;s still selected into a device context, so you end up leaking GDI objects as well.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-patriotb even thread-even depth-1" id="comment-387313">
				<div id="div-comment-387313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">PatriotB</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387313">
			June 1, 2006 at 11:27 pm</a>		</div>

		<p>Ah yes, CS_OWNDC. &nbsp;I used to work at a software company which produced massive VB6-based applications. &nbsp;Virtually *all* of the app&#8217;s windows had CS_OWNDC (at least on NT&#8211;we didn&#8217;t support our app on 9x). &nbsp;And people wondered why our app was reaching the limit of 10000 GDI handle per process&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387433">
				<div id="div-comment-387433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Billy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387433">
			June 2, 2006 at 11:00 am</a>		</div>

		<p>PatriotB &#8212; VB 6 Forms and UserControls have a property called HasDC which sets the CS_OWNDC class bit when set to true. &nbsp;Of course it defaults to true as well instead of false. &nbsp;I can remember going through this issue for one of our apps that would absolutely smash the GDI heap limits on Win 9x. &nbsp;This was in a large system with a large number of VB custom controls used on a large number of forms.</p>
<p>I never figured out why they defaulted it to true. &nbsp;It seems to be wrong. &nbsp;If you are doing something specific that requires the class bit, you should know enough to turn it on&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387473">
				<div id="div-comment-387473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387473">
			June 2, 2006 at 12:28 pm</a>		</div>

		<p>Billy &#8212; according to this:</p>
<p><a rel="nofollow" target="_new" href="http://www.vbwm.com/art_1999/whatsnew/hasdc.asp" rel="nofollow">http://www.vbwm.com/art_1999/whatsnew/hasdc.asp</a></p>
<p>it defaults to True so that the behavior is the same as in older VB versions (and so that the HDC property returns a value that can be cached; not that anyone should be using the HDC property anyway).</p>
<p>Now as to why it was set that way in older VB versions, I&#8217;m not sure&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387553">
				<div id="div-comment-387553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Jeremy Noring</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387553">
			June 2, 2006 at 4:47 pm</a>		</div>

		<p>Like I said in my first post, you don&#8217;t need to use a class library.</p>
<div class=post>[<i>A<br />
wrapper class is just a special case of a class library. And it<br />
wouldn&#8217;t have helped here anyway. I guess I&#8217;m not sure what your point<br />
is. Yes, &#8220;FunnyDraw&#8221; would have been a few lines shorter with a wrapper<br />
class, but it would be just as buggy. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387623">
				<div id="div-comment-387623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://www.williamwilling.com/' rel='external nofollow' class='url'>William Willing</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387623">
			June 3, 2006 at 4:13 am</a>		</div>

		<p>Suppose you are writing a graphics intensive application, like a photo editing app or a game, wouldn&#8217;t that be a good time to use CS_OWNDC? As long as you don&#8217;t try to get multiple DCs for your window, you should be fine, right? Or am I missing something?</p>
<p>Also, I thought one of the benefits of CS_OWNDC was that you can get the DC once after you created the window and then use it throughout your application, without further calls to GetDC or BeginPaint. That&#8217;s pretty much what the documentation says. Is that correct?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387653">
				<div id="div-comment-387653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sudsy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387653">
			June 3, 2006 at 1:55 pm</a>		</div>

		<p>&#8220;[You should allocate anything carelessly. DCs are a subset of &#8220;anything&#8221;. -Raymond]&#8221; </p>
<p>I&#8217;ll presume that Raymond accidently left out the word &#8220;not&#8221; from this. <br />But, the fact remains that there&#8217;s something unusual about DCs even in a virtual memory environment. It&#8217;s obvious that nothing should be allocated carelessly but I get the impression that it would be worse if I allocated 10,000 DCs than 10,000 buffers containing the string &#8220;The Old New Thing&#8221;. Right? Why?</p>
<div CLASS=post>[<i>Those 10,000 string buffers impact only your process. DCs are cross-process objects. It&#8217;s not the memory usage that&#8217;s the limiting factor; it&#8217;s the address space. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387763">
				<div id="div-comment-387763" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387763">
			June 4, 2006 at 11:21 pm</a>		</div>

		<blockquote><p>
  [The cache is per-thread so all you&#8217;re<br />
  <br />&gt; corrupting is yourself. -Raymond]</p>
<p>vs.</p>
<p>&gt; DCs are cross-process objects. It&#8217;s not the<br />
  <br />&gt; memory usage that&#8217;s the limiting factor;<br />
  <br />&gt; it&#8217;s the address space. -Raymond]</p>
<p>Huh? &nbsp;If they&#8217;re cross-process then didn&#8217;t Reinder still diagnose a problem properly?</p>
<div class="post">[<i>DCs are cross-process. The DC cache is per-thread. There is no &#8220;vs&#8221; here. -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387783">
				<div id="div-comment-387783" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387783">
			June 5, 2006 at 3:25 am</a>		</div>

		<blockquote><p>
  [DCs are cross-process. The DC cache is<br />
  <br />&gt; per-thread. There is no &#8220;vs&#8221; here. -Raymond]</p>
<p>I&#8217;m still missing part of this.</p>
<p>If a DC isn&#8217;t cleaned up before being released, then a corrupted DC<br />
  goes into a per-thread cache. &nbsp;Therefore it seems likely that all<br />
  released DCs, corrupted or not, go into a per-thread cache.</p>
<p>When do DCs become cross-process objects? &nbsp;When they&#8217;re<br />
  acquired they become cross-process but when they&#8217;re released they go<br />
  into a per-thread cache? &nbsp;(I sure hope not, I sure hope this<br />
  logical inference is as illogical to you as it is to me.) &nbsp;Do<br />
  CS_OWNDC windows do something to turn their DCs into cross-process<br />
  objects?</p>
<p>And Reinder&#8217;s question still seems relevant, if DCs are cross-process objects.</p>
<div CLASS=post>[<i>Well, some experimentation tells me that DCs are not cross-process after all (they were in Windows 3.1), so I apologize for the misinformation. I am not a substitute for formal documentation.</p>
<p>  By &#8220;cross-process&#8221; I meant that a DC handle, once created, is valid in any process. (This was true in Windows 3.1 though apparently not any more.) The handle doesn&#8217;t &#8220;become&#8221; cross-process any more than a window handle &#8220;becomes&#8221; cross-process. The DC cache is per-thread (or at least was in Windows 3.1; things may be different nowadays). If a thread calls &#8220;GetDC&#8221;, it looks in the cache of DCs recently released by that thread. The two concepts (visibility and cache affinity) are unrelated. Passports are per-country but are globally valid &#8211; nobody seems confused by that. -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387793">
				<div id="div-comment-387793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387793">
			June 5, 2006 at 5:29 am</a>		</div>

		<blockquote><p>
  I apologize for the misinformation.</p>
<p>Accepted, and thank you for the corrections.</p>
<p>&gt; I am not a substitute for formal<br />
  <br />&gt; documentation.</p>
<p>Yeah, well, formal documentation is no substitute for you either.<br />
  &nbsp;I think in the thread that started one day after this one,<br />
  someone guessed that your reason for posting this series is that you&#8217;re<br />
  not authorized to fix the formal documentation.</p>
</blockquote>
<div class="post">[<i>This type of article is not suitable for<br />
formal documentation. For one thing, it&#8217;s too informal. For another<br />
thing, formal documentation is about explaining what each flag does and<br />
letting you decide which ones you want. If you want to use CS_CLASSDC<br />
then more power to you. Formal documentation is not going to say<br />
&#8220;CS_CLASSDC is hard to use correctly, so be careful.&#8221; -Raymond</i>]</div>
<p>&gt; By &#8220;cross-process&#8221; I meant that a DC handle,<br />
<br />&gt; once created, is valid in any process [in<br />
<br />&gt; Windows 3.1]. &nbsp;[&#8230;] &nbsp;If a thread calls<br />
<br />&gt; &#8220;GetDC&#8221;, it looks in the cache of DCs<br />
<br />&gt; recently released by that thread.</p>
<p>So in 3.1, if this thread&#8217;s cache was empty and GetDC had to take a<br />
DC that isn&#8217;t from this thread&#8217;s cache, it still could have obtained a<br />
corrupted DC that a different thread released?</p>
<div class="post">[<i>What part of &#8220;per-thread&#8221; don&#8217;t you<br />
understand? If one thread could look in another thread&#8217;s cache, then<br />
it&#8217;s not a per-thread cache, now, is it? I can&#8217;t tell if you&#8217;re<br />
genuinely confused or are being intentionally obtuse to prove some<br />
point. -Raymond</i>]</div>
<p>Meanwhile&#8230;</p>
<p>&gt; Passports are per-country but are globally<br />
<br />&gt; valid</p>
<p>Wanna bet?</p>
<div class="post">[<i>I should have know that you of all people would pointlessly nitpick this analogy. -Raymond</i>]</div>
<p>&gt; nobody seems confused by that</p>
<p>Wanna bet?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-387943">
				<div id="div-comment-387943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387943">
			June 5, 2006 at 11:44 am</a>		</div>

		<p>So the way I understand what you&#8217;re saying, thread 2 always gets a<br />
different DC than thread 1; thread 2&#8217;s DC will never be dirty (have the<br />
wrong object(s) selected into it) unless thread 2 left it that way<br />
itself.</p>
<div class=post>[<i>Or unless you&#8217;re using CS_OWNDC or CS_CLASSDC, which was the point of this mini-series. -Raymond</i>]</div>
<p>Not that this excuses any practice of releasing dirty DCs, but at least you won&#8217;t be breaking anyone else&#8217;s window.</p>
<p>Actually, re-reading the comments here, it seems you said that at<br />
least once before, way back up under Reinder&#8217;s comment June 1.<br />
&nbsp;Hmm.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-387923">
				<div id="div-comment-387923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-387923">
			June 5, 2006 at 11:21 am</a>		</div>

		<p>I *think* Norman meant a scenario like this (if not, I&#8217;m wondering what happens):</p>
<p>Thread 1 calls GetDC, selects some object into the returned DC, and<br />
releases it. &nbsp;The DC gets put back into thread 1&#8217;s cache, in a<br />
&#8220;dirty&#8221; state.</p>
<p>Then, thread 2 gets a DC for the same window (&#8230;is this even<br />
legal, since the window is owned by thread 1?). &nbsp;No DC for that<br />
window exists in thread 2&#8217;s cache. &nbsp;Does it get the dirty DC that<br />
thread 1 released, or does the window manager create a new DC? &nbsp;If<br />
thread 2 gets the dirty DC, does it get a clean one after the dirty one<br />
ages out of thread 1&#8217;s cache?</p>
<div class=post>[<i>Thread 2 can&#8217;t see thread 1&#8217;s cache. There could be a<br />
kangaroo in thread 1&#8217;s cache, it won&#8217;t have any effect on thread 2.<br />
Note that the fact that the cache is per-thread is an implementation<br />
detail and can change at any time. In fact, it may have already changed<br />
and I simply haven&#8217;t noticed. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-388073">
				<div id="div-comment-388073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-388073">
			June 5, 2006 at 8:49 pm</a>		</div>

		<blockquote><p>
  &gt;&gt; By &#8220;cross-process&#8221; I meant that a DC <br />&gt;&gt;&gt; handle, once created, is valid in any <br />&gt;&gt;&gt; process [in Windows 3.1]. &nbsp;[&#8230;] &nbsp;If a <br />&gt;&gt;&gt; thread calls &#8220;GetDC&#8221;, it looks in the <br />&gt;&gt;&gt; cache of DCs recently released by that <br />&gt;&gt;&gt; thread. <br />&gt;&gt; <br />&gt;&gt; So in 3.1, if this thread&#8217;s cache was empty <br />&gt;&gt; and GetDC had to take a DC that isn&#8217;t from <br />&gt;&gt; this thread&#8217;s cache, it still could have <br />&gt;&gt; obtained a corrupted DC that a different <br />&gt;&gt; thread released? <br />&gt; <br />&gt; [What part of &#8220;per-thread&#8221; don&#8217;t you <br />&gt; understand? </p>
<p>Maybe the part that turns a cache into an infinite supply? &nbsp;You said there&#8217;s a per-thread cache and that a released DC goes into the thread&#8217;s cache. &nbsp;Well the same thread is capable of getting DCs again. &nbsp;After it&#8217;s gotten all the DCs that it previously released, its cache is empty, right? &nbsp;When it tries to get another DC, can it get one? </p>
<p>When a thread exits, do its corrupted cached DCs get leaked or do they rejoin a pool of available DCs? </p>
<p>  If all currently unused DCs are on the caches of other threads, and our thread tries to get another DC, does Windows inherit a famous old DEC error message? &nbsp;(&#8220;Memory available, but not for you.&#8221;) &nbsp;Or does Windows take a DC in order to get it usable where needed?</p>
<p>  And still, still, if DCs are cross-process then Reinder&#8217;s question still looks mighty valid.</p>
<div class=post>[<i>This article was not about the details of the DC cache. The cache has a policies to cover these cases and they are pretty much in line with most other cache policies And I already answered Reinder&#8217;s question: The cache is per thread. All you&#8217;re corrupting is yourself. -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-388523">
				<div id="div-comment-388523" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miral</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-388523">
			June 6, 2006 at 8:56 pm</a>		</div>

		<p>&gt; Formal documentation is not going to say &quot;CS_CLASSDC is hard to use<br />
<br />&gt; correctly, so be careful.&quot; </p>
<p>Why not? &nbsp;If it&#8217;s true, it should. &nbsp;Many people are only ever exposed to the formal documentation, and don&#8217;t see the informal docs that say &quot;but wait, you shouldn&#8217;t use it like *this*&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-388963">
				<div id="div-comment-388963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-388963">
			June 7, 2006 at 10:40 pm</a>		</div>

		<p>I agree with Miral. &nbsp;In fact some pages in MSDN say that certain items are defined only for backwards compatibility with 16-bit Windows and new applications should not use them. &nbsp;I think such notices have even been added to more pages recently, belatedly but better than never.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-599573">
				<div id="div-comment-599573" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://bobobobo.wordpress.com/2008/02/11/opengl-in-a-proper-windows-app-no-glut/' rel='external nofollow' class='url'>OpenGL in a PROPER Windows APP (NO GLUT!!) &laquo; Bobobobo&#8217;s Weblog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-599573">
			February 10, 2008 at 7:20 pm</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://bobobobo.wordpress.com/2008/02/11/opengl-in-a-proper-windows-app-no-glut/" rel="nofollow">http://bobobobo.wordpress.com/2008/02/11/opengl-in-a-proper-windows-app-no-glut/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-632813">
				<div id="div-comment-632813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://bobobobo.wordpress.com/2008/02/09/windows-function-references/' rel='external nofollow' class='url'>Windows function references &laquo; Bobobobo&#8217;s Weblog</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060601-06/?p=31003#comment-632813">
			May 26, 2008 at 11:29 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://bobobobo.wordpress.com/2008/02/09/windows-function-references/" rel="nofollow">http://bobobobo.wordpress.com/2008/02/09/windows-function-references/</a></p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

