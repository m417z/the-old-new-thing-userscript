<html>
<head>
<title>Why does the CREATOR_OWNER SID sometimes reset itself to the object's current owner rather than its original owner?</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Why does the CREATOR_OWNER SID sometimes reset itself to the object&#8217;s current owner rather than its original owner?</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>June 13, 2018 / year-entry #136</td></tr>
<tr><td><b>Tags:</b></td><td>tipssupport</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>17</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">It's a snapshot, but you can ask for a new snapshot.</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
I noted some time ago that
the <code>CREATOR_</code><code>OWNER</code> security identifier (SID)
is not a
shorthand that refers to the object's current owner.
Rather,
<a HREF="https://blogs.msdn.microsoft.com/oldnewthing/20160524-00/?p=93515">
the <code>CREATOR_</code><code>OWNER</code> SID is a template
that is applied when the object is created</a>.
When the template is applied,
all occurrences of
<code>CREATOR_</code><code>OWNER</code> are
replaced with the object's current owner,
and it is the replaced SID that controls access.
Changing the object's owner doesn't cause these access control entries
to be recalculated;&sup1; they continue to refer to the captured value.
</p>
<p>
A customer observed this phenomenon when they created a folder
with an inheritable
access control entry (ACE) for <code>CREATOR_</code><code>OWNER</code>.
They observed that those access control entries were indeed propagated
to child objects, with the
<code>CREATOR_</code><code>OWNER</code> changed to the
object's actual owner.
Furthermore, if they went to the Security properties and
changed the child object's owner, the ACE was not
recalculated to update the ACE's SID from the old owner to the new owner.
</p>
<p>
However (and this is the weird part),
if they use the Security properties to make some unrelated change
to the object's access control list (ACL),
then this has a side effect of recalculating the ACEs
and updating the
<code>CREATOR_</code><code>OWNER</code>-sourced ACEs
to refer to the new owner.
</p>
<p>
This recalculation is not being done by the security infrastructure.
It's being done by the ACL editor.
</p>
<p>
When you change the access control list for an item,
the ACL editor calls
<code>Tree&shy;Set&shy;Named&shy;Security&shy;Info</code>
and passes an ACL that consists only of the non-inherited ACEs,
and it sets the
<code>UNPROTECTED_</code><code>DACL_</code><code>SECURITY_</code><code>INFORMATION</code>
flag,
which means
"Oh, and also inherit ACEs from my parent, as if I were newly-created."
</p>
<p>
In other words, the ACL edit deletes all the ACEs that were obtained
by inherance,
and then creates new ACEs based on the current parent's
inheritable ACEs.
</p>
<p>
The ACL editor is trying to be helpful, but it ends up being confusing.
</p>
<p>
&sup1;
What would this recalculation even mean if the object was moved
to a new folder after being created, or if the containing folder's
access control list were modified in the interim?
I guess you could have a bit somewhere in the ACE
that says,
"This was originally created from a template that used
<code>CREATOR_</code><code>OWNER</code>."
The closest thing to that is the <code>INHERITED_</code><code>ACE</code>
bit, which says
"This ACE was autogenerated via inheritance,"
but it doesn't give any information as to what the
original ACE was.
Suppose the object's current owner is Bob.
If an ACE applies to Bob and has the
<code>INHERITED_</code><code>ACE</code> bit set,
it could mean that the original template ACE's SID was
<code>CREATOR_</code><code>OWNER</code> that was changed to Bob
during template application because Bob was the original owner,
or it could mean that the original template ACE's SID was
<code>CREATOR_</code><code>GROUP</code> that was changed to Bob
during template application because Bob was the original group,
or it could mean that the original template ACE's SID was
Bob all along.</p>
<p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (17)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1 parent" id="comment-1346355">
				<div id="div-comment-1346355" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346355">
			June 13, 2018 at 7:49 am</a>		</div>

		<p>The callback function of Tree­Set­Named­Security­Info() <a href="https://msdn.microsoft.com/en-us/library/aa965849.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/aa965849.aspx</a> is declared without calling convention; with compiler switches /Gr or /Gz this will generate WRONG code.<br />
Most (if not all) other callback functions used in the Win32 API are but declared CALLBACK alias __stdcall<br />
Is there a deeper reason for this bug, or is this just sloppy coding?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip odd alt depth-2 parent" id="comment-1346455">
				<div id="div-comment-1346455" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346455">
			June 13, 2018 at 2:34 pm</a>		</div>

		<p>To be a bit picky, the code generated is correct for the definitions, but this is an ODR violation.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1346775">
				<div id="div-comment-1346775" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346775">
			June 14, 2018 at 10:09 am</a>		</div>

		<p>No ODR here!<br />
The first compilation unit, the DLL, is compiled with /Gz, so the callback function gets __stdcall calling convention.<br />
The second compilation unit, the user program, is typically compiled without /Gz, so the callback function gets __cdecl calling convention.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip odd alt depth-4 parent" id="comment-1346935">
				<div id="div-comment-1346935" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346935">
			June 14, 2018 at 7:43 pm</a>		</div>

		<p>Well, if you want to be picky to my picky, then fine, I&#8217;ll be picky back.<br />
The exact rule that governs this is, in the C++17 standard 6.5 [basic.link] paragraph 10.<br />
&#8220;After all adjustments of types (&#8230;), the types speciﬁed by all declarations referring to a given variable or function shall be identical, except that declarations for an array object can specify array types that differ by the presence or absence of a major array bound. A violation of this rule on type identity does not require a diagnostic.&#8221;<br />
Since the type of TreeSetNamedSecurityInfo has external linkage and the types are different then we have a function with external linkage declared with two different types in two different translation units.<br />
Either way, the code being generated isn&#8217;t wrong for the definitions.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1347005">
				<div id="div-comment-1347005" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1347005">
			June 15, 2018 at 4:26 am</a>		</div>

		<p>1. who said something about C++?<br />
<a href="https://msdn.microsoft.com/en-us/library/aa965849.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/aa965849.aspx</a> is the pure ANSI C interface<br />
2. the difference between theory and practice is the practice.<br />
Unless compiled with /Gz the callee doesn&#8217;t match the caller&#8217;s expectation and will lead to a crash or vulnerability.<br />
Do I REALLY need to come up with an exploit?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-archangelpip odd alt depth-5" id="comment-1347205">
				<div id="div-comment-1347205" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1347205">
			June 15, 2018 at 10:00 am</a>		</div>

		<p>Stefan Kanthak:<br />
Who said anything about the C++ standard&#8217;s rules only apply to C++. The standard itself is quite compatible with C, and in fact the rules are usually the same, just worded differently. The C11 standard, 6.7 paragraph 4, states that all declaration in the same scope that refer to the same object must have compatible types. So even for a C interface the rule is the same.<br />
Also, I don&#8217;t think you quite get what I mean. If the compiler is given incorrect information on a function type, you can&#8217;t call the code it generates wrong, since for the declarations the compiler is given, the code generated is correct. But note, this is NOT the same as me saying this isn&#8217;t a problem, this is a problem. It is just that this is caused by the declarations violating the rules of the C standard.</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-2 parent" id="comment-1346485">
				<div id="div-comment-1346485" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346485">
			June 13, 2018 at 5:15 pm</a>		</div>

		<p>I filed a bug against the team that owns that header file. Just sloppiness. Forgetting the calling convention is a common error. Since the unit test builds with the same compiler switches as the OS code (namely /Gz &#8211; stdcall as default), the lack of an explicit convention specifier is not detected.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-3 parent" id="comment-1346745">
				<div id="div-comment-1346745" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346745">
			June 14, 2018 at 10:02 am</a>		</div>

		<p>So it&#8217;s a double happy^Wsloppiness when such simple to spot bugs go undetected.<br />
Insane question: why doesn&#8217;t Microsoft let customers file such bugs directly?<br />
Thanks for picking this up.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-oldnewthing bypostauthor even depth-4 parent" id="comment-1346925">
				<div id="div-comment-1346925" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Raymond+Chen+-+MSFT' rel='external nofollow' class='url'>Raymond Chen - MSFT</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346925">
			June 14, 2018 at 3:33 pm</a>		</div>

		<p>In practice, what happens is that most of the bugs are low quality, and it&#8217;s hard to find the needle of good bugs in the haystack of bad ones.</p>

		
				</div>
		<ol class="children">
		<li class="comment odd alt depth-5" id="comment-1346995">
				<div id="div-comment-1346995" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1346995">
			June 15, 2018 at 4:20 am</a>		</div>

		<p>I consider every bug low quality.-)</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment even thread-odd thread-alt depth-1 parent" id="comment-1347375">
				<div id="div-comment-1347375" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1347375">
			June 16, 2018 at 10:14 am</a>		</div>

		<p>Are you able to find the MSVC keywords __cdecl, __stdcall or __fastcall (or anything like them which other compilers might support) in the standards you reference?<br />
Or the words &#8220;calling convention&#8221;?</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip odd alt depth-2 parent" id="comment-1347435">
				<div id="div-comment-1347435" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1347435">
			June 17, 2018 at 10:22 am</a>		</div>

		<p>Why does that matter? This isn&#8217;t as if this kind of problem stems from just the calling convention. Any time the declaration between two translation units is different, be it a compiler extension or from something in the language itself (32 bit type vs 64 bit type as one of the parameters) then this type of problem can still surface.</p>
<p>But the C++17 standard does actually use the term calling convention in relation to linkage specification. You can find this in 10.5 paragraph 1.</p>
<p>The C11 itself is a completely different thing. It implies that the description in the standard is for an abstract machine, and any implementation will have to fill in the gaps when porting to a real machine. So it does refer to abstract semantics and actual semantics. For example, 5.1.2.3 paragraph 9. So this acknowledges that the standard itself isn&#8217;t enough for a real machine and extra semantics are needed on real processors. There is also a note in 6.2.5 paragraph 14, note 44 that says an implementation is allowed to add keywords to provide alternative ways to designate a type. Function pointers are types, function prototypes are types, so this does allow for keywords like __cdecl and __stdcall to be used</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-3 parent" id="comment-1347535">
				<div id="div-comment-1347535" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1347535">
			June 18, 2018 at 9:23 am</a>		</div>

		<p>The definition of the function FN_PROGRESS was introduced with Windows XP (or earlier) for the TreeResetNamedSecurityInfo() function.<br />
This predates the introduction of the ODR: the ISO C++ standard 2003 came a little bit later.<br />
And it predates C11 by a decade.</p>
<p>So: was this bug NO bug before the introduction of the ODR with the ISO C standard (2011)?</p>
<p>You argue with something invented/introduced after the fact.</p>

		
				</div>
		<ol class="children">
		<li class="comment byuser comment-author-archangelpip odd alt depth-4 parent" id="comment-1347645">
				<div id="div-comment-1347645" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1347645">
			June 18, 2018 at 1:44 pm</a>		</div>

		<p>Of course not, I was just using the C11 standard since it was the latest. The C99 standard 6.2.5 paragraph 14 has note 34, and it has the same information. The C99, and C89/90 standards are also written to indicate that the behaviour in the standard is written for an abstract machine, and a real machine is allowed to have stricter semantics. The example that I gave, 5.1.2.3 paragraph 9 is 5.1.2.3 paragraph 8 in the C99 standard and it has the same information. Also, the C99 standard predates XP. Another thing, C++ was first standardised in 98, 03 was just a bug fixed version of 98 so the actual ODR and declarations across translation units issues was in standardised C++ prior to the release of Windows XP.<br />
But again this doesn&#8217;t matter, the issue with different declarations of the same functions predated the C++ standardisation, and even the C standardisation. This can be traced as far back to K&amp;R C where function declarations didn&#8217;t include parameter types. So it was well known back in the early 1980s how problematic calling functions with the incorrect function prototypes was. This actually seems like it was inherited from the B programming language too. When Dennis Ritchie took over maintaining B and this was a completely untyped language, one of the first things he did was to add variable types to the language, but functions still didn&#8217;t have prototypes. An interesting note, C actually added function prototypes to the standardised C89/90 standard after taking them from the pre-standardised C++.</p>

		
				</div>
		<ol class="children">
		<li class="comment even depth-5" id="comment-1348365">
				<div id="div-comment-1348365" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stefan Kanthak</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1348365">
			June 22, 2018 at 7:34 am</a>		</div>

		<p>Thanks! You just showed that your pickies weren&#8217;t pick^Wprecise enough in the first place.<br />
Regarding your also: note the slight difference between TreeResetNamedSecurityInfo() and TreeSetNamedSecurityInfo(), both in their names and the dates of their introduction.<br />
Don&#8217;t try to be picky&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-archangelpip odd alt depth-5" id="comment-1348495">
				<div id="div-comment-1348495" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1348495">
			June 22, 2018 at 12:46 pm</a>		</div>

		<p>@Stefan Kanthak<br />
Eh? I am confused here. The C standard has several clauses, that I have mentioned that declarations of objects in the same scope must match, this does include across translation units. That the calling convention is a machine specific semantic that the C standard supports, and is part of the function type and function pointer type.<br />
My being picky was based upon you stating that the compiler will generate the wrong code. I disagreed with you stating that the declaration of the functions is different between two translation units, and the code generated for the function given the type was correct. But this was an invalid program due to it violating the standard.<br />
You can find this in the C standard all the way back to the C89/90 standard, which predates Windows NT. While there is plenty of evidence in the C standard to support this, you told me that I wasn&#8217;t precise enough and that I shouldn&#8217;t be picky without providing any kind of counter debate?<br />
I&#8217;m sorry, but I do not understand this at all. Did you actually read the standards? Did it not even logically make sense to you that for the compiler to do the right thing that it needs to be given the correct information? Since two translation units are given different information, (the TreeSetNamedSecurityInfo function and your application) then how could it be a case of wrong code generation. It is like giving someone incorrect instructions regarding a task, and after they did the work you tell them that they did the wrong work.<br />
Finally, so what if TreeResetNamedSecurityInfo was in Windows XP. It wasn&#8217;t as if that counters the C standard definitions being standardised since 1989. Windows XP was released in 2001, this is a whole 12 years after the C standard initially stated that two declarations in the same scope referring to the same object must match. So please tell me, where was I not precise enough?</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li class="comment byuser comment-author-archangelpip even depth-4" id="comment-1347655">
				<div id="div-comment-1347655" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Darran+Rowe' rel='external nofollow' class='url'>Darran Rowe</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20180613-00/?p=98995#comment-1347655">
			June 18, 2018 at 1:49 pm</a>		</div>

		<p>Oh, and also, the Windows headers indicate that TreeSetNamedSecurityInfo was added in Windows Vista. The function definitions are wrapped in #if (NTDDI_VERSION &gt;= NTDDI_VISTA).</p>

		
				</div>
		</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

