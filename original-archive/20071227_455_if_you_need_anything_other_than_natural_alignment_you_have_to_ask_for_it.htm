<html>
<head>
<title>If you need anything other than natural alignment, you have to ask for it</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>If you need anything other than natural alignment, you have to ask for it</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 27, 2007 / year-entry #456</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>27</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">If you need variables to be aligned a particular way, you need to ask for it. Let's say I have the following code: void fn() { int a; char b; long c; char d[10]; } What would the alignment of the starting adresses of a,b,c and d be? What would the alignment be if the...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
If you need variables to be aligned a particular way,
you need to ask for it.
</p>
<blockquote CLASS=q>
<p>
Let's say I have the following code:
</p>
<pre>
void fn() 
{ 
 int a; 
 char b; 
 long c; 
 char d[10];
} 
</pre>
<p>
What would the alignment of the starting adresses of a,b,c and d be?
</p>
<p>
What would the alignment be if the memory were allocated on heap?
</p>
<p>
If this alignment varies for different data types
within the same translation unit,
is there a way to force uniform alignment for all types?
</p>
</blockquote>
<p>
If you need a particular alignment, you have to ask for it.
By default,
all you can count on is that
variables are aligned according to their natural requirements.
</p>
<p>
First, of course, there is no guarantee that local variables
even reside on the stack.
The optimizer may very well decide that particular local
variables can reside in registers, in which case it has no
alignment at all!
</p>
<p>
There are a few ways to force a particular alignment.
The one that fits the C language standard is to use a union:
</p>
<pre>
union char_with_int_alignment {
 char ch;
 int Alignment;
} u;
</pre>
<p>
Given this union, you can say <code>u.ch</code> to obtain a
character whose alignment is suitable for an integer.
</p>
<p>
The Visual C++ compiler supports a declaration specifier to
override the default alignment of a variable.
</p>
<pre>
typedef struct __declspec(align(16)) _M128 {
    unsigned __int64 Low;
    __int64 High;
} M128, *PM128;
</pre>
<p>
This structure consists of two eight-byte members.
Without the <code>__declspec(align(#))</code> directive,
the alignment of this structure would be 8-byte,
since that is the alignment of the members with the most
restrictive alignment.
(Both <code>unsigned __int64</code> and
<code>__int64</code> are naturally 8-byte-aligned.)
But with the directive, the aligment is expanded to 16&nbsp;bytes,
which is more restrictive than what the structure normally would be.
This particular structure is declared with more restrictive
alignment because it is intended to be use to hold 128-bit values
that will be used by the 128-bit XMM registers.
</p>
<p>
A third way to force alignment with the Visual C++ compiler
is to use the <code>#pragma pack(#)</code> directive.
(There is also a "push" variation of this pragma which remembers
the previous ambient alignment, which can be restored by
a "pop" directive.
And the <code>/Zp#</code> directive allows you to specify this
pragma from the compiler command line.)
This directive specifies that members can be placed at alignments
suitable for <code>#</code>-byte objects rather than their natural
alignment requirements, if the natural alignment is more restrictive.
For example, if you set the pack alignment to 2, then all objects
that are bigger than two bytes will be aligned
as if they were two-byte objects.
This can cause 32-bit values and 64-bit values to become mis-aligned;
it is assumed that you know what you're doing any can compensate
accordingly.
</p>
<p>
For example, consider this structure whose natural alignment
has been altered:
</p>
<pre>
#pragma pack(1)
struct misaligned_members {
 WORD w;
 DWORD dw;
 BYTE b;
};
</pre>
<p>
Given this structure, you cannot pass the address of the
<code>dw</code> member to a function that expects a
pointer to a <code>DWORD</code>,
since the ground rules for programming
specify that all pointers must be aligned unless unaligned
pointers are explicitly permitted.
</p>
<pre>
void ExpectsAlignedPointer(DWORD *pdw);
void UnalignedPointerOkay(UNALIGNED DWORD *pdw);

misaligned_members s;
ExpectsAlignedPointer(&amp;s.dw); // wrong
UnalignedPointerOkay(&amp;s.dw);  // okay
</pre>
<p>
What about the member <code>w</code>?
Is it aligned or not?
Well, it depends.
</p>
<p>
If you allocate a single structure on the heap,
then the <code>w</code> member is aligned,
since heap allocations are always aligned in a manner suitable
for any fundamental data type.
(I vaguely recall some possible weirdness with 10-byte floating point
values, but that's not relevant to the topic at hand.)
</p>
<pre>
misaligned_members *p = (misaligned_members)
    HeapAllocate(hheap, 0, sizeof(misaligned_members));
</pre>
<p>
Given this code fragment, the member
<code>p-&gt;w</code> is aligned since the entire structure
is suitably aligned, and therefore so too is <code>w</code>.
If you allocated an array, however, things are different.
</p>
<pre>
misaligned_members *p = (misaligned_members)
    HeapAllocate(hheap, 0, 2*sizeof(misaligned_members));
</pre>
<p>
In this code fragment, <code>p[1].w</code> is not aligned
because the entire <code>misaligned_members</code> structure
is 2+4+1=7 bytes in size since the packing is set to&nbsp;1.
Therefore, the second structure begins at an unaligned offset
relative to the start of the array.
</p>
<p>
One final issue is the expectations for alignment when using
header files provided by an outside component.
If you are writing a header file that will be consumed by others,
and you require special alignment, you need to say so explicitly
in your header file,
because you don't control the code that will be including your
header file.
Furthermore, if your header file changes any compiler settings,
you need to restore them before your header file is complete.
If you don't follow this rule, then you create the situation where
a program stops working if a program changes the order in which
it includes seemingly-unrelated header files.
</p>
<pre>
// this code works
#include &lt;foo.h&gt;
#include &lt;bar.h&gt;

// this code doesn't
#include &lt;bar.h&gt;
#include &lt;foo.h&gt;
</pre>
<p>
The problem was that <code>bar.h</code> changed the default
structure alignment and failed to return it to the original value
before it was over.
As a result, in the second case,
the structure alignment for the <code>foo.h</code> header file
got "infected" and no longer matched the structure alignment
used by the <code>foo</code> library.
</p>
<p>
You can imagine an analogous scenario where deleting a header file can
cause a program to stop working.
</p>
<p>
Therefore, if you're writing a header file that will be used by others,
and you require nonstandard alignment for your structures,
you should use this pattern to change the default alignment:
</p>
<pre>
#include &lt;pshpack1.h&gt; // change alignment to 1
... stuff that assumes byte packing ...
#include &lt;poppack.h&gt;  // return to original alignment
</pre>
<p>
In this way, you "leave things the way you found them"
and avoid the mysterious infection scenarios described above.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (27)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment byuser comment-author-nathan_works even thread-even depth-1" id="comment-582093">
				<div id="div-comment-582093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/nathan_works' rel='external nofollow' class='url'>nathan_works</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582093">
			December 27, 2007 at 10:38 am</a>		</div>

		<p>Help me out, since I&#8217;m not creative enough to envision non-academic scenarios where such things are needed.. About all I can think of was back to Database class where we mangled a disk simulator to write B-tree database structures to the fake disk, and read them back into arbitrary data records. In that scenario, no data was ever aligned, and it was pretty obnoxious. Outside of that, I&#8217;ve never dealt with data alignment or needing to have it aligned in any commercial software I&#8217;ve worked on. So why would someone want or need to know this ?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582123">
				<div id="div-comment-582123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Csaboka</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582123">
			December 27, 2007 at 10:59 am</a>		</div>

		<p>Well, x86 CPUs are quite forgiving about memory alignment, so you can get away with ignoring it altogether. (The code will run more slowly when accessing incorrectly aligned data, but it will still be correct.) Other CPUs can raise an exception or do other Bad Things when you try to access misaligned data, and then correct alignment becomes vital.</p>
<p>In other words, if you ignore alignment issues, you can write code that seems to be perfect ANSI C, and runs on PCs, but dies spectacularly when running it on something else&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582133">
				<div id="div-comment-582133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">njkayaker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582133">
			December 27, 2007 at 11:01 am</a>		</div>

		<p>I have a binary file format that I needed to support (years ago) across different versions of Windows (16bit and 32bit). Since the default alignments are different for 16bit and 32bit programs, I was able to force the alignment to be the same in all environments.</p>
<p>Basically, my case was being able to pass structured data between different computers.</p>
<p>I think the need for this is fairly rare.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582143">
				<div id="div-comment-582143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582143">
			December 27, 2007 at 11:14 am</a>		</div>

		<p>As njkayaker says, anything involving structured data might need specific alignment, if only for speed. &nbsp;This is especially important for using network protocols efficiently. &nbsp;The Win32 API is built on structures, some of which have unnatural alignment.</p>
<p>3D code and high-speed stuff that depends on the cache will require careful alignment. &nbsp;In managed languages it matters less, but if you&#8217;re writing in C++, you should always know at least roughly what your memory looks like.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582153">
				<div id="div-comment-582153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://fluff.info/blog' rel='external nofollow' class='url'>B</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582153">
			December 27, 2007 at 11:40 am</a>		</div>

		<p>This may mark me as a newbie to this territory, but why not just stick with union any time you need alignment? It&#8217;s standard, and doesn&#8217;t have the many caveats that you attach to the other methods.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582173">
				<div id="div-comment-582173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bobby</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582173">
			December 27, 2007 at 11:42 am</a>		</div>

		<p>Most major backup formats use packed data structures on tape or in backup files.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582193">
				<div id="div-comment-582193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Frank Schwab</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582193">
			December 27, 2007 at 11:52 am</a>		</div>

		<p>B &#8211;</p>
<p>I almost never see structure packing used when a program runs on a platform, and is &quot;self contained&quot;. &nbsp;I see it quite a bit when two programs, running on different computers, are trying to communicate using a shared set of structures. &nbsp;Anonymous above touched on the same point with Network structures.</p>
<p>&#8216;C&#8217; is very vague about structure packing. &nbsp;For example, on the embedded RISC processor I&#8217;m using now, the compiler likes to align everything on 32 bit boundaries; so a structure like:</p>
<p>struct</p>
<p>{</p>
<p>&nbsp;unsigned char a;</p>
<p>&nbsp;unsigned char b;</p>
<p>} c;</p>
<p>takes 8 bytes of memory. &nbsp;If I pass this structure across a communications port (Say, TCP/IP across Ethernet, or even USB) to another computer, the second computer may not correctly read the data. &nbsp;If, for example, the compiler on the second computer aligns the two elements on byte boundaries, the structure would only take up 2 bytes on the second computer, and the likelihood of succesfully transferring information between the two is low.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582203">
				<div id="div-comment-582203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Steve Nuchia</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582203">
			December 27, 2007 at 12:04 pm</a>		</div>

		<p>I&#8217;ve done intense systems-level programming in C and C++ for over two decades. &nbsp;In that time I&#8217;ve found about a dozen compiler bugs, used goto in production code perhaps three or four times, and had to step outside the portable parts of the languages to specify data alignment twice.</p>
<p>On the other hand, I&#8217;ve had to know what the compiler was doing about alignment pretty much every day. &nbsp;And just because I was able to use the portable portions of the language to get the alignment I needed doesn&#8217;t mean the code was portable &#8212; ifdefs are frequently needed.</p>
<p>Back in the day the Unix programming community was infected by the &quot;all the world is a VAX&quot; disease. &nbsp;Programmers who had the luxury of workingonly on the VAX believed ints were 32 bits and if p is null then *p is zero, to name just two of the symptoms of this disease. &nbsp;Today it is the PC that forms the basis for what most programmers think they know about portability.</p>
<p>This is another one of those posts from Mr. Chen that is incredibly valuable if you happen to need it but completely useless otherwise. &nbsp;If you think it is useless that&#8217;s just because the scope of your work has not yet included the need for it. &nbsp;Think and learn.</p>
<p>Word to the wise: in the brave new multicore world alignment and allocation issues will become one of the two or three determining factors of program performance. &nbsp;This is really very different from anything most programmers have experienced before, and to fix the problems post-hoc will be very hard.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582223">
				<div id="div-comment-582223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://vijairaj.blogspot.com' rel='external nofollow' class='url'>vijairaj</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582223">
			December 27, 2007 at 1:12 pm</a>		</div>

		<p>When it comes to packing, I would prefer gcc&#8217;s way of doing it &#8211; struct {&#8230;} <strong>attribute</strong> ((packed)). This method allows to specify the alignment requirement as an attribute to the structure definition itself, rather than as a separate #pragma push &amp; pop pack. I have seen code in many places where a header file has #pragma pack(push) in the top and a pop at the end. When an unaware user copies one of these packed structures, then the results are scary.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-benkaras odd alt thread-odd thread-alt depth-1" id="comment-582233">
				<div id="div-comment-582233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">benkaras</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582233">
			December 27, 2007 at 2:15 pm</a>		</div>

		<p>Vijairaj: Read Raymond&#8217;s post again. &nbsp;Look for the paragraph where he shows __declspec(align(16)).</p>
<p>B: Unions cannot pack things tighter than they otherwise would be</p>
<p>Frank hit it on the head. &nbsp;If you have shared data, you often must be explicit about the alignment. &nbsp;It can get really hairy when you have a 32bit program writing data that will be read bya &nbsp;64bit program. &nbsp;That&#8217;s when alignment matters most.</p>
<p>It is also rather important to pack persisted data since smaller reads make for faster reads. &nbsp;</p>
<p>Finally, in Windows shell namespace extensions, it is a common practice to pack IDLists since they take up memory and are sometimes persisted.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582283">
				<div id="div-comment-582283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anonymous</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582283">
			December 27, 2007 at 3:22 pm</a>		</div>

		<p>Forcing the alignment is not enough for reading/writing a binary file format (or passing data to/from another computer). You also have to worry about endianess (for instance, TCP/IP is big-endian, while x86 is little-endian).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582303">
				<div id="div-comment-582303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">rbirkby</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582303">
			December 27, 2007 at 4:15 pm</a>		</div>

		<p>So as you&#8217;re a shell guy, whose bright idea was it to specify SHCOLUMNINFO as 1-byte alignment? Was the expectation that there would be so many columns in a details view that the saving would be worthwhile? Really? Even when Explorer was first written for Cairo back in 1991?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582313">
				<div id="div-comment-582313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582313">
			December 27, 2007 at 5:12 pm</a>		</div>

		<p>What pisses me off is the inability to get aligned memory back from new[] operator.</p>
<p>Say you have a class:</p>
<p>class Foo</p>
<p>{</p>
<p>public:</p>
<pre><code>__m128  vec;

Foo(void)

{

    vec = _mm_setzero_ps();

}
</code></pre>
<p>};</p>
<p>When you do this:</p>
<p>Foo *p = new Foo[5];</p>
<p>It will crash because of MOVAPS in the constructor is expecting 16-byte aligned memory.</p>
<p>To fix the problem, you have to overload new[] and delete[] and use _mm_malloc() and _mm_free() even though compiler could align the memory for you &#8212; I believe it has enough information about the Foo object size and alignment requirements at compile time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582333">
				<div id="div-comment-582333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">njkayaker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582333">
			December 27, 2007 at 6:07 pm</a>		</div>

		<p>&quot;This may mark me as a newbie to this territory, but why not just stick with union any time you need alignment? It&#8217;s standard, and doesn&#8217;t have the many caveats that you attach to the other methods.&quot;</p>
<p>Unions allow different types to -share- the same memory by forcing an alignment that works for all the types. (Note that heap memory is typically aligned for all types: It&#8217;s union for all.)</p>
<p>The &quot;packing&quot; stuff mucks with the gaps between different memory blocks in a structure (it has nothing to do with sharing).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582353">
				<div id="div-comment-582353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">scorpion007</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582353">
			December 27, 2007 at 6:58 pm</a>		</div>

		<p>Shouldn&#8217;t you be casting to (misaligned_members *) instead of (misaligned_members)?</p>
<p>And isn&#8217;t the function HeapAlloc(), not HeapAllocate()?</p>
<p>But other than that, thanks for the fantastic information :)</p>
<div class=post>[<i>There may very well be errors. I assume you&#8217;re smart enough to be able to fix them on your own. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582363">
				<div id="div-comment-582363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">KJK::Hyperion</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582363">
			December 27, 2007 at 7:48 pm</a>		</div>

		<p>Automatic (stack) allocation doesn&#8217;t guarantee the correct alignment, only &quot;good enough&quot; alignment, i.e., given &quot;type stack_variable;&quot;, &quot;(INT_PTR)&amp;stack_variable % TYPE_ALIGNMENT(type)&quot; might not be zero. This is an issue if half your code is in user mode and the other half in kernel mode, and you need to call ProbeForRead/ProbeForWrite on one such object (they will raise STATUS_DATATYPE_MISALIGNMENT). Setting packing to a larger value won&#8217;t help. The safest solution is to declare &quot;type&quot; as &quot;DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) type&quot;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582393">
				<div id="div-comment-582393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabest</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582393">
			December 27, 2007 at 11:35 pm</a>		</div>

		<p>I ran into a compiler bug around the time when openmp was new in vc, it didn&#8217;t align declspec&#8217;ed stack variables correctly.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-582563">
				<div id="div-comment-582563" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582563">
			December 28, 2007 at 12:59 pm</a>		</div>

		<p>Pragma pack was far more common on DOS-based handheld computers, because packing could actually make the difference between the customer&#8217;s data fitting into RAM and not fitting. This counted for both running program memory and &#8216;disk&#8217; storage, for these devices didn&#8217;t have fixed disks, only RAM disks of up to 4MB, but RAM was very expensive on these units!</p>
<p>On Windows CE on ARM processors you want to avoid it like the plague because it massively bloats your code, as the processor itself will generate misalignment faults, so the code has to include every possible pattern for misalignment.</p>
<p>In a very few cases when porting code from the old devices to the new, we want the on-&#8216;disk&#8217; structures to be the same, and we&#8217;ll leave the packing pragma in. Otherwise, it comes out.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582653">
				<div id="div-comment-582653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Stewart</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582653">
			December 28, 2007 at 1:51 pm</a>		</div>

		<p>B, the other problem with only ever using union is that it only provides a way to increase the packing &#8211; you can&#8217;t reduce it, so say you have the following struct</p>
<p>struct { short a; short b; int c; } a;</p>
<p>By default on WIN32 using VC++ a and b will be packed into four bytes (IIRC) and c will follow so sizeof(a) will be 8 bytes. If you wanted a to occupy four bytes, this could be done with a union (this is most often done when you have a one element array at the end of a structure which is really of variable length).</p>
<p>Unfortunately, if you have this</p>
<p>struct ( short a; int b } a;</p>
<p>a will be two bytes followed by two bytes of padding to make b dword aligned (again on win32 with VC++) &#8211; there is no way that I know of with a union to tell the compiler that actually you want the size of this structure to be six bytes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-582943">
				<div id="div-comment-582943" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Allan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582943">
			December 29, 2007 at 7:50 pm</a>		</div>

		<p>Are there cases where misalignement of data on Windows/x86 causes slower execution?</p>
<p>Most docs I searched were either for RISC architecture, or were somewhat imprecise with the concept.</p>
<p>For example, the following link:</p>
<p><a href="http://msdn2.microsoft.com/en-us/library/aa984851" target="_new" rel="nofollow">http://msdn2.microsoft.com/en-us/library/aa984851</a>(vs.71).aspx</p>
<p>Speaks about performance issue on 386 and RISC processors, but nothing on 486 or pentiums. Are these last processors immune to the speed degradation induced by misaligned data?</p>
<p>Thanks!</p>
<div class="post">[<i>You need to improve your search engine skills. I searched for <u>site:intel.com misaligned</u> and found lots of information, including <a href="http://www.intel.com/software/products/compilers/flin/docs/main_for/mergedProjects/optaps_for/common/optaps_vec_exmp.htm" rel="nofollow">this page</a> which says that a misaligned access causes a six- to twelve-cycle stall. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-582993">
				<div id="div-comment-582993" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-582993">
			December 30, 2007 at 12:57 am</a>		</div>

		<p>&quot;Are there cases where misalignement of data on Windows/x86 causes slower execution?&quot;</p>
<p>There are also cases where it causes NO execution. For SIMD data types if you acccess unaligned memory with MOVAPS/MOVDQA (instead of MOVUPS/MOVDQU) you get a crash.</p>
<p>MOVUPS/MOVDQU in combination with unaligned memory can result in 50% slower execution time compared to properly aligned data and MOVAPS/MOVDQA.</p>
<p>Always align your data in memory, especially for SIMD data types!</p>
<p>Also, if you have two threads accessing variables which reside next to each other in memory, make sure you align those variables to the cache line boundary (i.e. so that they end up in different cache lines) in order to prevent false sharing which is a significant performance penalty).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-583003">
				<div id="div-comment-583003" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor Levicki</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-583003">
			December 30, 2007 at 1:02 am</a>		</div>

		<p>Here &#8212; Intel&#174; 64 and IA-32 Architectures Optimization Reference Manual:</p>
<p><a rel="nofollow" target="_new" href="http://developer.intel.com/design/processor/manuals/248966.pdf" rel="nofollow">http://developer.intel.com/design/processor/manuals/248966.pdf</a></p>
<p>You may find that x86 is not as forgiving when it comes to alignment after all, it is just that some of you have chosen to ignore it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-583033">
				<div id="div-comment-583033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Allan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-583033">
			December 30, 2007 at 7:40 am</a>		</div>

		<p>&gt; You need to improve your search engine skills.</p>
<p>Thanks. I&#8217;m reading the page right now. At first glance, I&#8217;m feel like, ahem, I&#8217;m reading japanese&#8230;</p>
<p>:-p</p>
<p>Anyway, this is the way we learn, so&#8230;</p>
<p>:-)</p>
<p>&gt; You may find that x86 is not as forgiving when it comes to alignment after all, it is just that some of you have chosen to ignore it.</p>
<p>Thanks for the link to the PDF.</p>
<p>I will forward the info to the people who *did* make misalignement-related decisions years before I joined the team.</p>
<p>;-p</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-583113">
				<div id="div-comment-583113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miral</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-583113">
			December 31, 2007 at 4:14 am</a>		</div>

		<p>I know the feeling. &nbsp;I work with a large codebase that&#8217;s pretty much entirely been #pragma pack(1)&#8217;d &#8212; largely because it&#8217;s been inherited from way back in the DOS ages and it has a lot of structures representing on-disk record layouts. &nbsp;I&#8217;ve been itching to get rid of it (or at least reduce the scope a bit) for a while now but haven&#8217;t been able to get approval.</p>
<p>Interestingly it all still runs just fine even with the misalignments &#8212; and this is for a soft-real-time control system, so performance is important&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-583133">
				<div id="div-comment-583133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-583133">
			December 31, 2007 at 5:58 am</a>		</div>

		<p>I got badly bitten by alignment issues on an embedded platform. The X86 version ran without problems, but on the PPC version I was getting the occasional wrong value for a floating point number.</p>
<p>It turned out to be a bug on the logic board. Reading a misaligned float on that particular processor was supposed to raise an exception, but the exception was being lost and the program was silently continuing with zero instead of the proper value.</p>
<p>Discovering it was an alignment issue took a bit of psychic debugging to start with. Fixing it was the next problem.</p>
<p>I couldn&#8217;t change the alignment so I had to write a macro to copy the misaligned data (as a bit-pattern) into an aligned buffer and then read it from there as a float.</p>
<p>Finding every instance where the program read a float that could possibly be misaligned was an experience I would prefer not to have to repeat. It is not out of the question that there are one or two instances left in there, and I might never know.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick odd alt thread-odd thread-alt depth-1" id="comment-583123">
				<div id="div-comment-583123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-583123">
			December 31, 2007 at 4:48 am</a>		</div>

		<p>There are still a few pages on MSDN which refer to &#8216;386&#8217; as a general term for 32-bit x86 processors. For 386, generally, read &#8216;386 and later&#8217; unless specifically noted otherwise.</p>
<p>Another thing you need to watch out for is misaligning anything you plan to use with interlocked instructions. If you do, x86 processors will still perform the requested operation (add, exchange, compare) BUT it won&#8217;t be properly interlocked &#8211; it&#8217;ll do two read/write cycles to the two aligned locations with the LOCK line asserted, but the intra-CPU bus doesn&#8217;t have any way to associate the two operations as being atomic.</p>
<p>I&#8217;m not sure but I think Raymond&#8217;s example link is actually talking about how the Intel Fortran compiler is using SSE instructions (that would fit with the 16-byte = 128-bit alignment), although it could be related to cache lines (the processor *actually* asks for data from main memory in cache-line chunks, to take advantage of the &#8216;burst mode&#8217; sequential output of all RAM modules since EDO, unless performing interlocked accesses or other non-combining reads or writes). I&#8217;m not sure how big current cache lines are, I think it&#8217;s 64 bytes.</p>
<p>Speaking of cache lines, here&#8217;s something interesting I found relating to Core 2: apparently regular unaligned reads are not too bad, but you get a perf hit if they cross cache line boundaries, and an even bigger one crossing page boundaries. Source: <a rel="nofollow" target="_new" href="http://forums.xkcd.com/viewtopic.php?f=11&amp;t=15337" rel="nofollow">http://forums.xkcd.com/viewtopic.php?f=11&#038;t=15337</a>. Because cache line boundaries and page boundaries are (large) multiples of 8 bytes, if your structures are aligned you&#8217;ll be OK, or at least you won&#8217;t hit this particular problem.</p>
<p>A lot of programmers have a mental model of the computer that is twenty years out of date. To understand the modern machine, I suggest watching Herb Sutter&#8217;s presentation to the Northwest C++ Users&#8217; Group, &quot;Machine Architecture: Things Your Programming Language Never Told You&quot; at <a rel="nofollow" target="_new" href="http://www.nwcpp.org/Meetings/2007/09.html" rel="nofollow">http://www.nwcpp.org/Meetings/2007/09.html</a>.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-585063">
				<div id="div-comment-585063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">anonymous coward</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20071227-00/?p=24013#comment-585063">
			January 3, 2008 at 8:46 am</a>		</div>

		<p>Raymond,</p>
<p>you state:</p>
<p>&quot;There are a few ways to force a particular alignment. The one that fits the C language standard is to use a union:</p>
<p>union char_with_int_alignment {</p>
<p>char ch;</p>
<p>int Alignment;</p>
<p>} u;</p>
<p>Given this union, you can say u.ch to obtain a character whose alignment is suitable for an integer.&quot;</p>
<p>The C language standard does not state (or even know) anything about alignment. In fact, the way a union is described, a compiler is even free to treat a &quot;union&quot; like a &quot;struct&quot;, and still be a C compiler.</p>
<p>Another option for a compiler might be to put the ch at ((char*)&amp;Alignment)[1] or so, and still be according to the C standard. (No, I am not arguing if this would make sense in most cases, but the compiler is indeed free to do so).</p>
<p>The fine print: There is NO way to do this totally portable. Of course, experience tells us that on most compilers, this will indeed work.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

