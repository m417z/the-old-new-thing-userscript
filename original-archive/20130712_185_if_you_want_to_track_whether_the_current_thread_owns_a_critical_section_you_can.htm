<html>
<head>
<title>If you want to track whether the current thread owns a critical section, you can use the critical section itself to protect it</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>If you want to track whether the current thread owns a critical section, you can use the critical section itself to protect it</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>July 12, 2013 / year-entry #186</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>42</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">You may find yourself in the situation where you want to keep track of the owner of a critical section. This is usually for debugging or diagnostic purposes. For example, a particular function may have as a prerequisite that a particular critical section is held, and you want to assert this so that you can...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
You may find yourself in the situation where you want to keep
track of the owner of a critical section.
This is usually for debugging or diagnostic purposes.
For example,
a particular function may have as a prerequisite that a particular
critical section is held,
and you want to assert this so that you can catch the problem
when running the debug build.
</p>
<p>
<pre>
class CriticalSectionWithOwner
{
public:

  CriticalSectionWithOwner() : m_Owner(0), m_EntryCount(0)
  {
    InitializeCriticalSection(&amp;m_cs);
  }

  ~CriticalSectionWithOwner()
  {
    DeleteCriticalSection(&amp;m_cs);
  }

  void Enter()
  {
    EnterCriticalSection(&amp;m_cs);
#ifdef DEBUG
    m_Owner = GetCurrentThreadId();
    m_EntryCount++;
#endif
  }

  void Leave()
  {
#ifdef DEBUG
    if (--m_EntryCount == 0) {
      m_Owner = 0;
    }
#endif
    LeaveCriticalSection(&amp;m_cs);
  }

#ifdef DEBUG
  bool IsHeldByCurrentThread()
  {
    return m_EntryCount &amp;&amp;
           m_Owner == GetCurrentThreadId();
  }
#endif

private:
  CRITICAL_SECTION m_cs;
#ifdef DEBUG
  DWORD m_Owner;
  int m_EntryCount;
#endif
};
</pre>
<p>
After we successfully enter the critical section,
we mark the current thread as the owner and increment the
entry count.
Before leaving the critical section, we see if this is the last exit,
and if so, we clear the owner field.
</p>
<p>
Note that we update the owner and entry count while the critical
section is held.
We are using the critical section to protect its own diagnostic data.
</p>
<p>
The subtle part is the
<code>Is&shy;Held&shy;By&shy;Current&shy;Thread</code> function.
Let's look at the cases:
</p>
<p>
First, if the current thread is the owner of the critical section,
then we know that the diagnostic data is safe to access
because we own the critical section that protects it.
That's not the subtle part.
</p>
<p>
The subtle part is the case where the current thread is <i>not</i>
the owner of the critical section.
A na&iuml;ve analysis would say that the diagnostic data is off limits
because you are trying to access it without owning the protective
critical section.
But what value can
<code>m_Owner</code> have at this point?
</p>
<ol>
<li>If the critical section is not held, then
    <code>m_Owner</code> will be zero, which will be unequal to the
    current thread ID.</p>
<li>If the critical section is held, then
    <code>m_Owner</code> will be the owner of the critical section,
    which will also be unequal to the current thread ID.
</ol>
<p>
But what if the value of <code>m_Owner</code> changes while we
are looking at it?
Well, since we are not the owner of the critical section,
it can only change between the two states above
(possibly from one state&nbsp;2 to another state&nbsp;2).
In other words, it can only change from one value that is not
equal to the current thread ID
to another value that is <i>still</i> not equal to the current
thread ID.
Therefore, even if we race against another thread entering or
leaving the critical section,
the fact that the owner of the critical section is <i>not us</i>
doesn't change.
</p>
<p>
Note that this analysis assumes that the <code>m_Owner</code>
is a suitably-aligned value that can be updated atomically.
(If not, then it's possible that a torn value will be read
which coincidentally matches our thread ID.)
</p>
<p>
Since the <code>CRITICAL_<wbr>SECTION</code> itself must already
be suitably aligned,
placing the <code>DWORD</code> up against it will also align
the <code>DWORD</code>.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (42)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-1067023">
				<div id="div-comment-1067023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">xix</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067023">
			July 12, 2013 at 7:03 am</a>		</div>

		<p>(Aside due to RAMP&#39;s post no longer accepting comments): &nbsp;If you missed Raymond&#39;s presentation, it&#39;s recorded here:</p>
<p><a rel="nofollow" target="_new" href="http://www.ustream.tv/recorded/35704183">http://www.ustream.tv/&#8230;/35704183</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067033">
				<div id="div-comment-1067033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067033">
			July 12, 2013 at 7:12 am</a>		</div>

		<p>Is GetCurrentThreadId() guaranteed to never return 0? &nbsp;I assume it is, but I don&#39;t see that listed in the documentation.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067043">
				<div id="div-comment-1067043" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067043">
			July 12, 2013 at 7:16 am</a>		</div>

		<p>That the Thread ID cannot be zero would be a property of the thread id, not a property of GetCurrentThreadId function. Therefore you have to look at the description of the properties of the Thread ID, and voila, there it is stated:</p>
<p>A thread can use the GetCurrentThreadId function to get its own thread identifier. The identifiers are valid from the time the thread is created until the thread has been terminated. Note that no thread identifier will ever be 0.</p>
<p>Quote from MSDN at <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms686746%28v=vs.85%29.aspx">msdn.microsoft.com/&#8230;/ms686746%28v=vs.85%29.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067053">
				<div id="div-comment-1067053" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067053">
			July 12, 2013 at 7:16 am</a>		</div>

		<p>&#8230;and of course if I&#39;d bothered to Google, I would&#39;ve found <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx">blogs.msdn.com/&#8230;/78395.aspx</a> before posting that. &nbsp;Yes, 0 is an invalid thread ID as one would expect, but that fact is only implied in the documentation of other semi-related functions. &nbsp;The documentation for GetCurrentThreadId() and friends ought to be more explicit about such things.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1067063">
				<div id="div-comment-1067063" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067063">
			July 12, 2013 at 7:20 am</a>		</div>

		<p>I suppose, while you&#39;re at it, you could add an ASSERT(m_EntryCount == 0) in the destructor.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits odd alt thread-odd thread-alt depth-1" id="comment-1067073">
				<div id="div-comment-1067073" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067073">
			July 12, 2013 at 7:22 am</a>		</div>

		<p>And in the beginning of Leave():</p>
<p>ASSERT(m_EntryCount &gt; 0 &amp;&amp; m_Owner == GetCurrentThreadId())</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067083">
				<div id="div-comment-1067083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067083">
			July 12, 2013 at 7:22 am</a>		</div>

		<p>@Adam: I don&#39;t think it&#39;s the responsibility of each function receiving or returning a thread id to re-state all the properties of a thread id. That&#39;s like restating all the properties of an integer on every function working with an integer. If you want invariants about a type you&#39;d look at the types documentation, not at functions working with the type.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067093">
				<div id="div-comment-1067093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067093">
			July 12, 2013 at 7:27 am</a>		</div>

		<p>Why are m_Owner and m_EntryCount not required to be &quot;volatile&quot;? Does this example assume a) &quot;DEBUG&quot; always means no compiler optimizations, including those that would cache the values, and b) x86 architecture, where the memory model is essentially &quot;everything&#39;s volatile&quot; anyway?</p>
<p>Or is there some other guarantee going on that allows those members to be used without &quot;volatile&quot; semantics, even on non-x86 architectures and in optimized builds?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067103">
				<div id="div-comment-1067103" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067103">
			July 12, 2013 at 7:31 am</a>		</div>

		<p>@Zarat: Fair enough. &nbsp;But it is interesting that GetThreadId() lists a return value of 0 as an error, whilst GetCurrentThreadId() makes no similar mention (presumably because it can&#39;t fail).</p>
<p>I just thought of another interesting potential edge case &#8212; if a thread exits while holding the critical section, and that thread&#39;s ID gets reused for another thread, wouldn&#39;t that other thread mistakenly think it owned the critical section? &nbsp;How long does it take for thread IDs to be reused?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067113">
				<div id="div-comment-1067113" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067113">
			July 12, 2013 at 7:35 am</a>		</div>

		<p>0 sounds like a value one would get back if GetCurrentThreadId failed. But how can that happen? Non-Win32 thread? If so, somebody really screwed up if it&#39;s got Win32 code running on it and EnterCriticalSection is probably dead meat.</p>
<p>Incidentally, 0 is a valid process id, but it won&#39;t be a Win32 process (it&#39;s the System Idle Process). You can&#39;t inject Win32 code in that.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-1067123">
				<div id="div-comment-1067123" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067123">
			July 12, 2013 at 7:40 am</a>		</div>

		<p>&gt; wouldn&#39;t that other thread mistakenly think it owned the critical section</p>
<p>Yup.</p>
<p>&gt; How long does it take for thread IDs to be reused</p>
<p>Developers should assume that thread IDs are reused at the worst possible time&#8230; that is, that the agent handing out thread IDs is malicious.</p>
<p>If you want to know whether a given thread is still around, you need a thread handle. You can call WaitForSingleObject(h, 0) == WAIT_OBJECT_0 to know whether the thread has exited.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067143">
				<div id="div-comment-1067143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Zarat</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067143">
			July 12, 2013 at 7:50 am</a>		</div>

		<p>Reusing the thread id cannot change it from &quot;not my thread id&quot; to &quot;my thread id&quot; (or reverse) because that would mean someone just got the same thread id assigned as the currently running thread.</p>
<p>But I agree with the others who are being cautious, I don&#39;t trust myself enough to be understand all the corner cases a compiler or non-x86 platform can introduce. I&#39;d probably use a C++11 atomic variable to let it do the hard work of figuring out how to &quot;get it right&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067153">
				<div id="div-comment-1067153" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Damien</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067153">
			July 12, 2013 at 7:53 am</a>		</div>

		<p>Is the m_EntryCount test in IsHeldByCurrentThread just an optimization to avoid calling GetCurrentThreadId()?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067163">
				<div id="div-comment-1067163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067163">
			July 12, 2013 at 8:01 am</a>		</div>

		<p>@pete.d: I don&#39;t think that the lack of volatile here is a problem. &nbsp;If the thread is the owner of the critical section, then if that thread calls IsHeldByCurrentThread(), it&#39;s the same thread which is reading and writing m_Owner and m_EntryCount, so there are no threading/caching issues.</p>
<p>Conversely, if another thread tries reading m_Owner and m_EntryCount while another thread is obtaining, obtains, or is releasing the critical section, it doesn&#39;t matter if the thread reads a stale, cached value or the most up-to-date value, and it also doesn&#39;t matter if the reads happen out-of-order &#8212; in any of those cases, the value it reads for m_Owner will either be 0 or another thread&#39;s ID, so it will never be the calling thread&#39;s ID.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1067173">
				<div id="div-comment-1067173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067173">
			July 12, 2013 at 8:02 am</a>		</div>

		<p>&gt;I just thought of another interesting potential edge case &#8212; if a thread exits while holding the critical section, and that thread&#39;s ID gets reused for another thread, wouldn&#39;t that other thread mistakenly think it owned the critical section?</p>
<p>That&#39;s not an edge case, that&#39;s a bug which should not occur in a valid program. You just don&#39;t exit while holding a CS.</p>
<p>@pete.d:</p>
<p>EnterCS and LeaveCS provide a memory barrier. Because of that, those variables don&#39;t have to be volatile.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067193">
				<div id="div-comment-1067193" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Buchan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067193">
			July 12, 2013 at 8:10 am</a>		</div>

		<p>@pete.d: Enter/LeaveCriticalSection(), like all synchronization APIs has to be defined as a (potentially one directional) memory barrier in order to work, so the compiler is not permitted to move either reads or writes above enter or below exit, even without volatile, and it must emit sufficient instructions to ensure the CPU doesn&#39;t either. (Which can get expensive on ARM7, I hear)</p>
<p>You&#39;re probably thinking of volatile&#39;s semi-abuse in lock-free algorithms: volatile says the compiler can&#39;t do anything to accesses to this variable: coalesce writes, hoist reads out of guards and other common codegen optimizations, essentially that they are IO. It doesn&#39;t prevent the CPU from doing so, since the CPU knows if that address was mapped to a DMA range or whatever. It just happens that x86 doesn&#39;t, (at least in most cases?), so a lot of technically unsafe uses of volatile work. std::atomic&lt;&gt; was introduced in C++11 as the right thing to use instead of volatile: it requires that the correct interlocked instructions are emitted. Win32 provided the Interlocked*() APIs to gain portable (to windows supported hardware platforms) access to those instructions beforehand.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067203">
				<div id="div-comment-1067203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">wqw</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067203">
			July 12, 2013 at 8:29 am</a>		</div>

		<p>m_Owner and m_EntryCount are declared in debug build only, but the constructor references them in release too. Or am I missing somthing?</p>
<div class="post">[<em>You&#39;re not missing anything. It&#39;s just a bug. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067223">
				<div id="div-comment-1067223" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.msdn.com/arcangelpip_4000_hotmail.com/ProfileUrlRedirect.ashx' rel='external nofollow' class='url'>arcangelpip@hotmail.com</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067223">
			July 12, 2013 at 10:01 am</a>		</div>

		<p>@Adam Rosenfield:</p>
<p>I would assume that GetCurrentThreadId function would get the value from the TEB structure. If that gets into a status where it could fail, then it would be better if the thread was dead.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067233">
				<div id="div-comment-1067233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067233">
			July 12, 2013 at 10:01 am</a>		</div>

		<p>@Adam Rosenfield, alegrl1:</p>
<p>Wouldn&#39;t EnterCriticalSection hang forever or return ABANDONED_MUTEX error in that case?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067243">
				<div id="div-comment-1067243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adam Rosenfield</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067243">
			July 12, 2013 at 10:25 am</a>		</div>

		<p>@alegr1: Yes, any thread that exits while holding a critical section is clearly a very bad bug, so it&#39;s not worth trying to fix this code to handle that case correctly. &nbsp;But I just thought that it&#39;s worth noting that thread ID reuse is something to think about.</p>
<p>@Joshua: The behavior is undefined, according to the documentation on EnterCriticalSection(). &nbsp;So actually, it&#39;s not even (theoretically) possible to handle that case correctly, since the behavior becomes undefined as soon as the thread exits while holding the critical section, not the next time some other tries to enter the critical section.</p>
<p>You&#39;re probably thinking of the WAIT_ABANDONED status which can be returned by the Wait* family of functions when given a mutex. &nbsp;Since mutexes act across processes, other processes may need to conceivably handle the WAIT_ABANDONED status (such as by closing shared memory objects), so the behavior needs to remain defined when a process exits while holding a mutex. &nbsp;But critical sections are local to processes and cannot be shared across processes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067283">
				<div id="div-comment-1067283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mordachai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067283">
			July 12, 2013 at 12:21 pm</a>		</div>

		<p>Awesome little idea, and great discussion spawned. &nbsp;Thanks :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067293">
				<div id="div-comment-1067293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067293">
			July 12, 2013 at 4:49 pm</a>		</div>

		<p>&quot;Enter/LeaveCriticalSection(), like all synchronization APIs has to be defined as a (potentially one directional) memory barrier in order to work&quot;</p>
<p>But that only affects the thread writing to the value, doesnt&#39; it? The thread reading, without any synchronization, doesn&#39;t necessarily benefit from that. Without its own memory barrier (which at least in some languages is provided by using &quot;volatile&quot;&#8230;I don&#39;t recall off the top of my head what C++&#39;s memory model is, and I realize it might not be as formalized as e.g. .NET languages&#39; models), the CPU may still reorder the read to occur too early to see a write from another thread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067303">
				<div id="div-comment-1067303" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067303">
			July 12, 2013 at 5:12 pm</a>		</div>

		<p>@alegrl1: In NT4, CriticalSection is implemented in terms of a mutex (with the optimization that it only exists when somebody is actually waiting for it). They got fancy in newer versions of Windows but it boils down to basically the same thing.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067253">
				<div id="div-comment-1067253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Vine [MSFT]</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067253">
			July 12, 2013 at 10:32 am</a>		</div>

		<p>I do not agree with some of the points in this post. However much you argue about what possible values entry-count and owner have this is *clearly* and *unequivocally* undefined behaviour according to the C++ standard &#8211; there&#39;s a clear data race here as defined in the latest [C++11 standard]. And once you have undefined behaviour then your whole program is undefined. If you make the 2 extra values std::atomic you lose a *tiny* bit off efficiency with the benefit of a well defined program.</p>
<p>Whether or not the MS compiler guarantees this to work, all of us as C++ professional programmers should hold ourselves to higher standards than this.</p>
<p>Oh, and those talking about using volatile for thread safety, if you&#39;ve got access to a C++11 compiler please use std::atomic &#8211; volatile isn&#39;t really useful for thread safety, even with the MS specific extensions (which I&#39;m hoping will eventually be deprecated, they&#39;re already are off by default on VS for Arm) there are still situations where volatile just doesn&#39;t do enough. See <a rel="nofollow" target="_new" href="http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484" rel="nofollow">http://www.drdobbs.com/&#8230;/212701484</a> for lots of juicy info on why you should migrate from using volatile in C++!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067313">
				<div id="div-comment-1067313" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">pete.d</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067313">
			July 12, 2013 at 5:54 pm</a>		</div>

		<p>Re: lack of volatile</p>
<p>I read a couple more replies, and think I understand now. That is, it doesn&#39;t matter that the read value might be wrong, because the wrong value is still not going to be the current thread&#39;s values (i.e. the function will still return false, as needed).</p>
<p>The only exception I see to this is the (probably rare) case where the thread ID is reused. That would be the scenario where the values could theoretically match, but be from an old, dead thread if volatile semantics aren&#39;t observed. But it&#39;s my understanding that there is at least one implicit memory barrier imposed when a thread starts up, obviating the need for explicitly imposing volatile.</p>
<p>In other words, all good. :)</p>
<p>Still, I have to agree with all the other commenters: this sounds like the kind of thing to let the author of some high-performance concurrency library worry about. It&#39;s a great topic for the blog, but it&#39;s not the kind of thing that ought to show up in most people&#39;s production code. :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-rat odd alt thread-odd thread-alt depth-1" id="comment-1067273">
				<div id="div-comment-1067273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/hacksoncode' rel='external nofollow' class='url'>hacksoncode</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067273">
			July 12, 2013 at 11:26 am</a>		</div>

		<p>@Mike Vine: It&#39;s clear from the context that this program is *not* using C++11, because if it were, it would also be using C++11 threads and, consequently, synchronization primitives (i.e. *not* critical sections). I&#39;m not even sure there *is* a spec for what happens in this case in a C++11 program if you&#39;re not using C++11 threads, because the abstract execution model for multiprocessing isn&#39;t defined unless you are. </p>
<p>So, yes, a programmer &quot;should&quot; refactor the entire program to use C++11 threads, and making use of atomic variables in this case would probably be the only way anyone would think of doing it. </p>
<p>If you&#39;re using OS-level threads, however, this kind of meta-analysis about the effects is perfectly valid, because you&#39;re already constrained to that OS&#39;s thread, execution, and memory model. And on Windows, with the processors it runs on, the function in question has perfectly well-defined high-level behavior, because the only possible ambiguities don&#39;t matter. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067333">
				<div id="div-comment-1067333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067333">
			July 12, 2013 at 10:36 pm</a>		</div>

		<p>This looks ok to me without volatile or atomic as long as you&#39;re on a single processor but I&#39;m not convinced it&#39;s good with multiprocessors. &nbsp;The sequence might be:</p>
<p>Thread 1 on processor A has the lock</p>
<p>Thread 1 calls IsHeldByCurrentThread and gets back true</p>
<p>Thread 1 migrates to processor B and releases the lock</p>
<p>Thread 2 on processor B acquires the lock</p>
<p>Thread 1 migrates back to processor A and calls IsHeldByCurrentThread again</p>
<p>Without an acquire/release on m_Owner and m_EntryCount I&#39;m not sure that processor A is guaranteed to know that anything&#39;s changed and might still return true. &nbsp;Enter/LeaveCriticalSection doesn&#39;t give that to you because they&#39;re operating on a completely different structure.</p>
<div class="post">[<em>In other words, what if processor A has not yet observed the write to m_Owner that occurred as part of the Leave? Imagine if this were possible, that a thread can migrate to a processor which has not observed memory changes made by the thread prior to the migration. Then this code could assert: <code>void foo() { int x = 1; assert(x==1); }</code> I think you&#39;d agree that pretty much every line of code would be broken if this were true. It would require all memory accesses to be performed with explicit barriers. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067343">
				<div id="div-comment-1067343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Killer{R}</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067343">
			July 13, 2013 at 3:19 am</a>		</div>

		<p>/*Note that this analysis assumes that the m_Owner is a suitably-aligned value that can be updated atomically. (If not, then it&#39;s possible that a torn value will be read which coincidentally matches our thread ID.)*/</p>
<p>Anyway, if its not true, or if we&#39;re on some exotic hardware, so in race state it can return some garbage instead of old/previous values &#8211; this can be simple fixed by TryEnterCriticalSection(). By the cost of some overhead of course.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1067383">
				<div id="div-comment-1067383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067383">
			July 13, 2013 at 2:05 pm</a>		</div>

		<p>@Joshua:</p>
<p>&gt;In NT4, CriticalSection is implemented in terms of a mutex </p>
<p>Any implementation of Critical_section that&#39;s trying to avoid unnecessary kernel roundtrip cannot use a kernel mutex. A auto-reset event is required. That&#39;s because you need to be able to signal the event without havind to acuire it beforehand, and not have to release it after having waited for it.</p>
<p>If you want to use a kernel mutex, you cannot apply any user-mode optimization.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067403">
				<div id="div-comment-1067403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Clovis</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067403">
			July 14, 2013 at 11:08 pm</a>		</div>

		<p>The ctor needs an #ifdef DEBUG around the member initialisation too. </p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067453">
				<div id="div-comment-1067453" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067453">
			July 15, 2013 at 12:00 pm</a>		</div>

		<p>&quot;Since the CRITICAL_SECTION itself must already be suitably aligned, placing the DWORD up against it will also align the DWORD.&quot;</p>
<p>Not true. Alignment/Padding of fields is up to the compiler. (I can&#39;t for the life of me think why a compiler might deliberately MIS-align a field, but that doesn&#39;t mean it can&#39;t happen).</p>
<div class="post">[<em>A compiler which intentionally misaligned types would not be Win32-compatible, and consequently this entire article does not apply. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067463">
				<div id="div-comment-1067463" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067463">
			July 15, 2013 at 12:08 pm</a>		</div>

		<p>// setup:</p>
<p>CriticalSectionWithOwner cs;</p>
<p>for(ULONG i = 0; i &lt; (ULONG)UINT_MAX); i++)</p>
<p> &nbsp;cs.Enter();</p>
<p>// ZOMG an Integer Overflow :(</p>
<p>cs.Enter();</p>
<p>ASSERT(cs.IsHeldByCurrentThread());</p>
<p>// cleanup</p>
<p>cs.Leave();</p>
<p>for(ULONG i = 0; i &lt; ((ULONG)UINT_MAX) + 1; i++)</p>
<p> &nbsp;cs.Leave();</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067473">
				<div id="div-comment-1067473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Matt</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067473">
			July 15, 2013 at 12:13 pm</a>		</div>

		<p>@alegr1, @Joshua:</p>
<p>A CRITICAL_SECTION is a spin-lock and a lazily initialized kernel MUTANT object. EnterCriticalSection waits a certain number of spins on the spin lock before giving up and creating and waiting on the kernel mutex. This means that if your CRITICAL_SECTION is rarely contested (or protects a very fast section of code), then a CRITICAL_SECTION is basically a spin lock with no syscalls or kernel resources. But if the protected code is slow and occasionally contested, the threads waiting on it will call the kernel to wait on the mutex which will deschedule the thread, avoiding wasting the CPU spinning on a thread that is going to have to wait for a long time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1067513">
				<div id="div-comment-1067513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067513">
			July 15, 2013 at 5:15 pm</a>		</div>

		<p>@Matt:</p>
<p>Using a kernel mutant in a CS would require that EnterCriticalSection requires a *mandatory* trip to the kernel even if there is no contention. Because if a contender appears later, and had to wait for the mutex, the mutex would not be owned otherwise. LeaveCriticalSection will also require a kernel call.</p>
<p>So if you want to use a mutex, you might as well just use a mutex, not bothering with any CS, because you&#39;ll just have to acquire and release it every time.</p>
<p>Whereas using an auto-reset event for CS makes everything a piece of cake. With an event, you can use the usermode optimization, because you only need to signal the event if there are contenders, and you only need to wait on the event if there is contention. And you can signal the event (release the wait) without ever having to wait on it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-1067553">
				<div id="div-comment-1067553" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">smf</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067553">
			July 16, 2013 at 3:42 am</a>		</div>

		<p>Can&#39;t you use the OwningThread member in the CRITICAL_SECTION structure?</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/magazine/cc164040.aspx">msdn.microsoft.com/&#8230;/cc164040.aspx</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067653">
				<div id="div-comment-1067653" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067653">
			July 16, 2013 at 10:51 am</a>		</div>

		<p>@alegrl: When I took computing theory, mutexes didn&#39;t check if you were stupid enough to lock on one thread then unlock on another.</p>
<p>@smf: If you do that, there&#39;s a random chance your code breaks on any service pack.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1067683">
				<div id="div-comment-1067683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067683">
			July 16, 2013 at 1:44 pm</a>		</div>

		<p>@Joshua:</p>
<p>&gt;When I took computing theory, mutexes didn&#39;t check if you were stupid enough to lock on one thread then unlock on another.</p>
<p>In theory, the practice is same as theory, and Windows mutexes don&#39;t check if you release them from another thread.</p>
<p>In practice, they&#39;re not the same, and the mutexes do check that. The very first remark in ReleaseMutex doc says so.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev odd alt thread-odd thread-alt depth-1" id="comment-1067703">
				<div id="div-comment-1067703" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067703">
			July 16, 2013 at 1:48 pm</a>		</div>

		<p>@Joshua:</p>
<p>Also, a lazy CreateMutex when a thread needs to wait for the first time for a contended CS cannot create it in the state owned by a different thread, which would be necessary for actual WaitForSingleObject to suspend the thread.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1067713">
				<div id="div-comment-1067713" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067713">
			July 16, 2013 at 1:51 pm</a>		</div>

		<p>&gt;When I took computing theory, mutexes didn&#39;t check if you were stupid enough to lock on one thread then unlock on another.</p>
<p>Of course you can have a non-reentrant mutex that you can also release from any thread. In Windows it is called an auto-reset event.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-1067813">
				<div id="div-comment-1067813" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067813">
			July 17, 2013 at 7:18 am</a>		</div>

		<p>alegr1: I&#39;m pretty sure that a non-reentrant mutex that you can also release from any thread was originally called a &quot;semaphore&quot;.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-alegrigoriev even thread-even depth-1" id="comment-1067933">
				<div id="div-comment-1067933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/alegr1' rel='external nofollow' class='url'>alegr1</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1067933">
			July 17, 2013 at 10:50 am</a>		</div>

		<p>@Gabe:</p>
<p>&gt;I&#39;m pretty sure that a non-reentrant mutex that you can also release from any thread was originally called a &quot;semaphore&quot;.</p>
<p>The CS would require a semaphore with max count of 1 (to only allow releasing one waiter), which is equivalent to an auto-reset event.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-martin-baschnegger odd alt thread-odd thread-alt depth-1" id="comment-1068263">
				<div id="div-comment-1068263" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Martin+Ba.+_' rel='external nofollow' class='url'>Martin Ba. _</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20130712-00/?p=3823#comment-1068263">
			July 19, 2013 at 12:18 am</a>		</div>

		<p>Why not just assert on the members of the CRITICAL_SECTION structure itself? (LockCount, OwningThread, &#8230;) Seriously.</p>
<div class="post">[<em>Please tell me you&#39;re joking. -Raymond</em>]</div>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

