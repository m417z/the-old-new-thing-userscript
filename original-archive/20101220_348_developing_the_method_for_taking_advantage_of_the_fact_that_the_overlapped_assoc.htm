<html>
<head>
<title>Developing the method for taking advantage of the fact that the OVERLAPPED associated with asynchronous I/O is passed by address</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Developing the method for taking advantage of the fact that the OVERLAPPED associated with asynchronous I/O is passed by address</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>December 20, 2010 / year-entry #349</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>26</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">You can take advantage of the fact that the OVERLAPPED associated with asynchronous I/O is passed by address, but there was some confusion about how this technique could "work" when kernel mode has no idea that you are playing this trick. Whether kernel mode is in on the trick is immaterial since it is not...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
<a HREF="http://blogs.msdn.com/b/oldnewthing/archive/2010/12/17/10106259.aspx">
You can take advantage of the fact that the
<code>OVERLAPPED</code> associated with asynchronous I/O is
passed by address</a>,
but there was some confusion about how this technique could
"work" when kernel mode has no idea that you are playing this trick.
</p>
<p>
Whether kernel mode is in on the trick is immaterial since it is not
part of the trick.
</p>
<p>
Let's start with a version of the code which does not take advantage
of the <code>OVERLAPPED</code> structure address in the way
described in the article.
This is a technique I found in a book on advanced Windows programming:
</p>
<pre>
#define MAX_OVERLAPPED 10 // let's do 10 I/O's at a time

// data to associate with each OVERLAPPED
struct OTHERDATA { ... };

OVERLAPPED MasterOverlapped[MAX_OVERLAPPED];
OTHERDATA OtherData[MAX_OVERLAPPED];

OTHERDATA* FindOtherDataFromOverlapped(OVERLAPPED *lpOverlapped)
{
 ptrdiff_t index = lpOverlapped - MasterOverlapped;
 return &amp;OtherData[index];
}

// I/O is issued via
// ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead,
//            &amp;MasterOverlapped[i], CompletionRoutine);

void CALLBACK CompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED lpOverlapped)
{
 OTHERDATA *lpOtherData =
                       FindOtherDataFromOverlapped(lpOverlapped);
 ... do stuff with lpOverlapped and lpOtherData ...
}
</pre>
<p>
This version of the code uses the address of the
<code>OVERLAPPED</code> structure to determine the
location in the <code>MasterOverlapped</code> table
and uses the corresponding entry in the parallel array
at <code>OtherData</code> to hold the other data.
</p>
<p>
Let's make this code worse before we make it better:
</p>
<pre>
OTHERDATA* FindOtherDataFromOverlapped(OVERLAPPED *lpOverlapped)
{
 for (int index = 0; index &lt; MAX_OVERLAPPED; index++) {
  if (&amp;MasterOverlapped[index] == lpOverlapped) {
   return &amp;OtherData[index];
  }
 }
 FatalError(); // should never be reached
}
</pre>
<p>
Instead of doing simple pointer arithmetic to recover
the index, we walk the array testing the pointers.
This is naturally worse than doing pointer arithmetic, but
watch what this step allows us to do:
First, we reorganize the data so that instead of two
parallel arrays, we have a single array of a compound
structure.
</p>
<pre>
struct OVERLAPPEDEX
{
 OVERLAPPED Overlapped;
 OTHERDATA OtherData;
};

OVERLAPPEDEX Master[MAX_OVERLAPPED];

OTHERDATA* FindOtherDataFromOverlapped(OVERLAPPED *lpOverlapped)
{
 for (int index = 0; index &lt; MAX_OVERLAPPED; index++) {
  if (&amp;Master[index].Overlapped == lpOverlapped) {
   return &amp;Master[index].OtherData;
  }
 }
 FatalError(); // should never be reached
}

// I/O is issued via
// ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead,
//            &amp;Master[i].Overlapped, CompletionRoutine);
</pre>
<p>
All we did was consolidate the parallel arrays into a single array.
</p>
<p>
Now that it's an array of compound structures, we don't need
to carry two pointers around (one to the <code>OVERLAPPED</code>
and one to the <code>OTHERDATA</code>).
We can just use a single <code>OVERLAPPEDEX</code> pointer
and dereference either the <code>Overlapped</code>
or the <code>OtherData</code> part.
</p>
<pre>
OVERLAPPEDEX* FindOverlappedExFromOverlapped(
    OVERLAPPED *lpOverlapped)
{
 for (int index = 0; index &lt; MAX_OVERLAPPED; index++) {
  if (&amp;Master[index].Overlapped == lpOverlapped) {
   return &amp;Master[index];
  }
 }
 FatalError(); // should never be reached
}

void CALLBACK CompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED lpOverlapped)
{
    OVELRAPPEDEX *lpOverlappedEx =
                    FindOverlappedExFromOverlapped(lpOverlapped);
    ... do stuff with lpOverlappedEx ...
}
</pre>
<p>
Finally, we can optimize the
<code>FindOverlappedExFromOverlapped</code> function
that we de-optimized earlier.
Observe that the de-optimized loop is an example of the
"for/if" anti-pattern.
</p>
<p>
The "for/if" anti-pattern goes like this:
</p>
<pre>
for (int i = 0; i &lt; 100; i++) {
 if (i == 42) do_something(i);
}
</pre>
<p>
This can naturally be simplified to
</p>
<pre>
do_something(42);
</pre>
<p>
Our
<code>FindOverlappedExFromOverlapped</code> function
is a special case of this anti-pattern.
It becomes more evident if we do some rewriting.
Start with
</p>
<pre>
&amp;Master[index].Overlapped == lpOverlapped
</pre>
<p>
Apply <code>CONTAINING_RECORD</code> to both sides.
</p>
<pre>
CONTAINING_RECORD(&amp;Master[index].Overlapped, OVERLAPPEDEX, Overlapped) ==
    CONTAINING_RECORD(lpOverlapped, OVERLAPPEDEX, Overlapped)
</pre>
<p>
The left-hand side of the comparison simplifies to
</p>
<pre>
    &amp;Master[index]
</pre>
<p>
resulting in
</p>
<pre>
&amp;Master[index] ==
   CONTAINING_RECORD(lpOverlapped, OVERLAPPEDEX, Overlapped)
</pre>
<p>
Recall that <code>a[b]</code> is equivalent to <code>*(a+b)</code>,
and therefore <code>&amp;a[b]</code> is equivalent to <code>a+b</code>.
</p>
<pre>
Master + index ==
   CONTAINING_RECORD(lpOverlapped, OVERLAPPEDEX, Overlapped)
</pre>
<p>Now subtract <code>Master</code> from both sides:</p>
<pre>
index == CONTAINING_RECORD(lpOverlapped, OVERLAPPEDEX, Overlapped) - Master
</pre>
<p>
We have transformed the test into a clear case of the
for/if anti-pattern,
and the function can be simplified to
</p>
<pre>
OVERLAPPEDEX* FindOverlappedExFromOverlapped(
    OVERLAPPED *lpOverlapped)
{
 ptrdiff_t index =
   CONTAINING_RECORD(lpOverlapped, OVERLAPPEDEX, Overlapped) - Master;
 return &amp;Master[index];
}
</pre>
<p>
Again, rewrite <code>&amp;a[b]</code> as <code>a+b</code>:
</p>
<pre>
 return Master + index;
</pre>
<p>
Substitute the value of <code>index</code> computed on the previous
line:
</p>
<pre>
 return Master + 
   CONTAINING_RECORD(lpOverlapped, OVERLAPPEDEX, Overlapped) - Master;
</pre>
<p>
The two occurrences of <code>Master</code> cancel out, leaving
</p>
<pre>
OVERLAPPEDEX* FindOverlappedExFromOverlapped(
    OVERLAPPED *lpOverlapped)
{
 return CONTAINING_RECORD(lpOverlapped, OVERLAPPEDEX, Overlapped);
}
</pre>
<p>
And there you have it.
By a series of purely mechanical transformations,
we have rediscovered the technique of
extending the <code>OVERLAPPED</code> structure.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (26)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-883243">
				<div id="div-comment-883243" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Cory Nelson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883243">
			December 20, 2010 at 8:08 am</a>		</div>

		<p>&quot;The Old New Thing&quot; indeed! hehe</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883253">
				<div id="div-comment-883253" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Krunch</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883253">
			December 20, 2010 at 8:20 am</a>		</div>

		<p>This is also how linked list work in the Linux kernel. You embed the list struct in the struct you want to list and given a list pointer, you use container_of() to reach your data.</p>
<p><a rel="nofollow" target="_new" href="http://kernelnewbies.org/FAQ/LinkedLists" rel="nofollow">kernelnewbies.org/&#8230;/LinkedLists</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883273">
				<div id="div-comment-883273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pavlik</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883273">
			December 20, 2010 at 9:28 am</a>		</div>

		<p>Extenting OVERLAPPED structure is so common pattern but yet people have to rediscover it over and over and over again. I wonder what could be done to make it more discoverable.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883283">
				<div id="div-comment-883283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tyler</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883283">
			December 20, 2010 at 9:39 am</a>		</div>

		<p>@Pavlik well, the most common way to make this sort of thing more discoverable is to have Raymond Chen write about it on his blog.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883293">
				<div id="div-comment-883293" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">peterchen</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883293">
			December 20, 2010 at 10:40 am</a>		</div>

		<p>@Pavlik: By adding it as community content to the &quot;OVERLAPPED&quot; structure docunmentaiton in MSDN?</p>
<p>(<a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms684342(VS.85).aspx" rel="nofollow">msdn.microsoft.com/&#8230;/ms684342(VS.85).aspx</a>)</p>
<p>(How can I clickify a link over there?)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883323">
				<div id="div-comment-883323" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zonk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883323">
			December 20, 2010 at 11:53 am</a>		</div>

		<p>That&#39;s crazy.</p>
<p>I&#39;m passing some pointer to some function. It should read all data it needs and save it to it&#39;s internal storage. Then the function is calling me back and passing another pointer. I&#39;m reading all I need to, and return call. This pointer and that pointer must have nothing common, and if they do &#8211; that is unreliable feature. Isn</p>
<p>t it programming ground rules?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883333">
				<div id="div-comment-883333" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Joshua</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883333">
			December 20, 2010 at 11:56 am</a>		</div>

		<p>@zonk: It&#39;s a common pattern.</p>
<p>svn team calls it baton. .NET calls it Tag. Windows calls it LPARAM (see EnumWindows).</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883343">
				<div id="div-comment-883343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">zonk</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883343">
			December 20, 2010 at 12:08 pm</a>		</div>

		<p>@Joshua:</p>
<p>Tag is Object. LPARAM is almost void*. They are special fields of structure, not the structure itself.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883353">
				<div id="div-comment-883353" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Simon Buchan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883353">
			December 20, 2010 at 12:22 pm</a>		</div>

		<p>@Joshua: Reserving a user data pointer is fairly different to embedding from a lifetime management POV, remember.</p>
<p>@zonk: Why on earth would you expect a pointer argument to be copied? This is when ownership rules are useful, instead of a pain in the ass &#8211; if you own a pointer and have to reclaim it yourself, then obviously the other party is required to not mess with it, it has to give the same pointer back so you know what to free, at the minimum.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883363">
				<div id="div-comment-883363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Gabe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883363">
			December 20, 2010 at 12:41 pm</a>		</div>

		<p>zonk: The OVERLAPPED struct isn&#39;t immutable. When you pass it to an I/O function, you are expecting that the memory pointed to will be modified. Thus, you should darn well better expect that the LPOVERLAPPED you get back is exactly the one you passed in.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883373">
				<div id="div-comment-883373" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">L</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883373">
			December 20, 2010 at 3:26 pm</a>		</div>

		<p>@zonk: Please read the descriptions of the API functions first:</p>
<p>GetQueuedCompletionStatus: &quot;A pointer to a variable that receives the address of the OVERLAPPED structure that was specified when the completed I/O operation was started. &quot;</p>
<p>GetOverlappedResult: &quot;A pointer to an OVERLAPPED structure that was specified when the overlapped operation was started.&quot;</p>
<p>ReadFile: &quot;Because the read operation starts at the offset that is specified in the OVERLAPPED structure, and ReadFile may return before the system-level read operation is complete (read pending), neither the offset nor any other part of the structure should be modified, freed, or reused by the application until the event is signaled (that is, the read completes)&quot;</p>
<p>You have to provide this OVERLAPPED structure. It must stay until the operation completes. But you can even access the hEvent handle inside this structure, as documented, so it is not opaque for the application.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883213">
				<div id="div-comment-883213" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Anton Tykhyy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883213">
			December 20, 2010 at 7:38 am</a>		</div>

		<p>The .NET framework uses this trick when it does asynchronous I/O. Moreover, it uses a completion port to have the kernel invoke callbacks on its thread pool. This is all well and good, but once a handle gets associated with this completion port *any* overlapped operations invoke the CLR&#39;s callback. What&#39;s more, the CLR&#39;s callback does not check whether it was called with CLR&#39;s OVERLAPPEDEX and crashes when it gets called as a result of a non-CLR-initiated overlapped operation. There is no way that I know of to *dis*associate a handle from a completion port, so it is impossible to use a single handle (DuplicateHandle does not help, presumably because the completion port is bound at the kernel level) with .NET&#39;s asynchronous I/O functions and with homebrew or third-party libraries which do their own overlapped I/O at the same time.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-883383">
				<div id="div-comment-883383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883383">
			December 20, 2010 at 3:41 pm</a>		</div>

		<p>I&#39;m willing to believe that the thread calling WriteFile will be able to access the extended OVERLAPPEDEX members.</p>
<p>It&#39;s a far cry from that to the assertion that the thread on which the completion function is invoked will be able to do the same.</p>
<p>I&#39;ve been told that &quot;the documentation says you can&quot; but I don&#39;t see such a statement in the documentation. &nbsp;Can anyone put a finger on a sentence or paragraph? &nbsp;I do see samples that rely on this behavior.</p>
<p>I don&#39;t find this post any more convincing. &nbsp;Sure, you can derive that assertion from the book, but this is circular logic: what assurance is there that the book is correct?</p>
<p>So I&#39;m with zonk on this one.</p>
<div class="post">[<i>You&#39;re making this much harder than it is. If you allocate N bytes of memory at address p, then you pass p to somebody, and that somebody later passes p back to you, then you can access N bytes of memory there. Is this not obvious? -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883393">
				<div id="div-comment-883393" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">L</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883393">
			December 20, 2010 at 3:41 pm</a>		</div>

		<p>There is even the PostQueuedCompletionStatus function (<a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/aa365458%28v=vs.85%29.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa365458%28v=vs.85%29.aspx</a>). The description of its last 3 parameters (the first one specifies the Completion Port) is:</p>
<p>dwNumberOfBytesTransferred [in]: The value to be returned through the lpNumberOfBytesTransferred parameter of the GetQueuedCompletionStatus function.</p>
<p>dwCompletionKey [in]: The value to be returned through the lpCompletionKey parameter of the GetQueuedCompletionStatus function.</p>
<p>lpOverlapped [in, optional]: The value to be returned through the lpOverlapped parameter of the GetQueuedCompletionStatus function.</p>
<p>This makes it very clear that the completion port mechanism does only return things that are given in before, unchanged.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-883403">
				<div id="div-comment-883403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883403">
			December 20, 2010 at 3:49 pm</a>		</div>

		<p>Ah, there we go &#8211; thanks, L.</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/aa365458%28v=vs.85%29.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/aa365458%28v=vs.85%29.aspx</a></p>
<p>Remarks The I/O completion packet will satisfy an outstanding call to the GetQueuedCompletionStatus function. This function returns with the three values passed as the second, third, and fourth parameters of the call to PostQueuedCompletionStatus. The system does not use or validate these values. ***In particular, the lpOverlapped parameter need not point to an OVERLAPPED structure.***</p>
<p>(my emphasis)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883473">
				<div id="div-comment-883473" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Sunil Joshi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883473">
			December 21, 2010 at 5:12 am</a>		</div>

		<p>@Maurits</p>
<p>Perhaps thinking about it another way may help. If for example I allocate an OVERLAPPED structure on the heap or on the stack, it will be followed in memory by other stuff (e.g. the header of the next heap block or some local var). If I pass a POVERLAPPED to a function, I am entitled to expect it won&#39;t corrupt the other stuff (if it did that would be a nasty bug). If the other stuff happens to be tracking data for my asynchronous io that doesn&#39;t make a difference (the function is still not entitled to write to more than sizeof(OVERLAPPED) bytes.) We do this sort of thing all the time. We pass structures to functions and expect them not to touch surrounding data. So the extra data will still be there when we need it.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883483">
				<div id="div-comment-883483" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883483">
			December 21, 2010 at 5:30 am</a>		</div>

		<p>I&#39;m with you, Raymond: there is a lot of over-thinking the problem. &nbsp;I hate to sound like and old codger, but I suspect people have trouble with this because most people don&#39;t do assembly language any more. &nbsp;Perhaps a more language-centric way of describing the solution might be to use unions, i.e.</p>
<p>union OVERLAPPEDEX {</p>
<p>&nbsp; &nbsp;OVERLAPPED ovl;</p>
<p>&nbsp; &nbsp;struct {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;BYTE reserved[sizeof(OVERLAPPED)];</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;OTHERDATA otherdata;</p>
<p>&nbsp; &nbsp;};</p>
<p>};</p>
<p>This is functionally equivalent to your OVERLAPPEDEX structure, but shows in a slightly different way that the pointer to the OVERLAPPEDEX can be cast to an OVERLAPPED without any difficulty. &nbsp;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883493">
				<div id="div-comment-883493" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Random832</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883493">
			December 21, 2010 at 5:40 am</a>		</div>

		<p>The confusion I saw wasn&#39;t due to whether the structs have compatible layout or whatever, it was due to it not being clear to people that it _is_ passed by address, they were asking if some kernel-mode component might cause a copy of it to be made and have _that_ address passed to the completion function, since it doesn&#39;t seem to be explicitly part of the contract. Such behavior would break every single example presented here.</p>
<div class="post">[<i>That the address passed to the completion function is identical to the address passed to the I/O function is explicitly <a href="http://msdn.microsoft.com/en-us/library/aa364052(v=VS.85).aspx" rel="nofollow">part of the contract</a>. (How else would you know which I/O completed?) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883503">
				<div id="div-comment-883503" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Tom</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883503">
			December 21, 2010 at 6:01 am</a>		</div>

		<p>@Random832: While you&#39;re right about the source of confusion, I still think people are over-thinking the problem.</p>
<p>The documentation for the asynchronous I/O functions states that the OVERLAPPED structure must exist until the I/O operation completes, and recommends that the OVERLAPPED be in a global variable or allocated on the heap because a stack-allocated OVERLAPPED will likely disappear before the I/O finishes. &nbsp;Because of this restriction, one can assume that the OVERLAPPED passed to the asynchronous I/O function is the same one passed to the completion function even if that is not explicitly stated in the documentation. &nbsp;After all, why would the kernel need to make a copy of the OVERLAPPED structure if the kernel already requires you to keep one hanging around until the I/O completes? &nbsp;If, on the other hand, this restriction were not in place (i.e. the OVERLAPPED could be freed as soon as the asynchronous ReadFile() call returned but before the I/O operation completed), then you should probably assume that the OVERLAPPED is copied.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883513">
				<div id="div-comment-883513" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Alex Grigoriev</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883513">
			December 21, 2010 at 8:10 am</a>		</div>

		<p>@Tom:</p>
<p>Your union OVERLAPPEDEX is an overkill which only adds confusion.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883533">
				<div id="div-comment-883533" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Pierre B.</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883533">
			December 21, 2010 at 9:07 am</a>		</div>

		<p>@Tom:</p>
<p>While in this case the documentation is very explicit so there is no question, it is not obivous that any structure passed to the kernel via a pointer will not get copied. Copying parameters to kernel function is a common trick to avoid subtle attack where the data is modified during the call to make the kernel overwrite protected memory. In fact, I suspect that the content of the overlapped structure really do get copied internally before being validate and used for the I/O.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883623">
				<div id="div-comment-883623" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">less confused now</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883623">
			December 21, 2010 at 1:00 pm</a>		</div>

		<p>Okay, I think what trips people is that somehow, they think when Windows invokes the callback function, the pointer to OVERLAPPED might not be the same one as the pointer from the original call.</p>
<p>It&#39;s explicitly not the case for the APIs here. &nbsp;But, I suppose such an API design is possible, and might even be desirable in that it doesn&#39;t require the caller to maintain the memory to the OVERLAPPED throughout the possible duration of the async I/O. &nbsp;Of course, if that were the design, it&#39;s likely that there would also have been some sort of generic caller-specified void* &quot;context&quot; pointer in the structure that will help the caller identify which OVERLAPPED it is, otherwise you end up with the undesirable situation where it&#39;s tricky/impossible for the caller to figure out in the callback which I/O operation it is for. &nbsp;That sort of &quot;context&quot; pointer could then be used for the caller&#39;s secret extra bytes.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-883613">
				<div id="div-comment-883613" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">confused about why people are confused</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883613">
			December 21, 2010 at 12:44 pm</a>		</div>

		<p>Whether or not the kernel makes copies of the structure is totally irrelevant. &nbsp;Internally the function is free to make billions of copies of the OVERLAPPED structure if it so likes, but at the end of the day, it still has to write back any relevant results back into the *original* structure being pointed to, the one from the caller. &nbsp;Similarly, the fact that there are extra bytes following the OVERLAPPED parameter has no bearing on the function; the caller is solely responsible for the lifetime management of the full blob of memory, and only the caller knows about the extra bytes; the function only ever access the bytes in the blob that are part of the OVERLAPPED structure.</p>
<p>The fact that the internal copies made by the function do not include the caller&#39;s &quot;secret extra bytes&quot; has no effect on anyone, since the function never knows or cares about the extra bytes to begin with, and the extra bytes from the caller&#39;s original structure are never being destroyed in the process since the caller maintains lifetime management on the original structure.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883893">
				<div id="div-comment-883893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">L</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883893">
			December 22, 2010 at 12:13 pm</a>		</div>

		<p>The real mysterious APIs are the ones with multi-page long descriptions, where it is nonetheless not clear at all what they are really doing under various circumstances and parameter combinations.</p>
<p>One of my favorites in this area is the CreateProcess() call. Very old and very basic. Why on earth does it need so many parameters? Why is the documentation still so unclear after so many years?</p>
<p>For example: What is the true meaning of many options for the dwCreationFlags parameter (Process Creation Flags)? What is the distinction between CREATE_NO_WINDOW and DETACHED_PROCESS? Why is Server 2008 R2 creating a conhost process for a new child process, when the parent process has no console window and the child is created with CREATE_NO_WINDOW (both are compiled as console programs)? I just don&#39;t understand.</p>
<p>Then add to this the inheritance of the stdin/stdout/stderr channels which is just cumbersome the way it must be done.</p>
<p>THAT one is a real mess.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-maurits even thread-even depth-1" id="comment-883843">
				<div id="div-comment-883843" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Maurits+%5BMSFT%5D' rel='external nofollow' class='url'>Maurits [MSFT]</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883843">
			December 22, 2010 at 10:52 am</a>		</div>

		<p>&gt; If you allocate N bytes of memory at address p, then you pass p to somebody, and that somebody later passes p back to you, then you can access N bytes of memory there. Is this not obvious?</p>
<p>Yes, it&#39;s obvious (even to such as stubborn ox as me) that static_cast&lt;OVERLAPPED_EX *&gt;(p)-&gt;foo gives me what I want.</p>
<p>It&#39;s also obvious (I hope) that static_cast&lt;OVERLAPPED_EX *&gt;(new OVERLAPPED(*p))-&gt;foo is a Very Bad Thing (TM).</p>
<p>What is not obvious to me (when relying solely on the signatures of the relevant functions) is, which case are we in?</p>
<p>Only a close reading of the documentation clears that ambiguity up. &nbsp;Even then this strikes me as a poor programming practice.</p>
<p>&gt; How else would you know which I/O completed?</p>
<p>By relying on something in the OVERLAPPED instance which you were reasonably confident was unique to that OVERLAPPED instances: to wit, the event handle.</p>
<p>In fact, my implementation of FindOtherDataFromOverlapped would probably go something like this:</p>
<p>OTHERDATA* FindOtherDataFromOverlapped(OVERLAPPED *lpOverlapped)</p>
<p>{</p>
<p>&nbsp; &nbsp;for (int i = 0; i &lt; MAX_OVERLAPPED; i++)</p>
<p>&nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;if (MasterOverlapped[i].hEvent == lpOverlapped-&gt;hEvent)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return &amp;OtherData[i];</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;// fatal error&#8230; blow up or something</p>
<p>&nbsp; &nbsp;return NULL;</p>
<p>}</p>
<div class="post">[<i>Let me get this straight. I spent two days trying to clarify something that was based on you &quot;relying solely on the signatures of the relevant functions&quot; and not the associated documentation? (BTW, most OVERLAPPED usages do not employ an event. Only if you need to check for completion outside the completion function/completion port do you need an event.) -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-883903">
				<div id="div-comment-883903" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">besides Raymond's point, but anyway</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20101220-01/?p=11963#comment-883903">
			December 22, 2010 at 12:47 pm</a>		</div>

		<p>Obviously we are not talking about casting any random OVERLAPPED* to OVERLAPPED_EX*. &nbsp;In this case you have control over this based on the completion routine you specified for that IO operation.</p>
<p>And while not a recommended practice, you can specify a NULL event handle in your OVERLAPPED structure, in the case where you know there won&#39;t be more than one I/O on the file/pipe/device. &nbsp;So using the event handle member as a unique identifier also depends on some particular knowledge of how the code is using the OVERLAPPED structure, not any different from knowing that your code will always pass in OVERLAPPED_EX for all I/Os associated with your particular completion routine.</p>
<p><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/en-us/library/ms686358%28VS.85%29.aspx" rel="nofollow">msdn.microsoft.com/&#8230;/ms686358%28VS.85%29.aspx</a></p>
<p>I suppose one can claim that the &quot;master table&quot; technique is less prone to AVs in the case where your code unwittingly violated the assumption of always getting OVERLAPPED_EX in your completion routine. &nbsp;(Assuming no bugs in the code that maintains the master table.)</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

