<html>
<head>
<title>Waiting until the dialog box is displayed before doing something</title>
<link rel="stylesheet" href="page.css">
</head><body>
<div class="titlediv"><h2>Waiting until the dialog box is displayed before doing something</h2></div>
<div class="hdrdiv"><table class="hdrtable" cellspacing="0" cellpadding="0">
<tr><td><b>Date:</b></td><td>September 25, 2006 / year-entry #326</td></tr>
<tr><td><b>Tags:</b></td><td>code</td></tr>
<tr><td><b>Orig Link:</b></td><td>https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603</td></tr>

<tr><td><b>Comments:&nbsp;&nbsp;&nbsp;&nbsp;</b></td><td>30</td></tr>
<tr><td valign="top"><b>Summary:</b></td><td valign="top">Last time, I left you with a few questions. Part of the answer to the first question was given in the comments, so I'll just link to that. The problem is more than just typeahead, though. The dialog box doesn't show itself until all message traffic has gone idle. If you actually ran the code...</td></tr>
</table></div>
<hr/>
<table class="contenttable" cellspacing="0" cellpadding="0"><tr><td><div class="contentdiv">
<!-- CONTENT START -->
<p>
Last time,
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2006/09/22/766168.aspx">
I left you with a few questions</a>.
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2006/09/22/766168.aspx#766941">
Part of the answer to the first question
was given in the comments</a>, so I'll just link to that.
The problem is more than just typeahead, though.
The dialog box doesn't show itself until all message traffic
has gone idle.
If you actually ran the code presented in the original message,
you'd find that it didn't actually work!
</p>
<pre>
#include &lt;windows.h&gt;

INT_PTR CALLBACK
DlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uiMsg) {

  case WM_INITDIALOG:
    PostMessage(hwnd, WM_APP, 0, 0);
    return TRUE;

  case WM_APP:
    MessageBox(hwnd,
              IsWindowVisible(hwnd) ? TEXT("Visible")
                                    : TEXT("Not Visible"),
               TEXT("Title"), MB_OK);
    break;

  case WM_CLOSE:
   EndDialog(hwnd, 0);
   break;
  }

  return FALSE;
}

int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev,
                   LPSTR lpCmdLine, int nShowCmd)
{
    DialogBox(hinst, MAKEINTRESOURCE(1), NULL, DlgProc);
    return 0;
}
</pre>
<p>
When you run this program, the  message box says "Not Visible",
and in fact when it appears, you can see that the main dialog
is not yet visible.
It doesn't show up until after you dismiss the message box.
</p>
<p>
Mission: Not accomplished.
</p>
<p>
Along the way, there was some dispute over whether the
private message should be <code>WM_USER</code> or
<code>WM_APP</code>.
As we saw before,
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2003/12/02/55914.aspx">
window messages in the <code>WM_USER</code> range belong to the
window class</a>,
and in this case, the window class is the dialog window class,
<i>i.e.</i>, <code>WC_DIALOG</code>.
Since you are not the implementor of the dialog window class
(you didn't write the window procedure),
the <code>WM_USER</code> messages are not yours for the taking.
And in fact, if you had decided to use <code>WM_USER</code>
you would have run into all sorts of problems,
because it so happens that the dialog manager
already defined that message for its own purposes:
</p>
<pre>
#define DM_GETDEFID         (WM_USER+0)
</pre>
<p>
When the dialog manager sends the dialog a <code>DM_GETDEFID</code>
message to obtain the default control ID,
you will think it's your <code>WM_USER</code> message and show your
dialog box.
It turns out that the dialog manager uses the default control ID
rather often, and as a result, you're going to display an awful
lot of dialog boxes.
(Even worse, your second dialog box will probably use the dialog
itself as the owner, which then leads to the problem of
having a dialog box with multiple modal children</a>,
<a HREF="http://blogs.msdn.com/oldnewthing/archive/2005/02/23/378866.aspx">
which then leads to disaster when they are dismissed by the
user in the wrong order</a>.)
</p>
<p>
Okay, so we're agreed that we should use <code>WM_APP</code>
as the private message.
</p>
<p>
Some people suggested using a timer,
on the theory that timer messages are lower priority than
paint messages,
so the timer won't fire until all painting is done.
While that's true, it also doesn't help.
The relative priority of timer and paint messages comes
into play only if the window manager has to choose between
timers and paint messages when deciding which one to deliver
first.
But if there are no paint messages needed in the first place,
then timers are free to go ahead.
</p>
<p>
And when the window is not visible,
it doesn't need any paint messages.
In a sense, the timer approach misses the point entirely:
It's trying to take advantage of paint messages being higher priority
precisely in the scenario where there are no paint messages!
</p>
<p>
Let's demonstrate this by implementing the timer approach,
but I'm going to add a twist to make the race condition clearer:
</p>
<pre>
...

INT_PTR CALLBACK
DlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uiMsg) {

  case WM_INITDIALOG:
    SetTimer(hwnd, 1, 1, 0);
    Sleep(100); //simulate paging
    return TRUE;

  case WM_TIMER:
    if (wParam == 1) {
      KillTimer(hwnd, 1);
      MessageBox(hwnd,
                IsWindowVisible(hwnd) ? TEXT("Visible")
                                      : TEXT("Not Visible"),
                 TEXT("Title"), MB_OK);
    }
    break;

  case WM_CLOSE:
   EndDialog(hwnd, 0);
   break;
  }

  return FALSE;
}
</pre>
<p>
If you run this program, you'll see the message "Not Visible".
I inserted an artificial <code>Sleep(100)</code> to simulate
the case where the code takes a page fault and has to wait
100ms for the code to arrive from the backing store.
(Maybe it's coming from the network or a CD-ROM,
or maybe the local hard drive is swamped with I/O and
you have to wait that long for your paging request to
become satisfied after all the other I/O requests active
on the drive.)
</p>
<p>
As a result of that <code>Sleep()</code>,
the dialog manager doesn't get a chance to empty the message
queue and show the window because the timer message is already
in the queue.
Result: The timer fires and the dialog is still hidden.
</p>
<p>
Some people waited for <code>WM_ACTIVATE</code>, but that
tells you when the window becomes active, which is not the
same as being shown, so it doesn't satisfy the original
requirements.
</p>
<p>
Others suggested waiting for <code>WM_PAINT</code>,
but a window can be visible without painting.
The <code>WM_PAINT</code> message arrives if the window's
client area is uncovered, but the caption bar might still be
visible even if the client area is covered.
Furthermore, while this addresses the problem if you interpret
"visible" as "results in pixels on the screen",
as opposed to <code>IsWindowVisible</code>,
you need to look behind the actual request to what the person
was really looking for.
(This is an important skill to have because people rarely ask
for what they want, but rather for what they think they want.)
The goal was to create a dialog box and have it look like the
user automatically clicked a button on it to call up a secondary dialog.
In order to get this look, the base dialog needs to be visible
before the secondary dialog can be displayed.
</p>
<p>
One approach is to show the second dialog on receipt of the
<code>WM_SHOWWINDOW</code>, but even that is too soon:
</p>
<pre>
// In real life, this would be an instance variable
BOOL g_fShown = FALSE;

INT_PTR CALLBACK
DlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uiMsg) {

  case WM_INITDIALOG:
    return TRUE;

  case WM_SHOWWINDOW:
    if (wParam &amp;&amp; !g_fShown) {
      g_fShown = TRUE;
      MessageBox(hwnd,
                 IsWindowVisible(hwnd) ? TEXT("Visible")
                                       : TEXT("Not Visible"),
                 TEXT("Title"), MB_OK);
    }
    break;

  case WM_CLOSE:
   EndDialog(hwnd, 0);
   break;
  }

  return FALSE;
}
</pre>
<p>
(Subtlety: Why do I set <code>g_fShown = TRUE</code> before
displaying the message box?)
</p>
<p>
If you run this program, you will still get the message
"Not Visible" because <code>WM_SHOWWINDOW</code> is sent
as part of the entire window-showing process.
At the time you receive it, your window is <strong>in the
process of being show</strong> but it's not quite there yet.
The <code>WM_SHOWWINDOW</code> serves a similar purpose
to <code>WM_INITDIALOG</code>: To let you prepare the window
while it's still hidden so the user won't see ugly flashing
which would otherwise occur if you had done
your preparation after the window were visible.
</p>
<p>
Is there a message that is sent after the window has been shown?
There sure is: <code>WM_WINDOWPOSCHANGED</code>.
</p>
<pre>
INT_PTR CALLBACK
DlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uiMsg) {

  case WM_INITDIALOG:
    return TRUE;

  case WM_WINDOWPOSCHANGED:
    if ((((WINDOWPOS*)lParam)-&gt;flags &amp; SWP_SHOWWINDOW) &amp;&amp;
        !g_fShown) {
      g_fShown = TRUE;
      MessageBox(hwnd,
                 IsWindowVisible(hwnd) ? TEXT("Visible")
                                       : TEXT("Not Visible"),
                 TEXT("Title"), MB_OK);
    }
    break;

  case WM_CLOSE:
   EndDialog(hwnd, 0);
   break;
  }

  return FALSE;
}
</pre>
<p>
This time, we get the message "Visible",
because <code>WM_WINDOWPOSCHANGED</code> is sent after
the window positioning negotiations are complete.
(The "ED" at the end emphasizes that it is delivered
after the operation has been done, as opposed to the "ING"
which is delivered while the operation is in progress.)
</p>
<p>
But wait, we're not out of the woods yet.
Although it's true that the window position negotiations
are complete, the message is nevertheless sent as part
of the whole window positioning process,
and there may be other things that need to be done
as part of the whole window-showing bookkeeping.
If you show the second dialog directly in your
<code>WM_WINDOWPOSCHANGED</code> handler,
then that clean-up won't happen until after the user
exits the second dialog.
</p>
<p>
For example, the window manager notifies Active Accessibility
of the completed window positioning operation after all
the window positions have settled down.
This reduces the likelihood that the accessibility tool will be told
"Okay, the window is shown" followed by
"Oh no wait, it moved again, ha ha!"
If you display the second dialog inside your
<code>WM_WINDOWPOSCHANGED</code> handler,
the screen reader will receive a bizarro sequence of events:
</p>
<ul>
<li>Second dialog shown.
<li>(User interacts with second dialog and dismisses it.)
<li>Second dialog destroyed.
<li>(Your <code>WM_WINDOWPOSCHANGED</code> handler returns.)
<li>Main dialog shown.
</ul>
<p>
Notice that the "Main dialog shown" notification arrives out of
order because you did additional UI work before the previous operation
was complete.
</p>
<p>
As another example, the window may have been shown as part
of a multiple-window window positioning operation
such as one created by <code>DeferWindowPos</code>.
All the affected windows will get their <code>WM_WINDOWPOSCHANGED</code>
notifications one at a time,
and if your window happened to go first,
then those other windows won't know that they were repositioned
until after the user finishes with the nested dialog.
This may manifest itself in those other windows appearing to
be "stuck" since your dialog is holding up the subsequent
notifications with your nested dialog.
For example, a window might be trying to do
<strong>exactly what you're trying to do here</strong>,
but since you're holding up the remainder of the notifications,
that other window won't display its secondary dialog until
the user dismisses yours.
From the user's standpoint, that other window is "stuck"
for no apparent reason.
</p>
<p>
Therefore, we need one more tweak to our solution.
</p>
<pre>
INT_PTR CALLBACK
DlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uiMsg) {

  case WM_INITDIALOG:
    return TRUE;

  case WM_WINDOWPOSCHANGED:
    if ((((WINDOWPOS*)lParam)-&gt;flags &amp; SWP_SHOWWINDOW) &amp;&amp;
        !g_fShown) {
      g_fShown = TRUE;
      PostMessage(hwnd, WM_APP, 0, 0);
    }
    break;


  case WM_APP:
      MessageBox(hwnd,
                 IsWindowVisible(hwnd) ? TEXT("Visible")
                                       : TEXT("Not Visible"),
                 TEXT("Title"), MB_OK);
      break;

  case WM_CLOSE:
   EndDialog(hwnd, 0);
   break;
  }

  return FALSE;
}
</pre>
<p>
When we learn that the dialog is being shown for the first time,
we post a message to ourselves to display the secondary dialog
and return from the <code>WM_WINDOWPOSCHANGED</code> handler.
This allows the window positioning operation to complete.
Everybody gets their notifications, they are all on board
with the state of the windows,
and only after everything has stabilized do we display our
message box.
</p>
<p>
This is a common thread to many types of window management.
Many window messages are notifications which are delivered
<strong>while the operation is still in progress</strong>.
You do not want to display new UI while handling those
notifications because that holds up the completion of the
original UI operation that generated the notification in the
first place.
Posting a message to yourself to complete the user interaction
after the original operation has stabilized is the standard solution.</p>
<!-- CONTENT END -->
</div></td></tr></table>
<hr/>
<table class="commenttable" cellspacing="0" cellpadding="0"><tr><td><div class="commentdiv"><div class="commentdivhdr">
<!-- COMMENTS START -->
Comments (30)	</div>

	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-423793">
				<div id="div-comment-423793" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Bruce Dickinson</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423793">
			September 25, 2006 at 10:09 am</a>		</div>

		<p>Woweee wow wow wow &#8211; thats alot of cowbell!!</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-423803">
				<div id="div-comment-423803" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423803">
			September 25, 2006 at 10:23 am</a>		</div>

		<blockquote><p>
  (Subtlety: Why do I set g_fShown = TRUE before displaying the message box?)</p>
<p>Guessing here, but: &nbsp;Because during MessageBox, you may get another WM_SHOWWINDOW message? &nbsp;I&#8217;m not sure how that would work, or why it would happen, but it&#8217;s the only reason that I can come up with that makes any sense.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-423833">
				<div id="div-comment-423833" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mike Jones</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423833">
			September 25, 2006 at 11:02 am</a>		</div>

		<p>If WM_USER should not be used by -er- users could it please be renamed. &nbsp;Or a compiler warning given.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-423853">
				<div id="div-comment-423853" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">HitScan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423853">
			September 25, 2006 at 11:20 am</a>		</div>

		<p>The compiler doesn&#8217;t and shouldn&#8217;t know what various #defines are and aren&#8217;t safe to use in various situations. That&#8217;s what the API documentation is for. You can use WM_USER, just not in a dialog class. (and possibly other situations)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jamescurran even thread-even depth-1" id="comment-423863">
				<div id="div-comment-423863" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Garry Trinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423863">
			September 25, 2006 at 11:23 am</a>		</div>

		<blockquote><p>
  (Subtlety: Why do I set g_fShown = TRUE before displaying the message box?)</p>
<p>All you goota do is check the docs. &nbsp;WM_SHOWWINDOW will also be sent if the window is revealed by restoring a maximized window, and other reasons.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-jamescurran odd alt thread-odd thread-alt depth-1" id="comment-423873">
				<div id="div-comment-423873" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Garry Trinder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423873">
			September 25, 2006 at 11:25 am</a>		</div>

		<blockquote><p>
  &gt; If WM_USER should not be used by -er- users could it please be renamed.</p>
<p>It should have been given a differnet name originally, but changing it now will break existing code.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-423883">
				<div id="div-comment-423883" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Adrian</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423883">
			September 25, 2006 at 11:30 am</a>		</div>

		<p>Raymond wrote: &nbsp;&#8220;Many window messages are notifications which are delivered while the operation is still in progress.&#8221; </p>
<p>Could that explain this problem I described in your suggestion box? </p>
<p><a href="http://blogs.msdn.com/oldnewthing/articles/382765.aspx#382868" target=_new rel=nofollow rel="nofollow">http://blogs.msdn.com/oldnewthing/articles/382765.aspx#382868</a> </p>
<p>I don&#8217;t see how, since it&#8217;s a posted message. &nbsp;The symptom seems related to the issue you describe in this post, but the solution doesn&#8217;t seem to apply.</p>
<div class=post>[<i>Repeating a question just makes me less likely to answer it. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-423893">
				<div id="div-comment-423893" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Igor</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423893">
			September 25, 2006 at 11:35 am</a>		</div>

		<p>So I was the closest with WM_WINDOWPOSCHANGED. Too bad I didn&#8217;t have time yesterday night to finish, but nevertheless nice to know that I was on the right track :)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-423923">
				<div id="div-comment-423923" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DanT</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423923">
			September 25, 2006 at 11:52 am</a>		</div>

		<blockquote><p>
  (Subtlety: Why do I set g_fShown = TRUE before displaying the message box?)</p>
<p>WM_WINDOWPOSCHANGED can be reentrant while the modal dialog is up &#8211; obvious example is while the message box is up, the user hits win-d and minimizes everything. It is also sent when the z order changes, etc.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-423933">
				<div id="div-comment-423933" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">DanT</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423933">
			September 25, 2006 at 11:54 am</a>		</div>

		<p>Actually I think win-d only changes the zorder, so I meant to say win-m</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-423963">
				<div id="div-comment-423963" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Mihai</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-423963">
			September 25, 2006 at 1:46 pm</a>		</div>

		<p>A while ago I had a related problem: validating a dialog after it is done displaying.</p>
<p>This might include detecting resizing problems, double or invalid quick-keys, spell-checking, etc.</p>
<p>So all controls have to be in the final state (visible or not).</p>
<p>I have a solution, but the main problem are now tabbed dialogs.<br />
<br />How do you know when a tab change is done? Because everything is just a collection of show/hide, no clue when is over.</p>
<p>And, by the way, I am &quot;outside&quot; the application I am checking :-)<br />
<br />(using hooks)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424023">
				<div id="div-comment-424023" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.explorewindows.com' rel='external nofollow' class='url'>Vipin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424023">
			September 25, 2006 at 2:25 pm</a>		</div>

		<p>I wanted to comment on the message pump and modal dialogs, but since that may take this particular thread on a different tangent,<br />
<br />I posted that in my blog.<br />
<br />For the curious, checkout:-<br />
<br /><a rel="nofollow" target="_new" href="http://blogs.explorewindows.com" rel="nofollow">http://blogs.explorewindows.com</a><br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424033">
				<div id="div-comment-424033" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424033">
			September 25, 2006 at 2:35 pm</a>		</div>

		<p>Why did you choose a postmessage in WM_WINDOWPOSCHANGED instead of a postmessage in WM_SHOWWINDOW? &nbsp;Seems all the same thing if you&#8217;re set to use PostMessage.</p>
<p>btw, about the early dismissal of WM_PAINT&#8230; &nbsp;The &quot;window&quot; could be visible because it&#8217;s frame is painted already &#8211; that&#8217;s technically true, but it isn&#8217;t the effect I would have want for the user. &nbsp;I would have wanted him to see the dialog, not just the frame. In WM_PAINT a PostMessage would have been used because I wouldn&#8217;t have left the window hanging in the middle of its WM_PAINT</p>
<p>I did not know that WM_USER isn&#8217;t safe in dialog boxes, although I understand why, it&#8217;s totally logical. &nbsp;Still &#8230; the dialog manager should have set its private messages in the system message range. &nbsp;I grepped our few hundred thousans lines of code and while we use WM_USER a lot, luckily it isn&#8217;t in dialog boxes. &nbsp;It was usually offsetted by a large value, like WM_USER+1000. &nbsp;Thank you for reminding us of these win32 items.<br /></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424083">
				<div id="div-comment-424083" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">stefang</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424083">
			September 25, 2006 at 4:59 pm</a>		</div>

		<p>Interesting stuff. </p>
<p>I think it is quite surprising that PostMessage(WM_APP) from WM_INITDIALOG did not work. </p>
<p>As far as I understand this must mean that DialogBox contains a PeekMessage loop that drains all messages before it calls ShowWindow() and falls down to the regular message loop. </p>
<p>Of course, this also means that any controls in a dialog must be prepared to accept keyboard events even before the dialog is shown. I am sure that this surprises a lot of people. </p>
<p>I dont think I have ever seen this behavior documented anywhere before &#8211; not even in your own Dialog box series about a year ago. </p>
<div CLASS=post>[<i>I did mention that dialog boxes hold off display until all typeahead is processed, and since posted messages come before input, they have to churn through all posted messages too. I admit it wasn&#8217;t explicit, but I thought everybody knew this already. Maybe the newer Win32 programming books don&#8217;t mention it any more. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424093">
				<div id="div-comment-424093" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Ulric</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424093">
			September 25, 2006 at 5:50 pm</a>		</div>

		<p>Hum, I don&#8217;t think it&#8217;s obvious that posted messages are going to be processed before the keyboard messages already in the queue. &nbsp;As a windows programmer since 1994, I&#8217;m completely aware that mouse, and paint, messages are low priority, but that doesn&#8217;t necessarily equate to me that a posted message will be processed before already-queued keyboard input, and that furthermore this will all have to be processed before the dialog box is displayed.</p>
<div CLASS=post>[<i>This was covered as part 5 of the &#8220;Five Things Every Win32 Developer Should Know&#8221;. Posted messages and input come from different queues. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424133">
				<div id="div-comment-424133" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Miral</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424133">
			September 25, 2006 at 9:12 pm</a>		</div>

		<p>Ok, I know this isn&#8217;t really a .NET blog, but what&#8217;s the .NET equivalent of this? &nbsp;OnLoad is definitely before it&#8217;s visible, and OnVisibleChanged seems like the equivalent of WM_SHOWWINDOW.</p>
<p>Not that you can really post messages in .NET anyway. &nbsp;Maybe we&#8217;re just screwed&#8230;</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424143">
				<div id="div-comment-424143" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424143">
			September 25, 2006 at 10:42 pm</a>		</div>

		<blockquote><p>
  &gt; If WM_USER should not be used by -er- users<br />
  <br />&gt;&gt; could it please be renamed.<br />
  <br />&gt;<br />
  <br />&gt; It should have been given a differnet name<br />
  <br />&gt; originally, but changing it now will break<br />
  <br />&gt; existing code.</p>
<p>I&#8217;ll bet it would mostly break broken code. &nbsp;I recommend that users not be blamed for writing broken code based on an inference that user means user, but still it is broken code that needs fixing. &nbsp;Ulric&#8217;s later example of code that uses numbers like WM_USER+1000 is code that luckily avoided being broken yet, so yes a rename would be a breaking change for this poor victim, but I&#8217;ll bet a vastly larger number of other poor victims would suddenly be informed of what they have to fix.</p>
<p>&gt; Why did you choose a postmessage in<br />
  <br />&gt; WM_WINDOWPOSCHANGED instead of a postmessage<br />
  <br />&gt; in WM_SHOWWINDOW? &nbsp;Seems all the same thing<br />
  <br />&gt; if you&#8217;re set to use PostMessage.</p>
<p>A message posted during WM_SHOWWINDOW will be read after finishing the computations of what to show in the window but still before showing is completed. &nbsp;A message posted during WM_WINDOWPOSCHANGED will be read after showing is completed.</p>
<p>I would feel more comfortable with WM_ENTERIDLE, but Windows CE doesn&#8217;t have it.</p>
<p>&gt; Maybe the newer Win32 programming books<br />
  <br />&gt; don&#8217;t mention it any more.</p>
<p>Richter was 1999 and Petzold was 1998, right? &nbsp;Any recommendations for newer Win32 programming books?
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424183">
				<div id="div-comment-424183" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://gnobal.net/?p=346' rel='external nofollow' class='url'>Syntactically Correct - Amit Schreiber&#8217;s Blog / Writing Software - Part 2</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424183">
			September 26, 2006 at 12:40 am</a>		</div>

		<p>PingBack from <a rel="nofollow" target="_new" href="http://gnobal.net/?p=346" rel="nofollow">http://gnobal.net/?p=346</a></p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424203">
				<div id="div-comment-424203" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">josh</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424203">
			September 26, 2006 at 1:24 am</a>		</div>

		<p>Hey, I knew if I guessed enough things, at least one of them would be part of the answer. &nbsp;:)</p>
<p>So how about WM_STYLECHANGED?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424233">
				<div id="div-comment-424233" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">stefang</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424233">
			September 26, 2006 at 4:12 am</a>		</div>

		<blockquote><p>
  &gt; Why did you choose a postmessage in<br />
  <br />&gt;&gt; WM_WINDOWPOSCHANGED instead of a postmessage<br />
  <br />&gt;&gt; in WM_SHOWWINDOW? &nbsp;Seems all the same thing<br />
  <br />&gt;&gt; if you&#8217;re set to use PostMessage. </p>
<p>&gt;A message posted during WM_SHOWWINDOW will be read after finishing the computations of what to show in the window but still before showing is completed. &nbsp;A message posted during WM_WINDOWPOSCHANGED will be read after showing is completed. </p>
<p>&gt;I would feel more comfortable with WM_ENTERIDLE, but Windows CE doesn&#8217;t have it. </p>
<p>I see no reason why posting the message in WM_SHOWWINDOW should not work.</p>
<p>The code in DialogBox probably looks something like this pseudocode:</p>
<p>CreateWindow</p>
<p>SendMessage(WM_INITDIALOG)</p>
<p>// Dispatch messages until idle<br />
  <br />while PeekMessage<br />
  <br /> &nbsp; anyMessagesDispatched = true<br />
  <br /> &nbsp; DispatchMessage</p>
<p>if anyMessagesDispatched<br />
  <br /> &nbsp; SendMessage(WM_ENTERIDLE)</p>
<p>ShowWindow</p>
<p>While dialog is active<br />
  <br /> &nbsp; GetMessage<br />
  <br /> &nbsp; DispatchMessage</p>
<p>Note that both WM_SHOWWINDOW and WM_WINDOWPOSCHANGED are sent from inside the ShowWindow call, so the effect of posting a message from either event should be the same.</p>
<p>WM_ENTERIDLE is sent to the owner of the newly created dialogbox &#8211; not to the dialog box itself. The documentation also suggests that WM_ENTERIDLE is only sent if the peekmessage loop found any messages to dispatch.<br />
  <br />Unfortunately, the docuemntation for WM_ENTERIDLE does not specify if it is sent before or after ShowWindow()</p>
<p>Raymond, does my pseudocode look accurate to you ?</p>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424163">
				<div id="div-comment-424163" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424163">
			September 25, 2006 at 10:56 pm</a>		</div>

		<p>Sorry for a second message box in a row, but I just noticed some source code that would benefit from editing, in winuser.h:</p>
<p>#define WM_APP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x8000</p>
<p>/*<br />
<br /> * NOTE: All Message Numbers below 0x0400 are RESERVED.<br />
<br /> *<br />
<br /> * Private Window Messages Start Here:<br />
<br /> */<br />
<br />#define WM_USER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0400</p>
<p>May I recommend:</p>
<p>#define WM_USER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0400</p>
<p>/*<br />
<br /> * NOTE: All Message Numbers below 0x0800 are RESERVED.<br />
<br /> *<br />
<br /> * Private Window Messages Start Here:<br />
<br /> */<br />
<br />#define WM_APP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x8000</p>
<div CLASS=post>[<i>The new comment is misleading. Messages between 0x400 and 0x8000 are available for use by the class implementor; they aren&#8217;t reserved by the system. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424173">
				<div id="div-comment-424173" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Norman Diamond</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424173">
			September 25, 2006 at 11:38 pm</a>		</div>

		<p>&gt; Messages between 0x400 and 0x8000 are<br />
<br />&gt; available for use by the class implementor;<br />
<br />&gt; they aren&#8217;t reserved by the system.</p>
<p>OK, I got it. &nbsp;Hmm, I misedited my previous message, changing 0x0400 to 0x0800 which should have been 0x8000, but your response still addressed it correctly and I understand.</p>
<p>I retract my previous statement &#8220;but I&#8217;ll bet a vastly larger number of other poor victims would suddenly be informed of what they have to fix&#8221;. &nbsp;The number of users who validly used the WM_USER range in private classes might be larger than the number of users who luckily happened to avoid conflicts with the use of the WM_USER range in dialog boxes, windows that contain standard controls, etc.</p>
<p>I still think it would be helpful to add a comment though:</p>
<p>* Message numbers in the range 0x0400 to 0x8000<br />
<br />* can be used in private window classes, but<br />
<br />* should be treated as reserved when using<br />
<br />* dialog boxes or standard Windows controls.</p>
<div CLASS=post>[<i>But that&#8217;s just a specific version of the more general statement that messages in the 0x0400 to 0x7FFF range belong to the window class, whether that window class be the dialog box class, a standard Windows control, or a custom control you bought from another company. At any rate, comments in header files are really a bad place for discussion. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-mike-dimmick even thread-even depth-1" id="comment-424273">
				<div id="div-comment-424273" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='https://social.msdn.microsoft.com/profile/Mike+Dimmick' rel='external nofollow' class='url'>Mike Dimmick</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424273">
			September 26, 2006 at 7:34 am</a>		</div>

		<p>Norman: there really aren&#8217;t any newer Windows programming books.</p>
<p>It would help a lot if Richter&#8217;s books weren&#8217;t out of print! &quot;Programming Applications for Windows&quot; is currently selling for between $125 and $200 on Amazon Marketplace.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424283">
				<div id="div-comment-424283" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424283">
			September 26, 2006 at 8:12 am</a>		</div>

		<p>Miral &#8212; In the non-compact framework, you can override your form&#8217;s WndProc to get at both WM_WINDOWPOSCHANGED and WM_APP. &nbsp;Between that and p/invoke with PostMessage, you can do everything required.</p>
<p>Yes, it&#8217;s a pain, but it should work.</p>
<p>(Although I doubt that dialog boxes in .net are really dialog-box-class windows. &nbsp;Maybe that doesn&#8217;t matter though.)</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424343">
				<div id="div-comment-424343" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Threadder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424343">
			September 26, 2006 at 12:26 pm</a>		</div>

		<blockquote><p>
  Posting a message to yourself to complete the user interaction after the original operation has stabilized is the standard solution.</p>
<p>Why should an app interact with the window system to be able to send a message to itself? As you shown, it&#8217;s clearly a source of errors.</p>
<div CLASS=post>[<i>I don&#8217;t understand the question. To send a window message you have to use the window system. That&#8217;s just a tautology. -Raymond</i>]</div>
<p>&gt; If WM_USER should not be used by -er- users could it please be renamed. &nbsp;Or a compiler warning given. </p>
<p>And thats why you should use threading instead of message passing.
</p></blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424363">
				<div id="div-comment-424363" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">David Walker</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424363">
			September 26, 2006 at 12:51 pm</a>		</div>

		<p>Um, from a naive standpoint, what is it about the underlying tools available to the programmer that makes all of this so complicated? &nbsp;</p>
<p>Would better or differently architected &nbsp;tools (APIs) in the OS make the job easier to understand, easier to implement, clearer, and harder to mess up?</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424383">
				<div id="div-comment-424383" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn"><a href='http://blogs.explorewindows.com' rel='external nofollow' class='url'>Vipin</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424383">
			September 26, 2006 at 1:37 pm</a>		</div>

		<p>Mike,<br />
<br /> &nbsp; &nbsp; I have a copy of &quot;Programming Applications for Windows&quot;.Its mainly meant to get an understanding of the operating system from a application programmer(win32) perspective. Nice book to have on the shelf. You won&#8217;t get to read much on GUI(user32/gdi) in that book.</p>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424403">
				<div id="div-comment-424403" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424403">
			September 26, 2006 at 2:10 pm</a>		</div>

		<blockquote><p>
  Um, from a naive standpoint, what is it about the underlying tools available to the programmer that makes all of this so complicated? </p>
<p>It&#8217;s two things. &nbsp;First, people want to do some action after their window is shown. &nbsp;Second, there is no &#8220;your window has completed showing itself&#8221; message sent by the system.</p>
<div CLASS=post>[<i>Um, WM_WINDOWPOSCHANGED is the message that says &#8220;Here&#8217;s what happened (past tense) to your window. It&#8217;s all over. Now I&#8217;m just telling everybody about it..&#8221; -Raymond</i>]</div>
</blockquote>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-424433">
				<div id="div-comment-424433" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">Threadder</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424433">
			September 26, 2006 at 3:43 pm</a>		</div>

		<p>[I don&#8217;t understand the question. To send a window message you have to use the window system. That&#8217;s just a tautology. -Raymond]</p>
<p>Any message doesn&#8217;t necessary have to be a window message. An app could (on appropritate event &#8211; WM_WINDOWPOSCHANGED) send an internally &#8220;syncronisation message&#8221; to another thread that shows the second dialog window.</p>
<div CLASS=post>[<i>Then I guess I don&#8217;t understand the question. You asked, &#8220;Why should an app interact with the window system to be able to send a message to itself?&#8221; and then here you gave an example of not doing it. Oh, I see, the &#8220;should&#8221; here was not in the sense of &#8220;Why am I forced to do it this way&#8221; but rather &#8220;Why are you recommending it?&#8221; Well, for one thing, cross-thread UI is extremely difficult to get right. -Raymond</i>]</div>

		
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-424683">
				<div id="div-comment-424683" class="comment-body">
				<div class="comment-author vcard">
						<cite class="fn">BryanK</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20060925-02/?p=29603#comment-424683">
			September 27, 2006 at 10:27 am</a>		</div>

		<p>&gt; [Um, WM_WINDOWPOSCHANGED is the message that says &quot;Here&#8217;s what happened (past tense) to your window. It&#8217;s all over. Now I&#8217;m just telling everybody about it..&quot; -Raymond]</p>
<p>Right. &nbsp;I guess I meant that the name of the message constant doesn&#8217;t make it very obvious that it&#8217;s what you should use to trigger stuff that needs to happen after the window is shown.</p>
<p>The docs for WM_WINDOWPOSCHANGED don&#8217;t really (explicitly) mention this, either. &nbsp;That&#8217;s why I&#8217;m not all that surprised that people can&#8217;t find the appropriate message to trigger &quot;after-window-show&quot; behavior from. &nbsp;They search MSDN for some string they think is appropriate, and nothing comes back.</p>
<p>Now, I&#8217;m not sure the docs can even be changed. &nbsp;Certainly it&#8217;d be a bad idea to try to explicitly document the state of the window in each message (it would help, but it would be a *huge* undertaking). &nbsp;Perhaps a new message &#8212; WM_WINDOWSHOWN or something &#8212; would help make it obvious what to watch for, but that would probably require a new version of Windows (i.e., it likely won&#8217;t be added to Vista, let alone XP or 2K).</p>
<p>Yes, WM_WINDOWPOSCHANGED is equivalent to this WM_WINDOWSHOWN (as far as the window&#8217;s state is concerned), and I know that now. &nbsp;But if I didn&#8217;t know that, I&#8217;d have no idea what message to use.</p>

		
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
			<p class="no-comments">Comments are closed.</p>
<!-- COMMENTS END -->
</div></td></tr></table>

</body>
</html>
<br/><div class="disclaimer">
*DISCLAIMER: I DO NOT OWN THIS CONTENT. If you are the owner and would like it removed, please
<a target="_blank" href="/contact.htm">contact me</a>.
The content herein is an archived reproduction of entries from
Raymond Chen's "Old New Thing" Blog (most recent link is <a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/">here</a>).
It may have slight formatting modifications for consistency and to improve readability.
<br/><br/>
WHY DID I DUPLICATE THIS CONTENT HERE?
Let me first say this site has never had anything to sell and has never shown ads of any kind. I have nothing monetarily to gain by duplicating content here.
Because I had made my own local copy of this content throughout the years, for ease of using tools like grep, I decided to put it online after I discovered
some of the original content previously and publicly available, had disappeared approximately early to mid 2019.
At the same time, I present the content in an easily accessible theme-agnostic way.
<br/><br/>
The information provided by Raymond's blog is, for all practical purposes, more authoritative on Windows Development than Microsoft's
own MSDN documentation and should be considered supplemental reading to that documentation. The wealth of missing details
provided by this blog that Microsoft could not or did not document about Windows over the years is vital enough, many would agree an online "backup" of these details
is a necessary endeavor. Specifics include:<br/>
<ul>
    <li>
        A "redesign" after 2019 erased thousands of user's comments from previous years. As many have stated, the comments are nearly as important as the postings themselves.
        The archived copies of the postings contained here retain the original comments.
    </li>
    <li>
        The blog has changed domains many times and the urls have otherwise been under constant change since 2003.
        Even when proper redirection has been set up for those links, redirection only works for a limited period of time.
        For example, all of the internal blog links that were valid in early 2019, were broken by 2020 without proper redirection.
    </li>
    <li>
        The blog has been under constant re-design and re-theming since its inception.
        It is downright irritating to deal with a bogged-down site experience as the result of the latest visual themes designed for cell-phone browsers.
        As of this writing, it is cumbersome to navigate titles with only 10 entries per page.
        While it is nice that the official site has a search feature, searching using this index (with all titles on a single page) is much quicker (CTRL-F in most browsers).
    </li>
</ul>
</div><br/>
&lt;-- Back to <a href="index.htm">Old New Thing Archive Index</a>

